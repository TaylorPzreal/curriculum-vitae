{"source":"webpackJsonp([2],{1254:function(module,exports,__webpack_require__){\neval(\"var THREE = __webpack_require__(194)\\n\\n/**\\n * @author qiao / https://github.com/qiao\\n * @author mrdoob / http://mrdoob.com\\n * @author alteredq / http://alteredqualia.com/\\n * @author WestLangley / http://github.com/WestLangley\\n * @author erich666 / http://erichaines.com\\n */\\n\\n// This set of controls performs orbiting, dollying (zooming), and panning.\\n// Unlike TrackballControls, it maintains the \\\"up\\\" direction object.up (+Y by default).\\n//\\n//    Orbit - left mouse / touch: one finger move\\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\\n//    Pan - right mouse, or arrow keys / touch: three finger swipe\\n\\nfunction OrbitControls ( object, domElement ) {\\n\\n\\tthis.object = object;\\n\\n\\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\\n\\n\\t// Set to false to disable this control\\n\\tthis.enabled = true;\\n\\n\\t// \\\"target\\\" sets the location of focus, where the object orbits around\\n\\tthis.target = new THREE.Vector3();\\n\\n\\t// How far you can dolly in and out ( PerspectiveCamera only )\\n\\tthis.minDistance = 0;\\n\\tthis.maxDistance = Infinity;\\n\\n\\t// How far you can zoom in and out ( OrthographicCamera only )\\n\\tthis.minZoom = 0;\\n\\tthis.maxZoom = Infinity;\\n\\n\\t// How far you can orbit vertically, upper and lower limits.\\n\\t// Range is 0 to Math.PI radians.\\n\\tthis.minPolarAngle = 0; // radians\\n\\tthis.maxPolarAngle = Math.PI; // radians\\n\\n\\t// How far you can orbit horizontally, upper and lower limits.\\n\\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\\n\\tthis.minAzimuthAngle = - Infinity; // radians\\n\\tthis.maxAzimuthAngle = Infinity; // radians\\n\\n\\t// Set to true to enable damping (inertia)\\n\\t// If damping is enabled, you must call controls.update() in your animation loop\\n\\tthis.enableDamping = false;\\n\\tthis.dampingFactor = 0.25;\\n\\n\\t// This option actually enables dollying in and out; left as \\\"zoom\\\" for backwards compatibility.\\n\\t// Set to false to disable zooming\\n\\tthis.enableZoom = true;\\n\\tthis.zoomSpeed = 1.0;\\n\\n\\t// Set to false to disable rotating\\n\\tthis.enableRotate = true;\\n\\tthis.rotateSpeed = 1.0;\\n\\n\\t// Set to false to disable panning\\n\\tthis.enablePan = true;\\n\\tthis.keyPanSpeed = 7.0;\\t// pixels moved per arrow key push\\n\\n\\t// Set to true to automatically rotate around the target\\n\\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\\n\\tthis.autoRotate = false;\\n\\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\\n\\n\\t// Set to false to disable use of the keys\\n\\tthis.enableKeys = true;\\n\\n\\t// The four arrow keys\\n\\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\\n\\n\\t// Mouse buttons\\n\\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\\n\\n\\t// for reset\\n\\tthis.target0 = this.target.clone();\\n\\tthis.position0 = this.object.position.clone();\\n\\tthis.zoom0 = this.object.zoom;\\n\\n\\t//\\n\\t// public methods\\n\\t//\\n\\n\\tthis.getPolarAngle = function () {\\n\\n\\t\\treturn spherical.phi;\\n\\n\\t};\\n\\n\\tthis.getAzimuthalAngle = function () {\\n\\n\\t\\treturn spherical.theta;\\n\\n\\t};\\n\\n\\tthis.saveState = function () {\\n\\n\\t\\tscope.target0.copy( scope.target );\\n\\t\\tscope.position0.copy( scope.object.position );\\n\\t\\tscope.zoom0 = scope.object.zoom;\\n\\n\\t};\\n\\n\\tthis.reset = function () {\\n\\n\\t\\tscope.target.copy( scope.target0 );\\n\\t\\tscope.object.position.copy( scope.position0 );\\n\\t\\tscope.object.zoom = scope.zoom0;\\n\\n\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\tscope.update();\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t};\\n\\n\\t// this method is exposed, but perhaps it would be better if we can make it private...\\n\\tthis.update = function () {\\n\\n\\t\\tvar offset = new THREE.Vector3();\\n\\n\\t\\t// so camera.up is the orbit axis\\n\\t\\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\\n\\t\\tvar quatInverse = quat.clone().inverse();\\n\\n\\t\\tvar lastPosition = new THREE.Vector3();\\n\\t\\tvar lastQuaternion = new THREE.Quaternion();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tvar position = scope.object.position;\\n\\n\\t\\t\\toffset.copy( position ).sub( scope.target );\\n\\n\\t\\t\\t// rotate offset to \\\"y-axis-is-up\\\" space\\n\\t\\t\\toffset.applyQuaternion( quat );\\n\\n\\t\\t\\t// angle from z-axis around y-axis\\n\\t\\t\\tspherical.setFromVector3( offset );\\n\\n\\t\\t\\tif ( scope.autoRotate && state === STATE.NONE ) {\\n\\n\\t\\t\\t\\trotateLeft( getAutoRotationAngle() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tspherical.theta += sphericalDelta.theta;\\n\\t\\t\\tspherical.phi += sphericalDelta.phi;\\n\\n\\t\\t\\t// restrict theta to be between desired limits\\n\\t\\t\\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\\n\\n\\t\\t\\t// restrict phi to be between desired limits\\n\\t\\t\\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\\n\\n\\t\\t\\tspherical.makeSafe();\\n\\n\\n\\t\\t\\tspherical.radius *= scale;\\n\\n\\t\\t\\t// restrict radius to be between desired limits\\n\\t\\t\\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\\n\\n\\t\\t\\t// move target to panned location\\n\\t\\t\\tscope.target.add( panOffset );\\n\\n\\t\\t\\toffset.setFromSpherical( spherical );\\n\\n\\t\\t\\t// rotate offset back to \\\"camera-up-vector-is-up\\\" space\\n\\t\\t\\toffset.applyQuaternion( quatInverse );\\n\\n\\t\\t\\tposition.copy( scope.target ).add( offset );\\n\\n\\t\\t\\tscope.object.lookAt( scope.target );\\n\\n\\t\\t\\tif ( scope.enableDamping === true ) {\\n\\n\\t\\t\\t\\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\\n\\t\\t\\t\\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tsphericalDelta.set( 0, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscale = 1;\\n\\t\\t\\tpanOffset.set( 0, 0, 0 );\\n\\n\\t\\t\\t// update condition is:\\n\\t\\t\\t// min(camera displacement, camera rotation in radians)^2 > EPS\\n\\t\\t\\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\\n\\n\\t\\t\\tif ( zoomChanged ||\\n\\t\\t\\t\\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\\n\\t\\t\\t\\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\\n\\n\\t\\t\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\t\\t\\tlastPosition.copy( scope.object.position );\\n\\t\\t\\t\\tlastQuaternion.copy( scope.object.quaternion );\\n\\t\\t\\t\\tzoomChanged = false;\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tthis.dispose = function () {\\n\\n\\t\\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\\n\\t\\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\\n\\t\\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\\n\\n\\t\\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\\n\\t\\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\\n\\t\\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\\n\\n\\t\\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\\n\\n\\t\\twindow.removeEventListener( 'keydown', onKeyDown, false );\\n\\n\\t\\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\\n\\n\\t};\\n\\n\\t//\\n\\t// internals\\n\\t//\\n\\n\\tvar scope = this;\\n\\n\\tvar changeEvent = { type: 'change' };\\n\\tvar startEvent = { type: 'start' };\\n\\tvar endEvent = { type: 'end' };\\n\\n\\tvar STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\\n\\n\\tvar state = STATE.NONE;\\n\\n\\tvar EPS = 0.000001;\\n\\n\\t// current position in spherical coordinates\\n\\tvar spherical = new THREE.Spherical();\\n\\tvar sphericalDelta = new THREE.Spherical();\\n\\n\\tvar scale = 1;\\n\\tvar panOffset = new THREE.Vector3();\\n\\tvar zoomChanged = false;\\n\\n\\tvar rotateStart = new THREE.Vector2();\\n\\tvar rotateEnd = new THREE.Vector2();\\n\\tvar rotateDelta = new THREE.Vector2();\\n\\n\\tvar panStart = new THREE.Vector2();\\n\\tvar panEnd = new THREE.Vector2();\\n\\tvar panDelta = new THREE.Vector2();\\n\\n\\tvar dollyStart = new THREE.Vector2();\\n\\tvar dollyEnd = new THREE.Vector2();\\n\\tvar dollyDelta = new THREE.Vector2();\\n\\n\\tfunction getAutoRotationAngle() {\\n\\n\\t\\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\\n\\n\\t}\\n\\n\\tfunction getZoomScale() {\\n\\n\\t\\treturn Math.pow( 0.95, scope.zoomSpeed );\\n\\n\\t}\\n\\n\\tfunction rotateLeft( angle ) {\\n\\n\\t\\tsphericalDelta.theta -= angle;\\n\\n\\t}\\n\\n\\tfunction rotateUp( angle ) {\\n\\n\\t\\tsphericalDelta.phi -= angle;\\n\\n\\t}\\n\\n\\tvar panLeft = function () {\\n\\n\\t\\tvar v = new THREE.Vector3();\\n\\n\\t\\treturn function panLeft( distance, objectMatrix ) {\\n\\n\\t\\t\\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\\n\\t\\t\\tv.multiplyScalar( - distance );\\n\\n\\t\\t\\tpanOffset.add( v );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tvar panUp = function () {\\n\\n\\t\\tvar v = new THREE.Vector3();\\n\\n\\t\\treturn function panUp( distance, objectMatrix ) {\\n\\n\\t\\t\\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\\n\\t\\t\\tv.multiplyScalar( distance );\\n\\n\\t\\t\\tpanOffset.add( v );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t// deltaX and deltaY are in pixels; right and down are positive\\n\\tvar pan = function () {\\n\\n\\t\\tvar offset = new THREE.Vector3();\\n\\n\\t\\treturn function pan( deltaX, deltaY ) {\\n\\n\\t\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t\\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\\n\\n\\t\\t\\t\\t// perspective\\n\\t\\t\\t\\tvar position = scope.object.position;\\n\\t\\t\\t\\toffset.copy( position ).sub( scope.target );\\n\\t\\t\\t\\tvar targetDistance = offset.length();\\n\\n\\t\\t\\t\\t// half of the fov is center to top of screen\\n\\t\\t\\t\\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\\n\\n\\t\\t\\t\\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\\n\\t\\t\\t\\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\\n\\t\\t\\t\\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\\n\\n\\t\\t\\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\\n\\n\\t\\t\\t\\t// orthographic\\n\\t\\t\\t\\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\\n\\t\\t\\t\\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// camera neither orthographic nor perspective\\n\\t\\t\\t\\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\\n\\t\\t\\t\\tscope.enablePan = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tfunction dollyIn( dollyScale ) {\\n\\n\\t\\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\\n\\n\\t\\t\\tscale /= dollyScale;\\n\\n\\t\\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\\n\\n\\t\\t\\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\\n\\t\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\t\\tzoomChanged = true;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\\n\\t\\t\\tscope.enableZoom = false;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction dollyOut( dollyScale ) {\\n\\n\\t\\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\\n\\n\\t\\t\\tscale *= dollyScale;\\n\\n\\t\\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\\n\\n\\t\\t\\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\\n\\t\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\t\\tzoomChanged = true;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\\n\\t\\t\\tscope.enableZoom = false;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t//\\n\\t// event callbacks - update the object state\\n\\t//\\n\\n\\tfunction handleMouseDownRotate( event ) {\\n\\n\\t\\t//console.log( 'handleMouseDownRotate' );\\n\\n\\t\\trotateStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseDownDolly( event ) {\\n\\n\\t\\t//console.log( 'handleMouseDownDolly' );\\n\\n\\t\\tdollyStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseDownPan( event ) {\\n\\n\\t\\t//console.log( 'handleMouseDownPan' );\\n\\n\\t\\tpanStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseMoveRotate( event ) {\\n\\n\\t\\t//console.log( 'handleMouseMoveRotate' );\\n\\n\\t\\trotateEnd.set( event.clientX, event.clientY );\\n\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\n\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseMoveDolly( event ) {\\n\\n\\t\\t//console.log( 'handleMouseMoveDolly' );\\n\\n\\t\\tdollyEnd.set( event.clientX, event.clientY );\\n\\n\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t} else if ( dollyDelta.y < 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseMovePan( event ) {\\n\\n\\t\\t//console.log( 'handleMouseMovePan' );\\n\\n\\t\\tpanEnd.set( event.clientX, event.clientY );\\n\\n\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\n\\t\\tpan( panDelta.x, panDelta.y );\\n\\n\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseUp( event ) {\\n\\n\\t\\t// console.log( 'handleMouseUp' );\\n\\n\\t}\\n\\n\\tfunction handleMouseWheel( event ) {\\n\\n\\t\\t// console.log( 'handleMouseWheel' );\\n\\n\\t\\tif ( event.deltaY < 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t} else if ( event.deltaY > 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleKeyDown( event ) {\\n\\n\\t\\t//console.log( 'handleKeyDown' );\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\n\\t\\t\\tcase scope.keys.UP:\\n\\t\\t\\t\\tpan( 0, scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.BOTTOM:\\n\\t\\t\\t\\tpan( 0, - scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.LEFT:\\n\\t\\t\\t\\tpan( scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.RIGHT:\\n\\t\\t\\t\\tpan( - scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction handleTouchStartRotate( event ) {\\n\\n\\t\\t//console.log( 'handleTouchStartRotate' );\\n\\n\\t\\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t}\\n\\n\\tfunction handleTouchStartDolly( event ) {\\n\\n\\t\\t//console.log( 'handleTouchStartDolly' );\\n\\n\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\n\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\tdollyStart.set( 0, distance );\\n\\n\\t}\\n\\n\\tfunction handleTouchStartPan( event ) {\\n\\n\\t\\t//console.log( 'handleTouchStartPan' );\\n\\n\\t\\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t}\\n\\n\\tfunction handleTouchMoveRotate( event ) {\\n\\n\\t\\t//console.log( 'handleTouchMoveRotate' );\\n\\n\\t\\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\n\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchMoveDolly( event ) {\\n\\n\\t\\t//console.log( 'handleTouchMoveDolly' );\\n\\n\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\n\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\tdollyEnd.set( 0, distance );\\n\\n\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t} else if ( dollyDelta.y < 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchMovePan( event ) {\\n\\n\\t\\t//console.log( 'handleTouchMovePan' );\\n\\n\\t\\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\n\\t\\tpan( panDelta.x, panDelta.y );\\n\\n\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchEnd( event ) {\\n\\n\\t\\t//console.log( 'handleTouchEnd' );\\n\\n\\t}\\n\\n\\t//\\n\\t// event handlers - FSM: listen for events and reset state\\n\\t//\\n\\n\\tfunction onMouseDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tswitch ( event.button ) {\\n\\n\\t\\t\\tcase scope.mouseButtons.ORBIT:\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownRotate( event );\\n\\n\\t\\t\\t\\tstate = STATE.ROTATE;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.mouseButtons.ZOOM:\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownDolly( event );\\n\\n\\t\\t\\t\\tstate = STATE.DOLLY;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.mouseButtons.PAN:\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownPan( event );\\n\\n\\t\\t\\t\\tstate = STATE.PAN;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t\\tif ( state !== STATE.NONE ) {\\n\\n\\t\\t\\tdocument.addEventListener( 'mousemove', onMouseMove, false );\\n\\t\\t\\tdocument.addEventListener( 'mouseup', onMouseUp, false );\\n\\n\\t\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onMouseMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tswitch ( state ) {\\n\\n\\t\\t\\tcase STATE.ROTATE:\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMoveRotate( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase STATE.DOLLY:\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMoveDolly( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase STATE.PAN:\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMovePan( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onMouseUp( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\thandleMouseUp( event );\\n\\n\\t\\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\\n\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onMouseWheel( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\thandleMouseWheel( event );\\n\\n\\t\\tscope.dispatchEvent( startEvent ); // not sure why these are here...\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t}\\n\\n\\tfunction onKeyDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\\n\\n\\t\\thandleKeyDown( event );\\n\\n\\t}\\n\\n\\tfunction onTouchStart( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\t// one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartRotate( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_ROTATE;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\t// two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartDolly( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_DOLLY;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartPan( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_PAN;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t\\tif ( state !== STATE.NONE ) {\\n\\n\\t\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onTouchMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1: // one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMoveRotate( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2: // two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMoveDolly( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMovePan( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onTouchEnd( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\thandleTouchEnd( event );\\n\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onContextMenu( event ) {\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t}\\n\\n\\t//\\n\\n\\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\\n\\n\\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\\n\\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\\n\\n\\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\\n\\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\\n\\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\\n\\n\\twindow.addEventListener( 'keydown', onKeyDown, false );\\n\\n\\t// force an update at start\\n\\n\\tthis.update();\\n\\n};\\n\\nOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\\nOrbitControls.prototype.constructor = OrbitControls;\\n\\nObject.defineProperties( OrbitControls.prototype, {\\n\\n\\tcenter: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\\n\\t\\t\\treturn this.target;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// backward compatibility\\n\\n\\tnoZoom: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\\n\\t\\t\\treturn ! this.enableZoom;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\\n\\t\\t\\tthis.enableZoom = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoRotate: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\\n\\t\\t\\treturn ! this.enableRotate;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\\n\\t\\t\\tthis.enableRotate = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoPan: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\\n\\t\\t\\treturn ! this.enablePan;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\\n\\t\\t\\tthis.enablePan = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoKeys: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\\n\\t\\t\\treturn ! this.enableKeys;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\\n\\t\\t\\tthis.enableKeys = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tstaticMoving: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\\n\\t\\t\\treturn ! this.enableDamping;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\\n\\t\\t\\tthis.enableDamping = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tdynamicDampingFactor: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\\n\\t\\t\\treturn this.dampingFactor;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\\n\\t\\t\\tthis.dampingFactor = value;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n} );\\n\\nmodule.exports = OrbitControls\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vdGhyZWUtb3JiaXRjb250cm9scy9PcmJpdENvbnRyb2xzLmpzPzlhMmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKVxuXG4vKipcbiAqIEBhdXRob3IgcWlhbyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGVyaWNoNjY2IC8gaHR0cDovL2VyaWNoYWluZXMuY29tXG4gKi9cblxuLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuXG4vLyBVbmxpa2UgVHJhY2tiYWxsQ29udHJvbHMsIGl0IG1haW50YWlucyB0aGUgXCJ1cFwiIGRpcmVjdGlvbiBvYmplY3QudXAgKCtZIGJ5IGRlZmF1bHQpLlxuLy9cbi8vICAgIE9yYml0IC0gbGVmdCBtb3VzZSAvIHRvdWNoOiBvbmUgZmluZ2VyIG1vdmVcbi8vICAgIFpvb20gLSBtaWRkbGUgbW91c2UsIG9yIG1vdXNld2hlZWwgLyB0b3VjaDogdHdvIGZpbmdlciBzcHJlYWQgb3Igc3F1aXNoXG4vLyAgICBQYW4gLSByaWdodCBtb3VzZSwgb3IgYXJyb3cga2V5cyAvIHRvdWNoOiB0aHJlZSBmaW5nZXIgc3dpcGVcblxuZnVuY3Rpb24gT3JiaXRDb250cm9scyAoIG9iamVjdCwgZG9tRWxlbWVudCApIHtcblxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHR0aGlzLmRvbUVsZW1lbnQgPSAoIGRvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCApID8gZG9tRWxlbWVudCA6IGRvY3VtZW50O1xuXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBvYmplY3Qgb3JiaXRzIGFyb3VuZFxuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0Ly8gSG93IGZhciB5b3UgY2FuIGRvbGx5IGluIGFuZCBvdXQgKCBQZXJzcGVjdGl2ZUNhbWVyYSBvbmx5IClcblx0dGhpcy5taW5EaXN0YW5jZSA9IDA7XG5cdHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcblxuXHQvLyBIb3cgZmFyIHlvdSBjYW4gem9vbSBpbiBhbmQgb3V0ICggT3J0aG9ncmFwaGljQ2FtZXJhIG9ubHkgKVxuXHR0aGlzLm1pblpvb20gPSAwO1xuXHR0aGlzLm1heFpvb20gPSBJbmZpbml0eTtcblxuXHQvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgdmVydGljYWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cblx0Ly8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXG5cdHRoaXMubWluUG9sYXJBbmdsZSA9IDA7IC8vIHJhZGlhbnNcblx0dGhpcy5tYXhQb2xhckFuZ2xlID0gTWF0aC5QSTsgLy8gcmFkaWFuc1xuXG5cdC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCBob3Jpem9udGFsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG5cdC8vIElmIHNldCwgbXVzdCBiZSBhIHN1Yi1pbnRlcnZhbCBvZiB0aGUgaW50ZXJ2YWwgWyAtIE1hdGguUEksIE1hdGguUEkgXS5cblx0dGhpcy5taW5BemltdXRoQW5nbGUgPSAtIEluZmluaXR5OyAvLyByYWRpYW5zXG5cdHRoaXMubWF4QXppbXV0aEFuZ2xlID0gSW5maW5pdHk7IC8vIHJhZGlhbnNcblxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgZGFtcGluZyAoaW5lcnRpYSlcblx0Ly8gSWYgZGFtcGluZyBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3Bcblx0dGhpcy5lbmFibGVEYW1waW5nID0gZmFsc2U7XG5cdHRoaXMuZGFtcGluZ0ZhY3RvciA9IDAuMjU7XG5cblx0Ly8gVGhpcyBvcHRpb24gYWN0dWFsbHkgZW5hYmxlcyBkb2xseWluZyBpbiBhbmQgb3V0OyBsZWZ0IGFzIFwiem9vbVwiIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZ1xuXHR0aGlzLmVuYWJsZVpvb20gPSB0cnVlO1xuXHR0aGlzLnpvb21TcGVlZCA9IDEuMDtcblxuXHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSByb3RhdGluZ1xuXHR0aGlzLmVuYWJsZVJvdGF0ZSA9IHRydWU7XG5cdHRoaXMucm90YXRlU3BlZWQgPSAxLjA7XG5cblx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcGFubmluZ1xuXHR0aGlzLmVuYWJsZVBhbiA9IHRydWU7XG5cdHRoaXMua2V5UGFuU3BlZWQgPSA3LjA7XHQvLyBwaXhlbHMgbW92ZWQgcGVyIGFycm93IGtleSBwdXNoXG5cblx0Ly8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcblx0Ly8gSWYgYXV0by1yb3RhdGUgaXMgZW5hYmxlZCwgeW91IG11c3QgY2FsbCBjb250cm9scy51cGRhdGUoKSBpbiB5b3VyIGFuaW1hdGlvbiBsb29wXG5cdHRoaXMuYXV0b1JvdGF0ZSA9IGZhbHNlO1xuXHR0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgcm91bmQgd2hlbiBmcHMgaXMgNjBcblxuXHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB1c2Ugb2YgdGhlIGtleXNcblx0dGhpcy5lbmFibGVLZXlzID0gdHJ1ZTtcblxuXHQvLyBUaGUgZm91ciBhcnJvdyBrZXlzXG5cdHRoaXMua2V5cyA9IHsgTEVGVDogMzcsIFVQOiAzOCwgUklHSFQ6IDM5LCBCT1RUT006IDQwIH07XG5cblx0Ly8gTW91c2UgYnV0dG9uc1xuXHR0aGlzLm1vdXNlQnV0dG9ucyA9IHsgT1JCSVQ6IFRIUkVFLk1PVVNFLkxFRlQsIFpPT006IFRIUkVFLk1PVVNFLk1JRERMRSwgUEFOOiBUSFJFRS5NT1VTRS5SSUdIVCB9O1xuXG5cdC8vIGZvciByZXNldFxuXHR0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXHR0aGlzLnBvc2l0aW9uMCA9IHRoaXMub2JqZWN0LnBvc2l0aW9uLmNsb25lKCk7XG5cdHRoaXMuem9vbTAgPSB0aGlzLm9iamVjdC56b29tO1xuXG5cdC8vXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdC8vXG5cblx0dGhpcy5nZXRQb2xhckFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHNwaGVyaWNhbC5waGk7XG5cblx0fTtcblxuXHR0aGlzLmdldEF6aW11dGhhbEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHNwaGVyaWNhbC50aGV0YTtcblxuXHR9O1xuXG5cdHRoaXMuc2F2ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0c2NvcGUudGFyZ2V0MC5jb3B5KCBzY29wZS50YXJnZXQgKTtcblx0XHRzY29wZS5wb3NpdGlvbjAuY29weSggc2NvcGUub2JqZWN0LnBvc2l0aW9uICk7XG5cdFx0c2NvcGUuem9vbTAgPSBzY29wZS5vYmplY3Quem9vbTtcblxuXHR9O1xuXG5cdHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRzY29wZS50YXJnZXQuY29weSggc2NvcGUudGFyZ2V0MCApO1xuXHRcdHNjb3BlLm9iamVjdC5wb3NpdGlvbi5jb3B5KCBzY29wZS5wb3NpdGlvbjAgKTtcblx0XHRzY29wZS5vYmplY3Quem9vbSA9IHNjb3BlLnpvb20wO1xuXG5cdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBjaGFuZ2VFdmVudCApO1xuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0fTtcblxuXHQvLyB0aGlzIG1ldGhvZCBpcyBleHBvc2VkLCBidXQgcGVyaGFwcyBpdCB3b3VsZCBiZSBiZXR0ZXIgaWYgd2UgY2FuIG1ha2UgaXQgcHJpdmF0ZS4uLlxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBvZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0Ly8gc28gY2FtZXJhLnVwIGlzIHRoZSBvcmJpdCBheGlzXG5cdFx0dmFyIHF1YXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLnNldEZyb21Vbml0VmVjdG9ycyggb2JqZWN0LnVwLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XG5cdFx0dmFyIHF1YXRJbnZlcnNlID0gcXVhdC5jbG9uZSgpLmludmVyc2UoKTtcblxuXHRcdHZhciBsYXN0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBsYXN0UXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG5cblx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdC8vIHJvdGF0ZSBvZmZzZXQgdG8gXCJ5LWF4aXMtaXMtdXBcIiBzcGFjZVxuXHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdCApO1xuXG5cdFx0XHQvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXG5cdFx0XHRzcGhlcmljYWwuc2V0RnJvbVZlY3RvcjMoIG9mZnNldCApO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmF1dG9Sb3RhdGUgJiYgc3RhdGUgPT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdFx0cm90YXRlTGVmdCggZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNwaGVyaWNhbC50aGV0YSArPSBzcGhlcmljYWxEZWx0YS50aGV0YTtcblx0XHRcdHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpO1xuXG5cdFx0XHQvLyByZXN0cmljdCB0aGV0YSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cdFx0XHRzcGhlcmljYWwudGhldGEgPSBNYXRoLm1heCggc2NvcGUubWluQXppbXV0aEFuZ2xlLCBNYXRoLm1pbiggc2NvcGUubWF4QXppbXV0aEFuZ2xlLCBzcGhlcmljYWwudGhldGEgKSApO1xuXG5cdFx0XHQvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXHRcdFx0c3BoZXJpY2FsLnBoaSA9IE1hdGgubWF4KCBzY29wZS5taW5Qb2xhckFuZ2xlLCBNYXRoLm1pbiggc2NvcGUubWF4UG9sYXJBbmdsZSwgc3BoZXJpY2FsLnBoaSApICk7XG5cblx0XHRcdHNwaGVyaWNhbC5tYWtlU2FmZSgpO1xuXG5cblx0XHRcdHNwaGVyaWNhbC5yYWRpdXMgKj0gc2NhbGU7XG5cblx0XHRcdC8vIHJlc3RyaWN0IHJhZGl1cyB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cdFx0XHRzcGhlcmljYWwucmFkaXVzID0gTWF0aC5tYXgoIHNjb3BlLm1pbkRpc3RhbmNlLCBNYXRoLm1pbiggc2NvcGUubWF4RGlzdGFuY2UsIHNwaGVyaWNhbC5yYWRpdXMgKSApO1xuXG5cdFx0XHQvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cblx0XHRcdHNjb3BlLnRhcmdldC5hZGQoIHBhbk9mZnNldCApO1xuXG5cdFx0XHRvZmZzZXQuc2V0RnJvbVNwaGVyaWNhbCggc3BoZXJpY2FsICk7XG5cblx0XHRcdC8vIHJvdGF0ZSBvZmZzZXQgYmFjayB0byBcImNhbWVyYS11cC12ZWN0b3ItaXMtdXBcIiBzcGFjZVxuXHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdEludmVyc2UgKTtcblxuXHRcdFx0cG9zaXRpb24uY29weSggc2NvcGUudGFyZ2V0ICkuYWRkKCBvZmZzZXQgKTtcblxuXHRcdFx0c2NvcGUub2JqZWN0Lmxvb2tBdCggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlRGFtcGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRzcGhlcmljYWxEZWx0YS50aGV0YSAqPSAoIDEgLSBzY29wZS5kYW1waW5nRmFjdG9yICk7XG5cdFx0XHRcdHNwaGVyaWNhbERlbHRhLnBoaSAqPSAoIDEgLSBzY29wZS5kYW1waW5nRmFjdG9yICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c3BoZXJpY2FsRGVsdGEuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c2NhbGUgPSAxO1xuXHRcdFx0cGFuT2Zmc2V0LnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHQvLyB1cGRhdGUgY29uZGl0aW9uIGlzOlxuXHRcdFx0Ly8gbWluKGNhbWVyYSBkaXNwbGFjZW1lbnQsIGNhbWVyYSByb3RhdGlvbiBpbiByYWRpYW5zKV4yID4gRVBTXG5cdFx0XHQvLyB1c2luZyBzbWFsbC1hbmdsZSBhcHByb3hpbWF0aW9uIGNvcyh4LzIpID0gMSAtIHheMiAvIDhcblxuXHRcdFx0aWYgKCB6b29tQ2hhbmdlZCB8fFxuXHRcdFx0XHRsYXN0UG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoIHNjb3BlLm9iamVjdC5wb3NpdGlvbiApID4gRVBTIHx8XG5cdFx0XHRcdDggKiAoIDEgLSBsYXN0UXVhdGVybmlvbi5kb3QoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICkgKSA+IEVQUyApIHtcblxuXHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBjaGFuZ2VFdmVudCApO1xuXG5cdFx0XHRcdGxhc3RQb3NpdGlvbi5jb3B5KCBzY29wZS5vYmplY3QucG9zaXRpb24gKTtcblx0XHRcdFx0bGFzdFF1YXRlcm5pb24uY29weSggc2NvcGUub2JqZWN0LnF1YXRlcm5pb24gKTtcblx0XHRcdFx0em9vbUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUsIGZhbHNlICk7XG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlICk7XG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XG5cblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBmYWxzZSApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UgKTtcblxuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcblxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UgKTtcblxuXHRcdC8vc2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApOyAvLyBzaG91bGQgdGhpcyBiZSBhZGRlZCBoZXJlP1xuXG5cdH07XG5cblx0Ly9cblx0Ly8gaW50ZXJuYWxzXG5cdC8vXG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHR2YXIgY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XG5cdHZhciBzdGFydEV2ZW50ID0geyB0eXBlOiAnc3RhcnQnIH07XG5cdHZhciBlbmRFdmVudCA9IHsgdHlwZTogJ2VuZCcgfTtcblxuXHR2YXIgU1RBVEUgPSB7IE5PTkU6IC0gMSwgUk9UQVRFOiAwLCBET0xMWTogMSwgUEFOOiAyLCBUT1VDSF9ST1RBVEU6IDMsIFRPVUNIX0RPTExZOiA0LCBUT1VDSF9QQU46IDUgfTtcblxuXHR2YXIgc3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdHZhciBFUFMgPSAwLjAwMDAwMTtcblxuXHQvLyBjdXJyZW50IHBvc2l0aW9uIGluIHNwaGVyaWNhbCBjb29yZGluYXRlc1xuXHR2YXIgc3BoZXJpY2FsID0gbmV3IFRIUkVFLlNwaGVyaWNhbCgpO1xuXHR2YXIgc3BoZXJpY2FsRGVsdGEgPSBuZXcgVEhSRUUuU3BoZXJpY2FsKCk7XG5cblx0dmFyIHNjYWxlID0gMTtcblx0dmFyIHBhbk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB6b29tQ2hhbmdlZCA9IGZhbHNlO1xuXG5cdHZhciByb3RhdGVTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciByb3RhdGVFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcm90YXRlRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHZhciBwYW5TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciBwYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcGFuRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHZhciBkb2xseVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIGRvbGx5RW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIGRvbGx5RGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xuXG5cdFx0cmV0dXJuIDIgKiBNYXRoLlBJIC8gNjAgLyA2MCAqIHNjb3BlLmF1dG9Sb3RhdGVTcGVlZDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Wm9vbVNjYWxlKCkge1xuXG5cdFx0cmV0dXJuIE1hdGgucG93KCAwLjk1LCBzY29wZS56b29tU3BlZWQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcm90YXRlTGVmdCggYW5nbGUgKSB7XG5cblx0XHRzcGhlcmljYWxEZWx0YS50aGV0YSAtPSBhbmdsZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcm90YXRlVXAoIGFuZ2xlICkge1xuXG5cdFx0c3BoZXJpY2FsRGVsdGEucGhpIC09IGFuZ2xlO1xuXG5cdH1cblxuXHR2YXIgcGFuTGVmdCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBwYW5MZWZ0KCBkaXN0YW5jZSwgb2JqZWN0TWF0cml4ICkge1xuXG5cdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMCApOyAvLyBnZXQgWCBjb2x1bW4gb2Ygb2JqZWN0TWF0cml4XG5cdFx0XHR2Lm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlICk7XG5cblx0XHRcdHBhbk9mZnNldC5hZGQoIHYgKTtcblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdHZhciBwYW5VcCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBwYW5VcCggZGlzdGFuY2UsIG9iamVjdE1hdHJpeCApIHtcblxuXHRcdFx0di5zZXRGcm9tTWF0cml4Q29sdW1uKCBvYmplY3RNYXRyaXgsIDEgKTsgLy8gZ2V0IFkgY29sdW1uIG9mIG9iamVjdE1hdHJpeFxuXHRcdFx0di5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKTtcblxuXHRcdFx0cGFuT2Zmc2V0LmFkZCggdiApO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0Ly8gZGVsdGFYIGFuZCBkZWx0YVkgYXJlIGluIHBpeGVsczsgcmlnaHQgYW5kIGRvd24gYXJlIHBvc2l0aXZlXG5cdHZhciBwYW4gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBwYW4oIGRlbHRhWCwgZGVsdGFZICkge1xuXG5cdFx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdFx0aWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuXHRcdFx0XHQvLyBwZXJzcGVjdGl2ZVxuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG5cdFx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cdFx0XHRcdHZhciB0YXJnZXREaXN0YW5jZSA9IG9mZnNldC5sZW5ndGgoKTtcblxuXHRcdFx0XHQvLyBoYWxmIG9mIHRoZSBmb3YgaXMgY2VudGVyIHRvIHRvcCBvZiBzY3JlZW5cblx0XHRcdFx0dGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oICggc2NvcGUub2JqZWN0LmZvdiAvIDIgKSAqIE1hdGguUEkgLyAxODAuMCApO1xuXG5cdFx0XHRcdC8vIHdlIGFjdHVhbGx5IGRvbid0IHVzZSBzY3JlZW5XaWR0aCwgc2luY2UgcGVyc3BlY3RpdmUgY2FtZXJhIGlzIGZpeGVkIHRvIHNjcmVlbiBoZWlnaHRcblx0XHRcdFx0cGFuTGVmdCggMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblx0XHRcdFx0cGFuVXAoIDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHQvLyBvcnRob2dyYXBoaWNcblx0XHRcdFx0cGFuTGVmdCggZGVsdGFYICogKCBzY29wZS5vYmplY3QucmlnaHQgLSBzY29wZS5vYmplY3QubGVmdCApIC8gc2NvcGUub2JqZWN0Lnpvb20gLyBlbGVtZW50LmNsaWVudFdpZHRoLCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cdFx0XHRcdHBhblVwKCBkZWx0YVkgKiAoIHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tICkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gY2FtZXJhIG5laXRoZXIgb3J0aG9ncmFwaGljIG5vciBwZXJzcGVjdGl2ZVxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRzY29wZS5lbmFibGVQYW4gPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0ZnVuY3Rpb24gZG9sbHlJbiggZG9sbHlTY2FsZSApIHtcblxuXHRcdGlmICggc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdHNjYWxlIC89IGRvbGx5U2NhbGU7XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoIHNjb3BlLm1pblpvb20sIE1hdGgubWluKCBzY29wZS5tYXhab29tLCBzY29wZS5vYmplY3Quem9vbSAqIGRvbGx5U2NhbGUgKSApO1xuXHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdHpvb21DaGFuZ2VkID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyApO1xuXHRcdFx0c2NvcGUuZW5hYmxlWm9vbSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBkb2xseU91dCggZG9sbHlTY2FsZSApIHtcblxuXHRcdGlmICggc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdHNjYWxlICo9IGRvbGx5U2NhbGU7XG5cblx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoIHNjb3BlLm1pblpvb20sIE1hdGgubWluKCBzY29wZS5tYXhab29tLCBzY29wZS5vYmplY3Quem9vbSAvIGRvbGx5U2NhbGUgKSApO1xuXHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdHpvb21DaGFuZ2VkID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyApO1xuXHRcdFx0c2NvcGUuZW5hYmxlWm9vbSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvL1xuXHQvLyBldmVudCBjYWxsYmFja3MgLSB1cGRhdGUgdGhlIG9iamVjdCBzdGF0ZVxuXHQvL1xuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duUm90YXRlJyApO1xuXG5cdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bkRvbGx5KCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZURvd25Eb2xseScgKTtcblxuXHRcdGRvbGx5U3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blBhbiggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duUGFuJyApO1xuXG5cdFx0cGFuU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlUm90YXRlJyApO1xuXG5cdFx0cm90YXRlRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXHRcdHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcblxuXHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0Ly8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuXHRcdHJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0Ly8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXG5cdFx0cm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQgKTtcblxuXHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZU1vdmVEb2xseScgKTtcblxuXHRcdGRvbGx5RW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0ZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG5cdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRkb2xseUluKCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0fSBlbHNlIGlmICggZG9sbHlEZWx0YS55IDwgMCApIHtcblxuXHRcdFx0ZG9sbHlPdXQoIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHR9XG5cblx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlUGFuKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZU1vdmVQYW4nICk7XG5cblx0XHRwYW5FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICk7XG5cblx0XHRwYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcblxuXHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoIGV2ZW50ICkge1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICdoYW5kbGVNb3VzZVVwJyApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKCBldmVudCApIHtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VXaGVlbCcgKTtcblxuXHRcdGlmICggZXZlbnQuZGVsdGFZIDwgMCApIHtcblxuXHRcdFx0ZG9sbHlPdXQoIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHR9IGVsc2UgaWYgKCBldmVudC5kZWx0YVkgPiAwICkge1xuXG5cdFx0XHRkb2xseUluKCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0fVxuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZUtleURvd24oIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZUtleURvd24nICk7XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuVVA6XG5cdFx0XHRcdHBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxuXHRcdFx0XHRwYW4oIDAsIC0gc2NvcGUua2V5UGFuU3BlZWQgKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuTEVGVDpcblx0XHRcdFx0cGFuKCBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5SSUdIVDpcblx0XHRcdFx0cGFuKCAtIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydFJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hTdGFydFJvdGF0ZScgKTtcblxuXHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5KCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaFN0YXJ0RG9sbHknICk7XG5cblx0XHR2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XG5cdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXG5cdFx0dmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG5cdFx0ZG9sbHlTdGFydC5zZXQoIDAsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRQYW4oIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoU3RhcnRQYW4nICk7XG5cblx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZVJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hNb3ZlUm90YXRlJyApO1xuXG5cdFx0cm90YXRlRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XG5cblx0XHR2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcblx0XHRyb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogc2NvcGUucm90YXRlU3BlZWQgKTtcblxuXHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuXHRcdHJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRyb3RhdGVTdGFydC5jb3B5KCByb3RhdGVFbmQgKTtcblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseSggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hNb3ZlRG9sbHknICk7XG5cblx0XHR2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XG5cdFx0dmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXG5cdFx0dmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG5cdFx0ZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXG5cdFx0ZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG5cdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRkb2xseU91dCggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGRvbGx5RGVsdGEueSA8IDAgKSB7XG5cblx0XHRcdGRvbGx5SW4oIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHR9XG5cblx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUGFuKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaE1vdmVQYW4nICk7XG5cblx0XHRwYW5FbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXG5cdFx0cGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xuXG5cdFx0cGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cblx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hFbmQnICk7XG5cblx0fVxuXG5cdC8vXG5cdC8vIGV2ZW50IGhhbmRsZXJzIC0gRlNNOiBsaXN0ZW4gZm9yIGV2ZW50cyBhbmQgcmVzZXQgc3RhdGVcblx0Ly9cblxuXHRmdW5jdGlvbiBvbk1vdXNlRG93biggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LmJ1dHRvbiApIHtcblxuXHRcdFx0Y2FzZSBzY29wZS5tb3VzZUJ1dHRvbnMuT1JCSVQ6XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlRG93blJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlJPVEFURTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBzY29wZS5tb3VzZUJ1dHRvbnMuWk9PTTpcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlRG93bkRvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuRE9MTFk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUubW91c2VCdXR0b25zLlBBTjpcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VEb3duUGFuKCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuUEFOO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHtcblxuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRzd2l0Y2ggKCBzdGF0ZSApIHtcblxuXHRcdFx0Y2FzZSBTVEFURS5ST1RBVEU6XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBTVEFURS5ET0xMWTpcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFNUQVRFLlBBTjpcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlUGFuKCBldmVudCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlVXAoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGhhbmRsZU1vdXNlVXAoIGV2ZW50ICk7XG5cblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSB8fCAoIHN0YXRlICE9PSBTVEFURS5OT05FICYmIHN0YXRlICE9PSBTVEFURS5ST1RBVEUgKSApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRoYW5kbGVNb3VzZVdoZWVsKCBldmVudCApO1xuXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApOyAvLyBub3Qgc3VyZSB3aHkgdGhlc2UgYXJlIGhlcmUuLi5cblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbktleURvd24oIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVLZXlzID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0aGFuZGxlS2V5RG93biggZXZlbnQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0Y2FzZSAxOlx0Ly8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydFJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAyOlx0Ly8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydERvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0UGFuKCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUEFOO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH1cblxuXHRcdGlmICggc3RhdGUgIT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Ub3VjaE1vdmUoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0Y2FzZSAxOiAvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfUk9UQVRFICkgcmV0dXJuOyAvLyBpcyB0aGlzIG5lZWRlZD8uLi5cblxuXHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgMjogLy8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX0RPTExZICkgcmV0dXJuOyAvLyBpcyB0aGlzIG5lZWRlZD8uLi5cblxuXHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseSggZXZlbnQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9QQU4gKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxuXG5cdFx0XHRcdGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uVG91Y2hFbmQoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGhhbmRsZVRvdWNoRW5kKCBldmVudCApO1xuXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcblxuXHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Db250ZXh0TWVudSggZXZlbnQgKSB7XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdH1cblxuXHQvL1xuXG5cdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UgKTtcblxuXHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UgKTtcblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XG5cblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UgKTtcblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSApO1xuXHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UgKTtcblxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlICk7XG5cblx0Ly8gZm9yY2UgYW4gdXBkYXRlIGF0IHN0YXJ0XG5cblx0dGhpcy51cGRhdGUoKTtcblxufTtcblxuT3JiaXRDb250cm9scy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlICk7XG5PcmJpdENvbnRyb2xzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9yYml0Q29udHJvbHM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBPcmJpdENvbnRyb2xzLnByb3RvdHlwZSwge1xuXG5cdGNlbnRlcjoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5jZW50ZXIgaGFzIGJlZW4gcmVuYW1lZCB0byAudGFyZ2V0JyApO1xuXHRcdFx0cmV0dXJuIHRoaXMudGFyZ2V0O1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG5cdG5vWm9vbToge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1pvb20gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVab29tIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVab29tO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vWm9vbSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVpvb20gaW5zdGVhZC4nICk7XG5cdFx0XHR0aGlzLmVuYWJsZVpvb20gPSAhIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0bm9Sb3RhdGU6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9Sb3RhdGUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVSb3RhdGUgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZVJvdGF0ZTtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1JvdGF0ZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVJvdGF0ZSBpbnN0ZWFkLicgKTtcblx0XHRcdHRoaXMuZW5hYmxlUm90YXRlID0gISB2YWx1ZTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdG5vUGFuOiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vUGFuIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUGFuIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVQYW47XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9QYW4gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVQYW4gaW5zdGVhZC4nICk7XG5cdFx0XHR0aGlzLmVuYWJsZVBhbiA9ICEgdmFsdWU7XG5cblx0XHR9XG5cblx0fSxcblxuXHRub0tleXM6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9LZXlzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlS2V5cyBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiAhIHRoaXMuZW5hYmxlS2V5cztcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub0tleXMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVLZXlzIGluc3RlYWQuJyApO1xuXHRcdFx0dGhpcy5lbmFibGVLZXlzID0gISB2YWx1ZTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHN0YXRpY01vdmluZzoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5zdGF0aWNNb3ZpbmcgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVEYW1waW5nIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVEYW1waW5nO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLnN0YXRpY01vdmluZyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZURhbXBpbmcgaW5zdGVhZC4nICk7XG5cdFx0XHR0aGlzLmVuYWJsZURhbXBpbmcgPSAhIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0ZHluYW1pY0RhbXBpbmdGYWN0b3I6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAuZHluYW1pY0RhbXBpbmdGYWN0b3IgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIC5kYW1waW5nRmFjdG9yIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZGFtcGluZ0ZhY3RvcjtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5keW5hbWljRGFtcGluZ0ZhY3RvciBoYXMgYmVlbiByZW5hbWVkLiBVc2UgLmRhbXBpbmdGYWN0b3IgaW5zdGVhZC4nICk7XG5cdFx0XHR0aGlzLmRhbXBpbmdGYWN0b3IgPSB2YWx1ZTtcblxuXHRcdH1cblxuXHR9XG5cbn0gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcmJpdENvbnRyb2xzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGhyZWUtb3JiaXRjb250cm9scy9PcmJpdENvbnRyb2xzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\")\n},1255:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (immutable) */ __webpack_exports__[\"a\"] = __extends;\\n/* unused harmony export __assign */\\n/* unused harmony export __rest */\\n/* unused harmony export __decorate */\\n/* unused harmony export __param */\\n/* unused harmony export __metadata */\\n/* unused harmony export __awaiter */\\n/* unused harmony export __generator */\\n/* unused harmony export __exportStar */\\n/* unused harmony export __values */\\n/* unused harmony export __read */\\n/* unused harmony export __spread */\\n/* unused harmony export __await */\\n/* unused harmony export __asyncGenerator */\\n/* unused harmony export __asyncDelegator */\\n/* unused harmony export __asyncValues */\\n/*! *****************************************************************************\\r\\nCopyright (c) Microsoft Corporation. All rights reserved.\\r\\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\\r\\nthis file except in compliance with the License. You may obtain a copy of the\\r\\nLicense at http://www.apache.org/licenses/LICENSE-2.0\\r\\n\\r\\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\r\\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\\r\\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\\r\\nMERCHANTABLITY OR NON-INFRINGEMENT.\\r\\n\\r\\nSee the Apache Version 2.0 License for specific language governing permissions\\r\\nand limitations under the License.\\r\\n***************************************************************************** */\\r\\n/* global Reflect, Promise */\\r\\n\\r\\nvar extendStatics = Object.setPrototypeOf ||\\r\\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\r\\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\r\\n\\r\\nfunction __extends(d, b) {\\r\\n    extendStatics(d, b);\\r\\n    function __() { this.constructor = d; }\\r\\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\r\\n}\\r\\n\\r\\nvar __assign = Object.assign || function __assign(t) {\\r\\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\\r\\n        s = arguments[i];\\r\\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\\r\\n    }\\r\\n    return t;\\r\\n}\\r\\n\\r\\nfunction __rest(s, e) {\\r\\n    var t = {};\\r\\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\\r\\n        t[p] = s[p];\\r\\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\\r\\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\\r\\n            t[p[i]] = s[p[i]];\\r\\n    return t;\\r\\n}\\r\\n\\r\\nfunction __decorate(decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n}\\r\\n\\r\\nfunction __param(paramIndex, decorator) {\\r\\n    return function (target, key) { decorator(target, key, paramIndex); }\\r\\n}\\r\\n\\r\\nfunction __metadata(metadataKey, metadataValue) {\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\\r\\n}\\r\\n\\r\\nfunction __awaiter(thisArg, _arguments, P, generator) {\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n}\\r\\n\\r\\nfunction __generator(thisArg, body) {\\r\\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\\r\\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\\r\\n    function verb(n) { return function (v) { return step([n, v]); }; }\\r\\n    function step(op) {\\r\\n        if (f) throw new TypeError(\"Generator is already executing.\");\\r\\n        while (_) try {\\r\\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\\r\\n            if (y = 0, t) op = [0, t.value];\\r\\n            switch (op[0]) {\\r\\n                case 0: case 1: t = op; break;\\r\\n                case 4: _.label++; return { value: op[1], done: false };\\r\\n                case 5: _.label++; y = op[1]; op = [0]; continue;\\r\\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\\r\\n                default:\\r\\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\\r\\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\\r\\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\\r\\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\\r\\n                    if (t[2]) _.ops.pop();\\r\\n                    _.trys.pop(); continue;\\r\\n            }\\r\\n            op = body.call(thisArg, _);\\r\\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\\r\\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction __exportStar(m, exports) {\\r\\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\\r\\n}\\r\\n\\r\\nfunction __values(o) {\\r\\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\\r\\n    if (m) return m.call(o);\\r\\n    return {\\r\\n        next: function () {\\r\\n            if (o && i >= o.length) o = void 0;\\r\\n            return { value: o && o[i++], done: !o };\\r\\n        }\\r\\n    };\\r\\n}\\r\\n\\r\\nfunction __read(o, n) {\\r\\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\\r\\n    if (!m) return o;\\r\\n    var i = m.call(o), r, ar = [], e;\\r\\n    try {\\r\\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\\r\\n    }\\r\\n    catch (error) { e = { error: error }; }\\r\\n    finally {\\r\\n        try {\\r\\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\\r\\n        }\\r\\n        finally { if (e) throw e.error; }\\r\\n    }\\r\\n    return ar;\\r\\n}\\r\\n\\r\\nfunction __spread() {\\r\\n    for (var ar = [], i = 0; i < arguments.length; i++)\\r\\n        ar = ar.concat(__read(arguments[i]));\\r\\n    return ar;\\r\\n}\\r\\n\\r\\nfunction __await(v) {\\r\\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\\r\\n}\\r\\n\\r\\nfunction __asyncGenerator(thisArg, _arguments, generator) {\\r\\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\\r\\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\\r\\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\\r\\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\\r\\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\\r\\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\\r\\n    function fulfill(value) { resume(\"next\", value); }\\r\\n    function reject(value) { resume(\"throw\", value); }\\r\\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\\r\\n}\\r\\n\\r\\nfunction __asyncDelegator(o) {\\r\\n    var i, p;\\r\\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\\r\\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\\r\\n}\\r\\n\\r\\nfunction __asyncValues(o) {\\r\\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\\r\\n    var m = o[Symbol.asyncIterator];\\r\\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\\r\\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vdHNsaWIvdHNsaWIuZXM2LmpzPzM3OTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RzbGliL3RzbGliLmVzNi5qc1xuLy8gbW9kdWxlIGlkID0gMTI1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==')},1264:function(t,exports,n){n(89),n(90),t.exports=n(484)},216:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar blog_edit_component_1 = __webpack_require__(508);\\r\\nexports.BlogEditComponent = blog_edit_component_1.BlogEditComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ibG9nLWVkaXQvaW5kZXgudHM/NmRhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBCbG9nRWRpdENvbXBvbmVudCB9IGZyb20gJy4vYmxvZy1lZGl0LmNvbXBvbmVudCc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vdHNsaW50LWxvYWRlcj8/cmVmLS0wLTAhLi9zcmMvYXBwL2Jsb2ctZWRpdC9pbmRleC50cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==')},217:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar blog_list_component_1 = __webpack_require__(509);\\r\\nexports.BlogListComponent = blog_list_component_1.BlogListComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ibG9nLWxpc3QvaW5kZXgudHM/ODkxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBCbG9nTGlzdENvbXBvbmVudCB9IGZyb20gJy4vYmxvZy1saXN0LmNvbXBvbmVudCc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vdHNsaW50LWxvYWRlcj8/cmVmLS0wLTAhLi9zcmMvYXBwL2Jsb2ctbGlzdC9pbmRleC50cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==')},218:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar datav_component_1 = __webpack_require__(510);\\r\\nexports.DatavComponent = datav_component_1.DatavComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9kYXRhdi9pbmRleC50cz82ODBiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IERhdGF2Q29tcG9uZW50IH0gZnJvbSAnLi9kYXRhdi5jb21wb25lbnQnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9kYXRhdi9pbmRleC50cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==')},219:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar home_component_1 = __webpack_require__(511);\\r\\nexports.HomeComponent = home_component_1.HomeComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2luZGV4LnRzPzQwMmIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgSG9tZUNvbXBvbmVudCB9IGZyb20gJy4vaG9tZS5jb21wb25lbnQnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9ob21lL2luZGV4LnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9')},220:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar login_component_1 = __webpack_require__(512);\\r\\nexports.LoginComponent = login_component_1.LoginComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9sb2dpbi9pbmRleC50cz9jYWQyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IExvZ2luQ29tcG9uZW50IH0gZnJvbSAnLi9sb2dpbi5jb21wb25lbnQnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9sb2dpbi9pbmRleC50cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==')},484:function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function(process) {\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar platform_browser_dynamic_1 = __webpack_require__(214);\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar app_module_1 = __webpack_require__(507);\\r\\nif (process.env.ENV === 'production') {\\r\\n    core_1.enableProdMode();\\r\\n}\\r\\nplatform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21haW4udHM/ZmIxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbmltcG9ydCB7IGVuYWJsZVByb2RNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBcHBNb2R1bGUgfSBmcm9tICcuL2FwcC9hcHAubW9kdWxlJztcbmlmIChwcm9jZXNzLmVudi5FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBlbmFibGVQcm9kTW9kZSgpO1xufVxucGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL21haW4udHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\")},502:function(module,__webpack_exports__,__webpack_require__){\"use strict\"\n;eval('Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dir\", function() { return Dir; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RtlModule\", function() { return RtlModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObserveContentModule\", function() { return ObserveContentModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObserveContent\", function() { return ObserveContent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdOptionModule\", function() { return MdOptionModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdOption\", function() { return MdOption; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdOptionSelectionChange\", function() { return MdOptionSelectionChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Portal\", function() { return Portal; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasePortalHost\", function() { return BasePortalHost; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentPortal\", function() { return ComponentPortal; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplatePortal\", function() { return TemplatePortal; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PortalHostDirective\", function() { return PortalHostDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplatePortalDirective\", function() { return TemplatePortalDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PortalModule\", function() { return PortalModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DomPortalHost\", function() { return DomPortalHost; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GestureConfig\", function() { return GestureConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiveAnnouncer\", function() { return LiveAnnouncer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LIVE_ANNOUNCER_ELEMENT_TOKEN\", function() { return LIVE_ANNOUNCER_ELEMENT_TOKEN; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LIVE_ANNOUNCER_PROVIDER\", function() { return LIVE_ANNOUNCER_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InteractivityChecker\", function() { return InteractivityChecker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFakeMousedownFromScreenReader\", function() { return isFakeMousedownFromScreenReader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A11yModule\", function() { return A11yModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniqueSelectionDispatcher\", function() { return UniqueSelectionDispatcher; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UNIQUE_SELECTION_DISPATCHER_PROVIDER\", function() { return UNIQUE_SELECTION_DISPATCHER_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdLineModule\", function() { return MdLineModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdLine\", function() { return MdLine; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdLineSetter\", function() { return MdLineSetter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"coerceBooleanProperty\", function() { return coerceBooleanProperty; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"coerceNumberProperty\", function() { return coerceNumberProperty; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompatibilityModule\", function() { return CompatibilityModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoConflictStyleCompatibilityMode\", function() { return NoConflictStyleCompatibilityMode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCommonModule\", function() { return MdCommonModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCoreModule\", function() { return MdCoreModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlatformModule\", function() { return PlatformModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform\", function() { return Platform; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSupportedInputTypes\", function() { return getSupportedInputTypes; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Overlay\", function() { return Overlay; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OVERLAY_PROVIDERS\", function() { return OVERLAY_PROVIDERS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayContainer\", function() { return OverlayContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FullscreenOverlayContainer\", function() { return FullscreenOverlayContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayRef\", function() { return OverlayRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayState\", function() { return OverlayState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConnectedOverlayDirective\", function() { return ConnectedOverlayDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayOrigin\", function() { return OverlayOrigin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayModule\", function() { return OverlayModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewportRuler\", function() { return ViewportRuler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GlobalPositionStrategy\", function() { return GlobalPositionStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConnectedPositionStrategy\", function() { return ConnectedPositionStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConnectionPositionPair\", function() { return ConnectionPositionPair; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollableViewProperties\", function() { return ScrollableViewProperties; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConnectedOverlayPositionChange\", function() { return ConnectedOverlayPositionChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scrollable\", function() { return Scrollable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollDispatcher\", function() { return ScrollDispatcher; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RepositionScrollStrategy\", function() { return RepositionScrollStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CloseScrollStrategy\", function() { return CloseScrollStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoopScrollStrategy\", function() { return NoopScrollStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BlockScrollStrategy\", function() { return BlockScrollStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollDispatchModule\", function() { return ScrollDispatchModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRipple\", function() { return MdRipple; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_RIPPLE_GLOBAL_OPTIONS\", function() { return MD_RIPPLE_GLOBAL_OPTIONS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RippleRef\", function() { return RippleRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RippleState\", function() { return RippleState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RIPPLE_FADE_IN_DURATION\", function() { return RIPPLE_FADE_IN_DURATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RIPPLE_FADE_OUT_DURATION\", function() { return RIPPLE_FADE_OUT_DURATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRippleModule\", function() { return MdRippleModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectionModel\", function() { return SelectionModel; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectionChange\", function() { return SelectionChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FocusTrap\", function() { return FocusTrap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FocusTrapFactory\", function() { return FocusTrapFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FocusTrapDeprecatedDirective\", function() { return FocusTrapDeprecatedDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FocusTrapDirective\", function() { return FocusTrapDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StyleModule\", function() { return StyleModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TOUCH_BUFFER_MS\", function() { return TOUCH_BUFFER_MS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FocusOriginMonitor\", function() { return FocusOriginMonitor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkMonitorFocus\", function() { return CdkMonitorFocus; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY\", function() { return FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FOCUS_ORIGIN_MONITOR_PROVIDER\", function() { return FOCUS_ORIGIN_MONITOR_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyCssTransform\", function() { return applyCssTransform; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UP_ARROW\", function() { return UP_ARROW; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOWN_ARROW\", function() { return DOWN_ARROW; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RIGHT_ARROW\", function() { return RIGHT_ARROW; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LEFT_ARROW\", function() { return LEFT_ARROW; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PAGE_UP\", function() { return PAGE_UP; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PAGE_DOWN\", function() { return PAGE_DOWN; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HOME\", function() { return HOME; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"END\", function() { return END; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ENTER\", function() { return ENTER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SPACE\", function() { return SPACE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TAB\", function() { return TAB; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ESCAPE\", function() { return ESCAPE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BACKSPACE\", function() { return BACKSPACE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DELETE\", function() { return DELETE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MATERIAL_COMPATIBILITY_MODE\", function() { return MATERIAL_COMPATIBILITY_MODE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MATERIAL_SANITY_CHECKS\", function() { return MATERIAL_SANITY_CHECKS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdCompatibilityInvalidPrefixError\", function() { return getMdCompatibilityInvalidPrefixError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAT_ELEMENTS_SELECTOR\", function() { return MAT_ELEMENTS_SELECTOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_ELEMENTS_SELECTOR\", function() { return MD_ELEMENTS_SELECTOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatPrefixRejector\", function() { return MatPrefixRejector; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPrefixRejector\", function() { return MdPrefixRejector; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationCurves\", function() { return AnimationCurves; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationDurations\", function() { return AnimationDurations; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSelectionModule\", function() { return MdSelectionModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPseudoCheckbox\", function() { return MdPseudoCheckbox; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NativeDateModule\", function() { return NativeDateModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdNativeDateModule\", function() { return MdNativeDateModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DateAdapter\", function() { return DateAdapter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_DATE_FORMATS\", function() { return MD_DATE_FORMATS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NativeDateAdapter\", function() { return NativeDateAdapter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_NATIVE_DATE_FORMATS\", function() { return MD_NATIVE_DATE_FORMATS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaterialModule\", function() { return MaterialModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdAutocompleteModule\", function() { return MdAutocompleteModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdAutocomplete\", function() { return MdAutocomplete; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AUTOCOMPLETE_OPTION_HEIGHT\", function() { return AUTOCOMPLETE_OPTION_HEIGHT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AUTOCOMPLETE_PANEL_HEIGHT\", function() { return AUTOCOMPLETE_PANEL_HEIGHT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_AUTOCOMPLETE_VALUE_ACCESSOR\", function() { return MD_AUTOCOMPLETE_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdAutocompleteTrigger\", function() { return MdAutocompleteTrigger; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonModule\", function() { return MdButtonModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonCssMatStyler\", function() { return MdButtonCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRaisedButtonCssMatStyler\", function() { return MdRaisedButtonCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdIconButtonCssMatStyler\", function() { return MdIconButtonCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdFabCssMatStyler\", function() { return MdFabCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMiniFabCssMatStyler\", function() { return MdMiniFabCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonBase\", function() { return MdButtonBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdButtonMixinBase\", function() { return _MdButtonMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButton\", function() { return MdButton; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdAnchor\", function() { return MdAnchor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggleModule\", function() { return MdButtonToggleModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR\", function() { return MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggleChange\", function() { return MdButtonToggleChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggleGroup\", function() { return MdButtonToggleGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggleGroupMultiple\", function() { return MdButtonToggleGroupMultiple; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggle\", function() { return MdButtonToggle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardModule\", function() { return MdCardModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardContent\", function() { return MdCardContent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardTitle\", function() { return MdCardTitle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardSubtitle\", function() { return MdCardSubtitle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardActions\", function() { return MdCardActions; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardFooter\", function() { return MdCardFooter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardSmImage\", function() { return MdCardSmImage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardMdImage\", function() { return MdCardMdImage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardLgImage\", function() { return MdCardLgImage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardImage\", function() { return MdCardImage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardXlImage\", function() { return MdCardXlImage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardAvatar\", function() { return MdCardAvatar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCard\", function() { return MdCard; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardHeader\", function() { return MdCardHeader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardTitleGroup\", function() { return MdCardTitleGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdChipsModule\", function() { return MdChipsModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdChipList\", function() { return MdChipList; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdChip\", function() { return MdChip; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCheckboxModule\", function() { return MdCheckboxModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_CHECKBOX_CONTROL_VALUE_ACCESSOR\", function() { return MD_CHECKBOX_CONTROL_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransitionCheckState\", function() { return TransitionCheckState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCheckboxChange\", function() { return MdCheckboxChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCheckboxBase\", function() { return MdCheckboxBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdCheckboxMixinBase\", function() { return _MdCheckboxMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCheckbox\", function() { return MdCheckbox; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepickerModule\", function() { return MdDatepickerModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCalendar\", function() { return MdCalendar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCalendarCell\", function() { return MdCalendarCell; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCalendarBody\", function() { return MdCalendarBody; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepickerContent\", function() { return MdDatepickerContent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepicker\", function() { return MdDatepicker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_DATEPICKER_VALUE_ACCESSOR\", function() { return MD_DATEPICKER_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_DATEPICKER_VALIDATORS\", function() { return MD_DATEPICKER_VALIDATORS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepickerInput\", function() { return MdDatepickerInput; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepickerIntl\", function() { return MdDatepickerIntl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepickerToggle\", function() { return MdDatepickerToggle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMonthView\", function() { return MdMonthView; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdYearView\", function() { return MdYearView; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogModule\", function() { return MdDialogModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_DIALOG_DATA\", function() { return MD_DIALOG_DATA; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialog\", function() { return MdDialog; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"throwMdDialogContentAlreadyAttachedError\", function() { return throwMdDialogContentAlreadyAttachedError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogContainer\", function() { return MdDialogContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogClose\", function() { return MdDialogClose; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogTitle\", function() { return MdDialogTitle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogContent\", function() { return MdDialogContent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogActions\", function() { return MdDialogActions; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogConfig\", function() { return MdDialogConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogRef\", function() { return MdDialogRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdGridListModule\", function() { return MdGridListModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdGridTile\", function() { return MdGridTile; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdGridList\", function() { return MdGridList; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdIconModule\", function() { return MdIconModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdIcon\", function() { return MdIcon; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdIconNameNotFoundError\", function() { return getMdIconNameNotFoundError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdIconNoHttpProviderError\", function() { return getMdIconNoHttpProviderError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdIconRegistry\", function() { return MdIconRegistry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ICON_REGISTRY_PROVIDER_FACTORY\", function() { return ICON_REGISTRY_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ICON_REGISTRY_PROVIDER\", function() { return ICON_REGISTRY_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdInputModule\", function() { return MdInputModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTextareaAutosize\", function() { return MdTextareaAutosize; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPlaceholder\", function() { return MdPlaceholder; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdHint\", function() { return MdHint; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdErrorDirective\", function() { return MdErrorDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPrefix\", function() { return MdPrefix; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSuffix\", function() { return MdSuffix; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdInputDirective\", function() { return MdInputDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdInputContainer\", function() { return MdInputContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdInputContainerPlaceholderConflictError\", function() { return getMdInputContainerPlaceholderConflictError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdInputContainerUnsupportedTypeError\", function() { return getMdInputContainerUnsupportedTypeError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdInputContainerDuplicatedHintError\", function() { return getMdInputContainerDuplicatedHintError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdInputContainerMissingMdInputError\", function() { return getMdInputContainerMissingMdInputError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListModule\", function() { return MdListModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListDivider\", function() { return MdListDivider; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdList\", function() { return MdList; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListCssMatStyler\", function() { return MdListCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdNavListCssMatStyler\", function() { return MdNavListCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDividerCssMatStyler\", function() { return MdDividerCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListAvatarCssMatStyler\", function() { return MdListAvatarCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListIconCssMatStyler\", function() { return MdListIconCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListSubheaderCssMatStyler\", function() { return MdListSubheaderCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListItem\", function() { return MdListItem; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMenuModule\", function() { return MdMenuModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeInItems\", function() { return fadeInItems; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMenu\", function() { return transformMenu; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMenu\", function() { return MdMenu; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMenuItem\", function() { return MdMenuItem; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMenuTrigger\", function() { return MdMenuTrigger; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressBarModule\", function() { return MdProgressBarModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressBar\", function() { return MdProgressBar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressSpinnerModule\", function() { return MdProgressSpinnerModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PROGRESS_SPINNER_STROKE_WIDTH\", function() { return PROGRESS_SPINNER_STROKE_WIDTH; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressSpinnerCssMatStyler\", function() { return MdProgressSpinnerCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressSpinner\", function() { return MdProgressSpinner; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSpinner\", function() { return MdSpinner; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioModule\", function() { return MdRadioModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR\", function() { return MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioChange\", function() { return MdRadioChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioGroupBase\", function() { return MdRadioGroupBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdRadioGroupMixinBase\", function() { return _MdRadioGroupMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioGroup\", function() { return MdRadioGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioButton\", function() { return MdRadioButton; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSelectModule\", function() { return MdSelectModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeInContent\", function() { return fadeInContent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformPanel\", function() { return transformPanel; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformPlaceholder\", function() { return transformPlaceholder; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_OPTION_HEIGHT\", function() { return SELECT_OPTION_HEIGHT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_PANEL_MAX_HEIGHT\", function() { return SELECT_PANEL_MAX_HEIGHT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_MAX_OPTIONS_DISPLAYED\", function() { return SELECT_MAX_OPTIONS_DISPLAYED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_TRIGGER_HEIGHT\", function() { return SELECT_TRIGGER_HEIGHT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_OPTION_HEIGHT_ADJUSTMENT\", function() { return SELECT_OPTION_HEIGHT_ADJUSTMENT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_PANEL_PADDING_X\", function() { return SELECT_PANEL_PADDING_X; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_MULTIPLE_PANEL_PADDING_X\", function() { return SELECT_MULTIPLE_PANEL_PADDING_X; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_PANEL_PADDING_Y\", function() { return SELECT_PANEL_PADDING_Y; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_PANEL_VIEWPORT_PADDING\", function() { return SELECT_PANEL_VIEWPORT_PADDING; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSelectChange\", function() { return MdSelectChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSelect\", function() { return MdSelect; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSidenavModule\", function() { return MdSidenavModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"throwMdDuplicatedSidenavError\", function() { return throwMdDuplicatedSidenavError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSidenavToggleResult\", function() { return MdSidenavToggleResult; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSidenav\", function() { return MdSidenav; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSidenavContainer\", function() { return MdSidenavContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSliderModule\", function() { return MdSliderModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_SLIDER_VALUE_ACCESSOR\", function() { return MD_SLIDER_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSliderChange\", function() { return MdSliderChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSliderBase\", function() { return MdSliderBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdSliderMixinBase\", function() { return _MdSliderMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSlider\", function() { return MdSlider; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SliderRenderer\", function() { return SliderRenderer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSlideToggleModule\", function() { return MdSlideToggleModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_SLIDE_TOGGLE_VALUE_ACCESSOR\", function() { return MD_SLIDE_TOGGLE_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSlideToggleChange\", function() { return MdSlideToggleChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSlideToggleBase\", function() { return MdSlideToggleBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdSlideToggleMixinBase\", function() { return _MdSlideToggleMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSlideToggle\", function() { return MdSlideToggle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSnackBarModule\", function() { return MdSnackBarModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSnackBar\", function() { return MdSnackBar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHOW_ANIMATION\", function() { return SHOW_ANIMATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HIDE_ANIMATION\", function() { return HIDE_ANIMATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSnackBarContainer\", function() { return MdSnackBarContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSnackBarConfig\", function() { return MdSnackBarConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSnackBarRef\", function() { return MdSnackBarRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimpleSnackBar\", function() { return SimpleSnackBar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabsModule\", function() { return MdTabsModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdInkBar\", function() { return MdInkBar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabBody\", function() { return MdTabBody; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabHeader\", function() { return MdTabHeader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabLabelWrapper\", function() { return MdTabLabelWrapper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTab\", function() { return MdTab; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabLabel\", function() { return MdTabLabel; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabChangeEvent\", function() { return MdTabChangeEvent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabGroup\", function() { return MdTabGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabNavBar\", function() { return MdTabNavBar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabLink\", function() { return MdTabLink; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabLinkRipple\", function() { return MdTabLinkRipple; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdToolbarModule\", function() { return MdToolbarModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdToolbarRow\", function() { return MdToolbarRow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdToolbar\", function() { return MdToolbar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTooltipModule\", function() { return MdTooltipModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TOUCHEND_HIDE_DELAY\", function() { return TOUCHEND_HIDE_DELAY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SCROLL_THROTTLE_MS\", function() { return SCROLL_THROTTLE_MS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"throwMdTooltipInvalidPositionError\", function() { return throwMdTooltipInvalidPositionError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTooltip\", function() { return MdTooltip; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TooltipComponent\", function() { return TooltipComponent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return LIVE_ANNOUNCER_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return mixinDisabled; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MdMutationObserverFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return OVERLAY_CONTAINER_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return OVERLAY_CONTAINER_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return OverlayPositionBuilder; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return VIEWPORT_RULER_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return VIEWPORT_RULER_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return SCROLL_DISPATCHER_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return SCROLL_DISPATCHER_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return RippleRenderer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return MdGridAvatarCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return MdGridTileFooterCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return MdGridTileHeaderCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return MdGridTileText; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(1255);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__ = __webpack_require__(46);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__ = __webpack_require__(19);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_operator_debounceTime__ = __webpack_require__(426);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_operator_debounceTime___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_add_operator_debounceTime__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__angular_common__ = __webpack_require__(67);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_Subscription__ = __webpack_require__(21);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_Subscription___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_Subscription__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_add_observable_fromEvent__ = __webpack_require__(420);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_add_observable_fromEvent___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs_add_observable_fromEvent__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_add_observable_merge__ = __webpack_require__(421);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_add_observable_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs_add_observable_merge__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_add_operator_auditTime__ = __webpack_require__(424);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_add_operator_auditTime___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_rxjs_add_operator_auditTime__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_add_operator_first__ = __webpack_require__(429);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_add_operator_first___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_rxjs_add_operator_first__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_add_observable_of__ = __webpack_require__(422);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_add_observable_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs_add_observable_of__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__angular_forms__ = __webpack_require__(212);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__angular_animations__ = __webpack_require__(137);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_add_operator_startWith__ = __webpack_require__(431);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_add_operator_startWith___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_rxjs_add_operator_startWith__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_add_operator_filter__ = __webpack_require__(75);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_add_operator_filter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_rxjs_add_operator_filter__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__angular_http__ = __webpack_require__(213);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_add_observable_forkJoin__ = __webpack_require__(419);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_add_observable_forkJoin___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_rxjs_add_observable_forkJoin__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_add_operator_map__ = __webpack_require__(64);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_add_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_rxjs_add_operator_map__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_rxjs_add_operator_do__ = __webpack_require__(427);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_rxjs_add_operator_do___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20_rxjs_add_operator_do__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_add_operator_share__ = __webpack_require__(430);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_add_operator_share___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21_rxjs_add_operator_share__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_rxjs_add_operator_finally__ = __webpack_require__(428);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_rxjs_add_operator_finally___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22_rxjs_add_operator_finally__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_rxjs_add_operator_catch__ = __webpack_require__(425);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_rxjs_add_operator_catch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_23_rxjs_add_operator_catch__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_rxjs_add_observable_throw__ = __webpack_require__(423);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_rxjs_add_observable_throw___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_24_rxjs_add_observable_throw__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_rxjs_add_operator_switchMap__ = __webpack_require__(181);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_rxjs_add_operator_switchMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_25_rxjs_add_operator_switchMap__);\\n\\n/**\\n  * @license Angular Material v2.0.0-beta.6\\n  * Copyright (c) 2017 Google, Inc. https://material.angular.io/\\n  * License: MIT\\n  */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar MATERIAL_COMPATIBILITY_MODE = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-compatibility-mode\\');\\n/**\\n * Injection token that configures whether the Material sanity checks are enabled.\\n */\\nvar MATERIAL_SANITY_CHECKS = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-sanity-checks\\');\\n/**\\n * Returns an exception to be thrown if the consumer has used\\n * an invalid Material prefix on a component.\\n * \\\\@docs-private\\n * @param {?} prefix\\n * @param {?} nodeName\\n * @return {?}\\n */\\nfunction getMdCompatibilityInvalidPrefixError(prefix, nodeName) {\\n    return new Error(\"The \\\\\"\" + prefix + \"-\\\\\" prefix cannot be used in ng-material v1 compatibility mode. \" +\\n        (\"It was used on an \\\\\"\" + nodeName.toLowerCase() + \"\\\\\" element.\"));\\n}\\n/**\\n * Selector that matches all elements that may have style collisions with AngularJS Material.\\n */\\nvar MAT_ELEMENTS_SELECTOR = \"\\\\n  [mat-button],\\\\n  [mat-card-subtitle],\\\\n  [mat-card-title],\\\\n  [mat-dialog-actions],\\\\n  [mat-dialog-close],\\\\n  [mat-dialog-content],\\\\n  [mat-dialog-title],\\\\n  [mat-fab],\\\\n  [mat-icon-button],\\\\n  [mat-menu-trigger-for],\\\\n  [mat-mini-fab],\\\\n  [mat-raised-button],\\\\n  [mat-tab-label],\\\\n  [mat-tab-link],\\\\n  [mat-tab-nav-bar],\\\\n  [matTooltip],\\\\n  mat-autocomplete,\\\\n  mat-button-toggle,\\\\n  mat-button-toggle-group,\\\\n  mat-button-toggle,\\\\n  mat-card,\\\\n  mat-card-actions,\\\\n  mat-card-content,\\\\n  mat-card-footer,\\\\n  mat-card-header,\\\\n  mat-card-subtitle,\\\\n  mat-card-title,\\\\n  mat-card-title-group,\\\\n  mat-checkbox,\\\\n  mat-chip,\\\\n  mat-dialog-actions,\\\\n  mat-dialog-container,\\\\n  mat-dialog-content,\\\\n  mat-divider,\\\\n  mat-grid-list,\\\\n  mat-grid-tile,\\\\n  mat-grid-tile-footer,\\\\n  mat-grid-tile-header,\\\\n  mat-hint,\\\\n  mat-icon,\\\\n  mat-list,\\\\n  mat-list-item,\\\\n  mat-menu,\\\\n  mat-nav-list,\\\\n  mat-option,\\\\n  mat-placeholder,\\\\n  mat-progress-bar,\\\\n  mat-pseudo-checkbox,\\\\n  mat-radio-button,\\\\n  mat-radio-group,\\\\n  mat-select,\\\\n  mat-sidenav,\\\\n  mat-sidenav-container,\\\\n  mat-slider,\\\\n  mat-spinner,\\\\n  mat-tab,\\\\n  mat-tab-group,\\\\n  mat-toolbar,\\\\n  mat-error\";\\n/**\\n * Selector that matches all elements that may have style collisions with AngularJS Material.\\n */\\nvar MD_ELEMENTS_SELECTOR = \"\\\\n  [md-button],\\\\n  [md-card-subtitle],\\\\n  [md-card-title],\\\\n  [md-dialog-actions],\\\\n  [md-dialog-close],\\\\n  [md-dialog-content],\\\\n  [md-dialog-title],\\\\n  [md-fab],\\\\n  [md-icon-button],\\\\n  [md-menu-trigger-for],\\\\n  [md-mini-fab],\\\\n  [md-raised-button],\\\\n  [md-tab-label],\\\\n  [md-tab-link],\\\\n  [md-tab-nav-bar],\\\\n  [mdTooltip],\\\\n  md-autocomplete,\\\\n  md-button-toggle,\\\\n  md-button-toggle-group,\\\\n  md-button-toggle,\\\\n  md-card,\\\\n  md-card-actions,\\\\n  md-card-content,\\\\n  md-card-footer,\\\\n  md-card-header,\\\\n  md-card-subtitle,\\\\n  md-card-title,\\\\n  md-card-title-group,\\\\n  md-checkbox,\\\\n  md-chip,\\\\n  md-dialog-actions,\\\\n  md-dialog-container,\\\\n  md-dialog-content,\\\\n  md-divider,\\\\n  md-grid-list,\\\\n  md-grid-tile,\\\\n  md-grid-tile-footer,\\\\n  md-grid-tile-header,\\\\n  md-hint,\\\\n  md-icon,\\\\n  md-list,\\\\n  md-list-item,\\\\n  md-menu,\\\\n  md-nav-list,\\\\n  md-option,\\\\n  md-placeholder,\\\\n  md-progress-bar,\\\\n  md-pseudo-checkbox,\\\\n  md-radio-button,\\\\n  md-radio-group,\\\\n  md-select,\\\\n  md-sidenav,\\\\n  md-sidenav-container,\\\\n  md-slider,\\\\n  md-spinner,\\\\n  md-tab,\\\\n  md-tab-group,\\\\n  md-toolbar,\\\\n  md-error\";\\n/**\\n * Directive that enforces that the `mat-` prefix cannot be used.\\n */\\nvar MatPrefixRejector = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} isCompatibilityMode\\n     * @param {?} elementRef\\n     */\\n    function MatPrefixRejector(isCompatibilityMode, elementRef) {\\n        if (!isCompatibilityMode) {\\n            throw getMdCompatibilityInvalidPrefixError(\\'mat\\', elementRef.nativeElement.nodeName);\\n        }\\n    }\\n    return MatPrefixRejector;\\n}());\\nMatPrefixRejector.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: MAT_ELEMENTS_SELECTOR },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMatPrefixRejector.ctorParameters = function () { return [\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MATERIAL_COMPATIBILITY_MODE,] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\n/**\\n * Directive that enforces that the `md-` prefix cannot be used.\\n */\\nvar MdPrefixRejector = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} isCompatibilityMode\\n     * @param {?} elementRef\\n     */\\n    function MdPrefixRejector(isCompatibilityMode, elementRef) {\\n        if (isCompatibilityMode) {\\n            throw getMdCompatibilityInvalidPrefixError(\\'md\\', elementRef.nativeElement.nodeName);\\n        }\\n    }\\n    return MdPrefixRejector;\\n}());\\nMdPrefixRejector.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: MD_ELEMENTS_SELECTOR },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPrefixRejector.ctorParameters = function () { return [\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MATERIAL_COMPATIBILITY_MODE,] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\n/**\\n * Module that enforces the default compatibility mode settings. When this module is loaded\\n * without NoConflictStyleCompatibilityMode also being imported, it will throw an error if\\n * there are any uses of the `mat-` prefix.\\n */\\nvar CompatibilityModule = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _document\\n     * @param {?} _sanityChecksEnabled\\n     */\\n    function CompatibilityModule(_document, _sanityChecksEnabled) {\\n        this._document = _document;\\n        /**\\n         * Whether we\\'ve done the global sanity checks (e.g. a theme is loaded, there is a doctype).\\n         */\\n        this._hasDoneGlobalChecks = false;\\n        if (_sanityChecksEnabled && !this._hasDoneGlobalChecks && _document && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"])()) {\\n            // Delay running the check to allow more time for the user\\'s styles to load.\\n            this._checkDoctype();\\n            this._checkTheme();\\n            this._hasDoneGlobalChecks = true;\\n        }\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    CompatibilityModule.prototype._checkDoctype = function () {\\n        if (!this._document.doctype) {\\n            console.warn(\\'Current document does not have a doctype. This may cause \\' +\\n                \\'some Angular Material components not to behave as expected.\\');\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    CompatibilityModule.prototype._checkTheme = function () {\\n        if (typeof getComputedStyle === \\'function\\') {\\n            var /** @type {?} */ testElement = this._document.createElement(\\'div\\');\\n            testElement.classList.add(\\'mat-theme-loaded-marker\\');\\n            this._document.body.appendChild(testElement);\\n            if (getComputedStyle(testElement).display !== \\'none\\') {\\n                console.warn(\\'Could not find Angular Material core theme. Most Material \\' +\\n                    \\'components may not work as expected. For more info refer \\' +\\n                    \\'to the theming guide: https://material.angular.io/guide/theming\\');\\n            }\\n            this._document.body.removeChild(testElement);\\n        }\\n    };\\n    return CompatibilityModule;\\n}());\\nCompatibilityModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                declarations: [MatPrefixRejector, MdPrefixRejector],\\n                exports: [MatPrefixRejector, MdPrefixRejector],\\n                providers: [{\\n                        provide: MATERIAL_SANITY_CHECKS, useValue: true,\\n                    }],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCompatibilityModule.ctorParameters = function () { return [\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__[\"DOCUMENT\"],] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MATERIAL_SANITY_CHECKS,] },] },\\n]; };\\n/**\\n * Module that enforces \"no-conflict\" compatibility mode settings. When this module is loaded,\\n * it will throw an error if there are any uses of the `md-` prefix.\\n */\\nvar NoConflictStyleCompatibilityMode = /*@__PURE__*/(function () {\\n    function NoConflictStyleCompatibilityMode() {\\n    }\\n    return NoConflictStyleCompatibilityMode;\\n}());\\nNoConflictStyleCompatibilityMode.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                providers: [{\\n                        provide: MATERIAL_COMPATIBILITY_MODE, useValue: true,\\n                    }],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nNoConflictStyleCompatibilityMode.ctorParameters = function () { return []; };\\n/**\\n * Module that captures anything that should be loaded and/or run for *all* Angular Material\\n * components. This includes Bidi, compatibility mode, etc.\\n *\\n * This module should be imported to each top-level component module (e.g., MdTabsModule).\\n */\\nvar MdCommonModule = /*@__PURE__*/(function () {\\n    function MdCommonModule() {\\n    }\\n    return MdCommonModule;\\n}());\\nMdCommonModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [CompatibilityModule],\\n                exports: [CompatibilityModule],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCommonModule.ctorParameters = function () { return []; };\\n/**\\n * Shared directive to count lines inside a text area, such as a list item.\\n * Line elements can be extracted with a \\\\@ContentChildren(MdLine) query, then\\n * counted by checking the query list\\'s length.\\n */\\nvar MdLine = /*@__PURE__*/(function () {\\n    function MdLine() {\\n    }\\n    return MdLine;\\n}());\\nMdLine.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-line], [mat-line]\\',\\n                host: {\\n                    \\'[class.mat-line]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdLine.ctorParameters = function () { return []; };\\n/**\\n * Helper that takes a query list of lines and sets the correct class on the host.\\n * \\\\@docs-private\\n */\\nvar MdLineSetter = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _lines\\n     * @param {?} _renderer\\n     * @param {?} _element\\n     */\\n    function MdLineSetter(_lines, _renderer, _element) {\\n        var _this = this;\\n        this._lines = _lines;\\n        this._renderer = _renderer;\\n        this._element = _element;\\n        this._setLineClass(this._lines.length);\\n        this._lines.changes.subscribe(function () {\\n            _this._setLineClass(_this._lines.length);\\n        });\\n    }\\n    /**\\n     * @param {?} count\\n     * @return {?}\\n     */\\n    MdLineSetter.prototype._setLineClass = function (count) {\\n        this._resetClasses();\\n        if (count === 2 || count === 3) {\\n            this._setClass(\"mat-\" + count + \"-line\", true);\\n        }\\n        else if (count > 3) {\\n            this._setClass(\"mat-multi-line\", true);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdLineSetter.prototype._resetClasses = function () {\\n        this._setClass(\\'mat-2-line\\', false);\\n        this._setClass(\\'mat-3-line\\', false);\\n        this._setClass(\\'mat-multi-line\\', false);\\n    };\\n    /**\\n     * @param {?} className\\n     * @param {?} isAdd\\n     * @return {?}\\n     */\\n    MdLineSetter.prototype._setClass = function (className, isAdd) {\\n        if (isAdd) {\\n            this._renderer.addClass(this._element.nativeElement, className);\\n        }\\n        else {\\n            this._renderer.removeClass(this._element.nativeElement, className);\\n        }\\n    };\\n    return MdLineSetter;\\n}());\\nvar MdLineModule = /*@__PURE__*/(function () {\\n    function MdLineModule() {\\n    }\\n    return MdLineModule;\\n}());\\nMdLineModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule],\\n                exports: [MdLine, MdCommonModule],\\n                declarations: [MdLine],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdLineModule.ctorParameters = function () { return []; };\\n/**\\n * Directive to listen for changes of direction of part of the DOM.\\n *\\n * Applications should use this directive instead of the native attribute so that Material\\n * components can listen on changes of direction.\\n */\\nvar Dir = /*@__PURE__*/(function () {\\n    function Dir() {\\n        /**\\n         * Layout direction of the element.\\n         */\\n        this._dir = \\'ltr\\';\\n        /**\\n         * Event emitted when the direction changes.\\n         */\\n        this.dirChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(Dir.prototype, \"dir\", {\\n        /**\\n         * \\\\@docs-private\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._dir;\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            var /** @type {?} */ old = this._dir;\\n            this._dir = v;\\n            if (old != this._dir) {\\n                this.dirChange.emit();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(Dir.prototype, \"value\", {\\n        /**\\n         * Current layout direction of the element.\\n         * @return {?}\\n         */\\n        get: function () { return this.dir; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.dir = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return Dir;\\n}());\\nDir.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[dir]\\',\\n                // TODO(hansl): maybe `$implicit` isn\\'t the best option here, but for now that\\'s the best we got.\\n                exportAs: \\'$implicit\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nDir.ctorParameters = function () { return []; };\\nDir.propDecorators = {\\n    \\'_dir\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'dir\\',] },],\\n    \\'dirChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'dir\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'attr.dir\\',] },],\\n};\\nvar RtlModule = /*@__PURE__*/(function () {\\n    function RtlModule() {\\n    }\\n    return RtlModule;\\n}());\\nRtlModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                exports: [Dir],\\n                declarations: [Dir]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nRtlModule.ctorParameters = function () { return []; };\\n/**\\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\\n * \\\\@docs-private\\n */\\nvar MdMutationObserverFactory = /*@__PURE__*/(function () {\\n    function MdMutationObserverFactory() {\\n    }\\n    /**\\n     * @param {?} callback\\n     * @return {?}\\n     */\\n    MdMutationObserverFactory.prototype.create = function (callback) {\\n        return new MutationObserver(callback);\\n    };\\n    return MdMutationObserverFactory;\\n}());\\nMdMutationObserverFactory.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMutationObserverFactory.ctorParameters = function () { return []; };\\n/**\\n * Directive that triggers a callback whenever the content of\\n * its associated element has changed.\\n */\\nvar ObserveContent = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _mutationObserverFactory\\n     * @param {?} _elementRef\\n     */\\n    function ObserveContent(_mutationObserverFactory, _elementRef) {\\n        this._mutationObserverFactory = _mutationObserverFactory;\\n        this._elementRef = _elementRef;\\n        /**\\n         * Event emitted for each change in the element\\'s content.\\n         */\\n        this.event = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Used for debouncing the emitted values to the observeContent event.\\n         */\\n        this._debouncer = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    ObserveContent.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        if (this.debounce > 0) {\\n            this._debouncer\\n                .debounceTime(this.debounce)\\n                .subscribe(function (mutations) { return _this.event.emit(mutations); });\\n        }\\n        else {\\n            this._debouncer.subscribe(function (mutations) { return _this.event.emit(mutations); });\\n        }\\n        this._observer = this._mutationObserverFactory.create(function (mutations) {\\n            _this._debouncer.next(mutations);\\n        });\\n        this._observer.observe(this._elementRef.nativeElement, {\\n            characterData: true,\\n            childList: true,\\n            subtree: true\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    ObserveContent.prototype.ngOnDestroy = function () {\\n        if (this._observer) {\\n            this._observer.disconnect();\\n            this._debouncer.complete();\\n            this._debouncer = this._observer = null;\\n        }\\n    };\\n    return ObserveContent;\\n}());\\nObserveContent.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdkObserveContent]\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nObserveContent.ctorParameters = function () { return [\\n    { type: MdMutationObserverFactory, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nObserveContent.propDecorators = {\\n    \\'event\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'cdkObserveContent\\',] },],\\n    \\'debounce\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar ObserveContentModule = /*@__PURE__*/(function () {\\n    function ObserveContentModule() {\\n    }\\n    return ObserveContentModule;\\n}());\\nObserveContentModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                exports: [ObserveContent],\\n                declarations: [ObserveContent],\\n                providers: [MdMutationObserverFactory]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nObserveContentModule.ctorParameters = function () { return []; };\\n// Due to a bug in the ChromeDriver, Angular keyboard events are not triggered by `sendKeys`\\n// during E2E tests when using dot notation such as `(keydown.rightArrow)`. To get around this,\\n// we are temporarily using a single (keydown) handler.\\n// See: https://github.com/angular/angular/issues/9419\\nvar UP_ARROW = 38;\\nvar DOWN_ARROW = 40;\\nvar RIGHT_ARROW = 39;\\nvar LEFT_ARROW = 37;\\nvar PAGE_UP = 33;\\nvar PAGE_DOWN = 34;\\nvar HOME = 36;\\nvar END = 35;\\nvar ENTER = 13;\\nvar SPACE = 32;\\nvar TAB = 9;\\nvar ESCAPE = 27;\\nvar BACKSPACE = 8;\\nvar DELETE = 46;\\n/**\\n * Coerces a data-bound value (typically a string) to a boolean.\\n * @param {?} value\\n * @return {?}\\n */\\nfunction coerceBooleanProperty(value) {\\n    return value != null && \"\" + value !== \\'false\\';\\n}\\nvar RippleState = {};\\nRippleState.FADING_IN = 0;\\nRippleState.VISIBLE = 1;\\nRippleState.FADING_OUT = 2;\\nRippleState.HIDDEN = 3;\\nRippleState[RippleState.FADING_IN] = \"FADING_IN\";\\nRippleState[RippleState.VISIBLE] = \"VISIBLE\";\\nRippleState[RippleState.FADING_OUT] = \"FADING_OUT\";\\nRippleState[RippleState.HIDDEN] = \"HIDDEN\";\\n/**\\n * Reference to a previously launched ripple element.\\n */\\nvar RippleRef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} element\\n     * @param {?} config\\n     */\\n    function RippleRef(_renderer, element, config) {\\n        this._renderer = _renderer;\\n        this.element = element;\\n        this.config = config;\\n        /**\\n         * Current state of the ripple reference.\\n         */\\n        this.state = RippleState.HIDDEN;\\n    }\\n    /**\\n     * Fades out the ripple element.\\n     * @return {?}\\n     */\\n    RippleRef.prototype.fadeOut = function () {\\n        this._renderer.fadeOutRipple(this);\\n    };\\n    return RippleRef;\\n}());\\n/**\\n * Fade-in duration for the ripples. Can be modified with the speedFactor option.\\n */\\nvar RIPPLE_FADE_IN_DURATION = 450;\\n/**\\n * Fade-out duration for the ripples in milliseconds. This can\\'t be modified by the speedFactor.\\n */\\nvar RIPPLE_FADE_OUT_DURATION = 400;\\n/**\\n * Helper service that performs DOM manipulations. Not intended to be used outside this module.\\n * The constructor takes a reference to the ripple directive\\'s host element and a map of DOM\\n * event handlers to be installed on the element that triggers ripple animations.\\n * This will eventually become a custom renderer once Angular support exists.\\n * \\\\@docs-private\\n */\\nvar RippleRenderer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementRef\\n     * @param {?} _ngZone\\n     * @param {?} _ruler\\n     * @param {?} platform\\n     */\\n    function RippleRenderer(elementRef, _ngZone, _ruler, platform) {\\n        this._ngZone = _ngZone;\\n        this._ruler = _ruler;\\n        /**\\n         * Whether the mouse is currently down or not.\\n         */\\n        this._isMousedown = false;\\n        /**\\n         * Events to be registered on the trigger element.\\n         */\\n        this._triggerEvents = new Map();\\n        /**\\n         * Set of currently active ripple references.\\n         */\\n        this._activeRipples = new Set();\\n        /**\\n         * Ripple config for all ripples created by events.\\n         */\\n        this.rippleConfig = {};\\n        /**\\n         * Whether mouse ripples should be created or not.\\n         */\\n        this.rippleDisabled = false;\\n        // Only do anything if we\\'re on the browser.\\n        if (platform.isBrowser) {\\n            this._containerElement = elementRef.nativeElement;\\n            // Specify events which need to be registered on the trigger.\\n            this._triggerEvents.set(\\'mousedown\\', this.onMousedown.bind(this));\\n            this._triggerEvents.set(\\'mouseup\\', this.onMouseup.bind(this));\\n            this._triggerEvents.set(\\'mouseleave\\', this.onMouseLeave.bind(this));\\n            // By default use the host element as trigger element.\\n            this.setTriggerElement(this._containerElement);\\n        }\\n    }\\n    /**\\n     * Fades in a ripple at the given coordinates.\\n     * @param {?} pageX\\n     * @param {?} pageY\\n     * @param {?=} config\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.fadeInRipple = function (pageX, pageY, config) {\\n        var _this = this;\\n        if (config === void 0) { config = {}; }\\n        var /** @type {?} */ containerRect = this._containerElement.getBoundingClientRect();\\n        if (config.centered) {\\n            pageX = containerRect.left + containerRect.width / 2;\\n            pageY = containerRect.top + containerRect.height / 2;\\n        }\\n        else {\\n            // Subtract scroll values from the coordinates because calculations below\\n            // are always relative to the viewport rectangle.\\n            var /** @type {?} */ scrollPosition = this._ruler.getViewportScrollPosition();\\n            pageX -= scrollPosition.left;\\n            pageY -= scrollPosition.top;\\n        }\\n        var /** @type {?} */ radius = config.radius || distanceToFurthestCorner(pageX, pageY, containerRect);\\n        var /** @type {?} */ duration = RIPPLE_FADE_IN_DURATION * (1 / (config.speedFactor || 1));\\n        var /** @type {?} */ offsetX = pageX - containerRect.left;\\n        var /** @type {?} */ offsetY = pageY - containerRect.top;\\n        var /** @type {?} */ ripple = document.createElement(\\'div\\');\\n        ripple.classList.add(\\'mat-ripple-element\\');\\n        ripple.style.left = offsetX - radius + \"px\";\\n        ripple.style.top = offsetY - radius + \"px\";\\n        ripple.style.height = radius * 2 + \"px\";\\n        ripple.style.width = radius * 2 + \"px\";\\n        // If the color is not set, the default CSS color will be used.\\n        ripple.style.backgroundColor = config.color;\\n        ripple.style.transitionDuration = duration + \"ms\";\\n        this._containerElement.appendChild(ripple);\\n        // By default the browser does not recalculate the styles of dynamically created\\n        // ripple elements. This is critical because then the `scale` would not animate properly.\\n        enforceStyleRecalculation(ripple);\\n        ripple.style.transform = \\'scale(1)\\';\\n        // Exposed reference to the ripple that will be returned.\\n        var /** @type {?} */ rippleRef = new RippleRef(this, ripple, config);\\n        rippleRef.state = RippleState.FADING_IN;\\n        // Add the ripple reference to the list of all active ripples.\\n        this._activeRipples.add(rippleRef);\\n        // Wait for the ripple element to be completely faded in.\\n        // Once it\\'s faded in, the ripple can be hidden immediately if the mouse is released.\\n        this.runTimeoutOutsideZone(function () {\\n            rippleRef.state = RippleState.VISIBLE;\\n            if (!config.persistent && !_this._isMousedown) {\\n                rippleRef.fadeOut();\\n            }\\n        }, duration);\\n        return rippleRef;\\n    };\\n    /**\\n     * Fades out a ripple reference.\\n     * @param {?} rippleRef\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.fadeOutRipple = function (rippleRef) {\\n        // For ripples that are not active anymore, don\\'t re-un the fade-out animation.\\n        if (!this._activeRipples.delete(rippleRef)) {\\n            return;\\n        }\\n        var /** @type {?} */ rippleEl = rippleRef.element;\\n        rippleEl.style.transitionDuration = RIPPLE_FADE_OUT_DURATION + \"ms\";\\n        rippleEl.style.opacity = \\'0\\';\\n        rippleRef.state = RippleState.FADING_OUT;\\n        // Once the ripple faded out, the ripple can be safely removed from the DOM.\\n        this.runTimeoutOutsideZone(function () {\\n            rippleRef.state = RippleState.HIDDEN;\\n            rippleEl.parentNode.removeChild(rippleEl);\\n        }, RIPPLE_FADE_OUT_DURATION);\\n    };\\n    /**\\n     * Fades out all currently active ripples.\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.fadeOutAll = function () {\\n        this._activeRipples.forEach(function (ripple) { return ripple.fadeOut(); });\\n    };\\n    /**\\n     * Sets the trigger element and registers the mouse events.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.setTriggerElement = function (element) {\\n        var _this = this;\\n        // Remove all previously register event listeners from the trigger element.\\n        if (this._triggerElement) {\\n            this._triggerEvents.forEach(function (fn, type) { return _this._triggerElement.removeEventListener(type, fn); });\\n        }\\n        if (element) {\\n            // If the element is not null, register all event listeners on the trigger element.\\n            this._ngZone.runOutsideAngular(function () {\\n                _this._triggerEvents.forEach(function (fn, type) { return element.addEventListener(type, fn); });\\n            });\\n        }\\n        this._triggerElement = element;\\n    };\\n    /**\\n     * Listener being called on mousedown event.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.onMousedown = function (event) {\\n        if (!this.rippleDisabled) {\\n            this._isMousedown = true;\\n            this.fadeInRipple(event.pageX, event.pageY, this.rippleConfig);\\n        }\\n    };\\n    /**\\n     * Listener being called on mouseup event.\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.onMouseup = function () {\\n        this._isMousedown = false;\\n        // Fade-out all ripples that are completely visible and not persistent.\\n        this._activeRipples.forEach(function (ripple) {\\n            if (!ripple.config.persistent && ripple.state === RippleState.VISIBLE) {\\n                ripple.fadeOut();\\n            }\\n        });\\n    };\\n    /**\\n     * Listener being called on mouseleave event.\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.onMouseLeave = function () {\\n        if (this._isMousedown) {\\n            this.onMouseup();\\n        }\\n    };\\n    /**\\n     * Runs a timeout outside of the Angular zone to avoid triggering the change detection.\\n     * @param {?} fn\\n     * @param {?=} delay\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.runTimeoutOutsideZone = function (fn, delay) {\\n        if (delay === void 0) { delay = 0; }\\n        this._ngZone.runOutsideAngular(function () { return setTimeout(fn, delay); });\\n    };\\n    return RippleRenderer;\\n}());\\n/**\\n * @param {?} element\\n * @return {?}\\n */\\nfunction enforceStyleRecalculation(element) {\\n    // Enforce a style recalculation by calling `getComputedStyle` and accessing any property.\\n    // Calling `getPropertyValue` is important to let optimizers know that this is not a noop.\\n    // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a\\n    window.getComputedStyle(element).getPropertyValue(\\'opacity\\');\\n}\\n/**\\n * Returns the distance from the point (x, y) to the furthest corner of a rectangle.\\n * @param {?} x\\n * @param {?} y\\n * @param {?} rect\\n * @return {?}\\n */\\nfunction distanceToFurthestCorner(x, y, rect) {\\n    var /** @type {?} */ distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));\\n    var /** @type {?} */ distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));\\n    return Math.sqrt(distX * distX + distY * distY);\\n}\\n// Whether the current platform supports the V8 Break Iterator. The V8 check\\n// is necessary to detect all Blink based browsers.\\nvar hasV8BreakIterator = (typeof (Intl) !== \\'undefined\\' && ((Intl)).v8BreakIterator);\\n/**\\n * Service to detect the current platform by comparing the userAgent strings and\\n * checking browser-specific global properties.\\n * \\\\@docs-private\\n */\\nvar Platform = /*@__PURE__*/(function () {\\n    function Platform() {\\n        this.isBrowser = typeof document === \\'object\\' && !!document;\\n        /**\\n         * Layout Engines\\n         */\\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\\n        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\\n        this.BLINK = this.isBrowser &&\\n            (!!(((window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\\n        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\\n        // ensure that Webkit runs standalone and is not used as another engine\\'s base.\\n        this.WEBKIT = this.isBrowser &&\\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\\n        /**\\n         * Browsers and Platform Types\\n         */\\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\\n        // It\\'s difficult to detect the plain Gecko engine, because most of the browsers identify\\n        // them self as Gecko-like browsers and modify the userAgent\\'s according to that.\\n        // Since we only cover one explicit Firefox case, we can simply check for Firefox\\n        // instead of having an unstable check for Gecko.\\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\\n        // Trident on mobile adds the android platform to the userAgent to trick detections.\\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\\n    }\\n    return Platform;\\n}());\\nPlatform.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nPlatform.ctorParameters = function () { return []; };\\nvar supportedInputTypes;\\n/**\\n * @return {?} The input types supported by this browser.\\n */\\nfunction getSupportedInputTypes() {\\n    if (!supportedInputTypes) {\\n        var /** @type {?} */ featureTestInput_1 = document.createElement(\\'input\\');\\n        supportedInputTypes = new Set([\\n            // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\\n            // first changing it to something else:\\n            // The specified value \"\" does not conform to the required format.\\n            // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\\n            \\'color\\',\\n            \\'button\\',\\n            \\'checkbox\\',\\n            \\'date\\',\\n            \\'datetime-local\\',\\n            \\'email\\',\\n            \\'file\\',\\n            \\'hidden\\',\\n            \\'image\\',\\n            \\'month\\',\\n            \\'number\\',\\n            \\'password\\',\\n            \\'radio\\',\\n            \\'range\\',\\n            \\'reset\\',\\n            \\'search\\',\\n            \\'submit\\',\\n            \\'tel\\',\\n            \\'text\\',\\n            \\'time\\',\\n            \\'url\\',\\n            \\'week\\',\\n        ].filter(function (value) {\\n            featureTestInput_1.setAttribute(\\'type\\', value);\\n            return featureTestInput_1.type === value;\\n        }));\\n    }\\n    return supportedInputTypes;\\n}\\nvar PlatformModule = /*@__PURE__*/(function () {\\n    function PlatformModule() {\\n    }\\n    return PlatformModule;\\n}());\\nPlatformModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                providers: [Platform]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nPlatformModule.ctorParameters = function () { return []; };\\n/**\\n * Time in ms to throttle the scrolling events by default.\\n */\\nvar DEFAULT_SCROLL_TIME = 20;\\n/**\\n * Service contained all registered Scrollable references and emits an event when any one of the\\n * Scrollable references emit a scrolled event.\\n */\\nvar ScrollDispatcher = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _ngZone\\n     * @param {?} _platform\\n     */\\n    function ScrollDispatcher(_ngZone, _platform) {\\n        this._ngZone = _ngZone;\\n        this._platform = _platform;\\n        /**\\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\\n         */\\n        this._scrolled = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        /**\\n         * Keeps track of the global `scroll` and `resize` subscriptions.\\n         */\\n        this._globalSubscription = null;\\n        /**\\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\\n         */\\n        this._scrolledCount = 0;\\n        /**\\n         * Map of all the scrollable references that are registered with the service and their\\n         * scroll event subscriptions.\\n         */\\n        this.scrollableReferences = new Map();\\n    }\\n    /**\\n     * Registers a Scrollable with the service and listens for its scrolled events. When the\\n     * scrollable is scrolled, the service emits the event in its scrolled observable.\\n     * @param {?} scrollable Scrollable instance to be registered.\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype.register = function (scrollable) {\\n        var _this = this;\\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled().subscribe(function () { return _this._notify(); });\\n        this.scrollableReferences.set(scrollable, scrollSubscription);\\n    };\\n    /**\\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\\n     * @param {?} scrollable Scrollable instance to be deregistered.\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype.deregister = function (scrollable) {\\n        if (this.scrollableReferences.has(scrollable)) {\\n            this.scrollableReferences.get(scrollable).unsubscribe();\\n            this.scrollableReferences.delete(scrollable);\\n        }\\n    };\\n    /**\\n     * Subscribes to an observable that emits an event whenever any of the registered Scrollable\\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\\n     * to override the default \"throttle\" time.\\n     * @param {?=} auditTimeInMs\\n     * @param {?=} callback\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype.scrolled = function (auditTimeInMs, callback) {\\n        var _this = this;\\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\\n        // Scroll events can only happen on the browser, so do nothing if we\\'re not on the browser.\\n        if (!this._platform.isBrowser) {\\n            return __WEBPACK_IMPORTED_MODULE_7_rxjs_Subscription__[\"Subscription\"].EMPTY;\\n        }\\n        // In the case of a 0ms delay, use an observable without auditTime\\n        // since it does add a perceptible delay in processing overhead.\\n        var /** @type {?} */ observable = auditTimeInMs > 0 ?\\n            this._scrolled.asObservable().auditTime(auditTimeInMs) :\\n            this._scrolled.asObservable();\\n        this._scrolledCount++;\\n        if (!this._globalSubscription) {\\n            this._globalSubscription = this._ngZone.runOutsideAngular(function () {\\n                return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].merge(__WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].fromEvent(window.document, \\'scroll\\'), __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].fromEvent(window, \\'resize\\')).subscribe(function () { return _this._notify(); });\\n            });\\n        }\\n        // Note that we need to do the subscribing from here, in order to be able to remove\\n        // the global event listeners once there are no more subscriptions.\\n        var /** @type {?} */ subscription = observable.subscribe(callback);\\n        subscription.add(function () {\\n            _this._scrolledCount--;\\n            if (_this._globalSubscription && !_this.scrollableReferences.size && !_this._scrolledCount) {\\n                _this._globalSubscription.unsubscribe();\\n                _this._globalSubscription = null;\\n            }\\n        });\\n        return subscription;\\n    };\\n    /**\\n     * Returns all registered Scrollables that contain the provided element.\\n     * @param {?} elementRef\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype.getScrollContainers = function (elementRef) {\\n        var _this = this;\\n        var /** @type {?} */ scrollingContainers = [];\\n        this.scrollableReferences.forEach(function (subscription, scrollable) {\\n            if (_this.scrollableContainsElement(scrollable, elementRef)) {\\n                scrollingContainers.push(scrollable);\\n            }\\n        });\\n        return scrollingContainers;\\n    };\\n    /**\\n     * Returns true if the element is contained within the provided Scrollable.\\n     * @param {?} scrollable\\n     * @param {?} elementRef\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype.scrollableContainsElement = function (scrollable, elementRef) {\\n        var /** @type {?} */ element = elementRef.nativeElement;\\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\\n        // Traverse through the element parents until we reach null, checking if any of the elements\\n        // are the scrollable\\'s element.\\n        do {\\n            if (element == scrollableElement) {\\n                return true;\\n            }\\n        } while (element = element.parentElement);\\n    };\\n    /**\\n     * Sends a notification that a scroll event has been fired.\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype._notify = function () {\\n        this._scrolled.next();\\n    };\\n    return ScrollDispatcher;\\n}());\\nScrollDispatcher.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nScrollDispatcher.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: Platform, },\\n]; };\\n/**\\n * @param {?} parentDispatcher\\n * @param {?} ngZone\\n * @param {?} platform\\n * @return {?}\\n */\\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\\n    return parentDispatcher || new ScrollDispatcher(ngZone, platform);\\n}\\nvar SCROLL_DISPATCHER_PROVIDER = {\\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\\n    provide: ScrollDispatcher,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), ScrollDispatcher], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], Platform],\\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\\n};\\n/**\\n * Simple utility for getting the bounds of the browser viewport.\\n * \\\\@docs-private\\n */\\nvar ViewportRuler = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} scrollDispatcher\\n     */\\n    function ViewportRuler(scrollDispatcher) {\\n        var _this = this;\\n        // Subscribe to scroll and resize events and update the document rectangle on changes.\\n        scrollDispatcher.scrolled(null, function () { return _this._cacheViewportGeometry(); });\\n    }\\n    /**\\n     * Gets a ClientRect for the viewport\\'s bounds.\\n     * @param {?=} documentRect\\n     * @return {?}\\n     */\\n    ViewportRuler.prototype.getViewportRect = function (documentRect) {\\n        if (documentRect === void 0) { documentRect = this._documentRect; }\\n        // Cache the document bounding rect so that we don\\'t recompute it for multiple calls.\\n        if (!documentRect) {\\n            this._cacheViewportGeometry();\\n            documentRect = this._documentRect;\\n        }\\n        // Use the document element\\'s bounding rect rather than the window scroll properties\\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\\n        // We use the documentElement instead of the body because, by default (without a css reset)\\n        // browsers typically give the document body an 8px margin, which is not included in\\n        // getBoundingClientRect().\\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition(documentRect);\\n        var /** @type {?} */ height = window.innerHeight;\\n        var /** @type {?} */ width = window.innerWidth;\\n        return {\\n            top: scrollPosition.top,\\n            left: scrollPosition.left,\\n            bottom: scrollPosition.top + height,\\n            right: scrollPosition.left + width,\\n            height: height,\\n            width: width,\\n        };\\n    };\\n    /**\\n     * Gets the (top, left) scroll position of the viewport.\\n     * @param {?=} documentRect\\n     * @return {?}\\n     */\\n    ViewportRuler.prototype.getViewportScrollPosition = function (documentRect) {\\n        if (documentRect === void 0) { documentRect = this._documentRect; }\\n        // Cache the document bounding rect so that we don\\'t recompute it for multiple calls.\\n        if (!documentRect) {\\n            this._cacheViewportGeometry();\\n            documentRect = this._documentRect;\\n        }\\n        // The top-left-corner of the viewport is determined by the scroll position of the document\\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\\n        // `document.documentElement` works consistently, where the `top` and `left` values will\\n        // equal negative the scroll position.\\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\\n            document.documentElement.scrollTop || 0;\\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\\n            document.documentElement.scrollLeft || 0;\\n        return { top: top, left: left };\\n    };\\n    /**\\n     * Caches the latest client rectangle of the document element.\\n     * @return {?}\\n     */\\n    ViewportRuler.prototype._cacheViewportGeometry = function () {\\n        this._documentRect = document.documentElement.getBoundingClientRect();\\n    };\\n    return ViewportRuler;\\n}());\\nViewportRuler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nViewportRuler.ctorParameters = function () { return [\\n    { type: ScrollDispatcher, },\\n]; };\\n/**\\n * @param {?} parentRuler\\n * @param {?} scrollDispatcher\\n * @return {?}\\n */\\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, scrollDispatcher) {\\n    return parentRuler || new ViewportRuler(scrollDispatcher);\\n}\\nvar VIEWPORT_RULER_PROVIDER = {\\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\\n    provide: ViewportRuler,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), ViewportRuler], ScrollDispatcher],\\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\\n};\\n/**\\n * Injection token that can be used to specify the global ripple options.\\n */\\nvar MD_RIPPLE_GLOBAL_OPTIONS = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-ripple-global-options\\');\\nvar MdRipple = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementRef\\n     * @param {?} ngZone\\n     * @param {?} ruler\\n     * @param {?} platform\\n     * @param {?} globalOptions\\n     */\\n    function MdRipple(elementRef, ngZone, ruler, platform, globalOptions) {\\n        /**\\n         * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius\\n         * will be the distance from the center of the ripple to the furthest corner of the host element\\'s\\n         * bounding rectangle.\\n         */\\n        this.radius = 0;\\n        /**\\n         * If set, the normal duration of ripple animations is divided by this value. For example,\\n         * setting it to 0.5 will cause the animations to take twice as long.\\n         * A changed speedFactor will not modify the fade-out duration of the ripples.\\n         */\\n        this.speedFactor = 1;\\n        this._rippleRenderer = new RippleRenderer(elementRef, ngZone, ruler, platform);\\n        this._globalOptions = globalOptions ? globalOptions : {};\\n        this._updateRippleRenderer();\\n    }\\n    /**\\n     * @param {?} changes\\n     * @return {?}\\n     */\\n    MdRipple.prototype.ngOnChanges = function (changes) {\\n        if (changes[\\'trigger\\'] && this.trigger) {\\n            this._rippleRenderer.setTriggerElement(this.trigger);\\n        }\\n        this._updateRippleRenderer();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRipple.prototype.ngOnDestroy = function () {\\n        // Set the trigger element to null to cleanup all listeners.\\n        this._rippleRenderer.setTriggerElement(null);\\n    };\\n    /**\\n     * Launches a manual ripple at the specified position.\\n     * @param {?} pageX\\n     * @param {?} pageY\\n     * @param {?=} config\\n     * @return {?}\\n     */\\n    MdRipple.prototype.launch = function (pageX, pageY, config) {\\n        if (config === void 0) { config = this.rippleConfig; }\\n        return this._rippleRenderer.fadeInRipple(pageX, pageY, config);\\n    };\\n    /**\\n     * Fades out all currently showing ripple elements.\\n     * @return {?}\\n     */\\n    MdRipple.prototype.fadeOutAll = function () {\\n        this._rippleRenderer.fadeOutAll();\\n    };\\n    Object.defineProperty(MdRipple.prototype, \"rippleConfig\", {\\n        /**\\n         * Ripple configuration from the directive\\'s input values.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return {\\n                centered: this.centered,\\n                speedFactor: this.speedFactor * (this._globalOptions.baseSpeedFactor || 1),\\n                radius: this.radius,\\n                color: this.color\\n            };\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Updates the ripple renderer with the latest ripple configuration.\\n     * @return {?}\\n     */\\n    MdRipple.prototype._updateRippleRenderer = function () {\\n        this._rippleRenderer.rippleDisabled = this._globalOptions.disabled || this.disabled;\\n        this._rippleRenderer.rippleConfig = this.rippleConfig;\\n    };\\n    return MdRipple;\\n}());\\nMdRipple.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-ripple], [mat-ripple], [mdRipple], [matRipple]\\',\\n                exportAs: \\'mdRipple\\',\\n                host: {\\n                    \\'class\\': \\'mat-ripple\\',\\n                    \\'[class.mat-ripple-unbounded]\\': \\'unbounded\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRipple.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: ViewportRuler, },\\n    { type: Platform, },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_RIPPLE_GLOBAL_OPTIONS,] },] },\\n]; };\\nMdRipple.propDecorators = {\\n    \\'trigger\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleTrigger\\',] },],\\n    \\'centered\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleCentered\\',] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleDisabled\\',] },],\\n    \\'radius\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleRadius\\',] },],\\n    \\'speedFactor\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleSpeedFactor\\',] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleColor\\',] },],\\n    \\'unbounded\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleUnbounded\\',] },],\\n};\\n/**\\n * Sends an event when the directive\\'s element is scrolled. Registers itself with the\\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\\n * can be listened to through the service.\\n */\\nvar Scrollable = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _scroll\\n     * @param {?} _ngZone\\n     * @param {?} _renderer\\n     */\\n    function Scrollable(_elementRef, _scroll, _ngZone, _renderer) {\\n        this._elementRef = _elementRef;\\n        this._scroll = _scroll;\\n        this._ngZone = _ngZone;\\n        this._renderer = _renderer;\\n        this._elementScrolled = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    Scrollable.prototype.ngOnInit = function () {\\n        var _this = this;\\n        this._scrollListener = this._ngZone.runOutsideAngular(function () {\\n            return _this._renderer.listen(_this.getElementRef().nativeElement, \\'scroll\\', function (event) {\\n                _this._elementScrolled.next(event);\\n            });\\n        });\\n        this._scroll.register(this);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    Scrollable.prototype.ngOnDestroy = function () {\\n        this._scroll.deregister(this);\\n        if (this._scrollListener) {\\n            this._scrollListener();\\n            this._scrollListener = null;\\n        }\\n    };\\n    /**\\n     * Returns observable that emits when a scroll event is fired on the host element.\\n     * @return {?}\\n     */\\n    Scrollable.prototype.elementScrolled = function () {\\n        return this._elementScrolled.asObservable();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    Scrollable.prototype.getElementRef = function () {\\n        return this._elementRef;\\n    };\\n    return Scrollable;\\n}());\\nScrollable.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdk-scrollable], [cdkScrollable]\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nScrollable.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: ScrollDispatcher, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\n/**\\n * Strategy that will update the element position as the user is scrolling.\\n */\\nvar RepositionScrollStrategy = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _scrollDispatcher\\n     * @param {?=} _scrollThrottle\\n     */\\n    function RepositionScrollStrategy(_scrollDispatcher, _scrollThrottle) {\\n        if (_scrollThrottle === void 0) { _scrollThrottle = 0; }\\n        this._scrollDispatcher = _scrollDispatcher;\\n        this._scrollThrottle = _scrollThrottle;\\n        this._scrollSubscription = null;\\n    }\\n    /**\\n     * @param {?} overlayRef\\n     * @return {?}\\n     */\\n    RepositionScrollStrategy.prototype.attach = function (overlayRef) {\\n        this._overlayRef = overlayRef;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    RepositionScrollStrategy.prototype.enable = function () {\\n        var _this = this;\\n        if (!this._scrollSubscription) {\\n            this._scrollSubscription = this._scrollDispatcher.scrolled(this._scrollThrottle, function () {\\n                _this._overlayRef.updatePosition();\\n            });\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    RepositionScrollStrategy.prototype.disable = function () {\\n        if (this._scrollSubscription) {\\n            this._scrollSubscription.unsubscribe();\\n            this._scrollSubscription = null;\\n        }\\n    };\\n    return RepositionScrollStrategy;\\n}());\\n/**\\n * Strategy that will close the overlay as soon as the user starts scrolling.\\n */\\nvar CloseScrollStrategy = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _scrollDispatcher\\n     */\\n    function CloseScrollStrategy(_scrollDispatcher) {\\n        this._scrollDispatcher = _scrollDispatcher;\\n        this._scrollSubscription = null;\\n    }\\n    /**\\n     * @param {?} overlayRef\\n     * @return {?}\\n     */\\n    CloseScrollStrategy.prototype.attach = function (overlayRef) {\\n        this._overlayRef = overlayRef;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    CloseScrollStrategy.prototype.enable = function () {\\n        var _this = this;\\n        if (!this._scrollSubscription) {\\n            this._scrollSubscription = this._scrollDispatcher.scrolled(null, function () {\\n                if (_this._overlayRef.hasAttached()) {\\n                    _this._overlayRef.detach();\\n                }\\n                _this.disable();\\n            });\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    CloseScrollStrategy.prototype.disable = function () {\\n        if (this._scrollSubscription) {\\n            this._scrollSubscription.unsubscribe();\\n            this._scrollSubscription = null;\\n        }\\n    };\\n    return CloseScrollStrategy;\\n}());\\n/**\\n * Scroll strategy that doesn\\'t do anything.\\n */\\nvar NoopScrollStrategy = /*@__PURE__*/(function () {\\n    function NoopScrollStrategy() {\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    NoopScrollStrategy.prototype.enable = function () { };\\n    /**\\n     * @return {?}\\n     */\\n    NoopScrollStrategy.prototype.disable = function () { };\\n    /**\\n     * @return {?}\\n     */\\n    NoopScrollStrategy.prototype.attach = function () { };\\n    return NoopScrollStrategy;\\n}());\\n/**\\n * Strategy that will prevent the user from scrolling while the overlay is visible.\\n */\\nvar BlockScrollStrategy = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _viewportRuler\\n     */\\n    function BlockScrollStrategy(_viewportRuler) {\\n        this._viewportRuler = _viewportRuler;\\n        this._previousHTMLStyles = { top: null, left: null };\\n        this._isEnabled = false;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    BlockScrollStrategy.prototype.attach = function () { };\\n    /**\\n     * @return {?}\\n     */\\n    BlockScrollStrategy.prototype.enable = function () {\\n        if (this._canBeEnabled()) {\\n            var /** @type {?} */ root = document.documentElement;\\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\\n            // Cache the previous inline styles in case the user had set them.\\n            this._previousHTMLStyles.left = root.style.left;\\n            this._previousHTMLStyles.top = root.style.top;\\n            // Note: we\\'re using the `html` node, instead of the `body`, because the `body` may\\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\\n            root.style.left = -this._previousScrollPosition.left + \"px\";\\n            root.style.top = -this._previousScrollPosition.top + \"px\";\\n            root.classList.add(\\'cdk-global-scrollblock\\');\\n            this._isEnabled = true;\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    BlockScrollStrategy.prototype.disable = function () {\\n        if (this._isEnabled) {\\n            this._isEnabled = false;\\n            document.documentElement.style.left = this._previousHTMLStyles.left;\\n            document.documentElement.style.top = this._previousHTMLStyles.top;\\n            document.documentElement.classList.remove(\\'cdk-global-scrollblock\\');\\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    BlockScrollStrategy.prototype._canBeEnabled = function () {\\n        // Since the scroll strategies can\\'t be singletons, we have to use a global CSS class\\n        // (`cdk-global-scrollblock`) to make sure that we don\\'t try to disable global\\n        // scrolling multiple times.\\n        if (document.documentElement.classList.contains(\\'cdk-global-scrollblock\\') || this._isEnabled) {\\n            return false;\\n        }\\n        var /** @type {?} */ body = document.body;\\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportRect();\\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\\n    };\\n    return BlockScrollStrategy;\\n}());\\nvar ScrollDispatchModule = /*@__PURE__*/(function () {\\n    function ScrollDispatchModule() {\\n    }\\n    return ScrollDispatchModule;\\n}());\\nScrollDispatchModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [PlatformModule],\\n                exports: [Scrollable],\\n                declarations: [Scrollable],\\n                providers: [SCROLL_DISPATCHER_PROVIDER],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nScrollDispatchModule.ctorParameters = function () { return []; };\\nvar MdRippleModule = /*@__PURE__*/(function () {\\n    function MdRippleModule() {\\n    }\\n    return MdRippleModule;\\n}());\\nMdRippleModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule, PlatformModule, ScrollDispatchModule],\\n                exports: [MdRipple, MdCommonModule],\\n                declarations: [MdRipple],\\n                providers: [VIEWPORT_RULER_PROVIDER],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRippleModule.ctorParameters = function () { return []; };\\n/**\\n * Component that shows a simplified checkbox without including any kind of \"real\" checkbox.\\n * Meant to be used when the checkbox is purely decorative and a large number of them will be\\n * included, such as for the options in a multi-select. Uses no SVGs or complex animations.\\n *\\n * Note that this component will be completely invisible to screen-reader users. This is *not*\\n * interchangeable with <md-checkbox> and should *not* be used if the user would directly interact\\n * with the checkbox. The pseudo-checkbox should only be used as an implementation detail of\\n * more complex components that appropriately handle selected / checked state.\\n * \\\\@docs-private\\n */\\nvar MdPseudoCheckbox = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     */\\n    function MdPseudoCheckbox(_elementRef, _renderer) {\\n        this._elementRef = _elementRef;\\n        this._renderer = _renderer;\\n        /**\\n         * Display state of the checkbox.\\n         */\\n        this.state = \\'unchecked\\';\\n        /**\\n         * Whether the checkbox is disabled.\\n         */\\n        this.disabled = false;\\n        this.color = \\'accent\\';\\n    }\\n    Object.defineProperty(MdPseudoCheckbox.prototype, \"color\", {\\n        /**\\n         * Color of the checkbox.\\n         * @return {?}\\n         */\\n        get: function () { return this._color; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value) {\\n                var /** @type {?} */ nativeElement = this._elementRef.nativeElement;\\n                this._renderer.removeClass(nativeElement, \"mat-\" + this.color);\\n                this._renderer.addClass(nativeElement, \"mat-\" + value);\\n                this._color = value;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return MdPseudoCheckbox;\\n}());\\nMdPseudoCheckbox.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                selector: \\'md-pseudo-checkbox, mat-pseudo-checkbox\\',\\n                styles: [\".mat-pseudo-checkbox{width:20px;height:20px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;transition:border-color 90ms cubic-bezier(0,0,.2,.1),background-color 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:\\'\\';border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:9px;left:2px;width:16px;opacity:1}.mat-pseudo-checkbox-checked::after{top:5px;left:3px;width:12px;height:5px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1} /*# sourceMappingURL=pseudo-checkbox.css.map */ \"],\\n                template: \\'\\',\\n                host: {\\n                    \\'[class.mat-pseudo-checkbox]\\': \\'true\\',\\n                    \\'[class.mat-pseudo-checkbox-indeterminate]\\': \\'state === \"indeterminate\"\\',\\n                    \\'[class.mat-pseudo-checkbox-checked]\\': \\'state === \"checked\"\\',\\n                    \\'[class.mat-pseudo-checkbox-disabled]\\': \\'disabled\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPseudoCheckbox.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\nMdPseudoCheckbox.propDecorators = {\\n    \\'state\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdSelectionModule = /*@__PURE__*/(function () {\\n    function MdSelectionModule() {\\n    }\\n    return MdSelectionModule;\\n}());\\nMdSelectionModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                exports: [MdPseudoCheckbox],\\n                declarations: [MdPseudoCheckbox]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSelectionModule.ctorParameters = function () { return []; };\\n/**\\n * Option IDs need to be unique across components, so this counter exists outside of\\n * the component definition.\\n */\\nvar _uniqueIdCounter = 0;\\n/**\\n * Event object emitted by MdOption when selected or deselected.\\n */\\nvar MdOptionSelectionChange = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} source\\n     * @param {?=} isUserInput\\n     */\\n    function MdOptionSelectionChange(source, isUserInput) {\\n        if (isUserInput === void 0) { isUserInput = false; }\\n        this.source = source;\\n        this.isUserInput = isUserInput;\\n    }\\n    return MdOptionSelectionChange;\\n}());\\n/**\\n * Single option inside of a `<md-select>` element.\\n */\\nvar MdOption = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _element\\n     * @param {?} _isCompatibilityMode\\n     */\\n    function MdOption(_element, _isCompatibilityMode) {\\n        this._element = _element;\\n        this._isCompatibilityMode = _isCompatibilityMode;\\n        this._selected = false;\\n        this._active = false;\\n        /**\\n         * Whether the option is disabled.\\n         */\\n        this._disabled = false;\\n        this._id = \"md-option-\" + _uniqueIdCounter++;\\n        /**\\n         * Whether the wrapping component is in multiple selection mode.\\n         */\\n        this.multiple = false;\\n        /**\\n         * Event emitted when the option is selected or deselected.\\n         */\\n        this.onSelectionChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(MdOption.prototype, \"id\", {\\n        /**\\n         * The unique ID of the option.\\n         * @return {?}\\n         */\\n        get: function () { return this._id; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdOption.prototype, \"selected\", {\\n        /**\\n         * Whether or not the option is currently selected.\\n         * @return {?}\\n         */\\n        get: function () { return this._selected; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdOption.prototype, \"disabled\", {\\n        /**\\n         * Whether the option is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disabled; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disabled = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdOption.prototype, \"active\", {\\n        /**\\n         * Whether or not the option is currently active and ready to be selected.\\n         * An active option displays styles as if it is focused, but the\\n         * focus is actually retained somewhere else. This comes in handy\\n         * for components like autocomplete where focus must remain on the input.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._active;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdOption.prototype, \"viewValue\", {\\n        /**\\n         * The displayed value of the option. It is necessary to show the selected option in the\\n         * select\\'s trigger.\\n         * @return {?}\\n         */\\n        get: function () {\\n            // TODO(kara): Add input property alternative for node envs.\\n            return this._getHostElement().textContent.trim();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Selects the option.\\n     * @return {?}\\n     */\\n    MdOption.prototype.select = function () {\\n        this._selected = true;\\n        this._emitSelectionChangeEvent();\\n    };\\n    /**\\n     * Deselects the option.\\n     * @return {?}\\n     */\\n    MdOption.prototype.deselect = function () {\\n        this._selected = false;\\n        this._emitSelectionChangeEvent();\\n    };\\n    /**\\n     * Sets focus onto this option.\\n     * @return {?}\\n     */\\n    MdOption.prototype.focus = function () {\\n        this._getHostElement().focus();\\n    };\\n    /**\\n     * This method sets display styles on the option to make it appear\\n     * active. This is used by the ActiveDescendantKeyManager so key\\n     * events will display the proper options as active on arrow key events.\\n     * @return {?}\\n     */\\n    MdOption.prototype.setActiveStyles = function () {\\n        this._active = true;\\n    };\\n    /**\\n     * This method removes display styles on the option that made it appear\\n     * active. This is used by the ActiveDescendantKeyManager so key\\n     * events will display the proper options as active on arrow key events.\\n     * @return {?}\\n     */\\n    MdOption.prototype.setInactiveStyles = function () {\\n        this._active = false;\\n    };\\n    /**\\n     * Ensures the option is selected when activated from the keyboard.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdOption.prototype._handleKeydown = function (event) {\\n        if (event.keyCode === ENTER || event.keyCode === SPACE) {\\n            this._selectViaInteraction();\\n        }\\n    };\\n    /**\\n     * Selects the option while indicating the selection came from the user. Used to\\n     * determine if the select\\'s view -> model callback should be invoked.\\n     * @return {?}\\n     */\\n    MdOption.prototype._selectViaInteraction = function () {\\n        if (!this.disabled) {\\n            this._selected = this.multiple ? !this._selected : true;\\n            this._emitSelectionChangeEvent(true);\\n        }\\n    };\\n    /**\\n     * Returns the correct tabindex for the option depending on disabled state.\\n     * @return {?}\\n     */\\n    MdOption.prototype._getTabIndex = function () {\\n        return this.disabled ? \\'-1\\' : \\'0\\';\\n    };\\n    /**\\n     * Fetches the host DOM element.\\n     * @return {?}\\n     */\\n    MdOption.prototype._getHostElement = function () {\\n        return this._element.nativeElement;\\n    };\\n    /**\\n     * Emits the selection change event.\\n     * @param {?=} isUserInput\\n     * @return {?}\\n     */\\n    MdOption.prototype._emitSelectionChangeEvent = function (isUserInput) {\\n        if (isUserInput === void 0) { isUserInput = false; }\\n        this.onSelectionChange.emit(new MdOptionSelectionChange(this, isUserInput));\\n    };\\n    return MdOption;\\n}());\\nMdOption.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-option, mat-option\\',\\n                host: {\\n                    \\'role\\': \\'option\\',\\n                    \\'[attr.tabindex]\\': \\'_getTabIndex()\\',\\n                    \\'[class.mat-selected]\\': \\'selected\\',\\n                    \\'[class.mat-option-multiple]\\': \\'multiple\\',\\n                    \\'[class.mat-active]\\': \\'active\\',\\n                    \\'[id]\\': \\'id\\',\\n                    \\'[attr.aria-selected]\\': \\'selected.toString()\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled.toString()\\',\\n                    \\'[class.mat-option-disabled]\\': \\'disabled\\',\\n                    \\'(click)\\': \\'_selectViaInteraction()\\',\\n                    \\'(keydown)\\': \\'_handleKeydown($event)\\',\\n                    \\'[class.mat-option]\\': \\'true\\',\\n                },\\n                template: \"<span [ngSwitch]=\\\\\"_isCompatibilityMode\\\\\" *ngIf=\\\\\"multiple\\\\\"> <mat-pseudo-checkbox class=\\\\\"mat-option-pseudo-checkbox\\\\\" *ngSwitchCase=\\\\\"true\\\\\" [state]=\\\\\"selected ? \\'checked\\' : \\'\\'\\\\\" color=\\\\\"primary\\\\\"></mat-pseudo-checkbox> <md-pseudo-checkbox class=\\\\\"mat-option-pseudo-checkbox\\\\\" *ngSwitchDefault [state]=\\\\\"selected ? \\'checked\\' : \\'\\'\\\\\" color=\\\\\"primary\\\\\"></md-pseudo-checkbox> </span> <ng-content></ng-content> <div class=\\\\\"mat-option-ripple\\\\\" *ngIf=\\\\\"!disabled\\\\\" md-ripple [mdRippleTrigger]=\\\\\"_getHostElement()\\\\\"> </div> \",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdOption.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MATERIAL_COMPATIBILITY_MODE,] },] },\\n]; };\\nMdOption.propDecorators = {\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'onSelectionChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdOptionModule = /*@__PURE__*/(function () {\\n    function MdOptionModule() {\\n    }\\n    return MdOptionModule;\\n}());\\nMdOptionModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdRippleModule, __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"], MdSelectionModule],\\n                exports: [MdOption],\\n                declarations: [MdOption]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdOptionModule.ctorParameters = function () { return []; };\\n/**\\n * Throws an exception when attempting to attach a null portal to a host.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwNullPortalError() {\\n    throw new Error(\\'Must provide a portal to attach\\');\\n}\\n/**\\n * Throws an exception when attempting to attach a portal to a host that is already attached.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwPortalAlreadyAttachedError() {\\n    throw new Error(\\'Host already has a portal attached\\');\\n}\\n/**\\n * Throws an exception when attempting to attach a portal to an already-disposed host.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwPortalHostAlreadyDisposedError() {\\n    throw new Error(\\'This PortalHost has already been disposed\\');\\n}\\n/**\\n * Throws an exception when attempting to attach an unknown portal type.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwUnknownPortalTypeError() {\\n    throw new Error(\\'Attempting to attach an unknown Portal type. BasePortalHost accepts either\\' +\\n        \\'a ComponentPortal or a TemplatePortal.\\');\\n}\\n/**\\n * Throws an exception when attempting to attach a portal to a null host.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwNullPortalHostError() {\\n    throw new Error(\\'Attempting to attach a portal to a null PortalHost\\');\\n}\\n/**\\n * Throws an exception when attempting to detach a portal that is not attached.\\n * \\\\@docs-privatew\\n * @return {?}\\n */\\nfunction throwNoPortalAttachedError() {\\n    throw new Error(\\'Attempting to detach a portal that is not attached to a host\\');\\n}\\n/**\\n * A `Portal` is something that you want to render somewhere else.\\n * It can be attach to / detached from a `PortalHost`.\\n * @abstract\\n */\\nvar Portal = /*@__PURE__*/(function () {\\n    function Portal() {\\n    }\\n    /**\\n     * Attach this portal to a host.\\n     * @param {?} host\\n     * @return {?}\\n     */\\n    Portal.prototype.attach = function (host) {\\n        if (host == null) {\\n            throwNullPortalHostError();\\n        }\\n        if (host.hasAttached()) {\\n            throwPortalAlreadyAttachedError();\\n        }\\n        this._attachedHost = host;\\n        return (host.attach(this));\\n    };\\n    /**\\n     * Detach this portal from its host\\n     * @return {?}\\n     */\\n    Portal.prototype.detach = function () {\\n        var /** @type {?} */ host = this._attachedHost;\\n        if (host == null) {\\n            throwNoPortalAttachedError();\\n        }\\n        this._attachedHost = null;\\n        return host.detach();\\n    };\\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\\n        /**\\n         * Whether this portal is attached to a host.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._attachedHost != null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the PortalHost reference without performing `attach()`. This is used directly by\\n     * the PortalHost when it is performing an `attach()` or `detach()`.\\n     * @param {?} host\\n     * @return {?}\\n     */\\n    Portal.prototype.setAttachedHost = function (host) {\\n        this._attachedHost = host;\\n    };\\n    return Portal;\\n}());\\n/**\\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\\n */\\nvar ComponentPortal = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ComponentPortal, _super);\\n    /**\\n     * @param {?} component\\n     * @param {?=} viewContainerRef\\n     * @param {?=} injector\\n     */\\n    function ComponentPortal(component, viewContainerRef, injector) {\\n        if (viewContainerRef === void 0) { viewContainerRef = null; }\\n        if (injector === void 0) { injector = null; }\\n        var _this = _super.call(this) || this;\\n        _this.component = component;\\n        _this.viewContainerRef = viewContainerRef;\\n        _this.injector = injector;\\n        return _this;\\n    }\\n    return ComponentPortal;\\n}(Portal));\\n/**\\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\\n */\\nvar TemplatePortal = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](TemplatePortal, _super);\\n    /**\\n     * @param {?} template\\n     * @param {?} viewContainerRef\\n     */\\n    function TemplatePortal(template, viewContainerRef) {\\n        var _this = _super.call(this) || this;\\n        /**\\n         * Additional locals for the instantiated embedded view.\\n         * These locals can be seen as \"exports\" for the template, such as how ngFor has\\n         * index / event / odd.\\n         * See https://angular.io/docs/ts/latest/api/core/EmbeddedViewRef-class.html\\n         */\\n        _this.locals = new Map();\\n        _this.templateRef = template;\\n        _this.viewContainerRef = viewContainerRef;\\n        return _this;\\n    }\\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.templateRef.elementRef;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} host\\n     * @param {?=} locals\\n     * @return {?}\\n     */\\n    TemplatePortal.prototype.attach = function (host, locals) {\\n        this.locals = locals == null ? new Map() : locals;\\n        return _super.prototype.attach.call(this, host);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    TemplatePortal.prototype.detach = function () {\\n        this.locals = new Map();\\n        return _super.prototype.detach.call(this);\\n    };\\n    return TemplatePortal;\\n}(Portal));\\n/**\\n * Partial implementation of PortalHost that only deals with attaching either a\\n * ComponentPortal or a TemplatePortal.\\n * @abstract\\n */\\nvar BasePortalHost = /*@__PURE__*/(function () {\\n    function BasePortalHost() {\\n        /**\\n         * Whether this host has already been permanently disposed.\\n         */\\n        this._isDisposed = false;\\n    }\\n    /**\\n     * Whether this host has an attached portal.\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.hasAttached = function () {\\n        return !!this._attachedPortal;\\n    };\\n    /**\\n     * @param {?} portal\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.attach = function (portal) {\\n        if (!portal) {\\n            throwNullPortalError();\\n        }\\n        if (this.hasAttached()) {\\n            throwPortalAlreadyAttachedError();\\n        }\\n        if (this._isDisposed) {\\n            throwPortalHostAlreadyDisposedError();\\n        }\\n        if (portal instanceof ComponentPortal) {\\n            this._attachedPortal = portal;\\n            return this.attachComponentPortal(portal);\\n        }\\n        else if (portal instanceof TemplatePortal) {\\n            this._attachedPortal = portal;\\n            return this.attachTemplatePortal(portal);\\n        }\\n        throwUnknownPortalTypeError();\\n    };\\n    /**\\n     * @abstract\\n     * @template T\\n     * @param {?} portal\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.attachComponentPortal = function (portal) { };\\n    /**\\n     * @abstract\\n     * @param {?} portal\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.attachTemplatePortal = function (portal) { };\\n    /**\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.detach = function () {\\n        if (this._attachedPortal) {\\n            this._attachedPortal.setAttachedHost(null);\\n            this._attachedPortal = null;\\n        }\\n        this._invokeDisposeFn();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.dispose = function () {\\n        if (this.hasAttached()) {\\n            this.detach();\\n        }\\n        this._invokeDisposeFn();\\n        this._isDisposed = true;\\n    };\\n    /**\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.setDisposeFn = function (fn) {\\n        this._disposeFn = fn;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype._invokeDisposeFn = function () {\\n        if (this._disposeFn) {\\n            this._disposeFn();\\n            this._disposeFn = null;\\n        }\\n    };\\n    return BasePortalHost;\\n}());\\n/**\\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\\n *\\n * Usage:\\n * <ng-template portal #greeting>\\n *   <p> Hello {{name}} </p>\\n * </ng-template>\\n */\\nvar TemplatePortalDirective = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](TemplatePortalDirective, _super);\\n    /**\\n     * @param {?} templateRef\\n     * @param {?} viewContainerRef\\n     */\\n    function TemplatePortalDirective(templateRef, viewContainerRef) {\\n        return _super.call(this, templateRef, viewContainerRef) || this;\\n    }\\n    return TemplatePortalDirective;\\n}(TemplatePortal));\\nTemplatePortalDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdk-portal], [cdkPortal], [portal]\\',\\n                exportAs: \\'cdkPortal\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nTemplatePortalDirective.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\n/**\\n * Directive version of a PortalHost. Because the directive *is* a PortalHost, portals can be\\n * directly attached to it, enabling declarative use.\\n *\\n * Usage:\\n * <ng-template [cdkPortalHost]=\"greeting\"></ng-template>\\n */\\nvar PortalHostDirective = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](PortalHostDirective, _super);\\n    /**\\n     * @param {?} _componentFactoryResolver\\n     * @param {?} _viewContainerRef\\n     */\\n    function PortalHostDirective(_componentFactoryResolver, _viewContainerRef) {\\n        var _this = _super.call(this) || this;\\n        _this._componentFactoryResolver = _componentFactoryResolver;\\n        _this._viewContainerRef = _viewContainerRef;\\n        return _this;\\n    }\\n    Object.defineProperty(PortalHostDirective.prototype, \"_deprecatedPortal\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this.portal; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.portal = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(PortalHostDirective.prototype, \"portal\", {\\n        /**\\n         * Portal associated with the Portal host.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._portal;\\n        },\\n        /**\\n         * @param {?} portal\\n         * @return {?}\\n         */\\n        set: function (portal) {\\n            if (this.hasAttached()) {\\n                _super.prototype.detach.call(this);\\n            }\\n            if (portal) {\\n                _super.prototype.attach.call(this, portal);\\n            }\\n            this._portal = portal;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    PortalHostDirective.prototype.ngOnDestroy = function () {\\n        _super.prototype.dispose.call(this);\\n        this._portal = null;\\n    };\\n    /**\\n     * Attach the given ComponentPortal to this PortalHost using the ComponentFactoryResolver.\\n     *\\n     * @template T\\n     * @param {?} portal Portal to be attached to the portal host.\\n     * @return {?}\\n     */\\n    PortalHostDirective.prototype.attachComponentPortal = function (portal) {\\n        portal.setAttachedHost(this);\\n        // If the portal specifies an origin, use that as the logical location of the component\\n        // in the application tree. Otherwise use the location of this PortalHost.\\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\\n            portal.viewContainerRef :\\n            this._viewContainerRef;\\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\\n        this._portal = portal;\\n        return ref;\\n    };\\n    /**\\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\\n     * @param {?} portal Portal to be attached.\\n     * @return {?}\\n     */\\n    PortalHostDirective.prototype.attachTemplatePortal = function (portal) {\\n        var _this = this;\\n        portal.setAttachedHost(this);\\n        this._viewContainerRef.createEmbeddedView(portal.templateRef);\\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\\n        this._portal = portal;\\n        // TODO(jelbourn): return locals from view\\n        return new Map();\\n    };\\n    return PortalHostDirective;\\n}(BasePortalHost));\\nPortalHostDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdkPortalHost], [portalHost]\\',\\n                inputs: [\\'portal: cdkPortalHost\\']\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nPortalHostDirective.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ComponentFactoryResolver\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\nPortalHostDirective.propDecorators = {\\n    \\'_deprecatedPortal\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'portalHost\\',] },],\\n};\\nvar PortalModule = /*@__PURE__*/(function () {\\n    function PortalModule() {\\n    }\\n    return PortalModule;\\n}());\\nPortalModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                exports: [TemplatePortalDirective, PortalHostDirective],\\n                declarations: [TemplatePortalDirective, PortalHostDirective],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nPortalModule.ctorParameters = function () { return []; };\\n/**\\n * OverlayState is a bag of values for either the initial configuration or current state of an\\n * overlay.\\n */\\nvar OverlayState = /*@__PURE__*/(function () {\\n    function OverlayState() {\\n        /**\\n         * Strategy to be used when handling scroll events while the overlay is open.\\n         */\\n        this.scrollStrategy = new NoopScrollStrategy();\\n        /**\\n         * Whether the overlay has a backdrop.\\n         */\\n        this.hasBackdrop = false;\\n        /**\\n         * Custom class to add to the backdrop\\n         */\\n        this.backdropClass = \\'cdk-overlay-dark-backdrop\\';\\n        /**\\n         * The direction of the text in the overlay panel.\\n         */\\n        this.direction = \\'ltr\\';\\n        // TODO(jelbourn): configuration still to add\\n        // - focus trap\\n        // - disable pointer events\\n        // - z-index\\n    }\\n    return OverlayState;\\n}());\\n/**\\n * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular\\n * application context.\\n *\\n * This is the only part of the portal core that directly touches the DOM.\\n */\\nvar DomPortalHost = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](DomPortalHost, _super);\\n    /**\\n     * @param {?} _hostDomElement\\n     * @param {?} _componentFactoryResolver\\n     * @param {?} _appRef\\n     * @param {?} _defaultInjector\\n     */\\n    function DomPortalHost(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {\\n        var _this = _super.call(this) || this;\\n        _this._hostDomElement = _hostDomElement;\\n        _this._componentFactoryResolver = _componentFactoryResolver;\\n        _this._appRef = _appRef;\\n        _this._defaultInjector = _defaultInjector;\\n        return _this;\\n    }\\n    /**\\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\\n     * @template T\\n     * @param {?} portal Portal to be attached\\n     * @return {?}\\n     */\\n    DomPortalHost.prototype.attachComponentPortal = function (portal) {\\n        var _this = this;\\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\\n        var /** @type {?} */ componentRef;\\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\\n        // for the component (in terms of Angular\\'s component tree, not rendering).\\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\\n        // and then manually attach the view to the application.\\n        if (portal.viewContainerRef) {\\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\\n            this.setDisposeFn(function () { return componentRef.destroy(); });\\n        }\\n        else {\\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\\n            this._appRef.attachView(componentRef.hostView);\\n            this.setDisposeFn(function () {\\n                _this._appRef.detachView(componentRef.hostView);\\n                componentRef.destroy();\\n            });\\n        }\\n        // At this point the component has been instantiated, so we move it to the location in the DOM\\n        // where we want it to be rendered.\\n        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\\n        return componentRef;\\n    };\\n    /**\\n     * Attaches a template portal to the DOM as an embedded view.\\n     * @param {?} portal Portal to be attached.\\n     * @return {?}\\n     */\\n    DomPortalHost.prototype.attachTemplatePortal = function (portal) {\\n        var _this = this;\\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef);\\n        viewRef.detectChanges();\\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\\n        // But for the DomPortalHost the view can be added everywhere in the DOM (e.g Overlay Container)\\n        // To move the view to the specified host element. We just re-append the existing root nodes.\\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\\n        this.setDisposeFn((function () {\\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\\n            if (index !== -1) {\\n                viewContainer.remove(index);\\n            }\\n        }));\\n        // TODO(jelbourn): Return locals from view.\\n        return new Map();\\n    };\\n    /**\\n     * Clears out a portal from the DOM.\\n     * @return {?}\\n     */\\n    DomPortalHost.prototype.dispose = function () {\\n        _super.prototype.dispose.call(this);\\n        if (this._hostDomElement.parentNode != null) {\\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\\n        }\\n    };\\n    /**\\n     * Gets the root HTMLElement for an instantiated component.\\n     * @param {?} componentRef\\n     * @return {?}\\n     */\\n    DomPortalHost.prototype._getComponentRootNode = function (componentRef) {\\n        return (((componentRef.hostView)).rootNodes[0]);\\n    };\\n    return DomPortalHost;\\n}(BasePortalHost));\\n/**\\n * Reference to an overlay that has been created with the Overlay service.\\n * Used to manipulate or dispose of said overlay.\\n */\\nvar OverlayRef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _portalHost\\n     * @param {?} _pane\\n     * @param {?} _state\\n     * @param {?} _ngZone\\n     */\\n    function OverlayRef(_portalHost, _pane, _state, _ngZone) {\\n        this._portalHost = _portalHost;\\n        this._pane = _pane;\\n        this._state = _state;\\n        this._ngZone = _ngZone;\\n        this._backdropElement = null;\\n        this._backdropClick = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        this._attachments = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        this._detachments = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        this._state.scrollStrategy.attach(this);\\n    }\\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\\n        /**\\n         * The overlay\\'s HTML element\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._pane;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Attaches the overlay to a portal instance and adds the backdrop.\\n     * @param {?} portal Portal instance to which to attach the overlay.\\n     * @return {?} The portal attachment result.\\n     */\\n    OverlayRef.prototype.attach = function (portal) {\\n        var /** @type {?} */ attachResult = this._portalHost.attach(portal);\\n        // Update the pane element with the given state configuration.\\n        this._updateStackingOrder();\\n        this.updateSize();\\n        this.updateDirection();\\n        this.updatePosition();\\n        this._attachments.next();\\n        this._state.scrollStrategy.enable();\\n        // Enable pointer events for the overlay pane element.\\n        this._togglePointerEvents(true);\\n        if (this._state.hasBackdrop) {\\n            this._attachBackdrop();\\n        }\\n        return attachResult;\\n    };\\n    /**\\n     * Detaches an overlay from a portal.\\n     * @return {?} Resolves when the overlay has been detached.\\n     */\\n    OverlayRef.prototype.detach = function () {\\n        this.detachBackdrop();\\n        // When the overlay is detached, the pane element should disable pointer events.\\n        // This is necessary because otherwise the pane element will cover the page and disable\\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\\n        this._togglePointerEvents(false);\\n        this._state.scrollStrategy.disable();\\n        this._detachments.next();\\n        return this._portalHost.detach();\\n    };\\n    /**\\n     * Cleans up the overlay from the DOM.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.dispose = function () {\\n        if (this._state.positionStrategy) {\\n            this._state.positionStrategy.dispose();\\n        }\\n        this.detachBackdrop();\\n        this._portalHost.dispose();\\n        this._state.scrollStrategy.disable();\\n        this._detachments.next();\\n        this._detachments.complete();\\n        this._attachments.complete();\\n    };\\n    /**\\n     * Checks whether the overlay has been attached.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.hasAttached = function () {\\n        return this._portalHost.hasAttached();\\n    };\\n    /**\\n     * Returns an observable that emits when the backdrop has been clicked.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.backdropClick = function () {\\n        return this._backdropClick.asObservable();\\n    };\\n    /**\\n     * Returns an observable that emits when the overlay has been attached.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.attachments = function () {\\n        return this._attachments.asObservable();\\n    };\\n    /**\\n     * Returns an observable that emits when the overlay has been detached.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.detachments = function () {\\n        return this._detachments.asObservable();\\n    };\\n    /**\\n     * Gets the current state config of the overlay.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.getState = function () {\\n        return this._state;\\n    };\\n    /**\\n     * Updates the position of the overlay based on the position strategy.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.updatePosition = function () {\\n        if (this._state.positionStrategy) {\\n            this._state.positionStrategy.apply(this._pane);\\n        }\\n    };\\n    /**\\n     * Updates the text direction of the overlay panel.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.updateDirection = function () {\\n        this._pane.setAttribute(\\'dir\\', this._state.direction);\\n    };\\n    /**\\n     * Updates the size of the overlay based on the overlay config.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.updateSize = function () {\\n        if (this._state.width || this._state.width === 0) {\\n            this._pane.style.width = formatCssUnit(this._state.width);\\n        }\\n        if (this._state.height || this._state.height === 0) {\\n            this._pane.style.height = formatCssUnit(this._state.height);\\n        }\\n        if (this._state.minWidth || this._state.minWidth === 0) {\\n            this._pane.style.minWidth = formatCssUnit(this._state.minWidth);\\n        }\\n        if (this._state.minHeight || this._state.minHeight === 0) {\\n            this._pane.style.minHeight = formatCssUnit(this._state.minHeight);\\n        }\\n    };\\n    /**\\n     * Toggles the pointer events for the overlay pane element.\\n     * @param {?} enablePointer\\n     * @return {?}\\n     */\\n    OverlayRef.prototype._togglePointerEvents = function (enablePointer) {\\n        this._pane.style.pointerEvents = enablePointer ? \\'auto\\' : \\'none\\';\\n    };\\n    /**\\n     * Attaches a backdrop for this overlay.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype._attachBackdrop = function () {\\n        var _this = this;\\n        this._backdropElement = document.createElement(\\'div\\');\\n        this._backdropElement.classList.add(\\'cdk-overlay-backdrop\\');\\n        this._backdropElement.classList.add(this._state.backdropClass);\\n        // Insert the backdrop before the pane in the DOM order,\\n        // in order to handle stacked overlays properly.\\n        this._pane.parentElement.insertBefore(this._backdropElement, this._pane);\\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\\n        // action desired when such a click occurs (usually closing the overlay).\\n        this._backdropElement.addEventListener(\\'click\\', function () { return _this._backdropClick.next(null); });\\n        // Add class to fade-in the backdrop after one frame.\\n        requestAnimationFrame(function () {\\n            if (_this._backdropElement) {\\n                _this._backdropElement.classList.add(\\'cdk-overlay-backdrop-showing\\');\\n            }\\n        });\\n    };\\n    /**\\n     * Updates the stacking order of the element, moving it to the top if necessary.\\n     * This is required in cases where one overlay was detached, while another one,\\n     * that should be behind it, was destroyed. The next time both of them are opened,\\n     * the stacking will be wrong, because the detached element\\'s pane will still be\\n     * in its original DOM position.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype._updateStackingOrder = function () {\\n        if (this._pane.nextSibling) {\\n            this._pane.parentNode.appendChild(this._pane);\\n        }\\n    };\\n    /**\\n     * Detaches the backdrop (if any) associated with the overlay.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.detachBackdrop = function () {\\n        var _this = this;\\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\\n        if (backdropToDetach) {\\n            var /** @type {?} */ finishDetach_1 = function () {\\n                // It may not be attached to anything in certain cases (e.g. unit tests).\\n                if (backdropToDetach && backdropToDetach.parentNode) {\\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\\n                }\\n                // It is possible that a new portal has been attached to this overlay since we started\\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\\n                // is still the same instance that we started to remove.\\n                if (_this._backdropElement == backdropToDetach) {\\n                    _this._backdropElement = null;\\n                }\\n            };\\n            backdropToDetach.classList.remove(\\'cdk-overlay-backdrop-showing\\');\\n            backdropToDetach.classList.remove(this._state.backdropClass);\\n            backdropToDetach.addEventListener(\\'transitionend\\', finishDetach_1);\\n            // If the backdrop doesn\\'t have a transition, the `transitionend` event won\\'t fire.\\n            // In this case we make it unclickable and we try to remove it after a delay.\\n            backdropToDetach.style.pointerEvents = \\'none\\';\\n            // Run this outside the Angular zone because there\\'s nothing that Angular cares about.\\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\\n            // either async or fakeAsync.\\n            this._ngZone.runOutsideAngular(function () {\\n                setTimeout(finishDetach_1, 500);\\n            });\\n        }\\n    };\\n    return OverlayRef;\\n}());\\n/**\\n * @param {?} value\\n * @return {?}\\n */\\nfunction formatCssUnit(value) {\\n    return typeof value === \\'string\\' ? (value) : value + \"px\";\\n}\\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\\n/**\\n * The points of the origin element and the overlay element to connect.\\n */\\nvar ConnectionPositionPair = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} origin\\n     * @param {?} overlay\\n     */\\n    function ConnectionPositionPair(origin, overlay) {\\n        this.originX = origin.originX;\\n        this.originY = origin.originY;\\n        this.overlayX = overlay.overlayX;\\n        this.overlayY = overlay.overlayY;\\n    }\\n    return ConnectionPositionPair;\\n}());\\n/**\\n * Set of properties regarding the position of the origin and overlay relative to the viewport\\n * with respect to the containing Scrollable elements.\\n *\\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\\n * bounds of any one of the strategy\\'s Scrollable\\'s bounding client rectangle.\\n *\\n * The overlay and origin are outside view if there is no overlap between their bounding client\\n * rectangle and any one of the strategy\\'s Scrollable\\'s bounding client rectangle.\\n *\\n *       -----------                    -----------\\n *       | outside |                    | clipped |\\n *       |  view   |              --------------------------\\n *       |         |              |     |         |        |\\n *       ----------               |     -----------        |\\n *  --------------------------    |                        |\\n *  |                        |    |      Scrollable        |\\n *  |                        |    |                        |\\n *  |                        |     --------------------------\\n *  |      Scrollable        |\\n *  |                        |\\n *  --------------------------\\n */\\nvar ScrollableViewProperties = /*@__PURE__*/(function () {\\n    function ScrollableViewProperties() {\\n    }\\n    return ScrollableViewProperties;\\n}());\\n/**\\n * The change event emitted by the strategy when a fallback position is used.\\n */\\nvar ConnectedOverlayPositionChange = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} connectionPair\\n     * @param {?} scrollableViewProperties\\n     */\\n    function ConnectedOverlayPositionChange(connectionPair, scrollableViewProperties) {\\n        this.connectionPair = connectionPair;\\n        this.scrollableViewProperties = scrollableViewProperties;\\n    }\\n    return ConnectedOverlayPositionChange;\\n}());\\n/**\\n * @nocollapse\\n */\\nConnectedOverlayPositionChange.ctorParameters = function () { return [\\n    { type: ConnectionPositionPair, },\\n    { type: ScrollableViewProperties, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\n/**\\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\\n * implicit position relative some origin element. The relative position is defined in terms of\\n * a point on the origin element that is connected to a point on the overlay element. For example,\\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\\n * of the overlay.\\n */\\nvar ConnectedPositionStrategy = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _connectedTo\\n     * @param {?} _originPos\\n     * @param {?} _overlayPos\\n     * @param {?} _viewportRuler\\n     */\\n    function ConnectedPositionStrategy(_connectedTo, _originPos, _overlayPos, _viewportRuler) {\\n        this._connectedTo = _connectedTo;\\n        this._originPos = _originPos;\\n        this._overlayPos = _overlayPos;\\n        this._viewportRuler = _viewportRuler;\\n        this._dir = \\'ltr\\';\\n        /**\\n         * The offset in pixels for the overlay connection point on the x-axis\\n         */\\n        this._offsetX = 0;\\n        /**\\n         * The offset in pixels for the overlay connection point on the y-axis\\n         */\\n        this._offsetY = 0;\\n        /**\\n         * The Scrollable containers used to check scrollable view properties on position change.\\n         */\\n        this.scrollables = [];\\n        /**\\n         * Ordered list of preferred positions, from most to least desirable.\\n         */\\n        this._preferredPositions = [];\\n        this._onPositionChange = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        this._origin = this._connectedTo.nativeElement;\\n        this.withFallbackPosition(_originPos, _overlayPos);\\n    }\\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\\n        /**\\n         * Whether the we\\'re dealing with an RTL context\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._dir === \\'rtl\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\\n        /**\\n         * Emits an event when the connection point changes.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._onPositionChange.asObservable();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\\n        /**\\n         * Ordered list of preferred positions, from most to least desirable.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._preferredPositions;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * To be used to for any cleanup after the element gets destroyed.\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.dispose = function () { };\\n    /**\\n     * Updates the position of the overlay element, using whichever preferred position relative\\n     * to the origin fits on-screen.\\n     * \\\\@docs-private\\n     *\\n     * @param {?} element Element to which to apply the CSS styles.\\n     * @return {?} Resolves when the styles have been applied.\\n     */\\n    ConnectedPositionStrategy.prototype.apply = function (element) {\\n        // Cache the overlay pane element in case re-calculating position is necessary\\n        this._pane = element;\\n        // We need the bounding rects for the origin and the overlay to determine how to position\\n        // the overlay relative to the origin.\\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\\n        // We use the viewport rect to determine whether a position would go off-screen.\\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\\n        // Fallback point if none of the fallbacks fit into the viewport.\\n        var /** @type {?} */ fallbackPoint = null;\\n        var /** @type {?} */ fallbackPosition = null;\\n        // We want to place the overlay in the first of the preferred positions such that the\\n        // overlay fits on-screen.\\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\\n            var pos = _a[_i];\\n            // Get the (x, y) point of connection on the origin, and then use that to get the\\n            // (top, left) coordinate for the overlay at `pos`.\\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);\\n            // If the overlay in the calculated position fits on-screen, put it there and we\\'re done.\\n            if (overlayPoint.fitsInViewport) {\\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\\n                // Save the last connected position in case the position needs to be re-calculated.\\n                this._lastConnectedPosition = pos;\\n                // Notify that the position has been changed along with its change properties.\\n                var /** @type {?} */ scrollableViewProperties = this.getScrollableViewProperties(element);\\n                var /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\\n                this._onPositionChange.next(positionChange);\\n                return Promise.resolve(null);\\n            }\\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\\n                fallbackPoint = overlayPoint;\\n                fallbackPosition = pos;\\n            }\\n        }\\n        // If none of the preferred positions were in the viewport, take the one\\n        // with the largest visible area.\\n        this._setElementPosition(element, overlayRect, fallbackPoint, fallbackPosition);\\n        return Promise.resolve(null);\\n    };\\n    /**\\n     * This re-aligns the overlay element with the trigger in its last calculated position,\\n     * even if a position higher in the \"preferred positions\" list would now fit. This\\n     * allows one to re-align the panel without changing the orientation of the panel.\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = function () {\\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, lastPosition);\\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\\n    };\\n    /**\\n     * Sets the list of Scrollable containers that host the origin element so that\\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\\n     * Scrollable must be an ancestor element of the strategy\\'s origin element.\\n     * @param {?} scrollables\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {\\n        this.scrollables = scrollables;\\n    };\\n    /**\\n     * Adds a new preferred fallback position.\\n     * @param {?} originPos\\n     * @param {?} overlayPos\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.withFallbackPosition = function (originPos, overlayPos) {\\n        this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\\n        return this;\\n    };\\n    /**\\n     * Sets the layout direction so the overlay\\'s position can be adjusted to match.\\n     * @param {?} dir New layout direction.\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.withDirection = function (dir) {\\n        this._dir = dir;\\n        return this;\\n    };\\n    /**\\n     * Sets an offset for the overlay\\'s connection point on the x-axis\\n     * @param {?} offset New offset in the X axis.\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.withOffsetX = function (offset) {\\n        this._offsetX = offset;\\n        return this;\\n    };\\n    /**\\n     * Sets an offset for the overlay\\'s connection point on the y-axis\\n     * @param {?} offset New offset in the Y axis.\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.withOffsetY = function (offset) {\\n        this._offsetY = offset;\\n        return this;\\n    };\\n    /**\\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\\n     * @param {?} rect\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._getStartX = function (rect) {\\n        return this._isRtl ? rect.right : rect.left;\\n    };\\n    /**\\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\\n     * @param {?} rect\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._getEndX = function (rect) {\\n        return this._isRtl ? rect.left : rect.right;\\n    };\\n    /**\\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\\n     * @param {?} originRect\\n     * @param {?} pos\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = function (originRect, pos) {\\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\\n        var /** @type {?} */ x;\\n        if (pos.originX == \\'center\\') {\\n            x = originStartX + (originRect.width / 2);\\n        }\\n        else {\\n            x = pos.originX == \\'start\\' ? originStartX : originEndX;\\n        }\\n        var /** @type {?} */ y;\\n        if (pos.originY == \\'center\\') {\\n            y = originRect.top + (originRect.height / 2);\\n        }\\n        else {\\n            y = pos.originY == \\'top\\' ? originRect.top : originRect.bottom;\\n        }\\n        return { x: x, y: y };\\n    };\\n    /**\\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\\n     * origin point to which the overlay should be connected, as well as how much of the element\\n     * would be inside the viewport at that position.\\n     * @param {?} originPoint\\n     * @param {?} overlayRect\\n     * @param {?} viewportRect\\n     * @param {?} pos\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._getOverlayPoint = function (originPoint, overlayRect, viewportRect, pos) {\\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\\n        // relative to the origin point.\\n        var /** @type {?} */ overlayStartX;\\n        if (pos.overlayX == \\'center\\') {\\n            overlayStartX = -overlayRect.width / 2;\\n        }\\n        else if (pos.overlayX === \\'start\\') {\\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\\n        }\\n        else {\\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\\n        }\\n        var /** @type {?} */ overlayStartY;\\n        if (pos.overlayY == \\'center\\') {\\n            overlayStartY = -overlayRect.height / 2;\\n        }\\n        else {\\n            overlayStartY = pos.overlayY == \\'top\\' ? 0 : -overlayRect.height;\\n        }\\n        // The (x, y) coordinates of the overlay.\\n        var /** @type {?} */ x = originPoint.x + overlayStartX + this._offsetX;\\n        var /** @type {?} */ y = originPoint.y + overlayStartY + this._offsetY;\\n        // How much the overlay would overflow at this position, on each side.\\n        var /** @type {?} */ leftOverflow = 0 - x;\\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportRect.width;\\n        var /** @type {?} */ topOverflow = 0 - y;\\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportRect.height;\\n        // Visible parts of the element on each axis.\\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\\n        // The area of the element that\\'s within the viewport.\\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\\n    };\\n    /**\\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\\n     * or completely outside the view of any of the strategy\\'s scrollables.\\n     * @param {?} overlay\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.getScrollableViewProperties = function (overlay) {\\n        var _this = this;\\n        var /** @type {?} */ originBounds = this._getElementBounds(this._origin);\\n        var /** @type {?} */ overlayBounds = this._getElementBounds(overlay);\\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (scrollable) {\\n            return _this._getElementBounds(scrollable.getElementRef().nativeElement);\\n        });\\n        return {\\n            isOriginClipped: this.isElementClipped(originBounds, scrollContainerBounds),\\n            isOriginOutsideView: this.isElementOutsideView(originBounds, scrollContainerBounds),\\n            isOverlayClipped: this.isElementClipped(overlayBounds, scrollContainerBounds),\\n            isOverlayOutsideView: this.isElementOutsideView(overlayBounds, scrollContainerBounds),\\n        };\\n    };\\n    /**\\n     * Whether the element is completely out of the view of any of the containers.\\n     * @param {?} elementBounds\\n     * @param {?} containersBounds\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.isElementOutsideView = function (elementBounds, containersBounds) {\\n        return containersBounds.some(function (containerBounds) {\\n            var /** @type {?} */ outsideAbove = elementBounds.bottom < containerBounds.top;\\n            var /** @type {?} */ outsideBelow = elementBounds.top > containerBounds.bottom;\\n            var /** @type {?} */ outsideLeft = elementBounds.right < containerBounds.left;\\n            var /** @type {?} */ outsideRight = elementBounds.left > containerBounds.right;\\n            return outsideAbove || outsideBelow || outsideLeft || outsideRight;\\n        });\\n    };\\n    /**\\n     * Whether the element is clipped by any of the containers.\\n     * @param {?} elementBounds\\n     * @param {?} containersBounds\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.isElementClipped = function (elementBounds, containersBounds) {\\n        return containersBounds.some(function (containerBounds) {\\n            var /** @type {?} */ clippedAbove = elementBounds.top < containerBounds.top;\\n            var /** @type {?} */ clippedBelow = elementBounds.bottom > containerBounds.bottom;\\n            var /** @type {?} */ clippedLeft = elementBounds.left < containerBounds.left;\\n            var /** @type {?} */ clippedRight = elementBounds.right > containerBounds.right;\\n            return clippedAbove || clippedBelow || clippedLeft || clippedRight;\\n        });\\n    };\\n    /**\\n     * Physically positions the overlay element to the given coordinate.\\n     * @param {?} element\\n     * @param {?} overlayRect\\n     * @param {?} overlayPoint\\n     * @param {?} pos\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._setElementPosition = function (element, overlayRect, overlayPoint, pos) {\\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\\n        // or below the origin and the direction in which the element will expand.\\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === \\'bottom\\' ? \\'bottom\\' : \\'top\\';\\n        // When using `bottom`, we adjust the y position such that it is the distance\\n        // from the bottom of the viewport rather than the top.\\n        var /** @type {?} */ y = verticalStyleProperty === \\'top\\' ?\\n            overlayPoint.y :\\n            document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\\n        // or \"after\" the origin, which determines the direction in which the element will expand.\\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\\n        // page is in RTL or LTR.\\n        var /** @type {?} */ horizontalStyleProperty;\\n        if (this._dir === \\'rtl\\') {\\n            horizontalStyleProperty = pos.overlayX === \\'end\\' ? \\'left\\' : \\'right\\';\\n        }\\n        else {\\n            horizontalStyleProperty = pos.overlayX === \\'end\\' ? \\'right\\' : \\'left\\';\\n        }\\n        // When we\\'re setting `right`, we adjust the x position such that it is the distance\\n        // from the right edge of the viewport rather than the left edge.\\n        var /** @type {?} */ x = horizontalStyleProperty === \\'left\\' ?\\n            overlayPoint.x :\\n            document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\\n        // Reset any existing styles. This is necessary in case the preferred position has\\n        // changed since the last `apply`.\\n        [\\'top\\', \\'bottom\\', \\'left\\', \\'right\\'].forEach(function (p) { return element.style[p] = null; });\\n        element.style[verticalStyleProperty] = y + \"px\";\\n        element.style[horizontalStyleProperty] = x + \"px\";\\n    };\\n    /**\\n     * Returns the bounding positions of the provided element with respect to the viewport.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._getElementBounds = function (element) {\\n        var /** @type {?} */ boundingClientRect = element.getBoundingClientRect();\\n        return {\\n            top: boundingClientRect.top,\\n            right: boundingClientRect.left + boundingClientRect.width,\\n            bottom: boundingClientRect.top + boundingClientRect.height,\\n            left: boundingClientRect.left\\n        };\\n    };\\n    /**\\n     * Subtracts the amount that an element is overflowing on an axis from it\\'s length.\\n     * @param {?} length\\n     * @param {...?} overflows\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._subtractOverflows = function (length) {\\n        var overflows = [];\\n        for (var _i = 1; _i < arguments.length; _i++) {\\n            overflows[_i - 1] = arguments[_i];\\n        }\\n        return overflows.reduce(function (currentValue, currentOverflow) {\\n            return currentValue - Math.max(currentOverflow, 0);\\n        }, length);\\n    };\\n    return ConnectedPositionStrategy;\\n}());\\n/**\\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\\n * explicit position relative to the browser\\'s viewport. We use flexbox, instead of\\n * transforms, in order to avoid issues with subpixel rendering which can cause the\\n * element to become blurry.\\n */\\nvar GlobalPositionStrategy = /*@__PURE__*/(function () {\\n    function GlobalPositionStrategy() {\\n        this._cssPosition = \\'static\\';\\n        this._topOffset = \\'\\';\\n        this._bottomOffset = \\'\\';\\n        this._leftOffset = \\'\\';\\n        this._rightOffset = \\'\\';\\n        this._alignItems = \\'\\';\\n        this._justifyContent = \\'\\';\\n        this._width = \\'\\';\\n        this._height = \\'\\';\\n    }\\n    /**\\n     * Sets the top position of the overlay. Clears any previously set vertical position.\\n     * @param {?} value New top offset.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.top = function (value) {\\n        this._bottomOffset = \\'\\';\\n        this._topOffset = value;\\n        this._alignItems = \\'flex-start\\';\\n        return this;\\n    };\\n    /**\\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\\n     * @param {?} value New left offset.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.left = function (value) {\\n        this._rightOffset = \\'\\';\\n        this._leftOffset = value;\\n        this._justifyContent = \\'flex-start\\';\\n        return this;\\n    };\\n    /**\\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\\n     * @param {?} value New bottom offset.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.bottom = function (value) {\\n        this._topOffset = \\'\\';\\n        this._bottomOffset = value;\\n        this._alignItems = \\'flex-end\\';\\n        return this;\\n    };\\n    /**\\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\\n     * @param {?} value New right offset.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.right = function (value) {\\n        this._leftOffset = \\'\\';\\n        this._rightOffset = value;\\n        this._justifyContent = \\'flex-end\\';\\n        return this;\\n    };\\n    /**\\n     * Sets the overlay width and clears any previously set width.\\n     * @param {?} value New width for the overlay\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.width = function (value) {\\n        this._width = value;\\n        // When the width is 100%, we should reset the `left` and the offset,\\n        // in order to ensure that the element is flush against the viewport edge.\\n        if (value === \\'100%\\') {\\n            this.left(\\'0px\\');\\n        }\\n        return this;\\n    };\\n    /**\\n     * Sets the overlay height and clears any previously set height.\\n     * @param {?} value New height for the overlay\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.height = function (value) {\\n        this._height = value;\\n        // When the height is 100%, we should reset the `top` and the offset,\\n        // in order to ensure that the element is flush against the viewport edge.\\n        if (value === \\'100%\\') {\\n            this.top(\\'0px\\');\\n        }\\n        return this;\\n    };\\n    /**\\n     * Centers the overlay horizontally with an optional offset.\\n     * Clears any previously set horizontal position.\\n     *\\n     * @param {?=} offset Overlay offset from the horizontal center.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.centerHorizontally = function (offset) {\\n        if (offset === void 0) { offset = \\'\\'; }\\n        this.left(offset);\\n        this._justifyContent = \\'center\\';\\n        return this;\\n    };\\n    /**\\n     * Centers the overlay vertically with an optional offset.\\n     * Clears any previously set vertical position.\\n     *\\n     * @param {?=} offset Overlay offset from the vertical center.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.centerVertically = function (offset) {\\n        if (offset === void 0) { offset = \\'\\'; }\\n        this.top(offset);\\n        this._alignItems = \\'center\\';\\n        return this;\\n    };\\n    /**\\n     * Apply the position to the element.\\n     * \\\\@docs-private\\n     *\\n     * @param {?} element Element to which to apply the CSS.\\n     * @return {?} Resolved when the styles have been applied.\\n     */\\n    GlobalPositionStrategy.prototype.apply = function (element) {\\n        if (!this._wrapper) {\\n            this._wrapper = document.createElement(\\'div\\');\\n            this._wrapper.classList.add(\\'cdk-global-overlay-wrapper\\');\\n            element.parentNode.insertBefore(this._wrapper, element);\\n            this._wrapper.appendChild(element);\\n        }\\n        var /** @type {?} */ styles = element.style;\\n        var /** @type {?} */ parentStyles = ((element.parentNode)).style;\\n        styles.position = this._cssPosition;\\n        styles.marginTop = this._topOffset;\\n        styles.marginLeft = this._leftOffset;\\n        styles.marginBottom = this._bottomOffset;\\n        styles.marginRight = this._rightOffset;\\n        styles.width = this._width;\\n        styles.height = this._height;\\n        parentStyles.justifyContent = this._justifyContent;\\n        parentStyles.alignItems = this._alignItems;\\n        return Promise.resolve(null);\\n    };\\n    /**\\n     * Removes the wrapper element from the DOM.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.dispose = function () {\\n        if (this._wrapper && this._wrapper.parentNode) {\\n            this._wrapper.parentNode.removeChild(this._wrapper);\\n            this._wrapper = null;\\n        }\\n    };\\n    return GlobalPositionStrategy;\\n}());\\n/**\\n * Builder for overlay position strategy.\\n */\\nvar OverlayPositionBuilder = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _viewportRuler\\n     */\\n    function OverlayPositionBuilder(_viewportRuler) {\\n        this._viewportRuler = _viewportRuler;\\n    }\\n    /**\\n     * Creates a global position strategy.\\n     * @return {?}\\n     */\\n    OverlayPositionBuilder.prototype.global = function () {\\n        return new GlobalPositionStrategy();\\n    };\\n    /**\\n     * Creates a relative position strategy.\\n     * @param {?} elementRef\\n     * @param {?} originPos\\n     * @param {?} overlayPos\\n     * @return {?}\\n     */\\n    OverlayPositionBuilder.prototype.connectedTo = function (elementRef, originPos, overlayPos) {\\n        return new ConnectedPositionStrategy(elementRef, originPos, overlayPos, this._viewportRuler);\\n    };\\n    return OverlayPositionBuilder;\\n}());\\nOverlayPositionBuilder.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nOverlayPositionBuilder.ctorParameters = function () { return [\\n    { type: ViewportRuler, },\\n]; };\\n/**\\n * The OverlayContainer is the container in which all overlays will load.\\n * It should be provided in the root component to ensure it is properly shared.\\n */\\nvar OverlayContainer = /*@__PURE__*/(function () {\\n    function OverlayContainer() {\\n    }\\n    Object.defineProperty(OverlayContainer.prototype, \"themeClass\", {\\n        /**\\n         * Base theme to be applied to all overlay-based components.\\n         * @return {?}\\n         */\\n        get: function () { return this._themeClass; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._containerElement) {\\n                this._containerElement.classList.remove(this._themeClass);\\n                if (value) {\\n                    this._containerElement.classList.add(value);\\n                }\\n            }\\n            this._themeClass = value;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * This method returns the overlay container element.  It will lazily\\n     * create the element the first time  it is called to facilitate using\\n     * the container in non-browser environments.\\n     * @return {?} the container element\\n     */\\n    OverlayContainer.prototype.getContainerElement = function () {\\n        if (!this._containerElement) {\\n            this._createContainer();\\n        }\\n        return this._containerElement;\\n    };\\n    /**\\n     * Create the overlay container element, which is simply a div\\n     * with the \\'cdk-overlay-container\\' class on the document body.\\n     * @return {?}\\n     */\\n    OverlayContainer.prototype._createContainer = function () {\\n        var /** @type {?} */ container = document.createElement(\\'div\\');\\n        container.classList.add(\\'cdk-overlay-container\\');\\n        if (this._themeClass) {\\n            container.classList.add(this._themeClass);\\n        }\\n        document.body.appendChild(container);\\n        this._containerElement = container;\\n    };\\n    return OverlayContainer;\\n}());\\nOverlayContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nOverlayContainer.ctorParameters = function () { return []; };\\n/**\\n * @param {?} parentContainer\\n * @return {?}\\n */\\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {\\n    return parentContainer || new OverlayContainer();\\n}\\nvar OVERLAY_CONTAINER_PROVIDER = {\\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\\n    provide: OverlayContainer,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), OverlayContainer]],\\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\\n};\\n/**\\n * Next overlay unique ID.\\n */\\nvar nextUniqueId = 0;\\n/**\\n * The default state for newly created overlays.\\n */\\nvar defaultState = new OverlayState();\\n/**\\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\\n * of re-usable components rather than developers building end-user applications.\\n *\\n * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.\\n */\\nvar Overlay = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlayContainer\\n     * @param {?} _componentFactoryResolver\\n     * @param {?} _positionBuilder\\n     * @param {?} _appRef\\n     * @param {?} _injector\\n     * @param {?} _ngZone\\n     */\\n    function Overlay(_overlayContainer, _componentFactoryResolver, _positionBuilder, _appRef, _injector, _ngZone) {\\n        this._overlayContainer = _overlayContainer;\\n        this._componentFactoryResolver = _componentFactoryResolver;\\n        this._positionBuilder = _positionBuilder;\\n        this._appRef = _appRef;\\n        this._injector = _injector;\\n        this._ngZone = _ngZone;\\n    }\\n    /**\\n     * Creates an overlay.\\n     * @param {?=} state State to apply to the overlay.\\n     * @return {?} Reference to the created overlay.\\n     */\\n    Overlay.prototype.create = function (state$$1) {\\n        if (state$$1 === void 0) { state$$1 = defaultState; }\\n        return this._createOverlayRef(this._createPaneElement(), state$$1);\\n    };\\n    /**\\n     * Returns a position builder that can be used, via fluent API,\\n     * to construct and configure a position strategy.\\n     * @return {?}\\n     */\\n    Overlay.prototype.position = function () {\\n        return this._positionBuilder;\\n    };\\n    /**\\n     * Creates the DOM element for an overlay and appends it to the overlay container.\\n     * @return {?} Newly-created pane element\\n     */\\n    Overlay.prototype._createPaneElement = function () {\\n        var /** @type {?} */ pane = document.createElement(\\'div\\');\\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\\n        pane.classList.add(\\'cdk-overlay-pane\\');\\n        this._overlayContainer.getContainerElement().appendChild(pane);\\n        return pane;\\n    };\\n    /**\\n     * Create a DomPortalHost into which the overlay content can be loaded.\\n     * @param {?} pane The DOM element to turn into a portal host.\\n     * @return {?} A portal host for the given DOM element.\\n     */\\n    Overlay.prototype._createPortalHost = function (pane) {\\n        return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef, this._injector);\\n    };\\n    /**\\n     * Creates an OverlayRef for an overlay in the given DOM element.\\n     * @param {?} pane DOM element for the overlay\\n     * @param {?} state\\n     * @return {?}\\n     */\\n    Overlay.prototype._createOverlayRef = function (pane, state$$1) {\\n        return new OverlayRef(this._createPortalHost(pane), pane, state$$1, this._ngZone);\\n    };\\n    return Overlay;\\n}());\\nOverlay.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nOverlay.ctorParameters = function () { return [\\n    { type: OverlayContainer, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ComponentFactoryResolver\"], },\\n    { type: OverlayPositionBuilder, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ApplicationRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injector\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\n/**\\n * Providers for Overlay and its related injectables.\\n */\\nvar OVERLAY_PROVIDERS = [\\n    Overlay,\\n    OverlayPositionBuilder,\\n    VIEWPORT_RULER_PROVIDER,\\n    OVERLAY_CONTAINER_PROVIDER,\\n];\\n/**\\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\\n */\\nvar defaultPositionList = [\\n    new ConnectionPositionPair({ originX: \\'start\\', originY: \\'bottom\\' }, { overlayX: \\'start\\', overlayY: \\'top\\' }),\\n    new ConnectionPositionPair({ originX: \\'start\\', originY: \\'top\\' }, { overlayX: \\'start\\', overlayY: \\'bottom\\' }),\\n];\\n/**\\n * Directive applied to an element to make it usable as an origin for an Overlay using a\\n * ConnectedPositionStrategy.\\n */\\nvar OverlayOrigin = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementRef\\n     */\\n    function OverlayOrigin(elementRef) {\\n        this.elementRef = elementRef;\\n    }\\n    return OverlayOrigin;\\n}());\\nOverlayOrigin.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]\\',\\n                exportAs: \\'cdkOverlayOrigin\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nOverlayOrigin.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\n/**\\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\\n */\\nvar ConnectedOverlayDirective = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlay\\n     * @param {?} _renderer\\n     * @param {?} _scrollDispatcher\\n     * @param {?} templateRef\\n     * @param {?} viewContainerRef\\n     * @param {?} _dir\\n     */\\n    function ConnectedOverlayDirective(_overlay, _renderer, _scrollDispatcher, templateRef, viewContainerRef, _dir) {\\n        this._overlay = _overlay;\\n        this._renderer = _renderer;\\n        this._scrollDispatcher = _scrollDispatcher;\\n        this._dir = _dir;\\n        this._hasBackdrop = false;\\n        this._offsetX = 0;\\n        this._offsetY = 0;\\n        /**\\n         * Strategy to be used when handling scroll events while the overlay is open.\\n         */\\n        this.scrollStrategy = new RepositionScrollStrategy(this._scrollDispatcher);\\n        /**\\n         * Whether the overlay is open.\\n         */\\n        this.open = false;\\n        /**\\n         * Event emitted when the backdrop is clicked.\\n         */\\n        this.backdropClick = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the position has changed.\\n         */\\n        this.positionChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the overlay has been attached.\\n         */\\n        this.attach = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the overlay has been detached.\\n         */\\n        this.detach = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\\n    }\\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"offsetX\", {\\n        /**\\n         * The offset in pixels for the overlay connection point on the x-axis\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._offsetX;\\n        },\\n        /**\\n         * @param {?} offsetX\\n         * @return {?}\\n         */\\n        set: function (offsetX) {\\n            this._offsetX = offsetX;\\n            if (this._position) {\\n                this._position.withOffsetX(offsetX);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"offsetY\", {\\n        /**\\n         * The offset in pixels for the overlay connection point on the y-axis\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._offsetY;\\n        },\\n        /**\\n         * @param {?} offsetY\\n         * @return {?}\\n         */\\n        set: function (offsetY) {\\n            this._offsetY = offsetY;\\n            if (this._position) {\\n                this._position.withOffsetY(offsetY);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"hasBackdrop\", {\\n        /**\\n         * Whether or not the overlay should attach a backdrop.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._hasBackdrop;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._hasBackdrop = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"overlayRef\", {\\n        /**\\n         * The associated overlay reference.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._overlayRef;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"dir\", {\\n        /**\\n         * The element\\'s layout direction.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._dir ? this._dir.value : \\'ltr\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype.ngOnDestroy = function () {\\n        this._destroyOverlay();\\n    };\\n    /**\\n     * @param {?} changes\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype.ngOnChanges = function (changes) {\\n        if (changes[\\'open\\']) {\\n            this.open ? this._attachOverlay() : this._detachOverlay();\\n        }\\n    };\\n    /**\\n     * Creates an overlay\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._createOverlay = function () {\\n        if (!this.positions || !this.positions.length) {\\n            this.positions = defaultPositionList;\\n        }\\n        this._overlayRef = this._overlay.create(this._buildConfig());\\n    };\\n    /**\\n     * Builds the overlay config based on the directive\\'s inputs\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._buildConfig = function () {\\n        var /** @type {?} */ overlayConfig = new OverlayState();\\n        if (this.width || this.width === 0) {\\n            overlayConfig.width = this.width;\\n        }\\n        if (this.height || this.height === 0) {\\n            overlayConfig.height = this.height;\\n        }\\n        if (this.minWidth || this.minWidth === 0) {\\n            overlayConfig.minWidth = this.minWidth;\\n        }\\n        if (this.minHeight || this.minHeight === 0) {\\n            overlayConfig.minHeight = this.minHeight;\\n        }\\n        overlayConfig.hasBackdrop = this.hasBackdrop;\\n        if (this.backdropClass) {\\n            overlayConfig.backdropClass = this.backdropClass;\\n        }\\n        this._position = (this._createPositionStrategy());\\n        overlayConfig.positionStrategy = this._position;\\n        overlayConfig.scrollStrategy = this.scrollStrategy;\\n        return overlayConfig;\\n    };\\n    /**\\n     * Returns the position strategy of the overlay to be set on the overlay config\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._createPositionStrategy = function () {\\n        var /** @type {?} */ pos = this.positions[0];\\n        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };\\n        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };\\n        var /** @type {?} */ strategy = this._overlay.position()\\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\\n            .withOffsetX(this.offsetX)\\n            .withOffsetY(this.offsetY);\\n        this._handlePositionChanges(strategy);\\n        return strategy;\\n    };\\n    /**\\n     * @param {?} strategy\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._handlePositionChanges = function (strategy) {\\n        var _this = this;\\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\\n        }\\n        this._positionSubscription =\\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\\n    };\\n    /**\\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._attachOverlay = function () {\\n        var _this = this;\\n        if (!this._overlayRef) {\\n            this._createOverlay();\\n        }\\n        this._position.withDirection(this.dir);\\n        this._overlayRef.getState().direction = this.dir;\\n        this._initEscapeListener();\\n        if (!this._overlayRef.hasAttached()) {\\n            this._overlayRef.attach(this._templatePortal);\\n            this.attach.emit();\\n        }\\n        if (this.hasBackdrop) {\\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\\n                _this.backdropClick.emit();\\n            });\\n        }\\n    };\\n    /**\\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._detachOverlay = function () {\\n        if (this._overlayRef) {\\n            this._overlayRef.detach();\\n            this.detach.emit();\\n        }\\n        if (this._backdropSubscription) {\\n            this._backdropSubscription.unsubscribe();\\n            this._backdropSubscription = null;\\n        }\\n        if (this._escapeListener) {\\n            this._escapeListener();\\n        }\\n    };\\n    /**\\n     * Destroys the overlay created by this directive.\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._destroyOverlay = function () {\\n        if (this._overlayRef) {\\n            this._overlayRef.dispose();\\n        }\\n        if (this._backdropSubscription) {\\n            this._backdropSubscription.unsubscribe();\\n        }\\n        if (this._positionSubscription) {\\n            this._positionSubscription.unsubscribe();\\n        }\\n        if (this._escapeListener) {\\n            this._escapeListener();\\n        }\\n    };\\n    /**\\n     * Sets the event listener that closes the overlay when pressing Escape.\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._initEscapeListener = function () {\\n        var _this = this;\\n        this._escapeListener = this._renderer.listen(\\'document\\', \\'keydown\\', function (event) {\\n            if (event.keyCode === ESCAPE) {\\n                _this._detachOverlay();\\n            }\\n        });\\n    };\\n    return ConnectedOverlayDirective;\\n}());\\nConnectedOverlayDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]\\',\\n                exportAs: \\'cdkConnectedOverlay\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nConnectedOverlayDirective.ctorParameters = function () { return [\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: ScrollDispatcher, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nConnectedOverlayDirective.propDecorators = {\\n    \\'origin\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'positions\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'offsetX\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'offsetY\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'width\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'height\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'minWidth\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'minHeight\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'backdropClass\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'scrollStrategy\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'open\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'hasBackdrop\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'backdropClick\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'positionChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'attach\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'detach\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar OverlayModule = /*@__PURE__*/(function () {\\n    function OverlayModule() {\\n    }\\n    return OverlayModule;\\n}());\\nOverlayModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [PortalModule, ScrollDispatchModule],\\n                exports: [ConnectedOverlayDirective, OverlayOrigin, ScrollDispatchModule],\\n                declarations: [ConnectedOverlayDirective, OverlayOrigin],\\n                providers: [OVERLAY_PROVIDERS],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nOverlayModule.ctorParameters = function () { return []; };\\n/**\\n * Utility for checking the interactivity of an element, such as whether is is focusable or\\n * tabbable.\\n */\\nvar InteractivityChecker = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _platform\\n     */\\n    function InteractivityChecker(_platform) {\\n        this._platform = _platform;\\n    }\\n    /**\\n     * Gets whether an element is disabled.\\n     *\\n     * @param {?} element Element to be checked.\\n     * @return {?} Whether the element is disabled.\\n     */\\n    InteractivityChecker.prototype.isDisabled = function (element) {\\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\\n        // a form control inside of a disabled form, but should capture the most common cases.\\n        return element.hasAttribute(\\'disabled\\');\\n    };\\n    /**\\n     * Gets whether an element is visible for the purposes of interactivity.\\n     *\\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\\n     *\\n     * @param {?} element\\n     * @return {?} Whether the element is visible.\\n     */\\n    InteractivityChecker.prototype.isVisible = function (element) {\\n        return hasGeometry(element) && getComputedStyle(element).visibility === \\'visible\\';\\n    };\\n    /**\\n     * Gets whether an element can be reached via Tab key.\\n     * Assumes that the element has already been checked with isFocusable.\\n     *\\n     * @param {?} element Element to be checked.\\n     * @return {?} Whether the element is tabbable.\\n     */\\n    InteractivityChecker.prototype.isTabbable = function (element) {\\n        var /** @type {?} */ frameElement = (getWindow(element).frameElement);\\n        if (frameElement) {\\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\\n            // Frame elements inherit their tabindex onto all child elements.\\n            if (getTabIndexValue(frameElement) === -1) {\\n                return false;\\n            }\\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === \\'object\\') {\\n                return false;\\n            }\\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\\n                return false;\\n            }\\n        }\\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\\n        if (element.hasAttribute(\\'contenteditable\\')) {\\n            return tabIndexValue !== -1;\\n        }\\n        if (nodeName === \\'iframe\\') {\\n            // The frames may be tabbable depending on content, but it\\'s not possibly to reliably\\n            // investigate the content of the frames.\\n            return false;\\n        }\\n        if (nodeName === \\'audio\\') {\\n            if (!element.hasAttribute(\\'controls\\')) {\\n                // By default an <audio> element without the controls enabled is not tabbable.\\n                return false;\\n            }\\n            else if (this._platform.BLINK) {\\n                // In Blink <audio controls> elements are always tabbable.\\n                return true;\\n            }\\n        }\\n        if (nodeName === \\'video\\') {\\n            if (!element.hasAttribute(\\'controls\\') && this._platform.TRIDENT) {\\n                // In Trident a <video> element without the controls enabled is not tabbable.\\n                return false;\\n            }\\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\\n                // In Chrome and Firefox <video controls> elements are always tabbable.\\n                return true;\\n            }\\n        }\\n        if (nodeName === \\'object\\' && (this._platform.BLINK || this._platform.WEBKIT)) {\\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\\n            return false;\\n        }\\n        // In iOS the browser only considers some specific elements as tabbable.\\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\\n            return false;\\n        }\\n        return element.tabIndex >= 0;\\n    };\\n    /**\\n     * Gets whether an element can be focused by the user.\\n     *\\n     * @param {?} element Element to be checked.\\n     * @return {?} Whether the element is focusable.\\n     */\\n    InteractivityChecker.prototype.isFocusable = function (element) {\\n        // Perform checks in order of left to most expensive.\\n        // Again, naive approach that does not capture many edge cases and browser quirks.\\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\\n    };\\n    return InteractivityChecker;\\n}());\\nInteractivityChecker.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nInteractivityChecker.ctorParameters = function () { return [\\n    { type: Platform, },\\n]; };\\n/**\\n * Checks whether the specified element has any geometry / rectangles.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction hasGeometry(element) {\\n    // Use logic from jQuery to check for an invisible element.\\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\\n    return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\\n}\\n/**\\n * Gets whether an element\\'s\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isNativeFormElement(element) {\\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\\n    return nodeName === \\'input\\' ||\\n        nodeName === \\'select\\' ||\\n        nodeName === \\'button\\' ||\\n        nodeName === \\'textarea\\';\\n}\\n/**\\n * Gets whether an element is an <input type=\"hidden\">.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isHiddenInput(element) {\\n    return isInputElement(element) && element.type == \\'hidden\\';\\n}\\n/**\\n * Gets whether an element is an anchor that has an href attribute.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isAnchorWithHref(element) {\\n    return isAnchorElement(element) && element.hasAttribute(\\'href\\');\\n}\\n/**\\n * Gets whether an element is an input element.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isInputElement(element) {\\n    return element.nodeName.toLowerCase() == \\'input\\';\\n}\\n/**\\n * Gets whether an element is an anchor element.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isAnchorElement(element) {\\n    return element.nodeName.toLowerCase() == \\'a\\';\\n}\\n/**\\n * Gets whether an element has a valid tabindex.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction hasValidTabIndex(element) {\\n    if (!element.hasAttribute(\\'tabindex\\') || element.tabIndex === undefined) {\\n        return false;\\n    }\\n    var /** @type {?} */ tabIndex = element.getAttribute(\\'tabindex\\');\\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\\n    if (tabIndex == \\'-32768\\') {\\n        return false;\\n    }\\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\\n}\\n/**\\n * Returns the parsed tabindex from the element attributes instead of returning the\\n * evaluated tabindex from the browsers defaults.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction getTabIndexValue(element) {\\n    if (!hasValidTabIndex(element)) {\\n        return null;\\n    }\\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute(\\'tabindex\\'), 10);\\n    return isNaN(tabIndex) ? -1 : tabIndex;\\n}\\n/**\\n * Checks whether the specified element is potentially tabbable on iOS\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isPotentiallyTabbableIOS(element) {\\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\\n    var /** @type {?} */ inputType = nodeName === \\'input\\' && ((element)).type;\\n    return inputType === \\'text\\'\\n        || inputType === \\'password\\'\\n        || nodeName === \\'select\\'\\n        || nodeName === \\'textarea\\';\\n}\\n/**\\n * Gets whether an element is potentially focusable without taking current visible/disabled state\\n * into account.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isPotentiallyFocusable(element) {\\n    // Inputs are potentially focusable *unless* they\\'re type=\"hidden\".\\n    if (isHiddenInput(element)) {\\n        return false;\\n    }\\n    return isNativeFormElement(element) ||\\n        isAnchorWithHref(element) ||\\n        element.hasAttribute(\\'contenteditable\\') ||\\n        hasValidTabIndex(element);\\n}\\n/**\\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\\n * @param {?} node\\n * @return {?}\\n */\\nfunction getWindow(node) {\\n    return node.ownerDocument.defaultView || window;\\n}\\n/**\\n * Class that allows for trapping focus within a DOM element.\\n *\\n * NOTE: This class currently uses a very simple (naive) approach to focus trapping.\\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\\n * This will be replaced with a more intelligent solution before the library is considered stable.\\n */\\nvar FocusTrap = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _element\\n     * @param {?} _checker\\n     * @param {?} _ngZone\\n     * @param {?=} deferAnchors\\n     */\\n    function FocusTrap(_element, _checker, _ngZone, deferAnchors) {\\n        if (deferAnchors === void 0) { deferAnchors = false; }\\n        this._element = _element;\\n        this._checker = _checker;\\n        this._ngZone = _ngZone;\\n        this._enabled = true;\\n        if (!deferAnchors) {\\n            this.attachAnchors();\\n        }\\n    }\\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\\n        /**\\n         * Whether the focus trap is active.\\n         * @return {?}\\n         */\\n        get: function () { return this._enabled; },\\n        /**\\n         * @param {?} val\\n         * @return {?}\\n         */\\n        set: function (val) {\\n            this._enabled = val;\\n            if (this._startAnchor && this._endAnchor) {\\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Destroys the focus trap by cleaning up the anchors.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.destroy = function () {\\n        if (this._startAnchor && this._startAnchor.parentNode) {\\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\\n        }\\n        if (this._endAnchor && this._endAnchor.parentNode) {\\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\\n        }\\n        this._startAnchor = this._endAnchor = null;\\n    };\\n    /**\\n     * Inserts the anchors into the DOM. This is usually done automatically\\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.attachAnchors = function () {\\n        var _this = this;\\n        if (!this._startAnchor) {\\n            this._startAnchor = this._createAnchor();\\n        }\\n        if (!this._endAnchor) {\\n            this._endAnchor = this._createAnchor();\\n        }\\n        this._ngZone.runOutsideAngular(function () {\\n            _this._startAnchor.addEventListener(\\'focus\\', function () { return _this.focusLastTabbableElement(); });\\n            _this._endAnchor.addEventListener(\\'focus\\', function () { return _this.focusFirstTabbableElement(); });\\n            _this._element.parentNode.insertBefore(_this._startAnchor, _this._element);\\n            _this._element.parentNode.insertBefore(_this._endAnchor, _this._element.nextSibling);\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusInitialElementWhenReady = function () {\\n        var _this = this;\\n        this._ngZone.onMicrotaskEmpty.first().subscribe(function () { return _this.focusInitialElement(); });\\n    };\\n    /**\\n     * Waits for microtask queue to empty, then focuses\\n     * the first tabbable element within the focus trap region.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = function () {\\n        var _this = this;\\n        this._ngZone.onMicrotaskEmpty.first().subscribe(function () { return _this.focusFirstTabbableElement(); });\\n    };\\n    /**\\n     * Waits for microtask queue to empty, then focuses\\n     * the last tabbable element within the focus trap region.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = function () {\\n        var _this = this;\\n        this._ngZone.onMicrotaskEmpty.first().subscribe(function () { return _this.focusLastTabbableElement(); });\\n    };\\n    /**\\n     * Get the specified boundary element of the trapped region.\\n     * @param {?} bound The boundary to get (start or end of trapped region).\\n     * @return {?} The boundary element.\\n     */\\n    FocusTrap.prototype._getRegionBoundary = function (bound) {\\n        var /** @type {?} */ markers = Array.prototype.slice.call(this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"]\")).concat(Array.prototype.slice.call(this._element.querySelectorAll(\"[cdk-focus-\" + bound + \"]\")));\\n        markers.forEach(function (el) {\\n            if (el.hasAttribute(\"cdk-focus-\" + bound)) {\\n                console.warn(\"Found use of deprecated attribute \\'cdk-focus-\" + bound + \"\\',\" +\\n                    (\" use \\'cdk-focus-region-\" + bound + \"\\' instead.\"), el);\\n            }\\n        });\\n        if (bound == \\'start\\') {\\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\\n        }\\n        return markers.length ?\\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\\n    };\\n    /**\\n     * Focuses the element that should be focused when the focus trap is initialized.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusInitialElement = function () {\\n        var /** @type {?} */ redirectToElement = (this._element.querySelector(\\'[cdk-focus-initial]\\'));\\n        if (redirectToElement) {\\n            redirectToElement.focus();\\n        }\\n        else {\\n            this.focusFirstTabbableElement();\\n        }\\n    };\\n    /**\\n     * Focuses the first tabbable element within the focus trap region.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusFirstTabbableElement = function () {\\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary(\\'start\\');\\n        if (redirectToElement) {\\n            redirectToElement.focus();\\n        }\\n    };\\n    /**\\n     * Focuses the last tabbable element within the focus trap region.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusLastTabbableElement = function () {\\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary(\\'end\\');\\n        if (redirectToElement) {\\n            redirectToElement.focus();\\n        }\\n    };\\n    /**\\n     * Get the first tabbable element from a DOM subtree (inclusive).\\n     * @param {?} root\\n     * @return {?}\\n     */\\n    FocusTrap.prototype._getFirstTabbableElement = function (root) {\\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\\n            return root;\\n        }\\n        // Iterate in DOM order. Note that IE doesn\\'t have `children` for SVG so we fall\\n        // back to `childNodes` which includes text nodes, comments etc.\\n        var /** @type {?} */ children = root.children || root.childNodes;\\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\\n                null;\\n            if (tabbableChild) {\\n                return tabbableChild;\\n            }\\n        }\\n        return null;\\n    };\\n    /**\\n     * Get the last tabbable element from a DOM subtree (inclusive).\\n     * @param {?} root\\n     * @return {?}\\n     */\\n    FocusTrap.prototype._getLastTabbableElement = function (root) {\\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\\n            return root;\\n        }\\n        // Iterate in reverse DOM order.\\n        var /** @type {?} */ children = root.children || root.childNodes;\\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\\n                null;\\n            if (tabbableChild) {\\n                return tabbableChild;\\n            }\\n        }\\n        return null;\\n    };\\n    /**\\n     * Creates an anchor element.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype._createAnchor = function () {\\n        var /** @type {?} */ anchor = document.createElement(\\'div\\');\\n        anchor.tabIndex = this._enabled ? 0 : -1;\\n        anchor.classList.add(\\'cdk-visually-hidden\\');\\n        anchor.classList.add(\\'cdk-focus-trap-anchor\\');\\n        return anchor;\\n    };\\n    return FocusTrap;\\n}());\\n/**\\n * Factory that allows easy instantiation of focus traps.\\n */\\nvar FocusTrapFactory = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _checker\\n     * @param {?} _ngZone\\n     */\\n    function FocusTrapFactory(_checker, _ngZone) {\\n        this._checker = _checker;\\n        this._ngZone = _ngZone;\\n    }\\n    /**\\n     * @param {?} element\\n     * @param {?=} deferAnchors\\n     * @return {?}\\n     */\\n    FocusTrapFactory.prototype.create = function (element, deferAnchors) {\\n        if (deferAnchors === void 0) { deferAnchors = false; }\\n        return new FocusTrap(element, this._checker, this._ngZone, deferAnchors);\\n    };\\n    return FocusTrapFactory;\\n}());\\nFocusTrapFactory.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nFocusTrapFactory.ctorParameters = function () { return [\\n    { type: InteractivityChecker, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\n/**\\n * Directive for trapping focus within a region.\\n * @deprecated\\n */\\nvar FocusTrapDeprecatedDirective = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _focusTrapFactory\\n     */\\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\\n        this._elementRef = _elementRef;\\n        this._focusTrapFactory = _focusTrapFactory;\\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\\n    }\\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\\n        /**\\n         * Whether the focus trap is active.\\n         * @return {?}\\n         */\\n        get: function () { return !this.focusTrap.enabled; },\\n        /**\\n         * @param {?} val\\n         * @return {?}\\n         */\\n        set: function (val) {\\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = function () {\\n        this.focusTrap.destroy();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = function () {\\n        this.focusTrap.attachAnchors();\\n    };\\n    return FocusTrapDeprecatedDirective;\\n}());\\nFocusTrapDeprecatedDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'cdk-focus-trap\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nFocusTrapDeprecatedDirective.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusTrapFactory, },\\n]; };\\nFocusTrapDeprecatedDirective.propDecorators = {\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Directive for trapping focus within a region.\\n */\\nvar FocusTrapDirective = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _focusTrapFactory\\n     */\\n    function FocusTrapDirective(_elementRef, _focusTrapFactory) {\\n        this._elementRef = _elementRef;\\n        this._focusTrapFactory = _focusTrapFactory;\\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\\n    }\\n    Object.defineProperty(FocusTrapDirective.prototype, \"enabled\", {\\n        /**\\n         * Whether the focus trap is active.\\n         * @return {?}\\n         */\\n        get: function () { return this.focusTrap.enabled; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    FocusTrapDirective.prototype.ngOnDestroy = function () {\\n        this.focusTrap.destroy();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    FocusTrapDirective.prototype.ngAfterContentInit = function () {\\n        this.focusTrap.attachAnchors();\\n    };\\n    return FocusTrapDirective;\\n}());\\nFocusTrapDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdkTrapFocus]\\',\\n                exportAs: \\'cdkTrapFocus\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nFocusTrapDirective.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusTrapFactory, },\\n]; };\\nFocusTrapDirective.propDecorators = {\\n    \\'enabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'cdkTrapFocus\\',] },],\\n};\\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'liveAnnouncerElement\\');\\nvar LiveAnnouncer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementToken\\n     * @param {?} platform\\n     */\\n    function LiveAnnouncer(elementToken, platform) {\\n        // Only do anything if we\\'re on the browser platform.\\n        if (platform.isBrowser) {\\n            // We inject the live element as `any` because the constructor signature cannot reference\\n            // browser globals (HTMLElement) on non-browser environments, since having a class decorator\\n            // causes TypeScript to preserve the constructor signature types.\\n            this._liveElement = elementToken || this._createLiveElement();\\n        }\\n    }\\n    /**\\n     * Announces a message to screenreaders.\\n     * @param {?} message Message to be announced to the screenreader\\n     * @param {?=} politeness The politeness of the announcer element\\n     * @return {?}\\n     */\\n    LiveAnnouncer.prototype.announce = function (message, politeness) {\\n        var _this = this;\\n        if (politeness === void 0) { politeness = \\'polite\\'; }\\n        this._liveElement.textContent = \\'\\';\\n        // TODO: ensure changing the politeness works on all environments we support.\\n        this._liveElement.setAttribute(\\'aria-live\\', politeness);\\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won\\'t be read a\\n        //   second time without clearing and then using a non-zero delay.\\n        // (using JAWS 17 at time of this writing).\\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\\n    };\\n    /**\\n     * Removes the aria-live element from the DOM.\\n     * @return {?}\\n     */\\n    LiveAnnouncer.prototype._removeLiveElement = function () {\\n        if (this._liveElement && this._liveElement.parentNode) {\\n            this._liveElement.parentNode.removeChild(this._liveElement);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    LiveAnnouncer.prototype._createLiveElement = function () {\\n        var /** @type {?} */ liveEl = document.createElement(\\'div\\');\\n        liveEl.classList.add(\\'cdk-visually-hidden\\');\\n        liveEl.setAttribute(\\'aria-atomic\\', \\'true\\');\\n        liveEl.setAttribute(\\'aria-live\\', \\'polite\\');\\n        document.body.appendChild(liveEl);\\n        return liveEl;\\n    };\\n    return LiveAnnouncer;\\n}());\\nLiveAnnouncer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nLiveAnnouncer.ctorParameters = function () { return [\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\\n    { type: Platform, },\\n]; };\\n/**\\n * @param {?} parentDispatcher\\n * @param {?} liveElement\\n * @param {?} platform\\n * @return {?}\\n */\\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, platform) {\\n    return parentDispatcher || new LiveAnnouncer(liveElement, platform);\\n}\\nvar LIVE_ANNOUNCER_PROVIDER = {\\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\\n    provide: LiveAnnouncer,\\n    deps: [\\n        [new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), LiveAnnouncer],\\n        [new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"](LIVE_ANNOUNCER_ELEMENT_TOKEN)],\\n        Platform,\\n    ],\\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\\n};\\nvar A11yModule = /*@__PURE__*/(function () {\\n    function A11yModule() {\\n    }\\n    return A11yModule;\\n}());\\nA11yModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"], PlatformModule],\\n                declarations: [FocusTrapDirective, FocusTrapDeprecatedDirective],\\n                exports: [FocusTrapDirective, FocusTrapDeprecatedDirective],\\n                providers: [InteractivityChecker, FocusTrapFactory, LIVE_ANNOUNCER_PROVIDER]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nA11yModule.ctorParameters = function () { return []; };\\n/**\\n * The FullscreenOverlayContainer is the alternative to OverlayContainer\\n * that supports correct displaying of overlay elements in Fullscreen mode\\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\\n * It should be provided in the root component that way:\\n * providers: [\\n *   {provide: OverlayContainer, useClass: FullscreenOverlayContainer}\\n * ],\\n */\\nvar FullscreenOverlayContainer = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FullscreenOverlayContainer, _super);\\n    function FullscreenOverlayContainer() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    FullscreenOverlayContainer.prototype._createContainer = function () {\\n        var _this = this;\\n        _super.prototype._createContainer.call(this);\\n        this._adjustParentForFullscreenChange();\\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = function () {\\n        if (!this._containerElement) {\\n            return;\\n        }\\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\\n        var /** @type {?} */ parent = fullscreenElement || document.body;\\n        parent.appendChild(this._containerElement);\\n    };\\n    /**\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = function (fn) {\\n        if (document.fullscreenEnabled) {\\n            document.addEventListener(\\'fullscreenchange\\', fn);\\n        }\\n        else if (document.webkitFullscreenEnabled) {\\n            document.addEventListener(\\'webkitfullscreenchange\\', fn);\\n        }\\n        else if (((document)).mozFullScreenEnabled) {\\n            document.addEventListener(\\'mozfullscreenchange\\', fn);\\n        }\\n        else if (((document)).msFullscreenEnabled) {\\n            document.addEventListener(\\'MSFullscreenChange\\', fn);\\n        }\\n    };\\n    /**\\n     * When the page is put into fullscreen mode, a specific element is specified.\\n     * Only that element and its children are visible when in fullscreen mode.\\n     * @return {?}\\n     */\\n    FullscreenOverlayContainer.prototype.getFullscreenElement = function () {\\n        return document.fullscreenElement ||\\n            document.webkitFullscreenElement ||\\n            ((document)).mozFullScreenElement ||\\n            ((document)).msFullscreenElement ||\\n            null;\\n    };\\n    return FullscreenOverlayContainer;\\n}(OverlayContainer));\\nFullscreenOverlayContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nFullscreenOverlayContainer.ctorParameters = function () { return []; };\\nvar GestureConfig = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](GestureConfig, _super);\\n    function GestureConfig() {\\n        var _this = _super.call(this) || this;\\n        _this._hammer = typeof window !== \\'undefined\\' ? ((window)).Hammer : null;\\n        /* List of new event names to add to the gesture support list */\\n        _this.events = _this._hammer ? [\\n            \\'longpress\\',\\n            \\'slide\\',\\n            \\'slidestart\\',\\n            \\'slideend\\',\\n            \\'slideright\\',\\n            \\'slideleft\\'\\n        ] : [];\\n        if (!_this._hammer && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"])()) {\\n            console.warn(\\'Could not find HammerJS. Certain Angular Material \\' +\\n                \\'components may not work correctly.\\');\\n        }\\n        return _this;\\n    }\\n    /**\\n     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.\\n     *\\n     * Our gesture names come from the Material Design gestures spec:\\n     * https://www.google.com/design/spec/patterns/gestures.html#gestures-touch-mechanics\\n     *\\n     * More information on default recognizers can be found in Hammer docs:\\n     * http://hammerjs.github.io/recognizer-pan/\\n     * http://hammerjs.github.io/recognizer-press/\\n     *\\n     * @param {?} element Element to which to assign the new HammerJS gestures.\\n     * @return {?} Newly-created HammerJS instance.\\n     */\\n    GestureConfig.prototype.buildHammer = function (element) {\\n        var /** @type {?} */ mc = new this._hammer(element);\\n        // Default Hammer Recognizers.\\n        var /** @type {?} */ pan = new this._hammer.Pan();\\n        var /** @type {?} */ swipe = new this._hammer.Swipe();\\n        var /** @type {?} */ press = new this._hammer.Press();\\n        // Notice that a HammerJS recognizer can only depend on one other recognizer once.\\n        // Otherwise the previous `recognizeWith` will be dropped.\\n        // TODO: Confirm threshold numbers with Material Design UX Team\\n        var /** @type {?} */ slide = this._createRecognizer(pan, { event: \\'slide\\', threshold: 0 }, swipe);\\n        var /** @type {?} */ longpress = this._createRecognizer(press, { event: \\'longpress\\', time: 500 });\\n        // Overwrite the default `pan` event to use the swipe event.\\n        pan.recognizeWith(swipe);\\n        // Add customized gestures to Hammer manager\\n        mc.add([swipe, press, pan, slide, longpress]);\\n        return (mc);\\n    };\\n    /**\\n     * Creates a new recognizer, without affecting the default recognizers of HammerJS\\n     * @param {?} base\\n     * @param {?} options\\n     * @param {...?} inheritances\\n     * @return {?}\\n     */\\n    GestureConfig.prototype._createRecognizer = function (base, options) {\\n        var inheritances = [];\\n        for (var _i = 2; _i < arguments.length; _i++) {\\n            inheritances[_i - 2] = arguments[_i];\\n        }\\n        var /** @type {?} */ recognizer = new ((base.constructor))(options);\\n        inheritances.push(base);\\n        inheritances.forEach(function (item) { return recognizer.recognizeWith(item); });\\n        return recognizer;\\n    };\\n    return GestureConfig;\\n}(__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__[\"HammerGestureConfig\"]));\\nGestureConfig.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nGestureConfig.ctorParameters = function () { return []; };\\n/**\\n * Class to be used to power selecting one or more options from a list.\\n * \\\\@docs-private\\n */\\nvar SelectionModel = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?=} _isMulti\\n     * @param {?=} initiallySelectedValues\\n     * @param {?=} _emitChanges\\n     */\\n    function SelectionModel(_isMulti, initiallySelectedValues, _emitChanges) {\\n        if (_isMulti === void 0) { _isMulti = false; }\\n        if (_emitChanges === void 0) { _emitChanges = true; }\\n        var _this = this;\\n        this._isMulti = _isMulti;\\n        this._emitChanges = _emitChanges;\\n        /**\\n         * Currently-selected values.\\n         */\\n        this._selection = new Set();\\n        /**\\n         * Keeps track of the deselected options that haven\\'t been emitted by the change event.\\n         */\\n        this._deselectedToEmit = [];\\n        /**\\n         * Keeps track of the selected option that haven\\'t been emitted by the change event.\\n         */\\n        this._selectedToEmit = [];\\n        /**\\n         * Event emitted when the value has changed.\\n         */\\n        this.onChange = this._emitChanges ? new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]() : null;\\n        if (initiallySelectedValues) {\\n            if (_isMulti) {\\n                initiallySelectedValues.forEach(function (value) { return _this._markSelected(value); });\\n            }\\n            else {\\n                this._markSelected(initiallySelectedValues[0]);\\n            }\\n            // Clear the array in order to avoid firing the change event for preselected values.\\n            this._selectedToEmit.length = 0;\\n        }\\n    }\\n    Object.defineProperty(SelectionModel.prototype, \"selected\", {\\n        /**\\n         * Selected value(s).\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (!this._selected) {\\n                this._selected = Array.from(this._selection.values());\\n            }\\n            return this._selected;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Selects a value or an array of values.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.select = function (value) {\\n        this._markSelected(value);\\n        this._emitChangeEvent();\\n    };\\n    /**\\n     * Deselects a value or an array of values.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.deselect = function (value) {\\n        this._unmarkSelected(value);\\n        this._emitChangeEvent();\\n    };\\n    /**\\n     * Toggles a value between selected and deselected.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.toggle = function (value) {\\n        this.isSelected(value) ? this.deselect(value) : this.select(value);\\n    };\\n    /**\\n     * Clears all of the selected values.\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.clear = function () {\\n        this._unmarkAll();\\n        this._emitChangeEvent();\\n    };\\n    /**\\n     * Determines whether a value is selected.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.isSelected = function (value) {\\n        return this._selection.has(value);\\n    };\\n    /**\\n     * Determines whether the model does not have a value.\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.isEmpty = function () {\\n        return this._selection.size === 0;\\n    };\\n    /**\\n     * Determines whether the model has a value.\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.hasValue = function () {\\n        return !this.isEmpty();\\n    };\\n    /**\\n     * Sorts the selected values based on a predicate function.\\n     * @param {?=} predicate\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.sort = function (predicate) {\\n        if (this._isMulti && this.selected) {\\n            this._selected.sort(predicate);\\n        }\\n    };\\n    /**\\n     * Emits a change event and clears the records of selected and deselected values.\\n     * @return {?}\\n     */\\n    SelectionModel.prototype._emitChangeEvent = function () {\\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\\n            var /** @type {?} */ eventData = new SelectionChange(this._selectedToEmit, this._deselectedToEmit);\\n            this.onChange.next(eventData);\\n            this._deselectedToEmit = [];\\n            this._selectedToEmit = [];\\n        }\\n        this._selected = null;\\n    };\\n    /**\\n     * Selects a value.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype._markSelected = function (value) {\\n        if (!this.isSelected(value)) {\\n            if (!this._isMulti) {\\n                this._unmarkAll();\\n            }\\n            this._selection.add(value);\\n            if (this._emitChanges) {\\n                this._selectedToEmit.push(value);\\n            }\\n        }\\n    };\\n    /**\\n     * Deselects a value.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype._unmarkSelected = function (value) {\\n        if (this.isSelected(value)) {\\n            this._selection.delete(value);\\n            if (this._emitChanges) {\\n                this._deselectedToEmit.push(value);\\n            }\\n        }\\n    };\\n    /**\\n     * Clears out the selected values.\\n     * @return {?}\\n     */\\n    SelectionModel.prototype._unmarkAll = function () {\\n        var _this = this;\\n        if (!this.isEmpty()) {\\n            this._selection.forEach(function (value) { return _this._unmarkSelected(value); });\\n        }\\n    };\\n    return SelectionModel;\\n}());\\n/**\\n * Describes an event emitted when the value of a MdSelectionModel has changed.\\n * \\\\@docs-private\\n */\\nvar SelectionChange = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?=} added\\n     * @param {?=} removed\\n     */\\n    function SelectionChange(added, removed) {\\n        this.added = added;\\n        this.removed = removed;\\n    }\\n    return SelectionChange;\\n}());\\n/**\\n * Screenreaders will often fire fake mousedown events when a focusable element\\n * is activated using the keyboard. We can typically distinguish between these faked\\n * mousedown events and real mousedown events using the \"buttons\" property. While\\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\\n * the left mouse button), faked mousedowns will usually set the property value to 0.\\n * @param {?} event\\n * @return {?}\\n */\\nfunction isFakeMousedownFromScreenReader(event) {\\n    return event.buttons === 0;\\n}\\n/**\\n * Class to coordinate unique selection based on name.\\n * Intended to be consumed as an Angular service.\\n * This service is needed because native radio change events are only fired on the item currently\\n * being selected, and we still need to uncheck the previous selection.\\n *\\n * This service does not *store* any IDs and names because they may change at any time, so it is\\n * less error-prone if they are simply passed through when the events occur.\\n */\\nvar UniqueSelectionDispatcher = /*@__PURE__*/(function () {\\n    function UniqueSelectionDispatcher() {\\n        this._listeners = [];\\n    }\\n    /**\\n     * Notify other items that selection for the given name has been set.\\n     * @param {?} id ID of the item.\\n     * @param {?} name Name of the item.\\n     * @return {?}\\n     */\\n    UniqueSelectionDispatcher.prototype.notify = function (id, name) {\\n        for (var _i = 0, _a = this._listeners; _i < _a.length; _i++) {\\n            var listener = _a[_i];\\n            listener(id, name);\\n        }\\n    };\\n    /**\\n     * Listen for future changes to item selection.\\n     * @param {?} listener\\n     * @return {?}\\n     */\\n    UniqueSelectionDispatcher.prototype.listen = function (listener) {\\n        this._listeners.push(listener);\\n    };\\n    return UniqueSelectionDispatcher;\\n}());\\nUniqueSelectionDispatcher.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nUniqueSelectionDispatcher.ctorParameters = function () { return []; };\\n/**\\n * @param {?} parentDispatcher\\n * @return {?}\\n */\\nfunction UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY(parentDispatcher) {\\n    return parentDispatcher || new UniqueSelectionDispatcher();\\n}\\nvar UNIQUE_SELECTION_DISPATCHER_PROVIDER = {\\n    // If there is already a dispatcher available, use that. Otherwise, provide a new one.\\n    provide: UniqueSelectionDispatcher,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), UniqueSelectionDispatcher]],\\n    useFactory: UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY\\n};\\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\\n// that a value of around 650ms seems appropriate.\\nvar TOUCH_BUFFER_MS = 650;\\n/**\\n * Monitors mouse and keyboard events to determine the cause of focus events.\\n */\\nvar FocusOriginMonitor = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _ngZone\\n     * @param {?} _platform\\n     */\\n    function FocusOriginMonitor(_ngZone, _platform) {\\n        var _this = this;\\n        this._ngZone = _ngZone;\\n        this._platform = _platform;\\n        /**\\n         * The focus origin that the next focus event is a result of.\\n         */\\n        this._origin = null;\\n        /**\\n         * Whether the window has just been focused.\\n         */\\n        this._windowFocused = false;\\n        /**\\n         * Weak map of elements being monitored to their info.\\n         */\\n        this._elementInfo = new WeakMap();\\n        this._ngZone.runOutsideAngular(function () { return _this._registerDocumentEvents(); });\\n    }\\n    /**\\n     * Monitors focus on an element and applies appropriate CSS classes.\\n     * @param {?} element The element to monitor\\n     * @param {?} renderer The renderer to use to apply CSS classes to the element.\\n     * @param {?} checkChildren Whether to count the element as focused when its children are focused.\\n     * @return {?} An observable that emits when the focus state of the element changes.\\n     *     When the element is blurred, null will be emitted.\\n     */\\n    FocusOriginMonitor.prototype.monitor = function (element, renderer, checkChildren) {\\n        var _this = this;\\n        // Do nothing if we\\'re not on the browser platform.\\n        if (!this._platform.isBrowser) {\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].of();\\n        }\\n        // Check if we\\'re already monitoring this element.\\n        if (this._elementInfo.has(element)) {\\n            var /** @type {?} */ info_1 = this._elementInfo.get(element);\\n            info_1.checkChildren = checkChildren;\\n            return info_1.subject.asObservable();\\n        }\\n        // Create monitored element info.\\n        var /** @type {?} */ info = {\\n            unlisten: null,\\n            checkChildren: checkChildren,\\n            renderer: renderer,\\n            subject: new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]()\\n        };\\n        this._elementInfo.set(element, info);\\n        // Start listening. We need to listen in capture phase since focus events don\\'t bubble.\\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\\n        this._ngZone.runOutsideAngular(function () {\\n            element.addEventListener(\\'focus\\', focusListener, true);\\n            element.addEventListener(\\'blur\\', blurListener, true);\\n        });\\n        // Create an unlisten function for later.\\n        info.unlisten = function () {\\n            element.removeEventListener(\\'focus\\', focusListener, true);\\n            element.removeEventListener(\\'blur\\', blurListener, true);\\n        };\\n        return info.subject.asObservable();\\n    };\\n    /**\\n     * Stops monitoring an element and removes all focus classes.\\n     * @param {?} element The element to stop monitoring.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype.stopMonitoring = function (element) {\\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\\n        if (elementInfo) {\\n            elementInfo.unlisten();\\n            elementInfo.subject.complete();\\n            this._setClasses(element, null);\\n            this._elementInfo.delete(element);\\n        }\\n    };\\n    /**\\n     * Focuses the element via the specified focus origin.\\n     * @param {?} element The element to focus.\\n     * @param {?} renderer The renderer to use to invoke the focus method on the element.\\n     * @param {?} origin The focus origin.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype.focusVia = function (element, renderer, origin) {\\n        this._setOriginForCurrentEventQueue(origin);\\n        element.focus();\\n    };\\n    /**\\n     * Register necessary event listeners on the document and window.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype._registerDocumentEvents = function () {\\n        var _this = this;\\n        // Do nothing if we\\'re not on the browser platform.\\n        if (!this._platform.isBrowser) {\\n            return;\\n        }\\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\\n        // propagation.\\n        // On keydown record the origin and clear any touch event that may be in progress.\\n        document.addEventListener(\\'keydown\\', function () {\\n            _this._lastTouchTarget = null;\\n            _this._setOriginForCurrentEventQueue(\\'keyboard\\');\\n        }, true);\\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\\n        // happen as a result of a touch event.\\n        document.addEventListener(\\'mousedown\\', function () {\\n            if (!_this._lastTouchTarget) {\\n                _this._setOriginForCurrentEventQueue(\\'mouse\\');\\n            }\\n        }, true);\\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\\n        // we can\\'t rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\\n        // see if a focus happens.\\n        document.addEventListener(\\'touchstart\\', function (event) {\\n            if (_this._touchTimeout != null) {\\n                clearTimeout(_this._touchTimeout);\\n            }\\n            _this._lastTouchTarget = event.target;\\n            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\\n        }, true);\\n        // Make a note of when the window regains focus, so we can restore the origin info for the\\n        // focused element.\\n        window.addEventListener(\\'focus\\', function () {\\n            _this._windowFocused = true;\\n            setTimeout(function () { return _this._windowFocused = false; }, 0);\\n        });\\n    };\\n    /**\\n     * Sets the focus classes on the element based on the given focus origin.\\n     * @param {?} element The element to update the classes on.\\n     * @param {?} origin The focus origin.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype._setClasses = function (element, origin) {\\n        var /** @type {?} */ renderer = this._elementInfo.get(element).renderer;\\n        var /** @type {?} */ toggleClass = function (className, shouldSet) {\\n            shouldSet ? renderer.addClass(element, className) : renderer.removeClass(element, className);\\n        };\\n        toggleClass(\\'cdk-focused\\', !!origin);\\n        toggleClass(\\'cdk-touch-focused\\', origin === \\'touch\\');\\n        toggleClass(\\'cdk-keyboard-focused\\', origin === \\'keyboard\\');\\n        toggleClass(\\'cdk-mouse-focused\\', origin === \\'mouse\\');\\n        toggleClass(\\'cdk-program-focused\\', origin === \\'program\\');\\n    };\\n    /**\\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\\n     * @param {?} origin The origin to set.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype._setOriginForCurrentEventQueue = function (origin) {\\n        var _this = this;\\n        this._origin = origin;\\n        setTimeout(function () { return _this._origin = null; }, 0);\\n    };\\n    /**\\n     * Checks whether the given focus event was caused by a touchstart event.\\n     * @param {?} event The focus event to check.\\n     * @return {?} Whether the event was caused by a touch.\\n     */\\n    FocusOriginMonitor.prototype._wasCausedByTouch = function (event) {\\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\\n        // Consider the following dom structure:\\n        //\\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\\n        //   <div #child (click)=\"#parent.focus()\"></div>\\n        // </div>\\n        //\\n        // If the user touches the #child element and the #parent is programmatically focused as a\\n        // result, this code will still consider it to have been caused by the touch event and will\\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\\n        // relatively small edge-case that can be worked around by using\\n        // focusVia(parentEl, renderer,  \\'program\\') to focus the parent element.\\n        //\\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\\n        // for the first focus event after the touchstart, and then the first blur event after that\\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\\n        // touchstart.\\n        var /** @type {?} */ focusTarget = event.target;\\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\\n    };\\n    /**\\n     * Handles focus events on a registered element.\\n     * @param {?} event The focus event.\\n     * @param {?} element The monitored element.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype._onFocus = function (event, element) {\\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\\n        // focus event affecting the monitored element. If we want to use the origin of the first event\\n        // instead we should check for the cdk-focused class here and return if the element already has\\n        // it. (This only matters for elements that have includesChildren = true).\\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\\n        // monitored element itself.\\n        if (!this._elementInfo.get(element).checkChildren && element !== event.target) {\\n            return;\\n        }\\n        // If we couldn\\'t detect a cause for the focus event, it\\'s due to one of three reasons:\\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\\n        //    the element from before the window blurred.\\n        // 2) It was caused by a touch event, in which case we mark the origin as \\'touch\\'.\\n        // 3) The element was programmatically focused, in which case we should mark the origin as\\n        //    \\'program\\'.\\n        if (!this._origin) {\\n            if (this._windowFocused && this._lastFocusOrigin) {\\n                this._origin = this._lastFocusOrigin;\\n            }\\n            else if (this._wasCausedByTouch(event)) {\\n                this._origin = \\'touch\\';\\n            }\\n            else {\\n                this._origin = \\'program\\';\\n            }\\n        }\\n        this._setClasses(element, this._origin);\\n        this._elementInfo.get(element).subject.next(this._origin);\\n        this._lastFocusOrigin = this._origin;\\n        this._origin = null;\\n    };\\n    /**\\n     * Handles blur events on a registered element.\\n     * @param {?} event The blur event.\\n     * @param {?} element The monitored element.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype._onBlur = function (event, element) {\\n        // If we are counting child-element-focus as focused, make sure that we aren\\'t just blurring in\\n        // order to focus another child of the monitored element.\\n        if (this._elementInfo.get(element).checkChildren && event.relatedTarget instanceof Node &&\\n            element.contains(event.relatedTarget)) {\\n            return;\\n        }\\n        this._setClasses(element, null);\\n        this._elementInfo.get(element).subject.next(null);\\n    };\\n    return FocusOriginMonitor;\\n}());\\nFocusOriginMonitor.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nFocusOriginMonitor.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: Platform, },\\n]; };\\n/**\\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\\n * programmatically) and adds corresponding classes to the element.\\n *\\n * There are two variants of this directive:\\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\\n *    focused.\\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\\n */\\nvar CdkMonitorFocus = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _focusOriginMonitor\\n     * @param {?} renderer\\n     */\\n    function CdkMonitorFocus(_elementRef, _focusOriginMonitor, renderer) {\\n        var _this = this;\\n        this._elementRef = _elementRef;\\n        this._focusOriginMonitor = _focusOriginMonitor;\\n        this.cdkFocusChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        this._focusOriginMonitor.monitor(this._elementRef.nativeElement, renderer, this._elementRef.nativeElement.hasAttribute(\\'cdkMonitorSubtreeFocus\\'))\\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    CdkMonitorFocus.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._elementRef.nativeElement);\\n    };\\n    return CdkMonitorFocus;\\n}());\\nCdkMonitorFocus.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkMonitorFocus.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusOriginMonitor, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\nCdkMonitorFocus.propDecorators = {\\n    \\'cdkFocusChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * @param {?} parentDispatcher\\n * @param {?} ngZone\\n * @param {?} platform\\n * @return {?}\\n */\\nfunction FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\\n    return parentDispatcher || new FocusOriginMonitor(ngZone, platform);\\n}\\nvar FOCUS_ORIGIN_MONITOR_PROVIDER = {\\n    // If there is already a FocusOriginMonitor available, use that. Otherwise, provide a new one.\\n    provide: FocusOriginMonitor,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), FocusOriginMonitor], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], Platform],\\n    useFactory: FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY\\n};\\n/**\\n * Applies a CSS transform to an element, including browser-prefixed properties.\\n * @param {?} element\\n * @param {?} transformValue\\n * @return {?}\\n */\\nfunction applyCssTransform(element, transformValue) {\\n    // It\\'s important to trim the result, because the browser will ignore the set operation\\n    // if the string contains only whitespace.\\n    var /** @type {?} */ value = transformValue.trim();\\n    element.style.transform = value;\\n    element.style.webkitTransform = value;\\n}\\nvar StyleModule = /*@__PURE__*/(function () {\\n    function StyleModule() {\\n    }\\n    return StyleModule;\\n}());\\nStyleModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [PlatformModule],\\n                declarations: [CdkMonitorFocus],\\n                exports: [CdkMonitorFocus],\\n                providers: [FOCUS_ORIGIN_MONITOR_PROVIDER],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nStyleModule.ctorParameters = function () { return []; };\\n/**\\n * \\\\@docs-private\\n */\\nvar AnimationCurves = /*@__PURE__*/(function () {\\n    function AnimationCurves() {\\n    }\\n    return AnimationCurves;\\n}());\\nAnimationCurves.STANDARD_CURVE = \\'cubic-bezier(0.4,0.0,0.2,1)\\';\\nAnimationCurves.DECELERATION_CURVE = \\'cubic-bezier(0.0,0.0,0.2,1)\\';\\nAnimationCurves.ACCELERATION_CURVE = \\'cubic-bezier(0.4,0.0,1,1)\\';\\nAnimationCurves.SHARP_CURVE = \\'cubic-bezier(0.4,0.0,0.6,1)\\';\\n/**\\n * \\\\@docs-private\\n */\\nvar AnimationDurations = /*@__PURE__*/(function () {\\n    function AnimationDurations() {\\n    }\\n    return AnimationDurations;\\n}());\\nAnimationDurations.COMPLEX = \\'375ms\\';\\nAnimationDurations.ENTERING = \\'225ms\\';\\nAnimationDurations.EXITING = \\'195ms\\';\\n/**\\n * Coerces a data-bound value (typically a string) to a number.\\n * @param {?} value\\n * @param {?=} fallbackValue\\n * @return {?}\\n */\\nfunction coerceNumberProperty(value, fallbackValue) {\\n    if (fallbackValue === void 0) { fallbackValue = 0; }\\n    // parseFloat(value) handles most of the cases we\\'re interested in (it treats null, empty string,\\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\\n    // \\'123hello\\' to be a valid number. Therefore we also check if Number(value) is NaN.\\n    return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);\\n}\\n/**\\n * Adapts type `D` to be usable as a date by cdk-based components that work with dates.\\n * @abstract\\n */\\nvar DateAdapter = /*@__PURE__*/(function () {\\n    function DateAdapter() {\\n    }\\n    /**\\n     * Gets the year component of the given date.\\n     * @abstract\\n     * @param {?} date The date to extract the year from.\\n     * @return {?} The year component.\\n     */\\n    DateAdapter.prototype.getYear = function (date) { };\\n    /**\\n     * Gets the month component of the given date.\\n     * @abstract\\n     * @param {?} date The date to extract the month from.\\n     * @return {?} The month component (0-indexed, 0 = January).\\n     */\\n    DateAdapter.prototype.getMonth = function (date) { };\\n    /**\\n     * Gets the date of the month component of the given date.\\n     * @abstract\\n     * @param {?} date The date to extract the date of the month from.\\n     * @return {?} The month component (1-indexed, 1 = first of month).\\n     */\\n    DateAdapter.prototype.getDate = function (date) { };\\n    /**\\n     * Gets the day of the week component of the given date.\\n     * @abstract\\n     * @param {?} date The date to extract the day of the week from.\\n     * @return {?} The month component (0-indexed, 0 = Sunday).\\n     */\\n    DateAdapter.prototype.getDayOfWeek = function (date) { };\\n    /**\\n     * Gets a list of names for the months.\\n     * @abstract\\n     * @param {?} style The naming style (e.g. long = \\'January\\', short = \\'Jan\\', narrow = \\'J\\').\\n     * @return {?} An ordered list of all month names, starting with January.\\n     */\\n    DateAdapter.prototype.getMonthNames = function (style$$1) { };\\n    /**\\n     * Gets a list of names for the dates of the month.\\n     * @abstract\\n     * @return {?} An ordered list of all date of the month names, starting with \\'1\\'.\\n     */\\n    DateAdapter.prototype.getDateNames = function () { };\\n    /**\\n     * Gets a list of names for the days of the week.\\n     * @abstract\\n     * @param {?} style The naming style (e.g. long = \\'Sunday\\', short = \\'Sun\\', narrow = \\'S\\').\\n     * @return {?} An ordered list of all weekday names, starting with Sunday.\\n     */\\n    DateAdapter.prototype.getDayOfWeekNames = function (style$$1) { };\\n    /**\\n     * Gets the name for the year of the given date.\\n     * @abstract\\n     * @param {?} date The date to get the year name for.\\n     * @return {?} The name of the given year (e.g. \\'2017\\').\\n     */\\n    DateAdapter.prototype.getYearName = function (date) { };\\n    /**\\n     * Gets the first day of the week.\\n     * @abstract\\n     * @return {?} The first day of the week (0-indexed, 0 = Sunday).\\n     */\\n    DateAdapter.prototype.getFirstDayOfWeek = function () { };\\n    /**\\n     * Gets the number of days in the month of the given date.\\n     * @abstract\\n     * @param {?} date The date whose month should be checked.\\n     * @return {?} The number of days in the month of the given date.\\n     */\\n    DateAdapter.prototype.getNumDaysInMonth = function (date) { };\\n    /**\\n     * Clones the given date.\\n     * @abstract\\n     * @param {?} date The date to clone\\n     * @return {?} A new date equal to the given date.\\n     */\\n    DateAdapter.prototype.clone = function (date) { };\\n    /**\\n     * Creates a date with the given year, month, and date. Does not allow over/under-flow of the\\n     * month and date.\\n     * @abstract\\n     * @param {?} year The full year of the date. (e.g. 89 means the year 89, not the year 1989).\\n     * @param {?} month The month of the date (0-indexed, 0 = January). Must be an integer 0 - 11.\\n     * @param {?} date The date of month of the date. Must be an integer 1 - length of the given month.\\n     * @return {?} The new date, or null if invalid.\\n     */\\n    DateAdapter.prototype.createDate = function (year, month, date) { };\\n    /**\\n     * Gets today\\'s date.\\n     * @abstract\\n     * @return {?} Today\\'s date.\\n     */\\n    DateAdapter.prototype.today = function () { };\\n    /**\\n     * Parses a date from a value.\\n     * @abstract\\n     * @param {?} value The value to parse.\\n     * @param {?} parseFormat The expected format of the value being parsed\\n     *     (type is implementation-dependent).\\n     * @return {?} The parsed date, or null if date could not be parsed.\\n     */\\n    DateAdapter.prototype.parse = function (value, parseFormat) { };\\n    /**\\n     * Formats a date as a string.\\n     * @abstract\\n     * @param {?} date The value to parse.\\n     * @param {?} displayFormat The format to use to display the date as a string.\\n     * @return {?} The parsed date, or null if date could not be parsed.\\n     */\\n    DateAdapter.prototype.format = function (date, displayFormat) { };\\n    /**\\n     * Adds the given number of years to the date. Years are counted as if flipping 12 pages on the\\n     * calendar for each year and then finding the closest date in the new month. For example when\\n     * adding 1 year to Feb 29, 2016, the resulting date will be Feb 28, 2017.\\n     * @abstract\\n     * @param {?} date The date to add years to.\\n     * @param {?} years The number of years to add (may be negative).\\n     * @return {?} A new date equal to the given one with the specified number of years added.\\n     */\\n    DateAdapter.prototype.addCalendarYears = function (date, years) { };\\n    /**\\n     * Adds the given number of months to the date. Months are counted as if flipping a page on the\\n     * calendar for each month and then finding the closest date in the new month. For example when\\n     * adding 1 month to Jan 31, 2017, the resulting date will be Feb 28, 2017.\\n     * @abstract\\n     * @param {?} date The date to add months to.\\n     * @param {?} months The number of months to add (may be negative).\\n     * @return {?} A new date equal to the given one with the specified number of months added.\\n     */\\n    DateAdapter.prototype.addCalendarMonths = function (date, months) { };\\n    /**\\n     * Adds the given number of days to the date. Days are counted as if moving one cell on the\\n     * calendar for each day.\\n     * @abstract\\n     * @param {?} date The date to add days to.\\n     * @param {?} days The number of days to add (may be negative).\\n     * @return {?} A new date equal to the given one with the specified number of days added.\\n     */\\n    DateAdapter.prototype.addCalendarDays = function (date, days) { };\\n    /**\\n     * Gets the RFC 3339 compatible date string (https://tools.ietf.org/html/rfc3339)  for the given\\n     * date.\\n     * @abstract\\n     * @param {?} date The date to get the ISO date string for.\\n     * @return {?} The ISO date string date string.\\n     */\\n    DateAdapter.prototype.getISODateString = function (date) { };\\n    /**\\n     * Sets the locale used for all dates.\\n     * @param {?} locale The new locale.\\n     * @return {?}\\n     */\\n    DateAdapter.prototype.setLocale = function (locale) {\\n        this.locale = locale;\\n    };\\n    /**\\n     * Compares two dates.\\n     * @param {?} first The first date to compare.\\n     * @param {?} second The second date to compare.\\n     * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,\\n     *     a number greater than 0 if the first date is later.\\n     */\\n    DateAdapter.prototype.compareDate = function (first, second) {\\n        return this.getYear(first) - this.getYear(second) ||\\n            this.getMonth(first) - this.getMonth(second) ||\\n            this.getDate(first) - this.getDate(second);\\n    };\\n    /**\\n     * Checks if two dates are equal.\\n     * @param {?} first The first date to check.\\n     * @param {?} second The second date to check.\\n     *     Null dates are considered equal to other null dates.\\n     * @return {?}\\n     */\\n    DateAdapter.prototype.sameDate = function (first, second) {\\n        return first && second ? !this.compareDate(first, second) : first == second;\\n    };\\n    /**\\n     * Clamp the given date between min and max dates.\\n     * @param {?} date The date to clamp.\\n     * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.\\n     * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.\\n     * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,\\n     *     otherwise `date`.\\n     */\\n    DateAdapter.prototype.clampDate = function (date, min, max) {\\n        if (min && this.compareDate(date, min) < 0) {\\n            return min;\\n        }\\n        if (max && this.compareDate(date, max) > 0) {\\n            return max;\\n        }\\n        return date;\\n    };\\n    return DateAdapter;\\n}());\\n/**\\n * Whether the browser supports the Intl API.\\n */\\nvar SUPPORTS_INTL_API = typeof Intl != \\'undefined\\';\\n/**\\n * The default month names to use if Intl API is not available.\\n */\\nvar DEFAULT_MONTH_NAMES = {\\n    \\'long\\': [\\n        \\'January\\', \\'February\\', \\'March\\', \\'April\\', \\'May\\', \\'June\\', \\'July\\', \\'August\\', \\'September\\',\\n        \\'October\\', \\'November\\', \\'December\\'\\n    ],\\n    \\'short\\': [\\'Jan\\', \\'Feb\\', \\'Mar\\', \\'Apr\\', \\'May\\', \\'Jun\\', \\'Jul\\', \\'Aug\\', \\'Sep\\', \\'Oct\\', \\'Nov\\', \\'Dec\\'],\\n    \\'narrow\\': [\\'J\\', \\'F\\', \\'M\\', \\'A\\', \\'M\\', \\'J\\', \\'J\\', \\'A\\', \\'S\\', \\'O\\', \\'N\\', \\'D\\']\\n};\\n/**\\n * The default date names to use if Intl API is not available.\\n */\\nvar DEFAULT_DATE_NAMES = range(31, function (i) { return String(i + 1); });\\n/**\\n * The default day of the week names to use if Intl API is not available.\\n */\\nvar DEFAULT_DAY_OF_WEEK_NAMES = {\\n    \\'long\\': [\\'Sunday\\', \\'Monday\\', \\'Tuesday\\', \\'Wednesday\\', \\'Thursday\\', \\'Friday\\', \\'Saturday\\'],\\n    \\'short\\': [\\'Sun\\', \\'Mon\\', \\'Tue\\', \\'Wed\\', \\'Thu\\', \\'Fri\\', \\'Sat\\'],\\n    \\'narrow\\': [\\'S\\', \\'M\\', \\'T\\', \\'W\\', \\'T\\', \\'F\\', \\'S\\']\\n};\\n/**\\n * Creates an array and fills it with values.\\n * @template T\\n * @param {?} length\\n * @param {?} valueFunction\\n * @return {?}\\n */\\nfunction range(length, valueFunction) {\\n    return Array.apply(null, Array(length)).map(function (v, i) { return valueFunction(i); });\\n}\\n/**\\n * Adapts the native JS Date for use with cdk-based components that work with dates.\\n */\\nvar NativeDateAdapter = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](NativeDateAdapter, _super);\\n    function NativeDateAdapter() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getYear = function (date) {\\n        return date.getFullYear();\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getMonth = function (date) {\\n        return date.getMonth();\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getDate = function (date) {\\n        return date.getDate();\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getDayOfWeek = function (date) {\\n        return date.getDay();\\n    };\\n    /**\\n     * @param {?} style\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getMonthNames = function (style$$1) {\\n        var _this = this;\\n        if (SUPPORTS_INTL_API) {\\n            var /** @type {?} */ dtf_1 = new Intl.DateTimeFormat(this.locale, { month: style$$1 });\\n            return range(12, function (i) { return _this._stripDirectionalityCharacters(dtf_1.format(new Date(2017, i, 1))); });\\n        }\\n        return DEFAULT_MONTH_NAMES[style$$1];\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getDateNames = function () {\\n        var _this = this;\\n        if (SUPPORTS_INTL_API) {\\n            var /** @type {?} */ dtf_2 = new Intl.DateTimeFormat(this.locale, { day: \\'numeric\\' });\\n            return range(31, function (i) { return _this._stripDirectionalityCharacters(dtf_2.format(new Date(2017, 0, i + 1))); });\\n        }\\n        return DEFAULT_DATE_NAMES;\\n    };\\n    /**\\n     * @param {?} style\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getDayOfWeekNames = function (style$$1) {\\n        var _this = this;\\n        if (SUPPORTS_INTL_API) {\\n            var /** @type {?} */ dtf_3 = new Intl.DateTimeFormat(this.locale, { weekday: style$$1 });\\n            return range(7, function (i) { return _this._stripDirectionalityCharacters(dtf_3.format(new Date(2017, 0, i + 1))); });\\n        }\\n        return DEFAULT_DAY_OF_WEEK_NAMES[style$$1];\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getYearName = function (date) {\\n        if (SUPPORTS_INTL_API) {\\n            var /** @type {?} */ dtf = new Intl.DateTimeFormat(this.locale, { year: \\'numeric\\' });\\n            return this._stripDirectionalityCharacters(dtf.format(date));\\n        }\\n        return String(this.getYear(date));\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getFirstDayOfWeek = function () {\\n        // We can\\'t tell using native JS Date what the first day of the week is, we default to Sunday.\\n        return 0;\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getNumDaysInMonth = function (date) {\\n        return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.clone = function (date) {\\n        return this.createDate(this.getYear(date), this.getMonth(date), this.getDate(date));\\n    };\\n    /**\\n     * @param {?} year\\n     * @param {?} month\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.createDate = function (year, month, date) {\\n        // Check for invalid month and date (except upper bound on date which we have to check after\\n        // creating the Date).\\n        if (month < 0 || month > 11 || date < 1) {\\n            return null;\\n        }\\n        var /** @type {?} */ result = this._createDateWithOverflow(year, month, date);\\n        // Check that the date wasn\\'t above the upper bound for the month, causing the month to\\n        // overflow.\\n        if (result.getMonth() != month) {\\n            return null;\\n        }\\n        return result;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.today = function () {\\n        return new Date();\\n    };\\n    /**\\n     * @param {?} value\\n     * @param {?} parseFormat\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.parse = function (value, parseFormat) {\\n        // We have no way using the native JS Date to set the parse format or locale, so we ignore these\\n        // parameters.\\n        var /** @type {?} */ timestamp = typeof value == \\'number\\' ? value : Date.parse(value);\\n        return isNaN(timestamp) ? null : new Date(timestamp);\\n    };\\n    /**\\n     * @param {?} date\\n     * @param {?} displayFormat\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.format = function (date, displayFormat) {\\n        if (SUPPORTS_INTL_API) {\\n            var /** @type {?} */ dtf = new Intl.DateTimeFormat(this.locale, displayFormat);\\n            return this._stripDirectionalityCharacters(dtf.format(date));\\n        }\\n        return this._stripDirectionalityCharacters(date.toDateString());\\n    };\\n    /**\\n     * @param {?} date\\n     * @param {?} years\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.addCalendarYears = function (date, years) {\\n        return this.addCalendarMonths(date, years * 12);\\n    };\\n    /**\\n     * @param {?} date\\n     * @param {?} months\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.addCalendarMonths = function (date, months) {\\n        var /** @type {?} */ newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));\\n        // It\\'s possible to wind up in the wrong month if the original month has more days than the new\\n        // month. In this case we want to go to the last day of the desired month.\\n        // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn\\'t\\n        // guarantee this.\\n        if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {\\n            newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);\\n        }\\n        return newDate;\\n    };\\n    /**\\n     * @param {?} date\\n     * @param {?} days\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.addCalendarDays = function (date, days) {\\n        return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getISODateString = function (date) {\\n        return [\\n            date.getUTCFullYear(),\\n            this._2digit(date.getUTCMonth() + 1),\\n            this._2digit(date.getUTCDate())\\n        ].join(\\'-\\');\\n    };\\n    /**\\n     * Creates a date but allows the month and date to overflow.\\n     * @param {?} year\\n     * @param {?} month\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype._createDateWithOverflow = function (year, month, date) {\\n        var /** @type {?} */ result = new Date(year, month, date);\\n        // We need to correct for the fact that JS native Date treats years in range [0, 99] as\\n        // abbreviations for 19xx.\\n        if (year >= 0 && year < 100) {\\n            result.setFullYear(this.getYear(result) - 1900);\\n        }\\n        return result;\\n    };\\n    /**\\n     * Pads a number to make it two digits.\\n     * @param {?} n The number to pad.\\n     * @return {?} The padded number.\\n     */\\n    NativeDateAdapter.prototype._2digit = function (n) {\\n        return (\\'00\\' + n).slice(-2);\\n    };\\n    /**\\n     * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while\\n     * other browsers do not. We remove them to make output consistent and because they interfere with\\n     * date parsing.\\n     * @param {?} s The string to strip direction characters from.\\n     * @return {?} The stripped string.\\n     */\\n    NativeDateAdapter.prototype._stripDirectionalityCharacters = function (s) {\\n        return s.replace(/[\\\\u200e\\\\u200f]/g, \\'\\');\\n    };\\n    return NativeDateAdapter;\\n}(DateAdapter));\\nvar MD_DATE_FORMATS = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-date-formats\\');\\nvar MD_NATIVE_DATE_FORMATS = {\\n    parse: {\\n        dateInput: null,\\n    },\\n    display: {\\n        dateInput: { year: \\'numeric\\', month: \\'numeric\\', day: \\'numeric\\' },\\n        monthYearLabel: { year: \\'numeric\\', month: \\'short\\' },\\n        dateA11yLabel: { year: \\'numeric\\', month: \\'long\\', day: \\'numeric\\' },\\n        monthYearA11yLabel: { year: \\'numeric\\', month: \\'long\\' },\\n    }\\n};\\nvar NativeDateModule = /*@__PURE__*/(function () {\\n    function NativeDateModule() {\\n    }\\n    return NativeDateModule;\\n}());\\nNativeDateModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                providers: [{ provide: DateAdapter, useClass: NativeDateAdapter }],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nNativeDateModule.ctorParameters = function () { return []; };\\nvar MdNativeDateModule = /*@__PURE__*/(function () {\\n    function MdNativeDateModule() {\\n    }\\n    return MdNativeDateModule;\\n}());\\nMdNativeDateModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [NativeDateModule],\\n                providers: [{ provide: MD_DATE_FORMATS, useValue: MD_NATIVE_DATE_FORMATS }],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdNativeDateModule.ctorParameters = function () { return []; };\\nvar MdCoreModule = /*@__PURE__*/(function () {\\n    function MdCoreModule() {\\n    }\\n    return MdCoreModule;\\n}());\\nMdCoreModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    MdLineModule,\\n                    RtlModule,\\n                    MdRippleModule,\\n                    ObserveContentModule,\\n                    PortalModule,\\n                    OverlayModule,\\n                    A11yModule,\\n                    MdOptionModule,\\n                    MdSelectionModule,\\n                ],\\n                exports: [\\n                    MdLineModule,\\n                    RtlModule,\\n                    MdRippleModule,\\n                    ObserveContentModule,\\n                    PortalModule,\\n                    OverlayModule,\\n                    A11yModule,\\n                    MdOptionModule,\\n                    MdSelectionModule,\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCoreModule.ctorParameters = function () { return []; };\\n/**\\n * Provider Expression that allows md-button-toggle-group to register as a ControlValueAccessor.\\n * This allows it to support [(ngModel)].\\n * \\\\@docs-private\\n */\\nvar MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"])(function () { return MdButtonToggleGroup; }),\\n    multi: true\\n};\\nvar _uniqueIdCounter$1 = 0;\\n/**\\n * Change event object emitted by MdButtonToggle.\\n */\\nvar MdButtonToggleChange = /*@__PURE__*/(function () {\\n    function MdButtonToggleChange() {\\n    }\\n    return MdButtonToggleChange;\\n}());\\n/**\\n * Exclusive selection button toggle group that behaves like a radio-button group.\\n */\\nvar MdButtonToggleGroup = /*@__PURE__*/(function () {\\n    function MdButtonToggleGroup() {\\n        /**\\n         * The value for the button toggle group. Should match currently selected button toggle.\\n         */\\n        this._value = null;\\n        /**\\n         * The HTML name attribute applied to toggles in this group.\\n         */\\n        this._name = \"md-button-toggle-group-\" + _uniqueIdCounter$1++;\\n        /**\\n         * Disables all toggles in the group.\\n         */\\n        this._disabled = null;\\n        /**\\n         * Whether the button toggle group should be vertical.\\n         */\\n        this._vertical = false;\\n        /**\\n         * The currently selected button toggle, should match the value.\\n         */\\n        this._selected = null;\\n        /**\\n         * Whether the button toggle group is initialized or not.\\n         */\\n        this._isInitialized = false;\\n        /**\\n         * The method to be called in order to update ngModel.\\n         * Now `ngModel` binding is not supported in multiple selection mode.\\n         */\\n        this._controlValueAccessorChangeFn = function (value) { };\\n        /**\\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\\n         */\\n        this.onTouched = function () { };\\n        /**\\n         * Child button toggle buttons.\\n         */\\n        this._buttonToggles = null;\\n        /**\\n         * Event emitted when the group\\'s value changes.\\n         */\\n        this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype.ngAfterViewInit = function () {\\n        this._isInitialized = true;\\n    };\\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"name\", {\\n        /**\\n         * `name` attribute for the underlying `input` element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._name;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._name = value;\\n            this._updateButtonToggleNames();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"disabled\", {\\n        /**\\n         * Whether the toggle group is disabled.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._disabled;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"vertical\", {\\n        /**\\n         * Whether the toggle group is vertical.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._vertical;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._vertical = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"value\", {\\n        /**\\n         * Value of the toggle group.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._value;\\n        },\\n        /**\\n         * @param {?} newValue\\n         * @return {?}\\n         */\\n        set: function (newValue) {\\n            if (this._value != newValue) {\\n                this._value = newValue;\\n                this._updateSelectedButtonToggleFromValue();\\n                // Only emit a change event if the view is completely initialized.\\n                // We don\\'t want to emit a change event for the initial values.\\n                if (this._isInitialized) {\\n                    this._emitChangeEvent();\\n                }\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"selected\", {\\n        /**\\n         * Whether the toggle group is selected.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._selected;\\n        },\\n        /**\\n         * @param {?} selected\\n         * @return {?}\\n         */\\n        set: function (selected) {\\n            this._selected = selected;\\n            this.value = selected ? selected.value : null;\\n            if (selected && !selected.checked) {\\n                selected.checked = true;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype._updateButtonToggleNames = function () {\\n        var _this = this;\\n        if (this._buttonToggles) {\\n            this._buttonToggles.forEach(function (toggle) {\\n                toggle.name = _this._name;\\n            });\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype._updateSelectedButtonToggleFromValue = function () {\\n        var _this = this;\\n        var /** @type {?} */ isAlreadySelected = this._selected != null && this._selected.value == this._value;\\n        if (this._buttonToggles != null && !isAlreadySelected) {\\n            var /** @type {?} */ matchingButtonToggle = this._buttonToggles.filter(function (buttonToggle) { return buttonToggle.value == _this._value; })[0];\\n            if (matchingButtonToggle) {\\n                this.selected = matchingButtonToggle;\\n            }\\n            else if (this.value == null) {\\n                this.selected = null;\\n                this._buttonToggles.forEach(function (buttonToggle) {\\n                    buttonToggle.checked = false;\\n                });\\n            }\\n        }\\n    };\\n    /**\\n     * Dispatch change event with current selection and group value.\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype._emitChangeEvent = function () {\\n        var /** @type {?} */ event = new MdButtonToggleChange();\\n        event.source = this._selected;\\n        event.value = this._value;\\n        this._controlValueAccessorChangeFn(event.value);\\n        this.change.emit(event);\\n    };\\n    /**\\n     * Sets the model value. Implemented as part of ControlValueAccessor.\\n     * @param {?} value Value to be set to the model.\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype.writeValue = function (value) {\\n        this.value = value;\\n    };\\n    /**\\n     * Registers a callback that will be triggered when the value has changed.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn On change callback function.\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype.registerOnChange = function (fn) {\\n        this._controlValueAccessorChangeFn = fn;\\n    };\\n    /**\\n     * Registers a callback that will be triggered when the control has been touched.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn On touch callback function.\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype.registerOnTouched = function (fn) {\\n        this.onTouched = fn;\\n    };\\n    /**\\n     * Toggles the disabled state of the component. Implemented as part of ControlValueAccessor.\\n     * @param {?} isDisabled Whether the component should be disabled.\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n    };\\n    return MdButtonToggleGroup;\\n}());\\nMdButtonToggleGroup.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-button-toggle-group:not([multiple]), mat-button-toggle-group:not([multiple])\\',\\n                providers: [MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR],\\n                host: {\\n                    \\'[class.mat-button-toggle-group]\\': \\'true\\',\\n                    \\'role\\': \\'radiogroup\\',\\n                    \\'[class.mat-button-toggle-vertical]\\': \\'vertical\\'\\n                },\\n                exportAs: \\'mdButtonToggleGroup\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonToggleGroup.ctorParameters = function () { return []; };\\nMdButtonToggleGroup.propDecorators = {\\n    \\'_buttonToggles\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"])(function () { return MdButtonToggle; }),] },],\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'vertical\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Multiple selection button-toggle group. `ngModel` is not supported in this mode.\\n */\\nvar MdButtonToggleGroupMultiple = /*@__PURE__*/(function () {\\n    function MdButtonToggleGroupMultiple() {\\n        /**\\n         * Disables all toggles in the group.\\n         */\\n        this._disabled = null;\\n        /**\\n         * Whether the button toggle group should be vertical.\\n         */\\n        this._vertical = false;\\n    }\\n    Object.defineProperty(MdButtonToggleGroupMultiple.prototype, \"disabled\", {\\n        /**\\n         * Whether the toggle group is disabled.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._disabled;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = (value != null && value !== false) ? true : null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggleGroupMultiple.prototype, \"vertical\", {\\n        /**\\n         * Whether the toggle group is vertical.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._vertical;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._vertical = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return MdButtonToggleGroupMultiple;\\n}());\\nMdButtonToggleGroupMultiple.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-button-toggle-group[multiple], mat-button-toggle-group[multiple]\\',\\n                exportAs: \\'mdButtonToggleGroup\\',\\n                host: {\\n                    \\'[class.mat-button-toggle-group]\\': \\'true\\',\\n                    \\'[class.mat-button-toggle-vertical]\\': \\'vertical\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonToggleGroupMultiple.ctorParameters = function () { return []; };\\nMdButtonToggleGroupMultiple.propDecorators = {\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'vertical\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Single button inside of a toggle group.\\n */\\nvar MdButtonToggle = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} toggleGroup\\n     * @param {?} toggleGroupMultiple\\n     * @param {?} _buttonToggleDispatcher\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     * @param {?} _focusOriginMonitor\\n     */\\n    function MdButtonToggle(toggleGroup, toggleGroupMultiple, _buttonToggleDispatcher, _renderer, _elementRef, _focusOriginMonitor) {\\n        var _this = this;\\n        this._buttonToggleDispatcher = _buttonToggleDispatcher;\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n        this._focusOriginMonitor = _focusOriginMonitor;\\n        /**\\n         * Whether or not this button toggle is checked.\\n         */\\n        this._checked = false;\\n        /**\\n         * Whether or not this button toggle is disabled.\\n         */\\n        this._disabled = null;\\n        /**\\n         * Value assigned to this button toggle.\\n         */\\n        this._value = null;\\n        /**\\n         * Whether or not the button toggle is a single selection.\\n         */\\n        this._isSingleSelector = null;\\n        /**\\n         * Event emitted when the group value changes.\\n         */\\n        this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        this.buttonToggleGroup = toggleGroup;\\n        this.buttonToggleGroupMultiple = toggleGroupMultiple;\\n        if (this.buttonToggleGroup) {\\n            _buttonToggleDispatcher.listen(function (id, name) {\\n                if (id != _this.id && name == _this.name) {\\n                    _this.checked = false;\\n                }\\n            });\\n            this._type = \\'radio\\';\\n            this.name = this.buttonToggleGroup.name;\\n            this._isSingleSelector = true;\\n        }\\n        else {\\n            // Even if there is no group at all, treat the button toggle as a checkbox so it can be\\n            // toggled on or off.\\n            this._type = \\'checkbox\\';\\n            this._isSingleSelector = false;\\n        }\\n    }\\n    Object.defineProperty(MdButtonToggle.prototype, \"inputId\", {\\n        /**\\n         * Unique ID for the underlying `input` element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.id + \"-input\";\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggle.prototype, \"checked\", {\\n        /**\\n         * Whether the button is checked.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._checked;\\n        },\\n        /**\\n         * @param {?} newCheckedState\\n         * @return {?}\\n         */\\n        set: function (newCheckedState) {\\n            if (this._isSingleSelector) {\\n                if (newCheckedState) {\\n                    // Notify all button toggles with the same name (in the same group) to un-check.\\n                    this._buttonToggleDispatcher.notify(this.id, this.name);\\n                }\\n            }\\n            this._checked = newCheckedState;\\n            if (newCheckedState && this._isSingleSelector && this.buttonToggleGroup.value != this.value) {\\n                this.buttonToggleGroup.selected = this;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggle.prototype, \"value\", {\\n        /**\\n         * MdButtonToggleGroup reads this to assign its own value.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._value;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._value != value) {\\n                if (this.buttonToggleGroup != null && this.checked) {\\n                    this.buttonToggleGroup.value = value;\\n                }\\n                this._value = value;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggle.prototype, \"disabled\", {\\n        /**\\n         * Whether the button is disabled.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._disabled || (this.buttonToggleGroup != null && this.buttonToggleGroup.disabled) ||\\n                (this.buttonToggleGroupMultiple != null && this.buttonToggleGroupMultiple.disabled);\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = (value != null && value !== false) ? true : null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype.ngOnInit = function () {\\n        if (this.id == null) {\\n            this.id = \"md-button-toggle-\" + _uniqueIdCounter$1++;\\n        }\\n        if (this.buttonToggleGroup && this._value == this.buttonToggleGroup.value) {\\n            this._checked = true;\\n        }\\n        this._focusOriginMonitor.monitor(this._elementRef.nativeElement, this._renderer, true);\\n    };\\n    /**\\n     * Focuses the button.\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype.focus = function () {\\n        this._inputElement.nativeElement.focus();\\n    };\\n    /**\\n     * Toggle the state of the current button toggle.\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype._toggle = function () {\\n        this.checked = !this.checked;\\n    };\\n    /**\\n     * Checks the button toggle due to an interaction with the underlying native input.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype._onInputChange = function (event) {\\n        event.stopPropagation();\\n        if (this._isSingleSelector) {\\n            // Propagate the change one-way via the group, which will in turn mark this\\n            // button toggle as checked.\\n            this.checked = true;\\n            this.buttonToggleGroup.selected = this;\\n            this.buttonToggleGroup.onTouched();\\n        }\\n        else {\\n            this._toggle();\\n        }\\n        // Emit a change event when the native input does.\\n        this._emitChangeEvent();\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype._onInputClick = function (event) {\\n        // We have to stop propagation for click events on the visual hidden input element.\\n        // By default, when a user clicks on a label element, a generated click event will be\\n        // dispatched on the associated input element. Since we are using a label element as our\\n        // root container, the click event on the `slide-toggle` will be executed twice.\\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\\n        // This will lead to multiple click events.\\n        // Preventing bubbling for the second event will solve that issue.\\n        event.stopPropagation();\\n    };\\n    /**\\n     * Dispatch change event with current value.\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype._emitChangeEvent = function () {\\n        var /** @type {?} */ event = new MdButtonToggleChange();\\n        event.source = this;\\n        event.value = this._value;\\n        this.change.emit(event);\\n    };\\n    return MdButtonToggle;\\n}());\\nMdButtonToggle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-button-toggle, mat-button-toggle\\',\\n                template: \"<label [attr.for]=\\\\\"inputId\\\\\" class=\\\\\"mat-button-toggle-label\\\\\"> <input #input class=\\\\\"mat-button-toggle-input cdk-visually-hidden\\\\\" [type]=\\\\\"_type\\\\\" [id]=\\\\\"inputId\\\\\" [checked]=\\\\\"checked\\\\\" [disabled]=\\\\\"disabled\\\\\" [name]=\\\\\"name\\\\\" (change)=\\\\\"_onInputChange($event)\\\\\" (click)=\\\\\"_onInputClick($event)\\\\\"> <div class=\\\\\"mat-button-toggle-label-content\\\\\"> <ng-content></ng-content> </div> </label> \\x3c!-- the touchstart handler prevents the overlay from capturing the initial tap on touch devices --\\x3e <div class=\\\\\"mat-button-toggle-focus-overlay\\\\\" (touchstart)=\\\\\"$event.preventDefault()\\\\\"></div> \",\\n                styles: [\".mat-button-toggle-group{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);position:relative;display:inline-flex;flex-direction:row;border-radius:2px;cursor:pointer;white-space:nowrap}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle-disabled .mat-button-toggle-label-content{cursor:default}.mat-button-toggle{white-space:nowrap;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;position:relative}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:1}.mat-button-toggle-label-content{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:inline-block;line-height:36px;padding:0 16px;cursor:pointer}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{border-radius:inherit;pointer-events:none;opacity:0;position:absolute;top:0;left:0;right:0;bottom:0} /*# sourceMappingURL=button-toggle.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'[class.mat-button-toggle]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonToggle.ctorParameters = function () { return [\\n    { type: MdButtonToggleGroup, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: MdButtonToggleGroupMultiple, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: UniqueSelectionDispatcher, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusOriginMonitor, },\\n]; };\\nMdButtonToggle.propDecorators = {\\n    \\'_inputElement\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'input\\',] },],\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'checked\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'class.mat-button-toggle-checked\\',] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'class.mat-button-toggle-disabled\\',] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdButtonToggleModule = /*@__PURE__*/(function () {\\n    function MdButtonToggleModule() {\\n    }\\n    return MdButtonToggleModule;\\n}());\\nMdButtonToggleModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"FormsModule\"], MdCommonModule, StyleModule],\\n                exports: [\\n                    MdButtonToggleGroup,\\n                    MdButtonToggleGroupMultiple,\\n                    MdButtonToggle,\\n                    MdCommonModule,\\n                ],\\n                declarations: [MdButtonToggleGroup, MdButtonToggleGroupMultiple, MdButtonToggle],\\n                providers: [UNIQUE_SELECTION_DISPATCHER_PROVIDER]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonToggleModule.ctorParameters = function () { return []; };\\n/**\\n * Mixin to augment a directive with a `disabled` property.\\n * @template T\\n * @param {?} base\\n * @return {?}\\n */\\nfunction mixinDisabled(base) {\\n    return (function (_super) {\\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](class_1, _super);\\n        /**\\n         * @param {...?} args\\n         */\\n        function class_1() {\\n            var args = [];\\n            for (var _i = 0; _i < arguments.length; _i++) {\\n                args[_i] = arguments[_i];\\n            }\\n            var _this = _super.apply(this, args) || this;\\n            _this._disabled = false;\\n            return _this;\\n        }\\n        Object.defineProperty(class_1.prototype, \"disabled\", {\\n            /**\\n             * @return {?}\\n             */\\n            get: function () { return this._disabled; },\\n            /**\\n             * @param {?} value\\n             * @return {?}\\n             */\\n            set: function (value) { this._disabled = coerceBooleanProperty(value); },\\n            enumerable: true,\\n            configurable: true\\n        });\\n        return class_1;\\n    }(base));\\n}\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdButtonCssMatStyler = /*@__PURE__*/(function () {\\n    function MdButtonCssMatStyler() {\\n    }\\n    return MdButtonCssMatStyler;\\n}());\\nMdButtonCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-button], button[mat-button], a[md-button], a[mat-button]\\',\\n                host: { \\'class\\': \\'mat-button\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdRaisedButtonCssMatStyler = /*@__PURE__*/(function () {\\n    function MdRaisedButtonCssMatStyler() {\\n    }\\n    return MdRaisedButtonCssMatStyler;\\n}());\\nMdRaisedButtonCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-raised-button], button[mat-raised-button], \\' +\\n                    \\'a[md-raised-button], a[mat-raised-button]\\',\\n                host: { \\'class\\': \\'mat-raised-button\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRaisedButtonCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdIconButtonCssMatStyler = /*@__PURE__*/(function () {\\n    function MdIconButtonCssMatStyler() {\\n    }\\n    return MdIconButtonCssMatStyler;\\n}());\\nMdIconButtonCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-icon-button], button[mat-icon-button], a[md-icon-button], a[mat-icon-button]\\',\\n                host: { \\'class\\': \\'mat-icon-button\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdIconButtonCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdFabCssMatStyler = /*@__PURE__*/(function () {\\n    function MdFabCssMatStyler() {\\n    }\\n    return MdFabCssMatStyler;\\n}());\\nMdFabCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-fab], button[mat-fab], a[md-fab], a[mat-fab]\\',\\n                host: { \\'class\\': \\'mat-fab\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdFabCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdMiniFabCssMatStyler = /*@__PURE__*/(function () {\\n    function MdMiniFabCssMatStyler() {\\n    }\\n    return MdMiniFabCssMatStyler;\\n}());\\nMdMiniFabCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-mini-fab], button[mat-mini-fab], a[md-mini-fab], a[mat-mini-fab]\\',\\n                host: { \\'class\\': \\'mat-mini-fab\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMiniFabCssMatStyler.ctorParameters = function () { return []; };\\nvar MdButtonBase = /*@__PURE__*/(function () {\\n    function MdButtonBase() {\\n    }\\n    return MdButtonBase;\\n}());\\nvar _MdButtonMixinBase = mixinDisabled(MdButtonBase);\\n/**\\n * Material design button.\\n */\\nvar MdButton = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdButton, _super);\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     * @param {?} _platform\\n     * @param {?} _focusOriginMonitor\\n     */\\n    function MdButton(_elementRef, _renderer, _platform, _focusOriginMonitor) {\\n        var _this = _super.call(this) || this;\\n        _this._elementRef = _elementRef;\\n        _this._renderer = _renderer;\\n        _this._platform = _platform;\\n        _this._focusOriginMonitor = _focusOriginMonitor;\\n        /**\\n         * Whether the button is round.\\n         */\\n        _this._isRoundButton = _this._hasAttributeWithPrefix(\\'fab\\', \\'mini-fab\\');\\n        /**\\n         * Whether the button is icon button.\\n         */\\n        _this._isIconButton = _this._hasAttributeWithPrefix(\\'icon-button\\');\\n        /**\\n         * Whether the ripple effect on click should be disabled.\\n         */\\n        _this._disableRipple = false;\\n        _this._focusOriginMonitor.monitor(_this._elementRef.nativeElement, _this._renderer, true);\\n        return _this;\\n    }\\n    Object.defineProperty(MdButton.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect for this button is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this._disableRipple = coerceBooleanProperty(v); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdButton.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._elementRef.nativeElement);\\n    };\\n    Object.defineProperty(MdButton.prototype, \"color\", {\\n        /**\\n         * The color of the button. Can be `primary`, `accent`, or `warn`.\\n         * @return {?}\\n         */\\n        get: function () { return this._color; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._updateColor(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} newColor\\n     * @return {?}\\n     */\\n    MdButton.prototype._updateColor = function (newColor) {\\n        this._setElementColor(this._color, false);\\n        this._setElementColor(newColor, true);\\n        this._color = newColor;\\n    };\\n    /**\\n     * @param {?} color\\n     * @param {?} isAdd\\n     * @return {?}\\n     */\\n    MdButton.prototype._setElementColor = function (color, isAdd) {\\n        if (color != null && color != \\'\\') {\\n            if (isAdd) {\\n                this._renderer.addClass(this._getHostElement(), \"mat-\" + color);\\n            }\\n            else {\\n                this._renderer.removeClass(this._getHostElement(), \"mat-\" + color);\\n            }\\n        }\\n    };\\n    /**\\n     * Focuses the button.\\n     * @return {?}\\n     */\\n    MdButton.prototype.focus = function () {\\n        this._getHostElement().focus();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdButton.prototype._getHostElement = function () {\\n        return this._elementRef.nativeElement;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdButton.prototype._isRippleDisabled = function () {\\n        return this.disableRipple || this.disabled;\\n    };\\n    /**\\n     * Gets whether the button has one of the given attributes\\n     * with either an \\'md-\\' or \\'mat-\\' prefix.\\n     * @param {...?} unprefixedAttributeNames\\n     * @return {?}\\n     */\\n    MdButton.prototype._hasAttributeWithPrefix = function () {\\n        var _this = this;\\n        var unprefixedAttributeNames = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            unprefixedAttributeNames[_i] = arguments[_i];\\n        }\\n        // If not on the browser, say that there are none of the attributes present.\\n        // Since these only affect how the ripple displays (and ripples only happen on the client),\\n        // detecting these attributes isn\\'t necessary when not on the browser.\\n        if (!this._platform.isBrowser) {\\n            return false;\\n        }\\n        return unprefixedAttributeNames.some(function (suffix) {\\n            var /** @type {?} */ el = _this._getHostElement();\\n            return el.hasAttribute(\\'md-\\' + suffix) || el.hasAttribute(\\'mat-\\' + suffix);\\n        });\\n    };\\n    return MdButton;\\n}(_MdButtonMixinBase));\\nMdButton.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'button[md-button], button[md-raised-button], button[md-icon-button],\\' +\\n                    \\'button[md-fab], button[md-mini-fab],\\' +\\n                    \\'button[mat-button], button[mat-raised-button], button[mat-icon-button],\\' +\\n                    \\'button[mat-fab], button[mat-mini-fab]\\',\\n                host: {\\n                    \\'[disabled]\\': \\'disabled || null\\',\\n                },\\n                template: \"<span class=\\\\\"mat-button-wrapper\\\\\"><ng-content></ng-content></span> <div md-ripple class=\\\\\"mat-button-ripple\\\\\" [class.mat-button-ripple-round]=\\\\\"_isRoundButton || _isIconButton\\\\\" [mdRippleDisabled]=\\\\\"_isRippleDisabled()\\\\\" [mdRippleCentered]=\\\\\"_isIconButton\\\\\" [mdRippleTrigger]=\\\\\"_getHostElement()\\\\\"></div> <div class=\\\\\"mat-button-focus-overlay\\\\\"></div> \",\\n                styles: [\".mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;font-size:14px;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;font-weight:500;text-align:center;margin:0;min-width:88px;line-height:36px;padding:0 16px;border-radius:2px}[disabled].mat-button,[disabled].mat-fab,[disabled].mat-icon-button,[disabled].mat-mini-fab,[disabled].mat-raised-button{cursor:default}.cdk-keyboard-focused.mat-button .mat-button-focus-overlay,.cdk-keyboard-focused.mat-fab .mat-button-focus-overlay,.cdk-keyboard-focused.mat-icon-button .mat-button-focus-overlay,.cdk-keyboard-focused.mat-mini-fab .mat-button-focus-overlay,.cdk-keyboard-focused.mat-raised-button .mat-button-focus-overlay{opacity:1}.mat-button::-moz-focus-inner,.mat-fab::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-mini-fab::-moz-focus-inner,.mat-raised-button::-moz-focus-inner{border:0}.mat-fab,.mat-mini-fab,.mat-raised-button{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-fab:not([disabled]):active,.mat-mini-fab:not([disabled]):active,.mat-raised-button:not([disabled]):active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}[disabled].mat-fab,[disabled].mat-mini-fab,[disabled].mat-raised-button{box-shadow:none}.mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{transition:none;opacity:0}.mat-button:hover .mat-button-focus-overlay{opacity:1}.mat-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-fab .mat-icon,.mat-fab i{padding:16px 0;line-height:24px}.mat-mini-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-mini-fab .mat-icon,.mat-mini-fab i{padding:8px 0;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button,.mat-icon-button,.mat-raised-button{color:currentColor}.mat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*{vertical-align:middle}.mat-button-focus-overlay,.mat-button-ripple{position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none}.mat-button-focus-overlay{background-color:rgba(0,0,0,.12);border-radius:inherit;opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}@media screen and (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:rgba(255,255,255,.5)}}.mat-button-ripple-round{border-radius:50%;z-index:1}@media screen and (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}} /*# sourceMappingURL=button.css.map */ \"],\\n                inputs: [\\'disabled\\'],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButton.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: Platform, },\\n    { type: FocusOriginMonitor, },\\n]; };\\nMdButton.propDecorators = {\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Raised Material design button.\\n */\\nvar MdAnchor = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdAnchor, _super);\\n    /**\\n     * @param {?} elementRef\\n     * @param {?} renderer\\n     * @param {?} platform\\n     * @param {?} focusOriginMonitor\\n     */\\n    function MdAnchor(elementRef, renderer, platform, focusOriginMonitor) {\\n        return _super.call(this, elementRef, renderer, platform, focusOriginMonitor) || this;\\n    }\\n    Object.defineProperty(MdAnchor.prototype, \"tabIndex\", {\\n        /**\\n         * \\\\@docs-private\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.disabled ? -1 : 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdAnchor.prototype, \"_isAriaDisabled\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.disabled ? \\'true\\' : \\'false\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdAnchor.prototype._haltDisabledEvents = function (event) {\\n        // A disabled button shouldn\\'t apply any actions\\n        if (this.disabled) {\\n            event.preventDefault();\\n            event.stopImmediatePropagation();\\n        }\\n    };\\n    return MdAnchor;\\n}(MdButton));\\nMdAnchor.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \"a[md-button], a[md-raised-button], a[md-icon-button], a[md-fab], a[md-mini-fab],\\\\n             a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab], a[mat-mini-fab]\",\\n                host: {\\n                    \\'[attr.disabled]\\': \\'disabled || null\\',\\n                    \\'[attr.aria-disabled]\\': \\'_isAriaDisabled\\',\\n                    \\'(click)\\': \\'_haltDisabledEvents($event)\\',\\n                },\\n                inputs: [\\'disabled\\'],\\n                template: \"<span class=\\\\\"mat-button-wrapper\\\\\"><ng-content></ng-content></span> <div md-ripple class=\\\\\"mat-button-ripple\\\\\" [class.mat-button-ripple-round]=\\\\\"_isRoundButton || _isIconButton\\\\\" [mdRippleDisabled]=\\\\\"_isRippleDisabled()\\\\\" [mdRippleCentered]=\\\\\"_isIconButton\\\\\" [mdRippleTrigger]=\\\\\"_getHostElement()\\\\\"></div> <div class=\\\\\"mat-button-focus-overlay\\\\\"></div> \",\\n                styles: [\".mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;font-size:14px;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;font-weight:500;text-align:center;margin:0;min-width:88px;line-height:36px;padding:0 16px;border-radius:2px}[disabled].mat-button,[disabled].mat-fab,[disabled].mat-icon-button,[disabled].mat-mini-fab,[disabled].mat-raised-button{cursor:default}.cdk-keyboard-focused.mat-button .mat-button-focus-overlay,.cdk-keyboard-focused.mat-fab .mat-button-focus-overlay,.cdk-keyboard-focused.mat-icon-button .mat-button-focus-overlay,.cdk-keyboard-focused.mat-mini-fab .mat-button-focus-overlay,.cdk-keyboard-focused.mat-raised-button .mat-button-focus-overlay{opacity:1}.mat-button::-moz-focus-inner,.mat-fab::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-mini-fab::-moz-focus-inner,.mat-raised-button::-moz-focus-inner{border:0}.mat-fab,.mat-mini-fab,.mat-raised-button{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-fab:not([disabled]):active,.mat-mini-fab:not([disabled]):active,.mat-raised-button:not([disabled]):active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}[disabled].mat-fab,[disabled].mat-mini-fab,[disabled].mat-raised-button{box-shadow:none}.mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{transition:none;opacity:0}.mat-button:hover .mat-button-focus-overlay{opacity:1}.mat-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-fab .mat-icon,.mat-fab i{padding:16px 0;line-height:24px}.mat-mini-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-mini-fab .mat-icon,.mat-mini-fab i{padding:8px 0;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button,.mat-icon-button,.mat-raised-button{color:currentColor}.mat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*{vertical-align:middle}.mat-button-focus-overlay,.mat-button-ripple{position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none}.mat-button-focus-overlay{background-color:rgba(0,0,0,.12);border-radius:inherit;opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}@media screen and (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:rgba(255,255,255,.5)}}.mat-button-ripple-round{border-radius:50%;z-index:1}@media screen and (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}} /*# sourceMappingURL=button.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdAnchor.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: Platform, },\\n    { type: FocusOriginMonitor, },\\n]; };\\nMdAnchor.propDecorators = {\\n    \\'tabIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'tabIndex\\',] },],\\n};\\nvar MdButtonModule = /*@__PURE__*/(function () {\\n    function MdButtonModule() {\\n    }\\n    return MdButtonModule;\\n}());\\nMdButtonModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"],\\n                    MdRippleModule,\\n                    MdCommonModule,\\n                    StyleModule,\\n                ],\\n                exports: [\\n                    MdButton,\\n                    MdAnchor,\\n                    MdCommonModule,\\n                    MdButtonCssMatStyler,\\n                    MdRaisedButtonCssMatStyler,\\n                    MdIconButtonCssMatStyler,\\n                    MdFabCssMatStyler,\\n                    MdMiniFabCssMatStyler,\\n                ],\\n                declarations: [\\n                    MdButton,\\n                    MdAnchor,\\n                    MdButtonCssMatStyler,\\n                    MdRaisedButtonCssMatStyler,\\n                    MdIconButtonCssMatStyler,\\n                    MdFabCssMatStyler,\\n                    MdMiniFabCssMatStyler,\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonModule.ctorParameters = function () { return []; };\\n/**\\n * Monotonically increasing integer used to auto-generate unique ids for checkbox components.\\n */\\nvar nextId = 0;\\n/**\\n * Provider Expression that allows md-checkbox to register as a ControlValueAccessor.\\n * This allows it to support [(ngModel)].\\n * \\\\@docs-private\\n */\\nvar MD_CHECKBOX_CONTROL_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"])(function () { return MdCheckbox; }),\\n    multi: true\\n};\\nvar TransitionCheckState = {};\\nTransitionCheckState.Init = 0;\\nTransitionCheckState.Checked = 1;\\nTransitionCheckState.Unchecked = 2;\\nTransitionCheckState.Indeterminate = 3;\\nTransitionCheckState[TransitionCheckState.Init] = \"Init\";\\nTransitionCheckState[TransitionCheckState.Checked] = \"Checked\";\\nTransitionCheckState[TransitionCheckState.Unchecked] = \"Unchecked\";\\nTransitionCheckState[TransitionCheckState.Indeterminate] = \"Indeterminate\";\\n/**\\n * Change event object emitted by MdCheckbox.\\n */\\nvar MdCheckboxChange = /*@__PURE__*/(function () {\\n    function MdCheckboxChange() {\\n    }\\n    return MdCheckboxChange;\\n}());\\nvar MdCheckboxBase = /*@__PURE__*/(function () {\\n    function MdCheckboxBase() {\\n    }\\n    return MdCheckboxBase;\\n}());\\nvar _MdCheckboxMixinBase = mixinDisabled(MdCheckboxBase);\\n/**\\n * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,\\n * and exposes a similar API. A MdCheckbox can be either checked, unchecked, indeterminate, or\\n * disabled. Note that all additional accessibility attributes are taken care of by the component,\\n * so there is no need to provide them yourself. However, if you want to omit a label and still\\n * have the checkbox be accessible, you may supply an [aria-label] input.\\n * See: https://www.google.com/design/spec/components/selection-controls.html\\n */\\nvar MdCheckbox = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdCheckbox, _super);\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     * @param {?} _changeDetectorRef\\n     * @param {?} _focusOriginMonitor\\n     */\\n    function MdCheckbox(_renderer, _elementRef, _changeDetectorRef, _focusOriginMonitor) {\\n        var _this = _super.call(this) || this;\\n        _this._renderer = _renderer;\\n        _this._elementRef = _elementRef;\\n        _this._changeDetectorRef = _changeDetectorRef;\\n        _this._focusOriginMonitor = _focusOriginMonitor;\\n        /**\\n         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will\\n         * take precedence so this may be omitted.\\n         */\\n        _this.ariaLabel = \\'\\';\\n        /**\\n         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\\n         */\\n        _this.ariaLabelledby = null;\\n        /**\\n         * A unique id for the checkbox. If one is not supplied, it is auto-generated.\\n         */\\n        _this.id = \"md-checkbox-\" + ++nextId;\\n        /**\\n         * Whether the label should appear after or before the checkbox. Defaults to \\'after\\'\\n         */\\n        _this.labelPosition = \\'after\\';\\n        /**\\n         * Tabindex value that is passed to the underlying input element.\\n         */\\n        _this.tabIndex = 0;\\n        /**\\n         * Name value will be applied to the input element if present\\n         */\\n        _this.name = null;\\n        /**\\n         * Event emitted when the checkbox\\'s `checked` value changes.\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the checkbox\\'s `indeterminate` value changes.\\n         */\\n        _this.indeterminateChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\\n         * \\\\@docs-private\\n         */\\n        _this.onTouched = function () { };\\n        _this._currentAnimationClass = \\'\\';\\n        _this._currentCheckState = TransitionCheckState.Init;\\n        _this._checked = false;\\n        _this._indeterminate = false;\\n        _this._controlValueAccessorChangeFn = function (value) { };\\n        _this.color = \\'accent\\';\\n        return _this;\\n    }\\n    Object.defineProperty(MdCheckbox.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect for this checkbox is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCheckbox.prototype, \"inputId\", {\\n        /**\\n         * ID of the native input element inside `<md-checkbox>`\\n         * @return {?}\\n         */\\n        get: function () {\\n            return \"input-\" + this.id;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCheckbox.prototype, \"required\", {\\n        /**\\n         * Whether the checkbox is required.\\n         * @return {?}\\n         */\\n        get: function () { return this._required; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._required = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCheckbox.prototype, \"align\", {\\n        /**\\n         * Whether or not the checkbox should appear before or after the label.\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () {\\n            // align refers to the checkbox relative to the label, while labelPosition refers to the\\n            // label relative to the checkbox. As such, they are inverted.\\n            return this.labelPosition == \\'after\\' ? \\'start\\' : \\'end\\';\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this.labelPosition = (v == \\'start\\') ? \\'after\\' : \\'before\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Whether the checkbox has label\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._hasLabel = function () {\\n        var /** @type {?} */ labelText = this._labelWrapper.nativeElement.textContent || \\'\\';\\n        return !!labelText.trim().length;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.ngAfterViewInit = function () {\\n        var _this = this;\\n        this._focusOriginMonitor\\n            .monitor(this._inputElement.nativeElement, this._renderer, false)\\n            .subscribe(function (focusOrigin) { return _this._onInputFocusChange(focusOrigin); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._inputElement.nativeElement);\\n    };\\n    Object.defineProperty(MdCheckbox.prototype, \"checked\", {\\n        /**\\n         * Whether the checkbox is checked.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._checked;\\n        },\\n        /**\\n         * @param {?} checked\\n         * @return {?}\\n         */\\n        set: function (checked) {\\n            if (checked != this.checked) {\\n                this._checked = checked;\\n                this._changeDetectorRef.markForCheck();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCheckbox.prototype, \"indeterminate\", {\\n        /**\\n         * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\\n         * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\\n         * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\\n         * set to false.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._indeterminate;\\n        },\\n        /**\\n         * @param {?} indeterminate\\n         * @return {?}\\n         */\\n        set: function (indeterminate) {\\n            var /** @type {?} */ changed = indeterminate != this._indeterminate;\\n            this._indeterminate = indeterminate;\\n            if (changed) {\\n                if (this._indeterminate) {\\n                    this._transitionCheckState(TransitionCheckState.Indeterminate);\\n                }\\n                else {\\n                    this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\\n                }\\n                this.indeterminateChange.emit(this._indeterminate);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCheckbox.prototype, \"color\", {\\n        /**\\n         * The color of the button. Can be `primary`, `accent`, or `warn`.\\n         * @return {?}\\n         */\\n        get: function () { return this._color; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._updateColor(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} newColor\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._updateColor = function (newColor) {\\n        this._setElementColor(this._color, false);\\n        this._setElementColor(newColor, true);\\n        this._color = newColor;\\n    };\\n    /**\\n     * @param {?} color\\n     * @param {?} isAdd\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._setElementColor = function (color, isAdd) {\\n        if (color != null && color != \\'\\') {\\n            if (isAdd) {\\n                this._renderer.addClass(this._elementRef.nativeElement, \"mat-\" + color);\\n            }\\n            else {\\n                this._renderer.removeClass(this._elementRef.nativeElement, \"mat-\" + color);\\n            }\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._isRippleDisabled = function () {\\n        return this.disableRipple || this.disabled;\\n    };\\n    /**\\n     * Sets the model value. Implemented as part of ControlValueAccessor.\\n     * @param {?} value Value to be set to the model.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.writeValue = function (value) {\\n        this.checked = !!value;\\n    };\\n    /**\\n     * Registers a callback to be triggered when the value has changed.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Function to be called on change.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.registerOnChange = function (fn) {\\n        this._controlValueAccessorChangeFn = fn;\\n    };\\n    /**\\n     * Registers a callback to be triggered when the control has been touched.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Callback to be triggered when the checkbox is touched.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.registerOnTouched = function (fn) {\\n        this.onTouched = fn;\\n    };\\n    /**\\n     * Sets the checkbox\\'s disabled state. Implemented as a part of ControlValueAccessor.\\n     * @param {?} isDisabled Whether the checkbox should be disabled.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n        this._changeDetectorRef.markForCheck();\\n    };\\n    /**\\n     * @param {?} newState\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._transitionCheckState = function (newState) {\\n        var /** @type {?} */ oldState = this._currentCheckState;\\n        var /** @type {?} */ renderer = this._renderer;\\n        var /** @type {?} */ elementRef = this._elementRef;\\n        if (oldState === newState) {\\n            return;\\n        }\\n        if (this._currentAnimationClass.length > 0) {\\n            renderer.removeClass(elementRef.nativeElement, this._currentAnimationClass);\\n        }\\n        this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);\\n        this._currentCheckState = newState;\\n        if (this._currentAnimationClass.length > 0) {\\n            renderer.addClass(elementRef.nativeElement, this._currentAnimationClass);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._emitChangeEvent = function () {\\n        var /** @type {?} */ event = new MdCheckboxChange();\\n        event.source = this;\\n        event.checked = this.checked;\\n        this._controlValueAccessorChangeFn(this.checked);\\n        this.change.emit(event);\\n    };\\n    /**\\n     * Function is called whenever the focus changes for the input element.\\n     * @param {?} focusOrigin\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._onInputFocusChange = function (focusOrigin) {\\n        if (!this._focusRipple && focusOrigin === \\'keyboard\\') {\\n            this._focusRipple = this._ripple.launch(0, 0, { persistent: true, centered: true });\\n        }\\n        else if (!focusOrigin) {\\n            this._removeFocusRipple();\\n            this.onTouched();\\n        }\\n    };\\n    /**\\n     * Toggles the `checked` state of the checkbox.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.toggle = function () {\\n        this.checked = !this.checked;\\n    };\\n    /**\\n     * Event handler for checkbox input element.\\n     * Toggles checked state if element is not disabled.\\n     * Do not toggle on (change) event since IE doesn\\'t fire change event when\\n     *   indeterminate checkbox is clicked.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._onInputClick = function (event) {\\n        var _this = this;\\n        // We have to stop propagation for click events on the visual hidden input element.\\n        // By default, when a user clicks on a label element, a generated click event will be\\n        // dispatched on the associated input element. Since we are using a label element as our\\n        // root container, the click event on the `checkbox` will be executed twice.\\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\\n        // This will lead to multiple click events.\\n        // Preventing bubbling for the second event will solve that issue.\\n        event.stopPropagation();\\n        this._removeFocusRipple();\\n        if (!this.disabled) {\\n            // When user manually click on the checkbox, `indeterminate` is set to false.\\n            if (this._indeterminate) {\\n                Promise.resolve().then(function () {\\n                    _this._indeterminate = false;\\n                    _this.indeterminateChange.emit(_this._indeterminate);\\n                });\\n            }\\n            this.toggle();\\n            this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\\n            // Emit our custom change event if the native input emitted one.\\n            // It is important to only emit it, if the native input triggered one, because\\n            // we don\\'t want to trigger a change event, when the `checked` variable changes for example.\\n            this._emitChangeEvent();\\n        }\\n    };\\n    /**\\n     * Focuses the checkbox.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.focus = function () {\\n        this._focusOriginMonitor.focusVia(this._inputElement.nativeElement, this._renderer, \\'keyboard\\');\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._onInteractionEvent = function (event) {\\n        // We always have to stop propagation on the change event.\\n        // Otherwise the change event, from the input element, will bubble up and\\n        // emit its event object to the `change` output.\\n        event.stopPropagation();\\n    };\\n    /**\\n     * @param {?} oldState\\n     * @param {?} newState\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._getAnimationClassForCheckStateTransition = function (oldState, newState) {\\n        var /** @type {?} */ animSuffix;\\n        switch (oldState) {\\n            case TransitionCheckState.Init:\\n                // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or\\n                // [checked] bound to it.\\n                if (newState === TransitionCheckState.Checked) {\\n                    animSuffix = \\'unchecked-checked\\';\\n                }\\n                else if (newState == TransitionCheckState.Indeterminate) {\\n                    animSuffix = \\'unchecked-indeterminate\\';\\n                }\\n                else {\\n                    return \\'\\';\\n                }\\n                break;\\n            case TransitionCheckState.Unchecked:\\n                animSuffix = newState === TransitionCheckState.Checked ?\\n                    \\'unchecked-checked\\' : \\'unchecked-indeterminate\\';\\n                break;\\n            case TransitionCheckState.Checked:\\n                animSuffix = newState === TransitionCheckState.Unchecked ?\\n                    \\'checked-unchecked\\' : \\'checked-indeterminate\\';\\n                break;\\n            case TransitionCheckState.Indeterminate:\\n                animSuffix = newState === TransitionCheckState.Checked ?\\n                    \\'indeterminate-checked\\' : \\'indeterminate-unchecked\\';\\n        }\\n        return \"mat-checkbox-anim-\" + animSuffix;\\n    };\\n    /**\\n     * Fades out the focus state ripple.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._removeFocusRipple = function () {\\n        if (this._focusRipple) {\\n            this._focusRipple.fadeOut();\\n            this._focusRipple = null;\\n        }\\n    };\\n    return MdCheckbox;\\n}(_MdCheckboxMixinBase));\\nMdCheckbox.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-checkbox, mat-checkbox\\',\\n                template: \"<label class=\\\\\"mat-checkbox-layout\\\\\" #label> <div class=\\\\\"mat-checkbox-inner-container\\\\\" [class.mat-checkbox-inner-container-no-side-margin]=\\\\\"!_hasLabel()\\\\\"> <input #input class=\\\\\"mat-checkbox-input cdk-visually-hidden\\\\\" type=\\\\\"checkbox\\\\\" [id]=\\\\\"inputId\\\\\" [required]=\\\\\"required\\\\\" [checked]=\\\\\"checked\\\\\" [value]=\\\\\"value\\\\\" [disabled]=\\\\\"disabled\\\\\" [name]=\\\\\"name\\\\\" [tabIndex]=\\\\\"tabIndex\\\\\" [indeterminate]=\\\\\"indeterminate\\\\\" [attr.aria-label]=\\\\\"ariaLabel\\\\\" [attr.aria-labelledby]=\\\\\"ariaLabelledby\\\\\" (change)=\\\\\"_onInteractionEvent($event)\\\\\" (click)=\\\\\"_onInputClick($event)\\\\\"> <div md-ripple class=\\\\\"mat-checkbox-ripple\\\\\" [mdRippleTrigger]=\\\\\"label\\\\\" [mdRippleDisabled]=\\\\\"_isRippleDisabled()\\\\\" [mdRippleCentered]=\\\\\"true\\\\\"></div> <div class=\\\\\"mat-checkbox-frame\\\\\"></div> <div class=\\\\\"mat-checkbox-background\\\\\"> <svg version=\\\\\"1.1\\\\\" class=\\\\\"mat-checkbox-checkmark\\\\\" xmlns=\\\\\"http://www.w3.org/2000/svg\\\\\" viewBox=\\\\\"0 0 24 24\\\\\" xml:space=\\\\\"preserve\\\\\"> <path class=\\\\\"mat-checkbox-checkmark-path\\\\\" fill=\\\\\"none\\\\\" stroke=\\\\\"white\\\\\" d=\\\\\"M4.1,12.7 9,17.6 20.3,6.3\\\\\"/> </svg> \\x3c!-- Element for rendering the indeterminate state checkbox. --\\x3e <div class=\\\\\"mat-checkbox-mixedmark\\\\\"></div> </div> </div> <span class=\\\\\"mat-checkbox-label\\\\\" #labelWrapper> <ng-content></ng-content> </span> </label> \",\\n                styles: [\"@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.91026}50%{animation-timing-function:cubic-bezier(0,0,.2,.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0,0,0,1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(.4,0,1,1);stroke-dashoffset:0}to{stroke-dashoffset:-22.91026}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}100%,32.8%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-checkmark,.mat-checkbox-frame{bottom:0;left:0;position:absolute;right:0;top:0}.mat-checkbox-checkmark,.mat-checkbox-mixedmark{width:calc(100% - 4px)}.mat-checkbox-background,.mat-checkbox-frame{border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);cursor:pointer}.mat-checkbox-layout{cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex}.mat-checkbox-inner-container{display:inline-block;height:20px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:20px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-layout .mat-checkbox-label{line-height:24px}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0,0,.2,.1);border-width:2px;border-style:solid}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0,0,.2,.1),opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-checkbox-checkmark{width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.91026;stroke-dasharray:22.91026;stroke-width:2.66667px}.mat-checkbox-mixedmark{height:2px;opacity:0;transform:scaleX(0) rotate(0)}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0s mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0s mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:.3s linear 0s mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox-ripple{position:absolute;left:-15px;top:-15px;right:-15px;bottom:-15px;border-radius:50%;z-index:1;pointer-events:none} /*# sourceMappingURL=checkbox.css.map */ \"],\\n                host: {\\n                    \\'class\\': \\'mat-checkbox\\',\\n                    \\'[class.mat-checkbox-indeterminate]\\': \\'indeterminate\\',\\n                    \\'[class.mat-checkbox-checked]\\': \\'checked\\',\\n                    \\'[class.mat-checkbox-disabled]\\': \\'disabled\\',\\n                    \\'[class.mat-checkbox-label-before]\\': \\'labelPosition == \"before\"\\',\\n                },\\n                providers: [MD_CHECKBOX_CONTROL_VALUE_ACCESSOR],\\n                inputs: [\\'disabled\\'],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCheckbox.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: FocusOriginMonitor, },\\n]; };\\nMdCheckbox.propDecorators = {\\n    \\'ariaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'ariaLabelledby\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-labelledby\\',] },],\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'required\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'labelPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'tabIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'indeterminateChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_inputElement\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'input\\',] },],\\n    \\'_labelWrapper\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'labelWrapper\\',] },],\\n    \\'_ripple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdRipple,] },],\\n    \\'checked\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'indeterminate\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdCheckboxModule = /*@__PURE__*/(function () {\\n    function MdCheckboxModule() {\\n    }\\n    return MdCheckboxModule;\\n}());\\nMdCheckboxModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"], MdRippleModule, MdCommonModule],\\n                exports: [MdCheckbox, MdCommonModule],\\n                declarations: [MdCheckbox],\\n                providers: [FocusOriginMonitor]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCheckboxModule.ctorParameters = function () { return []; };\\n/**\\n * Provider Expression that allows md-radio-group to register as a ControlValueAccessor. This\\n * allows it to support [(ngModel)] and ngControl.\\n * \\\\@docs-private\\n */\\nvar MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"])(function () { return MdRadioGroup; }),\\n    multi: true\\n};\\nvar _uniqueIdCounter$2 = 0;\\n/**\\n * Change event object emitted by MdRadio and MdRadioGroup.\\n */\\nvar MdRadioChange = /*@__PURE__*/(function () {\\n    function MdRadioChange() {\\n    }\\n    return MdRadioChange;\\n}());\\nvar MdRadioGroupBase = /*@__PURE__*/(function () {\\n    function MdRadioGroupBase() {\\n    }\\n    return MdRadioGroupBase;\\n}());\\nvar _MdRadioGroupMixinBase = mixinDisabled(MdRadioGroupBase);\\n/**\\n * A group of radio buttons. May contain one or more `<md-radio-button>` elements.\\n */\\nvar MdRadioGroup = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdRadioGroup, _super);\\n    function MdRadioGroup() {\\n        var _this = _super.apply(this, arguments) || this;\\n        /**\\n         * Selected value for group. Should equal the value of the selected radio button if there *is*\\n         * a corresponding radio button with a matching value. If there is *not* such a corresponding\\n         * radio button, this value persists to be applied in case a new radio button is added with a\\n         * matching value.\\n         */\\n        _this._value = null;\\n        /**\\n         * The HTML name attribute applied to radio buttons in this group.\\n         */\\n        _this._name = \"md-radio-group-\" + _uniqueIdCounter$2++;\\n        /**\\n         * The currently selected radio button. Should match value.\\n         */\\n        _this._selected = null;\\n        /**\\n         * Whether the `value` has been set to its initial value.\\n         */\\n        _this._isInitialized = false;\\n        /**\\n         * The method to be called in order to update ngModel\\n         */\\n        _this._controlValueAccessorChangeFn = function (value) { };\\n        /**\\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\\n         * \\\\@docs-private\\n         */\\n        _this.onTouched = function () { };\\n        /**\\n         * Event emitted when the group value changes.\\n         * Change events are only emitted when the value changes due to user interaction with\\n         * a radio button (the same behavior as `<input type-\"radio\">`).\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Child radio buttons.\\n         */\\n        _this._radios = null;\\n        /**\\n         * Whether the labels should appear after or before the radio-buttons. Defaults to \\'after\\'\\n         */\\n        _this.labelPosition = \\'after\\';\\n        return _this;\\n    }\\n    Object.defineProperty(MdRadioGroup.prototype, \"name\", {\\n        /**\\n         * Name of the radio button group. All radio buttons inside this group will use this name.\\n         * @return {?}\\n         */\\n        get: function () { return this._name; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._name = value;\\n            this._updateRadioButtonNames();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioGroup.prototype, \"align\", {\\n        /**\\n         * Alignment of the radio-buttons relative to their labels. Can be \\'before\\' or \\'after\\'.\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () {\\n            // align refers to the checkbox relative to the label, while labelPosition refers to the\\n            // label relative to the checkbox. As such, they are inverted.\\n            return this.labelPosition == \\'after\\' ? \\'start\\' : \\'end\\';\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this.labelPosition = (v == \\'start\\') ? \\'after\\' : \\'before\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioGroup.prototype, \"value\", {\\n        /**\\n         * Value of the radio button.\\n         * @return {?}\\n         */\\n        get: function () { return this._value; },\\n        /**\\n         * @param {?} newValue\\n         * @return {?}\\n         */\\n        set: function (newValue) {\\n            if (this._value != newValue) {\\n                // Set this before proceeding to ensure no circular loop occurs with selection.\\n                this._value = newValue;\\n                this._updateSelectedRadioFromValue();\\n                this._checkSelectedRadioButton();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._checkSelectedRadioButton = function () {\\n        if (this.selected && !this._selected.checked) {\\n            this._selected.checked = true;\\n        }\\n    };\\n    Object.defineProperty(MdRadioGroup.prototype, \"selected\", {\\n        /**\\n         * Whether the radio button is selected.\\n         * @return {?}\\n         */\\n        get: function () { return this._selected; },\\n        /**\\n         * @param {?} selected\\n         * @return {?}\\n         */\\n        set: function (selected) {\\n            this._selected = selected;\\n            this.value = selected ? selected.value : null;\\n            this._checkSelectedRadioButton();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Initialize properties once content children are available.\\n     * This allows us to propagate relevant attributes to associated buttons.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype.ngAfterContentInit = function () {\\n        // Mark this component as initialized in AfterContentInit because the initial value can\\n        // possibly be set by NgModel on MdRadioGroup, and it is possible that the OnInit of the\\n        // NgModel occurs *after* the OnInit of the MdRadioGroup.\\n        this._isInitialized = true;\\n    };\\n    /**\\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\\n     * radio buttons upon their blur.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._touch = function () {\\n        if (this.onTouched) {\\n            this.onTouched();\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._updateRadioButtonNames = function () {\\n        var _this = this;\\n        if (this._radios) {\\n            this._radios.forEach(function (radio) {\\n                radio.name = _this.name;\\n            });\\n        }\\n    };\\n    /**\\n     * Updates the `selected` radio button from the internal _value state.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._updateSelectedRadioFromValue = function () {\\n        var _this = this;\\n        // If the value already matches the selected radio, do nothing.\\n        var /** @type {?} */ isAlreadySelected = this._selected != null && this._selected.value == this._value;\\n        if (this._radios != null && !isAlreadySelected) {\\n            this._selected = null;\\n            this._radios.forEach(function (radio) {\\n                radio.checked = _this.value == radio.value;\\n                if (radio.checked) {\\n                    _this._selected = radio;\\n                }\\n            });\\n        }\\n    };\\n    /**\\n     * Dispatch change event with current selection and group value.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._emitChangeEvent = function () {\\n        if (this._isInitialized) {\\n            var /** @type {?} */ event = new MdRadioChange();\\n            event.source = this._selected;\\n            event.value = this._value;\\n            this.change.emit(event);\\n        }\\n    };\\n    /**\\n     * Sets the model value. Implemented as part of ControlValueAccessor.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype.writeValue = function (value) {\\n        this.value = value;\\n    };\\n    /**\\n     * Registers a callback to be triggered when the model value changes.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Callback to be registered.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype.registerOnChange = function (fn) {\\n        this._controlValueAccessorChangeFn = fn;\\n    };\\n    /**\\n     * Registers a callback to be triggered when the control is touched.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Callback to be registered.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype.registerOnTouched = function (fn) {\\n        this.onTouched = fn;\\n    };\\n    /**\\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\\n     * @param {?} isDisabled Whether the control should be disabled.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n    };\\n    return MdRadioGroup;\\n}(_MdRadioGroupMixinBase));\\nMdRadioGroup.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-radio-group, mat-radio-group\\',\\n                providers: [MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],\\n                host: {\\n                    \\'role\\': \\'radiogroup\\',\\n                    \\'[class.mat-radio-group]\\': \\'true\\',\\n                },\\n                inputs: [\\'disabled\\'],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRadioGroup.ctorParameters = function () { return []; };\\nMdRadioGroup.propDecorators = {\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'_radios\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"])(function () { return MdRadioButton; }),] },],\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'labelPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * A radio-button. May be inside of\\n */\\nvar MdRadioButton = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} radioGroup\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     * @param {?} _focusOriginMonitor\\n     * @param {?} _radioDispatcher\\n     */\\n    function MdRadioButton(radioGroup, _elementRef, _renderer, _focusOriginMonitor, _radioDispatcher) {\\n        var _this = this;\\n        // Assertions. Ideally these should be stripped out by the compiler.\\n        // TODO(jelbourn): Assert that there\\'s no name binding AND a parent radio group.\\n        this._elementRef = _elementRef;\\n        this._renderer = _renderer;\\n        this._focusOriginMonitor = _focusOriginMonitor;\\n        this._radioDispatcher = _radioDispatcher;\\n        /**\\n         * The unique ID for the radio button.\\n         */\\n        this.id = \"md-radio-\" + _uniqueIdCounter$2++;\\n        /**\\n         * Event emitted when the checked state of this radio button changes.\\n         * Change events are only emitted when the value changes due to user interaction with\\n         * the radio button (the same behavior as `<input type-\"radio\">`).\\n         */\\n        this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Whether this radio is checked.\\n         */\\n        this._checked = false;\\n        /**\\n         * Value assigned to this radio.\\n         */\\n        this._value = null;\\n        this.radioGroup = radioGroup;\\n        _radioDispatcher.listen(function (id, name) {\\n            if (id != _this.id && name == _this.name) {\\n                _this.checked = false;\\n            }\\n        });\\n    }\\n    Object.defineProperty(MdRadioButton.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect for this radio button is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"checked\", {\\n        /**\\n         * Whether this radio button is checked.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._checked;\\n        },\\n        /**\\n         * @param {?} newCheckedState\\n         * @return {?}\\n         */\\n        set: function (newCheckedState) {\\n            if (this._checked != newCheckedState) {\\n                this._checked = newCheckedState;\\n                if (newCheckedState && this.radioGroup && this.radioGroup.value != this.value) {\\n                    this.radioGroup.selected = this;\\n                }\\n                else if (!newCheckedState && this.radioGroup && this.radioGroup.value == this.value) {\\n                    // When unchecking the selected radio button, update the selected radio\\n                    // property on the group.\\n                    this.radioGroup.selected = null;\\n                }\\n                if (newCheckedState) {\\n                    // Notify all radio buttons with the same name to un-check.\\n                    this._radioDispatcher.notify(this.id, this.name);\\n                }\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"value\", {\\n        /**\\n         * The value of this radio button.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._value;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._value != value) {\\n                this._value = value;\\n                if (this.radioGroup != null) {\\n                    if (!this.checked) {\\n                        // Update checked when the value changed to match the radio group\\'s value\\n                        this.checked = this.radioGroup.value == value;\\n                    }\\n                    if (this.checked) {\\n                        this.radioGroup.selected = this;\\n                    }\\n                }\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"align\", {\\n        /**\\n         * Whether or not the radio-button should appear before or after the label.\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () {\\n            // align refers to the checkbox relative to the label, while labelPosition refers to the\\n            // label relative to the checkbox. As such, they are inverted.\\n            return this.labelPosition == \\'after\\' ? \\'start\\' : \\'end\\';\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this.labelPosition = (v == \\'start\\') ? \\'after\\' : \\'before\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"labelPosition\", {\\n        /**\\n         * Whether the label should appear after or before the radio button. Defaults to \\'after\\'\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || \\'after\\';\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._labelPosition = value;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"disabled\", {\\n        /**\\n         * Whether the radio button is disabled.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._disabled || (this.radioGroup != null && this.radioGroup.disabled);\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"inputId\", {\\n        /**\\n         * ID of the native input element inside `<md-radio-button>`\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.id + \"-input\";\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Focuses the radio button.\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype.focus = function () {\\n        this._focusOriginMonitor.focusVia(this._inputElement.nativeElement, this._renderer, \\'keyboard\\');\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype.ngOnInit = function () {\\n        if (this.radioGroup) {\\n            // If the radio is inside a radio group, determine if it should be checked\\n            this.checked = this.radioGroup.value === this._value;\\n            // Copy name from parent radio group\\n            this.name = this.radioGroup.name;\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype.ngAfterViewInit = function () {\\n        var _this = this;\\n        this._focusOriginMonitor\\n            .monitor(this._inputElement.nativeElement, this._renderer, false)\\n            .subscribe(function (focusOrigin) { return _this._onInputFocusChange(focusOrigin); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._inputElement.nativeElement);\\n    };\\n    /**\\n     * Dispatch change event with current value.\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._emitChangeEvent = function () {\\n        var /** @type {?} */ event = new MdRadioChange();\\n        event.source = this;\\n        event.value = this._value;\\n        this.change.emit(event);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._isRippleDisabled = function () {\\n        return this.disableRipple || this.disabled;\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._onInputClick = function (event) {\\n        // We have to stop propagation for click events on the visual hidden input element.\\n        // By default, when a user clicks on a label element, a generated click event will be\\n        // dispatched on the associated input element. Since we are using a label element as our\\n        // root container, the click event on the `radio-button` will be executed twice.\\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\\n        // This will lead to multiple click events.\\n        // Preventing bubbling for the second event will solve that issue.\\n        event.stopPropagation();\\n    };\\n    /**\\n     * Triggered when the radio button received a click or the input recognized any change.\\n     * Clicking on a label element, will trigger a change event on the associated input.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._onInputChange = function (event) {\\n        // We always have to stop propagation on the change event.\\n        // Otherwise the change event, from the input element, will bubble up and\\n        // emit its event object to the `change` output.\\n        event.stopPropagation();\\n        var /** @type {?} */ groupValueChanged = this.radioGroup && this.value != this.radioGroup.value;\\n        this.checked = true;\\n        this._emitChangeEvent();\\n        if (this.radioGroup) {\\n            this.radioGroup._controlValueAccessorChangeFn(this.value);\\n            this.radioGroup._touch();\\n            if (groupValueChanged) {\\n                this.radioGroup._emitChangeEvent();\\n            }\\n        }\\n    };\\n    /**\\n     * Function is called whenever the focus changes for the input element.\\n     * @param {?} focusOrigin\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._onInputFocusChange = function (focusOrigin) {\\n        if (!this._focusRipple && focusOrigin === \\'keyboard\\') {\\n            this._focusRipple = this._ripple.launch(0, 0, { persistent: true, centered: true });\\n        }\\n        else if (!focusOrigin) {\\n            if (this.radioGroup) {\\n                this.radioGroup._touch();\\n            }\\n            if (this._focusRipple) {\\n                this._focusRipple.fadeOut();\\n                this._focusRipple = null;\\n            }\\n        }\\n    };\\n    return MdRadioButton;\\n}());\\nMdRadioButton.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-radio-button, mat-radio-button\\',\\n                template: \"\\x3c!-- TODO(jelbourn): render the radio on either side of the content --\\x3e \\x3c!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. --\\x3e <label [attr.for]=\\\\\"inputId\\\\\" class=\\\\\"mat-radio-label\\\\\" #label> \\x3c!-- The actual \\'radio\\' part of the control. --\\x3e <div class=\\\\\"mat-radio-container\\\\\"> <div class=\\\\\"mat-radio-outer-circle\\\\\"></div> <div class=\\\\\"mat-radio-inner-circle\\\\\"></div> <div md-ripple class=\\\\\"mat-radio-ripple\\\\\" [mdRippleTrigger]=\\\\\"label\\\\\" [mdRippleDisabled]=\\\\\"_isRippleDisabled()\\\\\" [mdRippleCentered]=\\\\\"true\\\\\"></div> </div> <input #input class=\\\\\"mat-radio-input cdk-visually-hidden\\\\\" type=\\\\\"radio\\\\\" [id]=\\\\\"inputId\\\\\" [checked]=\\\\\"checked\\\\\" [disabled]=\\\\\"disabled\\\\\" [name]=\\\\\"name\\\\\" [attr.aria-label]=\\\\\"ariaLabel\\\\\" [attr.aria-labelledby]=\\\\\"ariaLabelledby\\\\\" (change)=\\\\\"_onInputChange($event)\\\\\" (click)=\\\\\"_onInputClick($event)\\\\\"> \\x3c!-- The label content for radio control. --\\x3e <div class=\\\\\"mat-radio-label-content\\\\\" [class.mat-radio-label-before]=\\\\\"labelPosition == \\'before\\'\\\\\"> <ng-content></ng-content> </div> </label> \",\\n                styles: [\".mat-radio-button{display:inline-block;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif}.mat-radio-label{cursor:pointer;display:inline-flex;align-items:baseline;white-space:nowrap}.mat-radio-container{box-sizing:border-box;display:inline-block;height:20px;position:relative;width:20px;top:2px}.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:transform ease 280ms,background-color ease 280ms;transform:scale(0);width:20px}.mat-radio-checked .mat-radio-inner-circle{transform:scale(.5)}.mat-radio-label-content{display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-ripple{position:absolute;left:-15px;top:-15px;right:-15px;bottom:-15px;border-radius:50%;z-index:1;pointer-events:none} /*# sourceMappingURL=radio.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'[class.mat-radio-button]\\': \\'true\\',\\n                    \\'[class.mat-radio-checked]\\': \\'checked\\',\\n                    \\'[class.mat-radio-disabled]\\': \\'disabled\\',\\n                    \\'[attr.id]\\': \\'id\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRadioButton.ctorParameters = function () { return [\\n    { type: MdRadioGroup, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: FocusOriginMonitor, },\\n    { type: UniqueSelectionDispatcher, },\\n]; };\\nMdRadioButton.propDecorators = {\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'ariaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'ariaLabelledby\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-labelledby\\',] },],\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'checked\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'labelPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'_ripple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdRipple,] },],\\n    \\'_inputElement\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'input\\',] },],\\n};\\nvar MdRadioModule = /*@__PURE__*/(function () {\\n    function MdRadioModule() {\\n    }\\n    return MdRadioModule;\\n}());\\nMdRadioModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"], MdRippleModule, MdCommonModule],\\n                exports: [MdRadioGroup, MdRadioButton, MdCommonModule],\\n                providers: [UNIQUE_SELECTION_DISPATCHER_PROVIDER, VIEWPORT_RULER_PROVIDER, FocusOriginMonitor],\\n                declarations: [MdRadioGroup, MdRadioButton],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRadioModule.ctorParameters = function () { return []; };\\n/**\\n * This class manages keyboard events for selectable lists. If you pass it a query list\\n * of items, it will set the active item correctly when arrow events occur.\\n */\\nvar ListKeyManager = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _items\\n     */\\n    function ListKeyManager(_items) {\\n        this._items = _items;\\n        this._activeItemIndex = null;\\n        this._tabOut = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        this._wrap = false;\\n    }\\n    /**\\n     * Turns on wrapping mode, which ensures that the active item will wrap to\\n     * the other end of list when there are no more items in the given direction.\\n     *\\n     * @return {?} The ListKeyManager that the method was called on.\\n     */\\n    ListKeyManager.prototype.withWrap = function () {\\n        this._wrap = true;\\n        return this;\\n    };\\n    /**\\n     * Sets the active item to the item at the index specified.\\n     *\\n     * @param {?} index The index of the item to be set as active.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.setActiveItem = function (index) {\\n        this._activeItemIndex = index;\\n        this._activeItem = this._items.toArray()[index];\\n    };\\n    /**\\n     * Sets the active item depending on the key event passed in.\\n     * @param {?} event Keyboard event to be used for determining which element should be active.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.onKeydown = function (event) {\\n        switch (event.keyCode) {\\n            case DOWN_ARROW:\\n                this.setNextItemActive();\\n                break;\\n            case UP_ARROW:\\n                this.setPreviousItemActive();\\n                break;\\n            case TAB:\\n                // Note that we shouldn\\'t prevent the default action on tab.\\n                this._tabOut.next(null);\\n                return;\\n            default:\\n                return;\\n        }\\n        event.preventDefault();\\n    };\\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\\n        /**\\n         * Returns the index of the currently active item.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._activeItemIndex;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\\n        /**\\n         * Returns the currently active item.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._activeItem;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the active item to the first enabled item in the list.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.setFirstItemActive = function () {\\n        this._setActiveItemByIndex(0, 1);\\n    };\\n    /**\\n     * Sets the active item to the last enabled item in the list.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.setLastItemActive = function () {\\n        this._setActiveItemByIndex(this._items.length - 1, -1);\\n    };\\n    /**\\n     * Sets the active item to the next enabled item in the list.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.setNextItemActive = function () {\\n        this._activeItemIndex === null ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\\n    };\\n    /**\\n     * Sets the active item to a previous enabled item in the list.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.setPreviousItemActive = function () {\\n        this._activeItemIndex === null && this._wrap ? this.setLastItemActive()\\n            : this._setActiveItemByDelta(-1);\\n    };\\n    /**\\n     * Allows setting of the activeItemIndex without any other effects.\\n     * @param {?} index The new activeItemIndex.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.updateActiveItemIndex = function (index) {\\n        this._activeItemIndex = index;\\n    };\\n    Object.defineProperty(ListKeyManager.prototype, \"tabOut\", {\\n        /**\\n         * Observable that emits any time the TAB key is pressed, so components can react\\n         * when focus is shifted off of the list.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._tabOut.asObservable();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * This method sets the active item, given a list of items and the delta between the\\n     * currently active item and the new active item. It will calculate differently\\n     * depending on whether wrap mode is turned on.\\n     * @param {?} delta\\n     * @param {?=} items\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype._setActiveItemByDelta = function (delta, items) {\\n        if (items === void 0) { items = this._items.toArray(); }\\n        this._wrap ? this._setActiveInWrapMode(delta, items)\\n            : this._setActiveInDefaultMode(delta, items);\\n    };\\n    /**\\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\\n     * down the list until it finds an item that is not disabled, and it will wrap if it\\n     * encounters either end of the list.\\n     * @param {?} delta\\n     * @param {?} items\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype._setActiveInWrapMode = function (delta, items) {\\n        // when active item would leave menu, wrap to beginning or end\\n        this._activeItemIndex =\\n            (this._activeItemIndex + delta + items.length) % items.length;\\n        // skip all disabled menu items recursively until an enabled one is reached\\n        if (items[this._activeItemIndex].disabled) {\\n            this._setActiveInWrapMode(delta, items);\\n        }\\n        else {\\n            this.setActiveItem(this._activeItemIndex);\\n        }\\n    };\\n    /**\\n     * Sets the active item properly given the default mode. In other words, it will\\n     * continue to move down the list until it finds an item that is not disabled. If\\n     * it encounters either end of the list, it will stop and not wrap.\\n     * @param {?} delta\\n     * @param {?} items\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype._setActiveInDefaultMode = function (delta, items) {\\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\\n    };\\n    /**\\n     * Sets the active item to the first enabled item starting at the index specified. If the\\n     * item is disabled, it will move in the fallbackDelta direction until it either\\n     * finds an enabled item or encounters the end of the list.\\n     * @param {?} index\\n     * @param {?} fallbackDelta\\n     * @param {?=} items\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype._setActiveItemByIndex = function (index, fallbackDelta, items) {\\n        if (items === void 0) { items = this._items.toArray(); }\\n        if (!items[index]) {\\n            return;\\n        }\\n        while (items[index].disabled) {\\n            index += fallbackDelta;\\n            if (!items[index]) {\\n                return;\\n            }\\n        }\\n        this.setActiveItem(index);\\n    };\\n    return ListKeyManager;\\n}());\\nvar FocusKeyManager = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FocusKeyManager, _super);\\n    /**\\n     * @param {?} items\\n     */\\n    function FocusKeyManager(items) {\\n        return _super.call(this, items) || this;\\n    }\\n    /**\\n     * This method sets the active item to the item at the specified index.\\n     * It also adds focuses the newly active item.\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    FocusKeyManager.prototype.setActiveItem = function (index) {\\n        _super.prototype.setActiveItem.call(this, index);\\n        if (this.activeItem) {\\n            this.activeItem.focus();\\n        }\\n    };\\n    return FocusKeyManager;\\n}(ListKeyManager));\\n/**\\n * This animation shrinks the placeholder text to 75% of its normal size and translates\\n * it to either the top left corner (ltr) or top right corner (rtl) of the trigger,\\n * depending on the text direction of the application.\\n */\\nvar transformPlaceholder = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"trigger\"])(\\'transformPlaceholder\\', [\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'floating-ltr\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({\\n        top: \\'-22px\\',\\n        left: \\'-2px\\',\\n        transform: \"scale(0.75)\"\\n    })),\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'floating-rtl\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({\\n        top: \\'-22px\\',\\n        left: \\'2px\\',\\n        transform: \"scale(0.75)\"\\n    })),\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'* => *\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\"400ms cubic-bezier(0.25, 0.8, 0.25, 1)\"))\\n]);\\n/**\\n * This animation transforms the select\\'s overlay panel on and off the page.\\n *\\n * When the panel is attached to the DOM, it expands its width 32px, scales it up to\\n * 100% on the Y axis, fades in its border, and translates slightly up and to the\\n * side to ensure the option text correctly overlaps the trigger text.\\n *\\n * When the panel is removed from the DOM, it simply fades out linearly.\\n */\\nvar transformPanel = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"trigger\"])(\\'transformPanel\\', [\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'showing\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({\\n        opacity: 1,\\n        minWidth: \\'calc(100% + 32px)\\',\\n        transform: \"scaleY(1)\"\\n    })),\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'void => *\\', [\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({\\n            opacity: 0,\\n            minWidth: \\'100%\\',\\n            transform: \"scaleY(0)\"\\n        }),\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\"150ms cubic-bezier(0.25, 0.8, 0.25, 1)\")\\n    ]),\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'* => void\\', [\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\\'250ms 100ms linear\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ opacity: 0 }))\\n    ])\\n]);\\n/**\\n * This animation fades in the background color and text content of the\\n * select\\'s options. It is time delayed to occur 100ms after the overlay\\n * panel has transformed in.\\n */\\nvar fadeInContent = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"trigger\"])(\\'fadeInContent\\', [\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'showing\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ opacity: 1 })),\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'void => showing\\', [\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ opacity: 0 }),\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\"150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)\")\\n    ])\\n]);\\n/**\\n * Returns an exception to be thrown when attempting to change a s\\n * elect\\'s `multiple` option after initialization.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdSelectDynamicMultipleError() {\\n    return new Error(\\'Cannot change `multiple` mode of select after initialization.\\');\\n}\\n/**\\n * Returns an exception to be thrown when attempting to assign a non-array value to a select\\n * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for\\n * resetting the value.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdSelectNonArrayValueError() {\\n    return new Error(\\'Cannot assign truthy non-array value to select in `multiple` mode.\\');\\n}\\n/**\\n * The fixed height of every option element.\\n */\\nvar SELECT_OPTION_HEIGHT = 48;\\n/**\\n * The max height of the select\\'s overlay panel\\n */\\nvar SELECT_PANEL_MAX_HEIGHT = 256;\\n/**\\n * The max number of options visible at once in the select panel.\\n */\\nvar SELECT_MAX_OPTIONS_DISPLAYED = 5;\\n/**\\n * The fixed height of the select\\'s trigger element.\\n */\\nvar SELECT_TRIGGER_HEIGHT = 30;\\n/**\\n * Must adjust for the difference in height between the option and the trigger,\\n * so the text will align on the y axis.\\n * (SELECT_OPTION_HEIGHT (48) - SELECT_TRIGGER_HEIGHT (30)) / 2 = 9\\n */\\nvar SELECT_OPTION_HEIGHT_ADJUSTMENT = 9;\\n/**\\n * The panel\\'s padding on the x-axis\\n */\\nvar SELECT_PANEL_PADDING_X = 16;\\n/**\\n * Distance between the panel edge and the option text in\\n * multi-selection mode.\\n *\\n * (SELECT_PADDING * 1.75) + 20 = 48\\n * The padding is multiplied by 1.75 because the checkbox\\'s margin is half the padding, and\\n * the browser adds ~4px, because we\\'re using inline elements.\\n * The checkbox width is 20px.\\n */\\nvar SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_PANEL_PADDING_X * 1.75 + 20;\\n/**\\n * The panel\\'s padding on the y-axis. This padding indicates there are more\\n * options available if you scroll.\\n */\\nvar SELECT_PANEL_PADDING_Y = 16;\\n/**\\n * The select panel will only \"fit\" inside the viewport if it is positioned at\\n * this value or more away from the viewport boundary.\\n */\\nvar SELECT_PANEL_VIEWPORT_PADDING = 8;\\n/**\\n * Change event object that is emitted when the select value has changed.\\n */\\nvar MdSelectChange = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} source\\n     * @param {?} value\\n     */\\n    function MdSelectChange(source, value) {\\n        this.source = source;\\n        this.value = value;\\n    }\\n    return MdSelectChange;\\n}());\\nvar MdSelect = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _element\\n     * @param {?} _renderer\\n     * @param {?} _viewportRuler\\n     * @param {?} _changeDetectorRef\\n     * @param {?} _dir\\n     * @param {?} _control\\n     * @param {?} tabIndex\\n     */\\n    function MdSelect(_element, _renderer, _viewportRuler, _changeDetectorRef, _dir, _control, tabIndex) {\\n        this._element = _element;\\n        this._renderer = _renderer;\\n        this._viewportRuler = _viewportRuler;\\n        this._changeDetectorRef = _changeDetectorRef;\\n        this._dir = _dir;\\n        this._control = _control;\\n        /**\\n         * Whether or not the overlay panel is open.\\n         */\\n        this._panelOpen = false;\\n        /**\\n         * Whether filling out the select is required in the form.\\n         */\\n        this._required = false;\\n        /**\\n         * Whether the select is disabled.\\n         */\\n        this._disabled = false;\\n        /**\\n         * The scroll position of the overlay panel, calculated to center the selected option.\\n         */\\n        this._scrollTop = 0;\\n        /**\\n         * Whether the component is in multiple selection mode.\\n         */\\n        this._multiple = false;\\n        /**\\n         * The animation state of the placeholder.\\n         */\\n        this._placeholderState = \\'\\';\\n        /**\\n         * View -> model callback called when value changes\\n         */\\n        this._onChange = function (value) { };\\n        /**\\n         * View -> model callback called when select has been touched\\n         */\\n        this._onTouched = function () { };\\n        /**\\n         * The IDs of child options to be passed to the aria-owns attribute.\\n         */\\n        this._optionIds = \\'\\';\\n        /**\\n         * The value of the select panel\\'s transform-origin property.\\n         */\\n        this._transformOrigin = \\'top\\';\\n        /**\\n         * Whether the panel\\'s animation is done.\\n         */\\n        this._panelDoneAnimating = false;\\n        /**\\n         * The y-offset of the overlay panel in relation to the trigger\\'s top start corner.\\n         * This must be adjusted to align the selected option text over the trigger text.\\n         * when the panel opens. Will change based on the y-position of the selected option.\\n         */\\n        this._offsetY = 0;\\n        /**\\n         * This position config ensures that the top \"start\" corner of the overlay\\n         * is aligned with with the top \"start\" of the origin by default (overlapping\\n         * the trigger completely). If the panel cannot fit below the trigger, it\\n         * will fall back to a position above the trigger.\\n         */\\n        this._positions = [\\n            {\\n                originX: \\'start\\',\\n                originY: \\'top\\',\\n                overlayX: \\'start\\',\\n                overlayY: \\'top\\',\\n            },\\n            {\\n                originX: \\'start\\',\\n                originY: \\'bottom\\',\\n                overlayX: \\'start\\',\\n                overlayY: \\'bottom\\',\\n            },\\n        ];\\n        this._floatPlaceholder = \\'auto\\';\\n        /**\\n         * Aria label of the select. If not specified, the placeholder will be used as label.\\n         */\\n        this.ariaLabel = \\'\\';\\n        /**\\n         * Input that can be used to specify the `aria-labelledby` attribute.\\n         */\\n        this.ariaLabelledby = \\'\\';\\n        /**\\n         * Event emitted when the select has been opened.\\n         */\\n        this.onOpen = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the select has been closed.\\n         */\\n        this.onClose = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the selected value has been changed by the user.\\n         */\\n        this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        if (this._control) {\\n            this._control.valueAccessor = this;\\n        }\\n        this._tabIndex = parseInt(tabIndex) || 0;\\n    }\\n    Object.defineProperty(MdSelect.prototype, \"placeholder\", {\\n        /**\\n         * Placeholder to be shown if no value has been selected.\\n         * @return {?}\\n         */\\n        get: function () { return this._placeholder; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            var _this = this;\\n            this._placeholder = value;\\n            // Must wait to record the trigger width to ensure placeholder width is included.\\n            Promise.resolve(null).then(function () { return _this._setTriggerWidth(); });\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"disabled\", {\\n        /**\\n         * Whether the component is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disabled; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"required\", {\\n        /**\\n         * Whether the component is required.\\n         * @return {?}\\n         */\\n        get: function () { return this._required; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._required = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"multiple\", {\\n        /**\\n         * Whether the user should be allowed to select multiple options.\\n         * @return {?}\\n         */\\n        get: function () { return this._multiple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._selectionModel) {\\n                throw getMdSelectDynamicMultipleError();\\n            }\\n            this._multiple = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"floatPlaceholder\", {\\n        /**\\n         * Whether to float the placeholder text.\\n         * @return {?}\\n         */\\n        get: function () { return this._floatPlaceholder; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._floatPlaceholder = value || \\'auto\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"tabIndex\", {\\n        /**\\n         * Tab index for the select element.\\n         * @return {?}\\n         */\\n        get: function () { return this._disabled ? -1 : this._tabIndex; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (typeof value !== \\'undefined\\') {\\n                this._tabIndex = value;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"color\", {\\n        /**\\n         * Theme color for the component.\\n         * @return {?}\\n         */\\n        get: function () { return this._color; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value && value !== this._color) {\\n                this._renderer.removeClass(this._element.nativeElement, \"mat-\" + this._color);\\n                this._renderer.addClass(this._element.nativeElement, \"mat-\" + value);\\n                this._color = value;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"optionSelectionChanges\", {\\n        /**\\n         * Combined stream of all of the child options\\' change events.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].merge.apply(__WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"], this.options.map(function (option) { return option.onSelectionChange; }));\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdSelect.prototype.ngOnInit = function () {\\n        this._selectionModel = new SelectionModel(this.multiple, null, false);\\n        this.color = this.color || \\'primary\\';\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSelect.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._initKeyManager();\\n        this._changeSubscription = this.options.changes.startWith(null).subscribe(function () {\\n            _this._resetOptions();\\n            if (_this._control) {\\n                // Defer setting the value in order to avoid the \"Expression\\n                // has changed after it was checked\" errors from Angular.\\n                Promise.resolve(null).then(function () { return _this._setSelectionByValue(_this._control.value); });\\n            }\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSelect.prototype.ngOnDestroy = function () {\\n        this._dropSubscriptions();\\n        if (this._changeSubscription) {\\n            this._changeSubscription.unsubscribe();\\n        }\\n        if (this._tabSubscription) {\\n            this._tabSubscription.unsubscribe();\\n        }\\n    };\\n    /**\\n     * Toggles the overlay panel open or closed.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.toggle = function () {\\n        this.panelOpen ? this.close() : this.open();\\n    };\\n    /**\\n     * Opens the overlay panel.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.open = function () {\\n        if (this.disabled || !this.options.length) {\\n            return;\\n        }\\n        if (!this._triggerWidth) {\\n            this._setTriggerWidth();\\n        }\\n        this._calculateOverlayPosition();\\n        this._placeholderState = this._floatPlaceholderState();\\n        this._panelOpen = true;\\n    };\\n    /**\\n     * Closes the overlay panel and focuses the host element.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.close = function () {\\n        if (this._panelOpen) {\\n            this._panelOpen = false;\\n            if (this._selectionModel.isEmpty()) {\\n                this._placeholderState = \\'\\';\\n            }\\n            this._focusHost();\\n        }\\n    };\\n    /**\\n     * Sets the select\\'s value. Part of the ControlValueAccessor interface\\n     * required to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} value New value to be written to the model.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.writeValue = function (value) {\\n        if (this.options) {\\n            this._setSelectionByValue(value);\\n        }\\n    };\\n    /**\\n     * Saves a callback function to be invoked when the select\\'s value\\n     * changes from user input. Part of the ControlValueAccessor interface\\n     * required to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} fn Callback to be triggered when the value changes.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.registerOnChange = function (fn) {\\n        this._onChange = fn;\\n    };\\n    /**\\n     * Saves a callback function to be invoked when the select is blurred\\n     * by the user. Part of the ControlValueAccessor interface required\\n     * to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} fn Callback to be triggered when the component has been touched.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.registerOnTouched = function (fn) {\\n        this._onTouched = fn;\\n    };\\n    /**\\n     * Disables the select. Part of the ControlValueAccessor interface required\\n     * to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} isDisabled Sets whether the component is disabled.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n    };\\n    Object.defineProperty(MdSelect.prototype, \"panelOpen\", {\\n        /**\\n         * Whether or not the overlay panel is open.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._panelOpen;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"selected\", {\\n        /**\\n         * The currently selected option.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"triggerValue\", {\\n        /**\\n         * The value displayed in the trigger.\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (this._multiple) {\\n                var /** @type {?} */ selectedOptions = this._selectionModel.selected.map(function (option) { return option.viewValue; });\\n                if (this._isRtl()) {\\n                    selectedOptions.reverse();\\n                }\\n                // TODO(crisbeto): delimiter should be configurable for proper localization.\\n                return selectedOptions.join(\\', \\');\\n            }\\n            return this._selectionModel.selected[0].viewValue;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Whether the element is in RTL mode.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._isRtl = function () {\\n        return this._dir ? this._dir.value === \\'rtl\\' : false;\\n    };\\n    /**\\n     * Sets the width of the trigger element. This is necessary to match\\n     * the overlay width to the trigger width.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setTriggerWidth = function () {\\n        this._triggerWidth = this._getTriggerRect().width;\\n    };\\n    /**\\n     * Handles the keyboard interactions of a closed select.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSelect.prototype._handleClosedKeydown = function (event) {\\n        if (!this.disabled) {\\n            if (event.keyCode === ENTER || event.keyCode === SPACE) {\\n                event.preventDefault(); // prevents the page from scrolling down when pressing space\\n                this.open();\\n            }\\n            else if (event.keyCode === UP_ARROW || event.keyCode === DOWN_ARROW) {\\n                this._handleArrowKey(event);\\n            }\\n        }\\n    };\\n    /**\\n     * Handles keypresses inside the panel.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSelect.prototype._handlePanelKeydown = function (event) {\\n        if (event.keyCode === HOME || event.keyCode === END) {\\n            event.preventDefault();\\n            event.keyCode === HOME ? this._keyManager.setFirstItemActive() :\\n                this._keyManager.setLastItemActive();\\n        }\\n        else {\\n            this._keyManager.onKeydown(event);\\n        }\\n    };\\n    /**\\n     * When the panel element is finished transforming in (though not fading in), it\\n     * emits an event and focuses an option if the panel is open.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._onPanelDone = function () {\\n        if (this.panelOpen) {\\n            this._focusCorrectOption();\\n            this.onOpen.emit();\\n        }\\n        else {\\n            this.onClose.emit();\\n            this._panelDoneAnimating = false;\\n            this.overlayDir.offsetX = 0;\\n        }\\n    };\\n    /**\\n     * When the panel content is done fading in, the _panelDoneAnimating property is\\n     * set so the proper class can be added to the panel.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._onFadeInDone = function () {\\n        this._panelDoneAnimating = this.panelOpen;\\n    };\\n    /**\\n     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\\n     * \"blur\" to the panel when it opens, causing a false positive.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._onBlur = function () {\\n        if (!this.panelOpen) {\\n            this._onTouched();\\n        }\\n    };\\n    /**\\n     * Callback that is invoked when the overlay panel has been attached.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._onAttached = function () {\\n        this._calculateOverlayOffsetX();\\n        this._setScrollTop();\\n    };\\n    /**\\n     * Sets the scroll position of the scroll container. This must be called after\\n     * the overlay pane is attached or the scroll container element will not yet be\\n     * present in the DOM.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setScrollTop = function () {\\n        var /** @type {?} */ scrollContainer = this.overlayDir.overlayRef.overlayElement.querySelector(\\'.mat-select-panel\\');\\n        scrollContainer.scrollTop = this._scrollTop;\\n    };\\n    /**\\n     * Sets the selected option based on a value. If no option can be\\n     * found with the designated value, the select trigger is cleared.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setSelectionByValue = function (value) {\\n        var _this = this;\\n        var /** @type {?} */ isArray = Array.isArray(value);\\n        if (this.multiple && value && !isArray) {\\n            throw getMdSelectNonArrayValueError();\\n        }\\n        this._clearSelection();\\n        if (isArray) {\\n            value.forEach(function (currentValue) { return _this._selectValue(currentValue); });\\n            this._sortValues();\\n        }\\n        else {\\n            this._selectValue(value);\\n        }\\n        this._setValueWidth();\\n        if (this._selectionModel.isEmpty()) {\\n            this._placeholderState = \\'\\';\\n        }\\n        this._changeDetectorRef.markForCheck();\\n    };\\n    /**\\n     * Finds and selects and option based on its value.\\n     * @param {?} value\\n     * @return {?} Option that has the corresponding value.\\n     */\\n    MdSelect.prototype._selectValue = function (value) {\\n        var /** @type {?} */ optionsArray = this.options.toArray();\\n        var /** @type {?} */ correspondingOption = optionsArray.find(function (option) { return option.value && option.value === value; });\\n        if (correspondingOption) {\\n            correspondingOption.select();\\n            this._selectionModel.select(correspondingOption);\\n            this._keyManager.setActiveItem(optionsArray.indexOf(correspondingOption));\\n        }\\n        return correspondingOption;\\n    };\\n    /**\\n     * Clears the select trigger and deselects every option in the list.\\n     * @param {?=} skip Option that should not be deselected.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._clearSelection = function (skip) {\\n        this._selectionModel.clear();\\n        this.options.forEach(function (option) {\\n            if (option !== skip) {\\n                option.deselect();\\n            }\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getTriggerRect = function () {\\n        return this.trigger.nativeElement.getBoundingClientRect();\\n    };\\n    /**\\n     * Sets up a key manager to listen to keyboard events on the overlay panel.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._initKeyManager = function () {\\n        var _this = this;\\n        this._keyManager = new FocusKeyManager(this.options);\\n        this._tabSubscription = this._keyManager.tabOut.subscribe(function () { return _this.close(); });\\n    };\\n    /**\\n     * Drops current option subscriptions and IDs and resets from scratch.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._resetOptions = function () {\\n        this._dropSubscriptions();\\n        this._listenToOptions();\\n        this._setOptionIds();\\n        this._setOptionMultiple();\\n    };\\n    /**\\n     * Listens to user-generated selection events on each option.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._listenToOptions = function () {\\n        var _this = this;\\n        this._optionSubscription = this.optionSelectionChanges\\n            .filter(function (event) { return event.isUserInput; })\\n            .subscribe(function (event) {\\n            _this._onSelect(event.source);\\n            _this._setValueWidth();\\n            if (!_this.multiple) {\\n                _this.close();\\n            }\\n        });\\n    };\\n    /**\\n     * Invoked when an option is clicked.\\n     * @param {?} option\\n     * @return {?}\\n     */\\n    MdSelect.prototype._onSelect = function (option) {\\n        var /** @type {?} */ wasSelected = this._selectionModel.isSelected(option);\\n        // TODO(crisbeto): handle blank/null options inside multi-select.\\n        if (this.multiple) {\\n            this._selectionModel.toggle(option);\\n            wasSelected ? option.deselect() : option.select();\\n            this._sortValues();\\n        }\\n        else {\\n            this._clearSelection(option.value == null ? null : option);\\n            if (option.value == null) {\\n                this._propagateChanges(option.value);\\n            }\\n            else {\\n                this._selectionModel.select(option);\\n            }\\n        }\\n        if (wasSelected !== this._selectionModel.isSelected(option)) {\\n            this._propagateChanges();\\n        }\\n    };\\n    /**\\n     * Sorts the model values, ensuring that they keep the same\\n     * order that they have in the panel.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._sortValues = function () {\\n        var _this = this;\\n        if (this._multiple) {\\n            this._selectionModel.clear();\\n            this.options.forEach(function (option) {\\n                if (option.selected) {\\n                    _this._selectionModel.select(option);\\n                }\\n            });\\n        }\\n    };\\n    /**\\n     * Unsubscribes from all option subscriptions.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._dropSubscriptions = function () {\\n        if (this._optionSubscription) {\\n            this._optionSubscription.unsubscribe();\\n            this._optionSubscription = null;\\n        }\\n    };\\n    /**\\n     * Emits change event to set the model value.\\n     * @param {?=} fallbackValue\\n     * @return {?}\\n     */\\n    MdSelect.prototype._propagateChanges = function (fallbackValue) {\\n        var /** @type {?} */ valueToEmit = null;\\n        if (Array.isArray(this.selected)) {\\n            valueToEmit = this.selected.map(function (option) { return option.value; });\\n        }\\n        else {\\n            valueToEmit = this.selected ? this.selected.value : fallbackValue;\\n        }\\n        this._onChange(valueToEmit);\\n        this.change.emit(new MdSelectChange(this, valueToEmit));\\n    };\\n    /**\\n     * Records option IDs to pass to the aria-owns property.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setOptionIds = function () {\\n        this._optionIds = this.options.map(function (option) { return option.id; }).join(\\' \\');\\n    };\\n    /**\\n     * Sets the `multiple` property on each option. The promise is necessary\\n     * in order to avoid Angular errors when modifying the property after init.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setOptionMultiple = function () {\\n        var _this = this;\\n        if (this.multiple) {\\n            Promise.resolve(null).then(function () {\\n                _this.options.forEach(function (option) { return option.multiple = _this.multiple; });\\n            });\\n        }\\n    };\\n    /**\\n     * Must set the width of the selected option\\'s value programmatically\\n     * because it is absolutely positioned and otherwise will not clip\\n     * overflow. The selection arrow is 9px wide, add 4px of padding = 13\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setValueWidth = function () {\\n        this._selectedValueWidth = this._triggerWidth - 13;\\n    };\\n    /**\\n     * Focuses the selected item. If no option is selected, it will focus\\n     * the first item instead.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._focusCorrectOption = function () {\\n        if (this._selectionModel.isEmpty()) {\\n            this._keyManager.setFirstItemActive();\\n        }\\n        else {\\n            this._keyManager.setActiveItem(this._getOptionIndex(this._selectionModel.selected[0]));\\n        }\\n    };\\n    /**\\n     * Focuses the host element when the panel closes.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._focusHost = function () {\\n        this._element.nativeElement.focus();\\n    };\\n    /**\\n     * Gets the index of the provided option in the option list.\\n     * @param {?} option\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getOptionIndex = function (option) {\\n        return this.options.reduce(function (result, current, index) {\\n            return result === undefined ? (option === current ? index : undefined) : result;\\n        }, undefined);\\n    };\\n    /**\\n     * Calculates the scroll position and x- and y-offsets of the overlay panel.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._calculateOverlayPosition = function () {\\n        var /** @type {?} */ panelHeight = Math.min(this.options.length * SELECT_OPTION_HEIGHT, SELECT_PANEL_MAX_HEIGHT);\\n        var /** @type {?} */ scrollContainerHeight = this.options.length * SELECT_OPTION_HEIGHT;\\n        // The farthest the panel can be scrolled before it hits the bottom\\n        var /** @type {?} */ maxScroll = scrollContainerHeight - panelHeight;\\n        if (this._selectionModel.hasValue()) {\\n            var /** @type {?} */ selectedIndex = this._getOptionIndex(this._selectionModel.selected[0]);\\n            // We must maintain a scroll buffer so the selected option will be scrolled to the\\n            // center of the overlay panel rather than the top.\\n            var /** @type {?} */ scrollBuffer = panelHeight / 2;\\n            this._scrollTop = this._calculateOverlayScroll(selectedIndex, scrollBuffer, maxScroll);\\n            this._offsetY = this._calculateOverlayOffsetY(selectedIndex, scrollBuffer, maxScroll);\\n        }\\n        else {\\n            // If no option is selected, the panel centers on the first option. In this case,\\n            // we must only adjust for the height difference between the option element\\n            // and the trigger element, then multiply it by -1 to ensure the panel moves\\n            // in the correct direction up the page.\\n            this._offsetY = (SELECT_OPTION_HEIGHT - SELECT_TRIGGER_HEIGHT) / 2 * -1;\\n        }\\n        this._checkOverlayWithinViewport(maxScroll);\\n    };\\n    /**\\n     * Calculates the scroll position of the select\\'s overlay panel.\\n     *\\n     * Attempts to center the selected option in the panel. If the option is\\n     * too high or too low in the panel to be scrolled to the center, it clamps the\\n     * scroll position to the min or max scroll positions respectively.\\n     * @param {?} selectedIndex\\n     * @param {?} scrollBuffer\\n     * @param {?} maxScroll\\n     * @return {?}\\n     */\\n    MdSelect.prototype._calculateOverlayScroll = function (selectedIndex, scrollBuffer, maxScroll) {\\n        var /** @type {?} */ optionOffsetFromScrollTop = SELECT_OPTION_HEIGHT * selectedIndex;\\n        var /** @type {?} */ halfOptionHeight = SELECT_OPTION_HEIGHT / 2;\\n        // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the\\n        // scroll container, then subtracts the scroll buffer to scroll the option down to\\n        // the center of the overlay panel. Half the option height must be re-added to the\\n        // scrollTop so the option is centered based on its middle, not its top edge.\\n        var /** @type {?} */ optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;\\n        return clampValue(0, optimalScrollPosition, maxScroll);\\n    };\\n    /**\\n     * Figures out the appropriate animation state for the placeholder.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getPlaceholderAnimationState = function () {\\n        if (this.floatPlaceholder === \\'never\\') {\\n            return \\'\\';\\n        }\\n        if (this.floatPlaceholder === \\'always\\') {\\n            return this._floatPlaceholderState();\\n        }\\n        return this._placeholderState;\\n    };\\n    /**\\n     * Determines the CSS `opacity` of the placeholder element.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getPlaceholderOpacity = function () {\\n        return (this.floatPlaceholder !== \\'never\\' || this._selectionModel.isEmpty()) ?\\n            \\'1\\' : \\'0\\';\\n    };\\n    Object.defineProperty(MdSelect.prototype, \"_ariaLabel\", {\\n        /**\\n         * Returns the aria-label of the select component.\\n         * @return {?}\\n         */\\n        get: function () {\\n            // If an ariaLabelledby value has been set, the select should not overwrite the\\n            // `aria-labelledby` value by setting the ariaLabel to the placeholder.\\n            return this.ariaLabelledby ? null : this.ariaLabel || this.placeholder;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the x-offset of the overlay panel in relation to the trigger\\'s top start corner.\\n     * This must be adjusted to align the selected option text over the trigger text when\\n     * the panel opens. Will change based on LTR or RTL text direction. Note that the offset\\n     * can\\'t be calculated until the panel has been attached, because we need to know the\\n     * content width in order to constrain the panel within the viewport.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._calculateOverlayOffsetX = function () {\\n        var /** @type {?} */ overlayRect = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect();\\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\\n        var /** @type {?} */ isRtl = this._isRtl();\\n        var /** @type {?} */ offsetX = this.multiple ? SELECT_MULTIPLE_PANEL_PADDING_X : SELECT_PANEL_PADDING_X;\\n        if (!isRtl) {\\n            offsetX *= -1;\\n        }\\n        var /** @type {?} */ leftOverflow = 0 - (overlayRect.left + offsetX\\n            - (isRtl ? SELECT_PANEL_PADDING_X * 2 : 0));\\n        var /** @type {?} */ rightOverflow = overlayRect.right + offsetX - viewportRect.width\\n            + (isRtl ? 0 : SELECT_PANEL_PADDING_X * 2);\\n        if (leftOverflow > 0) {\\n            offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;\\n        }\\n        else if (rightOverflow > 0) {\\n            offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;\\n        }\\n        // Set the offset directly in order to avoid having to go through change detection and\\n        // potentially triggering \"changed after it was checked\" errors.\\n        this.overlayDir.offsetX = offsetX;\\n        this.overlayDir.overlayRef.updatePosition();\\n    };\\n    /**\\n     * Calculates the y-offset of the select\\'s overlay panel in relation to the\\n     * top start corner of the trigger. It has to be adjusted in order for the\\n     * selected option to be aligned over the trigger when the panel opens.\\n     * @param {?} selectedIndex\\n     * @param {?} scrollBuffer\\n     * @param {?} maxScroll\\n     * @return {?}\\n     */\\n    MdSelect.prototype._calculateOverlayOffsetY = function (selectedIndex, scrollBuffer, maxScroll) {\\n        var /** @type {?} */ optionOffsetFromPanelTop;\\n        if (this._scrollTop === 0) {\\n            optionOffsetFromPanelTop = selectedIndex * SELECT_OPTION_HEIGHT;\\n        }\\n        else if (this._scrollTop === maxScroll) {\\n            var /** @type {?} */ firstDisplayedIndex = this.options.length - SELECT_MAX_OPTIONS_DISPLAYED;\\n            var /** @type {?} */ selectedDisplayIndex = selectedIndex - firstDisplayedIndex;\\n            // Because the panel height is longer than the height of the options alone,\\n            // there is always extra padding at the top or bottom of the panel. When\\n            // scrolled to the very bottom, this padding is at the top of the panel and\\n            // must be added to the offset.\\n            optionOffsetFromPanelTop =\\n                selectedDisplayIndex * SELECT_OPTION_HEIGHT + SELECT_PANEL_PADDING_Y;\\n        }\\n        else {\\n            // If the option was scrolled to the middle of the panel using a scroll buffer,\\n            // its offset will be the scroll buffer minus the half height that was added to\\n            // center it.\\n            optionOffsetFromPanelTop = scrollBuffer - SELECT_OPTION_HEIGHT / 2;\\n        }\\n        // The final offset is the option\\'s offset from the top, adjusted for the height\\n        // difference, multiplied by -1 to ensure that the overlay moves in the correct\\n        // direction up the page.\\n        return optionOffsetFromPanelTop * -1 - SELECT_OPTION_HEIGHT_ADJUSTMENT;\\n    };\\n    /**\\n     * Checks that the attempted overlay position will fit within the viewport.\\n     * If it will not fit, tries to adjust the scroll position and the associated\\n     * y-offset so the panel can open fully on-screen. If it still won\\'t fit,\\n     * sets the offset back to 0 to allow the fallback position to take over.\\n     * @param {?} maxScroll\\n     * @return {?}\\n     */\\n    MdSelect.prototype._checkOverlayWithinViewport = function (maxScroll) {\\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\\n        var /** @type {?} */ triggerRect = this._getTriggerRect();\\n        var /** @type {?} */ topSpaceAvailable = triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;\\n        var /** @type {?} */ bottomSpaceAvailable = viewportRect.height - triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;\\n        var /** @type {?} */ panelHeightTop = Math.abs(this._offsetY);\\n        var /** @type {?} */ totalPanelHeight = Math.min(this.options.length * SELECT_OPTION_HEIGHT, SELECT_PANEL_MAX_HEIGHT);\\n        var /** @type {?} */ panelHeightBottom = totalPanelHeight - panelHeightTop - triggerRect.height;\\n        if (panelHeightBottom > bottomSpaceAvailable) {\\n            this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);\\n        }\\n        else if (panelHeightTop > topSpaceAvailable) {\\n            this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);\\n        }\\n        else {\\n            this._transformOrigin = this._getOriginBasedOnOption();\\n        }\\n    };\\n    /**\\n     * Adjusts the overlay panel up to fit in the viewport.\\n     * @param {?} panelHeightBottom\\n     * @param {?} bottomSpaceAvailable\\n     * @return {?}\\n     */\\n    MdSelect.prototype._adjustPanelUp = function (panelHeightBottom, bottomSpaceAvailable) {\\n        var /** @type {?} */ distanceBelowViewport = panelHeightBottom - bottomSpaceAvailable;\\n        // Scrolls the panel up by the distance it was extending past the boundary, then\\n        // adjusts the offset by that amount to move the panel up into the viewport.\\n        this._scrollTop -= distanceBelowViewport;\\n        this._offsetY -= distanceBelowViewport;\\n        this._transformOrigin = this._getOriginBasedOnOption();\\n        // If the panel is scrolled to the very top, it won\\'t be able to fit the panel\\n        // by scrolling, so set the offset to 0 to allow the fallback position to take\\n        // effect.\\n        if (this._scrollTop <= 0) {\\n            this._scrollTop = 0;\\n            this._offsetY = 0;\\n            this._transformOrigin = \"50% bottom 0px\";\\n        }\\n    };\\n    /**\\n     * Adjusts the overlay panel down to fit in the viewport.\\n     * @param {?} panelHeightTop\\n     * @param {?} topSpaceAvailable\\n     * @param {?} maxScroll\\n     * @return {?}\\n     */\\n    MdSelect.prototype._adjustPanelDown = function (panelHeightTop, topSpaceAvailable, maxScroll) {\\n        var /** @type {?} */ distanceAboveViewport = panelHeightTop - topSpaceAvailable;\\n        // Scrolls the panel down by the distance it was extending past the boundary, then\\n        // adjusts the offset by that amount to move the panel down into the viewport.\\n        this._scrollTop += distanceAboveViewport;\\n        this._offsetY += distanceAboveViewport;\\n        this._transformOrigin = this._getOriginBasedOnOption();\\n        // If the panel is scrolled to the very bottom, it won\\'t be able to fit the\\n        // panel by scrolling, so set the offset to 0 to allow the fallback position\\n        // to take effect.\\n        if (this._scrollTop >= maxScroll) {\\n            this._scrollTop = maxScroll;\\n            this._offsetY = 0;\\n            this._transformOrigin = \"50% top 0px\";\\n            return;\\n        }\\n    };\\n    /**\\n     * Sets the transform origin point based on the selected option.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getOriginBasedOnOption = function () {\\n        var /** @type {?} */ originY = Math.abs(this._offsetY) - SELECT_OPTION_HEIGHT_ADJUSTMENT + SELECT_OPTION_HEIGHT / 2;\\n        return \"50% \" + originY + \"px 0px\";\\n    };\\n    /**\\n     * Figures out the floating placeholder state value.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._floatPlaceholderState = function () {\\n        return this._isRtl() ? \\'floating-rtl\\' : \\'floating-ltr\\';\\n    };\\n    /**\\n     * Handles the user pressing the arrow keys on a closed select.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSelect.prototype._handleArrowKey = function (event) {\\n        if (this._multiple) {\\n            event.preventDefault();\\n            this.open();\\n        }\\n        else {\\n            var /** @type {?} */ prevActiveItem = this._keyManager.activeItem;\\n            // Cycle though the select options even when the select is closed,\\n            // matching the behavior of the native select element.\\n            // TODO(crisbeto): native selects also cycle through the options with left/right arrows,\\n            // however the key manager only supports up/down at the moment.\\n            this._keyManager.onKeydown(event);\\n            var /** @type {?} */ currentActiveItem = (this._keyManager.activeItem);\\n            if (currentActiveItem !== prevActiveItem) {\\n                this._clearSelection();\\n                this._setSelectionByValue(currentActiveItem.value);\\n                this._propagateChanges();\\n            }\\n        }\\n    };\\n    return MdSelect;\\n}());\\nMdSelect.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-select, mat-select\\',\\n                template: \"<div class=\\\\\"mat-select-trigger\\\\\" cdk-overlay-origin (click)=\\\\\"toggle()\\\\\" #origin=\\\\\"cdkOverlayOrigin\\\\\" #trigger> <span class=\\\\\"mat-select-placeholder\\\\\" [class.mat-floating-placeholder]=\\\\\"_selectionModel.hasValue()\\\\\" [@transformPlaceholder]=\\\\\"_getPlaceholderAnimationState()\\\\\" [style.opacity]=\\\\\"_getPlaceholderOpacity()\\\\\" [style.width.px]=\\\\\"_selectedValueWidth\\\\\"> {{ placeholder }} </span> <span class=\\\\\"mat-select-value\\\\\" *ngIf=\\\\\"_selectionModel.hasValue()\\\\\"> <span class=\\\\\"mat-select-value-text\\\\\">{{ triggerValue }}</span> </span> <span class=\\\\\"mat-select-arrow\\\\\"></span> <span class=\\\\\"mat-select-underline\\\\\"></span> </div> <ng-template cdk-connected-overlay [origin]=\\\\\"origin\\\\\" [open]=\\\\\"panelOpen\\\\\" hasBackdrop (backdropClick)=\\\\\"close()\\\\\" backdropClass=\\\\\"cdk-overlay-transparent-backdrop\\\\\" [positions]=\\\\\"_positions\\\\\" [minWidth]=\\\\\"_triggerWidth\\\\\" [offsetY]=\\\\\"_offsetY\\\\\" (attach)=\\\\\"_onAttached()\\\\\" (detach)=\\\\\"close()\\\\\"> <div class=\\\\\"mat-select-panel\\\\\" [@transformPanel]=\\\\\"\\'showing\\'\\\\\" (@transformPanel.done)=\\\\\"_onPanelDone()\\\\\" (keydown)=\\\\\"_handlePanelKeydown($event)\\\\\" [style.transformOrigin]=\\\\\"_transformOrigin\\\\\" [class.mat-select-panel-done-animating]=\\\\\"_panelDoneAnimating\\\\\" [ngClass]=\\\\\"\\'mat-\\' + color\\\\\"> <div class=\\\\\"mat-select-content\\\\\" [@fadeInContent]=\\\\\"\\'showing\\'\\\\\" (@fadeInContent.done)=\\\\\"_onFadeInDone()\\\\\"> <ng-content></ng-content> </div> </div> </ng-template> \",\\n                styles: [\".mat-select{display:inline-block;outline:0;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif}.mat-select-trigger{display:flex;align-items:center;height:30px;min-width:112px;cursor:pointer;position:relative;box-sizing:border-box;font-size:16px}[aria-disabled=true] .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-underline{position:absolute;bottom:0;left:0;right:0;height:1px}[aria-disabled=true] .mat-select-underline{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;background-color:transparent;background-position:0 bottom}.mat-select-placeholder{position:relative;padding:0 2px;transform-origin:left top;flex-grow:1}.mat-select-placeholder.mat-floating-placeholder{top:-22px;left:-2px;text-align:left;transform:scale(.75)}[dir=rtl] .mat-select-placeholder{transform-origin:right top}[dir=rtl] .mat-select-placeholder.mat-floating-placeholder{left:2px;text-align:right}[aria-required=true] .mat-select-placeholder::after{content:\\'*\\'}.mat-select-value{position:absolute;max-width:calc(100% - 18px);flex-grow:1;top:0;left:0;bottom:0;display:flex;align-items:center}[dir=rtl] .mat-select-value{left:auto;right:0}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;line-height:30px}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%}@media screen and (-ms-high-contrast:active){.mat-select-panel{outline:solid 1px}} /*# sourceMappingURL=select.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'role\\': \\'listbox\\',\\n                    \\'[attr.tabindex]\\': \\'tabIndex\\',\\n                    \\'[attr.aria-label]\\': \\'_ariaLabel\\',\\n                    \\'[attr.aria-labelledby]\\': \\'ariaLabelledby\\',\\n                    \\'[attr.aria-required]\\': \\'required.toString()\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled.toString()\\',\\n                    \\'[attr.aria-invalid]\\': \\'_control?.invalid || \"false\"\\',\\n                    \\'[attr.aria-owns]\\': \\'_optionIds\\',\\n                    \\'[class.mat-select-disabled]\\': \\'disabled\\',\\n                    \\'[class.mat-select]\\': \\'true\\',\\n                    \\'(keydown)\\': \\'_handleClosedKeydown($event)\\',\\n                    \\'(blur)\\': \\'_onBlur()\\',\\n                },\\n                animations: [\\n                    transformPlaceholder,\\n                    transformPanel,\\n                    fadeInContent\\n                ],\\n                exportAs: \\'mdSelect\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSelect.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: ViewportRuler, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NgControl\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Attribute\"], args: [\\'tabindex\\',] },] },\\n]; };\\nMdSelect.propDecorators = {\\n    \\'trigger\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'trigger\\',] },],\\n    \\'overlayDir\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [ConnectedOverlayDirective,] },],\\n    \\'options\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdOption,] },],\\n    \\'placeholder\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'required\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'multiple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'floatPlaceholder\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'tabIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'ariaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'ariaLabelledby\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-labelledby\\',] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'onOpen\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'onClose\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Clamps a value n between min and max values.\\n * @param {?} min\\n * @param {?} n\\n * @param {?} max\\n * @return {?}\\n */\\nfunction clampValue(min, n, max) {\\n    return Math.min(Math.max(min, n), max);\\n}\\nvar MdSelectModule = /*@__PURE__*/(function () {\\n    function MdSelectModule() {\\n    }\\n    return MdSelectModule;\\n}());\\nMdSelectModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"],\\n                    OverlayModule,\\n                    MdOptionModule,\\n                    MdCommonModule,\\n                ],\\n                exports: [MdSelect, MdOptionModule, MdCommonModule],\\n                declarations: [MdSelect],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSelectModule.ctorParameters = function () { return []; };\\nvar MD_SLIDE_TOGGLE_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"])(function () { return MdSlideToggle; }),\\n    multi: true\\n};\\nvar MdSlideToggleChange = /*@__PURE__*/(function () {\\n    function MdSlideToggleChange() {\\n    }\\n    return MdSlideToggleChange;\\n}());\\n// Increasing integer for generating unique ids for slide-toggle components.\\nvar nextId$1 = 0;\\nvar MdSlideToggleBase = /*@__PURE__*/(function () {\\n    function MdSlideToggleBase() {\\n    }\\n    return MdSlideToggleBase;\\n}());\\nvar _MdSlideToggleMixinBase = mixinDisabled(MdSlideToggleBase);\\n/**\\n * Represents a slidable \"switch\" toggle that can be moved between on and off.\\n */\\nvar MdSlideToggle = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdSlideToggle, _super);\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     * @param {?} _focusOriginMonitor\\n     */\\n    function MdSlideToggle(_elementRef, _renderer, _focusOriginMonitor) {\\n        var _this = _super.call(this) || this;\\n        _this._elementRef = _elementRef;\\n        _this._renderer = _renderer;\\n        _this._focusOriginMonitor = _focusOriginMonitor;\\n        _this.onChange = function (_) { };\\n        _this.onTouched = function () { };\\n        _this._uniqueId = \"md-slide-toggle-\" + ++nextId$1;\\n        _this._checked = false;\\n        _this._slideRenderer = null;\\n        _this._required = false;\\n        _this._disableRipple = false;\\n        /**\\n         * Name value will be applied to the input element if present\\n         */\\n        _this.name = null;\\n        /**\\n         * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.\\n         */\\n        _this.id = _this._uniqueId;\\n        /**\\n         * Used to specify the tabIndex value for the underlying input element.\\n         */\\n        _this.tabIndex = 0;\\n        /**\\n         * Whether the label should appear after or before the slide-toggle. Defaults to \\'after\\'\\n         */\\n        _this.labelPosition = \\'after\\';\\n        /**\\n         * Used to set the aria-label attribute on the underlying input element.\\n         */\\n        _this.ariaLabel = null;\\n        /**\\n         * Used to set the aria-labelledby attribute on the underlying input element.\\n         */\\n        _this.ariaLabelledby = null;\\n        /**\\n         * An event will be dispatched each time the slide-toggle changes its value.\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        return _this;\\n    }\\n    Object.defineProperty(MdSlideToggle.prototype, \"required\", {\\n        /**\\n         * Whether the slide-toggle is required.\\n         * @return {?}\\n         */\\n        get: function () { return this._required; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._required = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlideToggle.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect for this slide-toggle is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlideToggle.prototype, \"inputId\", {\\n        /**\\n         * Returns the unique id for the visual hidden input.\\n         * @return {?}\\n         */\\n        get: function () { return (this.id || this._uniqueId) + \"-input\"; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._slideRenderer = new SlideToggleRenderer(this._elementRef);\\n        this._focusOriginMonitor\\n            .monitor(this._inputElement.nativeElement, this._renderer, false)\\n            .subscribe(function (focusOrigin) { return _this._onInputFocusChange(focusOrigin); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._inputElement.nativeElement);\\n    };\\n    /**\\n     * The onChangeEvent method will be also called on click.\\n     * This is because everything for the slide-toggle is wrapped inside of a label,\\n     * which triggers a onChange event on click.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onChangeEvent = function (event) {\\n        // We always have to stop propagation on the change event.\\n        // Otherwise the change event, from the input element, will bubble up and\\n        // emit its event object to the component\\'s `change` output.\\n        event.stopPropagation();\\n        // Once a drag is currently in progress, we do not want to toggle the slide-toggle on a click.\\n        if (!this.disabled && !this._slideRenderer.dragging) {\\n            this.toggle();\\n            // Emit our custom change event if the native input emitted one.\\n            // It is important to only emit it, if the native input triggered one, because\\n            // we don\\'t want to trigger a change event, when the `checked` variable changes for example.\\n            this._emitChangeEvent();\\n        }\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onInputClick = function (event) {\\n        this.onTouched();\\n        // We have to stop propagation for click events on the visual hidden input element.\\n        // By default, when a user clicks on a label element, a generated click event will be\\n        // dispatched on the associated input element. Since we are using a label element as our\\n        // root container, the click event on the `slide-toggle` will be executed twice.\\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\\n        // This will lead to multiple click events.\\n        // Preventing bubbling for the second event will solve that issue.\\n        event.stopPropagation();\\n    };\\n    /**\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.writeValue = function (value) {\\n        this.checked = value;\\n    };\\n    /**\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.registerOnChange = function (fn) {\\n        this.onChange = fn;\\n    };\\n    /**\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.registerOnTouched = function (fn) {\\n        this.onTouched = fn;\\n    };\\n    /**\\n     * Implemented as a part of ControlValueAccessor.\\n     * @param {?} isDisabled\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n    };\\n    /**\\n     * Focuses the slide-toggle.\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.focus = function () {\\n        this._focusOriginMonitor.focusVia(this._inputElement.nativeElement, this._renderer, \\'keyboard\\');\\n    };\\n    Object.defineProperty(MdSlideToggle.prototype, \"checked\", {\\n        /**\\n         * Whether the slide-toggle is checked.\\n         * @return {?}\\n         */\\n        get: function () { return !!this._checked; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this.checked !== !!value) {\\n                this._checked = value;\\n                this.onChange(this._checked);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlideToggle.prototype, \"color\", {\\n        /**\\n         * The color of the slide-toggle. Can be primary, accent, or warn.\\n         * @return {?}\\n         */\\n        get: function () { return this._color; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._updateColor(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Toggles the checked state of the slide-toggle.\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.toggle = function () {\\n        this.checked = !this.checked;\\n    };\\n    /**\\n     * Function is called whenever the focus changes for the input element.\\n     * @param {?} focusOrigin\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onInputFocusChange = function (focusOrigin) {\\n        if (!this._focusRipple && focusOrigin === \\'keyboard\\') {\\n            // For keyboard focus show a persistent ripple as focus indicator.\\n            this._focusRipple = this._ripple.launch(0, 0, { persistent: true, centered: true });\\n        }\\n        else if (!focusOrigin) {\\n            this.onTouched();\\n            // Fade out and clear the focus ripple if one is currently present.\\n            if (this._focusRipple) {\\n                this._focusRipple.fadeOut();\\n                this._focusRipple = null;\\n            }\\n        }\\n    };\\n    /**\\n     * @param {?} newColor\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._updateColor = function (newColor) {\\n        this._setElementColor(this._color, false);\\n        this._setElementColor(newColor, true);\\n        this._color = newColor;\\n    };\\n    /**\\n     * @param {?} color\\n     * @param {?} isAdd\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._setElementColor = function (color, isAdd) {\\n        if (color != null && color != \\'\\') {\\n            if (isAdd) {\\n                this._renderer.addClass(this._elementRef.nativeElement, \"mat-\" + color);\\n            }\\n            else {\\n                this._renderer.removeClass(this._elementRef.nativeElement, \"mat-\" + color);\\n            }\\n        }\\n    };\\n    /**\\n     * Emits the change event to the `change` output EventEmitter\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._emitChangeEvent = function () {\\n        var /** @type {?} */ event = new MdSlideToggleChange();\\n        event.source = this;\\n        event.checked = this.checked;\\n        this.change.emit(event);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onDragStart = function () {\\n        if (!this.disabled) {\\n            this._slideRenderer.startThumbDrag(this.checked);\\n        }\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onDrag = function (event) {\\n        if (this._slideRenderer.dragging) {\\n            this._slideRenderer.updateThumbPosition(event.deltaX);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onDragEnd = function () {\\n        var _this = this;\\n        if (this._slideRenderer.dragging) {\\n            var /** @type {?} */ _previousChecked = this.checked;\\n            this.checked = this._slideRenderer.dragPercentage > 50;\\n            if (_previousChecked !== this.checked) {\\n                this._emitChangeEvent();\\n            }\\n            // The drag should be stopped outside of the current event handler, because otherwise the\\n            // click event will be fired before and will revert the drag change.\\n            setTimeout(function () { return _this._slideRenderer.stopThumbDrag(); });\\n        }\\n    };\\n    return MdSlideToggle;\\n}(_MdSlideToggleMixinBase));\\nMdSlideToggle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-slide-toggle, mat-slide-toggle\\',\\n                host: {\\n                    \\'[class.mat-slide-toggle]\\': \\'true\\',\\n                    \\'[class.mat-checked]\\': \\'checked\\',\\n                    \\'[class.mat-disabled]\\': \\'disabled\\',\\n                    \\'[class.mat-slide-toggle-label-before]\\': \\'labelPosition == \"before\"\\',\\n                },\\n                template: \"<label class=\\\\\"mat-slide-toggle-label\\\\\" #label> <div class=\\\\\"mat-slide-toggle-bar\\\\\"> <input #input class=\\\\\"mat-slide-toggle-input cdk-visually-hidden\\\\\" type=\\\\\"checkbox\\\\\" [id]=\\\\\"inputId\\\\\" [required]=\\\\\"required\\\\\" [tabIndex]=\\\\\"tabIndex\\\\\" [checked]=\\\\\"checked\\\\\" [disabled]=\\\\\"disabled\\\\\" [attr.name]=\\\\\"name\\\\\" [attr.aria-label]=\\\\\"ariaLabel\\\\\" [attr.aria-labelledby]=\\\\\"ariaLabelledby\\\\\" (change)=\\\\\"_onChangeEvent($event)\\\\\" (click)=\\\\\"_onInputClick($event)\\\\\"> <div class=\\\\\"mat-slide-toggle-thumb-container\\\\\" (slidestart)=\\\\\"_onDragStart()\\\\\" (slide)=\\\\\"_onDrag($event)\\\\\" (slideend)=\\\\\"_onDragEnd()\\\\\"> <div class=\\\\\"mat-slide-toggle-thumb\\\\\"></div> <div class=\\\\\"mat-slide-toggle-ripple\\\\\" md-ripple [mdRippleTrigger]=\\\\\"label\\\\\" [mdRippleCentered]=\\\\\"true\\\\\" [mdRippleDisabled]=\\\\\"disableRipple || disabled\\\\\"> </div> </div> </div> <span class=\\\\\"mat-slide-toggle-content\\\\\"> <ng-content></ng-content> </span> </label> \",\\n                styles: [\".mat-slide-toggle{display:inline-block;height:24px;line-height:24px;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px,0,0)}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-content{font-size:14px;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;font-weight:500}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;cursor:pointer}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}.mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-right:8px;margin-left:0}.mat-slide-toggle-label-before .mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0,0,0);transition:all 80ms linear;transition-property:transform;cursor:-webkit-grab;cursor:grab}.mat-slide-toggle-thumb-container.mat-dragging,.mat-slide-toggle-thumb-container:active{cursor:-webkit-grabbing;cursor:grabbing;transition-duration:0s}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%;box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-slide-toggle-thumb{background:#fff;border:solid 1px #000}}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;border-radius:8px}@media screen and (-ms-high-contrast:active){.mat-slide-toggle-bar{background:#fff}}.mat-slide-toggle-input{bottom:0;left:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}.mat-slide-toggle-ripple{position:absolute;top:-13px;left:-13px;height:46px;width:46px;border-radius:50%;z-index:1;pointer-events:none} /*# sourceMappingURL=slide-toggle.css.map */ \"],\\n                providers: [MD_SLIDE_TOGGLE_VALUE_ACCESSOR],\\n                inputs: [\\'disabled\\'],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSlideToggle.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: FocusOriginMonitor, },\\n]; };\\nMdSlideToggle.propDecorators = {\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'tabIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'labelPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'ariaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'ariaLabelledby\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-labelledby\\',] },],\\n    \\'required\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'_inputElement\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'input\\',] },],\\n    \\'_ripple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdRipple,] },],\\n    \\'checked\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Renderer for the Slide Toggle component, which separates DOM modification in its own class\\n */\\nvar SlideToggleRenderer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     */\\n    function SlideToggleRenderer(_elementRef) {\\n        this._elementRef = _elementRef;\\n        /**\\n         * Whether the thumb is currently being dragged.\\n         */\\n        this.dragging = false;\\n        this._thumbEl = _elementRef.nativeElement.querySelector(\\'.mat-slide-toggle-thumb-container\\');\\n        this._thumbBarEl = _elementRef.nativeElement.querySelector(\\'.mat-slide-toggle-bar\\');\\n    }\\n    /**\\n     * Initializes the drag of the slide-toggle.\\n     * @param {?} checked\\n     * @return {?}\\n     */\\n    SlideToggleRenderer.prototype.startThumbDrag = function (checked) {\\n        if (this.dragging) {\\n            return;\\n        }\\n        this._thumbBarWidth = this._thumbBarEl.clientWidth - this._thumbEl.clientWidth;\\n        this._thumbEl.classList.add(\\'mat-dragging\\');\\n        this._previousChecked = checked;\\n        this.dragging = true;\\n    };\\n    /**\\n     * Resets the current drag and returns the new checked value.\\n     * @return {?}\\n     */\\n    SlideToggleRenderer.prototype.stopThumbDrag = function () {\\n        if (!this.dragging) {\\n            return;\\n        }\\n        this.dragging = false;\\n        this._thumbEl.classList.remove(\\'mat-dragging\\');\\n        // Reset the transform because the component will take care of the thumb position after drag.\\n        applyCssTransform(this._thumbEl, \\'\\');\\n        return this.dragPercentage > 50;\\n    };\\n    /**\\n     * Updates the thumb containers position from the specified distance.\\n     * @param {?} distance\\n     * @return {?}\\n     */\\n    SlideToggleRenderer.prototype.updateThumbPosition = function (distance) {\\n        this.dragPercentage = this._getDragPercentage(distance);\\n        // Calculate the moved distance based on the thumb bar width.\\n        var /** @type {?} */ dragX = (this.dragPercentage / 100) * this._thumbBarWidth;\\n        applyCssTransform(this._thumbEl, \"translate3d(\" + dragX + \"px, 0, 0)\");\\n    };\\n    /**\\n     * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.\\n     * @param {?} distance\\n     * @return {?}\\n     */\\n    SlideToggleRenderer.prototype._getDragPercentage = function (distance) {\\n        var /** @type {?} */ percentage = (distance / this._thumbBarWidth) * 100;\\n        // When the toggle was initially checked, then we have to start the drag at the end.\\n        if (this._previousChecked) {\\n            percentage += 100;\\n        }\\n        return Math.max(0, Math.min(percentage, 100));\\n    };\\n    return SlideToggleRenderer;\\n}());\\nvar MdSlideToggleModule = /*@__PURE__*/(function () {\\n    function MdSlideToggleModule() {\\n    }\\n    return MdSlideToggleModule;\\n}());\\nMdSlideToggleModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"FormsModule\"], MdRippleModule, MdCommonModule],\\n                exports: [MdSlideToggle, MdCommonModule],\\n                declarations: [MdSlideToggle],\\n                providers: [\\n                    FOCUS_ORIGIN_MONITOR_PROVIDER,\\n                    { provide: __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__[\"HAMMER_GESTURE_CONFIG\"], useClass: GestureConfig }\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSlideToggleModule.ctorParameters = function () { return []; };\\n/**\\n * Visually, a 30px separation between tick marks looks best. This is very subjective but it is\\n * the default separation we chose.\\n */\\nvar MIN_AUTO_TICK_SEPARATION = 30;\\n/**\\n * The thumb gap size for a disabled slider.\\n */\\nvar DISABLED_THUMB_GAP = 7;\\n/**\\n * The thumb gap size for a non-active slider at its minimum value.\\n */\\nvar MIN_VALUE_NONACTIVE_THUMB_GAP = 7;\\n/**\\n * The thumb gap size for an active slider at its minimum value.\\n */\\nvar MIN_VALUE_ACTIVE_THUMB_GAP = 10;\\n/**\\n * Provider Expression that allows md-slider to register as a ControlValueAccessor.\\n * This allows it to support [(ngModel)] and [formControl].\\n */\\nvar MD_SLIDER_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"])(function () { return MdSlider; }),\\n    multi: true\\n};\\n/**\\n * A simple change event emitted by the MdSlider component.\\n */\\nvar MdSliderChange = /*@__PURE__*/(function () {\\n    function MdSliderChange() {\\n    }\\n    return MdSliderChange;\\n}());\\nvar MdSliderBase = /*@__PURE__*/(function () {\\n    function MdSliderBase() {\\n    }\\n    return MdSliderBase;\\n}());\\nvar _MdSliderMixinBase = mixinDisabled(MdSliderBase);\\n/**\\n * Allows users to select from a range of values by moving the slider thumb. It is similar in\\n * behavior to the native `<input type=\"range\">` element.\\n */\\nvar MdSlider = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdSlider, _super);\\n    /**\\n     * @param {?} renderer\\n     * @param {?} _elementRef\\n     * @param {?} _focusOriginMonitor\\n     * @param {?} _dir\\n     */\\n    function MdSlider(renderer, _elementRef, _focusOriginMonitor, _dir) {\\n        var _this = _super.call(this) || this;\\n        _this._elementRef = _elementRef;\\n        _this._focusOriginMonitor = _focusOriginMonitor;\\n        _this._dir = _dir;\\n        _this._invert = false;\\n        _this._max = 100;\\n        _this._min = 0;\\n        _this._step = 1;\\n        _this._thumbLabel = false;\\n        _this._tickInterval = 0;\\n        _this._value = null;\\n        _this._vertical = false;\\n        _this.color = \\'accent\\';\\n        /**\\n         * Event emitted when the slider value has changed.\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the slider thumb moves.\\n         */\\n        _this.input = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\\n         */\\n        _this.onTouched = function () { };\\n        _this._percent = 0;\\n        /**\\n         * Whether or not the thumb is sliding.\\n         * Used to determine if there should be a transition for the thumb and fill track.\\n         */\\n        _this._isSliding = false;\\n        /**\\n         * Whether or not the slider is active (clicked or sliding).\\n         * Used to shrink and grow the thumb as according to the Material Design spec.\\n         */\\n        _this._isActive = false;\\n        /**\\n         * The size of a tick interval as a percentage of the size of the track.\\n         */\\n        _this._tickIntervalPercent = 0;\\n        /**\\n         * A renderer to handle updating the slider\\'s thumb and fill track.\\n         */\\n        _this._renderer = null;\\n        /**\\n         * The dimensions of the slider.\\n         */\\n        _this._sliderDimensions = null;\\n        _this._controlValueAccessorChangeFn = function () { };\\n        /**\\n         * The last value for which a change event was emitted.\\n         */\\n        _this._lastChangeValue = null;\\n        /**\\n         * The last value for which an input event was emitted.\\n         */\\n        _this._lastInputValue = null;\\n        _this._focusOriginMonitor.monitor(_this._elementRef.nativeElement, renderer, true)\\n            .subscribe(function (origin) { return _this._isActive = !!origin && origin !== \\'keyboard\\'; });\\n        _this._renderer = new SliderRenderer(_this._elementRef);\\n        return _this;\\n    }\\n    Object.defineProperty(MdSlider.prototype, \"invert\", {\\n        /**\\n         * Whether the slider is inverted.\\n         * @return {?}\\n         */\\n        get: function () { return this._invert; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._invert = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"max\", {\\n        /**\\n         * The maximum value that the slider can have.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._max;\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._max = coerceNumberProperty(v, this._max);\\n            this._percent = this._calculatePercentage(this._value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"min\", {\\n        /**\\n         * The minimum value that the slider can have.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._min;\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._min = coerceNumberProperty(v, this._min);\\n            // If the value wasn\\'t explicitly set by the user, set it to the min.\\n            if (this._value === null) {\\n                this.value = this._min;\\n            }\\n            this._percent = this._calculatePercentage(this._value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"step\", {\\n        /**\\n         * The values at which the thumb will snap.\\n         * @return {?}\\n         */\\n        get: function () { return this._step; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._step = coerceNumberProperty(v, this._step);\\n            if (this._step % 1 !== 0) {\\n                this._roundLabelTo = this._step.toString().split(\\'.\\').pop().length;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"thumbLabel\", {\\n        /**\\n         * Whether or not to show the thumb label.\\n         * @return {?}\\n         */\\n        get: function () { return this._thumbLabel; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._thumbLabel = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_thumbLabelDeprecated\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this._thumbLabel; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._thumbLabel = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"tickInterval\", {\\n        /**\\n         * How often to show ticks. Relative to the step so that a tick always appears on a step.\\n         * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).\\n         * @return {?}\\n         */\\n        get: function () { return this._tickInterval; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value === \\'auto\\') {\\n                this._tickInterval = \\'auto\\';\\n            }\\n            else if (typeof value === \\'number\\' || typeof value === \\'string\\') {\\n                this._tickInterval = coerceNumberProperty(value, /** @type {?} */ (this._tickInterval));\\n            }\\n            else {\\n                this._tickInterval = 0;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_tickIntervalDeprecated\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this.tickInterval; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.tickInterval = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"value\", {\\n        /**\\n         * Value of the slider.\\n         * @return {?}\\n         */\\n        get: function () {\\n            // If the value needs to be read and it is still uninitialized, initialize it to the min.\\n            if (this._value === null) {\\n                this.value = this._min;\\n            }\\n            return this._value;\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._value = coerceNumberProperty(v, this._value);\\n            this._percent = this._calculatePercentage(this._value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"vertical\", {\\n        /**\\n         * Whether the slider is vertical.\\n         * @return {?}\\n         */\\n        get: function () { return this._vertical; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._vertical = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"displayValue\", {\\n        /**\\n         * The value to be used for display purposes.\\n         * @return {?}\\n         */\\n        get: function () {\\n            // Note that this could be improved further by rounding something like 0.999 to 1 or\\n            // 0.899 to 0.9, however it is very performance sensitive, because it gets called on\\n            // every change detection cycle.\\n            if (this._roundLabelTo && this.value % 1 !== 0) {\\n                return this.value.toFixed(this._roundLabelTo);\\n            }\\n            return this.value;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"percent\", {\\n        /**\\n         * The percentage of the slider that coincides with the value.\\n         * @return {?}\\n         */\\n        get: function () { return this._clamp(this._percent); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_invertAxis\", {\\n        /**\\n         * Whether the axis of the slider is inverted.\\n         * (i.e. whether moving the thumb in the positive x or y direction decreases the slider\\'s value).\\n         * @return {?}\\n         */\\n        get: function () {\\n            // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to\\n            // top. However from a y-axis standpoint this is inverted.\\n            return this.vertical ? !this.invert : this.invert;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_isMinValue\", {\\n        /**\\n         * Whether the slider is at its minimum value.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.percent === 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_thumbGap\", {\\n        /**\\n         * The amount of space to leave between the slider thumb and the track fill & track background\\n         * elements.\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (this.disabled) {\\n                return DISABLED_THUMB_GAP;\\n            }\\n            if (this._isMinValue && !this.thumbLabel) {\\n                return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;\\n            }\\n            return 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_trackBackgroundStyles\", {\\n        /**\\n         * CSS styles for the track background element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ axis = this.vertical ? \\'Y\\' : \\'X\\';\\n            var /** @type {?} */ sign = this._invertMouseCoords ? \\'-\\' : \\'\\';\\n            return {\\n                \\'transform\\': \"translate\" + axis + \"(\" + sign + this._thumbGap + \"px) scale\" + axis + \"(\" + (1 - this.percent) + \")\"\\n            };\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_trackFillStyles\", {\\n        /**\\n         * CSS styles for the track fill element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ axis = this.vertical ? \\'Y\\' : \\'X\\';\\n            var /** @type {?} */ sign = this._invertMouseCoords ? \\'\\' : \\'-\\';\\n            return {\\n                \\'transform\\': \"translate\" + axis + \"(\" + sign + this._thumbGap + \"px) scale\" + axis + \"(\" + this.percent + \")\"\\n            };\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_ticksContainerStyles\", {\\n        /**\\n         * CSS styles for the ticks container element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ axis = this.vertical ? \\'Y\\' : \\'X\\';\\n            // For a horizontal slider in RTL languages we push the ticks container off the left edge\\n            // instead of the right edge to avoid causing a horizontal scrollbar to appear.\\n            var /** @type {?} */ sign = !this.vertical && this._direction == \\'rtl\\' ? \\'\\' : \\'-\\';\\n            var /** @type {?} */ offset = this._tickIntervalPercent / 2 * 100;\\n            return {\\n                \\'transform\\': \"translate\" + axis + \"(\" + sign + offset + \"%)\"\\n            };\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_ticksStyles\", {\\n        /**\\n         * CSS styles for the ticks element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ tickSize = this._tickIntervalPercent * 100;\\n            var /** @type {?} */ backgroundSize = this.vertical ? \"2px \" + tickSize + \"%\" : tickSize + \"% 2px\";\\n            var /** @type {?} */ axis = this.vertical ? \\'Y\\' : \\'X\\';\\n            // Depending on the direction we pushed the ticks container, push the ticks the opposite\\n            // direction to re-center them but clip off the end edge. In RTL languages we need to flip the\\n            // ticks 180 degrees so we\\'re really cutting off the end edge abd not the start.\\n            var /** @type {?} */ sign = !this.vertical && this._direction == \\'rtl\\' ? \\'-\\' : \\'\\';\\n            var /** @type {?} */ rotate = !this.vertical && this._direction == \\'rtl\\' ? \\' rotate(180deg)\\' : \\'\\';\\n            var /** @type {?} */ styles = {\\n                \\'backgroundSize\\': backgroundSize,\\n                // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.\\n                \\'transform\\': \"translateZ(0) translate\" + axis + \"(\" + sign + tickSize / 2 + \"%)\" + rotate\\n            };\\n            if (this._isMinValue && this._thumbGap) {\\n                var /** @type {?} */ side = this.vertical ?\\n                    (this._invertAxis ? \\'Bottom\\' : \\'Top\\') :\\n                    (this._invertAxis ? \\'Right\\' : \\'Left\\');\\n                styles[\"padding\" + side] = this._thumbGap + \"px\";\\n            }\\n            return styles;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_thumbContainerStyles\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ axis = this.vertical ? \\'Y\\' : \\'X\\';\\n            // For a horizontal slider in RTL languages we push the thumb container off the left edge\\n            // instead of the right edge to avoid causing a horizontal scrollbar to appear.\\n            var /** @type {?} */ invertOffset = (this._direction == \\'rtl\\' && !this.vertical) ? !this._invertAxis : this._invertAxis;\\n            var /** @type {?} */ offset = (invertOffset ? this.percent : 1 - this.percent) * 100;\\n            return {\\n                \\'transform\\': \"translate\" + axis + \"(-\" + offset + \"%)\"\\n            };\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_invertMouseCoords\", {\\n        /**\\n         * Whether mouse events should be converted to a slider position by calculating their distance\\n         * from the right or bottom edge of the slider as opposed to the top or left.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return (this._direction == \\'rtl\\' && !this.vertical) ? !this._invertAxis : this._invertAxis;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_direction\", {\\n        /**\\n         * The language direction for this slider element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return (this._dir && this._dir.value == \\'rtl\\') ? \\'rtl\\' : \\'ltr\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._elementRef.nativeElement);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onMouseenter = function () {\\n        if (this.disabled) {\\n            return;\\n        }\\n        // We save the dimensions of the slider here so we can use them to update the spacing of the\\n        // ticks and determine where on the slider click and slide events happen.\\n        this._sliderDimensions = this._renderer.getSliderDimensions();\\n        this._updateTickIntervalPercent();\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onClick = function (event) {\\n        if (this.disabled) {\\n            return;\\n        }\\n        this._isSliding = false;\\n        this._renderer.addFocus();\\n        this._updateValueFromPosition({ x: event.clientX, y: event.clientY });\\n        /* Emits a change and input event if the value changed. */\\n        this._emitInputEvent();\\n        this._emitValueIfChanged();\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onSlide = function (event) {\\n        if (this.disabled) {\\n            return;\\n        }\\n        // Prevent the slide from selecting anything else.\\n        event.preventDefault();\\n        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });\\n        // Native range elements always emit `input` events when the value changed while sliding.\\n        this._emitInputEvent();\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onSlideStart = function (event) {\\n        if (this.disabled) {\\n            return;\\n        }\\n        // Simulate mouseenter in case this is a mobile device.\\n        this._onMouseenter();\\n        event.preventDefault();\\n        this._isSliding = true;\\n        this._renderer.addFocus();\\n        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onSlideEnd = function () {\\n        this._isSliding = false;\\n        this._emitValueIfChanged();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onFocus = function () {\\n        // We save the dimensions of the slider here so we can use them to update the spacing of the\\n        // ticks and determine where on the slider click and slide events happen.\\n        this._sliderDimensions = this._renderer.getSliderDimensions();\\n        this._updateTickIntervalPercent();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onBlur = function () {\\n        this.onTouched();\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onKeydown = function (event) {\\n        if (this.disabled) {\\n            return;\\n        }\\n        switch (event.keyCode) {\\n            case PAGE_UP:\\n                this._increment(10);\\n                break;\\n            case PAGE_DOWN:\\n                this._increment(-10);\\n                break;\\n            case END:\\n                this.value = this.max;\\n                break;\\n            case HOME:\\n                this.value = this.min;\\n                break;\\n            case LEFT_ARROW:\\n                // NOTE: For a sighted user it would make more sense that when they press an arrow key on an\\n                // inverted slider the thumb moves in that direction. However for a blind user, nothing\\n                // about the slider indicates that it is inverted. They will expect left to be decrement,\\n                // regardless of how it appears on the screen. For speakers ofRTL languages, they probably\\n                // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for\\n                // RTL. For inverted sliders we prefer a good a11y experience to having it \"look right\" for\\n                // sighted users, therefore we do not swap the meaning.\\n                this._increment(this._direction == \\'rtl\\' ? 1 : -1);\\n                break;\\n            case UP_ARROW:\\n                this._increment(1);\\n                break;\\n            case RIGHT_ARROW:\\n                // See comment on LEFT_ARROW about the conditions under which we flip the meaning.\\n                this._increment(this._direction == \\'rtl\\' ? -1 : 1);\\n                break;\\n            case DOWN_ARROW:\\n                this._increment(-1);\\n                break;\\n            default:\\n                // Return if the key is not one that we explicitly handle to avoid calling preventDefault on\\n                // it.\\n                return;\\n        }\\n        this._isSliding = true;\\n        event.preventDefault();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onKeyup = function () {\\n        this._isSliding = false;\\n    };\\n    /**\\n     * Increments the slider by the given number of steps (negative number decrements).\\n     * @param {?} numSteps\\n     * @return {?}\\n     */\\n    MdSlider.prototype._increment = function (numSteps) {\\n        this.value = this._clamp(this.value + this.step * numSteps, this.min, this.max);\\n        this._emitInputEvent();\\n        this._emitValueIfChanged();\\n    };\\n    /**\\n     * Calculate the new value from the new physical location. The value will always be snapped.\\n     * @param {?} pos\\n     * @return {?}\\n     */\\n    MdSlider.prototype._updateValueFromPosition = function (pos) {\\n        if (!this._sliderDimensions) {\\n            return;\\n        }\\n        var /** @type {?} */ offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;\\n        var /** @type {?} */ size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;\\n        var /** @type {?} */ posComponent = this.vertical ? pos.y : pos.x;\\n        // The exact value is calculated from the event and used to find the closest snap value.\\n        var /** @type {?} */ percent = this._clamp((posComponent - offset) / size);\\n        if (this._invertMouseCoords) {\\n            percent = 1 - percent;\\n        }\\n        var /** @type {?} */ exactValue = this._calculateValue(percent);\\n        // This calculation finds the closest step by finding the closest whole number divisible by the\\n        // step relative to the min.\\n        var /** @type {?} */ closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;\\n        // The value needs to snap to the min and max.\\n        this.value = this._clamp(closestValue, this.min, this.max);\\n    };\\n    /**\\n     * Emits a change event if the current value is different from the last emitted value.\\n     * @return {?}\\n     */\\n    MdSlider.prototype._emitValueIfChanged = function () {\\n        if (this.value != this._lastChangeValue) {\\n            var /** @type {?} */ event = this._createChangeEvent();\\n            this._lastChangeValue = this.value;\\n            this._controlValueAccessorChangeFn(this.value);\\n            this.change.emit(event);\\n        }\\n    };\\n    /**\\n     * Emits an input event when the current value is different from the last emitted value.\\n     * @return {?}\\n     */\\n    MdSlider.prototype._emitInputEvent = function () {\\n        if (this.value != this._lastInputValue) {\\n            var /** @type {?} */ event = this._createChangeEvent();\\n            this._lastInputValue = this.value;\\n            this.input.emit(event);\\n        }\\n    };\\n    /**\\n     * Updates the amount of space between ticks as a percentage of the width of the slider.\\n     * @return {?}\\n     */\\n    MdSlider.prototype._updateTickIntervalPercent = function () {\\n        if (!this.tickInterval) {\\n            return;\\n        }\\n        if (this.tickInterval == \\'auto\\') {\\n            var /** @type {?} */ trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;\\n            var /** @type {?} */ pixelsPerStep = trackSize * this.step / (this.max - this.min);\\n            var /** @type {?} */ stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);\\n            var /** @type {?} */ pixelsPerTick = stepsPerTick * this.step;\\n            this._tickIntervalPercent = pixelsPerTick / trackSize;\\n        }\\n        else {\\n            this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);\\n        }\\n    };\\n    /**\\n     * Creates a slider change object from the specified value.\\n     * @param {?=} value\\n     * @return {?}\\n     */\\n    MdSlider.prototype._createChangeEvent = function (value) {\\n        if (value === void 0) { value = this.value; }\\n        var /** @type {?} */ event = new MdSliderChange();\\n        event.source = this;\\n        event.value = value;\\n        return event;\\n    };\\n    /**\\n     * Calculates the percentage of the slider that a value is.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdSlider.prototype._calculatePercentage = function (value) {\\n        return (value - this.min) / (this.max - this.min);\\n    };\\n    /**\\n     * Calculates the value a percentage of the slider corresponds to.\\n     * @param {?} percentage\\n     * @return {?}\\n     */\\n    MdSlider.prototype._calculateValue = function (percentage) {\\n        return this.min + percentage * (this.max - this.min);\\n    };\\n    /**\\n     * Return a number between two numbers.\\n     * @param {?} value\\n     * @param {?=} min\\n     * @param {?=} max\\n     * @return {?}\\n     */\\n    MdSlider.prototype._clamp = function (value, min, max) {\\n        if (min === void 0) { min = 0; }\\n        if (max === void 0) { max = 1; }\\n        return Math.max(min, Math.min(value, max));\\n    };\\n    /**\\n     * Sets the model value. Implemented as part of ControlValueAccessor.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdSlider.prototype.writeValue = function (value) {\\n        this.value = value;\\n    };\\n    /**\\n     * Registers a callback to eb triggered when the value has changed.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Callback to be registered.\\n     * @return {?}\\n     */\\n    MdSlider.prototype.registerOnChange = function (fn) {\\n        this._controlValueAccessorChangeFn = fn;\\n    };\\n    /**\\n     * Registers a callback to be triggered when the component is touched.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Callback to be registered.\\n     * @return {?}\\n     */\\n    MdSlider.prototype.registerOnTouched = function (fn) {\\n        this.onTouched = fn;\\n    };\\n    /**\\n     * Sets whether the component should be disabled.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} isDisabled\\n     * @return {?}\\n     */\\n    MdSlider.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n    };\\n    return MdSlider;\\n}(_MdSliderMixinBase));\\nMdSlider.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-slider, mat-slider\\',\\n                providers: [MD_SLIDER_VALUE_ACCESSOR],\\n                host: {\\n                    \\'(focus)\\': \\'_onFocus()\\',\\n                    \\'(blur)\\': \\'_onBlur()\\',\\n                    \\'(click)\\': \\'_onClick($event)\\',\\n                    \\'(keydown)\\': \\'_onKeydown($event)\\',\\n                    \\'(keyup)\\': \\'_onKeyup()\\',\\n                    \\'(mouseenter)\\': \\'_onMouseenter()\\',\\n                    \\'(slide)\\': \\'_onSlide($event)\\',\\n                    \\'(slideend)\\': \\'_onSlideEnd()\\',\\n                    \\'(slidestart)\\': \\'_onSlideStart($event)\\',\\n                    \\'class\\': \\'mat-slider\\',\\n                    \\'role\\': \\'slider\\',\\n                    \\'tabindex\\': \\'0\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled\\',\\n                    \\'[attr.aria-valuemax]\\': \\'max\\',\\n                    \\'[attr.aria-valuemin]\\': \\'min\\',\\n                    \\'[attr.aria-valuenow]\\': \\'value\\',\\n                    \\'[attr.aria-orientation]\\': \\'vertical ? \"vertical\" : \"horizontal\"\\',\\n                    \\'[class.mat-primary]\\': \\'color == \"primary\"\\',\\n                    \\'[class.mat-accent]\\': \\'color != \"primary\" && color != \"warn\"\\',\\n                    \\'[class.mat-warn]\\': \\'color == \"warn\"\\',\\n                    \\'[class.mat-slider-disabled]\\': \\'disabled\\',\\n                    \\'[class.mat-slider-has-ticks]\\': \\'tickInterval\\',\\n                    \\'[class.mat-slider-horizontal]\\': \\'!vertical\\',\\n                    \\'[class.mat-slider-axis-inverted]\\': \\'_invertAxis\\',\\n                    \\'[class.mat-slider-sliding]\\': \\'_isSliding\\',\\n                    \\'[class.mat-slider-thumb-label-showing]\\': \\'thumbLabel\\',\\n                    \\'[class.mat-slider-vertical]\\': \\'vertical\\',\\n                    \\'[class.mat-slider-min-value]\\': \\'_isMinValue\\',\\n                    \\'[class.mat-slider-hide-last-tick]\\': \\'disabled || _isMinValue && _thumbGap && _invertAxis\\',\\n                },\\n                template: \"<div class=\\\\\"mat-slider-wrapper\\\\\"> <div class=\\\\\"mat-slider-track-wrapper\\\\\"> <div class=\\\\\"mat-slider-track-background\\\\\" [ngStyle]=\\\\\"_trackBackgroundStyles\\\\\"></div> <div class=\\\\\"mat-slider-track-fill\\\\\" [ngStyle]=\\\\\"_trackFillStyles\\\\\"></div> </div> <div class=\\\\\"mat-slider-ticks-container\\\\\" [ngStyle]=\\\\\"_ticksContainerStyles\\\\\"> <div class=\\\\\"mat-slider-ticks\\\\\" [ngStyle]=\\\\\"_ticksStyles\\\\\"></div> </div> <div class=\\\\\"mat-slider-thumb-container\\\\\" [ngStyle]=\\\\\"_thumbContainerStyles\\\\\"> <div class=\\\\\"mat-slider-focus-ring\\\\\"></div> <div class=\\\\\"mat-slider-thumb\\\\\"></div> <div class=\\\\\"mat-slider-thumb-label\\\\\"> <span class=\\\\\"mat-slider-thumb-label-text\\\\\">{{displayValue}}</span> </div> </div> </div> \",\\n                styles: [\".mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:0;vertical-align:middle}.mat-slider-wrapper{position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{background-repeat:repeat;background-clip:content-box;box-sizing:border-box;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),opacity .4s cubic-bezier(.25,.8,.25,1)}.cdk-keyboard-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb-label{cursor:-webkit-grab;cursor:grab}.mat-slider-sliding:not(.mat-slider-disabled) .mat-slider-thumb,.mat-slider-sliding:not(.mat-slider-disabled) .mat-slider-thumb-label,.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb-label:active,.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb:active{cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(.7);transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),border-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform .4s cubic-bezier(.25,.8,.25,1),border-radius .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label-text{z-index:1;font-size:12px;font-weight:700;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-sliding .mat-slider-thumb-container,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-track-fill{transition-duration:0s}.mat-slider-has-ticks .mat-slider-wrapper::after{content:\\'\\';position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.cdk-focused .mat-slider-thumb-label-text{opacity:1}.cdk-mouse-focused .mat-slider-thumb,.cdk-program-focused .mat-slider-thumb,.cdk-touch-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%} /*# sourceMappingURL=slider.css.map */ \"],\\n                inputs: [\\'disabled\\'],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSlider.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusOriginMonitor, },\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdSlider.propDecorators = {\\n    \\'invert\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'max\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'min\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'step\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'thumbLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_thumbLabelDeprecated\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'thumb-label\\',] },],\\n    \\'tickInterval\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_tickIntervalDeprecated\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'tick-interval\\',] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'vertical\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'input\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Renderer class in order to keep all dom manipulation in one place and outside of the main class.\\n * \\\\@docs-private\\n */\\nvar SliderRenderer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementRef\\n     */\\n    function SliderRenderer(elementRef) {\\n        this._sliderElement = elementRef.nativeElement;\\n    }\\n    /**\\n     * Get the bounding client rect of the slider track element.\\n     * The track is used rather than the native element to ignore the extra space that the thumb can\\n     * take up.\\n     * @return {?}\\n     */\\n    SliderRenderer.prototype.getSliderDimensions = function () {\\n        var /** @type {?} */ wrapperElement = this._sliderElement.querySelector(\\'.mat-slider-wrapper\\');\\n        return wrapperElement.getBoundingClientRect();\\n    };\\n    /**\\n     * Focuses the native element.\\n     * Currently only used to allow a blur event to fire but will be used with keyboard input later.\\n     * @return {?}\\n     */\\n    SliderRenderer.prototype.addFocus = function () {\\n        this._sliderElement.focus();\\n    };\\n    return SliderRenderer;\\n}());\\nvar MdSliderModule = /*@__PURE__*/(function () {\\n    function MdSliderModule() {\\n    }\\n    return MdSliderModule;\\n}());\\nMdSliderModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"], __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"FormsModule\"], MdCommonModule, StyleModule, RtlModule],\\n                exports: [MdSlider, MdCommonModule],\\n                declarations: [MdSlider],\\n                providers: [{ provide: __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__[\"HAMMER_GESTURE_CONFIG\"], useClass: GestureConfig }]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSliderModule.ctorParameters = function () { return []; };\\n/**\\n * Throws an exception when two MdSidenav are matching the same side.\\n * @param {?} align\\n * @return {?}\\n */\\nfunction throwMdDuplicatedSidenavError(align) {\\n    throw new Error(\"A sidenav was already declared for \\'align=\\\\\"\" + align + \"\\\\\"\\'\");\\n}\\n/**\\n * Sidenav toggle promise result.\\n */\\nvar MdSidenavToggleResult = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} type\\n     * @param {?} animationFinished\\n     */\\n    function MdSidenavToggleResult(type, animationFinished) {\\n        this.type = type;\\n        this.animationFinished = animationFinished;\\n    }\\n    return MdSidenavToggleResult;\\n}());\\n/**\\n * <md-sidenav> component.\\n *\\n * This component corresponds to the drawer of the sidenav.\\n *\\n * Please refer to README.md for examples on how to use it.\\n */\\nvar MdSidenav = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef The DOM element reference. Used for transition and width calculation.\\n     *     If not available we do not hook on transitions.\\n     * @param {?} _focusTrapFactory\\n     */\\n    function MdSidenav(_elementRef, _focusTrapFactory) {\\n        var _this = this;\\n        this._elementRef = _elementRef;\\n        this._focusTrapFactory = _focusTrapFactory;\\n        /**\\n         * Alignment of the sidenav (direction neutral); whether \\'start\\' or \\'end\\'.\\n         */\\n        this._align = \\'start\\';\\n        /**\\n         * Mode of the sidenav; one of \\'over\\', \\'push\\' or \\'side\\'.\\n         */\\n        this.mode = \\'over\\';\\n        this._disableClose = false;\\n        /**\\n         * Whether the sidenav is opened.\\n         */\\n        this._opened = false;\\n        /**\\n         * Event emitted when the sidenav is being opened. Use this to synchronize animations.\\n         */\\n        this.onOpenStart = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the sidenav is fully opened.\\n         */\\n        this.onOpen = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the sidenav is being closed. Use this to synchronize animations.\\n         */\\n        this.onCloseStart = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the sidenav is fully closed.\\n         */\\n        this.onClose = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the sidenav alignment changes.\\n         */\\n        this.onAlignChanged = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * The current toggle animation promise. `null` if no animation is in progress.\\n         */\\n        this._toggleAnimationPromise = null;\\n        /**\\n         * The current toggle animation promise resolution function.\\n         * `null` if no animation is in progress.\\n         */\\n        this._resolveToggleAnimationPromise = null;\\n        this._elementFocusedBeforeSidenavWasOpened = null;\\n        this.onOpen.subscribe(function () {\\n            _this._elementFocusedBeforeSidenavWasOpened = document.activeElement;\\n            if (_this.isFocusTrapEnabled && _this._focusTrap) {\\n                _this._focusTrap.focusInitialElementWhenReady();\\n            }\\n        });\\n        this.onClose.subscribe(function () {\\n            if (_this._elementFocusedBeforeSidenavWasOpened instanceof HTMLElement) {\\n                _this._elementFocusedBeforeSidenavWasOpened.focus();\\n            }\\n            else {\\n                _this._elementRef.nativeElement.blur();\\n            }\\n            _this._elementFocusedBeforeSidenavWasOpened = null;\\n        });\\n    }\\n    Object.defineProperty(MdSidenav.prototype, \"align\", {\\n        /**\\n         * Direction which the sidenav is aligned in.\\n         * @return {?}\\n         */\\n        get: function () { return this._align; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            // Make sure we have a valid value.\\n            value = (value == \\'end\\') ? \\'end\\' : \\'start\\';\\n            if (value != this._align) {\\n                this._align = value;\\n                this.onAlignChanged.emit();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"disableClose\", {\\n        /**\\n         * Whether the sidenav can be closed with the escape key or not.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableClose; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableClose = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"isFocusTrapEnabled\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            // The focus trap is only enabled when the sidenav is open in any mode other than side.\\n            return this.opened && this.mode !== \\'side\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenav.prototype.ngAfterContentInit = function () {\\n        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\\n        this._focusTrap.enabled = this.isFocusTrapEnabled;\\n        // This can happen when the sidenav is set to opened in\\n        // the template and the transition hasn\\'t ended.\\n        if (this._toggleAnimationPromise) {\\n            this._resolveToggleAnimationPromise(true);\\n            this._toggleAnimationPromise = this._resolveToggleAnimationPromise = null;\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenav.prototype.ngOnDestroy = function () {\\n        if (this._focusTrap) {\\n            this._focusTrap.destroy();\\n        }\\n    };\\n    Object.defineProperty(MdSidenav.prototype, \"opened\", {\\n        /**\\n         * Whether the sidenav is opened. We overload this because we trigger an event when it\\n         * starts or end.\\n         * @return {?}\\n         */\\n        get: function () { return this._opened; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this.toggle(coerceBooleanProperty(v));\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Open this sidenav, and return a Promise that will resolve when it\\'s fully opened (or get\\n     * rejected if it didn\\'t).\\n     * @return {?}\\n     */\\n    MdSidenav.prototype.open = function () {\\n        return this.toggle(true);\\n    };\\n    /**\\n     * Close this sidenav, and return a Promise that will resolve when it\\'s fully closed (or get\\n     * rejected if it didn\\'t).\\n     * @return {?}\\n     */\\n    MdSidenav.prototype.close = function () {\\n        return this.toggle(false);\\n    };\\n    /**\\n     * Toggle this sidenav. This is equivalent to calling open() when it\\'s already opened, or\\n     * close() when it\\'s closed.\\n     * @param {?=} isOpen Whether the sidenav should be open.\\n     * @return {?} Resolves with the result of whether the sidenav was opened or closed.\\n     */\\n    MdSidenav.prototype.toggle = function (isOpen) {\\n        var _this = this;\\n        if (isOpen === void 0) { isOpen = !this.opened; }\\n        // Shortcut it if we\\'re already opened.\\n        if (isOpen === this.opened) {\\n            return this._toggleAnimationPromise ||\\n                Promise.resolve(new MdSidenavToggleResult(isOpen ? \\'open\\' : \\'close\\', true));\\n        }\\n        this._opened = isOpen;\\n        if (this._focusTrap) {\\n            this._focusTrap.enabled = this.isFocusTrapEnabled;\\n        }\\n        if (isOpen) {\\n            this.onOpenStart.emit();\\n        }\\n        else {\\n            this.onCloseStart.emit();\\n        }\\n        if (this._toggleAnimationPromise) {\\n            this._resolveToggleAnimationPromise(false);\\n        }\\n        this._toggleAnimationPromise = new Promise(function (resolve) {\\n            _this._resolveToggleAnimationPromise = function (animationFinished) { return resolve(new MdSidenavToggleResult(isOpen ? \\'open\\' : \\'close\\', animationFinished)); };\\n        });\\n        return this._toggleAnimationPromise;\\n    };\\n    /**\\n     * Handles the keyboard events.\\n     * \\\\@docs-private\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSidenav.prototype.handleKeydown = function (event) {\\n        if (event.keyCode === ESCAPE && !this.disableClose) {\\n            this.close();\\n            event.stopPropagation();\\n        }\\n    };\\n    /**\\n     * When transition has finished, set the internal state for classes and emit the proper event.\\n     * The event passed is actually of type TransitionEvent, but that type is not available in\\n     * Android so we use any.\\n     * @param {?} transitionEvent\\n     * @return {?}\\n     */\\n    MdSidenav.prototype._onTransitionEnd = function (transitionEvent) {\\n        if (transitionEvent.target == this._elementRef.nativeElement\\n            && transitionEvent.propertyName.endsWith(\\'transform\\')) {\\n            if (this._opened) {\\n                this.onOpen.emit();\\n            }\\n            else {\\n                this.onClose.emit();\\n            }\\n            if (this._toggleAnimationPromise) {\\n                this._resolveToggleAnimationPromise(true);\\n                this._toggleAnimationPromise = this._resolveToggleAnimationPromise = null;\\n            }\\n        }\\n    };\\n    Object.defineProperty(MdSidenav.prototype, \"_isClosing\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return !this._opened && !!this._toggleAnimationPromise;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_isOpening\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._opened && !!this._toggleAnimationPromise;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_isClosed\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return !this._opened && !this._toggleAnimationPromise;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_isOpened\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._opened && !this._toggleAnimationPromise;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_isEnd\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.align == \\'end\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_modeSide\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.mode == \\'side\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_modeOver\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.mode == \\'over\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_modePush\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.mode == \\'push\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_width\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (this._elementRef.nativeElement) {\\n                return this._elementRef.nativeElement.offsetWidth;\\n            }\\n            return 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return MdSidenav;\\n}());\\nMdSidenav.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-sidenav, mat-sidenav\\',\\n                // TODO(mmalerba): move template to separate file.\\n                template: \"<ng-content></ng-content> \",\\n                host: {\\n                    \\'[class.mat-sidenav]\\': \\'true\\',\\n                    \\'(transitionend)\\': \\'_onTransitionEnd($event)\\',\\n                    \\'(keydown)\\': \\'handleKeydown($event)\\',\\n                    // must prevent the browser from aligning text based on value\\n                    \\'[attr.align]\\': \\'null\\',\\n                    \\'[class.mat-sidenav-closed]\\': \\'_isClosed\\',\\n                    \\'[class.mat-sidenav-closing]\\': \\'_isClosing\\',\\n                    \\'[class.mat-sidenav-end]\\': \\'_isEnd\\',\\n                    \\'[class.mat-sidenav-opened]\\': \\'_isOpened\\',\\n                    \\'[class.mat-sidenav-opening]\\': \\'_isOpening\\',\\n                    \\'[class.mat-sidenav-over]\\': \\'_modeOver\\',\\n                    \\'[class.mat-sidenav-push]\\': \\'_modePush\\',\\n                    \\'[class.mat-sidenav-side]\\': \\'_modeSide\\',\\n                    \\'tabIndex\\': \\'-1\\'\\n                },\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSidenav.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusTrapFactory, },\\n]; };\\nMdSidenav.propDecorators = {\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'mode\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disableClose\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'onOpenStart\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'open-start\\',] },],\\n    \\'onOpen\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'open\\',] },],\\n    \\'onCloseStart\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'close-start\\',] },],\\n    \\'onClose\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'close\\',] },],\\n    \\'onAlignChanged\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'align-changed\\',] },],\\n    \\'opened\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * <md-sidenav-container> component.\\n *\\n * This is the parent component to one or two <md-sidenav>s that validates the state internally\\n * and coordinates the backdrop and content styling.\\n */\\nvar MdSidenavContainer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dir\\n     * @param {?} _element\\n     * @param {?} _renderer\\n     * @param {?} _ngZone\\n     */\\n    function MdSidenavContainer(_dir, _element, _renderer, _ngZone) {\\n        var _this = this;\\n        this._dir = _dir;\\n        this._element = _element;\\n        this._renderer = _renderer;\\n        this._ngZone = _ngZone;\\n        /**\\n         * Event emitted when the sidenav backdrop is clicked.\\n         */\\n        this.backdropClick = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Whether to enable open/close trantions.\\n         */\\n        this._enableTransitions = false;\\n        // If a `Dir` directive exists up the tree, listen direction changes and update the left/right\\n        // properties to point to the proper start/end.\\n        if (_dir != null) {\\n            _dir.dirChange.subscribe(function () { return _this._validateDrawers(); });\\n        }\\n    }\\n    Object.defineProperty(MdSidenavContainer.prototype, \"start\", {\\n        /**\\n         * The sidenav child with the `start` alignment.\\n         * @return {?}\\n         */\\n        get: function () { return this._start; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenavContainer.prototype, \"end\", {\\n        /**\\n         * The sidenav child with the `end` alignment.\\n         * @return {?}\\n         */\\n        get: function () { return this._end; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        // On changes, assert on consistency.\\n        this._sidenavs.changes.subscribe(function () { return _this._validateDrawers(); });\\n        this._sidenavs.forEach(function (sidenav) {\\n            _this._watchSidenavToggle(sidenav);\\n            _this._watchSidenavAlign(sidenav);\\n        });\\n        this._validateDrawers();\\n        // Give the view a chance to render the initial state, then enable transitions.\\n        this._ngZone.onMicrotaskEmpty.first().subscribe(function () { return _this._enableTransitions = true; });\\n    };\\n    /**\\n     * Calls `open` of both start and end sidenavs\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype.open = function () {\\n        return Promise.all([this._start, this._end].map(function (sidenav) { return sidenav && sidenav.open(); }));\\n    };\\n    /**\\n     * Calls `close` of both start and end sidenavs\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype.close = function () {\\n        return Promise.all([this._start, this._end].map(function (sidenav) { return sidenav && sidenav.close(); }));\\n    };\\n    /**\\n     * Subscribes to sidenav events in order to set a class on the main container element when the\\n     * sidenav is open and the backdrop is visible. This ensures any overflow on the container element\\n     * is properly hidden.\\n     * @param {?} sidenav\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._watchSidenavToggle = function (sidenav) {\\n        var _this = this;\\n        if (!sidenav || sidenav.mode === \\'side\\') {\\n            return;\\n        }\\n        sidenav.onOpen.subscribe(function () { return _this._setContainerClass(true); });\\n        sidenav.onClose.subscribe(function () { return _this._setContainerClass(false); });\\n    };\\n    /**\\n     * Subscribes to sidenav onAlignChanged event in order to re-validate drawers when the align\\n     * changes.\\n     * @param {?} sidenav\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._watchSidenavAlign = function (sidenav) {\\n        var _this = this;\\n        if (!sidenav) {\\n            return;\\n        }\\n        // NOTE: We need to wait for the microtask queue to be empty before validating,\\n        // since both drawers may be swapping sides at the same time.\\n        sidenav.onAlignChanged.subscribe(function () { return _this._ngZone.onMicrotaskEmpty.first().subscribe(function () { return _this._validateDrawers(); }); });\\n    };\\n    /**\\n     * Toggles the \\'mat-sidenav-opened\\' class on the main \\'md-sidenav-container\\' element.\\n     * @param {?} isAdd\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._setContainerClass = function (isAdd) {\\n        if (isAdd) {\\n            this._renderer.addClass(this._element.nativeElement, \\'mat-sidenav-opened\\');\\n        }\\n        else {\\n            this._renderer.removeClass(this._element.nativeElement, \\'mat-sidenav-opened\\');\\n        }\\n    };\\n    /**\\n     * Validate the state of the sidenav children components.\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._validateDrawers = function () {\\n        this._start = this._end = null;\\n        // Ensure that we have at most one start and one end sidenav.\\n        // NOTE: We must call toArray on _sidenavs even though it\\'s iterable\\n        // (see https://github.com/Microsoft/TypeScript/issues/3164).\\n        for (var _i = 0, _a = this._sidenavs.toArray(); _i < _a.length; _i++) {\\n            var sidenav = _a[_i];\\n            if (sidenav.align == \\'end\\') {\\n                if (this._end != null) {\\n                    throwMdDuplicatedSidenavError(\\'end\\');\\n                }\\n                this._end = sidenav;\\n            }\\n            else {\\n                if (this._start != null) {\\n                    throwMdDuplicatedSidenavError(\\'start\\');\\n                }\\n                this._start = sidenav;\\n            }\\n        }\\n        this._right = this._left = null;\\n        // Detect if we\\'re LTR or RTL.\\n        if (this._dir == null || this._dir.value == \\'ltr\\') {\\n            this._left = this._start;\\n            this._right = this._end;\\n        }\\n        else {\\n            this._left = this._end;\\n            this._right = this._start;\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._onBackdropClicked = function () {\\n        this.backdropClick.emit();\\n        this._closeModalSidenav();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._closeModalSidenav = function () {\\n        // Close all open sidenav\\'s where closing is not disabled and the mode is not `side`.\\n        [this._start, this._end]\\n            .filter(function (sidenav) { return sidenav && !sidenav.disableClose && sidenav.mode !== \\'side\\'; })\\n            .forEach(function (sidenav) { return sidenav.close(); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._isShowingBackdrop = function () {\\n        return (this._isSidenavOpen(this._start) && this._start.mode != \\'side\\')\\n            || (this._isSidenavOpen(this._end) && this._end.mode != \\'side\\');\\n    };\\n    /**\\n     * @param {?} side\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._isSidenavOpen = function (side) {\\n        return side != null && side.opened;\\n    };\\n    /**\\n     * Return the width of the sidenav, if it\\'s in the proper mode and opened.\\n     * This may relayout the view, so do not call this often.\\n     * @param {?} sidenav\\n     * @param {?} mode\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getSidenavEffectiveWidth = function (sidenav, mode) {\\n        return (this._isSidenavOpen(sidenav) && sidenav.mode == mode) ? sidenav._width : 0;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getMarginLeft = function () {\\n        return this._getSidenavEffectiveWidth(this._left, \\'side\\');\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getMarginRight = function () {\\n        return this._getSidenavEffectiveWidth(this._right, \\'side\\');\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getPositionLeft = function () {\\n        return this._getSidenavEffectiveWidth(this._left, \\'push\\');\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getPositionRight = function () {\\n        return this._getSidenavEffectiveWidth(this._right, \\'push\\');\\n    };\\n    /**\\n     * Returns the horizontal offset for the content area.  There should never be a value for both\\n     * left and right, so by subtracting the right value from the left value, we should always get\\n     * the appropriate offset.\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getPositionOffset = function () {\\n        return this._getPositionLeft() - this._getPositionRight();\\n    };\\n    /**\\n     * This is using [ngStyle] rather than separate [style...] properties because [style.transform]\\n     * doesn\\'t seem to work right now.\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getStyles = function () {\\n        return {\\n            marginLeft: this._getMarginLeft() + \"px\",\\n            marginRight: this._getMarginRight() + \"px\",\\n            transform: \"translate3d(\" + this._getPositionOffset() + \"px, 0, 0)\"\\n        };\\n    };\\n    return MdSidenavContainer;\\n}());\\nMdSidenavContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-sidenav-container, mat-sidenav-container\\',\\n                // Do not use ChangeDetectionStrategy.OnPush. It does not work for this component because\\n                // technically it is a sibling of MdSidenav (on the content tree) and isn\\'t updated when MdSidenav\\n                // changes its state.\\n                template: \"<div class=\\\\\"mat-sidenav-backdrop\\\\\" (click)=\\\\\"_onBackdropClicked()\\\\\" [class.mat-sidenav-shown]=\\\\\"_isShowingBackdrop()\\\\\"></div> <ng-content select=\\\\\"md-sidenav, mat-sidenav\\\\\"></ng-content> <div class=\\\\\"mat-sidenav-content\\\\\" [ngStyle]=\\\\\"_getStyles()\\\\\" cdk-scrollable> <ng-content></ng-content> </div> \",\\n                styles: [\".mat-sidenav-container{position:relative;transform:translate3d(0,0,0);box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-sidenav-container[fullscreen]{position:absolute;top:0;left:0;right:0;bottom:0}.mat-sidenav-container[fullscreen].mat-sidenav-opened{overflow:hidden}.mat-sidenav-backdrop{position:absolute;top:0;left:0;right:0;bottom:0;display:block;z-index:2;visibility:hidden}.mat-sidenav-backdrop.mat-sidenav-shown{visibility:visible}@media screen and (-ms-high-contrast:active){.mat-sidenav-backdrop{opacity:.5}}.mat-sidenav-content{position:relative;transform:translate3d(0,0,0);display:block;height:100%;overflow:auto}.mat-sidenav{position:relative;transform:translate3d(0,0,0);display:block;position:absolute;top:0;bottom:0;z-index:3;min-width:5vw;outline:0;box-sizing:border-box;height:100%;overflow-y:auto;transform:translate3d(-100%,0,0)}.mat-sidenav.mat-sidenav-closed{visibility:hidden}.mat-sidenav.mat-sidenav-opened,.mat-sidenav.mat-sidenav-opening{transform:translate3d(0,0,0)}.mat-sidenav.mat-sidenav-side{z-index:1}.mat-sidenav.mat-sidenav-end{right:0;transform:translate3d(100%,0,0)}.mat-sidenav.mat-sidenav-end.mat-sidenav-closed{visibility:hidden}.mat-sidenav.mat-sidenav-end.mat-sidenav-opened,.mat-sidenav.mat-sidenav-end.mat-sidenav-opening{transform:translate3d(0,0,0)}[dir=rtl] .mat-sidenav{transform:translate3d(100%,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-closed{visibility:hidden}[dir=rtl] .mat-sidenav.mat-sidenav-opened,[dir=rtl] .mat-sidenav.mat-sidenav-opening{transform:translate3d(0,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-end{left:0;right:auto;transform:translate3d(-100%,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-closed{visibility:hidden}[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-opened,[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-opening{transform:translate3d(0,0,0)}.mat-sidenav.mat-sidenav-opened:not(.mat-sidenav-side),.mat-sidenav.mat-sidenav-opening:not(.mat-sidenav-side){box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)} /*# sourceMappingURL=sidenav.css.map */ \",\\n                    \".mat-sidenav-transition .mat-sidenav{transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-sidenav-transition .mat-sidenav-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-sidenav-transition .mat-sidenav-backdrop.mat-sidenav-shown{transition:background-color .4s cubic-bezier(.25,.8,.25,1)} /*# sourceMappingURL=sidenav-transitions.css.map */ \"],\\n                host: {\\n                    \\'[class.mat-sidenav-container]\\': \\'true\\',\\n                    \\'[class.mat-sidenav-transition]\\': \\'_enableTransitions\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSidenavContainer.ctorParameters = function () { return [\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\nMdSidenavContainer.propDecorators = {\\n    \\'_sidenavs\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdSidenav,] },],\\n    \\'backdropClick\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdSidenavModule = /*@__PURE__*/(function () {\\n    function MdSidenavModule() {\\n    }\\n    return MdSidenavModule;\\n}());\\nMdSidenavModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"], MdCommonModule, A11yModule, OverlayModule],\\n                exports: [MdSidenavContainer, MdSidenav, MdCommonModule],\\n                declarations: [MdSidenavContainer, MdSidenav],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSidenavModule.ctorParameters = function () { return []; };\\nvar MdListDivider = /*@__PURE__*/(function () {\\n    function MdListDivider() {\\n    }\\n    return MdListDivider;\\n}());\\nMdListDivider.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-divider, mat-divider\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListDivider.ctorParameters = function () { return []; };\\nvar MdList = /*@__PURE__*/(function () {\\n    function MdList() {\\n        this._disableRipple = false;\\n    }\\n    Object.defineProperty(MdList.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect should be disabled on the list-items or not.\\n         * This flag only has an effect for `md-nav-list` components.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return MdList;\\n}());\\nMdList.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-list, mat-list, md-nav-list, mat-nav-list\\',\\n                host: {\\n                    \\'role\\': \\'list\\'\\n                },\\n                template: \\'<ng-content></ng-content>\\',\\n                styles: [\".mat-list,.mat-nav-list{padding-top:8px;display:block}.mat-list .mat-subheader,.mat-nav-list .mat-subheader{display:block;box-sizing:border-box;height:48px;padding:16px;margin:0;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;font-size:14px;font-weight:500}.mat-list .mat-subheader:first-child,.mat-nav-list .mat-subheader:first-child{margin-top:-8px}.mat-list .mat-list-item,.mat-nav-list .mat-list-item{display:block}.mat-list .mat-list-item .mat-list-item-content,.mat-nav-list .mat-list-item .mat-list-item-content{display:flex;flex-direction:row;align-items:center;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;box-sizing:border-box;font-size:16px;height:48px;padding:0 16px;position:relative}.mat-list .mat-list-item .mat-list-item-ripple,.mat-nav-list .mat-list-item .mat-list-item-ripple{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none}.mat-list .mat-list-item.mat-list-item-avatar .mat-list-item-content,.mat-nav-list .mat-list-item.mat-list-item-avatar .mat-list-item-content{height:56px}.mat-list .mat-list-item.mat-2-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-2-line .mat-list-item-content{height:72px}.mat-list .mat-list-item.mat-3-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-3-line .mat-list-item-content{height:88px}.mat-list .mat-list-item.mat-multi-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-multi-line .mat-list-item-content{height:100%;padding:8px 16px}.mat-list .mat-list-item .mat-list-text,.mat-nav-list .mat-list-item .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0 16px}.mat-list .mat-list-item .mat-list-text>*,.mat-nav-list .mat-list-item .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list .mat-list-item .mat-list-text:empty,.mat-nav-list .mat-list-item .mat-list-text:empty{display:none}.mat-list .mat-list-item .mat-list-text:nth-child(2),.mat-nav-list .mat-list-item .mat-list-text:nth-child(2){padding:0}.mat-list .mat-list-item .mat-list-avatar,.mat-nav-list .mat-list-item .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%}.mat-list .mat-list-item .mat-list-icon,.mat-nav-list .mat-list-item .mat-list-icon{width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list .mat-list-item .mat-line,.mat-nav-list .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list .mat-list-item .mat-line:nth-child(n+2),.mat-nav-list .mat-list-item .mat-line:nth-child(n+2){font-size:14px}.mat-list[dense],.mat-nav-list[dense]{padding-top:4px;display:block}.mat-list[dense] .mat-subheader,.mat-nav-list[dense] .mat-subheader{display:block;box-sizing:border-box;height:40px;padding:16px;margin:0;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;font-size:13px;font-weight:500}.mat-list[dense] .mat-subheader:first-child,.mat-nav-list[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list[dense] .mat-list-item,.mat-nav-list[dense] .mat-list-item{display:block}.mat-list[dense] .mat-list-item .mat-list-item-content,.mat-nav-list[dense] .mat-list-item .mat-list-item-content{display:flex;flex-direction:row;align-items:center;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;box-sizing:border-box;font-size:13px;height:40px;padding:0 16px;position:relative}.mat-list[dense] .mat-list-item .mat-list-item-ripple,.mat-nav-list[dense] .mat-list-item .mat-list-item-ripple{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none}.mat-list[dense] .mat-list-item.mat-list-item-avatar .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-list-item-avatar .mat-list-item-content{height:48px}.mat-list[dense] .mat-list-item.mat-2-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-2-line .mat-list-item-content{height:60px}.mat-list[dense] .mat-list-item.mat-3-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-3-line .mat-list-item-content{height:76px}.mat-list[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-multi-line .mat-list-item-content{height:100%;padding:8px 16px}.mat-list[dense] .mat-list-item .mat-list-text,.mat-nav-list[dense] .mat-list-item .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0 16px}.mat-list[dense] .mat-list-item .mat-list-text>*,.mat-nav-list[dense] .mat-list-item .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list[dense] .mat-list-item .mat-list-text:empty,.mat-nav-list[dense] .mat-list-item .mat-list-text:empty{display:none}.mat-list[dense] .mat-list-item .mat-list-text:nth-child(2),.mat-nav-list[dense] .mat-list-item .mat-list-text:nth-child(2){padding:0}.mat-list[dense] .mat-list-item .mat-list-avatar,.mat-nav-list[dense] .mat-list-item .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%}.mat-list[dense] .mat-list-item .mat-list-icon,.mat-nav-list[dense] .mat-list-item .mat-list-icon{width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list[dense] .mat-list-item .mat-line,.mat-nav-list[dense] .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list[dense] .mat-list-item .mat-line:nth-child(n+2),.mat-nav-list[dense] .mat-list-item .mat-line:nth-child(n+2){font-size:13px}.mat-divider{display:block;border-top-style:solid;border-top-width:1px;margin:0}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item-content{cursor:pointer}.mat-nav-list .mat-list-item-content.mat-list-item-focus,.mat-nav-list .mat-list-item-content:hover{outline:0} /*# sourceMappingURL=list.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdList.ctorParameters = function () { return []; };\\nMdList.propDecorators = {\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdListCssMatStyler = /*@__PURE__*/(function () {\\n    function MdListCssMatStyler() {\\n    }\\n    return MdListCssMatStyler;\\n}());\\nMdListCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-list, mat-list\\',\\n                host: {\\n                    \\'[class.mat-list]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdNavListCssMatStyler = /*@__PURE__*/(function () {\\n    function MdNavListCssMatStyler() {\\n    }\\n    return MdNavListCssMatStyler;\\n}());\\nMdNavListCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-nav-list, mat-nav-list\\',\\n                host: {\\n                    \\'[class.mat-nav-list]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdNavListCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdDividerCssMatStyler = /*@__PURE__*/(function () {\\n    function MdDividerCssMatStyler() {\\n    }\\n    return MdDividerCssMatStyler;\\n}());\\nMdDividerCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-divider, mat-divider\\',\\n                host: {\\n                    \\'[class.mat-divider]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDividerCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdListAvatarCssMatStyler = /*@__PURE__*/(function () {\\n    function MdListAvatarCssMatStyler() {\\n    }\\n    return MdListAvatarCssMatStyler;\\n}());\\nMdListAvatarCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-list-avatar], [mat-list-avatar]\\',\\n                host: {\\n                    \\'[class.mat-list-avatar]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListAvatarCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdListIconCssMatStyler = /*@__PURE__*/(function () {\\n    function MdListIconCssMatStyler() {\\n    }\\n    return MdListIconCssMatStyler;\\n}());\\nMdListIconCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-list-icon], [mat-list-icon]\\',\\n                host: {\\n                    \\'[class.mat-list-icon]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListIconCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdListSubheaderCssMatStyler = /*@__PURE__*/(function () {\\n    function MdListSubheaderCssMatStyler() {\\n    }\\n    return MdListSubheaderCssMatStyler;\\n}());\\nMdListSubheaderCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-subheader], [mat-subheader]\\',\\n                host: {\\n                    \\'[class.mat-subheader]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListSubheaderCssMatStyler.ctorParameters = function () { return []; };\\nvar MdListItem = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _element\\n     * @param {?} _list\\n     * @param {?} navList\\n     */\\n    function MdListItem(_renderer, _element, _list, navList) {\\n        this._renderer = _renderer;\\n        this._element = _element;\\n        this._list = _list;\\n        this._disableRipple = false;\\n        this._isNavList = false;\\n        this._isNavList = !!navList;\\n    }\\n    Object.defineProperty(MdListItem.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect on click should be disabled. This applies only to list items that are\\n         * part of a nav list. The value of `disableRipple` on the `md-nav-list` overrides this flag.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdListItem.prototype, \"_hasAvatar\", {\\n        /**\\n         * @param {?} avatar\\n         * @return {?}\\n         */\\n        set: function (avatar) {\\n            if (avatar != null) {\\n                this._renderer.addClass(this._element.nativeElement, \\'mat-list-item-avatar\\');\\n            }\\n            else {\\n                this._renderer.removeClass(this._element.nativeElement, \\'mat-list-item-avatar\\');\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdListItem.prototype.ngAfterContentInit = function () {\\n        this._lineSetter = new MdLineSetter(this._lines, this._renderer, this._element);\\n    };\\n    /**\\n     * Whether this list item should show a ripple effect when clicked.\\n     * @return {?}\\n     */\\n    MdListItem.prototype.isRippleEnabled = function () {\\n        return !this.disableRipple && this._isNavList && !this._list.disableRipple;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdListItem.prototype._handleFocus = function () {\\n        this._renderer.addClass(this._element.nativeElement, \\'mat-list-item-focus\\');\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdListItem.prototype._handleBlur = function () {\\n        this._renderer.removeClass(this._element.nativeElement, \\'mat-list-item-focus\\');\\n    };\\n    /**\\n     * Retrieves the DOM element of the component host.\\n     * @return {?}\\n     */\\n    MdListItem.prototype._getHostElement = function () {\\n        return this._element.nativeElement;\\n    };\\n    return MdListItem;\\n}());\\nMdListItem.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-list-item, mat-list-item, a[md-list-item], a[mat-list-item]\\',\\n                host: {\\n                    \\'role\\': \\'listitem\\',\\n                    \\'(focus)\\': \\'_handleFocus()\\',\\n                    \\'(blur)\\': \\'_handleBlur()\\',\\n                    \\'[class.mat-list-item]\\': \\'true\\',\\n                },\\n                template: \"<div class=\\\\\"mat-list-item-content\\\\\"> <div class=\\\\\"mat-list-item-ripple\\\\\" md-ripple [mdRippleTrigger]=\\\\\"_getHostElement()\\\\\" [mdRippleDisabled]=\\\\\"!isRippleEnabled()\\\\\"> </div> <ng-content select=\\\\\"[md-list-avatar],[md-list-icon], [mat-list-avatar], [mat-list-icon]\\\\\"></ng-content> <div class=\\\\\"mat-list-text\\\\\"><ng-content select=\\\\\"[md-line], [mat-line]\\\\\"></ng-content></div> <ng-content></ng-content> </div> \",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListItem.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: MdList, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: MdNavListCssMatStyler, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdListItem.propDecorators = {\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_lines\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdLine,] },],\\n    \\'_hasAvatar\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [MdListAvatarCssMatStyler,] },],\\n};\\nvar MdListModule = /*@__PURE__*/(function () {\\n    function MdListModule() {\\n    }\\n    return MdListModule;\\n}());\\nMdListModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdLineModule, MdRippleModule, MdCommonModule],\\n                exports: [\\n                    MdList,\\n                    MdListItem,\\n                    MdListDivider,\\n                    MdListAvatarCssMatStyler,\\n                    MdLineModule,\\n                    MdCommonModule,\\n                    MdListIconCssMatStyler,\\n                    MdListCssMatStyler,\\n                    MdNavListCssMatStyler,\\n                    MdDividerCssMatStyler,\\n                    MdListSubheaderCssMatStyler,\\n                ],\\n                declarations: [\\n                    MdList,\\n                    MdListItem,\\n                    MdListDivider,\\n                    MdListAvatarCssMatStyler,\\n                    MdListIconCssMatStyler,\\n                    MdListCssMatStyler,\\n                    MdNavListCssMatStyler,\\n                    MdDividerCssMatStyler,\\n                    MdListSubheaderCssMatStyler,\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListModule.ctorParameters = function () { return []; };\\n/**\\n * Converts values into strings. Falsy values become empty strings.\\n * \\\\@docs-private\\n * @param {?} value\\n * @return {?}\\n */\\nfunction coerceToString(value) {\\n    return \"\" + (value || \\'\\');\\n}\\n/**\\n * Converts a value that might be a string into a number.\\n * \\\\@docs-private\\n * @param {?} value\\n * @return {?}\\n */\\nfunction coerceToNumber(value) {\\n    return typeof value === \\'string\\' ? parseInt(value, 10) : value;\\n}\\nvar MdGridTile = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _element\\n     */\\n    function MdGridTile(_renderer, _element) {\\n        this._renderer = _renderer;\\n        this._element = _element;\\n        this._rowspan = 1;\\n        this._colspan = 1;\\n    }\\n    Object.defineProperty(MdGridTile.prototype, \"rowspan\", {\\n        /**\\n         * Amount of rows that the grid tile takes up.\\n         * @return {?}\\n         */\\n        get: function () { return this._rowspan; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._rowspan = coerceToNumber(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdGridTile.prototype, \"colspan\", {\\n        /**\\n         * Amount of columns that the grid tile takes up.\\n         * @return {?}\\n         */\\n        get: function () { return this._colspan; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._colspan = coerceToNumber(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the style of the grid-tile element.  Needs to be set manually to avoid\\n     * \"Changed after checked\" errors that would occur with HostBinding.\\n     * @param {?} property\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdGridTile.prototype._setStyle = function (property, value) {\\n        this._renderer.setStyle(this._element.nativeElement, property, value);\\n    };\\n    return MdGridTile;\\n}());\\nMdGridTile.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-grid-tile, mat-grid-tile\\',\\n                host: {\\n                    \\'role\\': \\'listitem\\',\\n                    \\'[class.mat-grid-tile]\\': \\'true\\',\\n                },\\n                template: \"\\x3c!-- TODO(kara): Revisit why this is a figure.--\\x3e <figure class=\\\\\"mat-figure\\\\\"> <ng-content></ng-content> </figure>\",\\n                styles: [\".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{display:flex;position:absolute;align-items:center;justify-content:center;height:100%;top:0;right:0;bottom:0;left:0;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;font-size:16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer .mat-line,.mat-grid-tile .mat-grid-tile-header .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile .mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile .mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none} /*# sourceMappingURL=grid-list.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridTile.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdGridTile.propDecorators = {\\n    \\'rowspan\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'colspan\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdGridTileText = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _element\\n     */\\n    function MdGridTileText(_renderer, _element) {\\n        this._renderer = _renderer;\\n        this._element = _element;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdGridTileText.prototype.ngAfterContentInit = function () {\\n        this._lineSetter = new MdLineSetter(this._lines, this._renderer, this._element);\\n    };\\n    return MdGridTileText;\\n}());\\nMdGridTileText.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-grid-tile-header, mat-grid-tile-header, md-grid-tile-footer, mat-grid-tile-footer\\',\\n                template: \"<ng-content select=\\\\\"[md-grid-avatar], [mat-grid-avatar]\\\\\"></ng-content> <div class=\\\\\"mat-grid-list-text\\\\\"><ng-content select=\\\\\"[md-line], [mat-line]\\\\\"></ng-content></div> <ng-content></ng-content> \"\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridTileText.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdGridTileText.propDecorators = {\\n    \\'_lines\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdLine,] },],\\n};\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdGridAvatarCssMatStyler = /*@__PURE__*/(function () {\\n    function MdGridAvatarCssMatStyler() {\\n    }\\n    return MdGridAvatarCssMatStyler;\\n}());\\nMdGridAvatarCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-grid-avatar], [mat-grid-avatar]\\',\\n                host: {\\n                    \\'[class.mat-grid-avatar]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridAvatarCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdGridTileHeaderCssMatStyler = /*@__PURE__*/(function () {\\n    function MdGridTileHeaderCssMatStyler() {\\n    }\\n    return MdGridTileHeaderCssMatStyler;\\n}());\\nMdGridTileHeaderCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-grid-tile-header, mat-grid-tile-header\\',\\n                host: {\\n                    \\'[class.mat-grid-tile-header]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridTileHeaderCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdGridTileFooterCssMatStyler = /*@__PURE__*/(function () {\\n    function MdGridTileFooterCssMatStyler() {\\n    }\\n    return MdGridTileFooterCssMatStyler;\\n}());\\nMdGridTileFooterCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-grid-tile-footer, mat-grid-tile-footer\\',\\n                host: {\\n                    \\'[class.mat-grid-tile-footer]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridTileFooterCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Class for determining, from a list of tiles, the (row, col) position of each of those tiles\\n * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)\\n * because the tiles can have a rowspan.\\n *\\n * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid\\n * large enough to accommodate it so that the tiles still render in the same order in which they\\n * are given.\\n *\\n * The basis of the algorithm is the use of an array to track the already placed tiles. Each\\n * element of the array corresponds to a column, and the value indicates how many cells in that\\n * column are already occupied; zero indicates an empty cell. Moving \"down\" to the next row\\n * decrements each value in the tracking array (indicating that the column is one cell closer to\\n * being free).\\n *\\n * \\\\@docs-private\\n */\\nvar TileCoordinator = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} numColumns\\n     * @param {?} tiles\\n     */\\n    function TileCoordinator(numColumns, tiles) {\\n        var _this = this;\\n        /**\\n         * Index at which the search for the next gap will start.\\n         */\\n        this.columnIndex = 0;\\n        /**\\n         * The current row index.\\n         */\\n        this.rowIndex = 0;\\n        this.tracker = new Array(numColumns);\\n        this.tracker.fill(0, 0, this.tracker.length);\\n        this.positions = tiles.map(function (tile) { return _this._trackTile(tile); });\\n    }\\n    Object.defineProperty(TileCoordinator.prototype, \"rowCount\", {\\n        /**\\n         * Gets the total number of rows occupied by tiles\\n         * @return {?}\\n         */\\n        get: function () { return this.rowIndex + 1; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(TileCoordinator.prototype, \"rowspan\", {\\n        /**\\n         * Gets the total span of rows occupied by tiles.\\n         * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ lastRowMax = Math.max.apply(Math, this.tracker);\\n            // if any of the tiles has a rowspan that pushes it beyond the total row count,\\n            // add the difference to the rowcount\\n            return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Calculates the row and col position of a tile.\\n     * @param {?} tile\\n     * @return {?}\\n     */\\n    TileCoordinator.prototype._trackTile = function (tile) {\\n        // Find a gap large enough for this tile.\\n        var /** @type {?} */ gapStartIndex = this._findMatchingGap(tile.colspan);\\n        // Place tile in the resulting gap.\\n        this._markTilePosition(gapStartIndex, tile);\\n        // The next time we look for a gap, the search will start at columnIndex, which should be\\n        // immediately after the tile that has just been placed.\\n        this.columnIndex = gapStartIndex + tile.colspan;\\n        return new TilePosition(this.rowIndex, gapStartIndex);\\n    };\\n    /**\\n     * Finds the next available space large enough to fit the tile.\\n     * @param {?} tileCols\\n     * @return {?}\\n     */\\n    TileCoordinator.prototype._findMatchingGap = function (tileCols) {\\n        if (tileCols > this.tracker.length) {\\n            throw new Error(\"md-grid-list: tile with colspan \" + tileCols + \" is wider than \" +\\n                (\"grid with cols=\\\\\"\" + this.tracker.length + \"\\\\\".\"));\\n        }\\n        // Start index is inclusive, end index is exclusive.\\n        var /** @type {?} */ gapStartIndex = -1;\\n        var /** @type {?} */ gapEndIndex = -1;\\n        // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.\\n        do {\\n            // If we\\'ve reached the end of the row, go to the next row.\\n            if (this.columnIndex + tileCols > this.tracker.length) {\\n                this._nextRow();\\n                continue;\\n            }\\n            gapStartIndex = this.tracker.indexOf(0, this.columnIndex);\\n            // If there are no more empty spaces in this row at all, move on to the next row.\\n            if (gapStartIndex == -1) {\\n                this._nextRow();\\n                continue;\\n            }\\n            gapEndIndex = this._findGapEndIndex(gapStartIndex);\\n            // If a gap large enough isn\\'t found, we want to start looking immediately after the current\\n            // gap on the next iteration.\\n            this.columnIndex = gapStartIndex + 1;\\n            // Continue iterating until we find a gap wide enough for this tile.\\n        } while (gapEndIndex - gapStartIndex < tileCols);\\n        return gapStartIndex;\\n    };\\n    /**\\n     * Move \"down\" to the next row.\\n     * @return {?}\\n     */\\n    TileCoordinator.prototype._nextRow = function () {\\n        this.columnIndex = 0;\\n        this.rowIndex++;\\n        // Decrement all spaces by one to reflect moving down one row.\\n        for (var /** @type {?} */ i = 0; i < this.tracker.length; i++) {\\n            this.tracker[i] = Math.max(0, this.tracker[i] - 1);\\n        }\\n    };\\n    /**\\n     * Finds the end index (exclusive) of a gap given the index from which to start looking.\\n     * The gap ends when a non-zero value is found.\\n     * @param {?} gapStartIndex\\n     * @return {?}\\n     */\\n    TileCoordinator.prototype._findGapEndIndex = function (gapStartIndex) {\\n        for (var /** @type {?} */ i = gapStartIndex + 1; i < this.tracker.length; i++) {\\n            if (this.tracker[i] != 0) {\\n                return i;\\n            }\\n        }\\n        // The gap ends with the end of the row.\\n        return this.tracker.length;\\n    };\\n    /**\\n     * Update the tile tracker to account for the given tile in the given space.\\n     * @param {?} start\\n     * @param {?} tile\\n     * @return {?}\\n     */\\n    TileCoordinator.prototype._markTilePosition = function (start, tile) {\\n        for (var /** @type {?} */ i = 0; i < tile.colspan; i++) {\\n            this.tracker[start + i] = tile.rowspan;\\n        }\\n    };\\n    return TileCoordinator;\\n}());\\n/**\\n * Simple data structure for tile position (row, col).\\n * \\\\@docs-private\\n */\\nvar TilePosition = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} row\\n     * @param {?} col\\n     */\\n    function TilePosition(row, col) {\\n        this.row = row;\\n        this.col = col;\\n    }\\n    return TilePosition;\\n}());\\n/**\\n * Sets the style properties for an individual tile, given the position calculated by the\\n * Tile Coordinator.\\n * \\\\@docs-private\\n */\\nvar TileStyler = /*@__PURE__*/(function () {\\n    function TileStyler() {\\n        this._rows = 0;\\n        this._rowspan = 0;\\n    }\\n    /**\\n     * Adds grid-list layout info once it is available. Cannot be processed in the constructor\\n     * because these properties haven\\'t been calculated by that point.\\n     *\\n     * @param {?} gutterSize Size of the grid\\'s gutter.\\n     * @param {?} tracker Instance of the TileCoordinator.\\n     * @param {?} cols Amount of columns in the grid.\\n     * @param {?} direction Layout direction of the grid.\\n     * @return {?}\\n     */\\n    TileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {\\n        this._gutterSize = normalizeUnits(gutterSize);\\n        this._rows = tracker.rowCount;\\n        this._rowspan = tracker.rowspan;\\n        this._cols = cols;\\n        this._direction = direction;\\n    };\\n    /**\\n     * Computes the amount of space a single 1x1 tile would take up (width or height).\\n     * Used as a basis for other calculations.\\n     * @param {?} sizePercent Percent of the total grid-list space that one 1x1 tile would take up.\\n     * @param {?} gutterFraction Fraction of the gutter size taken up by one 1x1 tile.\\n     * @return {?} The size of a 1x1 tile as an expression that can be evaluated via CSS calc().\\n     */\\n    TileStyler.prototype.getBaseTileSize = function (sizePercent, gutterFraction) {\\n        // Take the base size percent (as would be if evenly dividing the size between cells),\\n        // and then subtracting the size of one gutter. However, since there are no gutters on the\\n        // edges, each tile only uses a fraction (gutterShare = numGutters / numCells) of the gutter\\n        // size. (Imagine having one gutter per tile, and then breaking up the extra gutter on the\\n        // edge evenly among the cells).\\n        return \"(\" + sizePercent + \"% - ( \" + this._gutterSize + \" * \" + gutterFraction + \" ))\";\\n    };\\n    /**\\n     * Gets The horizontal or vertical position of a tile, e.g., the \\'top\\' or \\'left\\' property value.\\n     * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).\\n     * @param {?} offset Number of tiles that have already been rendered in the row/column.\\n     * @return {?} Position of the tile as a CSS calc() expression.\\n     */\\n    TileStyler.prototype.getTilePosition = function (baseSize, offset) {\\n        // The position comes the size of a 1x1 tile plus gutter for each previous tile in the\\n        // row/column (offset).\\n        return calc(\"(\" + baseSize + \" + \" + this._gutterSize + \") * \" + offset);\\n    };\\n    /**\\n     * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.\\n     * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).\\n     * @param {?} span The tile\\'s rowspan or colspan.\\n     * @return {?} Size of the tile as a CSS calc() expression.\\n     */\\n    TileStyler.prototype.getTileSize = function (baseSize, span) {\\n        return \"(\" + baseSize + \" * \" + span + \") + (\" + (span - 1) + \" * \" + this._gutterSize + \")\";\\n    };\\n    /**\\n     * Sets the style properties to be applied to a tile for the given row and column index.\\n     * @param {?} tile Tile to which to apply the styling.\\n     * @param {?} rowIndex Index of the tile\\'s row.\\n     * @param {?} colIndex Index of the tile\\'s column.\\n     * @return {?}\\n     */\\n    TileStyler.prototype.setStyle = function (tile, rowIndex, colIndex) {\\n        // Percent of the available horizontal space that one column takes up.\\n        var /** @type {?} */ percentWidthPerTile = 100 / this._cols;\\n        // Fraction of the vertical gutter size that each column takes up.\\n        // For example, if there are 5 columns, each column uses 4/5 = 0.8 times the gutter width.\\n        var /** @type {?} */ gutterWidthFractionPerTile = (this._cols - 1) / this._cols;\\n        this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);\\n        this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);\\n    };\\n    /**\\n     * Sets the horizontal placement of the tile in the list.\\n     * @param {?} tile\\n     * @param {?} colIndex\\n     * @param {?} percentWidth\\n     * @param {?} gutterWidth\\n     * @return {?}\\n     */\\n    TileStyler.prototype.setColStyles = function (tile, colIndex, percentWidth, gutterWidth) {\\n        // Base horizontal size of a column.\\n        var /** @type {?} */ baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);\\n        // The width and horizontal position of each tile is always calculated the same way, but the\\n        // height and vertical position depends on the rowMode.\\n        var /** @type {?} */ side = this._direction === \\'ltr\\' ? \\'left\\' : \\'right\\';\\n        tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));\\n        tile._setStyle(\\'width\\', calc(this.getTileSize(baseTileWidth, tile.colspan)));\\n    };\\n    /**\\n     * Calculates the total size taken up by gutters across one axis of a list.\\n     * @return {?}\\n     */\\n    TileStyler.prototype.getGutterSpan = function () {\\n        return this._gutterSize + \" * (\" + this._rowspan + \" - 1)\";\\n    };\\n    /**\\n     * Calculates the total size taken up by tiles across one axis of a list.\\n     * @param {?} tileHeight Height of the tile.\\n     * @return {?}\\n     */\\n    TileStyler.prototype.getTileSpan = function (tileHeight) {\\n        return this._rowspan + \" * \" + this.getTileSize(tileHeight, 1);\\n    };\\n    /**\\n     * Sets the vertical placement of the tile in the list.\\n     * This method will be implemented by each type of TileStyler.\\n     * \\\\@docs-private\\n     * @param {?} tile\\n     * @param {?} rowIndex\\n     * @param {?} percentWidth\\n     * @param {?} gutterWidth\\n     * @return {?}\\n     */\\n    TileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) { };\\n    /**\\n     * Calculates the computed height and returns the correct style property to set.\\n     * This method will be implemented by each type of TileStyler.\\n     * \\\\@docs-private\\n     * @return {?}\\n     */\\n    TileStyler.prototype.getComputedHeight = function () { return null; };\\n    return TileStyler;\\n}());\\n/**\\n * This type of styler is instantiated when the user passes in a fixed row height.\\n * Example <md-grid-list cols=\"3\" rowHeight=\"100px\">\\n * \\\\@docs-private\\n */\\nvar FixedTileStyler = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FixedTileStyler, _super);\\n    /**\\n     * @param {?} fixedRowHeight\\n     */\\n    function FixedTileStyler(fixedRowHeight) {\\n        var _this = _super.call(this) || this;\\n        _this.fixedRowHeight = fixedRowHeight;\\n        return _this;\\n    }\\n    /**\\n     * @param {?} gutterSize\\n     * @param {?} tracker\\n     * @param {?} cols\\n     * @param {?} direction\\n     * @return {?}\\n     */\\n    FixedTileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {\\n        _super.prototype.init.call(this, gutterSize, tracker, cols, direction);\\n        this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);\\n    };\\n    /**\\n     * @param {?} tile\\n     * @param {?} rowIndex\\n     * @param {?} percentWidth\\n     * @param {?} gutterWidth\\n     * @return {?}\\n     */\\n    FixedTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {\\n        tile._setStyle(\\'top\\', this.getTilePosition(this.fixedRowHeight, rowIndex));\\n        tile._setStyle(\\'height\\', calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    FixedTileStyler.prototype.getComputedHeight = function () {\\n        return [\\n            \\'height\\', calc(this.getTileSpan(this.fixedRowHeight) + \" + \" + this.getGutterSpan())\\n        ];\\n    };\\n    return FixedTileStyler;\\n}(TileStyler));\\n/**\\n * This type of styler is instantiated when the user passes in a width:height ratio\\n * for the row height.  Example <md-grid-list cols=\"3\" rowHeight=\"3:1\">\\n * \\\\@docs-private\\n */\\nvar RatioTileStyler = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](RatioTileStyler, _super);\\n    /**\\n     * @param {?} value\\n     */\\n    function RatioTileStyler(value) {\\n        var _this = _super.call(this) || this;\\n        _this._parseRatio(value);\\n        return _this;\\n    }\\n    /**\\n     * @param {?} tile\\n     * @param {?} rowIndex\\n     * @param {?} percentWidth\\n     * @param {?} gutterWidth\\n     * @return {?}\\n     */\\n    RatioTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {\\n        var /** @type {?} */ percentHeightPerTile = percentWidth / this.rowHeightRatio;\\n        this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);\\n        // Use paddingTop and marginTop to maintain the given aspect ratio, as\\n        // a percentage-based value for these properties is applied versus the *width* of the\\n        // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties\\n        tile._setStyle(\\'marginTop\\', this.getTilePosition(this.baseTileHeight, rowIndex));\\n        tile._setStyle(\\'paddingTop\\', calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    RatioTileStyler.prototype.getComputedHeight = function () {\\n        return [\\n            \\'paddingBottom\\', calc(this.getTileSpan(this.baseTileHeight) + \" + \" + this.getGutterSpan())\\n        ];\\n    };\\n    /**\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    RatioTileStyler.prototype._parseRatio = function (value) {\\n        var /** @type {?} */ ratioParts = value.split(\\':\\');\\n        if (ratioParts.length !== 2) {\\n            throw new Error(\"md-grid-list: invalid ratio given for row-height: \\\\\"\" + value + \"\\\\\"\");\\n        }\\n        this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);\\n    };\\n    return RatioTileStyler;\\n}(TileStyler));\\n/**\\n * This type of styler is instantiated when the user selects a \"fit\" row height mode.\\n * In other words, the row height will reflect the total height of the container divided\\n * by the number of rows.  Example <md-grid-list cols=\"3\" rowHeight=\"fit\">\\n *\\n * \\\\@docs-private\\n */\\nvar FitTileStyler = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FitTileStyler, _super);\\n    function FitTileStyler() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    /**\\n     * @param {?} tile\\n     * @param {?} rowIndex\\n     * @param {?} percentWidth\\n     * @param {?} gutterWidth\\n     * @return {?}\\n     */\\n    FitTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {\\n        // Percent of the available vertical space that one row takes up.\\n        var /** @type {?} */ percentHeightPerTile = 100 / this._rowspan;\\n        // Fraction of the horizontal gutter size that each column takes up.\\n        var /** @type {?} */ gutterHeightPerTile = (this._rows - 1) / this._rows;\\n        // Base vertical size of a column.\\n        var /** @type {?} */ baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);\\n        tile._setStyle(\\'top\\', this.getTilePosition(baseTileHeight, rowIndex));\\n        tile._setStyle(\\'height\\', calc(this.getTileSize(baseTileHeight, tile.rowspan)));\\n    };\\n    return FitTileStyler;\\n}(TileStyler));\\n/**\\n * Wraps a CSS string in a calc function\\n * @param {?} exp\\n * @return {?}\\n */\\nfunction calc(exp) { return \"calc(\" + exp + \")\"; }\\n/**\\n * Appends pixels to a CSS string if no units are given.\\n * @param {?} value\\n * @return {?}\\n */\\nfunction normalizeUnits(value) {\\n    return (value.match(/px|em|rem/)) ? value : value + \\'px\\';\\n}\\n// TODO(kara): Conditional (responsive) column count / row size.\\n// TODO(kara): Re-layout on window resize / media change (debounced).\\n// TODO(kara): gridTileHeader and gridTileFooter.\\nvar MD_FIT_MODE = \\'fit\\';\\nvar MdGridList = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _element\\n     * @param {?} _dir\\n     */\\n    function MdGridList(_renderer, _element, _dir) {\\n        this._renderer = _renderer;\\n        this._element = _element;\\n        this._dir = _dir;\\n        /**\\n         * The amount of space between tiles. This will be something like \\'5px\\' or \\'2em\\'.\\n         */\\n        this._gutter = \\'1px\\';\\n    }\\n    Object.defineProperty(MdGridList.prototype, \"cols\", {\\n        /**\\n         * Amount of columns in the grid list.\\n         * @return {?}\\n         */\\n        get: function () { return this._cols; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._cols = coerceToNumber(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdGridList.prototype, \"gutterSize\", {\\n        /**\\n         * Size of the grid list\\'s gutter in pixels.\\n         * @return {?}\\n         */\\n        get: function () { return this._gutter; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._gutter = coerceToString(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdGridList.prototype, \"rowHeight\", {\\n        /**\\n         * Set internal representation of row height from the user-provided value.\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._rowHeight = coerceToString(value);\\n            this._setTileStyler();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdGridList.prototype.ngOnInit = function () {\\n        this._checkCols();\\n        this._checkRowHeight();\\n    };\\n    /**\\n     * The layout calculation is fairly cheap if nothing changes, so there\\'s little cost\\n     * to run it frequently.\\n     * @return {?}\\n     */\\n    MdGridList.prototype.ngAfterContentChecked = function () {\\n        this._layoutTiles();\\n    };\\n    /**\\n     * Throw a friendly error if cols property is missing\\n     * @return {?}\\n     */\\n    MdGridList.prototype._checkCols = function () {\\n        if (!this.cols) {\\n            throw new Error(\"md-grid-list: must pass in number of columns. \" +\\n                \"Example: <md-grid-list cols=\\\\\"3\\\\\">\");\\n        }\\n    };\\n    /**\\n     * Default to equal width:height if rowHeight property is missing\\n     * @return {?}\\n     */\\n    MdGridList.prototype._checkRowHeight = function () {\\n        if (!this._rowHeight) {\\n            this._tileStyler = new RatioTileStyler(\\'1:1\\');\\n        }\\n    };\\n    /**\\n     * Creates correct Tile Styler subtype based on rowHeight passed in by user\\n     * @return {?}\\n     */\\n    MdGridList.prototype._setTileStyler = function () {\\n        if (this._rowHeight === MD_FIT_MODE) {\\n            this._tileStyler = new FitTileStyler();\\n        }\\n        else if (this._rowHeight && this._rowHeight.indexOf(\\':\\') > -1) {\\n            this._tileStyler = new RatioTileStyler(this._rowHeight);\\n        }\\n        else {\\n            this._tileStyler = new FixedTileStyler(this._rowHeight);\\n        }\\n    };\\n    /**\\n     * Computes and applies the size and position for all children grid tiles.\\n     * @return {?}\\n     */\\n    MdGridList.prototype._layoutTiles = function () {\\n        var _this = this;\\n        var /** @type {?} */ tracker = new TileCoordinator(this.cols, this._tiles);\\n        var /** @type {?} */ direction = this._dir ? this._dir.value : \\'ltr\\';\\n        this._tileStyler.init(this.gutterSize, tracker, this.cols, direction);\\n        this._tiles.forEach(function (tile, index) {\\n            var /** @type {?} */ pos = tracker.positions[index];\\n            _this._tileStyler.setStyle(tile, pos.row, pos.col);\\n        });\\n        this._setListStyle(this._tileStyler.getComputedHeight());\\n    };\\n    /**\\n     * Sets style on the main grid-list element, given the style name and value.\\n     * @param {?} style\\n     * @return {?}\\n     */\\n    MdGridList.prototype._setListStyle = function (style$$1) {\\n        if (style$$1) {\\n            this._renderer.setStyle(this._element.nativeElement, style$$1[0], style$$1[1]);\\n        }\\n    };\\n    return MdGridList;\\n}());\\nMdGridList.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-grid-list, mat-grid-list\\',\\n                template: \"<div> <ng-content></ng-content> </div>\",\\n                styles: [\".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{display:flex;position:absolute;align-items:center;justify-content:center;height:100%;top:0;right:0;bottom:0;left:0;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;font-size:16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer .mat-line,.mat-grid-tile .mat-grid-tile-header .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile .mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile .mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none} /*# sourceMappingURL=grid-list.css.map */ \"],\\n                host: {\\n                    \\'role\\': \\'list\\',\\n                    \\'[class.mat-grid-list]\\': \\'true\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridList.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdGridList.propDecorators = {\\n    \\'_tiles\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdGridTile,] },],\\n    \\'cols\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'gutterSize\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'rowHeight\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdGridListModule = /*@__PURE__*/(function () {\\n    function MdGridListModule() {\\n    }\\n    return MdGridListModule;\\n}());\\nMdGridListModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdLineModule, MdCommonModule],\\n                exports: [\\n                    MdGridList,\\n                    MdGridTile,\\n                    MdGridTileText,\\n                    MdLineModule,\\n                    MdCommonModule,\\n                    MdGridTileHeaderCssMatStyler,\\n                    MdGridTileFooterCssMatStyler,\\n                    MdGridAvatarCssMatStyler\\n                ],\\n                declarations: [\\n                    MdGridList,\\n                    MdGridTile,\\n                    MdGridTileText,\\n                    MdGridTileHeaderCssMatStyler,\\n                    MdGridTileFooterCssMatStyler,\\n                    MdGridAvatarCssMatStyler\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridListModule.ctorParameters = function () { return []; };\\n/**\\n * Content of a card, needed as it\\'s used as a selector in the API.\\n * \\\\@docs-private\\n */\\nvar MdCardContent = /*@__PURE__*/(function () {\\n    function MdCardContent() {\\n    }\\n    return MdCardContent;\\n}());\\nMdCardContent.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-card-content, mat-card-content\\',\\n                host: {\\n                    \\'[class.mat-card-content]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardContent.ctorParameters = function () { return []; };\\n/**\\n * Title of a card, needed as it\\'s used as a selector in the API.\\n * \\\\@docs-private\\n */\\nvar MdCardTitle = /*@__PURE__*/(function () {\\n    function MdCardTitle() {\\n    }\\n    return MdCardTitle;\\n}());\\nMdCardTitle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-card-title, mat-card-title, [md-card-title], [mat-card-title]\\',\\n                host: {\\n                    \\'[class.mat-card-title]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardTitle.ctorParameters = function () { return []; };\\n/**\\n * Sub-title of a card, needed as it\\'s used as a selector in the API.\\n * \\\\@docs-private\\n */\\nvar MdCardSubtitle = /*@__PURE__*/(function () {\\n    function MdCardSubtitle() {\\n    }\\n    return MdCardSubtitle;\\n}());\\nMdCardSubtitle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-card-subtitle, mat-card-subtitle, [md-card-subtitle], [mat-card-subtitle]\\',\\n                host: {\\n                    \\'[class.mat-card-subtitle]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardSubtitle.ctorParameters = function () { return []; };\\n/**\\n * Action section of a card, needed as it\\'s used as a selector in the API.\\n * \\\\@docs-private\\n */\\nvar MdCardActions = /*@__PURE__*/(function () {\\n    function MdCardActions() {\\n    }\\n    return MdCardActions;\\n}());\\nMdCardActions.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-card-actions, mat-card-actions\\',\\n                host: {\\n                    \\'[class.mat-card-actions]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardActions.ctorParameters = function () { return []; };\\n/**\\n * Footer of a card, needed as it\\'s used as a selector in the API.\\n * \\\\@docs-private\\n */\\nvar MdCardFooter = /*@__PURE__*/(function () {\\n    function MdCardFooter() {\\n    }\\n    return MdCardFooter;\\n}());\\nMdCardFooter.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-card-footer, mat-card-footer\\',\\n                host: {\\n                    \\'[class.mat-card-footer]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardFooter.ctorParameters = function () { return []; };\\n/**\\n * Image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardSmImage = /*@__PURE__*/(function () {\\n    function MdCardSmImage() {\\n    }\\n    return MdCardSmImage;\\n}());\\nMdCardSmImage.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-sm-image], [mat-card-sm-image]\\',\\n                host: {\\n                    \\'[class.mat-card-sm-image]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardSmImage.ctorParameters = function () { return []; };\\n/**\\n * Image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardMdImage = /*@__PURE__*/(function () {\\n    function MdCardMdImage() {\\n    }\\n    return MdCardMdImage;\\n}());\\nMdCardMdImage.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-md-image], [mat-card-md-image]\\',\\n                host: {\\n                    \\'[class.mat-card-md-image]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardMdImage.ctorParameters = function () { return []; };\\n/**\\n * Image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardLgImage = /*@__PURE__*/(function () {\\n    function MdCardLgImage() {\\n    }\\n    return MdCardLgImage;\\n}());\\nMdCardLgImage.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-lg-image], [mat-card-lg-image]\\',\\n                host: {\\n                    \\'class.mat-card-lg-image\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardLgImage.ctorParameters = function () { return []; };\\n/**\\n * Image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardImage = /*@__PURE__*/(function () {\\n    function MdCardImage() {\\n    }\\n    return MdCardImage;\\n}());\\nMdCardImage.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-image], [mat-card-image]\\',\\n                host: {\\n                    \\'[class.mat-card-image]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardImage.ctorParameters = function () { return []; };\\n/**\\n * Large image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardXlImage = /*@__PURE__*/(function () {\\n    function MdCardXlImage() {\\n    }\\n    return MdCardXlImage;\\n}());\\nMdCardXlImage.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-xl-image], [mat-card-xl-image]\\',\\n                host: {\\n                    \\'[class.mat-card-xl-image]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardXlImage.ctorParameters = function () { return []; };\\n/**\\n * Avatar image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardAvatar = /*@__PURE__*/(function () {\\n    function MdCardAvatar() {\\n    }\\n    return MdCardAvatar;\\n}());\\nMdCardAvatar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-avatar], [mat-card-avatar]\\',\\n                host: {\\n                    \\'[class.mat-card-avatar]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardAvatar.ctorParameters = function () { return []; };\\n/**\\n * A basic content container component that adds the styles of a Material design card.\\n *\\n * While this component can be used alone, it also provides a number\\n * of preset styles for common card sections, including:\\n * - md-card-title\\n * - md-card-subtitle\\n * - md-card-content\\n * - md-card-actions\\n * - md-card-footer\\n */\\nvar MdCard = /*@__PURE__*/(function () {\\n    function MdCard() {\\n    }\\n    return MdCard;\\n}());\\nMdCard.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-card, mat-card\\',\\n                template: \"<ng-content></ng-content> \",\\n                styles: [\".mat-card{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);will-change:box-shadow;display:block;position:relative;padding:24px;border-radius:2px;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif}.mat-card:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-flat{box-shadow:none}.mat-card-actions,.mat-card-content,.mat-card-subtitle,.mat-card-title{display:block;margin-bottom:16px}.mat-card-title{font-size:24px;font-weight:400}.mat-card-subtitle{font-size:14px}.mat-card-content{font-size:14px}.mat-card-actions{margin-left:-16px;margin-right:-16px;padding:8px 0}.mat-card-actions[align=end]{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 48px);margin:0 -24px 16px -24px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-footer{position:absolute;width:100%;min-height:5px;bottom:0;left:0}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button{margin:0 4px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header-text{margin:0 8px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0}.mat-card-header .mat-card-title{font-size:14px}.mat-card-lg-image,.mat-card-md-image,.mat-card-sm-image{margin:-8px 0}.mat-card-title-group{display:flex;justify-content:space-between;margin:0 -8px}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}@media (max-width:600px){.mat-card{padding:24px 16px}.mat-card-actions{margin-left:-8px;margin-right:-8px}.mat-card-image{width:calc(100% + 32px);margin:16px -16px}.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}.mat-card-header{margin:-8px 0 0 0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child,.mat-card>:last-child{margin-bottom:0}.mat-card-image:first-child{margin-top:-24px}.mat-card>.mat-card-actions:last-child{margin-bottom:-16px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child{margin-left:0;margin-right:0}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px} /*# sourceMappingURL=card.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                host: {\\n                    \\'[class.mat-card]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCard.ctorParameters = function () { return []; };\\n/**\\n * Component intended to be used within the `<md-card>` component. It adds styles for a\\n * preset header section (i.e. a title, subtitle, and avatar layout).\\n * \\\\@docs-private\\n */\\nvar MdCardHeader = /*@__PURE__*/(function () {\\n    function MdCardHeader() {\\n    }\\n    return MdCardHeader;\\n}());\\nMdCardHeader.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-card-header, mat-card-header\\',\\n                template: \"<ng-content select=\\\\\"[md-card-avatar], [mat-card-avatar]\\\\\"></ng-content> <div class=\\\\\"mat-card-header-text\\\\\"> <ng-content select=\\\\\"md-card-title, mat-card-title, md-card-subtitle, mat-card-subtitle, [md-card-title], [mat-card-title], [md-card-subtitle], [mat-card-subtitle]\\\\\"></ng-content> </div> <ng-content></ng-content> \",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                host: {\\n                    \\'[class.mat-card-header]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardHeader.ctorParameters = function () { return []; };\\n/**\\n * Component intended to be used within the <md-card> component. It adds styles for a preset\\n * layout that groups an image with a title section.\\n * \\\\@docs-private\\n */\\nvar MdCardTitleGroup = /*@__PURE__*/(function () {\\n    function MdCardTitleGroup() {\\n    }\\n    return MdCardTitleGroup;\\n}());\\nMdCardTitleGroup.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-card-title-group, mat-card-title-group\\',\\n                template: \"<div> <ng-content select=\\\\\"md-card-title, mat-card-title, md-card-subtitle, mat-card-subtitle, [md-card-title], [mat-card-title], [md-card-subtitle], [mat-card-subtitle]\\\\\"></ng-content> </div> <ng-content select=\\\\\"img\\\\\"></ng-content> <ng-content></ng-content> \",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                host: {\\n                    \\'[class.mat-card-title-group]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardTitleGroup.ctorParameters = function () { return []; };\\nvar MdCardModule = /*@__PURE__*/(function () {\\n    function MdCardModule() {\\n    }\\n    return MdCardModule;\\n}());\\nMdCardModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule],\\n                exports: [\\n                    MdCard,\\n                    MdCardHeader,\\n                    MdCardTitleGroup,\\n                    MdCardContent,\\n                    MdCardTitle,\\n                    MdCardSubtitle,\\n                    MdCardActions,\\n                    MdCardFooter,\\n                    MdCardSmImage,\\n                    MdCardMdImage,\\n                    MdCardLgImage,\\n                    MdCardImage,\\n                    MdCardXlImage,\\n                    MdCardAvatar,\\n                    MdCommonModule,\\n                ],\\n                declarations: [\\n                    MdCard, MdCardHeader, MdCardTitleGroup, MdCardContent, MdCardTitle, MdCardSubtitle,\\n                    MdCardActions, MdCardFooter, MdCardSmImage, MdCardMdImage, MdCardLgImage, MdCardImage,\\n                    MdCardXlImage, MdCardAvatar,\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardModule.ctorParameters = function () { return []; };\\n/**\\n * Material design styled Chip component. Used inside the MdChipList component.\\n */\\nvar MdChip = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdChip(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n        /**\\n         * Whether or not the chip is disabled. Disabled chips cannot be focused.\\n         */\\n        this._disabled = null;\\n        /**\\n         * Whether or not the chip is selected.\\n         */\\n        this._selected = false;\\n        /**\\n         * The palette color of selected chips.\\n         */\\n        this._color = \\'primary\\';\\n        /**\\n         * Emitted when the chip is focused.\\n         */\\n        this.onFocus = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Emitted when the chip is selected.\\n         */\\n        this.select = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Emitted when the chip is deselected.\\n         */\\n        this.deselect = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Emitted when the chip is destroyed.\\n         */\\n        this.destroy = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdChip.prototype.ngOnInit = function () {\\n        this._addDefaultCSSClass();\\n        this._updateColor(this._color);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdChip.prototype.ngOnDestroy = function () {\\n        this.destroy.emit({ chip: this });\\n    };\\n    Object.defineProperty(MdChip.prototype, \"disabled\", {\\n        /**\\n         * Whether or not the chip is disabled.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._disabled;\\n        },\\n        /**\\n         * Sets the disabled state of the chip.\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = coerceBooleanProperty(value) ? true : null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdChip.prototype, \"_isAriaDisabled\", {\\n        /**\\n         * A String representation of the current disabled state.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return String(coerceBooleanProperty(this.disabled));\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdChip.prototype, \"selected\", {\\n        /**\\n         * Whether or not this chip is selected.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._selected;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._selected = coerceBooleanProperty(value);\\n            if (this._selected) {\\n                this.select.emit({ chip: this });\\n            }\\n            else {\\n                this.deselect.emit({ chip: this });\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Toggles the current selected state of this chip.\\n     * @return {?} Whether the chip is selected.\\n     */\\n    MdChip.prototype.toggleSelected = function () {\\n        this.selected = !this.selected;\\n        return this.selected;\\n    };\\n    Object.defineProperty(MdChip.prototype, \"color\", {\\n        /**\\n         * The color of the chip. Can be `primary`, `accent`, or `warn`.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._color;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._updateColor(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Allows for programmatic focusing of the chip.\\n     * @return {?}\\n     */\\n    MdChip.prototype.focus = function () {\\n        this._elementRef.nativeElement.focus();\\n        this.onFocus.emit({ chip: this });\\n    };\\n    /**\\n     * Ensures events fire properly upon click.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdChip.prototype._handleClick = function (event) {\\n        // Check disabled\\n        if (this.disabled) {\\n            event.preventDefault();\\n            event.stopPropagation();\\n        }\\n        else {\\n            this.focus();\\n        }\\n    };\\n    /**\\n     * Initializes the appropriate CSS classes based on the chip type (basic or standard).\\n     * @return {?}\\n     */\\n    MdChip.prototype._addDefaultCSSClass = function () {\\n        var /** @type {?} */ el = this._elementRef.nativeElement;\\n        // Always add the `mat-chip` class\\n        this._renderer.addClass(el, \\'mat-chip\\');\\n        // If we are a basic chip, also add the `mat-basic-chip` class for :not() targeting\\n        if (el.nodeName.toLowerCase() == \\'mat-basic-chip\\' || el.hasAttribute(\\'mat-basic-chip\\') ||\\n            el.nodeName.toLowerCase() == \\'md-basic-chip\\' || el.hasAttribute(\\'md-basic-chip\\')) {\\n            this._renderer.addClass(el, \\'mat-basic-chip\\');\\n        }\\n    };\\n    /**\\n     * Updates the private _color variable and the native element.\\n     * @param {?} newColor\\n     * @return {?}\\n     */\\n    MdChip.prototype._updateColor = function (newColor) {\\n        this._setElementColor(this._color, false);\\n        this._setElementColor(newColor, true);\\n        this._color = newColor;\\n    };\\n    /**\\n     * Sets the mat-color on the native element.\\n     * @param {?} color\\n     * @param {?} isAdd\\n     * @return {?}\\n     */\\n    MdChip.prototype._setElementColor = function (color, isAdd) {\\n        if (color != null && color != \\'\\') {\\n            if (isAdd) {\\n                this._renderer.addClass(this._elementRef.nativeElement, \"mat-\" + color);\\n            }\\n            else {\\n                this._renderer.removeClass(this._elementRef.nativeElement, \"mat-\" + color);\\n            }\\n        }\\n    };\\n    return MdChip;\\n}());\\nMdChip.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{\\n                selector: \"md-basic-chip, [md-basic-chip], md-chip, [md-chip],\\\\n             mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]\",\\n                template: \"<ng-content></ng-content>\",\\n                host: {\\n                    \\'[class.mat-chip]\\': \\'true\\',\\n                    \\'tabindex\\': \\'-1\\',\\n                    \\'role\\': \\'option\\',\\n                    \\'[class.mat-chip-selected]\\': \\'selected\\',\\n                    \\'[attr.disabled]\\': \\'disabled\\',\\n                    \\'[attr.aria-disabled]\\': \\'_isAriaDisabled\\',\\n                    \\'(click)\\': \\'_handleClick($event)\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdChip.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdChip.propDecorators = {\\n    \\'select\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'deselect\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'destroy\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * A material design chips component (named ChipList for it\\'s similarity to the List component).\\n *\\n * Example:\\n *\\n *     <md-chip-list>\\n *       <md-chip>Chip 1<md-chip>\\n *       <md-chip>Chip 2<md-chip>\\n *     </md-chip-list>\\n */\\nvar MdChipList = /*@__PURE__*/(function () {\\n    function MdChipList() {\\n        /**\\n         * Track which chips we\\'re listening to for focus/destruction.\\n         */\\n        this._subscribed = new WeakMap();\\n        /**\\n         * Whether or not the chip is selectable.\\n         */\\n        this._selectable = true;\\n        /**\\n         * Tab index for the chip list.\\n         */\\n        this._tabIndex = 0;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdChipList.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._keyManager = new FocusKeyManager(this.chips).withWrap();\\n        // Prevents the chip list from capturing focus and redirecting\\n        // it back to the first chip when the user tabs out.\\n        this._tabOutSubscription = this._keyManager.tabOut.subscribe(function () {\\n            _this._tabIndex = -1;\\n            setTimeout(function () { return _this._tabIndex = 0; });\\n        });\\n        // Go ahead and subscribe all of the initial chips\\n        this._subscribeChips(this.chips);\\n        // When the list changes, re-subscribe\\n        this.chips.changes.subscribe(function (chips) {\\n            _this._subscribeChips(chips);\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdChipList.prototype.ngOnDestroy = function () {\\n        if (this._tabOutSubscription) {\\n            this._tabOutSubscription.unsubscribe();\\n        }\\n    };\\n    Object.defineProperty(MdChipList.prototype, \"selectable\", {\\n        /**\\n         * Whether or not this chip is selectable. When a chip is not selectable,\\n         * it\\'s selected state is always ignored.\\n         * @return {?}\\n         */\\n        get: function () { return this._selectable; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._selectable = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Programmatically focus the chip list. This in turn focuses the first\\n     * non-disabled chip in this chip list.\\n     * @return {?}\\n     */\\n    MdChipList.prototype.focus = function () {\\n        // TODO: ARIA says this should focus the first `selected` chip.\\n        this._keyManager.setFirstItemActive();\\n    };\\n    /**\\n     * Passes relevant key presses to our key manager.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdChipList.prototype._keydown = function (event) {\\n        var /** @type {?} */ target = (event.target);\\n        // If they are on a chip, check for space/left/right, otherwise pass to our key manager\\n        if (target && target.classList.contains(\\'mat-chip\\')) {\\n            switch (event.keyCode) {\\n                case SPACE:\\n                    // If we are selectable, toggle the focused chip\\n                    if (this.selectable) {\\n                        this._toggleSelectOnFocusedChip();\\n                    }\\n                    // Always prevent space from scrolling the page since the list has focus\\n                    event.preventDefault();\\n                    break;\\n                case LEFT_ARROW:\\n                    this._keyManager.setPreviousItemActive();\\n                    event.preventDefault();\\n                    break;\\n                case RIGHT_ARROW:\\n                    this._keyManager.setNextItemActive();\\n                    event.preventDefault();\\n                    break;\\n                default:\\n                    this._keyManager.onKeydown(event);\\n            }\\n        }\\n    };\\n    /**\\n     * Toggles the selected state of the currently focused chip.\\n     * @return {?}\\n     */\\n    MdChipList.prototype._toggleSelectOnFocusedChip = function () {\\n        // Allow disabling of chip selection\\n        if (!this.selectable) {\\n            return;\\n        }\\n        var /** @type {?} */ focusedIndex = this._keyManager.activeItemIndex;\\n        if (this._isValidIndex(focusedIndex)) {\\n            var /** @type {?} */ focusedChip = this.chips.toArray()[focusedIndex];\\n            if (focusedChip) {\\n                focusedChip.toggleSelected();\\n            }\\n        }\\n    };\\n    /**\\n     * Iterate through the list of chips and add them to our list of\\n     * subscribed chips.\\n     *\\n     * @param {?} chips The list of chips to be subscribed.\\n     * @return {?}\\n     */\\n    MdChipList.prototype._subscribeChips = function (chips) {\\n        var _this = this;\\n        chips.forEach(function (chip) { return _this._addChip(chip); });\\n    };\\n    /**\\n     * Add a specific chip to our subscribed list. If the chip has\\n     * already been subscribed, this ensures it is only subscribed\\n     * once.\\n     *\\n     * @param {?} chip The chip to be subscribed (or checked for existing\\n     * subscription).\\n     * @return {?}\\n     */\\n    MdChipList.prototype._addChip = function (chip) {\\n        var _this = this;\\n        // If we\\'ve already been subscribed to a parent, do nothing\\n        if (this._subscribed.has(chip)) {\\n            return;\\n        }\\n        // Watch for focus events outside of the keyboard navigation\\n        chip.onFocus.subscribe(function () {\\n            var /** @type {?} */ chipIndex = _this.chips.toArray().indexOf(chip);\\n            if (_this._isValidIndex(chipIndex)) {\\n                _this._keyManager.updateActiveItemIndex(chipIndex);\\n            }\\n        });\\n        // On destroy, remove the item from our list, and check focus\\n        chip.destroy.subscribe(function () {\\n            var /** @type {?} */ chipIndex = _this.chips.toArray().indexOf(chip);\\n            if (_this._isValidIndex(chipIndex)) {\\n                // Check whether the chip is the last item\\n                if (chipIndex < _this.chips.length - 1) {\\n                    _this._keyManager.setActiveItem(chipIndex);\\n                }\\n                else if (chipIndex - 1 >= 0) {\\n                    _this._keyManager.setActiveItem(chipIndex - 1);\\n                }\\n            }\\n            _this._subscribed.delete(chip);\\n            chip.destroy.unsubscribe();\\n        });\\n        this._subscribed.set(chip, true);\\n    };\\n    /**\\n     * Utility to ensure all indexes are valid.\\n     *\\n     * @param {?} index The index to be checked.\\n     * @return {?} True if the index is valid for our list of chips.\\n     */\\n    MdChipList.prototype._isValidIndex = function (index) {\\n        return index >= 0 && index < this.chips.length;\\n    };\\n    return MdChipList;\\n}());\\nMdChipList.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-chip-list, mat-chip-list\\',\\n                template: \"<div class=\\\\\"mat-chip-list-wrapper\\\\\"><ng-content></ng-content></div>\",\\n                host: {\\n                    // Properties\\n                    \\'[attr.tabindex]\\': \\'_tabIndex\\',\\n                    \\'role\\': \\'listbox\\',\\n                    \\'[class.mat-chip-list]\\': \\'true\\',\\n                    // Events\\n                    \\'(focus)\\': \\'focus()\\',\\n                    \\'(keydown)\\': \\'_keydown($event)\\'\\n                },\\n                queries: {\\n                    chips: new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"](MdChip)\\n                },\\n                styles: [\".mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:flex-start}.mat-chip:not(.mat-basic-chip){display:inline-block;padding:8px 12px 8px 12px;border-radius:24px;font-size:13px;line-height:16px}.mat-chip:not(.mat-basic-chip)+.mat-chip:not(.mat-basic-chip){margin:0 0 0 3px}[dir=rtl] .mat-chip:not(.mat-basic-chip)+.mat-chip:not(.mat-basic-chip){margin:0 3px 0 0}.mat-chip-list-stacked .mat-chip-list-wrapper{display:block}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip){display:block;margin:0;margin-bottom:8px}[dir=rtl] .mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip){margin:0;margin-bottom:8px}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child,[dir=rtl] .mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child{margin-bottom:0} /*# sourceMappingURL=chips.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdChipList.ctorParameters = function () { return []; };\\nMdChipList.propDecorators = {\\n    \\'selectable\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdChipsModule = /*@__PURE__*/(function () {\\n    function MdChipsModule() {\\n    }\\n    return MdChipsModule;\\n}());\\nMdChipsModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [],\\n                exports: [MdChipList, MdChip],\\n                declarations: [MdChipList, MdChip]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdChipsModule.ctorParameters = function () { return []; };\\n/**\\n * Returns an exception to be thrown in the case when attempting to\\n * load an icon with a name that cannot be found.\\n * \\\\@docs-private\\n * @param {?} iconName\\n * @return {?}\\n */\\nfunction getMdIconNameNotFoundError(iconName) {\\n    return new Error(\"Unable to find icon with the name \\\\\"\" + iconName + \"\\\\\"\");\\n}\\n/**\\n * Returns an exception to be thrown when the consumer attempts to use\\n * `<md-icon>` without including \\\\@angular/http.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdIconNoHttpProviderError() {\\n    return new Error(\\'Could not find Http provider for use with Angular Material icons. \\' +\\n        \\'Please include the HttpModule from @angular/http in your app imports.\\');\\n}\\n/**\\n * Configuration for an icon, including the URL and possibly the cached SVG element.\\n * \\\\@docs-private\\n */\\nvar SvgIconConfig = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} url\\n     */\\n    function SvgIconConfig(url) {\\n        this.url = url;\\n        this.svgElement = null;\\n    }\\n    return SvgIconConfig;\\n}());\\n/**\\n * Service to register and display icons used by the <md-icon> component.\\n * - Registers icon URLs by namespace and name.\\n * - Registers icon set URLs by namespace.\\n * - Registers aliases for CSS classes, for use with icon fonts.\\n * - Loads icons from URLs and extracts individual icons from icon sets.\\n */\\nvar MdIconRegistry = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _http\\n     * @param {?} _sanitizer\\n     */\\n    function MdIconRegistry(_http, _sanitizer) {\\n        this._http = _http;\\n        this._sanitizer = _sanitizer;\\n        /**\\n         * URLs and cached SVG elements for individual icons. Keys are of the format \"[namespace]:[icon]\".\\n         */\\n        this._svgIconConfigs = new Map();\\n        /**\\n         * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.\\n         * Multiple icon sets can be registered under the same namespace.\\n         */\\n        this._iconSetConfigs = new Map();\\n        /**\\n         * Cache for icons loaded by direct URLs.\\n         */\\n        this._cachedIconsByUrl = new Map();\\n        /**\\n         * In-progress icon fetches. Used to coalesce multiple requests to the same URL.\\n         */\\n        this._inProgressUrlFetches = new Map();\\n        /**\\n         * Map from font identifiers to their CSS class names. Used for icon fonts.\\n         */\\n        this._fontCssClassesByAlias = new Map();\\n        /**\\n         * The CSS class to apply when an <md-icon> component has no icon name, url, or font specified.\\n         * The default \\'material-icons\\' value assumes that the material icon font has been loaded as\\n         * described at http://google.github.io/material-design-icons/#icon-font-for-the-web\\n         */\\n        this._defaultFontSetClass = \\'material-icons\\';\\n    }\\n    /**\\n     * Registers an icon by URL in the default namespace.\\n     * @param {?} iconName Name under which the icon should be registered.\\n     * @param {?} url\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.addSvgIcon = function (iconName, url) {\\n        return this.addSvgIconInNamespace(\\'\\', iconName, url);\\n    };\\n    /**\\n     * Registers an icon by URL in the specified namespace.\\n     * @param {?} namespace Namespace in which the icon should be registered.\\n     * @param {?} iconName Name under which the icon should be registered.\\n     * @param {?} url\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.addSvgIconInNamespace = function (namespace, iconName, url) {\\n        var /** @type {?} */ key = iconKey(namespace, iconName);\\n        this._svgIconConfigs.set(key, new SvgIconConfig(url));\\n        return this;\\n    };\\n    /**\\n     * Registers an icon set by URL in the default namespace.\\n     * @param {?} url\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.addSvgIconSet = function (url) {\\n        return this.addSvgIconSetInNamespace(\\'\\', url);\\n    };\\n    /**\\n     * Registers an icon set by URL in the specified namespace.\\n     * @param {?} namespace Namespace in which to register the icon set.\\n     * @param {?} url\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.addSvgIconSetInNamespace = function (namespace, url) {\\n        var /** @type {?} */ config = new SvgIconConfig(url);\\n        if (this._iconSetConfigs.has(namespace)) {\\n            this._iconSetConfigs.get(namespace).push(config);\\n        }\\n        else {\\n            this._iconSetConfigs.set(namespace, [config]);\\n        }\\n        return this;\\n    };\\n    /**\\n     * Defines an alias for a CSS class name to be used for icon fonts. Creating an mdIcon\\n     * component with the alias as the fontSet input will cause the class name to be applied\\n     * to the <md-icon> element.\\n     *\\n     * @param {?} alias Alias for the font.\\n     * @param {?=} className Class name override to be used instead of the alias.\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.registerFontClassAlias = function (alias, className) {\\n        if (className === void 0) { className = alias; }\\n        this._fontCssClassesByAlias.set(alias, className);\\n        return this;\\n    };\\n    /**\\n     * Returns the CSS class name associated with the alias by a previous call to\\n     * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.\\n     * @param {?} alias\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.classNameForFontAlias = function (alias) {\\n        return this._fontCssClassesByAlias.get(alias) || alias;\\n    };\\n    /**\\n     * Sets the CSS class name to be used for icon fonts when an <md-icon> component does not\\n     * have a fontSet input value, and is not loading an icon by name or URL.\\n     *\\n     * @param {?} className\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.setDefaultFontSetClass = function (className) {\\n        this._defaultFontSetClass = className;\\n        return this;\\n    };\\n    /**\\n     * Returns the CSS class name to be used for icon fonts when an <md-icon> component does not\\n     * have a fontSet input value, and is not loading an icon by name or URL.\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.getDefaultFontSetClass = function () {\\n        return this._defaultFontSetClass;\\n    };\\n    /**\\n     * Returns an Observable that produces the icon (as an <svg> DOM element) from the given URL.\\n     * The response from the URL may be cached so this will not always cause an HTTP request, but\\n     * the produced element will always be a new copy of the originally fetched icon. (That is,\\n     * it will not contain any modifications made to elements previously returned).\\n     *\\n     * @param {?} safeUrl URL from which to fetch the SVG icon.\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.getSvgIconFromUrl = function (safeUrl) {\\n        var _this = this;\\n        var /** @type {?} */ url = this._sanitizer.sanitize(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].RESOURCE_URL, safeUrl);\\n        if (this._cachedIconsByUrl.has(url)) {\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].of(cloneSvg(this._cachedIconsByUrl.get(url)));\\n        }\\n        return this._loadSvgIconFromConfig(new SvgIconConfig(url))\\n            .do(function (svg) { return _this._cachedIconsByUrl.set(url, svg); })\\n            .map(function (svg) { return cloneSvg(svg); });\\n    };\\n    /**\\n     * Returns an Observable that produces the icon (as an <svg> DOM element) with the given name\\n     * and namespace. The icon must have been previously registered with addIcon or addIconSet;\\n     * if not, the Observable will throw an error.\\n     *\\n     * @param {?} name Name of the icon to be retrieved.\\n     * @param {?=} namespace Namespace in which to look for the icon.\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.getNamedSvgIcon = function (name, namespace) {\\n        if (namespace === void 0) { namespace = \\'\\'; }\\n        // Return (copy of) cached icon if possible.\\n        var /** @type {?} */ key = iconKey(namespace, name);\\n        if (this._svgIconConfigs.has(key)) {\\n            return this._getSvgFromConfig(this._svgIconConfigs.get(key));\\n        }\\n        // See if we have any icon sets registered for the namespace.\\n        var /** @type {?} */ iconSetConfigs = this._iconSetConfigs.get(namespace);\\n        if (iconSetConfigs) {\\n            return this._getSvgFromIconSetConfigs(name, iconSetConfigs);\\n        }\\n        return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].throw(getMdIconNameNotFoundError(key));\\n    };\\n    /**\\n     * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.\\n     * @param {?} config\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._getSvgFromConfig = function (config) {\\n        if (config.svgElement) {\\n            // We already have the SVG element for this icon, return a copy.\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].of(cloneSvg(config.svgElement));\\n        }\\n        else {\\n            // Fetch the icon from the config\\'s URL, cache it, and return a copy.\\n            return this._loadSvgIconFromConfig(config)\\n                .do(function (svg) { return config.svgElement = svg; })\\n                .map(function (svg) { return cloneSvg(svg); });\\n        }\\n    };\\n    /**\\n     * Attempts to find an icon with the specified name in any of the SVG icon sets.\\n     * First searches the available cached icons for a nested element with a matching name, and\\n     * if found copies the element to a new <svg> element. If not found, fetches all icon sets\\n     * that have not been cached, and searches again after all fetches are completed.\\n     * The returned Observable produces the SVG element if possible, and throws\\n     * an error if no icon with the specified name can be found.\\n     * @param {?} name\\n     * @param {?} iconSetConfigs\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._getSvgFromIconSetConfigs = function (name, iconSetConfigs) {\\n        var _this = this;\\n        // For all the icon set SVG elements we\\'ve fetched, see if any contain an icon with the\\n        // requested name.\\n        var /** @type {?} */ namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\\n        if (namedIcon) {\\n            // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every\\n            // time anyway, there\\'s probably not much advantage compared to just always extracting\\n            // it from the icon set.\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].of(namedIcon);\\n        }\\n        // Not found in any cached icon sets. If there are icon sets with URLs that we haven\\'t\\n        // fetched, fetch them now and look for iconName in the results.\\n        var /** @type {?} */ iconSetFetchRequests = iconSetConfigs\\n            .filter(function (iconSetConfig) { return !iconSetConfig.svgElement; })\\n            .map(function (iconSetConfig) { return _this._loadSvgIconSetFromConfig(iconSetConfig)\\n            .catch(function (err, caught) {\\n            var /** @type {?} */ url = _this._sanitizer.sanitize(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].RESOURCE_URL, iconSetConfig.url);\\n            // Swallow errors fetching individual URLs so the combined Observable won\\'t\\n            // necessarily fail.\\n            console.log(\"Loading icon set URL: \" + url + \" failed: \" + err);\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].of(null);\\n        })\\n            .do(function (svg) {\\n            // Cache SVG element.\\n            if (svg) {\\n                iconSetConfig.svgElement = svg;\\n            }\\n        }); });\\n        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a\\n        // cached SVG element (unless the request failed), and we can check again for the icon.\\n        return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].forkJoin(iconSetFetchRequests)\\n            .map(function (ignoredResults) {\\n            var /** @type {?} */ foundIcon = _this._extractIconWithNameFromAnySet(name, iconSetConfigs);\\n            if (!foundIcon) {\\n                throw getMdIconNameNotFoundError(name);\\n            }\\n            return foundIcon;\\n        });\\n    };\\n    /**\\n     * Searches the cached SVG elements for the given icon sets for a nested icon element whose \"id\"\\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\\n     * returns it. Returns null if no matching element is found.\\n     * @param {?} iconName\\n     * @param {?} iconSetConfigs\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._extractIconWithNameFromAnySet = function (iconName, iconSetConfigs) {\\n        // Iterate backwards, so icon sets added later have precedence.\\n        for (var /** @type {?} */ i = iconSetConfigs.length - 1; i >= 0; i--) {\\n            var /** @type {?} */ config = iconSetConfigs[i];\\n            if (config.svgElement) {\\n                var /** @type {?} */ foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName);\\n                if (foundIcon) {\\n                    return foundIcon;\\n                }\\n            }\\n        }\\n        return null;\\n    };\\n    /**\\n     * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element\\n     * from it.\\n     * @param {?} config\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._loadSvgIconFromConfig = function (config) {\\n        var _this = this;\\n        return this._fetchUrl(config.url)\\n            .map(function (svgText) { return _this._createSvgElementForSingleIcon(svgText); });\\n    };\\n    /**\\n     * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element\\n     * from it.\\n     * @param {?} config\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._loadSvgIconSetFromConfig = function (config) {\\n        var _this = this;\\n        // TODO: Document that icons should only be loaded from trusted sources.\\n        return this._fetchUrl(config.url)\\n            .map(function (svgText) { return _this._svgElementFromString(svgText); });\\n    };\\n    /**\\n     * Creates a DOM element from the given SVG string, and adds default attributes.\\n     * @param {?} responseText\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._createSvgElementForSingleIcon = function (responseText) {\\n        var /** @type {?} */ svg = this._svgElementFromString(responseText);\\n        this._setSvgAttributes(svg);\\n        return svg;\\n    };\\n    /**\\n     * Searches the cached element of the given SvgIconConfig for a nested icon element whose \"id\"\\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\\n     * returns it. Returns null if no matching element is found.\\n     * @param {?} iconSet\\n     * @param {?} iconName\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._extractSvgIconFromSet = function (iconSet, iconName) {\\n        var /** @type {?} */ iconNode = iconSet.querySelector(\\'#\\' + iconName);\\n        if (!iconNode) {\\n            return null;\\n        }\\n        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as\\n        // the content of a new <svg> node.\\n        if (iconNode.tagName.toLowerCase() === \\'svg\\') {\\n            return this._setSvgAttributes(/** @type {?} */ (iconNode.cloneNode(true)));\\n        }\\n        // If the node is a <symbol>, it won\\'t be rendered so we have to convert it into <svg>. Note\\n        // that the same could be achieved by referring to it via <use href=\"#id\">, however the <use>\\n        // tag is problematic on Firefox, because it needs to include the current page path.\\n        if (iconNode.nodeName.toLowerCase() === \\'symbol\\') {\\n            return this._setSvgAttributes(this._toSvgElement(iconNode));\\n        }\\n        // createElement(\\'SVG\\') doesn\\'t work as expected; the DOM ends up with\\n        // the correct nodes, but the SVG content doesn\\'t render. Instead we\\n        // have to create an empty SVG node using innerHTML and append its content.\\n        // Elements created using DOMParser.parseFromString have the same problem.\\n        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display\\n        var /** @type {?} */ svg = this._svgElementFromString(\\'<svg></svg>\\');\\n        // Clone the node so we don\\'t remove it from the parent icon set element.\\n        svg.appendChild(iconNode.cloneNode(true));\\n        return this._setSvgAttributes(svg);\\n    };\\n    /**\\n     * Creates a DOM element from the given SVG string.\\n     * @param {?} str\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._svgElementFromString = function (str) {\\n        // TODO: Is there a better way than innerHTML? Renderer doesn\\'t appear to have a method for\\n        // creating an element from an HTML string.\\n        var /** @type {?} */ div = document.createElement(\\'DIV\\');\\n        div.innerHTML = str;\\n        var /** @type {?} */ svg = (div.querySelector(\\'svg\\'));\\n        if (!svg) {\\n            throw new Error(\\'<svg> tag not found\\');\\n        }\\n        return svg;\\n    };\\n    /**\\n     * Converts an element into an SVG node by cloning all of its children.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._toSvgElement = function (element) {\\n        var /** @type {?} */ svg = this._svgElementFromString(\\'<svg></svg>\\');\\n        for (var /** @type {?} */ i = 0; i < element.childNodes.length; i++) {\\n            if (element.childNodes[i].nodeType === Node.ELEMENT_NODE) {\\n                svg.appendChild(element.childNodes[i].cloneNode(true));\\n            }\\n        }\\n        return svg;\\n    };\\n    /**\\n     * Sets the default attributes for an SVG element to be used as an icon.\\n     * @param {?} svg\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._setSvgAttributes = function (svg) {\\n        if (!svg.getAttribute(\\'xmlns\\')) {\\n            svg.setAttribute(\\'xmlns\\', \\'http://www.w3.org/2000/svg\\');\\n        }\\n        svg.setAttribute(\\'fit\\', \\'\\');\\n        svg.setAttribute(\\'height\\', \\'100%\\');\\n        svg.setAttribute(\\'width\\', \\'100%\\');\\n        svg.setAttribute(\\'preserveAspectRatio\\', \\'xMidYMid meet\\');\\n        svg.setAttribute(\\'focusable\\', \\'false\\'); // Disable IE11 default behavior to make SVGs focusable.\\n        return svg;\\n    };\\n    /**\\n     * Returns an Observable which produces the string contents of the given URL. Results may be\\n     * cached, so future calls with the same URL may not cause another HTTP request.\\n     * @param {?} safeUrl\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._fetchUrl = function (safeUrl) {\\n        var _this = this;\\n        if (!this._http) {\\n            throw getMdIconNoHttpProviderError();\\n        }\\n        var /** @type {?} */ url = this._sanitizer.sanitize(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].RESOURCE_URL, safeUrl);\\n        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is\\n        // already a request in progress for that URL. It\\'s necessary to call share() on the\\n        // Observable returned by http.get() so that multiple subscribers don\\'t cause multiple XHRs.\\n        if (this._inProgressUrlFetches.has(url)) {\\n            return this._inProgressUrlFetches.get(url);\\n        }\\n        // TODO(jelbourn): for some reason, the `finally` operator \"loses\" the generic type on the\\n        // Observable. Figure out why and fix it.\\n        var /** @type {?} */ req = (this._http.get(url)\\n            .map(function (response) { return response.text(); })\\n            .finally(function () {\\n            _this._inProgressUrlFetches.delete(url);\\n        })\\n            .share());\\n        this._inProgressUrlFetches.set(url, req);\\n        return req;\\n    };\\n    return MdIconRegistry;\\n}());\\nMdIconRegistry.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdIconRegistry.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_17__angular_http__[\"Http\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__[\"DomSanitizer\"], },\\n]; };\\n/**\\n * @param {?} parentRegistry\\n * @param {?} http\\n * @param {?} sanitizer\\n * @return {?}\\n */\\nfunction ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, http, sanitizer) {\\n    return parentRegistry || new MdIconRegistry(http, sanitizer);\\n}\\nvar ICON_REGISTRY_PROVIDER = {\\n    // If there is already an MdIconRegistry available, use that. Otherwise, provide a new one.\\n    provide: MdIconRegistry,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), MdIconRegistry], [new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), __WEBPACK_IMPORTED_MODULE_17__angular_http__[\"Http\"]], __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__[\"DomSanitizer\"]],\\n    useFactory: ICON_REGISTRY_PROVIDER_FACTORY\\n};\\n/**\\n * Clones an SVGElement while preserving type information.\\n * @param {?} svg\\n * @return {?}\\n */\\nfunction cloneSvg(svg) {\\n    return (svg.cloneNode(true));\\n}\\n/**\\n * Returns the cache key to use for an icon namespace and name.\\n * @param {?} namespace\\n * @param {?} name\\n * @return {?}\\n */\\nfunction iconKey(namespace, name) {\\n    return namespace + \\':\\' + name;\\n}\\n/**\\n * Component to display an icon. It can be used in the following ways:\\n * - Specify the svgSrc input to load an SVG icon from a URL. The SVG content is directly inlined\\n *   as a child of the <md-icon> component, so that CSS styles can easily be applied to it.\\n *   The URL is loaded via an XMLHttpRequest, so it must be on the same domain as the page or its\\n *   server must be configured to allow cross-domain requests.\\n *   Example:\\n *     <md-icon svgSrc=\"assets/arrow.svg\"></md-icon>\\n *\\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\\n *   MdIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\\n *   Examples:\\n *     <md-icon svgIcon=\"left-arrow\"></md-icon>\\n *     <md-icon svgIcon=\"animals:cat\"></md-icon>\\n *\\n * - Use a font ligature as an icon by putting the ligature text in the content of the <md-icon>\\n *   component. By default the Material icons font is used as described at\\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\\n *   desired font, or to an alias previously registered with MdIconRegistry.registerFontClassAlias.\\n *   Examples:\\n *     <md-icon>home</md-icon>\\n *     <md-icon fontSet=\"myfont\">sun</md-icon>\\n *\\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\\n *   https://fortawesome.github.io/Font-Awesome/examples/\\n *   Example:\\n *     <md-icon fontSet=\"fa\" fontIcon=\"alarm\"></md-icon>\\n */\\nvar MdIcon = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     * @param {?} _mdIconRegistry\\n     */\\n    function MdIcon(_elementRef, _renderer, _mdIconRegistry) {\\n        this._elementRef = _elementRef;\\n        this._renderer = _renderer;\\n        this._mdIconRegistry = _mdIconRegistry;\\n        /**\\n         * Screenreader label for the icon.\\n         */\\n        this.hostAriaLabel = \\'\\';\\n    }\\n    Object.defineProperty(MdIcon.prototype, \"color\", {\\n        /**\\n         * Color of the icon.\\n         * @return {?}\\n         */\\n        get: function () { return this._color; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._updateColor(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} newColor\\n     * @return {?}\\n     */\\n    MdIcon.prototype._updateColor = function (newColor) {\\n        this._setElementColor(this._color, false);\\n        this._setElementColor(newColor, true);\\n        this._color = newColor;\\n    };\\n    /**\\n     * @param {?} color\\n     * @param {?} isAdd\\n     * @return {?}\\n     */\\n    MdIcon.prototype._setElementColor = function (color, isAdd) {\\n        if (color != null && color != \\'\\') {\\n            if (isAdd) {\\n                this._renderer.addClass(this._elementRef.nativeElement, \"mat-\" + color);\\n            }\\n            else {\\n                this._renderer.removeClass(this._elementRef.nativeElement, \"mat-\" + color);\\n            }\\n        }\\n    };\\n    /**\\n     * Splits an svgIcon binding value into its icon set and icon name components.\\n     * Returns a 2-element array of [(icon set), (icon name)].\\n     * The separator for the two fields is \\':\\'. If there is no separator, an empty\\n     * string is returned for the icon set and the entire value is returned for\\n     * the icon name. If the argument is falsy, returns an array of two empty strings.\\n     * Throws an error if the name contains two or more \\':\\' separators.\\n     * Examples:\\n     *   \\'social:cake\\' -> [\\'social\\', \\'cake\\']\\n     *   \\'penguin\\' -> [\\'\\', \\'penguin\\']\\n     *   null -> [\\'\\', \\'\\']\\n     *   \\'a:b:c\\' -> (throws Error)\\n     * @param {?} iconName\\n     * @return {?}\\n     */\\n    MdIcon.prototype._splitIconName = function (iconName) {\\n        if (!iconName) {\\n            return [\\'\\', \\'\\'];\\n        }\\n        var /** @type {?} */ parts = iconName.split(\\':\\');\\n        switch (parts.length) {\\n            case 1:\\n                // Use default namespace.\\n                return [\\'\\', parts[0]];\\n            case 2:\\n                return (parts);\\n            default:\\n                throw new Error(\"Invalid icon name: \\\\\"\" + iconName + \"\\\\\"\");\\n        }\\n    };\\n    /**\\n     * @param {?} changes\\n     * @return {?}\\n     */\\n    MdIcon.prototype.ngOnChanges = function (changes) {\\n        var _this = this;\\n        var /** @type {?} */ changedInputs = Object.keys(changes);\\n        // Only update the inline SVG icon if the inputs changed, to avoid unnecessary DOM operations.\\n        if (changedInputs.indexOf(\\'svgIcon\\') != -1 || changedInputs.indexOf(\\'svgSrc\\') != -1) {\\n            if (this.svgIcon) {\\n                var _a = this._splitIconName(this.svgIcon), namespace = _a[0], iconName = _a[1];\\n                this._mdIconRegistry.getNamedSvgIcon(iconName, namespace).first().subscribe(function (svg) { return _this._setSvgElement(svg); }, function (err) { return console.log(\"Error retrieving icon: \" + err.message); });\\n            }\\n        }\\n        if (this._usingFontIcon()) {\\n            this._updateFontIconClasses();\\n        }\\n        this._updateAriaLabel();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdIcon.prototype.ngOnInit = function () {\\n        // Update font classes because ngOnChanges won\\'t be called if none of the inputs are present,\\n        // e.g. <md-icon>arrow</md-icon>. In this case we need to add a CSS class for the default font.\\n        if (this._usingFontIcon()) {\\n            this._updateFontIconClasses();\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdIcon.prototype.ngAfterViewChecked = function () {\\n        // Update aria label here because it may depend on the projected text content.\\n        // (e.g. <md-icon>home</md-icon> should use \\'home\\').\\n        this._updateAriaLabel();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdIcon.prototype._updateAriaLabel = function () {\\n        var /** @type {?} */ ariaLabel = this._getAriaLabel();\\n        if (ariaLabel && ariaLabel !== this._previousAriaLabel) {\\n            this._previousAriaLabel = ariaLabel;\\n            this._renderer.setAttribute(this._elementRef.nativeElement, \\'aria-label\\', ariaLabel);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdIcon.prototype._getAriaLabel = function () {\\n        // If the parent provided an aria-label attribute value, use it as-is. Otherwise look for a\\n        // reasonable value from the alt attribute, font icon name, SVG icon name, or (for ligatures)\\n        // the text content of the directive.\\n        var /** @type {?} */ label = this.hostAriaLabel ||\\n            this.alt ||\\n            this.fontIcon ||\\n            this._splitIconName(this.svgIcon)[1];\\n        if (label) {\\n            return label;\\n        }\\n        // The \"content\" of an SVG icon is not a useful label.\\n        if (this._usingFontIcon()) {\\n            var /** @type {?} */ text = this._elementRef.nativeElement.textContent;\\n            if (text) {\\n                return text;\\n            }\\n        }\\n        // TODO: Warn here in dev mode.\\n        return null;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdIcon.prototype._usingFontIcon = function () {\\n        return !this.svgIcon;\\n    };\\n    /**\\n     * @param {?} svg\\n     * @return {?}\\n     */\\n    MdIcon.prototype._setSvgElement = function (svg) {\\n        var /** @type {?} */ layoutElement = this._elementRef.nativeElement;\\n        // Remove existing child nodes and add the new SVG element.\\n        // We would use renderer.detachView(Array.from(layoutElement.childNodes)) here,\\n        // but it fails in IE11: https://github.com/angular/angular/issues/6327\\n        layoutElement.innerHTML = \\'\\';\\n        this._renderer.appendChild(layoutElement, svg);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdIcon.prototype._updateFontIconClasses = function () {\\n        if (!this._usingFontIcon()) {\\n            return;\\n        }\\n        var /** @type {?} */ elem = this._elementRef.nativeElement;\\n        var /** @type {?} */ fontSetClass = this.fontSet ?\\n            this._mdIconRegistry.classNameForFontAlias(this.fontSet) :\\n            this._mdIconRegistry.getDefaultFontSetClass();\\n        if (fontSetClass != this._previousFontSetClass) {\\n            if (this._previousFontSetClass) {\\n                this._renderer.removeClass(elem, this._previousFontSetClass);\\n            }\\n            if (fontSetClass) {\\n                this._renderer.addClass(elem, fontSetClass);\\n            }\\n            this._previousFontSetClass = fontSetClass;\\n        }\\n        if (this.fontIcon != this._previousFontIconClass) {\\n            if (this._previousFontIconClass) {\\n                this._renderer.removeClass(elem, this._previousFontIconClass);\\n            }\\n            if (this.fontIcon) {\\n                this._renderer.addClass(elem, this.fontIcon);\\n            }\\n            this._previousFontIconClass = this.fontIcon;\\n        }\\n    };\\n    return MdIcon;\\n}());\\nMdIcon.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ template: \\'<ng-content></ng-content>\\',\\n                selector: \\'md-icon, mat-icon\\',\\n                styles: [\".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px} /*# sourceMappingURL=icon.css.map */ \"],\\n                host: {\\n                    \\'role\\': \\'img\\',\\n                    \\'[class.mat-icon]\\': \\'true\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdIcon.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: MdIconRegistry, },\\n]; };\\nMdIcon.propDecorators = {\\n    \\'svgIcon\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'fontSet\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'fontIcon\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'alt\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'hostAriaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdIconModule = /*@__PURE__*/(function () {\\n    function MdIconModule() {\\n    }\\n    return MdIconModule;\\n}());\\nMdIconModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule],\\n                exports: [MdIcon, MdCommonModule],\\n                declarations: [MdIcon],\\n                providers: [ICON_REGISTRY_PROVIDER],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdIconModule.ctorParameters = function () { return []; };\\n/**\\n * A single degree in radians.\\n */\\nvar DEGREE_IN_RADIANS = Math.PI / 180;\\n/**\\n * Duration of the indeterminate animation.\\n */\\nvar DURATION_INDETERMINATE = 667;\\n/**\\n * Duration of the indeterminate animation.\\n */\\nvar DURATION_DETERMINATE = 225;\\n/**\\n * Start animation value of the indeterminate animation\\n */\\nvar startIndeterminate = 3;\\n/**\\n * End animation value of the indeterminate animation\\n */\\nvar endIndeterminate = 80;\\n/**\\n * Maximum angle for the arc. The angle can\\'t be exactly 360, because the arc becomes hidden.\\n */\\nvar MAX_ANGLE = 359.99 / 100;\\n/**\\n * Whether the user\\'s browser supports requestAnimationFrame.\\n */\\nvar HAS_RAF = typeof requestAnimationFrame !== \\'undefined\\';\\n/**\\n * Default stroke width as a percentage of the viewBox.\\n */\\nvar PROGRESS_SPINNER_STROKE_WIDTH = 10;\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdProgressSpinnerCssMatStyler = /*@__PURE__*/(function () {\\n    function MdProgressSpinnerCssMatStyler() {\\n    }\\n    return MdProgressSpinnerCssMatStyler;\\n}());\\nMdProgressSpinnerCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-progress-spinner, mat-progress-spinner\\',\\n                host: {\\n                    \\'[class.mat-progress-spinner]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdProgressSpinnerCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * <md-progress-spinner> component.\\n */\\nvar MdProgressSpinner = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _ngZone\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     */\\n    function MdProgressSpinner(_ngZone, _elementRef, _renderer) {\\n        this._ngZone = _ngZone;\\n        this._elementRef = _elementRef;\\n        this._renderer = _renderer;\\n        /**\\n         * The id of the last requested animation.\\n         */\\n        this._lastAnimationId = 0;\\n        this._mode = \\'determinate\\';\\n        this._color = \\'primary\\';\\n        /**\\n         * Stroke width of the progress spinner. By default uses 10px as stroke width.\\n         */\\n        this.strokeWidth = PROGRESS_SPINNER_STROKE_WIDTH;\\n    }\\n    Object.defineProperty(MdProgressSpinner.prototype, \"_ariaValueMin\", {\\n        /**\\n         * Values for aria max and min are only defined as numbers when in a determinate mode.  We do this\\n         * because voiceover does not report the progress indicator as indeterminate if the aria min\\n         * and/or max value are number values.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.mode == \\'determinate\\' ? 0 : null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdProgressSpinner.prototype, \"_ariaValueMax\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.mode == \\'determinate\\' ? 100 : null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdProgressSpinner.prototype, \"interdeterminateInterval\", {\\n        /**\\n         * \\\\@docs-private\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._interdeterminateInterval;\\n        },\\n        /**\\n         * \\\\@docs-private\\n         * @param {?} interval\\n         * @return {?}\\n         */\\n        set: function (interval) {\\n            clearInterval(this._interdeterminateInterval);\\n            this._interdeterminateInterval = interval;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Clean up any animations that were running.\\n     * @return {?}\\n     */\\n    MdProgressSpinner.prototype.ngOnDestroy = function () {\\n        this._cleanupIndeterminateAnimation();\\n    };\\n    Object.defineProperty(MdProgressSpinner.prototype, \"color\", {\\n        /**\\n         * The color of the progress-spinner. Can be primary, accent, or warn.\\n         * @return {?}\\n         */\\n        get: function () { return this._color; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value) {\\n                this._renderer.removeClass(this._elementRef.nativeElement, \"mat-\" + this._color);\\n                this._renderer.addClass(this._elementRef.nativeElement, \"mat-\" + value);\\n                this._color = value;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdProgressSpinner.prototype, \"value\", {\\n        /**\\n         * Value of the progress circle. It is bound to the host as the attribute aria-valuenow.\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (this.mode == \\'determinate\\') {\\n                return this._value;\\n            }\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            if (v != null && this.mode == \\'determinate\\') {\\n                var /** @type {?} */ newValue = clamp(v);\\n                this._animateCircle(this.value || 0, newValue);\\n                this._value = newValue;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdProgressSpinner.prototype, \"mode\", {\\n        /**\\n         * Mode of the progress circle\\n         *\\n         * Input must be one of the values from ProgressMode, defaults to \\'determinate\\'.\\n         * mode is bound to the host as the attribute host.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._mode;\\n        },\\n        /**\\n         * @param {?} mode\\n         * @return {?}\\n         */\\n        set: function (mode) {\\n            if (mode !== this._mode) {\\n                if (mode === \\'indeterminate\\') {\\n                    this._startIndeterminateAnimation();\\n                }\\n                else {\\n                    this._cleanupIndeterminateAnimation();\\n                    this._animateCircle(0, this._value);\\n                }\\n                this._mode = mode;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Animates the circle from one percentage value to another.\\n     *\\n     * @param {?} animateFrom The percentage of the circle filled starting the animation.\\n     * @param {?} animateTo The percentage of the circle filled ending the animation.\\n     * @param {?=} ease The easing function to manage the pace of change in the animation.\\n     * @param {?=} duration The length of time to show the animation, in milliseconds.\\n     * @param {?=} rotation The starting angle of the circle fill, with 0 represented at the top center\\n     *    of the circle.\\n     * @return {?}\\n     */\\n    MdProgressSpinner.prototype._animateCircle = function (animateFrom, animateTo, ease, duration, rotation) {\\n        var _this = this;\\n        if (ease === void 0) { ease = linearEase; }\\n        if (duration === void 0) { duration = DURATION_DETERMINATE; }\\n        if (rotation === void 0) { rotation = 0; }\\n        var /** @type {?} */ id = ++this._lastAnimationId;\\n        var /** @type {?} */ startTime = Date.now();\\n        var /** @type {?} */ changeInValue = animateTo - animateFrom;\\n        // No need to animate it if the values are the same\\n        if (animateTo === animateFrom) {\\n            this._renderArc(animateTo, rotation);\\n        }\\n        else {\\n            var /** @type {?} */ animation_1 = function () {\\n                // If there is no requestAnimationFrame, skip ahead to the end of the animation.\\n                var /** @type {?} */ elapsedTime = HAS_RAF ?\\n                    Math.max(0, Math.min(Date.now() - startTime, duration)) :\\n                    duration;\\n                _this._renderArc(ease(elapsedTime, animateFrom, changeInValue, duration), rotation);\\n                // Prevent overlapping animations by checking if a new animation has been called for and\\n                // if the animation has lasted longer than the animation duration.\\n                if (id === _this._lastAnimationId && elapsedTime < duration) {\\n                    requestAnimationFrame(animation_1);\\n                }\\n            };\\n            // Run the animation outside of Angular\\'s zone, in order to avoid\\n            // hitting ZoneJS and change detection on each frame.\\n            this._ngZone.runOutsideAngular(animation_1);\\n        }\\n    };\\n    /**\\n     * Starts the indeterminate animation interval, if it is not already running.\\n     * @return {?}\\n     */\\n    MdProgressSpinner.prototype._startIndeterminateAnimation = function () {\\n        var _this = this;\\n        var /** @type {?} */ rotationStartPoint = 0;\\n        var /** @type {?} */ start = startIndeterminate;\\n        var /** @type {?} */ end = endIndeterminate;\\n        var /** @type {?} */ duration = DURATION_INDETERMINATE;\\n        var /** @type {?} */ animate$$1 = function () {\\n            _this._animateCircle(start, end, materialEase, duration, rotationStartPoint);\\n            // Prevent rotation from reaching Number.MAX_SAFE_INTEGER.\\n            rotationStartPoint = (rotationStartPoint + end) % 100;\\n            var /** @type {?} */ temp = start;\\n            start = -end;\\n            end = -temp;\\n        };\\n        if (!this.interdeterminateInterval) {\\n            this._ngZone.runOutsideAngular(function () {\\n                _this.interdeterminateInterval = setInterval(animate$$1, duration + 50, 0, false);\\n                animate$$1();\\n            });\\n        }\\n    };\\n    /**\\n     * Removes interval, ending the animation.\\n     * @return {?}\\n     */\\n    MdProgressSpinner.prototype._cleanupIndeterminateAnimation = function () {\\n        this.interdeterminateInterval = null;\\n    };\\n    /**\\n     * Renders the arc onto the SVG element. Proxies `getArc` while setting the proper\\n     * DOM attribute on the `<path>`.\\n     * @param {?} currentValue\\n     * @param {?=} rotation\\n     * @return {?}\\n     */\\n    MdProgressSpinner.prototype._renderArc = function (currentValue, rotation) {\\n        if (rotation === void 0) { rotation = 0; }\\n        if (this._path) {\\n            var /** @type {?} */ svgArc = getSvgArc(currentValue, rotation, this.strokeWidth);\\n            this._renderer.setAttribute(this._path.nativeElement, \\'d\\', svgArc);\\n        }\\n    };\\n    return MdProgressSpinner;\\n}());\\nMdProgressSpinner.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-progress-spinner, mat-progress-spinner\\',\\n                host: {\\n                    \\'role\\': \\'progressbar\\',\\n                    \\'[attr.aria-valuemin]\\': \\'_ariaValueMin\\',\\n                    \\'[attr.aria-valuemax]\\': \\'_ariaValueMax\\'\\n                },\\n                template: \"\\x3c!-- preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle\\'s center. The center of the circle will remain at the center of the md-progress-spinner element containing the SVG. --\\x3e <svg viewBox=\\\\\"0 0 100 100\\\\\" preserveAspectRatio=\\\\\"xMidYMid meet\\\\\"> <path #path [style.strokeWidth]=\\\\\"strokeWidth\\\\\"></path> </svg> \",\\n                styles: [\":host{display:block;height:100px;width:100px;overflow:hidden}:host svg{height:100%;width:100%;transform-origin:center}:host path{fill:transparent;transition:stroke .3s cubic-bezier(.35,0,.25,1)}:host[mode=indeterminate] svg{animation-duration:5.25s,2.887s;animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;animation-timing-function:cubic-bezier(.35,0,.25,1),linear;animation-iteration-count:infinite;transition:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-sporadic-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}} /*# sourceMappingURL=progress-spinner.css.map */ \"],\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdProgressSpinner.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\nMdProgressSpinner.propDecorators = {\\n    \\'_path\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'path\\',] },],\\n    \\'strokeWidth\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'attr.aria-valuenow\\',] },],\\n    \\'mode\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'attr.mode\\',] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * <md-spinner> component.\\n *\\n * This is a component definition to be used as a convenience reference to create an\\n * indeterminate <md-progress-spinner> instance.\\n */\\nvar MdSpinner = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdSpinner, _super);\\n    /**\\n     * @param {?} elementRef\\n     * @param {?} ngZone\\n     * @param {?} renderer\\n     */\\n    function MdSpinner(elementRef, ngZone, renderer) {\\n        var _this = _super.call(this, ngZone, elementRef, renderer) || this;\\n        _this.mode = \\'indeterminate\\';\\n        return _this;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdSpinner.prototype.ngOnDestroy = function () {\\n        // The `ngOnDestroy` from `MdProgressSpinner` should be called explicitly, because\\n        // in certain cases Angular won\\'t call it (e.g. when using AoT and in unit tests).\\n        _super.prototype.ngOnDestroy.call(this);\\n    };\\n    return MdSpinner;\\n}(MdProgressSpinner));\\nMdSpinner.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-spinner, mat-spinner\\',\\n                host: {\\n                    \\'role\\': \\'progressbar\\',\\n                    \\'mode\\': \\'indeterminate\\',\\n                    \\'[class.mat-spinner]\\': \\'true\\',\\n                },\\n                template: \"\\x3c!-- preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle\\'s center. The center of the circle will remain at the center of the md-progress-spinner element containing the SVG. --\\x3e <svg viewBox=\\\\\"0 0 100 100\\\\\" preserveAspectRatio=\\\\\"xMidYMid meet\\\\\"> <path #path [style.strokeWidth]=\\\\\"strokeWidth\\\\\"></path> </svg> \",\\n                styles: [\":host{display:block;height:100px;width:100px;overflow:hidden}:host svg{height:100%;width:100%;transform-origin:center}:host path{fill:transparent;transition:stroke .3s cubic-bezier(.35,0,.25,1)}:host[mode=indeterminate] svg{animation-duration:5.25s,2.887s;animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;animation-timing-function:cubic-bezier(.35,0,.25,1),linear;animation-iteration-count:infinite;transition:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-sporadic-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}} /*# sourceMappingURL=progress-spinner.css.map */ \"],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSpinner.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\n/**\\n * Clamps a value to be between 0 and 100.\\n * @param {?} v\\n * @return {?}\\n */\\nfunction clamp(v) {\\n    return Math.max(0, Math.min(100, v));\\n}\\n/**\\n * Converts Polar coordinates to Cartesian.\\n * @param {?} radius\\n * @param {?} pathRadius\\n * @param {?} angleInDegrees\\n * @return {?}\\n */\\nfunction polarToCartesian(radius, pathRadius, angleInDegrees) {\\n    var /** @type {?} */ angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;\\n    return (radius + (pathRadius * Math.cos(angleInRadians))) +\\n        \\',\\' + (radius + (pathRadius * Math.sin(angleInRadians)));\\n}\\n/**\\n * Easing function for linear animation.\\n * @param {?} currentTime\\n * @param {?} startValue\\n * @param {?} changeInValue\\n * @param {?} duration\\n * @return {?}\\n */\\nfunction linearEase(currentTime, startValue, changeInValue, duration) {\\n    return changeInValue * currentTime / duration + startValue;\\n}\\n/**\\n * Easing function to match material design indeterminate animation.\\n * @param {?} currentTime\\n * @param {?} startValue\\n * @param {?} changeInValue\\n * @param {?} duration\\n * @return {?}\\n */\\nfunction materialEase(currentTime, startValue, changeInValue, duration) {\\n    var /** @type {?} */ time = currentTime / duration;\\n    var /** @type {?} */ timeCubed = Math.pow(time, 3);\\n    var /** @type {?} */ timeQuad = Math.pow(time, 4);\\n    var /** @type {?} */ timeQuint = Math.pow(time, 5);\\n    return startValue + changeInValue * ((6 * timeQuint) + (-15 * timeQuad) + (10 * timeCubed));\\n}\\n/**\\n * Determines the path value to define the arc.  Converting percentage values to to polar\\n * coordinates on the circle, and then to cartesian coordinates in the viewport.\\n *\\n * @param {?} currentValue The current percentage value of the progress circle, the percentage of the\\n *    circle to fill.\\n * @param {?} rotation The starting point of the circle with 0 being the 0 degree point.\\n * @param {?} strokeWidth Stroke width of the progress spinner arc.\\n * @return {?} A string for an SVG path representing a circle filled from the starting point to the\\n *    percentage value provided.\\n */\\nfunction getSvgArc(currentValue, rotation, strokeWidth) {\\n    var /** @type {?} */ startPoint = rotation || 0;\\n    var /** @type {?} */ radius = 50;\\n    var /** @type {?} */ pathRadius = radius - strokeWidth;\\n    var /** @type {?} */ startAngle = startPoint * MAX_ANGLE;\\n    var /** @type {?} */ endAngle = currentValue * MAX_ANGLE;\\n    var /** @type {?} */ start = polarToCartesian(radius, pathRadius, startAngle);\\n    var /** @type {?} */ end = polarToCartesian(radius, pathRadius, endAngle + startAngle);\\n    var /** @type {?} */ arcSweep = endAngle < 0 ? 0 : 1;\\n    var /** @type {?} */ largeArcFlag;\\n    if (endAngle < 0) {\\n        largeArcFlag = endAngle >= -180 ? 0 : 1;\\n    }\\n    else {\\n        largeArcFlag = endAngle <= 180 ? 0 : 1;\\n    }\\n    return \"M\" + start + \"A\" + pathRadius + \",\" + pathRadius + \" 0 \" + largeArcFlag + \",\" + arcSweep + \" \" + end;\\n}\\nvar MdProgressSpinnerModule = /*@__PURE__*/(function () {\\n    function MdProgressSpinnerModule() {\\n    }\\n    return MdProgressSpinnerModule;\\n}());\\nMdProgressSpinnerModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule],\\n                exports: [\\n                    MdProgressSpinner,\\n                    MdSpinner,\\n                    MdCommonModule,\\n                    MdProgressSpinnerCssMatStyler\\n                ],\\n                declarations: [\\n                    MdProgressSpinner,\\n                    MdSpinner,\\n                    MdProgressSpinnerCssMatStyler\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdProgressSpinnerModule.ctorParameters = function () { return []; };\\n/**\\n * <md-progress-bar> component.\\n */\\nvar MdProgressBar = /*@__PURE__*/(function () {\\n    function MdProgressBar() {\\n        /**\\n         * Color of the progress bar.\\n         */\\n        this.color = \\'primary\\';\\n        this._value = 0;\\n        this._bufferValue = 0;\\n        /**\\n         * Mode of the progress bar.\\n         *\\n         * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to\\n         * \\'determinate\\'.\\n         * Mirrored to mode attribute.\\n         */\\n        this.mode = \\'determinate\\';\\n    }\\n    Object.defineProperty(MdProgressBar.prototype, \"value\", {\\n        /**\\n         * Value of the progressbar. Defaults to zero. Mirrored to aria-valuenow.\\n         * @return {?}\\n         */\\n        get: function () { return this._value; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this._value = clamp$1(v || 0); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdProgressBar.prototype, \"bufferValue\", {\\n        /**\\n         * Buffer value of the progress bar. Defaults to zero.\\n         * @return {?}\\n         */\\n        get: function () { return this._bufferValue; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this._bufferValue = clamp$1(v || 0); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Gets the current transform value for the progress bar\\'s primary indicator.\\n     * @return {?}\\n     */\\n    MdProgressBar.prototype._primaryTransform = function () {\\n        var /** @type {?} */ scale = this.value / 100;\\n        return { transform: \"scaleX(\" + scale + \")\" };\\n    };\\n    /**\\n     * Gets the current transform value for the progress bar\\'s buffer indicator.  Only used if the\\n     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.\\n     * @return {?}\\n     */\\n    MdProgressBar.prototype._bufferTransform = function () {\\n        if (this.mode == \\'buffer\\') {\\n            var /** @type {?} */ scale = this.bufferValue / 100;\\n            return { transform: \"scaleX(\" + scale + \")\" };\\n        }\\n    };\\n    return MdProgressBar;\\n}());\\nMdProgressBar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-progress-bar, mat-progress-bar\\',\\n                host: {\\n                    \\'role\\': \\'progressbar\\',\\n                    \\'aria-valuemin\\': \\'0\\',\\n                    \\'aria-valuemax\\': \\'100\\',\\n                    \\'[class.mat-primary]\\': \\'color == \"primary\"\\',\\n                    \\'[class.mat-accent]\\': \\'color == \"accent\"\\',\\n                    \\'[class.mat-warn]\\': \\'color == \"warn\"\\',\\n                    \\'[class.mat-progress-bar]\\': \\'true\\',\\n                },\\n                template: \"\\x3c!-- The background div is named as such because it appears below the other divs and is not sized based on values. --\\x3e <div class=\\\\\"mat-progress-bar-background mat-progress-bar-element\\\\\"></div> <div class=\\\\\"mat-progress-bar-buffer mat-progress-bar-element\\\\\" [ngStyle]=\\\\\"_bufferTransform()\\\\\"></div> <div class=\\\\\"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\\\\\" [ngStyle]=\\\\\"_primaryTransform()\\\\\"></div> <div class=\\\\\"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\\\\\"></div> \",\\n                styles: [\":host{display:block;height:5px;overflow:hidden;position:relative;transform:translateZ(0);transition:opacity 250ms linear;width:100%}:host .mat-progress-bar-element,:host .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}:host .mat-progress-bar-background{background-repeat:repeat-x;background-size:10px 4px;display:none}:host .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease,stroke .3s cubic-bezier(.35,0,.25,1)}:host .mat-progress-bar-secondary{display:none}:host .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease,stroke .3s cubic-bezier(.35,0,.25,1)}:host .mat-progress-bar-fill::after{animation:none;content:\\'\\';display:inline-block;left:0}:host[mode=query]{transform:rotateZ(180deg)}:host[mode=indeterminate] .mat-progress-bar-fill,:host[mode=query] .mat-progress-bar-fill{transition:none}:host[mode=indeterminate] .mat-progress-bar-primary,:host[mode=query] .mat-progress-bar-primary{animation:mat-progress-bar-primary-indeterminate-translate 2s infinite linear;left:-145.166611%}:host[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,:host[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{animation:mat-progress-bar-primary-indeterminate-scale 2s infinite linear}:host[mode=indeterminate] .mat-progress-bar-secondary,:host[mode=query] .mat-progress-bar-secondary{animation:mat-progress-bar-secondary-indeterminate-translate 2s infinite linear;left:-54.888891%;display:block}:host[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,:host[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{animation:mat-progress-bar-secondary-indeterminate-scale 2s infinite linear}:host[mode=buffer] .mat-progress-bar-background{animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}:host-context([dir=rtl]){transform:rotateY(180deg)}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(.5,0,.70173,.49582);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);transform:translateX(83.67142%)}100%{transform:translateX(200.61106%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.66148)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:translateX(37.65191%)}48.35%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:translateX(84.38617%)}100%{transform:translateX(160.27778%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:scaleX(.4571)}44.15%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:scaleX(.72796)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-10px)}} /*# sourceMappingURL=progress-bar.css.map */ \"],\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdProgressBar.ctorParameters = function () { return []; };\\nMdProgressBar.propDecorators = {\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'attr.aria-valuenow\\',] },],\\n    \\'bufferValue\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'mode\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'attr.mode\\',] },],\\n};\\n/**\\n * Clamps a value to be between two numbers, by default 0 and 100.\\n * @param {?} v\\n * @param {?=} min\\n * @param {?=} max\\n * @return {?}\\n */\\nfunction clamp$1(v, min, max) {\\n    if (min === void 0) { min = 0; }\\n    if (max === void 0) { max = 100; }\\n    return Math.max(min, Math.min(max, v));\\n}\\nvar MdProgressBarModule = /*@__PURE__*/(function () {\\n    function MdProgressBarModule() {\\n    }\\n    return MdProgressBarModule;\\n}());\\nMdProgressBarModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"], MdCommonModule],\\n                exports: [MdProgressBar, MdCommonModule],\\n                declarations: [MdProgressBar],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdProgressBarModule.ctorParameters = function () { return []; };\\n/**\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdInputContainerPlaceholderConflictError() {\\n    return new Error(\\'Placeholder attribute and child element were both specified.\\');\\n}\\n/**\\n * \\\\@docs-private\\n * @param {?} type\\n * @return {?}\\n */\\nfunction getMdInputContainerUnsupportedTypeError(type) {\\n    return new Error(\"Input type \\\\\"\" + type + \"\\\\\" isn\\'t supported by md-input-container.\");\\n}\\n/**\\n * \\\\@docs-private\\n * @param {?} align\\n * @return {?}\\n */\\nfunction getMdInputContainerDuplicatedHintError(align) {\\n    return new Error(\"A hint was already declared for \\'align=\\\\\"\" + align + \"\\\\\"\\'.\");\\n}\\n/**\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdInputContainerMissingMdInputError() {\\n    return new Error(\\'md-input-container must contain an mdInput directive. \\' +\\n        \\'Did you forget to add mdInput to the native input or textarea element?\\');\\n}\\n// Invalid input type. Using one of these will throw an MdInputContainerUnsupportedTypeError.\\nvar MD_INPUT_INVALID_TYPES = [\\n    \\'button\\',\\n    \\'checkbox\\',\\n    \\'color\\',\\n    \\'file\\',\\n    \\'hidden\\',\\n    \\'image\\',\\n    \\'radio\\',\\n    \\'range\\',\\n    \\'reset\\',\\n    \\'submit\\'\\n];\\nvar nextUniqueId$1 = 0;\\n/**\\n * The placeholder directive. The content can declare this to implement more\\n * complex placeholders.\\n */\\nvar MdPlaceholder = /*@__PURE__*/(function () {\\n    function MdPlaceholder() {\\n    }\\n    return MdPlaceholder;\\n}());\\nMdPlaceholder.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-placeholder, mat-placeholder\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPlaceholder.ctorParameters = function () { return []; };\\n/**\\n * Hint text to be shown underneath the input.\\n */\\nvar MdHint = /*@__PURE__*/(function () {\\n    function MdHint() {\\n        /**\\n         * Whether to align the hint label at the start or end of the line.\\n         */\\n        this.align = \\'start\\';\\n        /**\\n         * Unique ID for the hint. Used for the aria-describedby on the input.\\n         */\\n        this.id = \"md-input-hint-\" + nextUniqueId$1++;\\n    }\\n    return MdHint;\\n}());\\nMdHint.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-hint, mat-hint\\',\\n                host: {\\n                    \\'[class.mat-hint]\\': \\'true\\',\\n                    \\'[class.mat-right]\\': \\'align == \"end\"\\',\\n                    \\'[attr.id]\\': \\'id\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdHint.ctorParameters = function () { return []; };\\nMdHint.propDecorators = {\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Single error message to be shown underneath the input.\\n */\\nvar MdErrorDirective = /*@__PURE__*/(function () {\\n    function MdErrorDirective() {\\n    }\\n    return MdErrorDirective;\\n}());\\nMdErrorDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-error, mat-error\\',\\n                host: {\\n                    \\'[class.mat-input-error]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdErrorDirective.ctorParameters = function () { return []; };\\n/**\\n * Prefix to be placed the the front of the input.\\n */\\nvar MdPrefix = /*@__PURE__*/(function () {\\n    function MdPrefix() {\\n    }\\n    return MdPrefix;\\n}());\\nMdPrefix.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[mdPrefix], [matPrefix], [md-prefix]\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPrefix.ctorParameters = function () { return []; };\\n/**\\n * Suffix to be placed at the end of the input.\\n */\\nvar MdSuffix = /*@__PURE__*/(function () {\\n    function MdSuffix() {\\n    }\\n    return MdSuffix;\\n}());\\nMdSuffix.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[mdSuffix], [matSuffix], [md-suffix]\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSuffix.ctorParameters = function () { return []; };\\n/**\\n * Marker for the input element that `MdInputContainer` is wrapping.\\n */\\nvar MdInputDirective = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     * @param {?} _ngControl\\n     */\\n    function MdInputDirective(_elementRef, _renderer, _ngControl) {\\n        this._elementRef = _elementRef;\\n        this._renderer = _renderer;\\n        this._ngControl = _ngControl;\\n        /**\\n         * Variables used as cache for getters and setters.\\n         */\\n        this._type = \\'text\\';\\n        this._placeholder = \\'\\';\\n        this._disabled = false;\\n        this._required = false;\\n        /**\\n         * Whether the element is focused or not.\\n         */\\n        this.focused = false;\\n        /**\\n         * Emits an event when the placeholder changes so that the `md-input-container` can re-validate.\\n         */\\n        this._placeholderChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        this._neverEmptyInputTypes = [\\n            \\'date\\',\\n            \\'datetime\\',\\n            \\'datetime-local\\',\\n            \\'month\\',\\n            \\'time\\',\\n            \\'week\\'\\n        ].filter(function (t) { return getSupportedInputTypes().has(t); });\\n        // Force setter to be called in case id was not specified.\\n        this.id = this.id;\\n    }\\n    Object.defineProperty(MdInputDirective.prototype, \"disabled\", {\\n        /**\\n         * Whether the element is disabled.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._ngControl ? this._ngControl.disabled : this._disabled;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"id\", {\\n        /**\\n         * Unique id of the element.\\n         * @return {?}\\n         */\\n        get: function () { return this._id; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._id = value || this._uid; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"placeholder\", {\\n        /**\\n         * Placeholder attribute of the element.\\n         * @return {?}\\n         */\\n        get: function () { return this._placeholder; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._placeholder !== value) {\\n                this._placeholder = value;\\n                this._placeholderChange.emit(this._placeholder);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"required\", {\\n        /**\\n         * Whether the element is required.\\n         * @return {?}\\n         */\\n        get: function () { return this._required; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._required = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"type\", {\\n        /**\\n         * Input type of the element.\\n         * @return {?}\\n         */\\n        get: function () { return this._type; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._type = value || \\'text\\';\\n            this._validateType();\\n            // When using Angular inputs, developers are no longer able to set the properties on the native\\n            // input element. To ensure that bindings for `type` work, we need to sync the setter\\n            // with the native property. Textarea elements don\\'t support the type property or attribute.\\n            if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\\n                this._renderer.setProperty(this._elementRef.nativeElement, \\'type\\', this._type);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"value\", {\\n        /**\\n         * The input element\\'s value.\\n         * @return {?}\\n         */\\n        get: function () { return this._elementRef.nativeElement.value; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._elementRef.nativeElement.value = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"empty\", {\\n        /**\\n         * Whether the input is empty.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return !this._isNeverEmpty() &&\\n                (this.value == null || this.value === \\'\\') &&\\n                // Check if the input contains bad input. If so, we know that it only appears empty because\\n                // the value failed to parse. From the user\\'s perspective it is not empty.\\n                // TODO(mmalerba): Add e2e test for bad input case.\\n                !this._isBadInput();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"_uid\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._cachedUid = this._cachedUid || \"md-input-\" + nextUniqueId$1++; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Focuses the input element.\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype.focus = function () { this._elementRef.nativeElement.focus(); };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._onFocus = function () { this.focused = true; };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._onBlur = function () { this.focused = false; };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._onInput = function () {\\n        // This is a noop function and is used to let Angular know whenever the value changes.\\n        // Angular will run a new change detection each time the `input` event has been dispatched.\\n        // It\\'s necessary that Angular recognizes the value change, because when floatingLabel\\n        // is set to false and Angular forms aren\\'t used, the placeholder won\\'t recognize the\\n        // value changes and will not disappear.\\n        // Listening to the input event wouldn\\'t be necessary when the input is using the\\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\\n    };\\n    /**\\n     * Make sure the input is a supported type.\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._validateType = function () {\\n        if (MD_INPUT_INVALID_TYPES.indexOf(this._type) !== -1) {\\n            throw getMdInputContainerUnsupportedTypeError(this._type);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._isNeverEmpty = function () { return this._neverEmptyInputTypes.indexOf(this._type) !== -1; };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._isBadInput = function () {\\n        return ((this._elementRef.nativeElement)).validity.badInput;\\n    };\\n    /**\\n     * Determines if the component host is a textarea. If not recognizable it returns false.\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._isTextarea = function () {\\n        var /** @type {?} */ nativeElement = this._elementRef.nativeElement;\\n        return nativeElement ? nativeElement.nodeName.toLowerCase() === \\'textarea\\' : false;\\n    };\\n    return MdInputDirective;\\n}());\\nMdInputDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \"input[mdInput], textarea[mdInput], input[matInput], textarea[matInput]\",\\n                host: {\\n                    \\'[class.mat-input-element]\\': \\'true\\',\\n                    // Native input properties that are overwritten by Angular inputs need to be synced with\\n                    // the native input element. Otherwise property bindings for those don\\'t work.\\n                    \\'[id]\\': \\'id\\',\\n                    \\'[placeholder]\\': \\'placeholder\\',\\n                    \\'[disabled]\\': \\'disabled\\',\\n                    \\'[required]\\': \\'required\\',\\n                    \\'[attr.aria-describedby]\\': \\'ariaDescribedby || null\\',\\n                    \\'(blur)\\': \\'_onBlur()\\',\\n                    \\'(focus)\\': \\'_onFocus()\\',\\n                    \\'(input)\\': \\'_onInput()\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdInputDirective.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NgControl\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"] },] },\\n]; };\\nMdInputDirective.propDecorators = {\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'placeholder\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'required\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'type\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_placeholderChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Container for text inputs that applies Material Design styling and behavior.\\n */\\nvar MdInputContainer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _changeDetectorRef\\n     * @param {?} _parentForm\\n     * @param {?} _parentFormGroup\\n     */\\n    function MdInputContainer(_elementRef, _changeDetectorRef, _parentForm, _parentFormGroup) {\\n        this._elementRef = _elementRef;\\n        this._changeDetectorRef = _changeDetectorRef;\\n        this._parentForm = _parentForm;\\n        this._parentFormGroup = _parentFormGroup;\\n        /**\\n         * Alignment of the input container\\'s content.\\n         */\\n        this.align = \\'start\\';\\n        /**\\n         * Color of the input divider, based on the theme.\\n         */\\n        this.color = \\'primary\\';\\n        /**\\n         * State of the md-hint and md-error animations.\\n         */\\n        this._subscriptAnimationState = \\'\\';\\n        this._hintLabel = \\'\\';\\n        // Unique id for the hint label.\\n        this._hintLabelId = \"md-input-hint-\" + nextUniqueId$1++;\\n        this._floatPlaceholder = \\'auto\\';\\n    }\\n    Object.defineProperty(MdInputContainer.prototype, \"dividerColor\", {\\n        /**\\n         * @deprecated Use color instead.\\n         * @return {?}\\n         */\\n        get: function () { return this.color; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this.color = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputContainer.prototype, \"hideRequiredMarker\", {\\n        /**\\n         * Whether the required marker should be hidden.\\n         * @return {?}\\n         */\\n        get: function () { return this._hideRequiredMarker; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._hideRequiredMarker = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputContainer.prototype, \"_shouldAlwaysFloat\", {\\n        /**\\n         * Whether the floating label should always float or not.\\n         * @return {?}\\n         */\\n        get: function () { return this._floatPlaceholder === \\'always\\'; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputContainer.prototype, \"_canPlaceholderFloat\", {\\n        /**\\n         * Whether the placeholder can float or not.\\n         * @return {?}\\n         */\\n        get: function () { return this._floatPlaceholder !== \\'never\\'; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputContainer.prototype, \"hintLabel\", {\\n        /**\\n         * Text for the input hint.\\n         * @return {?}\\n         */\\n        get: function () { return this._hintLabel; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._hintLabel = value;\\n            this._processHints();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputContainer.prototype, \"floatPlaceholder\", {\\n        /**\\n         * Whether the placeholder should always float, never float or float as the user types.\\n         * @return {?}\\n         */\\n        get: function () { return this._floatPlaceholder; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._floatPlaceholder = value || \\'auto\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._validateInputChild();\\n        this._processHints();\\n        this._validatePlaceholders();\\n        // Re-validate when things change.\\n        this._hintChildren.changes.subscribe(function () { return _this._processHints(); });\\n        this._mdInputChild._placeholderChange.subscribe(function () { return _this._validatePlaceholders(); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype.ngAfterContentChecked = function () {\\n        this._validateInputChild();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype.ngAfterViewInit = function () {\\n        // Avoid animations on load.\\n        this._subscriptAnimationState = \\'enter\\';\\n        this._changeDetectorRef.detectChanges();\\n    };\\n    /**\\n     * Determines whether a class from the NgControl should be forwarded to the host element.\\n     * @param {?} prop\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._shouldForward = function (prop) {\\n        var /** @type {?} */ control = this._mdInputChild ? this._mdInputChild._ngControl : null;\\n        return control && ((control))[prop];\\n    };\\n    /**\\n     * Whether the input has a placeholder.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._hasPlaceholder = function () { return !!(this._mdInputChild.placeholder || this._placeholderChild); };\\n    /**\\n     * Focuses the underlying input.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._focusInput = function () { this._mdInputChild.focus(); };\\n    /**\\n     * Whether the input container is in an error state.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._isErrorState = function () {\\n        var /** @type {?} */ control = this._mdInputChild._ngControl;\\n        var /** @type {?} */ isInvalid = control && control.invalid;\\n        var /** @type {?} */ isTouched = control && control.touched;\\n        var /** @type {?} */ isSubmitted = (this._parentFormGroup && this._parentFormGroup.submitted) ||\\n            (this._parentForm && this._parentForm.submitted);\\n        return !!(isInvalid && (isTouched || isSubmitted));\\n    };\\n    /**\\n     * Determines whether to display hints or errors.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._getDisplayedMessages = function () {\\n        return (this._errorChildren.length > 0 && this._isErrorState()) ? \\'error\\' : \\'hint\\';\\n    };\\n    /**\\n     * Ensure that there is only one placeholder (either `input` attribute or child element with the\\n     * `md-placeholder` attribute.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._validatePlaceholders = function () {\\n        if (this._mdInputChild.placeholder && this._placeholderChild) {\\n            throw getMdInputContainerPlaceholderConflictError();\\n        }\\n    };\\n    /**\\n     * Does any extra processing that is required when handling the hints.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._processHints = function () {\\n        this._validateHints();\\n        this._syncAriaDescribedby();\\n    };\\n    /**\\n     * Ensure that there is a maximum of one of each `<md-hint>` alignment specified, with the\\n     * attribute being considered as `align=\"start\"`.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._validateHints = function () {\\n        var _this = this;\\n        if (this._hintChildren) {\\n            var /** @type {?} */ startHint_1 = null;\\n            var /** @type {?} */ endHint_1 = null;\\n            this._hintChildren.forEach(function (hint) {\\n                if (hint.align == \\'start\\') {\\n                    if (startHint_1 || _this.hintLabel) {\\n                        throw getMdInputContainerDuplicatedHintError(\\'start\\');\\n                    }\\n                    startHint_1 = hint;\\n                }\\n                else if (hint.align == \\'end\\') {\\n                    if (endHint_1) {\\n                        throw getMdInputContainerDuplicatedHintError(\\'end\\');\\n                    }\\n                    endHint_1 = hint;\\n                }\\n            });\\n        }\\n    };\\n    /**\\n     * Sets the child input\\'s `aria-describedby` to a space-separated list of the ids\\n     * of the currently-specified hints, as well as a generated id for the hint label.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._syncAriaDescribedby = function () {\\n        if (this._mdInputChild) {\\n            var /** @type {?} */ ids = [];\\n            var /** @type {?} */ startHint = this._hintChildren ?\\n                this._hintChildren.find(function (hint) { return hint.align === \\'start\\'; }) : null;\\n            var /** @type {?} */ endHint = this._hintChildren ?\\n                this._hintChildren.find(function (hint) { return hint.align === \\'end\\'; }) : null;\\n            if (startHint) {\\n                ids.push(startHint.id);\\n            }\\n            else if (this._hintLabel) {\\n                ids.push(this._hintLabelId);\\n            }\\n            if (endHint) {\\n                ids.push(endHint.id);\\n            }\\n            this._mdInputChild.ariaDescribedby = ids.join(\\' \\');\\n        }\\n    };\\n    /**\\n     * Throws an error if the container\\'s input child was removed.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._validateInputChild = function () {\\n        if (!this._mdInputChild) {\\n            throw getMdInputContainerMissingMdInputError();\\n        }\\n    };\\n    return MdInputContainer;\\n}());\\nMdInputContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-input-container, mat-input-container\\',\\n                template: \"<div class=\\\\\"mat-input-wrapper\\\\\"> <div class=\\\\\"mat-input-table\\\\\"> <div class=\\\\\"mat-input-prefix\\\\\" *ngIf=\\\\\"_prefixChildren.length\\\\\"> \\x3c!-- TODO(andrewseguin): remove [md-prefix] --\\x3e <ng-content select=\\\\\"[mdPrefix], [matPrefix], [md-prefix]\\\\\"></ng-content> </div> <div class=\\\\\"mat-input-infix\\\\\" [class.mat-end]=\\\\\"align == \\'end\\'\\\\\"> <ng-content selector=\\\\\"input, textarea\\\\\"></ng-content> <span class=\\\\\"mat-input-placeholder-wrapper\\\\\"> <label class=\\\\\"mat-input-placeholder\\\\\" [attr.for]=\\\\\"_mdInputChild.id\\\\\" [class.mat-empty]=\\\\\"_mdInputChild.empty && !_shouldAlwaysFloat\\\\\" [class.mat-float]=\\\\\"_canPlaceholderFloat\\\\\" [class.mat-accent]=\\\\\"color == \\'accent\\'\\\\\" [class.mat-warn]=\\\\\"color == \\'warn\\'\\\\\" *ngIf=\\\\\"_hasPlaceholder()\\\\\"> <ng-content select=\\\\\"md-placeholder, mat-placeholder\\\\\"></ng-content> {{_mdInputChild.placeholder}} <span class=\\\\\"mat-placeholder-required\\\\\" *ngIf=\\\\\"!hideRequiredMarker && _mdInputChild.required\\\\\">*</span> </label> </span> </div> <div class=\\\\\"mat-input-suffix\\\\\" *ngIf=\\\\\"_suffixChildren.length\\\\\"> \\x3c!-- TODO(andrewseguin): remove [md-suffix] --\\x3e <ng-content select=\\\\\"[mdSuffix], [matSuffix], [md-suffix]\\\\\"></ng-content> </div> </div> <div class=\\\\\"mat-input-underline\\\\\" #underline [class.mat-disabled]=\\\\\"_mdInputChild.disabled\\\\\"> <span class=\\\\\"mat-input-ripple\\\\\" [class.mat-accent]=\\\\\"color == \\'accent\\'\\\\\" [class.mat-warn]=\\\\\"color == \\'warn\\'\\\\\"></span> </div> <div class=\\\\\"mat-input-subscript-wrapper\\\\\" [ngSwitch]=\\\\\"_getDisplayedMessages()\\\\\"> <div *ngSwitchCase=\\\\\"\\'error\\'\\\\\" [@transitionMessages]=\\\\\"_subscriptAnimationState\\\\\"> <ng-content select=\\\\\"md-error, mat-error\\\\\"></ng-content> </div> <div class=\\\\\"mat-input-hint-wrapper\\\\\" *ngSwitchCase=\\\\\"\\'hint\\'\\\\\" [@transitionMessages]=\\\\\"_subscriptAnimationState\\\\\"> <div *ngIf=\\\\\"hintLabel\\\\\" [id]=\\\\\"_hintLabelId\\\\\" class=\\\\\"mat-hint\\\\\">{{hintLabel}}</div> <ng-content select=\\\\\"md-hint:not([align=\\'end\\']), mat-hint:not([align=\\'end\\'])\\\\\"></ng-content> <div class=\\\\\"mat-input-hint-spacer\\\\\"></div> <ng-content select=\\\\\"md-hint[align=\\'end\\'], mat-hint[align=\\'end\\']\\\\\"></ng-content> </div> </div> </div> \",\\n                styles: [\".mat-input-container{display:inline-block;position:relative;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;line-height:normal;text-align:left}[dir=rtl] .mat-input-container{text-align:right}.mat-input-container .mat-datepicker-toggle,.mat-input-container .mat-icon{width:1em;height:1em;font-size:100%;vertical-align:top}.mat-input-wrapper{margin:1em 0;padding-bottom:6px}.mat-input-table{display:inline-table;flex-flow:column;vertical-align:bottom;width:100%}.mat-input-table>*{display:table-cell}.mat-input-infix{position:relative}.mat-input-element{font:inherit;background:0 0;color:currentColor;border:none;outline:0;padding:0;width:100%;vertical-align:bottom}.mat-end .mat-input-element{text-align:right}[dir=rtl] .mat-end .mat-input-element{text-align:left}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element:-webkit-autofill+.mat-input-placeholder-wrapper .mat-float{display:block;transform:translate3d(0,-1.35em,0) scale(.75);width:133.33333%;transition:none}.mat-input-element::placeholder{color:transparent!important}.mat-input-element::-moz-placeholder{color:transparent!important}.mat-input-element::-webkit-input-placeholder{color:transparent!important}.mat-input-element:-ms-input-placeholder{color:transparent!important}.mat-input-placeholder{position:absolute;left:0;top:0;font-size:100%;pointer-events:none;z-index:1;padding-top:1em;width:100%;display:none;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform:translate3d(0,0,0);transform-origin:bottom left;transition:transform .4s cubic-bezier(.25,.8,.25,1),color .4s cubic-bezier(.25,.8,.25,1),width .4s cubic-bezier(.25,.8,.25,1)}.mat-input-placeholder.mat-empty{display:block;cursor:text}.mat-focused .mat-input-placeholder.mat-float,.mat-input-placeholder.mat-float:not(.mat-empty){display:block;transform:translate3d(0,-1.35em,0) scale(.75);width:133.33333%}[dir=rtl] .mat-input-placeholder{transform-origin:bottom right;left:auto;right:0}.mat-input-placeholder:not(.mat-empty){transition:none}.mat-input-placeholder-wrapper{position:absolute;left:0;top:-1em;width:100%;padding-top:1em;overflow:hidden;pointer-events:none;transform:translate3d(0,0,0)}.mat-input-placeholder-wrapper::after{content:\\'\\';display:inline-table}.mat-input-underline{position:absolute;height:1px;width:100%;margin-top:4px;border-top-width:1px;border-top-style:solid}.mat-input-underline.mat-disabled{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;border-top:0;background-position:0}.mat-input-underline .mat-input-ripple{position:absolute;height:2px;z-index:1;top:-1px;width:100%;transform-origin:50%;transform:scaleX(.5);visibility:hidden;transition:background-color .3s cubic-bezier(.55,0,.55,.2)}.mat-focused .mat-input-underline .mat-input-ripple,.mat-input-invalid .mat-input-underline .mat-input-ripple{visibility:visible;transform:scaleX(1);transition:transform 150ms linear,background-color .3s cubic-bezier(.55,0,.55,.2)}.mat-input-subscript-wrapper{position:absolute;font-size:75%;top:100%;width:100%;margin-top:-1.2em;line-height:1.2em;overflow:hidden}.mat-input-hint-wrapper{display:flex}.mat-input-hint-spacer{flex:1 0 10px}.mat-input-error{display:block}.mat-input-prefix,.mat-input-suffix{width:.1px;white-space:nowrap} /*# sourceMappingURL=input-container.css.map */ \"],\\n                animations: [\\n                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"trigger\"])(\\'transitionMessages\\', [\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'enter\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ opacity: 1, transform: \\'translateY(0%)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'void => enter\\', [\\n                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ opacity: 0, transform: \\'translateY(-100%)\\' }),\\n                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\\'300ms cubic-bezier(0.55, 0, 0.55, 0.2)\\')\\n                        ])\\n                    ])\\n                ],\\n                host: {\\n                    // Remove align attribute to prevent it from interfering with layout.\\n                    \\'[attr.align]\\': \\'null\\',\\n                    \\'[class.mat-input-container]\\': \\'true\\',\\n                    \\'[class.mat-input-invalid]\\': \\'_isErrorState()\\',\\n                    \\'[class.mat-focused]\\': \\'_mdInputChild.focused\\',\\n                    \\'[class.ng-untouched]\\': \\'_shouldForward(\"untouched\")\\',\\n                    \\'[class.ng-touched]\\': \\'_shouldForward(\"touched\")\\',\\n                    \\'[class.ng-pristine]\\': \\'_shouldForward(\"pristine\")\\',\\n                    \\'[class.ng-dirty]\\': \\'_shouldForward(\"dirty\")\\',\\n                    \\'[class.ng-valid]\\': \\'_shouldForward(\"valid\")\\',\\n                    \\'[class.ng-invalid]\\': \\'_shouldForward(\"invalid\")\\',\\n                    \\'[class.ng-pending]\\': \\'_shouldForward(\"pending\")\\',\\n                    \\'(click)\\': \\'_focusInput()\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdInputContainer.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NgForm\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"FormGroupDirective\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdInputContainer.propDecorators = {\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'dividerColor\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'hideRequiredMarker\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'hintLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'floatPlaceholder\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'underlineRef\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'underline\\',] },],\\n    \\'_mdInputChild\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [MdInputDirective,] },],\\n    \\'_placeholderChild\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [MdPlaceholder,] },],\\n    \\'_errorChildren\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdErrorDirective,] },],\\n    \\'_hintChildren\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdHint,] },],\\n    \\'_prefixChildren\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdPrefix,] },],\\n    \\'_suffixChildren\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdSuffix,] },],\\n};\\n/**\\n * Directive to automatically resize a textarea to fit its content.\\n */\\nvar MdTextareaAutosize = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     */\\n    function MdTextareaAutosize(_elementRef) {\\n        this._elementRef = _elementRef;\\n    }\\n    Object.defineProperty(MdTextareaAutosize.prototype, \"minRows\", {\\n        /**\\n         * @deprecated Use mdAutosizeMinRows\\n         * @return {?}\\n         */\\n        get: function () { return this._minRows; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._minRows = value;\\n            this._setMinHeight();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTextareaAutosize.prototype, \"maxRows\", {\\n        /**\\n         * @deprecated Use mdAutosizeMaxRows\\n         * @return {?}\\n         */\\n        get: function () { return this._maxRows; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._maxRows = value;\\n            this._setMaxHeight();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTextareaAutosize.prototype, \"mdAutosizeMinRows\", {\\n        /**\\n         * Minimum number of rows for this textarea.\\n         * @return {?}\\n         */\\n        get: function () { return this.minRows; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this.minRows = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTextareaAutosize.prototype, \"mdAutosizeMaxRows\", {\\n        /**\\n         * Maximum number of rows for this textarea.\\n         * @return {?}\\n         */\\n        get: function () { return this.maxRows; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this.maxRows = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the minimum height of the textarea as determined by minRows.\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype._setMinHeight = function () {\\n        var /** @type {?} */ minHeight = this.minRows && this._cachedLineHeight ?\\n            this.minRows * this._cachedLineHeight + \"px\" : null;\\n        if (minHeight) {\\n            this._setTextareaStyle(\\'minHeight\\', minHeight);\\n        }\\n    };\\n    /**\\n     * Sets the maximum height of the textarea as determined by maxRows.\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype._setMaxHeight = function () {\\n        var /** @type {?} */ maxHeight = this.maxRows && this._cachedLineHeight ?\\n            this.maxRows * this._cachedLineHeight + \"px\" : null;\\n        if (maxHeight) {\\n            this._setTextareaStyle(\\'maxHeight\\', maxHeight);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype.ngAfterViewInit = function () {\\n        this._cacheTextareaLineHeight();\\n        this.resizeToFitContent();\\n    };\\n    /**\\n     * Sets a style property on the textarea element.\\n     * @param {?} property\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype._setTextareaStyle = function (property, value) {\\n        var /** @type {?} */ textarea = (this._elementRef.nativeElement);\\n        textarea.style[property] = value;\\n    };\\n    /**\\n     * Cache the height of a single-row textarea.\\n     *\\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\\n     * maxRows. For the initial version, we will assume that the height of a single line in the\\n     * textarea does not ever change.\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype._cacheTextareaLineHeight = function () {\\n        var /** @type {?} */ textarea = (this._elementRef.nativeElement);\\n        // Use a clone element because we have to override some styles.\\n        var /** @type {?} */ textareaClone = (textarea.cloneNode(false));\\n        textareaClone.rows = 1;\\n        // Use `position: absolute` so that this doesn\\'t cause a browser layout and use\\n        // `visibility: hidden` so that nothing is rendered. Clear any other styles that\\n        // would affect the height.\\n        textareaClone.style.position = \\'absolute\\';\\n        textareaClone.style.visibility = \\'hidden\\';\\n        textareaClone.style.border = \\'none\\';\\n        textareaClone.style.padding = \\'0\\';\\n        textareaClone.style.height = \\'\\';\\n        textareaClone.style.minHeight = \\'\\';\\n        textareaClone.style.maxHeight = \\'\\';\\n        textarea.parentNode.appendChild(textareaClone);\\n        this._cachedLineHeight = textareaClone.clientHeight;\\n        textarea.parentNode.removeChild(textareaClone);\\n        // Min and max heights have to be re-calculated if the cached line height changes\\n        this._setMinHeight();\\n        this._setMaxHeight();\\n    };\\n    /**\\n     * Resize the textarea to fit its content.\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype.resizeToFitContent = function () {\\n        var /** @type {?} */ textarea = (this._elementRef.nativeElement);\\n        // Reset the textarea height to auto in order to shrink back to its default size.\\n        textarea.style.height = \\'auto\\';\\n        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\\n        textarea.style.height = textarea.scrollHeight + \"px\";\\n    };\\n    return MdTextareaAutosize;\\n}());\\nMdTextareaAutosize.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'textarea[md-autosize], textarea[mdTextareaAutosize],\\' +\\n                    \\'textarea[mat-autosize], textarea[matTextareaAutosize]\\',\\n                exportAs: \\'mdTextareaAutosize\\',\\n                host: {\\n                    \\'(input)\\': \\'resizeToFitContent()\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTextareaAutosize.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdTextareaAutosize.propDecorators = {\\n    \\'minRows\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'maxRows\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'mdAutosizeMinRows\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'mdAutosizeMaxRows\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdInputModule = /*@__PURE__*/(function () {\\n    function MdInputModule() {\\n    }\\n    return MdInputModule;\\n}());\\nMdInputModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                declarations: [\\n                    MdErrorDirective,\\n                    MdHint,\\n                    MdInputContainer,\\n                    MdInputDirective,\\n                    MdPlaceholder,\\n                    MdPrefix,\\n                    MdSuffix,\\n                    MdTextareaAutosize,\\n                ],\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"],\\n                    __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"FormsModule\"],\\n                    PlatformModule,\\n                ],\\n                exports: [\\n                    MdErrorDirective,\\n                    MdHint,\\n                    MdInputContainer,\\n                    MdInputDirective,\\n                    MdPlaceholder,\\n                    MdPrefix,\\n                    MdSuffix,\\n                    MdTextareaAutosize,\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdInputModule.ctorParameters = function () { return []; };\\n/**\\n * Configuration used when opening a snack-bar.\\n */\\nvar MdSnackBarConfig = /*@__PURE__*/(function () {\\n    function MdSnackBarConfig() {\\n        /**\\n         * The politeness level for the MdAriaLiveAnnouncer announcement.\\n         */\\n        this.politeness = \\'assertive\\';\\n        /**\\n         * Message to be announced by the MdAriaLiveAnnouncer\\n         */\\n        this.announcementMessage = \\'\\';\\n        /**\\n         * The view container to place the overlay for the snack bar into.\\n         */\\n        this.viewContainerRef = null;\\n        /**\\n         * The length of time in milliseconds to wait before automatically dismissing the snack bar.\\n         */\\n        this.duration = 0;\\n        /**\\n         * Text layout direction for the snack bar.\\n         */\\n        this.direction = \\'ltr\\';\\n    }\\n    return MdSnackBarConfig;\\n}());\\n/**\\n * Reference to a snack bar dispatched from the snack bar service.\\n */\\nvar MdSnackBarRef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} instance\\n     * @param {?} containerInstance\\n     * @param {?} _overlayRef\\n     */\\n    function MdSnackBarRef(instance, containerInstance, _overlayRef) {\\n        var _this = this;\\n        this._overlayRef = _overlayRef;\\n        /**\\n         * Subject for notifying the user that the snack bar has closed.\\n         */\\n        this._afterClosed = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        /**\\n         * Subject for notifying the user that the snack bar action was called.\\n         */\\n        this._onAction = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        // Sets the readonly instance of the snack bar content component.\\n        this._instance = instance;\\n        this.containerInstance = containerInstance;\\n        // Dismiss snackbar on action.\\n        this.onAction().subscribe(function () { return _this.dismiss(); });\\n        containerInstance._onExit().subscribe(function () { return _this._finishDismiss(); });\\n    }\\n    Object.defineProperty(MdSnackBarRef.prototype, \"instance\", {\\n        /**\\n         * The instance of the component making up the content of the snack bar.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._instance;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Dismisses the snack bar.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype.dismiss = function () {\\n        if (!this._afterClosed.closed) {\\n            this.containerInstance.exit();\\n        }\\n    };\\n    /**\\n     * Marks the snackbar action clicked.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype._action = function () {\\n        if (!this._onAction.closed) {\\n            this._onAction.next();\\n            this._onAction.complete();\\n        }\\n    };\\n    /**\\n     * Marks the snackbar as opened\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype._open = function () {\\n        if (!this._afterOpened.closed) {\\n            this._afterOpened.next();\\n            this._afterOpened.complete();\\n        }\\n    };\\n    /**\\n     * Cleans up the DOM after closing.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype._finishDismiss = function () {\\n        this._overlayRef.dispose();\\n        this._afterClosed.next();\\n        this._afterClosed.complete();\\n    };\\n    /**\\n     * Gets an observable that is notified when the snack bar is finished closing.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype.afterDismissed = function () {\\n        return this._afterClosed.asObservable();\\n    };\\n    /**\\n     * Gets an observable that is notified when the snack bar has opened and appeared.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype.afterOpened = function () {\\n        return this.containerInstance._onEnter();\\n    };\\n    /**\\n     * Gets an observable that is notified when the snack bar action is called.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype.onAction = function () {\\n        return this._onAction.asObservable();\\n    };\\n    return MdSnackBarRef;\\n}());\\n// TODO(jelbourn): we can\\'t use constants from animation.ts here because you can\\'t use\\n// a text interpolation in anything that is analyzed statically with ngc (for AoT compile).\\nvar SHOW_ANIMATION = \\'225ms cubic-bezier(0.4,0.0,1,1)\\';\\nvar HIDE_ANIMATION = \\'195ms cubic-bezier(0.0,0.0,0.2,1)\\';\\n/**\\n * Internal component that wraps user-provided snack bar content.\\n * \\\\@docs-private\\n */\\nvar MdSnackBarContainer = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdSnackBarContainer, _super);\\n    /**\\n     * @param {?} _ngZone\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdSnackBarContainer(_ngZone, _renderer, _elementRef) {\\n        var _this = _super.call(this) || this;\\n        _this._ngZone = _ngZone;\\n        _this._renderer = _renderer;\\n        _this._elementRef = _elementRef;\\n        /**\\n         * Subject for notifying that the snack bar has exited from view.\\n         */\\n        _this.onExit = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        /**\\n         * Subject for notifying that the snack bar has finished entering the view.\\n         */\\n        _this.onEnter = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        /**\\n         * The state of the snack bar animations.\\n         */\\n        _this.animationState = \\'initial\\';\\n        return _this;\\n    }\\n    /**\\n     * Attach a component portal as content to this snack bar container.\\n     * @template T\\n     * @param {?} portal\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.attachComponentPortal = function (portal) {\\n        if (this._portalHost.hasAttached()) {\\n            throw new Error(\\'Attempting to attach snack bar content after content is already attached\\');\\n        }\\n        if (this.snackBarConfig.extraClasses) {\\n            // Not the most efficient way of adding classes, but the renderer doesn\\'t allow us\\n            // to pass in an array or a space-separated list.\\n            for (var _i = 0, _a = this.snackBarConfig.extraClasses; _i < _a.length; _i++) {\\n                var cssClass = _a[_i];\\n                this._renderer.addClass(this._elementRef.nativeElement, cssClass);\\n            }\\n        }\\n        return this._portalHost.attachComponentPortal(portal);\\n    };\\n    /**\\n     * Attach a template portal as content to this snack bar container.\\n     * @param {?} portal\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.attachTemplatePortal = function (portal) {\\n        throw new Error(\\'Not yet implemented\\');\\n    };\\n    /**\\n     * Handle end of animations, updating the state of the snackbar.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.onAnimationEnd = function (event) {\\n        if (event.toState === \\'void\\' || event.toState === \\'complete\\') {\\n            this._completeExit();\\n        }\\n        if (event.toState === \\'visible\\') {\\n            // Note: we shouldn\\'t use `this` inside the zone callback,\\n            // because it can cause a memory leak.\\n            var /** @type {?} */ onEnter_1 = this.onEnter;\\n            this._ngZone.run(function () {\\n                onEnter_1.next();\\n                onEnter_1.complete();\\n            });\\n        }\\n    };\\n    /**\\n     * Begin animation of snack bar entrance into view.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.enter = function () {\\n        this.animationState = \\'visible\\';\\n    };\\n    /**\\n     * Returns an observable resolving when the enter animation completes.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype._onEnter = function () {\\n        this.animationState = \\'visible\\';\\n        return this.onEnter.asObservable();\\n    };\\n    /**\\n     * Begin animation of the snack bar exiting from view.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.exit = function () {\\n        this.animationState = \\'complete\\';\\n        return this._onExit();\\n    };\\n    /**\\n     * Returns an observable that completes after the closing animation is done.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype._onExit = function () {\\n        return this.onExit.asObservable();\\n    };\\n    /**\\n     * Makes sure the exit callbacks have been invoked when the element is destroyed.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.ngOnDestroy = function () {\\n        this._completeExit();\\n    };\\n    /**\\n     * Waits for the zone to settle before removing the element. Helps prevent\\n     * errors where we end up removing an element which is in the middle of an animation.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype._completeExit = function () {\\n        // Note: we shouldn\\'t use `this` inside the zone callback,\\n        // because it can cause a memory leak.\\n        var /** @type {?} */ onExit = this.onExit;\\n        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {\\n            onExit.next();\\n            onExit.complete();\\n        });\\n    };\\n    return MdSnackBarContainer;\\n}(BasePortalHost));\\nMdSnackBarContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'snack-bar-container\\',\\n                template: \"<ng-template cdkPortalHost></ng-template> \",\\n                styles: [\":host{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);background:#323232;border-radius:2px;box-sizing:content-box;display:block;max-width:568px;min-width:288px;padding:14px 24px;transform:translateY(100%)}@media screen and (-ms-high-contrast:active){:host{border:solid 1px}} /*# sourceMappingURL=snack-bar-container.css.map */ \"],\\n                host: {\\n                    \\'role\\': \\'alert\\',\\n                    \\'[@state]\\': \\'animationState\\',\\n                    \\'(@state.done)\\': \\'onAnimationEnd($event)\\'\\n                },\\n                animations: [\\n                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"trigger\"])(\\'state\\', [\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'initial\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translateY(100%)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'visible\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translateY(0%)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'complete\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translateY(100%)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'visible => complete\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(HIDE_ANIMATION)),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'initial => visible, void => visible\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(SHOW_ANIMATION)),\\n                    ])\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSnackBarContainer.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdSnackBarContainer.propDecorators = {\\n    \\'_portalHost\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [PortalHostDirective,] },],\\n};\\n/**\\n * A component used to open as the default snack bar, matching material spec.\\n * This should only be used internally by the snack bar service.\\n */\\nvar SimpleSnackBar = /*@__PURE__*/(function () {\\n    function SimpleSnackBar() {\\n    }\\n    /**\\n     * Dismisses the snack bar.\\n     * @return {?}\\n     */\\n    SimpleSnackBar.prototype.dismiss = function () {\\n        this.snackBarRef._action();\\n    };\\n    Object.defineProperty(SimpleSnackBar.prototype, \"hasAction\", {\\n        /**\\n         * If the action button should be shown.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return !!this.action;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return SimpleSnackBar;\\n}());\\nSimpleSnackBar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'simple-snack-bar\\',\\n                template: \"{{message}} <button class=\\\\\"mat-simple-snackbar-action\\\\\" *ngIf=\\\\\"hasAction\\\\\" (click)=\\\\\"dismiss()\\\\\">{{action}}</button> \",\\n                styles: [\".mat-simple-snackbar{display:flex;justify-content:space-between;color:#fff;line-height:20px;font-size:14px;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif}.mat-simple-snackbar-action{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;background:0 0;color:inherit;line-height:1;flex-shrink:0;margin-left:48px;font-family:inherit;font-size:inherit;font-weight:600}[dir=rtl] .mat-simple-snackbar-action{margin-right:48px;margin-left:0} /*# sourceMappingURL=simple-snack-bar.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'[class.mat-simple-snackbar]\\': \\'true\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nSimpleSnackBar.ctorParameters = function () { return []; };\\n/**\\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\\n * similar to Object.assign.\\n *\\n * @param {?} dest The object which will have properties copied to it.\\n * @param {...?} sources The source objects from which properties will be copied.\\n * @return {?}\\n */\\nfunction extendObject(dest) {\\n    var sources = [];\\n    for (var _i = 1; _i < arguments.length; _i++) {\\n        sources[_i - 1] = arguments[_i];\\n    }\\n    if (dest == null) {\\n        throw TypeError(\\'Cannot convert undefined or null to object\\');\\n    }\\n    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\\n        var source = sources_1[_a];\\n        if (source != null) {\\n            for (var /** @type {?} */ key in source) {\\n                if (source.hasOwnProperty(key)) {\\n                    dest[key] = source[key];\\n                }\\n            }\\n        }\\n    }\\n    return dest;\\n}\\n/**\\n * Service to dispatch Material Design snack bar messages.\\n */\\nvar MdSnackBar = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlay\\n     * @param {?} _live\\n     * @param {?} _parentSnackBar\\n     */\\n    function MdSnackBar(_overlay, _live, _parentSnackBar) {\\n        this._overlay = _overlay;\\n        this._live = _live;\\n        this._parentSnackBar = _parentSnackBar;\\n    }\\n    Object.defineProperty(MdSnackBar.prototype, \"_openedSnackBarRef\", {\\n        /**\\n         * Reference to the currently opened snackbar at *any* level.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._parentSnackBar ?\\n                this._parentSnackBar._openedSnackBarRef : this._snackBarRefAtThisLevel;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._parentSnackBar) {\\n                this._parentSnackBar._openedSnackBarRef = value;\\n            }\\n            else {\\n                this._snackBarRefAtThisLevel = value;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Creates and dispatches a snack bar with a custom component for the content, removing any\\n     * currently opened snack bars.\\n     *\\n     * @template T\\n     * @param {?} component Component to be instantiated.\\n     * @param {?=} config Extra configuration for the snack bar.\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype.openFromComponent = function (component, config) {\\n        var _this = this;\\n        config = _applyConfigDefaults(config);\\n        var /** @type {?} */ overlayRef = this._createOverlay(config);\\n        var /** @type {?} */ snackBarContainer = this._attachSnackBarContainer(overlayRef, config);\\n        var /** @type {?} */ snackBarRef = this._attachSnackbarContent(component, snackBarContainer, overlayRef);\\n        // When the snackbar is dismissed, clear the reference to it.\\n        snackBarRef.afterDismissed().subscribe(function () {\\n            // Clear the snackbar ref if it hasn\\'t already been replaced by a newer snackbar.\\n            if (_this._openedSnackBarRef == snackBarRef) {\\n                _this._openedSnackBarRef = null;\\n            }\\n        });\\n        // If a snack bar is already in view, dismiss it and enter the new snack bar after exit\\n        // animation is complete.\\n        if (this._openedSnackBarRef) {\\n            this._openedSnackBarRef.afterDismissed().subscribe(function () {\\n                snackBarRef.containerInstance.enter();\\n            });\\n            this._openedSnackBarRef.dismiss();\\n            // If no snack bar is in view, enter the new snack bar.\\n        }\\n        else {\\n            snackBarRef.containerInstance.enter();\\n        }\\n        // If a dismiss timeout is provided, set up dismiss based on after the snackbar is opened.\\n        if (config.duration > 0) {\\n            snackBarRef.afterOpened().subscribe(function () {\\n                setTimeout(function () { return snackBarRef.dismiss(); }, config.duration);\\n            });\\n        }\\n        this._live.announce(config.announcementMessage, config.politeness);\\n        this._openedSnackBarRef = snackBarRef;\\n        return this._openedSnackBarRef;\\n    };\\n    /**\\n     * Opens a snackbar with a message and an optional action.\\n     * @param {?} message The message to show in the snackbar.\\n     * @param {?=} action The label for the snackbar action.\\n     * @param {?=} config Additional configuration options for the snackbar.\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype.open = function (message, action, config) {\\n        if (action === void 0) { action = \\'\\'; }\\n        if (config === void 0) { config = {}; }\\n        config.announcementMessage = message;\\n        var /** @type {?} */ simpleSnackBarRef = this.openFromComponent(SimpleSnackBar, config);\\n        simpleSnackBarRef.instance.snackBarRef = simpleSnackBarRef;\\n        simpleSnackBarRef.instance.message = message;\\n        simpleSnackBarRef.instance.action = action;\\n        return simpleSnackBarRef;\\n    };\\n    /**\\n     * Dismisses the currently-visible snack bar.\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype.dismiss = function () {\\n        if (this._openedSnackBarRef) {\\n            this._openedSnackBarRef.dismiss();\\n        }\\n    };\\n    /**\\n     * Attaches the snack bar container component to the overlay.\\n     * @param {?} overlayRef\\n     * @param {?} config\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype._attachSnackBarContainer = function (overlayRef, config) {\\n        var /** @type {?} */ containerPortal = new ComponentPortal(MdSnackBarContainer, config.viewContainerRef);\\n        var /** @type {?} */ containerRef = overlayRef.attach(containerPortal);\\n        containerRef.instance.snackBarConfig = config;\\n        return containerRef.instance;\\n    };\\n    /**\\n     * Places a new component as the content of the snack bar container.\\n     * @template T\\n     * @param {?} component\\n     * @param {?} container\\n     * @param {?} overlayRef\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype._attachSnackbarContent = function (component, container, overlayRef) {\\n        var /** @type {?} */ portal = new ComponentPortal(component);\\n        var /** @type {?} */ contentRef = container.attachComponentPortal(portal);\\n        return new MdSnackBarRef(contentRef.instance, container, overlayRef);\\n    };\\n    /**\\n     * Creates a new overlay and places it in the correct location.\\n     * @param {?} config The user-specified snack bar config.\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype._createOverlay = function (config) {\\n        var /** @type {?} */ state$$1 = new OverlayState();\\n        state$$1.direction = config.direction;\\n        state$$1.positionStrategy = this._overlay.position().global().centerHorizontally().bottom(\\'0\\');\\n        return this._overlay.create(state$$1);\\n    };\\n    return MdSnackBar;\\n}());\\nMdSnackBar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSnackBar.ctorParameters = function () { return [\\n    { type: Overlay, },\\n    { type: LiveAnnouncer, },\\n    { type: MdSnackBar, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"] },] },\\n]; };\\n/**\\n * Applies default options to the snackbar config.\\n * @param {?} config The configuration to which the defaults will be applied.\\n * @return {?} The new configuration object with defaults applied.\\n */\\nfunction _applyConfigDefaults(config) {\\n    return extendObject(new MdSnackBarConfig(), config);\\n}\\nvar MdSnackBarModule = /*@__PURE__*/(function () {\\n    function MdSnackBarModule() {\\n    }\\n    return MdSnackBarModule;\\n}());\\nMdSnackBarModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    OverlayModule,\\n                    PortalModule,\\n                    __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"],\\n                    MdCommonModule,\\n                ],\\n                exports: [MdSnackBarContainer, MdCommonModule],\\n                declarations: [MdSnackBarContainer, SimpleSnackBar],\\n                entryComponents: [MdSnackBarContainer, SimpleSnackBar],\\n                providers: [MdSnackBar, LIVE_ANNOUNCER_PROVIDER]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSnackBarModule.ctorParameters = function () { return []; };\\n/**\\n * Used to flag tab labels for use with the portal directive\\n */\\nvar MdTabLabel = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdTabLabel, _super);\\n    /**\\n     * @param {?} templateRef\\n     * @param {?} viewContainerRef\\n     */\\n    function MdTabLabel(templateRef, viewContainerRef) {\\n        return _super.call(this, templateRef, viewContainerRef) || this;\\n    }\\n    return MdTabLabel;\\n}(TemplatePortalDirective));\\nMdTabLabel.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-tab-label], [mat-tab-label]\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabLabel.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\nvar MdTab = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _viewContainerRef\\n     */\\n    function MdTab(_viewContainerRef) {\\n        this._viewContainerRef = _viewContainerRef;\\n        /**\\n         * The plain text label for the tab, used when there is no template label.\\n         */\\n        this.textLabel = \\'\\';\\n        /**\\n         * The portal that will be the hosted content of the tab\\n         */\\n        this._contentPortal = null;\\n        /**\\n         * The relatively indexed position where 0 represents the center, negative is left, and positive\\n         * represents the right.\\n         */\\n        this.position = null;\\n        /**\\n         * The initial relatively index origin of the tab if it was created and selected after there\\n         * was already a selected tab. Provides context of what position the tab should originate from.\\n         */\\n        this.origin = null;\\n        this._disabled = false;\\n    }\\n    Object.defineProperty(MdTab.prototype, \"content\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._contentPortal; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTab.prototype, \"disabled\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._disabled; },\\n        /**\\n         * Whether the tab is disabled\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disabled = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdTab.prototype.ngOnInit = function () {\\n        this._contentPortal = new TemplatePortal(this._content, this._viewContainerRef);\\n    };\\n    return MdTab;\\n}());\\nMdTab.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-tab, mat-tab\\',\\n                template: \"\\x3c!-- Create a template for the content of the <md-tab> so that we can grab a reference to this TemplateRef and use it in a Portal to render the tab content in the appropriate place in the tab-group. --\\x3e <ng-template><ng-content></ng-content></ng-template> \",\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTab.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\nMdTab.propDecorators = {\\n    \\'templateLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [MdTabLabel,] },],\\n    \\'_content\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"],] },],\\n    \\'textLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'label\\',] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Used to generate unique ID\\'s for each tab component\\n */\\nvar nextId$2 = 0;\\n/**\\n * A simple change event emitted on focus or selection changes.\\n */\\nvar MdTabChangeEvent = /*@__PURE__*/(function () {\\n    function MdTabChangeEvent() {\\n    }\\n    return MdTabChangeEvent;\\n}());\\n/**\\n * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\\n * animated ink-bar, keyboard navigation, and screen reader.\\n * See: https://www.google.com/design/spec/components/tabs.html\\n */\\nvar MdTabGroup = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     */\\n    function MdTabGroup(_renderer) {\\n        this._renderer = _renderer;\\n        /**\\n         * Whether this component has been initialized.\\n         */\\n        this._isInitialized = false;\\n        /**\\n         * The tab index that should be selected after the content has been checked.\\n         */\\n        this._indexToSelect = 0;\\n        /**\\n         * Snapshot of the height of the tab body wrapper before another tab is activated.\\n         */\\n        this._tabBodyWrapperHeight = null;\\n        /**\\n         * Whether the tab group should grow to the size of the active tab\\n         */\\n        this._dynamicHeight = false;\\n        this._disableRipple = false;\\n        this._selectedIndex = null;\\n        /**\\n         * Position of the tab header.\\n         */\\n        this.headerPosition = \\'above\\';\\n        /**\\n         * Event emitted when focus has changed within a tab group.\\n         */\\n        this.focusChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the tab selection has changed.\\n         */\\n        this.selectChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"](true);\\n        this._groupId = nextId$2++;\\n    }\\n    Object.defineProperty(MdTabGroup.prototype, \"dynamicHeight\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._dynamicHeight; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._dynamicHeight = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabGroup.prototype, \"_dynamicHeightDeprecated\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this._dynamicHeight; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._dynamicHeight = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabGroup.prototype, \"disableRipple\", {\\n        /**\\n         * Whether ripples for the tab-group should be disabled or not.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabGroup.prototype, \"selectedIndex\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._selectedIndex; },\\n        /**\\n         * The index of the active tab.\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._indexToSelect = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabGroup.prototype, \"selectedIndexChange\", {\\n        /**\\n         * Output to enable support for two-way binding on `[(selectedIndex)]`\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.selectChange.map(function (event) { return event.index; });\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * After the content is checked, this component knows what tabs have been defined\\n     * and what the selected index should be. This is where we can know exactly what position\\n     * each tab should be in according to the new selected index, and additionally we know how\\n     * a new selected tab should transition in (from the left or right).\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype.ngAfterContentChecked = function () {\\n        var _this = this;\\n        // Clamp the next selected index to the bounds of 0 and the tabs length. Note the `|| 0`, which\\n        // ensures that values like NaN can\\'t get through and which would otherwise throw the\\n        // component into an infinite loop (since Math.max(NaN, 0) === NaN).\\n        this._indexToSelect =\\n            Math.min(this._tabs.length - 1, Math.max(this._indexToSelect || 0, 0));\\n        // If there is a change in selected index, emit a change event. Should not trigger if\\n        // the selected index has not yet been initialized.\\n        if (this._selectedIndex != this._indexToSelect && this._selectedIndex != null) {\\n            this.selectChange.emit(this._createChangeEvent(this._indexToSelect));\\n        }\\n        // Setup the position for each tab and optionally setup an origin on the next selected tab.\\n        this._tabs.forEach(function (tab, index) {\\n            tab.position = index - _this._indexToSelect;\\n            // If there is already a selected tab, then set up an origin for the next selected tab\\n            // if it doesn\\'t have one already.\\n            if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {\\n                tab.origin = _this._indexToSelect - _this._selectedIndex;\\n            }\\n        });\\n        this._selectedIndex = this._indexToSelect;\\n    };\\n    /**\\n     * Waits one frame for the view to update, then updates the ink bar\\n     * Note: This must be run outside of the zone or it will create an infinite change detection loop.\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype.ngAfterViewChecked = function () {\\n        this._isInitialized = true;\\n    };\\n    /**\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._focusChanged = function (index) {\\n        this.focusChange.emit(this._createChangeEvent(index));\\n    };\\n    /**\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._createChangeEvent = function (index) {\\n        var /** @type {?} */ event = new MdTabChangeEvent;\\n        event.index = index;\\n        if (this._tabs && this._tabs.length) {\\n            event.tab = this._tabs.toArray()[index];\\n        }\\n        return event;\\n    };\\n    /**\\n     * Returns a unique id for each tab label element\\n     * @param {?} i\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._getTabLabelId = function (i) {\\n        return \"md-tab-label-\" + this._groupId + \"-\" + i;\\n    };\\n    /**\\n     * Returns a unique id for each tab content element\\n     * @param {?} i\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._getTabContentId = function (i) {\\n        return \"md-tab-content-\" + this._groupId + \"-\" + i;\\n    };\\n    /**\\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\\n     * height property is true.\\n     * @param {?} tabHeight\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._setTabBodyWrapperHeight = function (tabHeight) {\\n        if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\\n            return;\\n        }\\n        this._renderer.setStyle(this._tabBodyWrapper.nativeElement, \\'height\\', this._tabBodyWrapperHeight + \\'px\\');\\n        // This conditional forces the browser to paint the height so that\\n        // the animation to the new height can have an origin.\\n        if (this._tabBodyWrapper.nativeElement.offsetHeight) {\\n            this._renderer.setStyle(this._tabBodyWrapper.nativeElement, \\'height\\', tabHeight + \\'px\\');\\n        }\\n    };\\n    /**\\n     * Removes the height of the tab body wrapper.\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._removeTabBodyWrapperHeight = function () {\\n        this._tabBodyWrapperHeight = this._tabBodyWrapper.nativeElement.clientHeight;\\n        this._renderer.setStyle(this._tabBodyWrapper.nativeElement, \\'height\\', \\'\\');\\n    };\\n    return MdTabGroup;\\n}());\\nMdTabGroup.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-tab-group, mat-tab-group\\',\\n                template: \"<md-tab-header #tabHeader [selectedIndex]=\\\\\"selectedIndex\\\\\" [disableRipple]=\\\\\"disableRipple\\\\\" (indexFocused)=\\\\\"_focusChanged($event)\\\\\" (selectFocusedIndex)=\\\\\"selectedIndex = $event\\\\\"> <div class=\\\\\"mat-tab-label\\\\\" role=\\\\\"tab\\\\\" md-tab-label-wrapper md-ripple *ngFor=\\\\\"let tab of _tabs; let i = index\\\\\" [id]=\\\\\"_getTabLabelId(i)\\\\\" [tabIndex]=\\\\\"selectedIndex == i ? 0 : -1\\\\\" [attr.aria-controls]=\\\\\"_getTabContentId(i)\\\\\" [attr.aria-selected]=\\\\\"selectedIndex == i\\\\\" [class.mat-tab-label-active]=\\\\\"selectedIndex == i\\\\\" [disabled]=\\\\\"tab.disabled\\\\\" [mdRippleDisabled]=\\\\\"disableRipple\\\\\" (click)=\\\\\"tabHeader.focusIndex = selectedIndex = i\\\\\"> \\x3c!-- If there is a label template, use it. --\\x3e <ng-template [ngIf]=\\\\\"tab.templateLabel\\\\\"> <ng-template [cdkPortalHost]=\\\\\"tab.templateLabel\\\\\"></ng-template> </ng-template> \\x3c!-- If there is not a label template, fall back to the text label. --\\x3e <ng-template [ngIf]=\\\\\"!tab.templateLabel\\\\\">{{tab.textLabel}}</ng-template> </div> </md-tab-header> <div class=\\\\\"mat-tab-body-wrapper\\\\\" #tabBodyWrapper> <md-tab-body role=\\\\\"tabpanel\\\\\" *ngFor=\\\\\"let tab of _tabs; let i = index\\\\\" [id]=\\\\\"_getTabContentId(i)\\\\\" [attr.aria-labelledby]=\\\\\"_getTabLabelId(i)\\\\\" [class.mat-tab-body-active]=\\\\\"selectedIndex == i\\\\\" [content]=\\\\\"tab.content\\\\\" [position]=\\\\\"tab.position\\\\\" [origin]=\\\\\"tab.origin\\\\\" (onCentered)=\\\\\"_removeTabBodyWrapperHeight()\\\\\" (onCentering)=\\\\\"_setTabBodyWrapperHeight($event)\\\\\"> </md-tab-body> </div> \",\\n                styles: [\":host{display:flex;flex-direction:column;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif}:host.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{line-height:48px;height:48px;padding:0 12px;font-size:14px;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;font-weight:500;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;position:relative}.mat-tab-label:focus{outline:0;opacity:1}@media (max-width:600px){.mat-tab-label{min-width:72px}}:host[mat-stretch-tabs] .mat-tab-label,:host[md-stretch-tabs] .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{position:absolute;top:0;left:0;right:0;bottom:0;display:block;overflow:hidden}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}:host.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}.mat-tab-disabled{cursor:default;pointer-events:none} /*# sourceMappingURL=tab-group.css.map */ \"],\\n                host: {\\n                    \\'[class.mat-tab-group]\\': \\'true\\',\\n                    \\'[class.mat-tab-group-dynamic-height]\\': \\'dynamicHeight\\',\\n                    \\'[class.mat-tab-group-inverted-header]\\': \\'headerPosition === \"below\"\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabGroup.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\nMdTabGroup.propDecorators = {\\n    \\'_tabs\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdTab,] },],\\n    \\'_tabBodyWrapper\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'tabBodyWrapper\\',] },],\\n    \\'dynamicHeight\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_dynamicHeightDeprecated\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'md-dynamic-height\\',] },],\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'headerPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedIndexChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'focusChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'selectChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Used in the `md-tab-group` view to display tab labels.\\n * \\\\@docs-private\\n */\\nvar MdTabLabelWrapper = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementRef\\n     */\\n    function MdTabLabelWrapper(elementRef) {\\n        this.elementRef = elementRef;\\n        /**\\n         * Whether the tab label is disabled.\\n         */\\n        this._disabled = false;\\n    }\\n    Object.defineProperty(MdTabLabelWrapper.prototype, \"disabled\", {\\n        /**\\n         * Whether the element is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disabled; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disabled = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets focus on the wrapper element\\n     * @return {?}\\n     */\\n    MdTabLabelWrapper.prototype.focus = function () {\\n        this.elementRef.nativeElement.focus();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTabLabelWrapper.prototype.getOffsetLeft = function () {\\n        return this.elementRef.nativeElement.offsetLeft;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTabLabelWrapper.prototype.getOffsetWidth = function () {\\n        return this.elementRef.nativeElement.offsetWidth;\\n    };\\n    return MdTabLabelWrapper;\\n}());\\nMdTabLabelWrapper.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-tab-label-wrapper], [mat-tab-label-wrapper]\\',\\n                host: {\\n                    \\'[class.mat-tab-disabled]\\': \\'disabled\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabLabelWrapper.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdTabLabelWrapper.propDecorators = {\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * The ink-bar is used to display and animate the line underneath the current active tab label.\\n * \\\\@docs-private\\n */\\nvar MdInkBar = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     * @param {?} _ngZone\\n     */\\n    function MdInkBar(_renderer, _elementRef, _ngZone) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n        this._ngZone = _ngZone;\\n    }\\n    /**\\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\\n     * Shows the ink bar if previously set as hidden.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    MdInkBar.prototype.alignToElement = function (element) {\\n        var _this = this;\\n        this.show();\\n        this._ngZone.runOutsideAngular(function () {\\n            requestAnimationFrame(function () {\\n                _this._renderer.setStyle(_this._elementRef.nativeElement, \\'left\\', _this._getLeftPosition(element));\\n                _this._renderer.setStyle(_this._elementRef.nativeElement, \\'width\\', _this._getElementWidth(element));\\n            });\\n        });\\n    };\\n    /**\\n     * Shows the ink bar.\\n     * @return {?}\\n     */\\n    MdInkBar.prototype.show = function () {\\n        this._renderer.setStyle(this._elementRef.nativeElement, \\'visibility\\', \\'visible\\');\\n    };\\n    /**\\n     * Hides the ink bar.\\n     * @return {?}\\n     */\\n    MdInkBar.prototype.hide = function () {\\n        this._renderer.setStyle(this._elementRef.nativeElement, \\'visibility\\', \\'hidden\\');\\n    };\\n    /**\\n     * Generates the pixel distance from the left based on the provided element in string format.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    MdInkBar.prototype._getLeftPosition = function (element) {\\n        return element ? element.offsetLeft + \\'px\\' : \\'0\\';\\n    };\\n    /**\\n     * Generates the pixel width from the provided element in string format.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    MdInkBar.prototype._getElementWidth = function (element) {\\n        return element ? element.offsetWidth + \\'px\\' : \\'0\\';\\n    };\\n    return MdInkBar;\\n}());\\nMdInkBar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-ink-bar, mat-ink-bar\\',\\n                host: {\\n                    \\'[class.mat-ink-bar]\\': \\'true\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdInkBar.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\n/**\\n * Navigation component matching the styles of the tab group header.\\n * Provides anchored navigation with animated ink bar.\\n */\\nvar MdTabNavBar = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dir\\n     * @param {?} _ngZone\\n     */\\n    function MdTabNavBar(_dir, _ngZone) {\\n        this._dir = _dir;\\n        this._ngZone = _ngZone;\\n        /**\\n         * Combines listeners that will re-align the ink bar whenever they\\'re invoked.\\n         */\\n        this._realignInkBar = null;\\n    }\\n    /**\\n     * Notifies the component that the active link has been changed.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    MdTabNavBar.prototype.updateActiveLink = function (element) {\\n        this._activeLinkChanged = this._activeLinkElement != element;\\n        this._activeLinkElement = element;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTabNavBar.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._realignInkBar = this._ngZone.runOutsideAngular(function () {\\n            var /** @type {?} */ dirChange = _this._dir ? _this._dir.dirChange : __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].of(null);\\n            var /** @type {?} */ resize = typeof window !== \\'undefined\\' ?\\n                __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].fromEvent(window, \\'resize\\').auditTime(10) :\\n                __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].of(null);\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].merge(dirChange, resize).subscribe(function () { return _this._alignInkBar(); });\\n        });\\n    };\\n    /**\\n     * Checks if the active link has been changed and, if so, will update the ink bar.\\n     * @return {?}\\n     */\\n    MdTabNavBar.prototype.ngAfterContentChecked = function () {\\n        if (this._activeLinkChanged) {\\n            this._alignInkBar();\\n            this._activeLinkChanged = false;\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTabNavBar.prototype.ngOnDestroy = function () {\\n        if (this._realignInkBar) {\\n            this._realignInkBar.unsubscribe();\\n            this._realignInkBar = null;\\n        }\\n    };\\n    /**\\n     * Aligns the ink bar to the active link.\\n     * @return {?}\\n     */\\n    MdTabNavBar.prototype._alignInkBar = function () {\\n        if (this._activeLinkElement) {\\n            this._inkBar.alignToElement(this._activeLinkElement.nativeElement);\\n        }\\n    };\\n    return MdTabNavBar;\\n}());\\nMdTabNavBar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'[md-tab-nav-bar], [mat-tab-nav-bar]\\',\\n                template: \"<div class=\\\\\"mat-tab-links\\\\\"> <ng-content></ng-content> <md-ink-bar></md-ink-bar> </div> \",\\n                styles: [\".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative}.mat-tab-link{line-height:48px;height:48px;padding:0 12px;font-size:14px;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;font-weight:500;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-block;vertical-align:top;text-decoration:none;position:relative;overflow:hidden}.mat-tab-link:focus{outline:0;opacity:1}@media (max-width:600px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0} /*# sourceMappingURL=tab-nav-bar.css.map */ \"],\\n                host: { \\'class\\': \\'mat-tab-nav-bar\\' },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabNavBar.ctorParameters = function () { return [\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\nMdTabNavBar.propDecorators = {\\n    \\'_inkBar\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdInkBar,] },],\\n};\\n/**\\n * Link inside of a `md-tab-nav-bar`.\\n */\\nvar MdTabLink = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _mdTabNavBar\\n     * @param {?} _elementRef\\n     */\\n    function MdTabLink(_mdTabNavBar, _elementRef) {\\n        this._mdTabNavBar = _mdTabNavBar;\\n        this._elementRef = _elementRef;\\n        this._isActive = false;\\n    }\\n    Object.defineProperty(MdTabLink.prototype, \"active\", {\\n        /**\\n         * Whether the link is active.\\n         * @return {?}\\n         */\\n        get: function () { return this._isActive; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._isActive = value;\\n            if (value) {\\n                this._mdTabNavBar.updateActiveLink(this._elementRef);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return MdTabLink;\\n}());\\nMdTabLink.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-tab-link], [mat-tab-link]\\',\\n                host: { \\'class\\': \\'mat-tab-link\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabLink.ctorParameters = function () { return [\\n    { type: MdTabNavBar, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdTabLink.propDecorators = {\\n    \\'active\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Simple directive that extends the ripple and matches the selector of the MdTabLink. This\\n * adds the ripple behavior to nav bar labels.\\n */\\nvar MdTabLinkRipple = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdTabLinkRipple, _super);\\n    /**\\n     * @param {?} elementRef\\n     * @param {?} ngZone\\n     * @param {?} ruler\\n     * @param {?} platform\\n     * @param {?} globalOptions\\n     */\\n    function MdTabLinkRipple(elementRef, ngZone, ruler, platform, globalOptions) {\\n        return _super.call(this, elementRef, ngZone, ruler, platform, globalOptions) || this;\\n    }\\n    return MdTabLinkRipple;\\n}(MdRipple));\\nMdTabLinkRipple.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-tab-link], [mat-tab-link]\\',\\n                host: { \\'class\\': \\'mat-tab-link\\' },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabLinkRipple.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: ViewportRuler, },\\n    { type: Platform, },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_RIPPLE_GLOBAL_OPTIONS,] },] },\\n]; };\\n/**\\n * Wrapper for the contents of a tab.\\n * \\\\@docs-private\\n */\\nvar MdTabBody = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dir\\n     * @param {?} _elementRef\\n     */\\n    function MdTabBody(_dir, _elementRef) {\\n        this._dir = _dir;\\n        this._elementRef = _elementRef;\\n        /**\\n         * Event emitted when the tab begins to animate towards the center as the active tab.\\n         */\\n        this.onCentering = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the tab completes its animation towards the center.\\n         */\\n        this.onCentered = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"](true);\\n    }\\n    Object.defineProperty(MdTabBody.prototype, \"position\", {\\n        /**\\n         * @param {?} position\\n         * @return {?}\\n         */\\n        set: function (position) {\\n            if (position < 0) {\\n                this._position = this._getLayoutDirection() == \\'ltr\\' ? \\'left\\' : \\'right\\';\\n            }\\n            else if (position > 0) {\\n                this._position = this._getLayoutDirection() == \\'ltr\\' ? \\'right\\' : \\'left\\';\\n            }\\n            else {\\n                this._position = \\'center\\';\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabBody.prototype, \"origin\", {\\n        /**\\n         * The origin position from which this tab should appear when it is centered into view.\\n         * @param {?} origin\\n         * @return {?}\\n         */\\n        set: function (origin) {\\n            if (origin == null) {\\n                return;\\n            }\\n            var /** @type {?} */ dir = this._getLayoutDirection();\\n            if ((dir == \\'ltr\\' && origin <= 0) || (dir == \\'rtl\\' && origin > 0)) {\\n                this._origin = \\'left\\';\\n            }\\n            else {\\n                this._origin = \\'right\\';\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * After initialized, check if the content is centered and has an origin. If so, set the\\n     * special position states that transition the tab from the left or right before centering.\\n     * @return {?}\\n     */\\n    MdTabBody.prototype.ngOnInit = function () {\\n        if (this._position == \\'center\\' && this._origin) {\\n            this._position = this._origin == \\'left\\' ? \\'left-origin-center\\' : \\'right-origin-center\\';\\n        }\\n    };\\n    /**\\n     * After the view has been set, check if the tab content is set to the center and attach the\\n     * content if it is not already attached.\\n     * @return {?}\\n     */\\n    MdTabBody.prototype.ngAfterViewChecked = function () {\\n        if (this._isCenterPosition(this._position) && !this._portalHost.hasAttached()) {\\n            this._portalHost.attach(this._content);\\n        }\\n    };\\n    /**\\n     * @param {?} e\\n     * @return {?}\\n     */\\n    MdTabBody.prototype._onTranslateTabStarted = function (e) {\\n        if (this._isCenterPosition(e.toState)) {\\n            this.onCentering.emit(this._elementRef.nativeElement.clientHeight);\\n        }\\n    };\\n    /**\\n     * @param {?} e\\n     * @return {?}\\n     */\\n    MdTabBody.prototype._onTranslateTabComplete = function (e) {\\n        // If the end state is that the tab is not centered, then detach the content.\\n        if (!this._isCenterPosition(e.toState) && !this._isCenterPosition(this._position)) {\\n            this._portalHost.detach();\\n        }\\n        // If the transition to the center is complete, emit an event.\\n        if (this._isCenterPosition(e.toState) && this._isCenterPosition(this._position)) {\\n            this.onCentered.emit();\\n        }\\n    };\\n    /**\\n     * The text direction of the containing app.\\n     * @return {?}\\n     */\\n    MdTabBody.prototype._getLayoutDirection = function () {\\n        return this._dir && this._dir.value === \\'rtl\\' ? \\'rtl\\' : \\'ltr\\';\\n    };\\n    /**\\n     * Whether the provided position state is considered center, regardless of origin.\\n     * @param {?} position\\n     * @return {?}\\n     */\\n    MdTabBody.prototype._isCenterPosition = function (position) {\\n        return position == \\'center\\' ||\\n            position == \\'left-origin-center\\' ||\\n            position == \\'right-origin-center\\';\\n    };\\n    return MdTabBody;\\n}());\\nMdTabBody.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-tab-body, mat-tab-body\\',\\n                template: \"<div class=\\\\\"mat-tab-body-content\\\\\" #content [@translateTab]=\\\\\"_position\\\\\" (@translateTab.start)=\\\\\"_onTranslateTabStarted($event)\\\\\" (@translateTab.done)=\\\\\"_onTranslateTabComplete($event)\\\\\"> <ng-template cdkPortalHost></ng-template> </div> \",\\n                styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden} /*# sourceMappingURL=tab-body.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'[class.mat-tab-body]\\': \\'true\\',\\n                },\\n                animations: [\\n                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"trigger\"])(\\'translateTab\\', [\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'void\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(0, 0, 0)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'left\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(-100%, 0, 0)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'left-origin-center\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(0, 0, 0)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'right-origin-center\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(0, 0, 0)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'center\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(0, 0, 0)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'right\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(100%, 0, 0)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'* => left, * => right, left => center, right => center\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\\'500ms cubic-bezier(0.35, 0, 0.25, 1)\\')),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'void => left-origin-center\\', [\\n                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(-100%, 0, 0)\\' }),\\n                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\\'500ms cubic-bezier(0.35, 0, 0.25, 1)\\')\\n                        ]),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'void => right-origin-center\\', [\\n                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(100%, 0, 0)\\' }),\\n                            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\\'500ms cubic-bezier(0.35, 0, 0.25, 1)\\')\\n                        ])\\n                    ])\\n                ]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabBody.ctorParameters = function () { return [\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdTabBody.propDecorators = {\\n    \\'_portalHost\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [PortalHostDirective,] },],\\n    \\'onCentering\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'onCentered\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'_content\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'content\\',] },],\\n    \\'position\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'position\\',] },],\\n    \\'origin\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'origin\\',] },],\\n};\\n/**\\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\\n * provide a small affordance to the label next to it.\\n */\\nvar EXAGGERATED_OVERSCROLL = 60;\\n/**\\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\\n * an ink bar that follows the currently selected tab. When the tabs list\\'s width exceeds the\\n * width of the header container, then arrows will be displayed to allow the user to scroll\\n * left and right across the header.\\n * \\\\@docs-private\\n */\\nvar MdTabHeader = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _ngZone\\n     * @param {?} _dir\\n     */\\n    function MdTabHeader(_elementRef, _ngZone, _dir) {\\n        this._elementRef = _elementRef;\\n        this._ngZone = _ngZone;\\n        this._dir = _dir;\\n        /**\\n         * The tab index that is focused.\\n         */\\n        this._focusIndex = 0;\\n        /**\\n         * The distance in pixels that the tab labels should be translated to the left.\\n         */\\n        this._scrollDistance = 0;\\n        /**\\n         * Whether the header should scroll to the selected index after the view has been checked.\\n         */\\n        this._selectedIndexChanged = false;\\n        /**\\n         * Combines listeners that will re-align the ink bar whenever they\\'re invoked.\\n         */\\n        this._realignInkBar = null;\\n        /**\\n         * Whether the controls for pagination should be displayed\\n         */\\n        this._showPaginationControls = false;\\n        /**\\n         * Whether the tab list can be scrolled more towards the end of the tab label list.\\n         */\\n        this._disableScrollAfter = true;\\n        /**\\n         * Whether the tab list can be scrolled more towards the beginning of the tab label list.\\n         */\\n        this._disableScrollBefore = true;\\n        this._selectedIndex = 0;\\n        this._disableRipple = false;\\n        /**\\n         * Event emitted when the option is selected.\\n         */\\n        this.selectFocusedIndex = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when a label is focused.\\n         */\\n        this.indexFocused = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(MdTabHeader.prototype, \"selectedIndex\", {\\n        /**\\n         * The index of the active tab.\\n         * @return {?}\\n         */\\n        get: function () { return this._selectedIndex; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._selectedIndexChanged = this._selectedIndex != value;\\n            this._selectedIndex = value;\\n            this._focusIndex = value;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabHeader.prototype, \"disableRipple\", {\\n        /**\\n         * Whether ripples for the tab-header labels should be disabled or not.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype.ngAfterContentChecked = function () {\\n        // If the number of tab labels have changed, check if scrolling should be enabled\\n        if (this._tabLabelCount != this._labelWrappers.length) {\\n            this._updatePagination();\\n            this._tabLabelCount = this._labelWrappers.length;\\n        }\\n        // If the selected index has changed, scroll to the label and check if the scrolling controls\\n        // should be disabled.\\n        if (this._selectedIndexChanged) {\\n            this._scrollToLabel(this._selectedIndex);\\n            this._checkScrollingControls();\\n            this._alignInkBarToSelectedTab();\\n            this._selectedIndexChanged = false;\\n        }\\n        // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\\n        // then translate the header to reflect this.\\n        if (this._scrollDistanceChanged) {\\n            this._updateTabScrollPosition();\\n            this._scrollDistanceChanged = false;\\n        }\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._handleKeydown = function (event) {\\n        switch (event.keyCode) {\\n            case RIGHT_ARROW:\\n                this._focusNextTab();\\n                break;\\n            case LEFT_ARROW:\\n                this._focusPreviousTab();\\n                break;\\n            case ENTER:\\n                this.selectFocusedIndex.emit(this.focusIndex);\\n                break;\\n        }\\n    };\\n    /**\\n     * Aligns the ink bar to the selected tab on load.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._realignInkBar = this._ngZone.runOutsideAngular(function () {\\n            var /** @type {?} */ dirChange = _this._dir ? _this._dir.dirChange : __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].of(null);\\n            var /** @type {?} */ resize = typeof window !== \\'undefined\\' ?\\n                __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].fromEvent(window, \\'resize\\').auditTime(10) :\\n                __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].of(null);\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].merge(dirChange, resize).startWith(null).subscribe(function () {\\n                _this._updatePagination();\\n                _this._alignInkBarToSelectedTab();\\n            });\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype.ngOnDestroy = function () {\\n        if (this._realignInkBar) {\\n            this._realignInkBar.unsubscribe();\\n            this._realignInkBar = null;\\n        }\\n    };\\n    /**\\n     * Callback for when the MutationObserver detects that the content has changed.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._onContentChanges = function () {\\n        this._updatePagination();\\n        this._alignInkBarToSelectedTab();\\n    };\\n    /**\\n     * Updating the view whether pagination should be enabled or not\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._updatePagination = function () {\\n        this._checkPaginationEnabled();\\n        this._checkScrollingControls();\\n        this._updateTabScrollPosition();\\n    };\\n    Object.defineProperty(MdTabHeader.prototype, \"focusIndex\", {\\n        /**\\n         * Tracks which element has focus; used for keyboard navigation\\n         * @return {?}\\n         */\\n        get: function () { return this._focusIndex; },\\n        /**\\n         * When the focus index is set, we must manually send focus to the correct label\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (!this._isValidIndex(value) || this._focusIndex == value) {\\n                return;\\n            }\\n            this._focusIndex = value;\\n            this.indexFocused.emit(value);\\n            this._setTabFocus(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\\n     * providing a valid index and return true.\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._isValidIndex = function (index) {\\n        if (!this._labelWrappers) {\\n            return true;\\n        }\\n        var /** @type {?} */ tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\\n        return tab && !tab.disabled;\\n    };\\n    /**\\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\\n     * scrolling is enabled.\\n     * @param {?} tabIndex\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._setTabFocus = function (tabIndex) {\\n        if (this._showPaginationControls) {\\n            this._scrollToLabel(tabIndex);\\n        }\\n        if (this._labelWrappers && this._labelWrappers.length) {\\n            this._labelWrappers.toArray()[tabIndex].focus();\\n            // Do not let the browser manage scrolling to focus the element, this will be handled\\n            // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\\n            // should be the full width minus the offset width.\\n            var /** @type {?} */ containerEl = this._tabListContainer.nativeElement;\\n            var /** @type {?} */ dir = this._getLayoutDirection();\\n            if (dir == \\'ltr\\') {\\n                containerEl.scrollLeft = 0;\\n            }\\n            else {\\n                containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\\n            }\\n        }\\n    };\\n    /**\\n     * Moves the focus towards the beginning or the end of the list depending on the offset provided.\\n     * Valid offsets are 1 and -1.\\n     * @param {?} offset\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._moveFocus = function (offset) {\\n        if (this._labelWrappers) {\\n            var /** @type {?} */ tabs = this._labelWrappers.toArray();\\n            for (var /** @type {?} */ i = this.focusIndex + offset; i < tabs.length && i >= 0; i += offset) {\\n                if (this._isValidIndex(i)) {\\n                    this.focusIndex = i;\\n                    return;\\n                }\\n            }\\n        }\\n    };\\n    /**\\n     * Increment the focus index by 1 until a valid tab is found.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._focusNextTab = function () {\\n        this._moveFocus(this._getLayoutDirection() == \\'ltr\\' ? 1 : -1);\\n    };\\n    /**\\n     * Decrement the focus index by 1 until a valid tab is found.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._focusPreviousTab = function () {\\n        this._moveFocus(this._getLayoutDirection() == \\'ltr\\' ? -1 : 1);\\n    };\\n    /**\\n     * The layout direction of the containing app.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._getLayoutDirection = function () {\\n        return this._dir && this._dir.value === \\'rtl\\' ? \\'rtl\\' : \\'ltr\\';\\n    };\\n    /**\\n     * Performs the CSS transformation on the tab list that will cause the list to scroll.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._updateTabScrollPosition = function () {\\n        var /** @type {?} */ translateX = this.scrollDistance + \\'px\\';\\n        if (this._getLayoutDirection() == \\'ltr\\') {\\n            translateX = \\'-\\' + translateX;\\n        }\\n        applyCssTransform(this._tabList.nativeElement, \"translate3d(\" + translateX + \", 0, 0)\");\\n    };\\n    Object.defineProperty(MdTabHeader.prototype, \"scrollDistance\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._scrollDistance; },\\n        /**\\n         * Sets the distance in pixels that the tab header should be transformed in the X-axis.\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));\\n            // Mark that the scroll distance has changed so that after the view is checked, the CSS\\n            // transformation can move the header.\\n            this._scrollDistanceChanged = true;\\n            this._checkScrollingControls();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Moves the tab list in the \\'before\\' or \\'after\\' direction (towards the beginning of the list or\\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\\n     * length of the tab list view window.\\n     *\\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\\n     * should be called sparingly.\\n     * @param {?} scrollDir\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._scrollHeader = function (scrollDir) {\\n        var /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\\n        // Move the scroll distance one-third the length of the tab list\\'s viewport.\\n        this.scrollDistance += (scrollDir == \\'before\\' ? -1 : 1) * viewLength / 3;\\n    };\\n    /**\\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\\n     *\\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\\n     * should be called sparingly.\\n     * @param {?} labelIndex\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._scrollToLabel = function (labelIndex) {\\n        var /** @type {?} */ selectedLabel = this._labelWrappers\\n            ? this._labelWrappers.toArray()[labelIndex]\\n            : null;\\n        if (!selectedLabel) {\\n            return;\\n        }\\n        // The view length is the visible width of the tab labels.\\n        var /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\\n        var /** @type {?} */ labelBeforePos, /** @type {?} */ labelAfterPos;\\n        if (this._getLayoutDirection() == \\'ltr\\') {\\n            labelBeforePos = selectedLabel.getOffsetLeft();\\n            labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\\n        }\\n        else {\\n            labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\\n            labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\\n        }\\n        var /** @type {?} */ beforeVisiblePos = this.scrollDistance;\\n        var /** @type {?} */ afterVisiblePos = this.scrollDistance + viewLength;\\n        if (labelBeforePos < beforeVisiblePos) {\\n            // Scroll header to move label to the before direction\\n            this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\\n        }\\n        else if (labelAfterPos > afterVisiblePos) {\\n            // Scroll header to move label to the after direction\\n            this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\\n        }\\n    };\\n    /**\\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\\n     * tab list is wider than the size of the header container, then the pagination controls should\\n     * be shown.\\n     *\\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\\n     * should be called sparingly.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._checkPaginationEnabled = function () {\\n        this._showPaginationControls =\\n            this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\\n        if (!this._showPaginationControls) {\\n            this.scrollDistance = 0;\\n        }\\n    };\\n    /**\\n     * Evaluate whether the before and after controls should be enabled or disabled.\\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\\n     * before button. If the header is at the end of the list (scroll distance is equal to the\\n     * maximum distance we can scroll), then disable the after button.\\n     *\\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\\n     * should be called sparingly.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._checkScrollingControls = function () {\\n        // Check if the pagination arrows should be activated.\\n        this._disableScrollBefore = this.scrollDistance == 0;\\n        this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\\n    };\\n    /**\\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\\n     * is equal to the difference in width between the tab list container and tab header container.\\n     *\\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\\n     * should be called sparingly.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._getMaxScrollDistance = function () {\\n        var /** @type {?} */ lengthOfTabList = this._tabList.nativeElement.scrollWidth;\\n        var /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\\n        return lengthOfTabList - viewLength;\\n    };\\n    /**\\n     * Tells the ink-bar to align itself to the current label wrapper\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._alignInkBarToSelectedTab = function () {\\n        var /** @type {?} */ selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length\\n            ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement\\n            : null;\\n        this._inkBar.alignToElement(selectedLabelWrapper);\\n    };\\n    return MdTabHeader;\\n}());\\nMdTabHeader.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-tab-header, mat-tab-header\\',\\n                template: \"<div class=\\\\\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\\\\\" aria-hidden=\\\\\"true\\\\\" md-ripple [mdRippleDisabled]=\\\\\"_disableScrollBefore || disableRipple\\\\\" [class.mat-tab-header-pagination-disabled]=\\\\\"_disableScrollBefore\\\\\" (click)=\\\\\"_scrollHeader(\\'before\\')\\\\\"> <div class=\\\\\"mat-tab-header-pagination-chevron\\\\\"></div> </div> <div class=\\\\\"mat-tab-label-container\\\\\" #tabListContainer (keydown)=\\\\\"_handleKeydown($event)\\\\\"> <div class=\\\\\"mat-tab-list\\\\\" #tabList role=\\\\\"tablist\\\\\" (cdkObserveContent)=\\\\\"_onContentChanges()\\\\\"> <div class=\\\\\"mat-tab-labels\\\\\"> <ng-content></ng-content> </div> <md-ink-bar></md-ink-bar> </div> </div> <div class=\\\\\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\\\\\" aria-hidden=\\\\\"true\\\\\" md-ripple [mdRippleDisabled]=\\\\\"_disableScrollAfter || disableRipple\\\\\" [class.mat-tab-header-pagination-disabled]=\\\\\"_disableScrollAfter\\\\\" (click)=\\\\\"_scrollHeader(\\'after\\')\\\\\"> <div class=\\\\\"mat-tab-header-pagination-chevron\\\\\"></div> </div> \",\\n                styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{line-height:48px;height:48px;padding:0 12px;font-size:14px;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;font-weight:500;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;position:relative}.mat-tab-label:focus{outline:0;opacity:1}@media (max-width:600px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.mat-tab-header-pagination{position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\\'\\';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#ccc}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex} /*# sourceMappingURL=tab-header.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'class\\': \\'mat-tab-header\\',\\n                    \\'[class.mat-tab-header-pagination-controls-enabled]\\': \\'_showPaginationControls\\',\\n                    \\'[class.mat-tab-header-rtl]\\': \"_getLayoutDirection() == \\'rtl\\'\",\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabHeader.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdTabHeader.propDecorators = {\\n    \\'_labelWrappers\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdTabLabelWrapper,] },],\\n    \\'_inkBar\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdInkBar,] },],\\n    \\'_tabListContainer\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'tabListContainer\\',] },],\\n    \\'_tabList\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'tabList\\',] },],\\n    \\'selectedIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectFocusedIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'indexFocused\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdTabsModule = /*@__PURE__*/(function () {\\n    function MdTabsModule() {\\n    }\\n    return MdTabsModule;\\n}());\\nMdTabsModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"],\\n                    PortalModule,\\n                    MdRippleModule,\\n                    ObserveContentModule,\\n                    ScrollDispatchModule,\\n                ],\\n                // Don\\'t export all components because some are only to be used internally.\\n                exports: [\\n                    MdTabGroup,\\n                    MdTabLabel,\\n                    MdTab,\\n                    MdTabNavBar,\\n                    MdTabLink,\\n                    MdTabLinkRipple\\n                ],\\n                declarations: [\\n                    MdTabGroup,\\n                    MdTabLabel,\\n                    MdTab,\\n                    MdInkBar,\\n                    MdTabLabelWrapper,\\n                    MdTabNavBar,\\n                    MdTabLink,\\n                    MdTabBody,\\n                    MdTabLinkRipple,\\n                    MdTabHeader\\n                ],\\n                providers: [VIEWPORT_RULER_PROVIDER],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabsModule.ctorParameters = function () { return []; };\\nvar MdToolbarRow = /*@__PURE__*/(function () {\\n    function MdToolbarRow() {\\n    }\\n    return MdToolbarRow;\\n}());\\nMdToolbarRow.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-toolbar-row, mat-toolbar-row\\',\\n                host: {\\n                    \\'[class.mat-toolbar-row]\\': \\'true\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdToolbarRow.ctorParameters = function () { return []; };\\nvar MdToolbar = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     */\\n    function MdToolbar(_elementRef, _renderer) {\\n        this._elementRef = _elementRef;\\n        this._renderer = _renderer;\\n    }\\n    Object.defineProperty(MdToolbar.prototype, \"color\", {\\n        /**\\n         * The color of the toolbar. Can be primary, accent, or warn.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._color;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._updateColor(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} newColor\\n     * @return {?}\\n     */\\n    MdToolbar.prototype._updateColor = function (newColor) {\\n        this._setElementColor(this._color, false);\\n        this._setElementColor(newColor, true);\\n        this._color = newColor;\\n    };\\n    /**\\n     * @param {?} color\\n     * @param {?} isAdd\\n     * @return {?}\\n     */\\n    MdToolbar.prototype._setElementColor = function (color, isAdd) {\\n        if (color != null && color != \\'\\') {\\n            var /** @type {?} */ element = this._elementRef.nativeElement;\\n            if (isAdd) {\\n                this._renderer.addClass(element, \"mat-\" + color);\\n            }\\n            else {\\n                this._renderer.removeClass(element, \"mat-\" + color);\\n            }\\n        }\\n    };\\n    return MdToolbar;\\n}());\\nMdToolbar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-toolbar, mat-toolbar\\',\\n                template: \"<div class=\\\\\"mat-toolbar-layout\\\\\"> <md-toolbar-row> <ng-content></ng-content> </md-toolbar-row> <ng-content select=\\\\\"md-toolbar-row, mat-toolbar-row\\\\\"></ng-content> </div> \",\\n                styles: [\".mat-toolbar{display:flex;box-sizing:border-box;width:100%;font-size:20px;font-weight:500;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;padding:0 16px;flex-direction:column}.mat-toolbar .mat-toolbar-row{display:flex;box-sizing:border-box;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar{min-height:64px}.mat-toolbar-row{height:64px}@media (max-width:600px){.mat-toolbar{min-height:56px}.mat-toolbar-row{height:56px}} /*# sourceMappingURL=toolbar.css.map */ \"],\\n                host: {\\n                    \\'[class.mat-toolbar]\\': \\'true\\',\\n                    \\'role\\': \\'toolbar\\'\\n                },\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdToolbar.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\nMdToolbar.propDecorators = {\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdToolbarModule = /*@__PURE__*/(function () {\\n    function MdToolbarModule() {\\n    }\\n    return MdToolbarModule;\\n}());\\nMdToolbarModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule],\\n                exports: [MdToolbar, MdToolbarRow, MdCommonModule],\\n                declarations: [MdToolbar, MdToolbarRow],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdToolbarModule.ctorParameters = function () { return []; };\\n/**\\n * Time in ms to delay before changing the tooltip visibility to hidden\\n */\\nvar TOUCHEND_HIDE_DELAY = 1500;\\n/**\\n * Time in ms to throttle repositioning after scroll events.\\n */\\nvar SCROLL_THROTTLE_MS = 20;\\n/**\\n * Throws an error if the user supplied an invalid tooltip position.\\n * @param {?} position\\n * @return {?}\\n */\\nfunction throwMdTooltipInvalidPositionError(position) {\\n    throw new Error(\"Tooltip position \\\\\"\" + position + \"\\\\\" is invalid.\");\\n}\\n/**\\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\\n * hiding of a tooltip provided position (defaults to below the element).\\n *\\n * https://material.google.com/components/tooltips.html\\n */\\nvar MdTooltip = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlay\\n     * @param {?} _elementRef\\n     * @param {?} _scrollDispatcher\\n     * @param {?} _viewContainerRef\\n     * @param {?} _ngZone\\n     * @param {?} _renderer\\n     * @param {?} _platform\\n     * @param {?} _dir\\n     */\\n    function MdTooltip(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _renderer, _platform, _dir) {\\n        var _this = this;\\n        this._overlay = _overlay;\\n        this._elementRef = _elementRef;\\n        this._scrollDispatcher = _scrollDispatcher;\\n        this._viewContainerRef = _viewContainerRef;\\n        this._ngZone = _ngZone;\\n        this._renderer = _renderer;\\n        this._platform = _platform;\\n        this._dir = _dir;\\n        this._position = \\'below\\';\\n        this._disabled = false;\\n        /**\\n         * The default delay in ms before showing the tooltip after show is called\\n         */\\n        this.showDelay = 0;\\n        /**\\n         * The default delay in ms before hiding the tooltip after hide is called\\n         */\\n        this.hideDelay = 0;\\n        // The mouse events shouldn\\'t be bound on iOS devices, because\\n        // they can prevent the first tap from firing its click event.\\n        if (!_platform.IOS) {\\n            _renderer.listen(_elementRef.nativeElement, \\'mouseenter\\', function () { return _this.show(); });\\n            _renderer.listen(_elementRef.nativeElement, \\'mouseleave\\', function () { return _this.hide(); });\\n        }\\n    }\\n    Object.defineProperty(MdTooltip.prototype, \"position\", {\\n        /**\\n         * Allows the user to define the position of the tooltip relative to the parent element\\n         * @return {?}\\n         */\\n        get: function () { return this._position; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value !== this._position) {\\n                this._position = value;\\n                // TODO(andrewjs): When the overlay\\'s position can be dynamically changed, do not destroy\\n                // the tooltip.\\n                if (this._tooltipInstance) {\\n                    this._disposeTooltip();\\n                }\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"disabled\", {\\n        /**\\n         * Disables the display of the tooltip.\\n         * @return {?}\\n         */\\n        get: function () { return this._disabled; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = coerceBooleanProperty(value);\\n            // If tooltip is disabled, hide immediately.\\n            if (this._disabled) {\\n                this.hide(0);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_positionDeprecated\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this._position; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._position = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"message\", {\\n        /**\\n         * The message to be displayed in the tooltip\\n         * @return {?}\\n         */\\n        get: function () { return this._message; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._message = value;\\n            if (this._tooltipInstance) {\\n                this._setTooltipMessage(this._message);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_deprecatedMessage\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this.message; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.message = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matMessage\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.message; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.message = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matPosition\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.position; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.position = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matDisabled\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.disabled; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.disabled = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matHideDelay\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.hideDelay; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.hideDelay = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matShowDelay\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.showDelay; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.showDelay = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Dispose the tooltip when destroyed.\\n     * @return {?}\\n     */\\n    MdTooltip.prototype.ngOnDestroy = function () {\\n        if (this._tooltipInstance) {\\n            this._disposeTooltip();\\n        }\\n    };\\n    /**\\n     * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input\\n     * @param {?=} delay\\n     * @return {?}\\n     */\\n    MdTooltip.prototype.show = function (delay) {\\n        if (delay === void 0) { delay = this.showDelay; }\\n        if (this.disabled || !this._message || !this._message.trim()) {\\n            return;\\n        }\\n        if (!this._tooltipInstance) {\\n            this._createTooltip();\\n        }\\n        this._setTooltipMessage(this._message);\\n        this._tooltipInstance.show(this._position, delay);\\n    };\\n    /**\\n     * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input\\n     * @param {?=} delay\\n     * @return {?}\\n     */\\n    MdTooltip.prototype.hide = function (delay) {\\n        if (delay === void 0) { delay = this.hideDelay; }\\n        if (this._tooltipInstance) {\\n            this._tooltipInstance.hide(delay);\\n        }\\n    };\\n    /**\\n     * Shows/hides the tooltip\\n     * @return {?}\\n     */\\n    MdTooltip.prototype.toggle = function () {\\n        this._isTooltipVisible() ? this.hide() : this.show();\\n    };\\n    /**\\n     * Returns true if the tooltip is currently visible to the user\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._isTooltipVisible = function () {\\n        return !!this._tooltipInstance && this._tooltipInstance.isVisible();\\n    };\\n    /**\\n     * Create the tooltip to display\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._createTooltip = function () {\\n        var _this = this;\\n        this._createOverlay();\\n        var /** @type {?} */ portal = new ComponentPortal(TooltipComponent, this._viewContainerRef);\\n        this._tooltipInstance = this._overlayRef.attach(portal).instance;\\n        // Dispose the overlay when finished the shown tooltip.\\n        this._tooltipInstance.afterHidden().subscribe(function () {\\n            // Check first if the tooltip has already been removed through this components destroy.\\n            if (_this._tooltipInstance) {\\n                _this._disposeTooltip();\\n            }\\n        });\\n    };\\n    /**\\n     * Create the overlay config and position strategy\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._createOverlay = function () {\\n        var _this = this;\\n        var /** @type {?} */ origin = this._getOrigin();\\n        var /** @type {?} */ position = this._getOverlayPosition();\\n        // Create connected position strategy that listens for scroll events to reposition.\\n        // After position changes occur and the overlay is clipped by a parent scrollable then\\n        // close the tooltip.\\n        var /** @type {?} */ strategy = this._overlay.position().connectedTo(this._elementRef, origin, position);\\n        strategy.withScrollableContainers(this._scrollDispatcher.getScrollContainers(this._elementRef));\\n        strategy.onPositionChange.subscribe(function (change) {\\n            if (change.scrollableViewProperties.isOverlayClipped &&\\n                _this._tooltipInstance && _this._tooltipInstance.isVisible()) {\\n                _this.hide(0);\\n            }\\n        });\\n        var /** @type {?} */ config = new OverlayState();\\n        config.direction = this._dir ? this._dir.value : \\'ltr\\';\\n        config.positionStrategy = strategy;\\n        config.scrollStrategy =\\n            new RepositionScrollStrategy(this._scrollDispatcher, SCROLL_THROTTLE_MS);\\n        this._overlayRef = this._overlay.create(config);\\n    };\\n    /**\\n     * Disposes the current tooltip and the overlay it is attached to\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._disposeTooltip = function () {\\n        this._overlayRef.dispose();\\n        this._overlayRef = null;\\n        this._tooltipInstance = null;\\n    };\\n    /**\\n     * Returns the origin position based on the user\\'s position preference\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._getOrigin = function () {\\n        if (this.position == \\'above\\' || this.position == \\'below\\') {\\n            return { originX: \\'center\\', originY: this.position == \\'above\\' ? \\'top\\' : \\'bottom\\' };\\n        }\\n        var /** @type {?} */ isDirectionLtr = !this._dir || this._dir.value == \\'ltr\\';\\n        if (this.position == \\'left\\' ||\\n            this.position == \\'before\\' && isDirectionLtr ||\\n            this.position == \\'after\\' && !isDirectionLtr) {\\n            return { originX: \\'start\\', originY: \\'center\\' };\\n        }\\n        if (this.position == \\'right\\' ||\\n            this.position == \\'after\\' && isDirectionLtr ||\\n            this.position == \\'before\\' && !isDirectionLtr) {\\n            return { originX: \\'end\\', originY: \\'center\\' };\\n        }\\n        throwMdTooltipInvalidPositionError(this.position);\\n    };\\n    /**\\n     * Returns the overlay position based on the user\\'s preference\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._getOverlayPosition = function () {\\n        if (this.position == \\'above\\') {\\n            return { overlayX: \\'center\\', overlayY: \\'bottom\\' };\\n        }\\n        if (this.position == \\'below\\') {\\n            return { overlayX: \\'center\\', overlayY: \\'top\\' };\\n        }\\n        var /** @type {?} */ isLtr = !this._dir || this._dir.value == \\'ltr\\';\\n        if (this.position == \\'left\\' ||\\n            this.position == \\'before\\' && isLtr ||\\n            this.position == \\'after\\' && !isLtr) {\\n            return { overlayX: \\'end\\', overlayY: \\'center\\' };\\n        }\\n        if (this.position == \\'right\\' ||\\n            this.position == \\'after\\' && isLtr ||\\n            this.position == \\'before\\' && !isLtr) {\\n            return { overlayX: \\'start\\', overlayY: \\'center\\' };\\n        }\\n        throwMdTooltipInvalidPositionError(this.position);\\n    };\\n    /**\\n     * Updates the tooltip message and repositions the overlay according to the new message length\\n     * @param {?} message\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._setTooltipMessage = function (message) {\\n        var _this = this;\\n        // Must wait for the message to be painted to the tooltip so that the overlay can properly\\n        // calculate the correct positioning based on the size of the text.\\n        this._tooltipInstance.message = message;\\n        this._tooltipInstance._markForCheck();\\n        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {\\n            if (_this._tooltipInstance) {\\n                _this._overlayRef.updatePosition();\\n            }\\n        });\\n    };\\n    return MdTooltip;\\n}());\\nMdTooltip.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-tooltip], [mdTooltip], [mat-tooltip], [matTooltip]\\',\\n                host: {\\n                    \\'(longpress)\\': \\'show()\\',\\n                    \\'(touchend)\\': \\'hide(\\' + TOUCHEND_HIDE_DELAY + \\')\\',\\n                },\\n                exportAs: \\'mdTooltip\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTooltip.ctorParameters = function () { return [\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: ScrollDispatcher, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: Platform, },\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdTooltip.propDecorators = {\\n    \\'position\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltipPosition\\',] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltipDisabled\\',] },],\\n    \\'_positionDeprecated\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'tooltip-position\\',] },],\\n    \\'showDelay\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltipShowDelay\\',] },],\\n    \\'hideDelay\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltipHideDelay\\',] },],\\n    \\'message\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltip\\',] },],\\n    \\'_deprecatedMessage\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'md-tooltip\\',] },],\\n    \\'_matMessage\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltip\\',] },],\\n    \\'_matPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltipPosition\\',] },],\\n    \\'_matDisabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltipDisabled\\',] },],\\n    \\'_matHideDelay\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltipHideDelay\\',] },],\\n    \\'_matShowDelay\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltipShowDelay\\',] },],\\n};\\n/**\\n * Internal component that wraps the tooltip\\'s content.\\n * \\\\@docs-private\\n */\\nvar TooltipComponent = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dir\\n     * @param {?} _changeDetectorRef\\n     */\\n    function TooltipComponent(_dir, _changeDetectorRef) {\\n        this._dir = _dir;\\n        this._changeDetectorRef = _changeDetectorRef;\\n        /**\\n         * Property watched by the animation framework to show or hide the tooltip\\n         */\\n        this._visibility = \\'initial\\';\\n        /**\\n         * Whether interactions on the page should close the tooltip\\n         */\\n        this._closeOnInteraction = false;\\n        /**\\n         * The transform origin used in the animation for showing and hiding the tooltip\\n         */\\n        this._transformOrigin = \\'bottom\\';\\n        /**\\n         * Subject for notifying that the tooltip has been hidden from the view\\n         */\\n        this._onHide = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n    }\\n    /**\\n     * Shows the tooltip with an animation originating from the provided origin\\n     * @param {?} position Position of the tooltip.\\n     * @param {?} delay Amount of milliseconds to the delay showing the tooltip.\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype.show = function (position, delay) {\\n        var _this = this;\\n        // Cancel the delayed hide if it is scheduled\\n        if (this._hideTimeoutId) {\\n            clearTimeout(this._hideTimeoutId);\\n        }\\n        // Body interactions should cancel the tooltip if there is a delay in showing.\\n        this._closeOnInteraction = true;\\n        this._setTransformOrigin(position);\\n        this._showTimeoutId = setTimeout(function () {\\n            _this._visibility = \\'visible\\';\\n            // If this was set to true immediately, then a body click that triggers show() would\\n            // trigger interaction and close the tooltip right after it was displayed.\\n            _this._closeOnInteraction = false;\\n            // Mark for check so if any parent component has set the\\n            // ChangeDetectionStrategy to OnPush it will be checked anyways\\n            _this._markForCheck();\\n            setTimeout(function () { return _this._closeOnInteraction = true; }, 0);\\n        }, delay);\\n    };\\n    /**\\n     * Begins the animation to hide the tooltip after the provided delay in ms.\\n     * @param {?} delay Amount of milliseconds to delay showing the tooltip.\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype.hide = function (delay) {\\n        var _this = this;\\n        // Cancel the delayed show if it is scheduled\\n        if (this._showTimeoutId) {\\n            clearTimeout(this._showTimeoutId);\\n        }\\n        this._hideTimeoutId = setTimeout(function () {\\n            _this._visibility = \\'hidden\\';\\n            _this._closeOnInteraction = false;\\n            // Mark for check so if any parent component has set the\\n            // ChangeDetectionStrategy to OnPush it will be checked anyways\\n            _this._markForCheck();\\n        }, delay);\\n    };\\n    /**\\n     * Returns an observable that notifies when the tooltip has been hidden from view\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype.afterHidden = function () {\\n        return this._onHide.asObservable();\\n    };\\n    /**\\n     * Whether the tooltip is being displayed\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype.isVisible = function () {\\n        return this._visibility === \\'visible\\';\\n    };\\n    /**\\n     * Sets the tooltip transform origin according to the tooltip position\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype._setTransformOrigin = function (value) {\\n        var /** @type {?} */ isLtr = !this._dir || this._dir.value == \\'ltr\\';\\n        switch (value) {\\n            case \\'before\\':\\n                this._transformOrigin = isLtr ? \\'right\\' : \\'left\\';\\n                break;\\n            case \\'after\\':\\n                this._transformOrigin = isLtr ? \\'left\\' : \\'right\\';\\n                break;\\n            case \\'left\\':\\n                this._transformOrigin = \\'right\\';\\n                break;\\n            case \\'right\\':\\n                this._transformOrigin = \\'left\\';\\n                break;\\n            case \\'above\\':\\n                this._transformOrigin = \\'bottom\\';\\n                break;\\n            case \\'below\\':\\n                this._transformOrigin = \\'top\\';\\n                break;\\n            default: throwMdTooltipInvalidPositionError(value);\\n        }\\n    };\\n    /**\\n     * @param {?} e\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype._afterVisibilityAnimation = function (e) {\\n        if (e.toState === \\'hidden\\' && !this.isVisible()) {\\n            this._onHide.next();\\n        }\\n    };\\n    /**\\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\\n     * material design spec.\\n     * https://material.google.com/components/tooltips.html#tooltips-interaction\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype._handleBodyInteraction = function () {\\n        if (this._closeOnInteraction) {\\n            this.hide(0);\\n        }\\n    };\\n    /**\\n     * Marks that the tooltip needs to be checked in the next change detection run.\\n     * Mainly used for rendering the initial text before positioning a tooltip, which\\n     * can be problematic in components with OnPush change detection.\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype._markForCheck = function () {\\n        this._changeDetectorRef.markForCheck();\\n    };\\n    return TooltipComponent;\\n}());\\nTooltipComponent.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-tooltip-component, mat-tooltip-component\\',\\n                template: \"<div class=\\\\\"mat-tooltip\\\\\" [style.transform-origin]=\\\\\"_transformOrigin\\\\\" [@state]=\\\\\"_visibility\\\\\" (@state.done)=\\\\\"_afterVisibilityAnimation($event)\\\\\"> {{message}} </div>\",\\n                styles: [\":host{pointer-events:none}.mat-tooltip{color:#fff;padding:6px 8px;border-radius:2px;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;font-size:10px;margin:14px;max-width:250px}@media screen and (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}} /*# sourceMappingURL=tooltip.css.map */ \"],\\n                animations: [\\n                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"trigger\"])(\\'state\\', [\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'void\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'scale(0)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'initial\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'scale(0)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'visible\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'scale(1)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'hidden\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'scale(0)\\' })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'* => visible\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\\'150ms cubic-bezier(0.0, 0.0, 0.2, 1)\\')),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'* => hidden\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\\'150ms cubic-bezier(0.4, 0.0, 1, 1)\\')),\\n                    ])\\n                ],\\n                host: {\\n                    \\'(body:click)\\': \\'this._handleBodyInteraction()\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nTooltipComponent.ctorParameters = function () { return [\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n]; };\\nvar MdTooltipModule = /*@__PURE__*/(function () {\\n    function MdTooltipModule() {\\n    }\\n    return MdTooltipModule;\\n}());\\nMdTooltipModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [OverlayModule, MdCommonModule, PlatformModule],\\n                exports: [MdTooltip, TooltipComponent, MdCommonModule],\\n                declarations: [MdTooltip, TooltipComponent],\\n                entryComponents: [TooltipComponent],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTooltipModule.ctorParameters = function () { return []; };\\n/**\\n * Throws an exception for the case when menu trigger doesn\\'t have a valid md-menu instance\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwMdMenuMissingError() {\\n    throw new Error(\"md-menu-trigger: must pass in an md-menu instance.\\\\n\\\\n    Example:\\\\n      <md-menu #menu=\\\\\"mdMenu\\\\\"></md-menu>\\\\n      <button [mdMenuTriggerFor]=\\\\\"menu\\\\\"></button>\");\\n}\\n/**\\n * Throws an exception for the case when menu\\'s x-position value isn\\'t valid.\\n * In other words, it doesn\\'t match \\'before\\' or \\'after\\'.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwMdMenuInvalidPositionX() {\\n    throw new Error(\"x-position value must be either \\'before\\' or after\\'.\\\\n      Example: <md-menu x-position=\\\\\"before\\\\\" #menu=\\\\\"mdMenu\\\\\"></md-menu>\");\\n}\\n/**\\n * Throws an exception for the case when menu\\'s y-position value isn\\'t valid.\\n * In other words, it doesn\\'t match \\'above\\' or \\'below\\'.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwMdMenuInvalidPositionY() {\\n    throw new Error(\"y-position value must be either \\'above\\' or below\\'.\\\\n      Example: <md-menu y-position=\\\\\"above\\\\\" #menu=\\\\\"mdMenu\\\\\"></md-menu>\");\\n}\\n/**\\n * This directive is intended to be used inside an md-menu tag.\\n * It exists mostly to set the role attribute.\\n */\\nvar MdMenuItem = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     */\\n    function MdMenuItem(_elementRef) {\\n        this._elementRef = _elementRef;\\n        /**\\n         * Whether the menu item is disabled\\n         */\\n        this._disabled = false;\\n    }\\n    /**\\n     * Focuses the menu item.\\n     * @return {?}\\n     */\\n    MdMenuItem.prototype.focus = function () {\\n        this._getHostElement().focus();\\n    };\\n    Object.defineProperty(MdMenuItem.prototype, \"disabled\", {\\n        /**\\n         * Whether the menu item is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disabled; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = coerceBooleanProperty(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Used to set the `tabindex`.\\n     * @return {?}\\n     */\\n    MdMenuItem.prototype._getTabIndex = function () {\\n        return this._disabled ? \\'-1\\' : \\'0\\';\\n    };\\n    /**\\n     * Used to set the HTML `disabled` attribute. Necessary for links to be disabled properly.\\n     * @return {?}\\n     */\\n    MdMenuItem.prototype._getDisabledAttr = function () {\\n        return this._disabled ? true : null;\\n    };\\n    /**\\n     * Returns the host DOM element.\\n     * @return {?}\\n     */\\n    MdMenuItem.prototype._getHostElement = function () {\\n        return this._elementRef.nativeElement;\\n    };\\n    /**\\n     * Prevents the default element actions if it is disabled.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdMenuItem.prototype._checkDisabled = function (event) {\\n        if (this.disabled) {\\n            event.preventDefault();\\n            event.stopPropagation();\\n        }\\n    };\\n    return MdMenuItem;\\n}());\\nMdMenuItem.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'[md-menu-item], [mat-menu-item]\\',\\n                host: {\\n                    \\'role\\': \\'menuitem\\',\\n                    \\'[class.mat-menu-item]\\': \\'true\\',\\n                    \\'[attr.tabindex]\\': \\'_getTabIndex()\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled.toString()\\',\\n                    \\'[attr.disabled]\\': \\'_getDisabledAttr()\\',\\n                    \\'(click)\\': \\'_checkDisabled($event)\\',\\n                },\\n                template: \"<ng-content></ng-content> <div class=\\\\\"mat-menu-ripple\\\\\" *ngIf=\\\\\"!disabled\\\\\" md-ripple [mdRippleTrigger]=\\\\\"_getHostElement()\\\\\"> </div> \",\\n                exportAs: \\'mdMenuItem\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMenuItem.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdMenuItem.propDecorators = {\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Below are all the animations for the md-menu component.\\n * Animation duration and timing values are based on AngularJS Material.\\n */\\n/**\\n * This animation controls the menu panel\\'s entry and exit from the page.\\n *\\n * When the menu panel is added to the DOM, it scales in and fades in its border.\\n *\\n * When the menu panel is removed from the DOM, it simply fades out after a brief\\n * delay to display the ripple.\\n */\\n// TODO(kara): switch to :enter and :leave once Mobile Safari is sorted out.\\nvar transformMenu = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"trigger\"])(\\'transformMenu\\', [\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'showing\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({\\n        opacity: 1,\\n        transform: \"scale(1)\"\\n    })),\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'void => *\\', [\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({\\n            opacity: 0,\\n            transform: \"scale(0)\"\\n        }),\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\"200ms cubic-bezier(0.25, 0.8, 0.25, 1)\")\\n    ]),\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'* => void\\', [\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\\'50ms 100ms linear\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ opacity: 0 }))\\n    ])\\n]);\\n/**\\n * This animation fades in the background color and content of the menu panel\\n * after its containing element is scaled in.\\n */\\nvar fadeInItems = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"trigger\"])(\\'fadeInItems\\', [\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'showing\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ opacity: 1 })),\\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'void => *\\', [\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ opacity: 0 }),\\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\"200ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)\")\\n    ])\\n]);\\n// TODO(kara): prevent-close functionality\\nvar MdMenu = /*@__PURE__*/(function () {\\n    function MdMenu() {\\n        this._xPosition = \\'after\\';\\n        this._yPosition = \\'below\\';\\n        /**\\n         * Config object to be passed into the menu\\'s ngClass\\n         */\\n        this._classList = {};\\n        /**\\n         * Whether the menu should overlap its trigger.\\n         */\\n        this.overlapTrigger = true;\\n        /**\\n         * Event emitted when the menu is closed.\\n         */\\n        this.close = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(MdMenu.prototype, \"xPosition\", {\\n        /**\\n         * Position of the menu in the X axis.\\n         * @return {?}\\n         */\\n        get: function () { return this._xPosition; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value !== \\'before\\' && value !== \\'after\\') {\\n                throwMdMenuInvalidPositionX();\\n            }\\n            this._xPosition = value;\\n            this.setPositionClasses();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdMenu.prototype, \"yPosition\", {\\n        /**\\n         * Position of the menu in the Y axis.\\n         * @return {?}\\n         */\\n        get: function () { return this._yPosition; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value !== \\'above\\' && value !== \\'below\\') {\\n                throwMdMenuInvalidPositionY();\\n            }\\n            this._yPosition = value;\\n            this.setPositionClasses();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdMenu.prototype, \"classList\", {\\n        /**\\n         * This method takes classes set on the host md-menu element and applies them on the\\n         * menu template that displays in the overlay container.  Otherwise, it\\'s difficult\\n         * to style the containing menu from outside the component.\\n         * @param {?} classes list of class names\\n         * @return {?}\\n         */\\n        set: function (classes) {\\n            this._classList = classes.split(\\' \\').reduce(function (obj, className) {\\n                obj[className] = true;\\n                return obj;\\n            }, {});\\n            this.setPositionClasses();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdMenu.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._keyManager = new FocusKeyManager(this.items).withWrap();\\n        this._tabSubscription = this._keyManager.tabOut.subscribe(function () { return _this._emitCloseEvent(); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdMenu.prototype.ngOnDestroy = function () {\\n        if (this._tabSubscription) {\\n            this._tabSubscription.unsubscribe();\\n        }\\n    };\\n    /**\\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdMenu.prototype._handleKeydown = function (event) {\\n        switch (event.keyCode) {\\n            case ESCAPE:\\n                this._emitCloseEvent();\\n                return;\\n            default:\\n                this._keyManager.onKeydown(event);\\n        }\\n    };\\n    /**\\n     * Focus the first item in the menu. This method is used by the menu trigger\\n     * to focus the first item when the menu is opened by the ENTER key.\\n     * @return {?}\\n     */\\n    MdMenu.prototype.focusFirstItem = function () {\\n        this._keyManager.setFirstItemActive();\\n    };\\n    /**\\n     * This emits a close event to which the trigger is subscribed. When emitted, the\\n     * trigger will close the menu.\\n     * @return {?}\\n     */\\n    MdMenu.prototype._emitCloseEvent = function () {\\n        this.close.emit();\\n    };\\n    /**\\n     * It\\'s necessary to set position-based classes to ensure the menu panel animation\\n     * folds out from the correct direction.\\n     * @param {?=} posX\\n     * @param {?=} posY\\n     * @return {?}\\n     */\\n    MdMenu.prototype.setPositionClasses = function (posX, posY) {\\n        if (posX === void 0) { posX = this.xPosition; }\\n        if (posY === void 0) { posY = this.yPosition; }\\n        this._classList[\\'mat-menu-before\\'] = posX === \\'before\\';\\n        this._classList[\\'mat-menu-after\\'] = posX === \\'after\\';\\n        this._classList[\\'mat-menu-above\\'] = posY === \\'above\\';\\n        this._classList[\\'mat-menu-below\\'] = posY === \\'below\\';\\n    };\\n    return MdMenu;\\n}());\\nMdMenu.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-menu, mat-menu\\',\\n                host: { \\'role\\': \\'menu\\' },\\n                template: \"<ng-template> <div class=\\\\\"mat-menu-panel\\\\\" [ngClass]=\\\\\"_classList\\\\\" (keydown)=\\\\\"_handleKeydown($event)\\\\\" (click)=\\\\\"_emitCloseEvent()\\\\\" [@transformMenu]=\\\\\"\\'showing\\'\\\\\"> <div class=\\\\\"mat-menu-content\\\\\" [@fadeInItems]=\\\\\"\\'showing\\'\\\\\"> <ng-content></ng-content> </div> </div> </ng-template> \",\\n                styles: [\".mat-menu-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px)}.mat-menu-panel.mat-menu-after.mat-menu-below{transform-origin:left top}.mat-menu-panel.mat-menu-after.mat-menu-above{transform-origin:left bottom}.mat-menu-panel.mat-menu-before.mat-menu-below{transform-origin:right top}.mat-menu-panel.mat-menu-before.mat-menu-above{transform-origin:right bottom}[dir=rtl] .mat-menu-panel.mat-menu-after.mat-menu-below{transform-origin:right top}[dir=rtl] .mat-menu-panel.mat-menu-after.mat-menu-above{transform-origin:right bottom}[dir=rtl] .mat-menu-panel.mat-menu-before.mat-menu-below{transform-origin:left top}[dir=rtl] .mat-menu-panel.mat-menu-before.mat-menu-above{transform-origin:left bottom}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content{padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;font-size:16px;font-family:Roboto,\\\\\"Helvetica Neue\\\\\",sans-serif;text-align:left;text-decoration:none;position:relative}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}button.mat-menu-item{width:100%}.mat-menu-ripple{position:absolute;top:0;left:0;bottom:0;right:0} /*# sourceMappingURL=menu.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                animations: [\\n                    transformMenu,\\n                    fadeInItems\\n                ],\\n                exportAs: \\'mdMenu\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMenu.ctorParameters = function () { return []; };\\nMdMenu.propDecorators = {\\n    \\'xPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'yPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'templateRef\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"],] },],\\n    \\'items\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdMenuItem,] },],\\n    \\'overlapTrigger\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'classList\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'class\\',] },],\\n    \\'close\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * This directive is intended to be used in conjunction with an md-menu tag.  It is\\n * responsible for toggling the display of the provided menu instance.\\n */\\nvar MdMenuTrigger = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlay\\n     * @param {?} _element\\n     * @param {?} _viewContainerRef\\n     * @param {?} _dir\\n     * @param {?} _scrollDispatcher\\n     */\\n    function MdMenuTrigger(_overlay, _element, _viewContainerRef, _dir, _scrollDispatcher) {\\n        this._overlay = _overlay;\\n        this._element = _element;\\n        this._viewContainerRef = _viewContainerRef;\\n        this._dir = _dir;\\n        this._scrollDispatcher = _scrollDispatcher;\\n        this._menuOpen = false;\\n        this._openedByMouse = false;\\n        /**\\n         * Event emitted when the associated menu is opened.\\n         */\\n        this.onMenuOpen = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the associated menu is closed.\\n         */\\n        this.onMenuClose = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(MdMenuTrigger.prototype, \"_deprecatedMdMenuTriggerFor\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this.menu; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.menu = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdMenuTrigger.prototype, \"_deprecatedMatMenuTriggerFor\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this.menu; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.menu = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdMenuTrigger.prototype, \"_matMenuTriggerFor\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.menu; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.menu = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.ngAfterViewInit = function () {\\n        var _this = this;\\n        this._checkMenu();\\n        this.menu.close.subscribe(function () { return _this.closeMenu(); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.ngOnDestroy = function () { this.destroyMenu(); };\\n    Object.defineProperty(MdMenuTrigger.prototype, \"menuOpen\", {\\n        /**\\n         * Whether the menu is open.\\n         * @return {?}\\n         */\\n        get: function () { return this._menuOpen; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Toggles the menu between the open and closed states.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.toggleMenu = function () {\\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\\n    };\\n    /**\\n     * Opens the menu.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.openMenu = function () {\\n        if (!this._menuOpen) {\\n            this._createOverlay();\\n            this._overlayRef.attach(this._portal);\\n            this._subscribeToBackdrop();\\n            this._initMenu();\\n        }\\n    };\\n    /**\\n     * Closes the menu.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.closeMenu = function () {\\n        if (this._overlayRef) {\\n            this._overlayRef.detach();\\n            this._backdropSubscription.unsubscribe();\\n            this._resetMenu();\\n        }\\n    };\\n    /**\\n     * Removes the menu from the DOM.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.destroyMenu = function () {\\n        if (this._overlayRef) {\\n            this._overlayRef.dispose();\\n            this._overlayRef = null;\\n            this._cleanUpSubscriptions();\\n        }\\n    };\\n    /**\\n     * Focuses the menu trigger.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.focus = function () {\\n        this._element.nativeElement.focus();\\n    };\\n    Object.defineProperty(MdMenuTrigger.prototype, \"dir\", {\\n        /**\\n         * The text direction of the containing app.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._dir && this._dir.value === \\'rtl\\' ? \\'rtl\\' : \\'ltr\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * This method ensures that the menu closes when the overlay backdrop is clicked.\\n     * We do not use first() here because doing so would not catch clicks from within\\n     * the menu, and it would fail to unsubscribe properly. Instead, we unsubscribe\\n     * explicitly when the menu is closed or destroyed.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._subscribeToBackdrop = function () {\\n        var _this = this;\\n        this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\\n            _this.menu._emitCloseEvent();\\n        });\\n    };\\n    /**\\n     * This method sets the menu state to open and focuses the first item if\\n     * the menu was opened via the keyboard.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._initMenu = function () {\\n        this._setIsMenuOpen(true);\\n        // Should only set focus if opened via the keyboard, so keyboard users can\\n        // can easily navigate menu items. According to spec, mouse users should not\\n        // see the focus style.\\n        if (!this._openedByMouse) {\\n            this.menu.focusFirstItem();\\n        }\\n    };\\n    /**\\n     * This method resets the menu when it\\'s closed, most importantly restoring\\n     * focus to the menu trigger if the menu was opened via the keyboard.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._resetMenu = function () {\\n        this._setIsMenuOpen(false);\\n        // Focus only needs to be reset to the host element if the menu was opened\\n        // by the keyboard and manually shifted to the first menu item.\\n        if (!this._openedByMouse) {\\n            this.focus();\\n        }\\n        this._openedByMouse = false;\\n    };\\n    /**\\n     * @param {?} isOpen\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._setIsMenuOpen = function (isOpen) {\\n        this._menuOpen = isOpen;\\n        this._menuOpen ? this.onMenuOpen.emit() : this.onMenuClose.emit();\\n    };\\n    /**\\n     *  This method checks that a valid instance of MdMenu has been passed into\\n     *  mdMenuTriggerFor. If not, an exception is thrown.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._checkMenu = function () {\\n        if (!this.menu) {\\n            throwMdMenuMissingError();\\n        }\\n    };\\n    /**\\n     *  This method creates the overlay from the provided menu\\'s template and saves its\\n     *  OverlayRef so that it can be attached to the DOM when openMenu is called.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._createOverlay = function () {\\n        if (!this._overlayRef) {\\n            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\\n            var /** @type {?} */ config = this._getOverlayConfig();\\n            this._subscribeToPositions(/** @type {?} */ (config.positionStrategy));\\n            this._overlayRef = this._overlay.create(config);\\n        }\\n    };\\n    /**\\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\\n     * @return {?} OverlayState\\n     */\\n    MdMenuTrigger.prototype._getOverlayConfig = function () {\\n        var /** @type {?} */ overlayState = new OverlayState();\\n        overlayState.positionStrategy = this._getPosition()\\n            .withDirection(this.dir);\\n        overlayState.hasBackdrop = true;\\n        overlayState.backdropClass = \\'cdk-overlay-transparent-backdrop\\';\\n        overlayState.direction = this.dir;\\n        overlayState.scrollStrategy = new RepositionScrollStrategy(this._scrollDispatcher);\\n        return overlayState;\\n    };\\n    /**\\n     * Listens to changes in the position of the overlay and sets the correct classes\\n     * on the menu based on the new position. This ensures the animation origin is always\\n     * correct, even if a fallback position is used for the overlay.\\n     * @param {?} position\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._subscribeToPositions = function (position) {\\n        var _this = this;\\n        this._positionSubscription = position.onPositionChange.subscribe(function (change) {\\n            var /** @type {?} */ posX = change.connectionPair.originX === \\'start\\' ? \\'after\\' : \\'before\\';\\n            var /** @type {?} */ posY = change.connectionPair.originY === \\'top\\' ? \\'below\\' : \\'above\\';\\n            if (!_this.menu.overlapTrigger) {\\n                posY = posY === \\'below\\' ? \\'above\\' : \\'below\\';\\n            }\\n            _this.menu.setPositionClasses(posX, posY);\\n        });\\n    };\\n    /**\\n     * This method builds the position strategy for the overlay, so the menu is properly connected\\n     * to the trigger.\\n     * @return {?} ConnectedPositionStrategy\\n     */\\n    MdMenuTrigger.prototype._getPosition = function () {\\n        var _a = this.menu.xPosition === \\'before\\' ? [\\'end\\', \\'start\\'] : [\\'start\\', \\'end\\'], posX = _a[0], fallbackX = _a[1];\\n        var _b = this.menu.yPosition === \\'above\\' ? [\\'bottom\\', \\'top\\'] : [\\'top\\', \\'bottom\\'], overlayY = _b[0], fallbackOverlayY = _b[1];\\n        var /** @type {?} */ originY = overlayY;\\n        var /** @type {?} */ fallbackOriginY = fallbackOverlayY;\\n        if (!this.menu.overlapTrigger) {\\n            originY = overlayY === \\'top\\' ? \\'bottom\\' : \\'top\\';\\n            fallbackOriginY = fallbackOverlayY === \\'top\\' ? \\'bottom\\' : \\'top\\';\\n        }\\n        return this._overlay.position()\\n            .connectedTo(this._element, { originX: posX, originY: originY }, { overlayX: posX, overlayY: overlayY })\\n            .withFallbackPosition({ originX: fallbackX, originY: originY }, { overlayX: fallbackX, overlayY: overlayY })\\n            .withFallbackPosition({ originX: posX, originY: fallbackOriginY }, { overlayX: posX, overlayY: fallbackOverlayY })\\n            .withFallbackPosition({ originX: fallbackX, originY: fallbackOriginY }, { overlayX: fallbackX, overlayY: fallbackOverlayY });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._cleanUpSubscriptions = function () {\\n        if (this._backdropSubscription) {\\n            this._backdropSubscription.unsubscribe();\\n        }\\n        if (this._positionSubscription) {\\n            this._positionSubscription.unsubscribe();\\n        }\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._handleMousedown = function (event) {\\n        if (!isFakeMousedownFromScreenReader(event)) {\\n            this._openedByMouse = true;\\n        }\\n    };\\n    return MdMenuTrigger;\\n}());\\nMdMenuTrigger.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \"[md-menu-trigger-for], [mat-menu-trigger-for],\\\\n             [mdMenuTriggerFor], [matMenuTriggerFor]\",\\n                host: {\\n                    \\'aria-haspopup\\': \\'true\\',\\n                    \\'(mousedown)\\': \\'_handleMousedown($event)\\',\\n                    \\'(click)\\': \\'toggleMenu()\\',\\n                },\\n                exportAs: \\'mdMenuTrigger\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMenuTrigger.ctorParameters = function () { return [\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: ScrollDispatcher, },\\n]; };\\nMdMenuTrigger.propDecorators = {\\n    \\'_deprecatedMdMenuTriggerFor\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'md-menu-trigger-for\\',] },],\\n    \\'_deprecatedMatMenuTriggerFor\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mat-menu-trigger-for\\',] },],\\n    \\'_matMenuTriggerFor\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matMenuTriggerFor\\',] },],\\n    \\'menu\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdMenuTriggerFor\\',] },],\\n    \\'onMenuOpen\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'onMenuClose\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdMenuModule = /*@__PURE__*/(function () {\\n    function MdMenuModule() {\\n    }\\n    return MdMenuModule;\\n}());\\nMdMenuModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    OverlayModule,\\n                    __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"],\\n                    MdRippleModule,\\n                    MdCommonModule,\\n                ],\\n                exports: [MdMenu, MdMenuItem, MdMenuTrigger, MdCommonModule],\\n                declarations: [MdMenu, MdMenuItem, MdMenuTrigger],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMenuModule.ctorParameters = function () { return []; };\\n/**\\n * Reference to a dialog opened via the MdDialog service.\\n */\\nvar MdDialogRef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlayRef\\n     * @param {?} _containerInstance\\n     */\\n    function MdDialogRef(_overlayRef, _containerInstance) {\\n        var _this = this;\\n        this._overlayRef = _overlayRef;\\n        this._containerInstance = _containerInstance;\\n        /**\\n         * Subject for notifying the user that the dialog has finished closing.\\n         */\\n        this._afterClosed = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        _containerInstance._onAnimationStateChange\\n            .filter(function (event) { return event.toState === \\'exit\\'; })\\n            .subscribe(function () {\\n            _this._overlayRef.dispose();\\n            _this.componentInstance = null;\\n        }, null, function () {\\n            _this._afterClosed.next(_this._result);\\n            _this._afterClosed.complete();\\n        });\\n    }\\n    /**\\n     * Close the dialog.\\n     * @param {?=} dialogResult Optional result to return to the dialog opener.\\n     * @return {?}\\n     */\\n    MdDialogRef.prototype.close = function (dialogResult) {\\n        this._result = dialogResult;\\n        this._containerInstance._state = \\'exit\\';\\n        this._overlayRef.detachBackdrop(); // Transition the backdrop in parallel with the dialog.\\n    };\\n    /**\\n     * Gets an observable that is notified when the dialog is finished closing.\\n     * @return {?}\\n     */\\n    MdDialogRef.prototype.afterClosed = function () {\\n        return this._afterClosed.asObservable();\\n    };\\n    /**\\n     * Updates the dialog\\'s position.\\n     * @param {?=} position New dialog position.\\n     * @return {?}\\n     */\\n    MdDialogRef.prototype.updatePosition = function (position) {\\n        var /** @type {?} */ strategy = this._getPositionStrategy();\\n        if (position && (position.left || position.right)) {\\n            position.left ? strategy.left(position.left) : strategy.right(position.right);\\n        }\\n        else {\\n            strategy.centerHorizontally();\\n        }\\n        if (position && (position.top || position.bottom)) {\\n            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);\\n        }\\n        else {\\n            strategy.centerVertically();\\n        }\\n        this._overlayRef.updatePosition();\\n        return this;\\n    };\\n    /**\\n     * Updates the dialog\\'s width and height.\\n     * @param {?=} width New width of the dialog.\\n     * @param {?=} height New height of the dialog.\\n     * @return {?}\\n     */\\n    MdDialogRef.prototype.updateSize = function (width, height) {\\n        if (width === void 0) { width = \\'auto\\'; }\\n        if (height === void 0) { height = \\'auto\\'; }\\n        this._getPositionStrategy().width(width).height(height);\\n        this._overlayRef.updatePosition();\\n        return this;\\n    };\\n    /**\\n     * Fetches the position strategy object from the overlay ref.\\n     * @return {?}\\n     */\\n    MdDialogRef.prototype._getPositionStrategy = function () {\\n        return (this._overlayRef.getState().positionStrategy);\\n    };\\n    return MdDialogRef;\\n}());\\nvar MD_DIALOG_DATA = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'MdDialogData\\');\\n/**\\n * Custom injector type specifically for instantiating components with a dialog.\\n */\\nvar DialogInjector = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _parentInjector\\n     * @param {?} _dialogRef\\n     * @param {?} _data\\n     */\\n    function DialogInjector(_parentInjector, _dialogRef, _data) {\\n        this._parentInjector = _parentInjector;\\n        this._dialogRef = _dialogRef;\\n        this._data = _data;\\n    }\\n    /**\\n     * @param {?} token\\n     * @param {?=} notFoundValue\\n     * @return {?}\\n     */\\n    DialogInjector.prototype.get = function (token, notFoundValue) {\\n        if (token === MdDialogRef) {\\n            return this._dialogRef;\\n        }\\n        if (token === MD_DIALOG_DATA) {\\n            return this._data;\\n        }\\n        return this._parentInjector.get(token, notFoundValue);\\n    };\\n    return DialogInjector;\\n}());\\n/**\\n * Configuration for opening a modal dialog with the MdDialog service.\\n */\\nvar MdDialogConfig = /*@__PURE__*/(function () {\\n    function MdDialogConfig() {\\n        /**\\n         * The ARIA role of the dialog element.\\n         */\\n        this.role = \\'dialog\\';\\n        /**\\n         * Whether the dialog has a backdrop.\\n         */\\n        this.hasBackdrop = true;\\n        /**\\n         * Custom class for the backdrop,\\n         */\\n        this.backdropClass = \\'\\';\\n        /**\\n         * Whether the user can use escape or clicking outside to close a modal.\\n         */\\n        this.disableClose = false;\\n        /**\\n         * Width of the dialog.\\n         */\\n        this.width = \\'\\';\\n        /**\\n         * Height of the dialog.\\n         */\\n        this.height = \\'\\';\\n        /**\\n         * Data being injected into the child component.\\n         */\\n        this.data = null;\\n        // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.\\n    }\\n    return MdDialogConfig;\\n}());\\n/**\\n * Throws an exception for the case when a ComponentPortal is\\n * attached to a DomPortalHost without an origin.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwMdDialogContentAlreadyAttachedError() {\\n    throw new Error(\\'Attempting to attach dialog content after content is already attached\\');\\n}\\n/**\\n * Internal component that wraps user-provided dialog content.\\n * Animation is based on https://material.io/guidelines/motion/choreography.html.\\n * \\\\@docs-private\\n */\\nvar MdDialogContainer = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdDialogContainer, _super);\\n    /**\\n     * @param {?} _ngZone\\n     * @param {?} _elementRef\\n     * @param {?} _focusTrapFactory\\n     * @param {?} _document\\n     */\\n    function MdDialogContainer(_ngZone, _elementRef, _focusTrapFactory, _document) {\\n        var _this = _super.call(this) || this;\\n        _this._ngZone = _ngZone;\\n        _this._elementRef = _elementRef;\\n        _this._focusTrapFactory = _focusTrapFactory;\\n        /**\\n         * Element that was focused before the dialog was opened. Save this to restore upon close.\\n         */\\n        _this._elementFocusedBeforeDialogWasOpened = null;\\n        /**\\n         * State of the dialog animation.\\n         */\\n        _this._state = \\'enter\\';\\n        /**\\n         * Emits the current animation state whenever it changes.\\n         */\\n        _this._onAnimationStateChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        _this._document = _document;\\n        return _this;\\n    }\\n    /**\\n     * Attach a ComponentPortal as content to this dialog container.\\n     * @template T\\n     * @param {?} portal Portal to be attached as the dialog content.\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype.attachComponentPortal = function (portal) {\\n        if (this._portalHost.hasAttached()) {\\n            throwMdDialogContentAlreadyAttachedError();\\n        }\\n        this._savePreviouslyFocusedElement();\\n        return this._portalHost.attachComponentPortal(portal);\\n    };\\n    /**\\n     * Attach a TemplatePortal as content to this dialog container.\\n     * @param {?} portal Portal to be attached as the dialog content.\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype.attachTemplatePortal = function (portal) {\\n        if (this._portalHost.hasAttached()) {\\n            throwMdDialogContentAlreadyAttachedError();\\n        }\\n        this._savePreviouslyFocusedElement();\\n        return this._portalHost.attachTemplatePortal(portal);\\n    };\\n    /**\\n     * Moves the focus inside the focus trap.\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype._trapFocus = function () {\\n        if (!this._focusTrap) {\\n            this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\\n        }\\n        // If were to attempt to focus immediately, then the content of the dialog would not yet be\\n        // ready in instances where change detection has to run first. To deal with this, we simply\\n        // wait for the microtask queue to be empty.\\n        this._focusTrap.focusInitialElementWhenReady();\\n    };\\n    /**\\n     * Restores focus to the element that was focused before the dialog opened.\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype._restoreFocus = function () {\\n        var /** @type {?} */ toFocus = this._elementFocusedBeforeDialogWasOpened;\\n        // We need the extra check, because IE can set the `activeElement` to null in some cases.\\n        if (toFocus && \\'focus\\' in toFocus) {\\n            toFocus.focus();\\n        }\\n        if (this._focusTrap) {\\n            this._focusTrap.destroy();\\n        }\\n    };\\n    /**\\n     * Saves a reference to the element that was focused before the dialog was opened.\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype._savePreviouslyFocusedElement = function () {\\n        if (this._document) {\\n            this._elementFocusedBeforeDialogWasOpened = (this._document.activeElement);\\n        }\\n    };\\n    /**\\n     * Callback, invoked whenever an animation on the host completes.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype._onAnimationDone = function (event) {\\n        this._onAnimationStateChange.emit(event);\\n        if (event.toState === \\'enter\\') {\\n            this._trapFocus();\\n        }\\n        else if (event.toState === \\'exit\\') {\\n            this._restoreFocus();\\n            this._onAnimationStateChange.complete();\\n        }\\n    };\\n    return MdDialogContainer;\\n}(BasePortalHost));\\nMdDialogContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-dialog-container, mat-dialog-container\\',\\n                template: \"<ng-template cdkPortalHost></ng-template> \",\\n                styles: [\".mat-dialog-container{box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);display:block;padding:24px;border-radius:2px;box-sizing:border-box;overflow:auto;max-width:80vw;width:100%;height:100%}@media screen and (-ms-high-contrast:active){.mat-dialog-container{outline:solid 1px}}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{font-size:20px;font-weight:700;margin:0 0 20px;display:block}.mat-dialog-actions{padding:12px 0;display:flex}.mat-dialog-actions:last-child{margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center} /*# sourceMappingURL=dialog.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                animations: [\\n                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"trigger\"])(\\'slideDialog\\', [\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'void\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(0, 25%, 0) scale(0.9)\\', opacity: 0 })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'enter\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(0, 0, 0) scale(1)\\', opacity: 1 })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"state\"])(\\'exit\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"style\"])({ transform: \\'translate3d(0, 25%, 0)\\', opacity: 0 })),\\n                        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"transition\"])(\\'* => *\\', __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__angular_animations__[\"animate\"])(\\'400ms cubic-bezier(0.25, 0.8, 0.25, 1)\\')),\\n                    ])\\n                ],\\n                host: {\\n                    \\'[class.mat-dialog-container]\\': \\'true\\',\\n                    \\'[attr.role]\\': \\'dialogConfig?.role\\',\\n                    \\'[@slideDialog]\\': \\'_state\\',\\n                    \\'(@slideDialog.done)\\': \\'_onAnimationDone($event)\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogContainer.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusTrapFactory, },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__[\"DOCUMENT\"],] },] },\\n]; };\\nMdDialogContainer.propDecorators = {\\n    \\'_portalHost\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [PortalHostDirective,] },],\\n};\\n/**\\n * Service to open Material Design modal dialogs.\\n */\\nvar MdDialog = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlay\\n     * @param {?} _injector\\n     * @param {?} _viewportRuler\\n     * @param {?} _location\\n     * @param {?} _parentDialog\\n     */\\n    function MdDialog(_overlay, _injector, _viewportRuler, _location, _parentDialog) {\\n        var _this = this;\\n        this._overlay = _overlay;\\n        this._injector = _injector;\\n        this._viewportRuler = _viewportRuler;\\n        this._location = _location;\\n        this._parentDialog = _parentDialog;\\n        this._openDialogsAtThisLevel = [];\\n        this._afterAllClosedAtThisLevel = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        this._afterOpenAtThisLevel = new __WEBPACK_IMPORTED_MODULE_3_rxjs_Subject__[\"Subject\"]();\\n        this._boundKeydown = this._handleKeydown.bind(this);\\n        /**\\n         * Gets an observable that is notified when a dialog has been opened.\\n         */\\n        this.afterOpen = this._afterOpen.asObservable();\\n        /**\\n         * Gets an observable that is notified when all open dialog have finished closing.\\n         */\\n        this.afterAllClosed = this._afterAllClosed.asObservable();\\n        // Close all of the dialogs when the user goes forwards/backwards in history or when the\\n        // location hash changes. Note that this usually doesn\\'t include clicking on links (unless\\n        // the user is using the `HashLocationStrategy`).\\n        if (!_parentDialog && _location) {\\n            _location.subscribe(function () { return _this.closeAll(); });\\n        }\\n    }\\n    Object.defineProperty(MdDialog.prototype, \"_openDialogs\", {\\n        /**\\n         * Keeps track of the currently-open dialogs.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._parentDialog ? this._parentDialog._openDialogs : this._openDialogsAtThisLevel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDialog.prototype, \"_afterOpen\", {\\n        /**\\n         * Subject for notifying the user that a dialog has opened.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._parentDialog ? this._parentDialog._afterOpen : this._afterOpenAtThisLevel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDialog.prototype, \"_afterAllClosed\", {\\n        /**\\n         * Subject for notifying the user that all open dialogs have finished closing.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._parentDialog ?\\n                this._parentDialog._afterAllClosed : this._afterAllClosedAtThisLevel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Opens a modal dialog containing the given component.\\n     * @template T\\n     * @param {?} componentOrTemplateRef Type of the component to load into the dialog,\\n     *     or a TemplateRef to instantiate as the dialog content.\\n     * @param {?=} config Extra configuration options.\\n     * @return {?} Reference to the newly-opened dialog.\\n     */\\n    MdDialog.prototype.open = function (componentOrTemplateRef, config) {\\n        var _this = this;\\n        config = _applyConfigDefaults$1(config);\\n        var /** @type {?} */ overlayRef = this._createOverlay(config);\\n        var /** @type {?} */ dialogContainer = this._attachDialogContainer(overlayRef, config);\\n        var /** @type {?} */ dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);\\n        if (!this._openDialogs.length) {\\n            document.addEventListener(\\'keydown\\', this._boundKeydown);\\n        }\\n        this._openDialogs.push(dialogRef);\\n        dialogRef.afterClosed().subscribe(function () { return _this._removeOpenDialog(dialogRef); });\\n        this._afterOpen.next(dialogRef);\\n        return dialogRef;\\n    };\\n    /**\\n     * Closes all of the currently-open dialogs.\\n     * @return {?}\\n     */\\n    MdDialog.prototype.closeAll = function () {\\n        var /** @type {?} */ i = this._openDialogs.length;\\n        while (i--) {\\n            // The `_openDialogs` property isn\\'t updated after close until the rxjs subscription\\n            // runs on the next microtask, in addition to modifying the array as we\\'re going\\n            // through it. We loop through all of them and call close without assuming that\\n            // they\\'ll be removed from the list instantaneously.\\n            this._openDialogs[i].close();\\n        }\\n    };\\n    /**\\n     * Creates the overlay into which the dialog will be loaded.\\n     * @param {?} config The dialog configuration.\\n     * @return {?} A promise resolving to the OverlayRef for the created overlay.\\n     */\\n    MdDialog.prototype._createOverlay = function (config) {\\n        var /** @type {?} */ overlayState = this._getOverlayState(config);\\n        return this._overlay.create(overlayState);\\n    };\\n    /**\\n     * Creates an overlay state from a dialog config.\\n     * @param {?} dialogConfig The dialog configuration.\\n     * @return {?} The overlay configuration.\\n     */\\n    MdDialog.prototype._getOverlayState = function (dialogConfig) {\\n        var /** @type {?} */ overlayState = new OverlayState();\\n        overlayState.hasBackdrop = dialogConfig.hasBackdrop;\\n        overlayState.scrollStrategy = new BlockScrollStrategy(this._viewportRuler);\\n        if (dialogConfig.backdropClass) {\\n            overlayState.backdropClass = dialogConfig.backdropClass;\\n        }\\n        overlayState.positionStrategy = this._overlay.position().global();\\n        return overlayState;\\n    };\\n    /**\\n     * Attaches an MdDialogContainer to a dialog\\'s already-created overlay.\\n     * @param {?} overlay Reference to the dialog\\'s underlying overlay.\\n     * @param {?} config The dialog configuration.\\n     * @return {?} A promise resolving to a ComponentRef for the attached container.\\n     */\\n    MdDialog.prototype._attachDialogContainer = function (overlay, config) {\\n        var /** @type {?} */ viewContainer = config ? config.viewContainerRef : null;\\n        var /** @type {?} */ containerPortal = new ComponentPortal(MdDialogContainer, viewContainer);\\n        var /** @type {?} */ containerRef = overlay.attach(containerPortal);\\n        containerRef.instance.dialogConfig = config;\\n        return containerRef.instance;\\n    };\\n    /**\\n     * Attaches the user-provided component to the already-created MdDialogContainer.\\n     * @template T\\n     * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,\\n     *     or a TemplateRef to instantiate as the content.\\n     * @param {?} dialogContainer Reference to the wrapping MdDialogContainer.\\n     * @param {?} overlayRef Reference to the overlay in which the dialog resides.\\n     * @param {?} config The dialog configuration.\\n     * @return {?} A promise resolving to the MdDialogRef that should be returned to the user.\\n     */\\n    MdDialog.prototype._attachDialogContent = function (componentOrTemplateRef, dialogContainer, overlayRef, config) {\\n        // Create a reference to the dialog we\\'re creating in order to give the user a handle\\n        // to modify and close it.\\n        var /** @type {?} */ dialogRef = new MdDialogRef(overlayRef, dialogContainer);\\n        if (!config.disableClose) {\\n            // When the dialog backdrop is clicked, we want to close it.\\n            overlayRef.backdropClick().first().subscribe(function () { return dialogRef.close(); });\\n        }\\n        // We create an injector specifically for the component we\\'re instantiating so that it can\\n        // inject the MdDialogRef. This allows a component loaded inside of a dialog to close itself\\n        // and, optionally, to return a value.\\n        var /** @type {?} */ userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\\n        var /** @type {?} */ dialogInjector = new DialogInjector(userInjector || this._injector, dialogRef, config.data);\\n        if (componentOrTemplateRef instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"]) {\\n            dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null));\\n        }\\n        else {\\n            var /** @type {?} */ contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, null, dialogInjector));\\n            dialogRef.componentInstance = contentRef.instance;\\n        }\\n        dialogRef\\n            .updateSize(config.width, config.height)\\n            .updatePosition(config.position);\\n        return dialogRef;\\n    };\\n    /**\\n     * Removes a dialog from the array of open dialogs.\\n     * @param {?} dialogRef Dialog to be removed.\\n     * @return {?}\\n     */\\n    MdDialog.prototype._removeOpenDialog = function (dialogRef) {\\n        var /** @type {?} */ index = this._openDialogs.indexOf(dialogRef);\\n        if (index > -1) {\\n            this._openDialogs.splice(index, 1);\\n            // no open dialogs are left, call next on afterAllClosed Subject\\n            if (!this._openDialogs.length) {\\n                this._afterAllClosed.next();\\n                document.removeEventListener(\\'keydown\\', this._boundKeydown);\\n            }\\n        }\\n    };\\n    /**\\n     * Handles global key presses while there are open dialogs. Closes the\\n     * top dialog when the user presses escape.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdDialog.prototype._handleKeydown = function (event) {\\n        var /** @type {?} */ topDialog = this._openDialogs[this._openDialogs.length - 1];\\n        var /** @type {?} */ canClose = topDialog ? !topDialog._containerInstance.dialogConfig.disableClose : false;\\n        if (event.keyCode === ESCAPE && canClose) {\\n            topDialog.close();\\n        }\\n    };\\n    return MdDialog;\\n}());\\nMdDialog.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialog.ctorParameters = function () { return [\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injector\"], },\\n    { type: ViewportRuler, },\\n    { type: __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"Location\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: MdDialog, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"] },] },\\n]; };\\n/**\\n * Applies default options to the dialog config.\\n * @param {?} config Config to be modified.\\n * @return {?} The new configuration object.\\n */\\nfunction _applyConfigDefaults$1(config) {\\n    return extendObject(new MdDialogConfig(), config);\\n}\\n/**\\n * Button that will close the current dialog.\\n */\\nvar MdDialogClose = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} dialogRef\\n     */\\n    function MdDialogClose(dialogRef) {\\n        this.dialogRef = dialogRef;\\n        /**\\n         * Screenreader label for the button.\\n         */\\n        this.ariaLabel = \\'Close dialog\\';\\n    }\\n    Object.defineProperty(MdDialogClose.prototype, \"_matDialogClose\", {\\n        /**\\n         * Dialog close input for compatibility mode.\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this.dialogResult = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return MdDialogClose;\\n}());\\nMdDialogClose.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-dialog-close], button[mat-dialog-close]\\',\\n                host: {\\n                    \\'(click)\\': \\'dialogRef.close(dialogResult)\\',\\n                    \\'[attr.aria-label]\\': \\'ariaLabel\\',\\n                    \\'type\\': \\'button\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogClose.ctorParameters = function () { return [\\n    { type: MdDialogRef, },\\n]; };\\nMdDialogClose.propDecorators = {\\n    \\'ariaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'dialogResult\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'md-dialog-close\\',] },],\\n    \\'_matDialogClose\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mat-dialog-close\\',] },],\\n};\\n/**\\n * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.\\n */\\nvar MdDialogTitle = /*@__PURE__*/(function () {\\n    function MdDialogTitle() {\\n    }\\n    return MdDialogTitle;\\n}());\\nMdDialogTitle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-dialog-title], [mat-dialog-title]\\',\\n                host: {\\n                    \\'[class.mat-dialog-title]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogTitle.ctorParameters = function () { return []; };\\n/**\\n * Scrollable content container of a dialog.\\n */\\nvar MdDialogContent = /*@__PURE__*/(function () {\\n    function MdDialogContent() {\\n    }\\n    return MdDialogContent;\\n}());\\nMdDialogContent.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-dialog-content], md-dialog-content, [mat-dialog-content], mat-dialog-content\\',\\n                host: {\\n                    \\'[class.mat-dialog-content]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogContent.ctorParameters = function () { return []; };\\n/**\\n * Container for the bottom action buttons in a dialog.\\n * Stays fixed to the bottom when scrolling.\\n */\\nvar MdDialogActions = /*@__PURE__*/(function () {\\n    function MdDialogActions() {\\n    }\\n    return MdDialogActions;\\n}());\\nMdDialogActions.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-dialog-actions], md-dialog-actions, [mat-dialog-actions], mat-dialog-actions\\',\\n                host: {\\n                    \\'[class.mat-dialog-actions]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogActions.ctorParameters = function () { return []; };\\nvar MdDialogModule = /*@__PURE__*/(function () {\\n    function MdDialogModule() {\\n    }\\n    return MdDialogModule;\\n}());\\nMdDialogModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"],\\n                    OverlayModule,\\n                    PortalModule,\\n                    A11yModule,\\n                    MdCommonModule,\\n                ],\\n                exports: [\\n                    MdDialogContainer,\\n                    MdDialogClose,\\n                    MdDialogTitle,\\n                    MdDialogContent,\\n                    MdDialogActions,\\n                    MdCommonModule,\\n                ],\\n                declarations: [\\n                    MdDialogContainer,\\n                    MdDialogClose,\\n                    MdDialogTitle,\\n                    MdDialogActions,\\n                    MdDialogContent,\\n                ],\\n                providers: [\\n                    MdDialog,\\n                ],\\n                entryComponents: [MdDialogContainer],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogModule.ctorParameters = function () { return []; };\\nvar ActiveDescendantKeyManager = (function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ActiveDescendantKeyManager, _super);\\n    function ActiveDescendantKeyManager() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    /**\\n     * This method sets the active item to the item at the specified index.\\n     * It also adds active styles to the newly active item and removes active\\n     * styles from the previously active item.\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    ActiveDescendantKeyManager.prototype.setActiveItem = function (index) {\\n        var _this = this;\\n        Promise.resolve().then(function () {\\n            if (_this.activeItem) {\\n                _this.activeItem.setInactiveStyles();\\n            }\\n            _super.prototype.setActiveItem.call(_this, index);\\n            if (_this.activeItem) {\\n                _this.activeItem.setActiveStyles();\\n            }\\n        });\\n    };\\n    return ActiveDescendantKeyManager;\\n}(ListKeyManager));\\n/**\\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\\n * the component definition.\\n */\\nvar _uniqueAutocompleteIdCounter = 0;\\nvar MdAutocomplete = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _changeDetectorRef\\n     */\\n    function MdAutocomplete(_changeDetectorRef) {\\n        this._changeDetectorRef = _changeDetectorRef;\\n        /**\\n         * Whether the autocomplete panel displays above or below its trigger.\\n         */\\n        this.positionY = \\'below\\';\\n        /**\\n         * Whether the autocomplete panel should be visible, depending on option length.\\n         */\\n        this.showPanel = false;\\n        /**\\n         * Unique ID to be used by autocomplete trigger\\'s \"aria-owns\" property.\\n         */\\n        this.id = \"md-autocomplete-\" + _uniqueAutocompleteIdCounter++;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdAutocomplete.prototype.ngAfterContentInit = function () {\\n        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();\\n    };\\n    /**\\n     * Sets the panel scrollTop. This allows us to manually scroll to display\\n     * options below the fold, as they are not actually being focused when active.\\n     * @param {?} scrollTop\\n     * @return {?}\\n     */\\n    MdAutocomplete.prototype._setScrollTop = function (scrollTop) {\\n        if (this.panel) {\\n            this.panel.nativeElement.scrollTop = scrollTop;\\n        }\\n    };\\n    /**\\n     * Panel should hide itself when the option list is empty.\\n     * @return {?}\\n     */\\n    MdAutocomplete.prototype._setVisibility = function () {\\n        var _this = this;\\n        Promise.resolve().then(function () {\\n            _this.showPanel = !!_this.options.length;\\n            _this._changeDetectorRef.markForCheck();\\n        });\\n    };\\n    /**\\n     * Sets a class on the panel based on its position (used to set y-offset).\\n     * @return {?}\\n     */\\n    MdAutocomplete.prototype._getClassList = function () {\\n        return {\\n            \\'mat-autocomplete-panel-below\\': this.positionY === \\'below\\',\\n            \\'mat-autocomplete-panel-above\\': this.positionY === \\'above\\',\\n            \\'mat-autocomplete-visible\\': this.showPanel,\\n            \\'mat-autocomplete-hidden\\': !this.showPanel\\n        };\\n    };\\n    return MdAutocomplete;\\n}());\\nMdAutocomplete.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-autocomplete, mat-autocomplete\\',\\n                template: \"<ng-template> <div class=\\\\\"mat-autocomplete-panel\\\\\" role=\\\\\"listbox\\\\\" [id]=\\\\\"id\\\\\" [ngClass]=\\\\\"_getClassList()\\\\\" #panel> <ng-content></ng-content> </div> </ng-template> \",\\n                styles: [\".mat-autocomplete-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative}.mat-autocomplete-panel.mat-autocomplete-panel-below{top:6px}.mat-autocomplete-panel.mat-autocomplete-panel-above{top:-24px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden} /*# sourceMappingURL=autocomplete.css.map */ \"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                exportAs: \\'mdAutocomplete\\',\\n                host: {\\n                    \\'[class.mat-autocomplete]\\': \\'true\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdAutocomplete.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n]; };\\nMdAutocomplete.propDecorators = {\\n    \\'template\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"],] },],\\n    \\'panel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'panel\\',] },],\\n    \\'options\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdOption,] },],\\n    \\'displayWith\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * The height of each autocomplete option.\\n */\\nvar AUTOCOMPLETE_OPTION_HEIGHT = 48;\\n/**\\n * The total height of the autocomplete panel.\\n */\\nvar AUTOCOMPLETE_PANEL_HEIGHT = 256;\\n/**\\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\\n * \\\\@docs-private\\n */\\nvar MD_AUTOCOMPLETE_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"])(function () { return MdAutocompleteTrigger; }),\\n    multi: true\\n};\\nvar MdAutocompleteTrigger = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _element\\n     * @param {?} _overlay\\n     * @param {?} _viewContainerRef\\n     * @param {?} _changeDetectorRef\\n     * @param {?} _scrollDispatcher\\n     * @param {?} _dir\\n     * @param {?} _zone\\n     * @param {?} _inputContainer\\n     * @param {?} _document\\n     */\\n    function MdAutocompleteTrigger(_element, _overlay, _viewContainerRef, _changeDetectorRef, _scrollDispatcher, _dir, _zone, _inputContainer, _document) {\\n        this._element = _element;\\n        this._overlay = _overlay;\\n        this._viewContainerRef = _viewContainerRef;\\n        this._changeDetectorRef = _changeDetectorRef;\\n        this._scrollDispatcher = _scrollDispatcher;\\n        this._dir = _dir;\\n        this._zone = _zone;\\n        this._inputContainer = _inputContainer;\\n        this._document = _document;\\n        this._panelOpen = false;\\n        /**\\n         * Whether or not the placeholder state is being overridden.\\n         */\\n        this._manuallyFloatingPlaceholder = false;\\n        /**\\n         * View -> model callback called when value changes\\n         */\\n        this._onChange = function (value) { };\\n        /**\\n         * View -> model callback called when autocomplete has been touched\\n         */\\n        this._onTouched = function () { };\\n    }\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"_matAutocomplete\", {\\n        /**\\n         * Property with mat- prefix for no-conflict mode.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.autocomplete;\\n        },\\n        /**\\n         * @param {?} autocomplete\\n         * @return {?}\\n         */\\n        set: function (autocomplete) {\\n            this.autocomplete = autocomplete;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.ngOnDestroy = function () {\\n        if (this._panelPositionSubscription) {\\n            this._panelPositionSubscription.unsubscribe();\\n        }\\n        this._destroyPanel();\\n    };\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"panelOpen\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._panelOpen && this.autocomplete.showPanel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Opens the autocomplete suggestion panel.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.openPanel = function () {\\n        if (!this._overlayRef) {\\n            this._createOverlay();\\n        }\\n        else {\\n            /** Update the panel width, in case the host width has changed */\\n            this._overlayRef.getState().width = this._getHostWidth();\\n            this._overlayRef.updateSize();\\n        }\\n        if (!this._overlayRef.hasAttached()) {\\n            this._overlayRef.attach(this._portal);\\n            this._subscribeToClosingActions();\\n        }\\n        this.autocomplete._setVisibility();\\n        this._floatPlaceholder();\\n        this._panelOpen = true;\\n    };\\n    /**\\n     * Closes the autocomplete suggestion panel.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.closePanel = function () {\\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\\n            this._overlayRef.detach();\\n        }\\n        this._panelOpen = false;\\n        this._resetPlaceholder();\\n        // We need to trigger change detection manually, because\\n        // `fromEvent` doesn\\'t seem to do it at the proper time.\\n        // This ensures that the placeholder is reset when the\\n        // user clicks outside.\\n        this._changeDetectorRef.detectChanges();\\n    };\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"panelClosingActions\", {\\n        /**\\n         * A stream of actions that should close the autocomplete panel, including\\n         * when an option is selected, on blur, and when TAB is pressed.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].merge(this.optionSelections, this.autocomplete._keyManager.tabOut, this._outsideClickStream);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"optionSelections\", {\\n        /**\\n         * Stream of autocomplete option selections.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].merge.apply(__WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"], this.autocomplete.options.map(function (option) { return option.onSelectionChange; }));\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"activeOption\", {\\n        /**\\n         * The currently active option, coerced to MdOption type.\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (this.autocomplete._keyManager) {\\n                return (this.autocomplete._keyManager.activeItem);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"_outsideClickStream\", {\\n        /**\\n         * Stream of clicks outside of the autocomplete panel.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var _this = this;\\n            if (this._document) {\\n                return __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].fromEvent(this._document, \\'click\\').filter(function (event) {\\n                    var /** @type {?} */ clickTarget = (event.target);\\n                    var /** @type {?} */ inputContainer = _this._inputContainer ?\\n                        _this._inputContainer._elementRef.nativeElement : null;\\n                    return _this._panelOpen &&\\n                        clickTarget !== _this._element.nativeElement &&\\n                        (!inputContainer || !inputContainer.contains(clickTarget)) &&\\n                        !_this._overlayRef.overlayElement.contains(clickTarget);\\n                });\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the autocomplete\\'s value. Part of the ControlValueAccessor interface\\n     * required to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} value New value to be written to the model.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.writeValue = function (value) {\\n        var _this = this;\\n        Promise.resolve(null).then(function () { return _this._setTriggerValue(value); });\\n    };\\n    /**\\n     * Saves a callback function to be invoked when the autocomplete\\'s value\\n     * changes from user input. Part of the ControlValueAccessor interface\\n     * required to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} fn Callback to be triggered when the value changes.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.registerOnChange = function (fn) {\\n        this._onChange = fn;\\n    };\\n    /**\\n     * Saves a callback function to be invoked when the autocomplete is blurred\\n     * by the user. Part of the ControlValueAccessor interface required\\n     * to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} fn Callback to be triggered when the component has been touched.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.registerOnTouched = function (fn) {\\n        this._onTouched = fn;\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._handleKeydown = function (event) {\\n        var _this = this;\\n        if (this.activeOption && event.keyCode === ENTER) {\\n            this.activeOption._selectViaInteraction();\\n            event.preventDefault();\\n        }\\n        else {\\n            var /** @type {?} */ prevActiveItem_1 = this.autocomplete._keyManager.activeItem;\\n            var /** @type {?} */ isArrowKey_1 = event.keyCode === UP_ARROW || event.keyCode === DOWN_ARROW;\\n            this.autocomplete._keyManager.onKeydown(event);\\n            if (isArrowKey_1) {\\n                this.openPanel();\\n            }\\n            Promise.resolve().then(function () {\\n                if (isArrowKey_1 || _this.autocomplete._keyManager.activeItem !== prevActiveItem_1) {\\n                    _this._scrollToOption();\\n                }\\n            });\\n        }\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._handleInput = function (event) {\\n        // We need to ensure that the input is focused, because IE will fire the `input`\\n        // event on focus/blur/load if the input has a placeholder. See:\\n        // https://connect.microsoft.com/IE/feedback/details/885747/\\n        if (document.activeElement === event.target) {\\n            this._onChange(((event.target)).value);\\n            this.openPanel();\\n        }\\n    };\\n    /**\\n     * In \"auto\" mode, the placeholder will animate down as soon as focus is lost.\\n     * This causes the value to jump when selecting an option with the mouse.\\n     * This method manually floats the placeholder until the panel can be closed.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._floatPlaceholder = function () {\\n        if (this._inputContainer && this._inputContainer.floatPlaceholder === \\'auto\\') {\\n            this._inputContainer.floatPlaceholder = \\'always\\';\\n            this._manuallyFloatingPlaceholder = true;\\n        }\\n    };\\n    /**\\n     * If the placeholder has been manually elevated, return it to its normal state.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._resetPlaceholder = function () {\\n        if (this._manuallyFloatingPlaceholder) {\\n            this._inputContainer.floatPlaceholder = \\'auto\\';\\n            this._manuallyFloatingPlaceholder = false;\\n        }\\n    };\\n    /**\\n     * Given that we are not actually focusing active options, we must manually adjust scroll\\n     * to reveal options below the fold. First, we find the offset of the option from the top\\n     * of the panel. The new scrollTop will be that offset - the panel height + the option\\n     * height, so the active option will be just visible at the bottom of the panel.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._scrollToOption = function () {\\n        var /** @type {?} */ optionOffset = this.autocomplete._keyManager.activeItemIndex * AUTOCOMPLETE_OPTION_HEIGHT;\\n        var /** @type {?} */ newScrollTop = Math.max(0, optionOffset - AUTOCOMPLETE_PANEL_HEIGHT + AUTOCOMPLETE_OPTION_HEIGHT);\\n        this.autocomplete._setScrollTop(newScrollTop);\\n    };\\n    /**\\n     * This method listens to a stream of panel closing actions and resets the\\n     * stream every time the option list changes.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._subscribeToClosingActions = function () {\\n        var _this = this;\\n        // When the zone is stable initially, and when the option list changes...\\n        __WEBPACK_IMPORTED_MODULE_6_rxjs_Observable__[\"Observable\"].merge(this._zone.onStable.first(), this.autocomplete.options.changes)\\n            .switchMap(function () {\\n            _this._resetPanel();\\n            return _this.panelClosingActions;\\n        })\\n            .first()\\n            .subscribe(function (event) { return _this._setValueAndClose(event); });\\n    };\\n    /**\\n     * Destroys the autocomplete suggestion panel.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._destroyPanel = function () {\\n        if (this._overlayRef) {\\n            this.closePanel();\\n            this._overlayRef.dispose();\\n            this._overlayRef = null;\\n        }\\n    };\\n    /**\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._setTriggerValue = function (value) {\\n        var /** @type {?} */ toDisplay = this.autocomplete.displayWith ? this.autocomplete.displayWith(value) : value;\\n        this._element.nativeElement.value = toDisplay || \\'\\';\\n    };\\n    /**\\n     * This method closes the panel, and if a value is specified, also sets the associated\\n     * control to that value. It will also mark the control as dirty if this interaction\\n     * stemmed from the user.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._setValueAndClose = function (event) {\\n        if (event && event.source) {\\n            this._clearPreviousSelectedOption(event.source);\\n            this._setTriggerValue(event.source.value);\\n            this._onChange(event.source.value);\\n            this._element.nativeElement.focus();\\n        }\\n        this.closePanel();\\n    };\\n    /**\\n     * Clear any previous selected option and emit a selection change event for this option\\n     * @param {?} skip\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._clearPreviousSelectedOption = function (skip) {\\n        this.autocomplete.options.forEach(function (option) {\\n            if (option != skip && option.selected) {\\n                option.deselect();\\n            }\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._createOverlay = function () {\\n        this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);\\n        this._overlayRef = this._overlay.create(this._getOverlayConfig());\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._getOverlayConfig = function () {\\n        var /** @type {?} */ overlayState = new OverlayState();\\n        overlayState.positionStrategy = this._getOverlayPosition();\\n        overlayState.width = this._getHostWidth();\\n        overlayState.direction = this._dir ? this._dir.value : \\'ltr\\';\\n        overlayState.scrollStrategy = new RepositionScrollStrategy(this._scrollDispatcher);\\n        return overlayState;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._getOverlayPosition = function () {\\n        this._positionStrategy = this._overlay.position().connectedTo(this._element, { originX: \\'start\\', originY: \\'bottom\\' }, { overlayX: \\'start\\', overlayY: \\'top\\' })\\n            .withFallbackPosition({ originX: \\'start\\', originY: \\'top\\' }, { overlayX: \\'start\\', overlayY: \\'bottom\\' });\\n        this._subscribeToPositionChanges(this._positionStrategy);\\n        return this._positionStrategy;\\n    };\\n    /**\\n     * This method subscribes to position changes in the autocomplete panel, so the panel\\'s\\n     * y-offset can be adjusted to match the new position.\\n     * @param {?} strategy\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._subscribeToPositionChanges = function (strategy) {\\n        var _this = this;\\n        this._panelPositionSubscription = strategy.onPositionChange.subscribe(function (change) {\\n            _this.autocomplete.positionY = change.connectionPair.originY === \\'top\\' ? \\'above\\' : \\'below\\';\\n        });\\n    };\\n    /**\\n     * Returns the width of the input element, so the panel width can match it.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._getHostWidth = function () {\\n        return this._element.nativeElement.getBoundingClientRect().width;\\n    };\\n    /**\\n     * Reset active item to null so arrow events will activate the correct options.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._resetActiveItem = function () {\\n        this.autocomplete._keyManager.setActiveItem(null);\\n    };\\n    /**\\n     * Resets the active item and re-calculates alignment of the panel in case its size\\n     * has changed due to fewer or greater number of options.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._resetPanel = function () {\\n        this._resetActiveItem();\\n        this._positionStrategy.recalculateLastPosition();\\n        this.autocomplete._setVisibility();\\n    };\\n    return MdAutocompleteTrigger;\\n}());\\nMdAutocompleteTrigger.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'input[mdAutocomplete], input[matAutocomplete]\\',\\n                host: {\\n                    \\'role\\': \\'combobox\\',\\n                    \\'autocomplete\\': \\'off\\',\\n                    \\'aria-autocomplete\\': \\'list\\',\\n                    \\'aria-multiline\\': \\'false\\',\\n                    \\'[attr.aria-activedescendant]\\': \\'activeOption?.id\\',\\n                    \\'[attr.aria-expanded]\\': \\'panelOpen.toString()\\',\\n                    \\'[attr.aria-owns]\\': \\'autocomplete?.id\\',\\n                    \\'(focus)\\': \\'openPanel()\\',\\n                    \\'(input)\\': \\'_handleInput($event)\\',\\n                    \\'(blur)\\': \\'_onTouched()\\',\\n                    \\'(keydown)\\': \\'_handleKeydown($event)\\',\\n                },\\n                providers: [MD_AUTOCOMPLETE_VALUE_ACCESSOR]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdAutocompleteTrigger.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: ScrollDispatcher, },\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: MdInputContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Host\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__[\"DOCUMENT\"],] },] },\\n]; };\\nMdAutocompleteTrigger.propDecorators = {\\n    \\'autocomplete\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdAutocomplete\\',] },],\\n    \\'_matAutocomplete\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matAutocomplete\\',] },],\\n};\\nvar MdAutocompleteModule = /*@__PURE__*/(function () {\\n    function MdAutocompleteModule() {\\n    }\\n    return MdAutocompleteModule;\\n}());\\nMdAutocompleteModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdOptionModule, OverlayModule, MdCommonModule, __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"]],\\n                exports: [MdAutocomplete, MdOptionModule, MdAutocompleteTrigger, MdCommonModule],\\n                declarations: [MdAutocomplete, MdAutocompleteTrigger],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdAutocompleteModule.ctorParameters = function () { return []; };\\n/**\\n * An internal class that represents the data corresponding to a single calendar cell.\\n * \\\\@docs-private\\n */\\nvar MdCalendarCell = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} value\\n     * @param {?} displayValue\\n     * @param {?} ariaLabel\\n     * @param {?} enabled\\n     */\\n    function MdCalendarCell(value, displayValue, ariaLabel, enabled) {\\n        this.value = value;\\n        this.displayValue = displayValue;\\n        this.ariaLabel = ariaLabel;\\n        this.enabled = enabled;\\n    }\\n    return MdCalendarCell;\\n}());\\n/**\\n * An internal component used to display calendar data in a table.\\n * \\\\@docs-private\\n */\\nvar MdCalendarBody = /*@__PURE__*/(function () {\\n    function MdCalendarBody() {\\n        /**\\n         * The number of columns in the table.\\n         */\\n        this.numCols = 7;\\n        /**\\n         * Whether to allow selection of disabled cells.\\n         */\\n        this.allowDisabledSelection = false;\\n        /**\\n         * The cell number of the active cell in the table.\\n         */\\n        this.activeCell = 0;\\n        /**\\n         * Emits when a new value is selected.\\n         */\\n        this.selectedValueChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    /**\\n     * @param {?} cell\\n     * @return {?}\\n     */\\n    MdCalendarBody.prototype._cellClicked = function (cell) {\\n        if (!this.allowDisabledSelection && !cell.enabled) {\\n            return;\\n        }\\n        this.selectedValueChange.emit(cell.value);\\n    };\\n    Object.defineProperty(MdCalendarBody.prototype, \"_firstRowOffset\", {\\n        /**\\n         * The number of blank cells to put at the beginning for the first row.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.rows && this.rows.length && this.rows[0].length ?\\n                this.numCols - this.rows[0].length : 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} rowIndex\\n     * @param {?} colIndex\\n     * @return {?}\\n     */\\n    MdCalendarBody.prototype._isActiveCell = function (rowIndex, colIndex) {\\n        var /** @type {?} */ cellNumber = rowIndex * this.numCols + colIndex;\\n        // Account for the fact that the first row may not have as many cells.\\n        if (rowIndex) {\\n            cellNumber -= this._firstRowOffset;\\n        }\\n        return cellNumber == this.activeCell;\\n    };\\n    return MdCalendarBody;\\n}());\\nMdCalendarBody.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'[md-calendar-body]\\',\\n                template: \"\\x3c!-- If there\\'s not enough space in the first row, create a separate label row. We mark this row as aria-hidden because we don\\'t want it to be read out as one of the weeks in the month. --\\x3e <tr *ngIf=\\\\\"_firstRowOffset < labelMinRequiredCells\\\\\" aria-hidden=\\\\\"true\\\\\"> <td class=\\\\\"mat-calendar-body-label\\\\\" [attr.colspan]=\\\\\"numCols\\\\\" >{{label}}</td> </tr> \\x3c!-- Create the first row separately so we can include a special spacer cell. --\\x3e <tr *ngFor=\\\\\"let row of rows; let rowIndex = index\\\\\" role=\\\\\"row\\\\\"> \\x3c!-- We mark this cell as aria-hidden so it doesn\\'t get read out as one of the days in the week. --\\x3e <td *ngIf=\\\\\"rowIndex === 0 && _firstRowOffset\\\\\" aria-hidden=\\\\\"true\\\\\" class=\\\\\"mat-calendar-body-label\\\\\" [attr.colspan]=\\\\\"_firstRowOffset\\\\\"> {{_firstRowOffset >= labelMinRequiredCells ? label : \\'\\'}} </td> <td *ngFor=\\\\\"let item of row; let colIndex = index\\\\\" role=\\\\\"gridcell\\\\\" class=\\\\\"mat-calendar-body-cell\\\\\" [tabindex]=\\\\\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\\\\\" [class.mat-calendar-body-disabled]=\\\\\"!item.enabled\\\\\" [class.mat-calendar-body-active]=\\\\\"_isActiveCell(rowIndex, colIndex)\\\\\" [attr.aria-label]=\\\\\"item.ariaLabel\\\\\" [attr.aria-disabled]=\\\\\"!item.enabled || null\\\\\" (click)=\\\\\"_cellClicked(item)\\\\\"> <div class=\\\\\"mat-calendar-body-cell-content\\\\\" [class.mat-calendar-body-selected]=\\\\\"selectedValue === item.value\\\\\" [class.mat-calendar-body-today]=\\\\\"todayValue === item.value\\\\\"> {{item.displayValue}} </div> </td> </tr> \",\\n                styles: [\".mat-calendar-body{font-size:13px;min-width:224px}.mat-calendar-body-label{padding:7.14286% 0 7.14286% 7.14286%;height:0;line-height:0;transform:translateX(-6px);text-align:left;font-size:14px;font-weight:700}.mat-calendar-body-cell{position:relative;width:14.28571%;height:0;line-height:0;padding:7.14286% 0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;border-width:1px;border-style:solid;border-radius:50%}[dir=rtl] .mat-calendar-body-label{padding:0 7.14286% 0 0;transform:translateX(6px);text-align:right} /*# sourceMappingURL=calendar-body.css.map */ \"],\\n                host: {\\n                    \\'class\\': \\'mat-calendar-body\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCalendarBody.ctorParameters = function () { return []; };\\nMdCalendarBody.propDecorators = {\\n    \\'label\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'rows\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'todayValue\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedValue\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'labelMinRequiredCells\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'numCols\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'allowDisabledSelection\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'activeCell\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedValueChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * \\\\@docs-private\\n * @param {?} provider\\n * @return {?}\\n */\\nfunction createMissingDateImplError(provider) {\\n    return new Error(\"MdDatepicker: No provider found for \" + provider + \". You must import one of the following\" +\\n        \"modules at your application root: MdNativeDateModule, or provide a custom implementation.\");\\n}\\nvar DAYS_PER_WEEK = 7;\\n/**\\n * An internal component used to display a single month in the datepicker.\\n * \\\\@docs-private\\n */\\nvar MdMonthView = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dateAdapter\\n     * @param {?} _dateFormats\\n     */\\n    function MdMonthView(_dateAdapter, _dateFormats) {\\n        this._dateAdapter = _dateAdapter;\\n        this._dateFormats = _dateFormats;\\n        /**\\n         * Emits when a new date is selected.\\n         */\\n        this.selectedChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        if (!this._dateAdapter) {\\n            throw createMissingDateImplError(\\'DateAdapter\\');\\n        }\\n        if (!this._dateFormats) {\\n            throw createMissingDateImplError(\\'MD_DATE_FORMATS\\');\\n        }\\n        var firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();\\n        var narrowWeekdays = this._dateAdapter.getDayOfWeekNames(\\'narrow\\');\\n        var longWeekdays = this._dateAdapter.getDayOfWeekNames(\\'long\\');\\n        // Rotate the labels for days of the week based on the configured first day of the week.\\n        var weekdays = longWeekdays.map(function (long, i) {\\n            return { long: long, narrow: narrowWeekdays[i] };\\n        });\\n        this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));\\n        this._activeDate = this._dateAdapter.today();\\n    }\\n    Object.defineProperty(MdMonthView.prototype, \"activeDate\", {\\n        /**\\n         * The date to display in this month view (everything other than the month and year is ignored).\\n         * @return {?}\\n         */\\n        get: function () { return this._activeDate; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            var /** @type {?} */ oldActiveDate = this._activeDate;\\n            this._activeDate = value || this._dateAdapter.today();\\n            if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {\\n                this._init();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdMonthView.prototype, \"selected\", {\\n        /**\\n         * The currently selected date.\\n         * @return {?}\\n         */\\n        get: function () { return this._selected; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._selected = value;\\n            this._selectedDate = this._getDateInCurrentMonth(this.selected);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdMonthView.prototype.ngAfterContentInit = function () {\\n        this._init();\\n    };\\n    /**\\n     * Handles when a new date is selected.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdMonthView.prototype._dateSelected = function (date) {\\n        if (this._selectedDate == date) {\\n            return;\\n        }\\n        this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), date));\\n    };\\n    /**\\n     * Initializes this month view.\\n     * @return {?}\\n     */\\n    MdMonthView.prototype._init = function () {\\n        this._selectedDate = this._getDateInCurrentMonth(this.selected);\\n        this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());\\n        this._monthLabel =\\n            this._dateAdapter.getMonthNames(\\'short\\')[this._dateAdapter.getMonth(this.activeDate)]\\n                .toLocaleUpperCase();\\n        var /** @type {?} */ firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);\\n        this._firstWeekOffset =\\n            (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) -\\n                this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;\\n        this._createWeekCells();\\n    };\\n    /**\\n     * Creates MdCalendarCells for the dates in this month.\\n     * @return {?}\\n     */\\n    MdMonthView.prototype._createWeekCells = function () {\\n        var /** @type {?} */ daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);\\n        var /** @type {?} */ dateNames = this._dateAdapter.getDateNames();\\n        this._weeks = [[]];\\n        for (var /** @type {?} */ i = 0, /** @type {?} */ cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {\\n            if (cell == DAYS_PER_WEEK) {\\n                this._weeks.push([]);\\n                cell = 0;\\n            }\\n            var /** @type {?} */ date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);\\n            var /** @type {?} */ enabled = !this.dateFilter ||\\n                this.dateFilter(date);\\n            var /** @type {?} */ ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);\\n            this._weeks[this._weeks.length - 1]\\n                .push(new MdCalendarCell(i + 1, dateNames[i], ariaLabel, enabled));\\n        }\\n    };\\n    /**\\n     * Gets the date in this month that the given Date falls on.\\n     * Returns null if the given Date is in another month.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdMonthView.prototype._getDateInCurrentMonth = function (date) {\\n        return this._hasSameMonthAndYear(date, this.activeDate) ?\\n            this._dateAdapter.getDate(date) : null;\\n    };\\n    /**\\n     * Checks whether the 2 dates are non-null and fall within the same month of the same year.\\n     * @param {?} d1\\n     * @param {?} d2\\n     * @return {?}\\n     */\\n    MdMonthView.prototype._hasSameMonthAndYear = function (d1, d2) {\\n        return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&\\n            this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));\\n    };\\n    return MdMonthView;\\n}());\\nMdMonthView.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-month-view\\',\\n                template: \"<table class=\\\\\"mat-calendar-table\\\\\"> <thead class=\\\\\"mat-calendar-table-header\\\\\"> <tr><th *ngFor=\\\\\"let day of _weekdays\\\\\" [attr.aria-label]=\\\\\"day.long\\\\\">{{day.narrow}}</th></tr> <tr><th class=\\\\\"mat-calendar-table-header-divider\\\\\" colspan=\\\\\"7\\\\\" aria-hidden=\\\\\"true\\\\\"></th></tr> </thead> <tbody md-calendar-body role=\\\\\"grid\\\\\" [label]=\\\\\"_monthLabel\\\\\" [rows]=\\\\\"_weeks\\\\\" [todayValue]=\\\\\"_todayDate\\\\\" [selectedValue]=\\\\\"_selectedDate\\\\\" [labelMinRequiredCells]=\\\\\"3\\\\\" [activeCell]=\\\\\"_dateAdapter.getDate(activeDate) - 1\\\\\" (selectedValueChange)=\\\\\"_dateSelected($event)\\\\\"> </tbody> </table> \",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMonthView.ctorParameters = function () { return [\\n    { type: DateAdapter, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_DATE_FORMATS,] },] },\\n]; };\\nMdMonthView.propDecorators = {\\n    \\'activeDate\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'dateFilter\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * An internal component used to display a single year in the datepicker.\\n * \\\\@docs-private\\n */\\nvar MdYearView = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dateAdapter\\n     * @param {?} _dateFormats\\n     */\\n    function MdYearView(_dateAdapter, _dateFormats) {\\n        this._dateAdapter = _dateAdapter;\\n        this._dateFormats = _dateFormats;\\n        /**\\n         * Emits when a new month is selected.\\n         */\\n        this.selectedChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        if (!this._dateAdapter) {\\n            throw createMissingDateImplError(\\'DateAdapter\\');\\n        }\\n        if (!this._dateFormats) {\\n            throw createMissingDateImplError(\\'MD_DATE_FORMATS\\');\\n        }\\n        this._activeDate = this._dateAdapter.today();\\n    }\\n    Object.defineProperty(MdYearView.prototype, \"activeDate\", {\\n        /**\\n         * The date to display in this year view (everything other than the year is ignored).\\n         * @return {?}\\n         */\\n        get: function () { return this._activeDate; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            var /** @type {?} */ oldActiveDate = this._activeDate;\\n            this._activeDate = value || this._dateAdapter.today();\\n            if (this._dateAdapter.getYear(oldActiveDate) != this._dateAdapter.getYear(this._activeDate)) {\\n                this._init();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdYearView.prototype, \"selected\", {\\n        /**\\n         * The currently selected date.\\n         * @return {?}\\n         */\\n        get: function () { return this._selected; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._selected = value;\\n            this._selectedMonth = this._getMonthInCurrentYear(this.selected);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdYearView.prototype.ngAfterContentInit = function () {\\n        this._init();\\n    };\\n    /**\\n     * Handles when a new month is selected.\\n     * @param {?} month\\n     * @return {?}\\n     */\\n    MdYearView.prototype._monthSelected = function (month) {\\n        this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, this._dateAdapter.getDate(this.activeDate)));\\n    };\\n    /**\\n     * Initializes this month view.\\n     * @return {?}\\n     */\\n    MdYearView.prototype._init = function () {\\n        var _this = this;\\n        this._selectedMonth = this._getMonthInCurrentYear(this.selected);\\n        this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());\\n        this._yearLabel = this._dateAdapter.getYearName(this.activeDate);\\n        var /** @type {?} */ monthNames = this._dateAdapter.getMonthNames(\\'short\\');\\n        // First row of months only contains 5 elements so we can fit the year label on the same row.\\n        this._months = [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 10, 11]].map(function (row) { return row.map(function (month) { return _this._createCellForMonth(month, monthNames[month]); }); });\\n    };\\n    /**\\n     * Gets the month in this year that the given Date falls on.\\n     * Returns null if the given Date is in another year.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdYearView.prototype._getMonthInCurrentYear = function (date) {\\n        return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ?\\n            this._dateAdapter.getMonth(date) : null;\\n    };\\n    /**\\n     * Creates an MdCalendarCell for the given month.\\n     * @param {?} month\\n     * @param {?} monthName\\n     * @return {?}\\n     */\\n    MdYearView.prototype._createCellForMonth = function (month, monthName) {\\n        var /** @type {?} */ ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);\\n        return new MdCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._isMonthEnabled(month));\\n    };\\n    /**\\n     * Whether the given month is enabled.\\n     * @param {?} month\\n     * @return {?}\\n     */\\n    MdYearView.prototype._isMonthEnabled = function (month) {\\n        if (!this.dateFilter) {\\n            return true;\\n        }\\n        var /** @type {?} */ firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\\n        // If any date in the month is enabled count the month as enabled.\\n        for (var /** @type {?} */ date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {\\n            if (this.dateFilter(date)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n    return MdYearView;\\n}());\\nMdYearView.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-year-view\\',\\n                template: \"<table class=\\\\\"mat-calendar-table\\\\\"> <thead class=\\\\\"mat-calendar-table-header\\\\\"> <tr><th class=\\\\\"mat-calendar-table-header-divider\\\\\" colspan=\\\\\"7\\\\\"></th></tr> </thead> <tbody md-calendar-body role=\\\\\"grid\\\\\" allowDisabledSelection=\\\\\"true\\\\\" [label]=\\\\\"_yearLabel\\\\\" [rows]=\\\\\"_months\\\\\" [todayValue]=\\\\\"_todayMonth\\\\\" [selectedValue]=\\\\\"_selectedMonth\\\\\" [labelMinRequiredCells]=\\\\\"2\\\\\" [activeCell]=\\\\\"_dateAdapter.getMonth(activeDate)\\\\\" (selectedValueChange)=\\\\\"_monthSelected($event)\\\\\"> </tbody> </table> \",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdYearView.ctorParameters = function () { return [\\n    { type: DateAdapter, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_DATE_FORMATS,] },] },\\n]; };\\nMdYearView.propDecorators = {\\n    \\'activeDate\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'dateFilter\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Datepicker data that requires internationalization.\\n */\\nvar MdDatepickerIntl = /*@__PURE__*/(function () {\\n    function MdDatepickerIntl() {\\n        /**\\n         * A label for the calendar popup (used by screen readers).\\n         */\\n        this.calendarLabel = \\'Calendar\\';\\n        /**\\n         * A label for the button used to open the calendar popup (used by screen readers).\\n         */\\n        this.openCalendarLabel = \\'Open calendar\\';\\n        /**\\n         * A label for the previous month button (used by screen readers).\\n         */\\n        this.prevMonthLabel = \\'Previous month\\';\\n        /**\\n         * A label for the next month button (used by screen readers).\\n         */\\n        this.nextMonthLabel = \\'Next month\\';\\n        /**\\n         * A label for the previous year button (used by screen readers).\\n         */\\n        this.prevYearLabel = \\'Previous year\\';\\n        /**\\n         * A label for the next year button (used by screen readers).\\n         */\\n        this.nextYearLabel = \\'Next year\\';\\n        /**\\n         * A label for the \\'switch to month view\\' button (used by screen readers).\\n         */\\n        this.switchToMonthViewLabel = \\'Change to month view\\';\\n        /**\\n         * A label for the \\'switch to year view\\' button (used by screen readers).\\n         */\\n        this.switchToYearViewLabel = \\'Change to year view\\';\\n    }\\n    return MdDatepickerIntl;\\n}());\\nMdDatepickerIntl.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepickerIntl.ctorParameters = function () { return []; };\\n/**\\n * A calendar that is used as part of the datepicker.\\n * \\\\@docs-private\\n */\\nvar MdCalendar = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _intl\\n     * @param {?} _ngZone\\n     * @param {?} _isCompatibilityMode\\n     * @param {?} _dateAdapter\\n     * @param {?} _dateFormats\\n     */\\n    function MdCalendar(_elementRef, _intl, _ngZone, _isCompatibilityMode, _dateAdapter, _dateFormats) {\\n        var _this = this;\\n        this._elementRef = _elementRef;\\n        this._intl = _intl;\\n        this._ngZone = _ngZone;\\n        this._isCompatibilityMode = _isCompatibilityMode;\\n        this._dateAdapter = _dateAdapter;\\n        this._dateFormats = _dateFormats;\\n        /**\\n         * Whether the calendar should be started in month or year view.\\n         */\\n        this.startView = \\'month\\';\\n        /**\\n         * Emits when the currently selected date changes.\\n         */\\n        this.selectedChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Date filter for the month and year views.\\n         */\\n        this._dateFilterForViews = function (date) {\\n            return !!date &&\\n                (!_this.dateFilter || _this.dateFilter(date)) &&\\n                (!_this.minDate || _this._dateAdapter.compareDate(date, _this.minDate) >= 0) &&\\n                (!_this.maxDate || _this._dateAdapter.compareDate(date, _this.maxDate) <= 0);\\n        };\\n        if (!this._dateAdapter) {\\n            throw createMissingDateImplError(\\'DateAdapter\\');\\n        }\\n        if (!this._dateFormats) {\\n            throw createMissingDateImplError(\\'MD_DATE_FORMATS\\');\\n        }\\n    }\\n    Object.defineProperty(MdCalendar.prototype, \"_activeDate\", {\\n        /**\\n         * The current active date. This determines which time period is shown and which date is\\n         * highlighted when using keyboard navigation.\\n         * @return {?}\\n         */\\n        get: function () { return this._clampedActiveDate; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCalendar.prototype, \"_periodButtonText\", {\\n        /**\\n         * The label for the current calendar view.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._monthView ?\\n                this._dateAdapter.format(this._activeDate, this._dateFormats.display.monthYearLabel)\\n                    .toLocaleUpperCase() :\\n                this._dateAdapter.getYearName(this._activeDate);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCalendar.prototype, \"_periodButtonLabel\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._monthView ? this._intl.switchToYearViewLabel : this._intl.switchToMonthViewLabel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCalendar.prototype, \"_prevButtonLabel\", {\\n        /**\\n         * The label for the the previous button.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._monthView ? this._intl.prevMonthLabel : this._intl.prevYearLabel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCalendar.prototype, \"_nextButtonLabel\", {\\n        /**\\n         * The label for the the next button.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._monthView ? this._intl.nextMonthLabel : this._intl.nextYearLabel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdCalendar.prototype.ngAfterContentInit = function () {\\n        this._activeDate = this.startAt || this._dateAdapter.today();\\n        this._focusActiveCell();\\n        this._monthView = this.startView != \\'year\\';\\n    };\\n    /**\\n     * Handles date selection in the month view.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._dateSelected = function (date) {\\n        if (!this._dateAdapter.sameDate(date, this.selected)) {\\n            this.selectedChange.emit(date);\\n        }\\n    };\\n    /**\\n     * Handles month selection in the year view.\\n     * @param {?} month\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._monthSelected = function (month) {\\n        this._activeDate = month;\\n        this._monthView = true;\\n    };\\n    /**\\n     * Handles user clicks on the period label.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._currentPeriodClicked = function () {\\n        this._monthView = !this._monthView;\\n    };\\n    /**\\n     * Handles user clicks on the previous button.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._previousClicked = function () {\\n        this._activeDate = this._monthView ?\\n            this._dateAdapter.addCalendarMonths(this._activeDate, -1) :\\n            this._dateAdapter.addCalendarYears(this._activeDate, -1);\\n    };\\n    /**\\n     * Handles user clicks on the next button.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._nextClicked = function () {\\n        this._activeDate = this._monthView ?\\n            this._dateAdapter.addCalendarMonths(this._activeDate, 1) :\\n            this._dateAdapter.addCalendarYears(this._activeDate, 1);\\n    };\\n    /**\\n     * Whether the previous period button is enabled.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._previousEnabled = function () {\\n        if (!this.minDate) {\\n            return true;\\n        }\\n        return !this.minDate || !this._isSameView(this._activeDate, this.minDate);\\n    };\\n    /**\\n     * Whether the next period button is enabled.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._nextEnabled = function () {\\n        return !this.maxDate || !this._isSameView(this._activeDate, this.maxDate);\\n    };\\n    /**\\n     * Handles keydown events on the calendar body.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._handleCalendarBodyKeydown = function (event) {\\n        // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\\n        // disabled ones from being selected. This may not be ideal, we should look into whether\\n        // navigation should skip over disabled dates, and if so, how to implement that efficiently.\\n        if (this._monthView) {\\n            this._handleCalendarBodyKeydownInMonthView(event);\\n        }\\n        else {\\n            this._handleCalendarBodyKeydownInYearView(event);\\n        }\\n    };\\n    /**\\n     * Focuses the active cell after the microtask queue is empty.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._focusActiveCell = function () {\\n        var _this = this;\\n        this._ngZone.runOutsideAngular(function () { return _this._ngZone.onStable.first().subscribe(function () {\\n            var /** @type {?} */ activeEl = _this._elementRef.nativeElement.querySelector(\\'.mat-calendar-body-active\\');\\n            activeEl.focus();\\n        }); });\\n    };\\n    /**\\n     * Whether the two dates represent the same view in the current view mode (month or year).\\n     * @param {?} date1\\n     * @param {?} date2\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._isSameView = function (date1, date2) {\\n        return this._monthView ?\\n            this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&\\n                this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2) :\\n            this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);\\n    };\\n    /**\\n     * Handles keydown events on the calendar body when calendar is in month view.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._handleCalendarBodyKeydownInMonthView = function (event) {\\n        switch (event.keyCode) {\\n            case LEFT_ARROW:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -1);\\n                break;\\n            case RIGHT_ARROW:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1);\\n                break;\\n            case UP_ARROW:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);\\n                break;\\n            case DOWN_ARROW:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);\\n                break;\\n            case HOME:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));\\n                break;\\n            case END:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, (this._dateAdapter.getNumDaysInMonth(this._activeDate) -\\n                    this._dateAdapter.getDate(this._activeDate)));\\n                break;\\n            case PAGE_UP:\\n                this._activeDate = event.altKey ?\\n                    this._dateAdapter.addCalendarYears(this._activeDate, -1) :\\n                    this._dateAdapter.addCalendarMonths(this._activeDate, -1);\\n                break;\\n            case PAGE_DOWN:\\n                this._activeDate = event.altKey ?\\n                    this._dateAdapter.addCalendarYears(this._activeDate, 1) :\\n                    this._dateAdapter.addCalendarMonths(this._activeDate, 1);\\n                break;\\n            case ENTER:\\n                if (this._dateFilterForViews(this._activeDate)) {\\n                    this._dateSelected(this._activeDate);\\n                    // Prevent unexpected default actions such as form submission.\\n                    event.preventDefault();\\n                }\\n                return;\\n            default:\\n                // Don\\'t prevent default or focus active cell on keys that we don\\'t explicitly handle.\\n                return;\\n        }\\n        this._focusActiveCell();\\n        // Prevent unexpected default actions such as form submission.\\n        event.preventDefault();\\n    };\\n    /**\\n     * Handles keydown events on the calendar body when calendar is in year view.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._handleCalendarBodyKeydownInYearView = function (event) {\\n        switch (event.keyCode) {\\n            case LEFT_ARROW:\\n                this._activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -1);\\n                break;\\n            case RIGHT_ARROW:\\n                this._activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 1);\\n                break;\\n            case UP_ARROW:\\n                this._activeDate = this._prevMonthInSameCol(this._activeDate);\\n                break;\\n            case DOWN_ARROW:\\n                this._activeDate = this._nextMonthInSameCol(this._activeDate);\\n                break;\\n            case HOME:\\n                this._activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));\\n                break;\\n            case END:\\n                this._activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));\\n                break;\\n            case PAGE_UP:\\n                this._activeDate =\\n                    this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);\\n                break;\\n            case PAGE_DOWN:\\n                this._activeDate =\\n                    this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);\\n                break;\\n            case ENTER:\\n                this._monthSelected(this._activeDate);\\n                break;\\n            default:\\n                // Don\\'t prevent default or focus active cell on keys that we don\\'t explicitly handle.\\n                return;\\n        }\\n        this._focusActiveCell();\\n        // Prevent unexpected default actions such as form submission.\\n        event.preventDefault();\\n    };\\n    /**\\n     * Determine the date for the month that comes before the given month in the same column in the\\n     * calendar table.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._prevMonthInSameCol = function (date) {\\n        // Determine how many months to jump forward given that there are 2 empty slots at the beginning\\n        // of each year.\\n        var /** @type {?} */ increment = this._dateAdapter.getMonth(date) <= 4 ? -5 :\\n            (this._dateAdapter.getMonth(date) >= 7 ? -7 : -12);\\n        return this._dateAdapter.addCalendarMonths(date, increment);\\n    };\\n    /**\\n     * Determine the date for the month that comes after the given month in the same column in the\\n     * calendar table.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._nextMonthInSameCol = function (date) {\\n        // Determine how many months to jump forward given that there are 2 empty slots at the beginning\\n        // of each year.\\n        var /** @type {?} */ increment = this._dateAdapter.getMonth(date) <= 4 ? 7 :\\n            (this._dateAdapter.getMonth(date) >= 7 ? 5 : 12);\\n        return this._dateAdapter.addCalendarMonths(date, increment);\\n    };\\n    return MdCalendar;\\n}());\\nMdCalendar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-calendar\\',\\n                template: \"<div class=\\\\\"mat-calendar-header\\\\\"> <div class=\\\\\"mat-calendar-controls\\\\\"> \\x3c!-- TODO(mmalerba): Clean up duplicated compatibility mode code when we have a better way to do this. --\\x3e \\x3c!-- Check for compatibility mode and use correct prefix for md-button. --\\x3e <button *ngIf=\\\\\"!_isCompatibilityMode\\\\\" md-button class=\\\\\"mat-calendar-period-button\\\\\" (click)=\\\\\"_currentPeriodClicked()\\\\\"  [attr.aria-label]=\\\\\"_periodButtonLabel\\\\\"> {{_periodButtonText}} <div class=\\\\\"mat-calendar-arrow\\\\\" [class.mat-calendar-invert]=\\\\\"!_monthView\\\\\"></div> </button> <button *ngIf=\\\\\"_isCompatibilityMode\\\\\" mat-button class=\\\\\"mat-calendar-period-button\\\\\" (click)=\\\\\"_currentPeriodClicked()\\\\\"  [attr.aria-label]=\\\\\"_periodButtonLabel\\\\\"> {{_periodButtonText}} <div class=\\\\\"mat-calendar-arrow\\\\\" [class.mat-calendar-invert]=\\\\\"!_monthView\\\\\"></div> </button> <div class=\\\\\"mat-calendar-spacer\\\\\"></div> \\x3c!-- Check for compatibility mode and use correct prefix for md-icon-button. --\\x3e <button *ngIf=\\\\\"!_isCompatibilityMode\\\\\" md-icon-button class=\\\\\"mat-calendar-previous-button\\\\\" [disabled]=\\\\\"!_previousEnabled()\\\\\" (click)=\\\\\"_previousClicked()\\\\\" [attr.aria-label]=\\\\\"_prevButtonLabel\\\\\"> </button> <button *ngIf=\\\\\"_isCompatibilityMode\\\\\" mat-icon-button class=\\\\\"mat-calendar-previous-button\\\\\" [disabled]=\\\\\"!_previousEnabled()\\\\\" (click)=\\\\\"_previousClicked()\\\\\" [attr.aria-label]=\\\\\"_prevButtonLabel\\\\\"> </button> \\x3c!-- Check for compatibility mode and use correct prefix for md-icon-button. --\\x3e <button *ngIf=\\\\\"!_isCompatibilityMode\\\\\" md-icon-button class=\\\\\"mat-calendar-next-button\\\\\" [disabled]=\\\\\"!_nextEnabled()\\\\\" (click)=\\\\\"_nextClicked()\\\\\" [attr.aria-label]=\\\\\"_nextButtonLabel\\\\\"> </button> <button *ngIf=\\\\\"_isCompatibilityMode\\\\\" mat-icon-button class=\\\\\"mat-calendar-next-button\\\\\" [disabled]=\\\\\"!_nextEnabled()\\\\\" (click)=\\\\\"_nextClicked()\\\\\" [attr.aria-label]=\\\\\"_nextButtonLabel\\\\\"> </button> </div> </div> <div class=\\\\\"mat-calendar-content\\\\\" (keydown)=\\\\\"_handleCalendarBodyKeydown($event)\\\\\" cdkMonitorSubtreeFocus> <md-month-view *ngIf=\\\\\"_monthView\\\\\" [activeDate]=\\\\\"_activeDate\\\\\" [selected]=\\\\\"selected\\\\\" [dateFilter]=\\\\\"_dateFilterForViews\\\\\" (selectedChange)=\\\\\"_dateSelected($event)\\\\\"> </md-month-view> <md-year-view *ngIf=\\\\\"!_monthView\\\\\" [activeDate]=\\\\\"_activeDate\\\\\" [selected]=\\\\\"selected\\\\\" [dateFilter]=\\\\\"_dateFilterForViews\\\\\" (selectedChange)=\\\\\"_monthSelected($event)\\\\\"> </md-year-view> </div> \",\\n                styles: [\".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:0}.mat-calendar-controls{display:flex;padding:5% calc(100% / 14 - 22px) 5% calc(100% / 14 - 22px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{font:inherit;font-size:14px;font-weight:700;min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{content:\\'\\';position:absolute;top:0;left:0;bottom:0;right:0;margin:15.5px;border:0 solid currentColor;border-top-width:2px}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;font-size:11px;font-weight:400;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:\\'\\';position:absolute;top:0;left:-8px;right:-8px;height:1px} /*# sourceMappingURL=calendar.css.map */ \"],\\n                host: {\\n                    \\'[class.mat-calendar]\\': \\'true\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCalendar.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: MdDatepickerIntl, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MATERIAL_COMPATIBILITY_MODE,] },] },\\n    { type: DateAdapter, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_DATE_FORMATS,] },] },\\n]; };\\nMdCalendar.propDecorators = {\\n    \\'startAt\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'startView\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'minDate\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'maxDate\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'dateFilter\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Used to generate a unique ID for each datepicker instance.\\n */\\nvar datepickerUid = 0;\\n/**\\n * Component used as the content for the datepicker dialog and popup. We use this instead of using\\n * MdCalendar directly as the content so we can control the initial focus. This also gives us a\\n * place to put additional features of the popup that are not part of the calendar itself in the\\n * future. (e.g. confirmation buttons).\\n * \\\\@docs-internal\\n */\\nvar MdDatepickerContent = /*@__PURE__*/(function () {\\n    function MdDatepickerContent() {\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdDatepickerContent.prototype.ngAfterContentInit = function () {\\n        this._calendar._focusActiveCell();\\n    };\\n    /**\\n     * Handles keydown event on datepicker content.\\n     * @param {?} event The event.\\n     * @return {?}\\n     */\\n    MdDatepickerContent.prototype._handleKeydown = function (event) {\\n        switch (event.keyCode) {\\n            case ESCAPE:\\n                this.datepicker.close();\\n                break;\\n            default:\\n                // Return so that we don\\'t preventDefault on keys that are not explicitly handled.\\n                return;\\n        }\\n        event.preventDefault();\\n    };\\n    return MdDatepickerContent;\\n}());\\nMdDatepickerContent.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-datepicker-content\\',\\n                template: \"<md-calendar cdkTrapFocus [id]=\\\\\"datepicker.id\\\\\" [startAt]=\\\\\"datepicker.startAt\\\\\" [startView]=\\\\\"datepicker.startView\\\\\" [minDate]=\\\\\"datepicker._minDate\\\\\" [maxDate]=\\\\\"datepicker._maxDate\\\\\" [dateFilter]=\\\\\"datepicker._dateFilter\\\\\" [selected]=\\\\\"datepicker._selected\\\\\" (selectedChange)=\\\\\"datepicker._selectAndClose($event)\\\\\"> </md-calendar> \",\\n                styles: [\".mat-datepicker-content{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);display:block}.mat-calendar{width:296px}.mat-datepicker-content-touch{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{width:64vmin;height:80vmin;min-width:250px;min-height:312px;max-width:750px;max-height:788px} /*# sourceMappingURL=datepicker-content.css.map */ \"],\\n                host: {\\n                    \\'class\\': \\'mat-datepicker-content\\',\\n                    \\'[class.mat-datepicker-content-touch]\\': \\'datepicker.touchUi\\',\\n                    \\'(keydown)\\': \\'_handleKeydown($event)\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepickerContent.ctorParameters = function () { return []; };\\nMdDatepickerContent.propDecorators = {\\n    \\'_calendar\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdCalendar,] },],\\n};\\n/**\\n * Component responsible for managing the datepicker popup/dialog.\\n */\\nvar MdDatepicker = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dialog\\n     * @param {?} _overlay\\n     * @param {?} _viewContainerRef\\n     * @param {?} _dateAdapter\\n     * @param {?} _dir\\n     */\\n    function MdDatepicker(_dialog, _overlay, _viewContainerRef, _dateAdapter, _dir) {\\n        this._dialog = _dialog;\\n        this._overlay = _overlay;\\n        this._viewContainerRef = _viewContainerRef;\\n        this._dateAdapter = _dateAdapter;\\n        this._dir = _dir;\\n        /**\\n         * The view that the calendar should start in.\\n         */\\n        this.startView = \\'month\\';\\n        /**\\n         * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\\n         * than a popup and elements have more padding to allow for bigger touch targets.\\n         */\\n        this.touchUi = false;\\n        /**\\n         * Emits new selected date when selected date changes.\\n         */\\n        this.selectedChanged = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Whether the calendar is open.\\n         */\\n        this.opened = false;\\n        /**\\n         * The id for the datepicker calendar.\\n         */\\n        this.id = \"md-datepicker-\" + datepickerUid++;\\n        /**\\n         * The currently selected date.\\n         */\\n        this._selected = null;\\n        if (!this._dateAdapter) {\\n            throw createMissingDateImplError(\\'DateAdapter\\');\\n        }\\n    }\\n    Object.defineProperty(MdDatepicker.prototype, \"startAt\", {\\n        /**\\n         * The date to open the calendar to initially.\\n         * @return {?}\\n         */\\n        get: function () {\\n            // If an explicit startAt is set we start there, otherwise we start at whatever the currently\\n            // selected value is.\\n            return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);\\n        },\\n        /**\\n         * @param {?} date\\n         * @return {?}\\n         */\\n        set: function (date) { this._startAt = date; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepicker.prototype, \"_minDate\", {\\n        /**\\n         * The minimum selectable date.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._datepickerInput && this._datepickerInput.min;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepicker.prototype, \"_maxDate\", {\\n        /**\\n         * The maximum selectable date.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._datepickerInput && this._datepickerInput.max;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepicker.prototype, \"_dateFilter\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._datepickerInput && this._datepickerInput._dateFilter;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype.ngOnDestroy = function () {\\n        this.close();\\n        if (this._popupRef) {\\n            this._popupRef.dispose();\\n        }\\n        if (this._inputSubscription) {\\n            this._inputSubscription.unsubscribe();\\n        }\\n    };\\n    /**\\n     * Selects the given date and closes the currently open popup or dialog.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._selectAndClose = function (date) {\\n        var /** @type {?} */ oldValue = this._selected;\\n        this._selected = date;\\n        if (!this._dateAdapter.sameDate(oldValue, this._selected)) {\\n            this.selectedChanged.emit(date);\\n        }\\n        this.close();\\n    };\\n    /**\\n     * Register an input with this datepicker.\\n     * @param {?} input The datepicker input to register with this datepicker.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._registerInput = function (input) {\\n        var _this = this;\\n        if (this._datepickerInput) {\\n            throw new Error(\\'An MdDatepicker can only be associated with a single input.\\');\\n        }\\n        this._datepickerInput = input;\\n        this._inputSubscription =\\n            this._datepickerInput._valueChange.subscribe(function (value) { return _this._selected = value; });\\n    };\\n    /**\\n     * Open the calendar.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype.open = function () {\\n        if (this.opened) {\\n            return;\\n        }\\n        if (!this._datepickerInput) {\\n            throw new Error(\\'Attempted to open an MdDatepicker with no associated input.\\');\\n        }\\n        this.touchUi ? this._openAsDialog() : this._openAsPopup();\\n        this.opened = true;\\n    };\\n    /**\\n     * Close the calendar.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype.close = function () {\\n        if (!this.opened) {\\n            return;\\n        }\\n        if (this._popupRef && this._popupRef.hasAttached()) {\\n            this._popupRef.detach();\\n        }\\n        if (this._dialogRef) {\\n            this._dialogRef.close();\\n            this._dialogRef = null;\\n        }\\n        if (this._calendarPortal && this._calendarPortal.isAttached) {\\n            this._calendarPortal.detach();\\n        }\\n        this.opened = false;\\n    };\\n    /**\\n     * Open the calendar as a dialog.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._openAsDialog = function () {\\n        var _this = this;\\n        var /** @type {?} */ config = new MdDialogConfig();\\n        config.viewContainerRef = this._viewContainerRef;\\n        this._dialogRef = this._dialog.open(MdDatepickerContent, config);\\n        this._dialogRef.afterClosed().first().subscribe(function () { return _this.close(); });\\n        this._dialogRef.componentInstance.datepicker = this;\\n    };\\n    /**\\n     * Open the calendar as a popup.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._openAsPopup = function () {\\n        var _this = this;\\n        if (!this._calendarPortal) {\\n            this._calendarPortal = new ComponentPortal(MdDatepickerContent, this._viewContainerRef);\\n        }\\n        if (!this._popupRef) {\\n            this._createPopup();\\n        }\\n        if (!this._popupRef.hasAttached()) {\\n            var /** @type {?} */ componentRef = this._popupRef.attach(this._calendarPortal);\\n            componentRef.instance.datepicker = this;\\n        }\\n        this._popupRef.backdropClick().first().subscribe(function () { return _this.close(); });\\n    };\\n    /**\\n     * Create the popup.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._createPopup = function () {\\n        var /** @type {?} */ overlayState = new OverlayState();\\n        overlayState.positionStrategy = this._createPopupPositionStrategy();\\n        overlayState.hasBackdrop = true;\\n        overlayState.backdropClass = \\'md-overlay-transparent-backdrop\\';\\n        overlayState.direction = this._dir ? this._dir.value : \\'ltr\\';\\n        this._popupRef = this._overlay.create(overlayState);\\n    };\\n    /**\\n     * Create the popup PositionStrategy.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._createPopupPositionStrategy = function () {\\n        var /** @type {?} */ origin = ({ originX: \\'start\\', originY: \\'bottom\\' });\\n        var /** @type {?} */ overlay = ({ overlayX: \\'start\\', overlayY: \\'top\\' });\\n        return this._overlay.position().connectedTo(this._datepickerInput.getPopupConnectionElementRef(), origin, overlay);\\n    };\\n    return MdDatepicker;\\n}());\\nMdDatepicker.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-datepicker, mat-datepicker\\',\\n                template: \\'\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepicker.ctorParameters = function () { return [\\n    { type: MdDialog, },\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n    { type: DateAdapter, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: Dir, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdDatepicker.propDecorators = {\\n    \\'startAt\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'startView\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'touchUi\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedChanged\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MD_DATEPICKER_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"])(function () { return MdDatepickerInput; }),\\n    multi: true\\n};\\nvar MD_DATEPICKER_VALIDATORS = {\\n    provide: __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"NG_VALIDATORS\"],\\n    useExisting: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"])(function () { return MdDatepickerInput; }),\\n    multi: true\\n};\\n/**\\n * Directive used to connect an input to a MdDatepicker.\\n */\\nvar MdDatepickerInput = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     * @param {?} _dateAdapter\\n     * @param {?} _dateFormats\\n     * @param {?} _mdInputContainer\\n     */\\n    function MdDatepickerInput(_elementRef, _renderer, _dateAdapter, _dateFormats, _mdInputContainer) {\\n        var _this = this;\\n        this._elementRef = _elementRef;\\n        this._renderer = _renderer;\\n        this._dateAdapter = _dateAdapter;\\n        this._dateFormats = _dateFormats;\\n        this._mdInputContainer = _mdInputContainer;\\n        /**\\n         * Emits when the value changes (either due to user input or programmatic change).\\n         */\\n        this._valueChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        this._onTouched = function () { };\\n        this._cvaOnChange = function (value) { };\\n        this._validatorOnChange = function () { };\\n        /**\\n         * The form control validator for the min date.\\n         */\\n        this._minValidator = function (control) {\\n            return (!_this.min || !control.value ||\\n                _this._dateAdapter.compareDate(_this.min, control.value) < 0) ?\\n                null : { \\'mdDatepickerMin\\': { \\'min\\': _this.min, \\'actual\\': control.value } };\\n        };\\n        /**\\n         * The form control validator for the max date.\\n         */\\n        this._maxValidator = function (control) {\\n            return (!_this.max || !control.value ||\\n                _this._dateAdapter.compareDate(_this.max, control.value) > 0) ?\\n                null : { \\'mdDatepickerMax\\': { \\'max\\': _this.max, \\'actual\\': control.value } };\\n        };\\n        /**\\n         * The form control validator for the date filter.\\n         */\\n        this._filterValidator = function (control) {\\n            return !_this._dateFilter || !control.value || _this._dateFilter(control.value) ?\\n                null : { \\'mdDatepickerFilter\\': true };\\n        };\\n        /**\\n         * The combined form control validator for this input.\\n         */\\n        this._validator = __WEBPACK_IMPORTED_MODULE_13__angular_forms__[\"Validators\"].compose([this._minValidator, this._maxValidator, this._filterValidator]);\\n        if (!this._dateAdapter) {\\n            throw createMissingDateImplError(\\'DateAdapter\\');\\n        }\\n        if (!this._dateFormats) {\\n            throw createMissingDateImplError(\\'MD_DATE_FORMATS\\');\\n        }\\n    }\\n    Object.defineProperty(MdDatepickerInput.prototype, \"mdDatepicker\", {\\n        /**\\n         * The datepicker that this input is associated with.\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value) {\\n                this._datepicker = value;\\n                this._datepicker._registerInput(this);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"matDatepicker\", {\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this.mdDatepicker = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"mdDatepickerFilter\", {\\n        /**\\n         * @param {?} filter\\n         * @return {?}\\n         */\\n        set: function (filter) {\\n            this._dateFilter = filter;\\n            this._validatorOnChange();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"matDatepickerFilter\", {\\n        /**\\n         * @param {?} filter\\n         * @return {?}\\n         */\\n        set: function (filter) {\\n            this.mdDatepickerFilter = filter;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"value\", {\\n        /**\\n         * The value of the input.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._dateAdapter.parse(this._elementRef.nativeElement.value, this._dateFormats.parse.dateInput);\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            var /** @type {?} */ date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);\\n            var /** @type {?} */ oldDate = this.value;\\n            this._renderer.setProperty(this._elementRef.nativeElement, \\'value\\', date ? this._dateAdapter.format(date, this._dateFormats.display.dateInput) : \\'\\');\\n            if (!this._dateAdapter.sameDate(oldDate, date)) {\\n                this._valueChange.emit(date);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"min\", {\\n        /**\\n         * The minimum valid date.\\n         * @return {?}\\n         */\\n        get: function () { return this._min; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._min = value;\\n            this._validatorOnChange();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"max\", {\\n        /**\\n         * The maximum valid date.\\n         * @return {?}\\n         */\\n        get: function () { return this._max; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._max = value;\\n            this._validatorOnChange();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        if (this._datepicker) {\\n            this._datepickerSubscription =\\n                this._datepicker.selectedChanged.subscribe(function (selected) {\\n                    _this.value = selected;\\n                    _this._cvaOnChange(selected);\\n                });\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.ngOnDestroy = function () {\\n        if (this._datepickerSubscription) {\\n            this._datepickerSubscription.unsubscribe();\\n        }\\n    };\\n    /**\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.registerOnValidatorChange = function (fn) {\\n        this._validatorOnChange = fn;\\n    };\\n    /**\\n     * @param {?} c\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.validate = function (c) {\\n        return this._validator ? this._validator(c) : null;\\n    };\\n    /**\\n     * Gets the element that the datepicker popup should be connected to.\\n     * @return {?} The element to connect the popup to.\\n     */\\n    MdDatepickerInput.prototype.getPopupConnectionElementRef = function () {\\n        return this._mdInputContainer ? this._mdInputContainer.underlineRef : this._elementRef;\\n    };\\n    /**\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.writeValue = function (value) {\\n        this.value = value;\\n    };\\n    /**\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.registerOnChange = function (fn) {\\n        this._cvaOnChange = fn;\\n    };\\n    /**\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.registerOnTouched = function (fn) {\\n        this._onTouched = fn;\\n    };\\n    /**\\n     * @param {?} disabled\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.setDisabledState = function (disabled) {\\n        this._renderer.setProperty(this._elementRef.nativeElement, \\'disabled\\', disabled);\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype._onKeydown = function (event) {\\n        if (event.altKey && event.keyCode === DOWN_ARROW) {\\n            this._datepicker.open();\\n            event.preventDefault();\\n        }\\n    };\\n    /**\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype._onInput = function (value) {\\n        var /** @type {?} */ date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);\\n        this._cvaOnChange(date);\\n        this._valueChange.emit(date);\\n    };\\n    return MdDatepickerInput;\\n}());\\nMdDatepickerInput.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'input[mdDatepicker], input[matDatepicker]\\',\\n                providers: [MD_DATEPICKER_VALUE_ACCESSOR, MD_DATEPICKER_VALIDATORS],\\n                host: {\\n                    \\'[attr.aria-expanded]\\': \\'_datepicker?.opened || \"false\"\\',\\n                    \\'[attr.aria-haspopup]\\': \\'true\\',\\n                    \\'[attr.aria-owns]\\': \\'_datepicker?.id\\',\\n                    \\'[attr.min]\\': \\'min ? _dateAdapter.getISODateString(min) : null\\',\\n                    \\'[attr.max]\\': \\'max ? _dateAdapter.getISODateString(max) : null\\',\\n                    \\'(input)\\': \\'_onInput($event.target.value)\\',\\n                    \\'(blur)\\': \\'_onTouched()\\',\\n                    \\'(keydown)\\': \\'_onKeydown($event)\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepickerInput.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: DateAdapter, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_DATE_FORMATS,] },] },\\n    { type: MdInputContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdDatepickerInput.propDecorators = {\\n    \\'mdDatepicker\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'matDatepicker\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'mdDatepickerFilter\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'matDatepickerFilter\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'min\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'max\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdDatepickerToggle = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _intl\\n     */\\n    function MdDatepickerToggle(_intl) {\\n        this._intl = _intl;\\n        /**\\n         * Type of the button.\\n         */\\n        this.type = \\'button\\';\\n    }\\n    Object.defineProperty(MdDatepickerToggle.prototype, \"_datepicker\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.datepicker; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.datepicker = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdDatepickerToggle.prototype._open = function (event) {\\n        if (this.datepicker) {\\n            this.datepicker.open();\\n            event.stopPropagation();\\n        }\\n    };\\n    return MdDatepickerToggle;\\n}());\\nMdDatepickerToggle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'button[mdDatepickerToggle], button[matDatepickerToggle]\\',\\n                template: \\'\\',\\n                styles: [\".mat-datepicker-toggle{display:inline-block;background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iY3VycmVudENvbG9yIj48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE5IDNoLTFWMWgtMnYySDhWMUg2djJINWMtMS4xMSAwLTEuOTkuOS0xLjk5IDJMMyAxOWMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDVWOGgxNHYxMXpNNyAxMGg1djVIN3oiLz48L3N2Zz4=) no-repeat;background-size:contain;height:24px;width:24px;border:none;outline:0;vertical-align:middle}.mat-datepicker-toggle:not([disabled]){cursor:pointer} /*# sourceMappingURL=datepicker-toggle.css.map */ \"],\\n                host: {\\n                    \\'[attr.type]\\': \\'type\\',\\n                    \\'[class.mat-datepicker-toggle]\\': \\'true\\',\\n                    \\'[attr.aria-label]\\': \\'_intl.openCalendarLabel\\',\\n                    \\'(click)\\': \\'_open($event)\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepickerToggle.ctorParameters = function () { return [\\n    { type: MdDatepickerIntl, },\\n]; };\\nMdDatepickerToggle.propDecorators = {\\n    \\'datepicker\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdDatepickerToggle\\',] },],\\n    \\'type\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_datepicker\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matDatepickerToggle\\',] },],\\n};\\nvar MdDatepickerModule = /*@__PURE__*/(function () {\\n    function MdDatepickerModule() {\\n    }\\n    return MdDatepickerModule;\\n}());\\nMdDatepickerModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"],\\n                    MdButtonModule,\\n                    MdDialogModule,\\n                    OverlayModule,\\n                    StyleModule,\\n                ],\\n                exports: [\\n                    MdDatepicker,\\n                    MdDatepickerContent,\\n                    MdDatepickerInput,\\n                    MdDatepickerToggle,\\n                ],\\n                declarations: [\\n                    MdCalendar,\\n                    MdCalendarBody,\\n                    MdDatepicker,\\n                    MdDatepickerContent,\\n                    MdDatepickerInput,\\n                    MdDatepickerToggle,\\n                    MdMonthView,\\n                    MdYearView,\\n                ],\\n                providers: [\\n                    MdDatepickerIntl,\\n                ],\\n                entryComponents: [\\n                    MdDatepickerContent,\\n                ]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepickerModule.ctorParameters = function () { return []; };\\nvar MATERIAL_MODULES = [\\n    MdAutocompleteModule,\\n    MdButtonModule,\\n    MdButtonToggleModule,\\n    MdCardModule,\\n    MdChipsModule,\\n    MdCheckboxModule,\\n    MdDatepickerModule,\\n    MdDialogModule,\\n    MdGridListModule,\\n    MdIconModule,\\n    MdInputModule,\\n    MdListModule,\\n    MdMenuModule,\\n    MdProgressBarModule,\\n    MdProgressSpinnerModule,\\n    MdRadioModule,\\n    MdRippleModule,\\n    MdSelectModule,\\n    MdSidenavModule,\\n    MdSliderModule,\\n    MdSlideToggleModule,\\n    MdSnackBarModule,\\n    MdTabsModule,\\n    MdToolbarModule,\\n    MdTooltipModule,\\n    OverlayModule,\\n    PortalModule,\\n    RtlModule,\\n    StyleModule,\\n    A11yModule,\\n    PlatformModule,\\n    MdCommonModule,\\n    ObserveContentModule,\\n];\\n/**\\n * @deprecated\\n */\\nvar MaterialModule = /*@__PURE__*/(function () {\\n    function MaterialModule() {\\n    }\\n    return MaterialModule;\\n}());\\nMaterialModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: MATERIAL_MODULES,\\n                exports: MATERIAL_MODULES,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMaterialModule.ctorParameters = function () { return []; };\\n/**\\n * @module\\n * @description\\n * Entry point for all public APIs of Angular Material.\\n */\\n/**\\n * Generated bundle index. Do not edit.\\n */\\n\\n//# sourceMappingURL=material.es5.js.map\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9tYXRlcmlhbC9AYW5ndWxhci9tYXRlcmlhbC5lczUuanM/NDlkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuLyoqXG4gICogQGxpY2Vuc2UgQW5ndWxhciBNYXRlcmlhbCB2Mi4wLjAtYmV0YS42XG4gICogQ29weXJpZ2h0IChjKSAyMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL21hdGVyaWFsLmFuZ3VsYXIuaW8vXG4gICogTGljZW5zZTogTUlUXG4gICovXG5pbXBvcnQgeyBBcHBsaWNhdGlvblJlZiwgQXR0cmlidXRlLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb250ZW50Q2hpbGQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3QsIEhvc3RCaW5kaW5nLCBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciwgSW5wdXQsIE5nTW9kdWxlLCBOZ1pvbmUsIE9wdGlvbmFsLCBPdXRwdXQsIFJlbmRlcmVyMiwgU2VjdXJpdHlDb250ZXh0LCBTZWxmLCBTa2lwU2VsZiwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCwgVmlld0NvbnRhaW5lclJlZiwgVmlld0VuY2Fwc3VsYXRpb24sIGZvcndhcmRSZWYsIGlzRGV2TW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRE9DVU1FTlQsIERvbVNhbml0aXplciwgSEFNTUVSX0dFU1RVUkVfQ09ORklHLCBIYW1tZXJHZXN0dXJlQ29uZmlnIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZGVib3VuY2VUaW1lJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSwgTG9jYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9tZXJnZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2F1ZGl0VGltZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2ZpcnN0JztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9vZic7XG5pbXBvcnQgeyBGb3JtR3JvdXBEaXJlY3RpdmUsIEZvcm1zTW9kdWxlLCBOR19WQUxJREFUT1JTLCBOR19WQUxVRV9BQ0NFU1NPUiwgTmdDb250cm9sLCBOZ0Zvcm0sIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBhbmltYXRlLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc3RhcnRXaXRoJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZmlsdGVyJztcbmltcG9ydCB7IEh0dHAgfSBmcm9tICdAYW5ndWxhci9odHRwJztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9mb3JrSm9pbic7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL21hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2RvJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc2hhcmUnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9maW5hbGx5JztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2gnO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL3Rocm93JztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwJztcbnZhciBNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ21kLWNvbXBhdGliaWxpdHktbW9kZScpO1xuLyoqXG4gKiBJbmplY3Rpb24gdG9rZW4gdGhhdCBjb25maWd1cmVzIHdoZXRoZXIgdGhlIE1hdGVyaWFsIHNhbml0eSBjaGVja3MgYXJlIGVuYWJsZWQuXG4gKi9cbnZhciBNQVRFUklBTF9TQU5JVFlfQ0hFQ0tTID0gbmV3IEluamVjdGlvblRva2VuKCdtZC1zYW5pdHktY2hlY2tzJyk7XG4vKipcbiAqIFJldHVybnMgYW4gZXhjZXB0aW9uIHRvIGJlIHRocm93biBpZiB0aGUgY29uc3VtZXIgaGFzIHVzZWRcbiAqIGFuIGludmFsaWQgTWF0ZXJpYWwgcHJlZml4IG9uIGEgY29tcG9uZW50LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcGFyYW0gez99IHByZWZpeFxuICogQHBhcmFtIHs/fSBub2RlTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TWRDb21wYXRpYmlsaXR5SW52YWxpZFByZWZpeEVycm9yKHByZWZpeCwgbm9kZU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiVGhlIFxcXCJcIiArIHByZWZpeCArIFwiLVxcXCIgcHJlZml4IGNhbm5vdCBiZSB1c2VkIGluIG5nLW1hdGVyaWFsIHYxIGNvbXBhdGliaWxpdHkgbW9kZS4gXCIgK1xuICAgICAgICAoXCJJdCB3YXMgdXNlZCBvbiBhbiBcXFwiXCIgKyBub2RlTmFtZS50b0xvd2VyQ2FzZSgpICsgXCJcXFwiIGVsZW1lbnQuXCIpKTtcbn1cbi8qKlxuICogU2VsZWN0b3IgdGhhdCBtYXRjaGVzIGFsbCBlbGVtZW50cyB0aGF0IG1heSBoYXZlIHN0eWxlIGNvbGxpc2lvbnMgd2l0aCBBbmd1bGFySlMgTWF0ZXJpYWwuXG4gKi9cbnZhciBNQVRfRUxFTUVOVFNfU0VMRUNUT1IgPSBcIlxcbiAgW21hdC1idXR0b25dLFxcbiAgW21hdC1jYXJkLXN1YnRpdGxlXSxcXG4gIFttYXQtY2FyZC10aXRsZV0sXFxuICBbbWF0LWRpYWxvZy1hY3Rpb25zXSxcXG4gIFttYXQtZGlhbG9nLWNsb3NlXSxcXG4gIFttYXQtZGlhbG9nLWNvbnRlbnRdLFxcbiAgW21hdC1kaWFsb2ctdGl0bGVdLFxcbiAgW21hdC1mYWJdLFxcbiAgW21hdC1pY29uLWJ1dHRvbl0sXFxuICBbbWF0LW1lbnUtdHJpZ2dlci1mb3JdLFxcbiAgW21hdC1taW5pLWZhYl0sXFxuICBbbWF0LXJhaXNlZC1idXR0b25dLFxcbiAgW21hdC10YWItbGFiZWxdLFxcbiAgW21hdC10YWItbGlua10sXFxuICBbbWF0LXRhYi1uYXYtYmFyXSxcXG4gIFttYXRUb29sdGlwXSxcXG4gIG1hdC1hdXRvY29tcGxldGUsXFxuICBtYXQtYnV0dG9uLXRvZ2dsZSxcXG4gIG1hdC1idXR0b24tdG9nZ2xlLWdyb3VwLFxcbiAgbWF0LWJ1dHRvbi10b2dnbGUsXFxuICBtYXQtY2FyZCxcXG4gIG1hdC1jYXJkLWFjdGlvbnMsXFxuICBtYXQtY2FyZC1jb250ZW50LFxcbiAgbWF0LWNhcmQtZm9vdGVyLFxcbiAgbWF0LWNhcmQtaGVhZGVyLFxcbiAgbWF0LWNhcmQtc3VidGl0bGUsXFxuICBtYXQtY2FyZC10aXRsZSxcXG4gIG1hdC1jYXJkLXRpdGxlLWdyb3VwLFxcbiAgbWF0LWNoZWNrYm94LFxcbiAgbWF0LWNoaXAsXFxuICBtYXQtZGlhbG9nLWFjdGlvbnMsXFxuICBtYXQtZGlhbG9nLWNvbnRhaW5lcixcXG4gIG1hdC1kaWFsb2ctY29udGVudCxcXG4gIG1hdC1kaXZpZGVyLFxcbiAgbWF0LWdyaWQtbGlzdCxcXG4gIG1hdC1ncmlkLXRpbGUsXFxuICBtYXQtZ3JpZC10aWxlLWZvb3RlcixcXG4gIG1hdC1ncmlkLXRpbGUtaGVhZGVyLFxcbiAgbWF0LWhpbnQsXFxuICBtYXQtaWNvbixcXG4gIG1hdC1saXN0LFxcbiAgbWF0LWxpc3QtaXRlbSxcXG4gIG1hdC1tZW51LFxcbiAgbWF0LW5hdi1saXN0LFxcbiAgbWF0LW9wdGlvbixcXG4gIG1hdC1wbGFjZWhvbGRlcixcXG4gIG1hdC1wcm9ncmVzcy1iYXIsXFxuICBtYXQtcHNldWRvLWNoZWNrYm94LFxcbiAgbWF0LXJhZGlvLWJ1dHRvbixcXG4gIG1hdC1yYWRpby1ncm91cCxcXG4gIG1hdC1zZWxlY3QsXFxuICBtYXQtc2lkZW5hdixcXG4gIG1hdC1zaWRlbmF2LWNvbnRhaW5lcixcXG4gIG1hdC1zbGlkZXIsXFxuICBtYXQtc3Bpbm5lcixcXG4gIG1hdC10YWIsXFxuICBtYXQtdGFiLWdyb3VwLFxcbiAgbWF0LXRvb2xiYXIsXFxuICBtYXQtZXJyb3JcIjtcbi8qKlxuICogU2VsZWN0b3IgdGhhdCBtYXRjaGVzIGFsbCBlbGVtZW50cyB0aGF0IG1heSBoYXZlIHN0eWxlIGNvbGxpc2lvbnMgd2l0aCBBbmd1bGFySlMgTWF0ZXJpYWwuXG4gKi9cbnZhciBNRF9FTEVNRU5UU19TRUxFQ1RPUiA9IFwiXFxuICBbbWQtYnV0dG9uXSxcXG4gIFttZC1jYXJkLXN1YnRpdGxlXSxcXG4gIFttZC1jYXJkLXRpdGxlXSxcXG4gIFttZC1kaWFsb2ctYWN0aW9uc10sXFxuICBbbWQtZGlhbG9nLWNsb3NlXSxcXG4gIFttZC1kaWFsb2ctY29udGVudF0sXFxuICBbbWQtZGlhbG9nLXRpdGxlXSxcXG4gIFttZC1mYWJdLFxcbiAgW21kLWljb24tYnV0dG9uXSxcXG4gIFttZC1tZW51LXRyaWdnZXItZm9yXSxcXG4gIFttZC1taW5pLWZhYl0sXFxuICBbbWQtcmFpc2VkLWJ1dHRvbl0sXFxuICBbbWQtdGFiLWxhYmVsXSxcXG4gIFttZC10YWItbGlua10sXFxuICBbbWQtdGFiLW5hdi1iYXJdLFxcbiAgW21kVG9vbHRpcF0sXFxuICBtZC1hdXRvY29tcGxldGUsXFxuICBtZC1idXR0b24tdG9nZ2xlLFxcbiAgbWQtYnV0dG9uLXRvZ2dsZS1ncm91cCxcXG4gIG1kLWJ1dHRvbi10b2dnbGUsXFxuICBtZC1jYXJkLFxcbiAgbWQtY2FyZC1hY3Rpb25zLFxcbiAgbWQtY2FyZC1jb250ZW50LFxcbiAgbWQtY2FyZC1mb290ZXIsXFxuICBtZC1jYXJkLWhlYWRlcixcXG4gIG1kLWNhcmQtc3VidGl0bGUsXFxuICBtZC1jYXJkLXRpdGxlLFxcbiAgbWQtY2FyZC10aXRsZS1ncm91cCxcXG4gIG1kLWNoZWNrYm94LFxcbiAgbWQtY2hpcCxcXG4gIG1kLWRpYWxvZy1hY3Rpb25zLFxcbiAgbWQtZGlhbG9nLWNvbnRhaW5lcixcXG4gIG1kLWRpYWxvZy1jb250ZW50LFxcbiAgbWQtZGl2aWRlcixcXG4gIG1kLWdyaWQtbGlzdCxcXG4gIG1kLWdyaWQtdGlsZSxcXG4gIG1kLWdyaWQtdGlsZS1mb290ZXIsXFxuICBtZC1ncmlkLXRpbGUtaGVhZGVyLFxcbiAgbWQtaGludCxcXG4gIG1kLWljb24sXFxuICBtZC1saXN0LFxcbiAgbWQtbGlzdC1pdGVtLFxcbiAgbWQtbWVudSxcXG4gIG1kLW5hdi1saXN0LFxcbiAgbWQtb3B0aW9uLFxcbiAgbWQtcGxhY2Vob2xkZXIsXFxuICBtZC1wcm9ncmVzcy1iYXIsXFxuICBtZC1wc2V1ZG8tY2hlY2tib3gsXFxuICBtZC1yYWRpby1idXR0b24sXFxuICBtZC1yYWRpby1ncm91cCxcXG4gIG1kLXNlbGVjdCxcXG4gIG1kLXNpZGVuYXYsXFxuICBtZC1zaWRlbmF2LWNvbnRhaW5lcixcXG4gIG1kLXNsaWRlcixcXG4gIG1kLXNwaW5uZXIsXFxuICBtZC10YWIsXFxuICBtZC10YWItZ3JvdXAsXFxuICBtZC10b29sYmFyLFxcbiAgbWQtZXJyb3JcIjtcbi8qKlxuICogRGlyZWN0aXZlIHRoYXQgZW5mb3JjZXMgdGhhdCB0aGUgYG1hdC1gIHByZWZpeCBjYW5ub3QgYmUgdXNlZC5cbiAqL1xudmFyIE1hdFByZWZpeFJlamVjdG9yID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc0NvbXBhdGliaWxpdHlNb2RlXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWF0UHJlZml4UmVqZWN0b3IoaXNDb21wYXRpYmlsaXR5TW9kZSwgZWxlbWVudFJlZikge1xuICAgICAgICBpZiAoIWlzQ29tcGF0aWJpbGl0eU1vZGUpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kQ29tcGF0aWJpbGl0eUludmFsaWRQcmVmaXhFcnJvcignbWF0JywgZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm5vZGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWF0UHJlZml4UmVqZWN0b3I7XG59KCkpO1xuTWF0UHJlZml4UmVqZWN0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6IE1BVF9FTEVNRU5UU19TRUxFQ1RPUiB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1hdFByZWZpeFJlamVjdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSxdIH0sXSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbl07IH07XG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IGVuZm9yY2VzIHRoYXQgdGhlIGBtZC1gIHByZWZpeCBjYW5ub3QgYmUgdXNlZC5cbiAqL1xudmFyIE1kUHJlZml4UmVqZWN0b3IgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlzQ29tcGF0aWJpbGl0eU1vZGVcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFByZWZpeFJlamVjdG9yKGlzQ29tcGF0aWJpbGl0eU1vZGUsIGVsZW1lbnRSZWYpIHtcbiAgICAgICAgaWYgKGlzQ29tcGF0aWJpbGl0eU1vZGUpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kQ29tcGF0aWJpbGl0eUludmFsaWRQcmVmaXhFcnJvcignbWQnLCBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQubm9kZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNZFByZWZpeFJlamVjdG9yO1xufSgpKTtcbk1kUHJlZml4UmVqZWN0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6IE1EX0VMRU1FTlRTX1NFTEVDVE9SIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRQcmVmaXhSZWplY3Rvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUsXSB9LF0gfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG5dOyB9O1xuLyoqXG4gKiBNb2R1bGUgdGhhdCBlbmZvcmNlcyB0aGUgZGVmYXVsdCBjb21wYXRpYmlsaXR5IG1vZGUgc2V0dGluZ3MuIFdoZW4gdGhpcyBtb2R1bGUgaXMgbG9hZGVkXG4gKiB3aXRob3V0IE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlIGFsc28gYmVpbmcgaW1wb3J0ZWQsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAqIHRoZXJlIGFyZSBhbnkgdXNlcyBvZiB0aGUgYG1hdC1gIHByZWZpeC5cbiAqL1xudmFyIENvbXBhdGliaWxpdHlNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kb2N1bWVudFxuICAgICAqIEBwYXJhbSB7P30gX3Nhbml0eUNoZWNrc0VuYWJsZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21wYXRpYmlsaXR5TW9kdWxlKF9kb2N1bWVudCwgX3Nhbml0eUNoZWNrc0VuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHdlJ3ZlIGRvbmUgdGhlIGdsb2JhbCBzYW5pdHkgY2hlY2tzIChlLmcuIGEgdGhlbWUgaXMgbG9hZGVkLCB0aGVyZSBpcyBhIGRvY3R5cGUpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGFzRG9uZUdsb2JhbENoZWNrcyA9IGZhbHNlO1xuICAgICAgICBpZiAoX3Nhbml0eUNoZWNrc0VuYWJsZWQgJiYgIXRoaXMuX2hhc0RvbmVHbG9iYWxDaGVja3MgJiYgX2RvY3VtZW50ICYmIGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBydW5uaW5nIHRoZSBjaGVjayB0byBhbGxvdyBtb3JlIHRpbWUgZm9yIHRoZSB1c2VyJ3Mgc3R5bGVzIHRvIGxvYWQuXG4gICAgICAgICAgICB0aGlzLl9jaGVja0RvY3R5cGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrVGhlbWUoKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RvbmVHbG9iYWxDaGVja3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGF0aWJpbGl0eU1vZHVsZS5wcm90b3R5cGUuX2NoZWNrRG9jdHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5kb2N0eXBlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0N1cnJlbnQgZG9jdW1lbnQgZG9lcyBub3QgaGF2ZSBhIGRvY3R5cGUuIFRoaXMgbWF5IGNhdXNlICcgK1xuICAgICAgICAgICAgICAgICdzb21lIEFuZ3VsYXIgTWF0ZXJpYWwgY29tcG9uZW50cyBub3QgdG8gYmVoYXZlIGFzIGV4cGVjdGVkLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBhdGliaWxpdHlNb2R1bGUucHJvdG90eXBlLl9jaGVja1RoZW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGdldENvbXB1dGVkU3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlc3RFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtYXQtdGhlbWUtbG9hZGVkLW1hcmtlcicpO1xuICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXN0RWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0ZXN0RWxlbWVudCkuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBBbmd1bGFyIE1hdGVyaWFsIGNvcmUgdGhlbWUuIE1vc3QgTWF0ZXJpYWwgJyArXG4gICAgICAgICAgICAgICAgICAgICdjb21wb25lbnRzIG1heSBub3Qgd29yayBhcyBleHBlY3RlZC4gRm9yIG1vcmUgaW5mbyByZWZlciAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RvIHRoZSB0aGVtaW5nIGd1aWRlOiBodHRwczovL21hdGVyaWFsLmFuZ3VsYXIuaW8vZ3VpZGUvdGhlbWluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXN0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb21wYXRpYmlsaXR5TW9kdWxlO1xufSgpKTtcbkNvbXBhdGliaWxpdHlNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01hdFByZWZpeFJlamVjdG9yLCBNZFByZWZpeFJlamVjdG9yXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWF0UHJlZml4UmVqZWN0b3IsIE1kUHJlZml4UmVqZWN0b3JdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1BVEVSSUFMX1NBTklUWV9DSEVDS1MsIHVzZVZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQ29tcGF0aWJpbGl0eU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtET0NVTUVOVCxdIH0sXSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01BVEVSSUFMX1NBTklUWV9DSEVDS1MsXSB9LF0gfSxcbl07IH07XG4vKipcbiAqIE1vZHVsZSB0aGF0IGVuZm9yY2VzIFwibm8tY29uZmxpY3RcIiBjb21wYXRpYmlsaXR5IG1vZGUgc2V0dGluZ3MuIFdoZW4gdGhpcyBtb2R1bGUgaXMgbG9hZGVkLFxuICogaXQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IHVzZXMgb2YgdGhlIGBtZC1gIHByZWZpeC5cbiAqL1xudmFyIE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBOb0NvbmZsaWN0U3R5bGVDb21wYXRpYmlsaXR5TW9kZTtcbn0oKSk7XG5Ob0NvbmZsaWN0U3R5bGVDb21wYXRpYmlsaXR5TW9kZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTUFURVJJQUxfQ09NUEFUSUJJTElUWV9NT0RFLCB1c2VWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIE1vZHVsZSB0aGF0IGNhcHR1cmVzIGFueXRoaW5nIHRoYXQgc2hvdWxkIGJlIGxvYWRlZCBhbmQvb3IgcnVuIGZvciAqYWxsKiBBbmd1bGFyIE1hdGVyaWFsXG4gKiBjb21wb25lbnRzLiBUaGlzIGluY2x1ZGVzIEJpZGksIGNvbXBhdGliaWxpdHkgbW9kZSwgZXRjLlxuICpcbiAqIFRoaXMgbW9kdWxlIHNob3VsZCBiZSBpbXBvcnRlZCB0byBlYWNoIHRvcC1sZXZlbCBjb21wb25lbnQgbW9kdWxlIChlLmcuLCBNZFRhYnNNb2R1bGUpLlxuICovXG52YXIgTWRDb21tb25Nb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENvbW1vbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ29tbW9uTW9kdWxlO1xufSgpKTtcbk1kQ29tbW9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0NvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENvbW1vbk1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBTaGFyZWQgZGlyZWN0aXZlIHRvIGNvdW50IGxpbmVzIGluc2lkZSBhIHRleHQgYXJlYSwgc3VjaCBhcyBhIGxpc3QgaXRlbS5cbiAqIExpbmUgZWxlbWVudHMgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGEgXFxAQ29udGVudENoaWxkcmVuKE1kTGluZSkgcXVlcnksIHRoZW5cbiAqIGNvdW50ZWQgYnkgY2hlY2tpbmcgdGhlIHF1ZXJ5IGxpc3QncyBsZW5ndGguXG4gKi9cbnZhciBNZExpbmUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpbmUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZExpbmU7XG59KCkpO1xuTWRMaW5lLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtbGluZV0sIFttYXQtbGluZV0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtbGluZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTGluZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBIZWxwZXIgdGhhdCB0YWtlcyBhIHF1ZXJ5IGxpc3Qgb2YgbGluZXMgYW5kIHNldHMgdGhlIGNvcnJlY3QgY2xhc3Mgb24gdGhlIGhvc3QuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTGluZVNldHRlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2xpbmVzXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRMaW5lU2V0dGVyKF9saW5lcywgX3JlbmRlcmVyLCBfZWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9saW5lcyA9IF9saW5lcztcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fc2V0TGluZUNsYXNzKHRoaXMuX2xpbmVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX2xpbmVzLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9zZXRMaW5lQ2xhc3MoX3RoaXMuX2xpbmVzLmxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvdW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZExpbmVTZXR0ZXIucHJvdG90eXBlLl9zZXRMaW5lQ2xhc3MgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRDbGFzc2VzKCk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMiB8fCBjb3VudCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q2xhc3MoXCJtYXQtXCIgKyBjb3VudCArIFwiLWxpbmVcIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY291bnQgPiAzKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRDbGFzcyhcIm1hdC1tdWx0aS1saW5lXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTGluZVNldHRlci5wcm90b3R5cGUuX3Jlc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0Q2xhc3MoJ21hdC0yLWxpbmUnLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldENsYXNzKCdtYXQtMy1saW5lJywgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZXRDbGFzcygnbWF0LW11bHRpLWxpbmUnLCBmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7P30gaXNBZGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTGluZVNldHRlci5wcm90b3R5cGUuX3NldENsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgaXNBZGQpIHtcbiAgICAgICAgaWYgKGlzQWRkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZExpbmVTZXR0ZXI7XG59KCkpO1xudmFyIE1kTGluZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGluZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTGluZU1vZHVsZTtcbn0oKSk7XG5NZExpbmVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNZENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kTGluZSwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kTGluZV0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTGluZU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBEaXJlY3RpdmUgdG8gbGlzdGVuIGZvciBjaGFuZ2VzIG9mIGRpcmVjdGlvbiBvZiBwYXJ0IG9mIHRoZSBET00uXG4gKlxuICogQXBwbGljYXRpb25zIHNob3VsZCB1c2UgdGhpcyBkaXJlY3RpdmUgaW5zdGVhZCBvZiB0aGUgbmF0aXZlIGF0dHJpYnV0ZSBzbyB0aGF0IE1hdGVyaWFsXG4gKiBjb21wb25lbnRzIGNhbiBsaXN0ZW4gb24gY2hhbmdlcyBvZiBkaXJlY3Rpb24uXG4gKi9cbnZhciBEaXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXIoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMYXlvdXQgZGlyZWN0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGlyID0gJ2x0cic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGRpcmVjdGlvbiBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXIucHJvdG90eXBlLCBcImRpclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBkb2NzLXByaXZhdGVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpcjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkID0gdGhpcy5fZGlyO1xuICAgICAgICAgICAgdGhpcy5fZGlyID0gdjtcbiAgICAgICAgICAgIGlmIChvbGQgIT0gdGhpcy5fZGlyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJDaGFuZ2UuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IGxheW91dCBkaXJlY3Rpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlyOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuZGlyID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERpcjtcbn0oKSk7XG5EaXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tkaXJdJyxcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGhhbnNsKTogbWF5YmUgYCRpbXBsaWNpdGAgaXNuJ3QgdGhlIGJlc3Qgb3B0aW9uIGhlcmUsIGJ1dCBmb3Igbm93IHRoYXQncyB0aGUgYmVzdCB3ZSBnb3QuXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICckaW1wbGljaXQnXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkRpci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuRGlyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdfZGlyJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnZGlyJyxdIH0sXSxcbiAgICAnZGlyQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnZGlyJzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5kaXInLF0gfSxdLFxufTtcbnZhciBSdGxNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSdGxNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBSdGxNb2R1bGU7XG59KCkpO1xuUnRsTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbRGlyXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtEaXJdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblJ0bE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBGYWN0b3J5IHRoYXQgY3JlYXRlcyBhIG5ldyBNdXRhdGlvbk9ic2VydmVyIGFuZCBhbGxvd3MgdXMgdG8gc3R1YiBpdCBvdXQgaW4gdW5pdCB0ZXN0cy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRNdXRhdGlvbk9ic2VydmVyRmFjdG9yeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTXV0YXRpb25PYnNlcnZlckZhY3RvcnkoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTXV0YXRpb25PYnNlcnZlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIE1kTXV0YXRpb25PYnNlcnZlckZhY3Rvcnk7XG59KCkpO1xuTWRNdXRhdGlvbk9ic2VydmVyRmFjdG9yeS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRNdXRhdGlvbk9ic2VydmVyRmFjdG9yeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBEaXJlY3RpdmUgdGhhdCB0cmlnZ2VycyBhIGNhbGxiYWNrIHdoZW5ldmVyIHRoZSBjb250ZW50IG9mXG4gKiBpdHMgYXNzb2NpYXRlZCBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG52YXIgT2JzZXJ2ZUNvbnRlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9tdXRhdGlvbk9ic2VydmVyRmFjdG9yeVxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPYnNlcnZlQ29udGVudChfbXV0YXRpb25PYnNlcnZlckZhY3RvcnksIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5ID0gX211dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5O1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIGZvciBlYWNoIGNoYW5nZSBpbiB0aGUgZWxlbWVudCdzIGNvbnRlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBmb3IgZGVib3VuY2luZyB0aGUgZW1pdHRlZCB2YWx1ZXMgdG8gdGhlIG9ic2VydmVDb250ZW50IGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGVib3VuY2VyID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPYnNlcnZlQ29udGVudC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYm91bmNlclxuICAgICAgICAgICAgICAgIC5kZWJvdW5jZVRpbWUodGhpcy5kZWJvdW5jZSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHsgcmV0dXJuIF90aGlzLmV2ZW50LmVtaXQobXV0YXRpb25zKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJvdW5jZXIuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHsgcmV0dXJuIF90aGlzLmV2ZW50LmVtaXQobXV0YXRpb25zKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSB0aGlzLl9tdXRhdGlvbk9ic2VydmVyRmFjdG9yeS5jcmVhdGUoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgICAgICAgX3RoaXMuX2RlYm91bmNlci5uZXh0KG11dGF0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwge1xuICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE9ic2VydmVDb250ZW50LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9kZWJvdW5jZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2RlYm91bmNlciA9IHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmVDb250ZW50O1xufSgpKTtcbk9ic2VydmVDb250ZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrT2JzZXJ2ZUNvbnRlbnRdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5PYnNlcnZlQ29udGVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE1kTXV0YXRpb25PYnNlcnZlckZhY3RvcnksIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuXTsgfTtcbk9ic2VydmVDb250ZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdldmVudCc6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydjZGtPYnNlcnZlQ29udGVudCcsXSB9LF0sXG4gICAgJ2RlYm91bmNlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbnZhciBPYnNlcnZlQ29udGVudE1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVDb250ZW50TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gT2JzZXJ2ZUNvbnRlbnRNb2R1bGU7XG59KCkpO1xuT2JzZXJ2ZUNvbnRlbnRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtPYnNlcnZlQ29udGVudF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbT2JzZXJ2ZUNvbnRlbnRdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01kTXV0YXRpb25PYnNlcnZlckZhY3RvcnldXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk9ic2VydmVDb250ZW50TW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vLyBEdWUgdG8gYSBidWcgaW4gdGhlIENocm9tZURyaXZlciwgQW5ndWxhciBrZXlib2FyZCBldmVudHMgYXJlIG5vdCB0cmlnZ2VyZWQgYnkgYHNlbmRLZXlzYFxuLy8gZHVyaW5nIEUyRSB0ZXN0cyB3aGVuIHVzaW5nIGRvdCBub3RhdGlvbiBzdWNoIGFzIGAoa2V5ZG93bi5yaWdodEFycm93KWAuIFRvIGdldCBhcm91bmQgdGhpcyxcbi8vIHdlIGFyZSB0ZW1wb3JhcmlseSB1c2luZyBhIHNpbmdsZSAoa2V5ZG93bikgaGFuZGxlci5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvOTQxOVxudmFyIFVQX0FSUk9XID0gMzg7XG52YXIgRE9XTl9BUlJPVyA9IDQwO1xudmFyIFJJR0hUX0FSUk9XID0gMzk7XG52YXIgTEVGVF9BUlJPVyA9IDM3O1xudmFyIFBBR0VfVVAgPSAzMztcbnZhciBQQUdFX0RPV04gPSAzNDtcbnZhciBIT01FID0gMzY7XG52YXIgRU5EID0gMzU7XG52YXIgRU5URVIgPSAxMztcbnZhciBTUEFDRSA9IDMyO1xudmFyIFRBQiA9IDk7XG52YXIgRVNDQVBFID0gMjc7XG52YXIgQkFDS1NQQUNFID0gODtcbnZhciBERUxFVEUgPSA0Njtcbi8qKlxuICogQ29lcmNlcyBhIGRhdGEtYm91bmQgdmFsdWUgKHR5cGljYWxseSBhIHN0cmluZykgdG8gYSBib29sZWFuLlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgXCJcIiArIHZhbHVlICE9PSAnZmFsc2UnO1xufVxudmFyIFJpcHBsZVN0YXRlID0ge307XG5SaXBwbGVTdGF0ZS5GQURJTkdfSU4gPSAwO1xuUmlwcGxlU3RhdGUuVklTSUJMRSA9IDE7XG5SaXBwbGVTdGF0ZS5GQURJTkdfT1VUID0gMjtcblJpcHBsZVN0YXRlLkhJRERFTiA9IDM7XG5SaXBwbGVTdGF0ZVtSaXBwbGVTdGF0ZS5GQURJTkdfSU5dID0gXCJGQURJTkdfSU5cIjtcblJpcHBsZVN0YXRlW1JpcHBsZVN0YXRlLlZJU0lCTEVdID0gXCJWSVNJQkxFXCI7XG5SaXBwbGVTdGF0ZVtSaXBwbGVTdGF0ZS5GQURJTkdfT1VUXSA9IFwiRkFESU5HX09VVFwiO1xuUmlwcGxlU3RhdGVbUmlwcGxlU3RhdGUuSElEREVOXSA9IFwiSElEREVOXCI7XG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIHByZXZpb3VzbHkgbGF1bmNoZWQgcmlwcGxlIGVsZW1lbnQuXG4gKi9cbnZhciBSaXBwbGVSZWYgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29uZmlnXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmlwcGxlUmVmKF9yZW5kZXJlciwgZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIHJpcHBsZSByZWZlcmVuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gUmlwcGxlU3RhdGUuSElEREVOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGYWRlcyBvdXQgdGhlIHJpcHBsZSBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmlwcGxlUmVmLnByb3RvdHlwZS5mYWRlT3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5mYWRlT3V0UmlwcGxlKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJpcHBsZVJlZjtcbn0oKSk7XG4vKipcbiAqIEZhZGUtaW4gZHVyYXRpb24gZm9yIHRoZSByaXBwbGVzLiBDYW4gYmUgbW9kaWZpZWQgd2l0aCB0aGUgc3BlZWRGYWN0b3Igb3B0aW9uLlxuICovXG52YXIgUklQUExFX0ZBREVfSU5fRFVSQVRJT04gPSA0NTA7XG4vKipcbiAqIEZhZGUtb3V0IGR1cmF0aW9uIGZvciB0aGUgcmlwcGxlcyBpbiBtaWxsaXNlY29uZHMuIFRoaXMgY2FuJ3QgYmUgbW9kaWZpZWQgYnkgdGhlIHNwZWVkRmFjdG9yLlxuICovXG52YXIgUklQUExFX0ZBREVfT1VUX0RVUkFUSU9OID0gNDAwO1xuLyoqXG4gKiBIZWxwZXIgc2VydmljZSB0aGF0IHBlcmZvcm1zIERPTSBtYW5pcHVsYXRpb25zLiBOb3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuICogVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEgcmVmZXJlbmNlIHRvIHRoZSByaXBwbGUgZGlyZWN0aXZlJ3MgaG9zdCBlbGVtZW50IGFuZCBhIG1hcCBvZiBET01cbiAqIGV2ZW50IGhhbmRsZXJzIHRvIGJlIGluc3RhbGxlZCBvbiB0aGUgZWxlbWVudCB0aGF0IHRyaWdnZXJzIHJpcHBsZSBhbmltYXRpb25zLlxuICogVGhpcyB3aWxsIGV2ZW50dWFsbHkgYmVjb21lIGEgY3VzdG9tIHJlbmRlcmVyIG9uY2UgQW5ndWxhciBzdXBwb3J0IGV4aXN0cy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgUmlwcGxlUmVuZGVyZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IF9ydWxlclxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSaXBwbGVSZW5kZXJlcihlbGVtZW50UmVmLCBfbmdab25lLCBfcnVsZXIsIHBsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX3J1bGVyID0gX3J1bGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IGRvd24gb3Igbm90LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50cyB0byBiZSByZWdpc3RlcmVkIG9uIHRoZSB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IG9mIGN1cnJlbnRseSBhY3RpdmUgcmlwcGxlIHJlZmVyZW5jZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hY3RpdmVSaXBwbGVzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmlwcGxlIGNvbmZpZyBmb3IgYWxsIHJpcHBsZXMgY3JlYXRlZCBieSBldmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJpcHBsZUNvbmZpZyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBtb3VzZSByaXBwbGVzIHNob3VsZCBiZSBjcmVhdGVkIG9yIG5vdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmlwcGxlRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gT25seSBkbyBhbnl0aGluZyBpZiB3ZSdyZSBvbiB0aGUgYnJvd3Nlci5cbiAgICAgICAgaWYgKHBsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyRWxlbWVudCA9IGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIC8vIFNwZWNpZnkgZXZlbnRzIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBvbiB0aGUgdHJpZ2dlci5cbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMuc2V0KCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2Vkb3duLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50cy5zZXQoJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMuc2V0KCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0IHVzZSB0aGUgaG9zdCBlbGVtZW50IGFzIHRyaWdnZXIgZWxlbWVudC5cbiAgICAgICAgICAgIHRoaXMuc2V0VHJpZ2dlckVsZW1lbnQodGhpcy5fY29udGFpbmVyRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmFkZXMgaW4gYSByaXBwbGUgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7P30gcGFnZVhcbiAgICAgKiBAcGFyYW0gez99IHBhZ2VZXG4gICAgICogQHBhcmFtIHs/PX0gY29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUuZmFkZUluUmlwcGxlID0gZnVuY3Rpb24gKHBhZ2VYLCBwYWdlWSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluZXJSZWN0ID0gdGhpcy5fY29udGFpbmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5jZW50ZXJlZCkge1xuICAgICAgICAgICAgcGFnZVggPSBjb250YWluZXJSZWN0LmxlZnQgKyBjb250YWluZXJSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgIHBhZ2VZID0gY29udGFpbmVyUmVjdC50b3AgKyBjb250YWluZXJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBzY3JvbGwgdmFsdWVzIGZyb20gdGhlIGNvb3JkaW5hdGVzIGJlY2F1c2UgY2FsY3VsYXRpb25zIGJlbG93XG4gICAgICAgICAgICAvLyBhcmUgYWx3YXlzIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCByZWN0YW5nbGUuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3J1bGVyLmdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgICAgIHBhZ2VYIC09IHNjcm9sbFBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICBwYWdlWSAtPSBzY3JvbGxQb3NpdGlvbi50b3A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmFkaXVzID0gY29uZmlnLnJhZGl1cyB8fCBkaXN0YW5jZVRvRnVydGhlc3RDb3JuZXIocGFnZVgsIHBhZ2VZLCBjb250YWluZXJSZWN0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb24gPSBSSVBQTEVfRkFERV9JTl9EVVJBVElPTiAqICgxIC8gKGNvbmZpZy5zcGVlZEZhY3RvciB8fCAxKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldFggPSBwYWdlWCAtIGNvbnRhaW5lclJlY3QubGVmdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0WSA9IHBhZ2VZIC0gY29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpcHBsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICByaXBwbGUuY2xhc3NMaXN0LmFkZCgnbWF0LXJpcHBsZS1lbGVtZW50Jyk7XG4gICAgICAgIHJpcHBsZS5zdHlsZS5sZWZ0ID0gb2Zmc2V0WCAtIHJhZGl1cyArIFwicHhcIjtcbiAgICAgICAgcmlwcGxlLnN0eWxlLnRvcCA9IG9mZnNldFkgLSByYWRpdXMgKyBcInB4XCI7XG4gICAgICAgIHJpcHBsZS5zdHlsZS5oZWlnaHQgPSByYWRpdXMgKiAyICsgXCJweFwiO1xuICAgICAgICByaXBwbGUuc3R5bGUud2lkdGggPSByYWRpdXMgKiAyICsgXCJweFwiO1xuICAgICAgICAvLyBJZiB0aGUgY29sb3IgaXMgbm90IHNldCwgdGhlIGRlZmF1bHQgQ1NTIGNvbG9yIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgcmlwcGxlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbmZpZy5jb2xvcjtcbiAgICAgICAgcmlwcGxlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uICsgXCJtc1wiO1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHJpcHBsZSk7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgdGhlIGJyb3dzZXIgZG9lcyBub3QgcmVjYWxjdWxhdGUgdGhlIHN0eWxlcyBvZiBkeW5hbWljYWxseSBjcmVhdGVkXG4gICAgICAgIC8vIHJpcHBsZSBlbGVtZW50cy4gVGhpcyBpcyBjcml0aWNhbCBiZWNhdXNlIHRoZW4gdGhlIGBzY2FsZWAgd291bGQgbm90IGFuaW1hdGUgcHJvcGVybHkuXG4gICAgICAgIGVuZm9yY2VTdHlsZVJlY2FsY3VsYXRpb24ocmlwcGxlKTtcbiAgICAgICAgcmlwcGxlLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgICAgIC8vIEV4cG9zZWQgcmVmZXJlbmNlIHRvIHRoZSByaXBwbGUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaXBwbGVSZWYgPSBuZXcgUmlwcGxlUmVmKHRoaXMsIHJpcHBsZSwgY29uZmlnKTtcbiAgICAgICAgcmlwcGxlUmVmLnN0YXRlID0gUmlwcGxlU3RhdGUuRkFESU5HX0lOO1xuICAgICAgICAvLyBBZGQgdGhlIHJpcHBsZSByZWZlcmVuY2UgdG8gdGhlIGxpc3Qgb2YgYWxsIGFjdGl2ZSByaXBwbGVzLlxuICAgICAgICB0aGlzLl9hY3RpdmVSaXBwbGVzLmFkZChyaXBwbGVSZWYpO1xuICAgICAgICAvLyBXYWl0IGZvciB0aGUgcmlwcGxlIGVsZW1lbnQgdG8gYmUgY29tcGxldGVseSBmYWRlZCBpbi5cbiAgICAgICAgLy8gT25jZSBpdCdzIGZhZGVkIGluLCB0aGUgcmlwcGxlIGNhbiBiZSBoaWRkZW4gaW1tZWRpYXRlbHkgaWYgdGhlIG1vdXNlIGlzIHJlbGVhc2VkLlxuICAgICAgICB0aGlzLnJ1blRpbWVvdXRPdXRzaWRlWm9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByaXBwbGVSZWYuc3RhdGUgPSBSaXBwbGVTdGF0ZS5WSVNJQkxFO1xuICAgICAgICAgICAgaWYgKCFjb25maWcucGVyc2lzdGVudCAmJiAhX3RoaXMuX2lzTW91c2Vkb3duKSB7XG4gICAgICAgICAgICAgICAgcmlwcGxlUmVmLmZhZGVPdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICByZXR1cm4gcmlwcGxlUmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmFkZXMgb3V0IGEgcmlwcGxlIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0gez99IHJpcHBsZVJlZlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLmZhZGVPdXRSaXBwbGUgPSBmdW5jdGlvbiAocmlwcGxlUmVmKSB7XG4gICAgICAgIC8vIEZvciByaXBwbGVzIHRoYXQgYXJlIG5vdCBhY3RpdmUgYW55bW9yZSwgZG9uJ3QgcmUtdW4gdGhlIGZhZGUtb3V0IGFuaW1hdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmVSaXBwbGVzLmRlbGV0ZShyaXBwbGVSZWYpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlwcGxlRWwgPSByaXBwbGVSZWYuZWxlbWVudDtcbiAgICAgICAgcmlwcGxlRWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gUklQUExFX0ZBREVfT1VUX0RVUkFUSU9OICsgXCJtc1wiO1xuICAgICAgICByaXBwbGVFbC5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICByaXBwbGVSZWYuc3RhdGUgPSBSaXBwbGVTdGF0ZS5GQURJTkdfT1VUO1xuICAgICAgICAvLyBPbmNlIHRoZSByaXBwbGUgZmFkZWQgb3V0LCB0aGUgcmlwcGxlIGNhbiBiZSBzYWZlbHkgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAgICAgIHRoaXMucnVuVGltZW91dE91dHNpZGVab25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJpcHBsZVJlZi5zdGF0ZSA9IFJpcHBsZVN0YXRlLkhJRERFTjtcbiAgICAgICAgICAgIHJpcHBsZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmlwcGxlRWwpO1xuICAgICAgICB9LCBSSVBQTEVfRkFERV9PVVRfRFVSQVRJT04pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmFkZXMgb3V0IGFsbCBjdXJyZW50bHkgYWN0aXZlIHJpcHBsZXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUuZmFkZU91dEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmlwcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChyaXBwbGUpIHsgcmV0dXJuIHJpcHBsZS5mYWRlT3V0KCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdHJpZ2dlciBlbGVtZW50IGFuZCByZWdpc3RlcnMgdGhlIG1vdXNlIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJpcHBsZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRUcmlnZ2VyRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgcHJldmlvdXNseSByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgdHJpZ2dlciBlbGVtZW50LlxuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZm4sIHR5cGUpIHsgcmV0dXJuIF90aGlzLl90cmlnZ2VyRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBudWxsLCByZWdpc3RlciBhbGwgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGZuLCB0eXBlKSB7IHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyaWdnZXJFbGVtZW50ID0gZWxlbWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIGJlaW5nIGNhbGxlZCBvbiBtb3VzZWRvd24gZXZlbnQuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLm9uTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5yaXBwbGVEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNNb3VzZWRvd24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5mYWRlSW5SaXBwbGUoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZLCB0aGlzLnJpcHBsZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIGJlaW5nIGNhbGxlZCBvbiBtb3VzZXVwIGV2ZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLm9uTW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgLy8gRmFkZS1vdXQgYWxsIHJpcHBsZXMgdGhhdCBhcmUgY29tcGxldGVseSB2aXNpYmxlIGFuZCBub3QgcGVyc2lzdGVudC5cbiAgICAgICAgdGhpcy5fYWN0aXZlUmlwcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChyaXBwbGUpIHtcbiAgICAgICAgICAgIGlmICghcmlwcGxlLmNvbmZpZy5wZXJzaXN0ZW50ICYmIHJpcHBsZS5zdGF0ZSA9PT0gUmlwcGxlU3RhdGUuVklTSUJMRSkge1xuICAgICAgICAgICAgICAgIHJpcHBsZS5mYWRlT3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdGVuZXIgYmVpbmcgY2FsbGVkIG9uIG1vdXNlbGVhdmUgZXZlbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXNNb3VzZWRvd24pIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZXVwKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJ1bnMgYSB0aW1lb3V0IG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZSB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcGFyYW0gez89fSBkZWxheVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLnJ1blRpbWVvdXRPdXRzaWRlWm9uZSA9IGZ1bmN0aW9uIChmbiwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRUaW1lb3V0KGZuLCBkZWxheSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJpcHBsZVJlbmRlcmVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBlbmZvcmNlU3R5bGVSZWNhbGN1bGF0aW9uKGVsZW1lbnQpIHtcbiAgICAvLyBFbmZvcmNlIGEgc3R5bGUgcmVjYWxjdWxhdGlvbiBieSBjYWxsaW5nIGBnZXRDb21wdXRlZFN0eWxlYCBhbmQgYWNjZXNzaW5nIGFueSBwcm9wZXJ0eS5cbiAgICAvLyBDYWxsaW5nIGBnZXRQcm9wZXJ0eVZhbHVlYCBpcyBpbXBvcnRhbnQgdG8gbGV0IG9wdGltaXplcnMga25vdyB0aGF0IHRoaXMgaXMgbm90IGEgbm9vcC5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81ZDUyZmIwODFiMzU3MGM4MWUzYVxuICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ29wYWNpdHknKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgKHgsIHkpIHRvIHRoZSBmdXJ0aGVzdCBjb3JuZXIgb2YgYSByZWN0YW5nbGUuXG4gKiBAcGFyYW0gez99IHhcbiAqIEBwYXJhbSB7P30geVxuICogQHBhcmFtIHs/fSByZWN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkaXN0YW5jZVRvRnVydGhlc3RDb3JuZXIoeCwgeSwgcmVjdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpc3RYID0gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHJlY3QubGVmdCksIE1hdGguYWJzKHggLSByZWN0LnJpZ2h0KSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlzdFkgPSBNYXRoLm1heChNYXRoLmFicyh5IC0gcmVjdC50b3ApLCBNYXRoLmFicyh5IC0gcmVjdC5ib3R0b20pKTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGRpc3RYICogZGlzdFggKyBkaXN0WSAqIGRpc3RZKTtcbn1cbi8vIFdoZXRoZXIgdGhlIGN1cnJlbnQgcGxhdGZvcm0gc3VwcG9ydHMgdGhlIFY4IEJyZWFrIEl0ZXJhdG9yLiBUaGUgVjggY2hlY2tcbi8vIGlzIG5lY2Vzc2FyeSB0byBkZXRlY3QgYWxsIEJsaW5rIGJhc2VkIGJyb3dzZXJzLlxudmFyIGhhc1Y4QnJlYWtJdGVyYXRvciA9ICh0eXBlb2YgKEludGwpICE9PSAndW5kZWZpbmVkJyAmJiAoKEludGwpKS52OEJyZWFrSXRlcmF0b3IpO1xuLyoqXG4gKiBTZXJ2aWNlIHRvIGRldGVjdCB0aGUgY3VycmVudCBwbGF0Zm9ybSBieSBjb21wYXJpbmcgdGhlIHVzZXJBZ2VudCBzdHJpbmdzIGFuZFxuICogY2hlY2tpbmcgYnJvd3Nlci1zcGVjaWZpYyBnbG9iYWwgcHJvcGVydGllcy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgUGxhdGZvcm0gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybSgpIHtcbiAgICAgICAgdGhpcy5pc0Jyb3dzZXIgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnICYmICEhZG9jdW1lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMYXlvdXQgRW5naW5lc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5FREdFID0gdGhpcy5pc0Jyb3dzZXIgJiYgLyhlZGdlKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIHRoaXMuVFJJREVOVCA9IHRoaXMuaXNCcm93c2VyICYmIC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIC8vIEVkZ2VIVE1MIGFuZCBUcmlkZW50IG1vY2sgQmxpbmsgc3BlY2lmaWMgdGhpbmdzIGFuZCBuZWVkIHRvIGJlIGV4Y2x1ZGVkIGZyb20gdGhpcyBjaGVjay5cbiAgICAgICAgdGhpcy5CTElOSyA9IHRoaXMuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAoISEoKCh3aW5kb3cpKS5jaHJvbWUgfHwgaGFzVjhCcmVha0l0ZXJhdG9yKSAmJiAhIUNTUyAmJiAhdGhpcy5FREdFICYmICF0aGlzLlRSSURFTlQpO1xuICAgICAgICAvLyBXZWJraXQgaXMgcGFydCBvZiB0aGUgdXNlckFnZW50IGluIEVkZ2VIVE1MLCBCbGluayBhbmQgVHJpZGVudC4gVGhlcmVmb3JlIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgV2Via2l0IHJ1bnMgc3RhbmRhbG9uZSBhbmQgaXMgbm90IHVzZWQgYXMgYW5vdGhlciBlbmdpbmUncyBiYXNlLlxuICAgICAgICB0aGlzLldFQktJVCA9IHRoaXMuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAvQXBwbGVXZWJLaXQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF0aGlzLkJMSU5LICYmICF0aGlzLkVER0UgJiYgIXRoaXMuVFJJREVOVDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb3dzZXJzIGFuZCBQbGF0Zm9ybSBUeXBlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5JT1MgPSB0aGlzLmlzQnJvd3NlciAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuICAgICAgICAvLyBJdCdzIGRpZmZpY3VsdCB0byBkZXRlY3QgdGhlIHBsYWluIEdlY2tvIGVuZ2luZSwgYmVjYXVzZSBtb3N0IG9mIHRoZSBicm93c2VycyBpZGVudGlmeVxuICAgICAgICAvLyB0aGVtIHNlbGYgYXMgR2Vja28tbGlrZSBicm93c2VycyBhbmQgbW9kaWZ5IHRoZSB1c2VyQWdlbnQncyBhY2NvcmRpbmcgdG8gdGhhdC5cbiAgICAgICAgLy8gU2luY2Ugd2Ugb25seSBjb3ZlciBvbmUgZXhwbGljaXQgRmlyZWZveCBjYXNlLCB3ZSBjYW4gc2ltcGx5IGNoZWNrIGZvciBGaXJlZm94XG4gICAgICAgIC8vIGluc3RlYWQgb2YgaGF2aW5nIGFuIHVuc3RhYmxlIGNoZWNrIGZvciBHZWNrby5cbiAgICAgICAgdGhpcy5GSVJFRk9YID0gdGhpcy5pc0Jyb3dzZXIgJiYgLyhmaXJlZm94fG1pbmVmaWVsZCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAvLyBUcmlkZW50IG9uIG1vYmlsZSBhZGRzIHRoZSBhbmRyb2lkIHBsYXRmb3JtIHRvIHRoZSB1c2VyQWdlbnQgdG8gdHJpY2sgZGV0ZWN0aW9ucy5cbiAgICAgICAgdGhpcy5BTkRST0lEID0gdGhpcy5pc0Jyb3dzZXIgJiYgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF0aGlzLlRSSURFTlQ7XG4gICAgfVxuICAgIHJldHVybiBQbGF0Zm9ybTtcbn0oKSk7XG5QbGF0Zm9ybS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuUGxhdGZvcm0uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xuLyoqXG4gKiBAcmV0dXJuIHs/fSBUaGUgaW5wdXQgdHlwZXMgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci5cbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcygpIHtcbiAgICBpZiAoIXN1cHBvcnRlZElucHV0VHlwZXMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmVhdHVyZVRlc3RJbnB1dF8xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgLy8gYGNvbG9yYCBtdXN0IGNvbWUgZmlyc3QuIENocm9tZSA1NiBzaG93cyBhIHdhcm5pbmcgaWYgd2UgY2hhbmdlIHRoZSB0eXBlIHRvIGBjb2xvcmAgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGZpcnN0IGNoYW5naW5nIGl0IHRvIHNvbWV0aGluZyBlbHNlOlxuICAgICAgICAgICAgLy8gVGhlIHNwZWNpZmllZCB2YWx1ZSBcIlwiIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIHJlcXVpcmVkIGZvcm1hdC5cbiAgICAgICAgICAgIC8vIFRoZSBmb3JtYXQgaXMgXCIjcnJnZ2JiXCIgd2hlcmUgcnIsIGdnLCBiYiBhcmUgdHdvLWRpZ2l0IGhleGFkZWNpbWFsIG51bWJlcnMuXG4gICAgICAgICAgICAnY29sb3InLFxuICAgICAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICAgICAnY2hlY2tib3gnLFxuICAgICAgICAgICAgJ2RhdGUnLFxuICAgICAgICAgICAgJ2RhdGV0aW1lLWxvY2FsJyxcbiAgICAgICAgICAgICdlbWFpbCcsXG4gICAgICAgICAgICAnZmlsZScsXG4gICAgICAgICAgICAnaGlkZGVuJyxcbiAgICAgICAgICAgICdpbWFnZScsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAncGFzc3dvcmQnLFxuICAgICAgICAgICAgJ3JhZGlvJyxcbiAgICAgICAgICAgICdyYW5nZScsXG4gICAgICAgICAgICAncmVzZXQnLFxuICAgICAgICAgICAgJ3NlYXJjaCcsXG4gICAgICAgICAgICAnc3VibWl0JyxcbiAgICAgICAgICAgICd0ZWwnLFxuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgJ3RpbWUnLFxuICAgICAgICAgICAgJ3VybCcsXG4gICAgICAgICAgICAnd2VlaycsXG4gICAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZmVhdHVyZVRlc3RJbnB1dF8xLnNldEF0dHJpYnV0ZSgndHlwZScsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBmZWF0dXJlVGVzdElucHV0XzEudHlwZSA9PT0gdmFsdWU7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZElucHV0VHlwZXM7XG59XG52YXIgUGxhdGZvcm1Nb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFBsYXRmb3JtTW9kdWxlO1xufSgpKTtcblBsYXRmb3JtTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtQbGF0Zm9ybV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuUGxhdGZvcm1Nb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogVGltZSBpbiBtcyB0byB0aHJvdHRsZSB0aGUgc2Nyb2xsaW5nIGV2ZW50cyBieSBkZWZhdWx0LlxuICovXG52YXIgREVGQVVMVF9TQ1JPTExfVElNRSA9IDIwO1xuLyoqXG4gKiBTZXJ2aWNlIGNvbnRhaW5lZCBhbGwgcmVnaXN0ZXJlZCBTY3JvbGxhYmxlIHJlZmVyZW5jZXMgYW5kIGVtaXRzIGFuIGV2ZW50IHdoZW4gYW55IG9uZSBvZiB0aGVcbiAqIFNjcm9sbGFibGUgcmVmZXJlbmNlcyBlbWl0IGEgc2Nyb2xsZWQgZXZlbnQuXG4gKi9cbnZhciBTY3JvbGxEaXNwYXRjaGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBfcGxhdGZvcm1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTY3JvbGxEaXNwYXRjaGVyKF9uZ1pvbmUsIF9wbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IF9wbGF0Zm9ybTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGF0IGEgcmVnaXN0ZXJlZCBzY3JvbGxhYmxlIHJlZmVyZW5jZSBlbGVtZW50IGhhcyBiZWVuIHNjcm9sbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2Nyb2xsZWQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGdsb2JhbCBgc2Nyb2xsYCBhbmQgYHJlc2l6ZWAgc3Vic2NyaXB0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dsb2JhbFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgYW1vdW50IG9mIHN1YnNjcmlwdGlvbnMgdG8gYHNjcm9sbGVkYC4gVXNlZCBmb3IgY2xlYW5pbmcgdXAgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Njcm9sbGVkQ291bnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIG9mIGFsbCB0aGUgc2Nyb2xsYWJsZSByZWZlcmVuY2VzIHRoYXQgYXJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgc2VydmljZSBhbmQgdGhlaXJcbiAgICAgICAgICogc2Nyb2xsIGV2ZW50IHN1YnNjcmlwdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbGFibGVSZWZlcmVuY2VzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBTY3JvbGxhYmxlIHdpdGggdGhlIHNlcnZpY2UgYW5kIGxpc3RlbnMgZm9yIGl0cyBzY3JvbGxlZCBldmVudHMuIFdoZW4gdGhlXG4gICAgICogc2Nyb2xsYWJsZSBpcyBzY3JvbGxlZCwgdGhlIHNlcnZpY2UgZW1pdHMgdGhlIGV2ZW50IGluIGl0cyBzY3JvbGxlZCBvYnNlcnZhYmxlLlxuICAgICAqIEBwYXJhbSB7P30gc2Nyb2xsYWJsZSBTY3JvbGxhYmxlIGluc3RhbmNlIHRvIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChzY3JvbGxhYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcm9sbFN1YnNjcmlwdGlvbiA9IHNjcm9sbGFibGUuZWxlbWVudFNjcm9sbGVkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9ub3RpZnkoKTsgfSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuc2V0KHNjcm9sbGFibGUsIHNjcm9sbFN1YnNjcmlwdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXJlZ2lzdGVycyBhIFNjcm9sbGFibGUgcmVmZXJlbmNlIGFuZCB1bnN1YnNjcmliZXMgZnJvbSBpdHMgc2Nyb2xsIGV2ZW50IG9ic2VydmFibGUuXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxhYmxlIFNjcm9sbGFibGUgaW5zdGFuY2UgdG8gYmUgZGVyZWdpc3RlcmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2Nyb2xsRGlzcGF0Y2hlci5wcm90b3R5cGUuZGVyZWdpc3RlciA9IGZ1bmN0aW9uIChzY3JvbGxhYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGFibGVSZWZlcmVuY2VzLmhhcyhzY3JvbGxhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxhYmxlUmVmZXJlbmNlcy5nZXQoc2Nyb2xsYWJsZSkudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuZGVsZXRlKHNjcm9sbGFibGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBldmVudCB3aGVuZXZlciBhbnkgb2YgdGhlIHJlZ2lzdGVyZWQgU2Nyb2xsYWJsZVxuICAgICAqIHJlZmVyZW5jZXMgKG9yIHdpbmRvdywgZG9jdW1lbnQsIG9yIGJvZHkpIGZpcmUgYSBzY3JvbGxlZCBldmVudC4gQ2FuIHByb3ZpZGUgYSB0aW1lIGluIG1zXG4gICAgICogdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgXCJ0aHJvdHRsZVwiIHRpbWUuXG4gICAgICogQHBhcmFtIHs/PX0gYXVkaXRUaW1lSW5Nc1xuICAgICAqIEBwYXJhbSB7Pz19IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5zY3JvbGxlZCA9IGZ1bmN0aW9uIChhdWRpdFRpbWVJbk1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXVkaXRUaW1lSW5NcyA9PT0gdm9pZCAwKSB7IGF1ZGl0VGltZUluTXMgPSBERUZBVUxUX1NDUk9MTF9USU1FOyB9XG4gICAgICAgIC8vIFNjcm9sbCBldmVudHMgY2FuIG9ubHkgaGFwcGVuIG9uIHRoZSBicm93c2VyLCBzbyBkbyBub3RoaW5nIGlmIHdlJ3JlIG5vdCBvbiB0aGUgYnJvd3Nlci5cbiAgICAgICAgaWYgKCF0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSAwbXMgZGVsYXksIHVzZSBhbiBvYnNlcnZhYmxlIHdpdGhvdXQgYXVkaXRUaW1lXG4gICAgICAgIC8vIHNpbmNlIGl0IGRvZXMgYWRkIGEgcGVyY2VwdGlibGUgZGVsYXkgaW4gcHJvY2Vzc2luZyBvdmVyaGVhZC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2JzZXJ2YWJsZSA9IGF1ZGl0VGltZUluTXMgPiAwID9cbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGVkLmFzT2JzZXJ2YWJsZSgpLmF1ZGl0VGltZShhdWRpdFRpbWVJbk1zKSA6XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxlZC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsZWRDb3VudCsrO1xuICAgICAgICBpZiAoIXRoaXMuX2dsb2JhbFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uID0gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5tZXJnZShPYnNlcnZhYmxlLmZyb21FdmVudCh3aW5kb3cuZG9jdW1lbnQsICdzY3JvbGwnKSwgT2JzZXJ2YWJsZS5mcm9tRXZlbnQod2luZG93LCAncmVzaXplJykpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbm90aWZ5KCk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIG5lZWQgdG8gZG8gdGhlIHN1YnNjcmliaW5nIGZyb20gaGVyZSwgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byByZW1vdmVcbiAgICAgICAgLy8gdGhlIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMgb25jZSB0aGVyZSBhcmUgbm8gbW9yZSBzdWJzY3JpcHRpb25zLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3Njcm9sbGVkQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uICYmICFfdGhpcy5zY3JvbGxhYmxlUmVmZXJlbmNlcy5zaXplICYmICFfdGhpcy5fc2Nyb2xsZWRDb3VudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9nbG9iYWxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIFNjcm9sbGFibGVzIHRoYXQgY29udGFpbiB0aGUgcHJvdmlkZWQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNjcm9sbERpc3BhdGNoZXIucHJvdG90eXBlLmdldFNjcm9sbENvbnRhaW5lcnMgPSBmdW5jdGlvbiAoZWxlbWVudFJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY3JvbGxpbmdDb250YWluZXJzID0gW107XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaXB0aW9uLCBzY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2Nyb2xsYWJsZUNvbnRhaW5zRWxlbWVudChzY3JvbGxhYmxlLCBlbGVtZW50UmVmKSkge1xuICAgICAgICAgICAgICAgIHNjcm9sbGluZ0NvbnRhaW5lcnMucHVzaChzY3JvbGxhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzY3JvbGxpbmdDb250YWluZXJzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHByb3ZpZGVkIFNjcm9sbGFibGUuXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxhYmxlXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5zY3JvbGxhYmxlQ29udGFpbnNFbGVtZW50ID0gZnVuY3Rpb24gKHNjcm9sbGFibGUsIGVsZW1lbnRSZWYpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2Nyb2xsYWJsZUVsZW1lbnQgPSBzY3JvbGxhYmxlLmdldEVsZW1lbnRSZWYoKS5uYXRpdmVFbGVtZW50O1xuICAgICAgICAvLyBUcmF2ZXJzZSB0aHJvdWdoIHRoZSBlbGVtZW50IHBhcmVudHMgdW50aWwgd2UgcmVhY2ggbnVsbCwgY2hlY2tpbmcgaWYgYW55IG9mIHRoZSBlbGVtZW50c1xuICAgICAgICAvLyBhcmUgdGhlIHNjcm9sbGFibGUncyBlbGVtZW50LlxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PSBzY3JvbGxhYmxlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbm90aWZpY2F0aW9uIHRoYXQgYSBzY3JvbGwgZXZlbnQgaGFzIGJlZW4gZmlyZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5fbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxlZC5uZXh0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsRGlzcGF0Y2hlcjtcbn0oKSk7XG5TY3JvbGxEaXNwYXRjaGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5TY3JvbGxEaXNwYXRjaGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogUGxhdGZvcm0sIH0sXG5dOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHBhcmVudERpc3BhdGNoZXJcbiAqIEBwYXJhbSB7P30gbmdab25lXG4gKiBAcGFyYW0gez99IHBsYXRmb3JtXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudERpc3BhdGNoZXIsIG5nWm9uZSwgcGxhdGZvcm0pIHtcbiAgICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgU2Nyb2xsRGlzcGF0Y2hlcihuZ1pvbmUsIHBsYXRmb3JtKTtcbn1cbnZhciBTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgU2Nyb2xsRGlzcGF0Y2hlciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IFNjcm9sbERpc3BhdGNoZXIsXG4gICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIFNjcm9sbERpc3BhdGNoZXJdLCBOZ1pvbmUsIFBsYXRmb3JtXSxcbiAgICB1c2VGYWN0b3J5OiBTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUl9GQUNUT1JZXG59O1xuLyoqXG4gKiBTaW1wbGUgdXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgYm91bmRzIG9mIHRoZSBicm93c2VyIHZpZXdwb3J0LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBWaWV3cG9ydFJ1bGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxEaXNwYXRjaGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld3BvcnRSdWxlcihzY3JvbGxEaXNwYXRjaGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgcmVjdGFuZ2xlIG9uIGNoYW5nZXMuXG4gICAgICAgIHNjcm9sbERpc3BhdGNoZXIuc2Nyb2xsZWQobnVsbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NhY2hlVmlld3BvcnRHZW9tZXRyeSgpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIENsaWVudFJlY3QgZm9yIHRoZSB2aWV3cG9ydCdzIGJvdW5kcy5cbiAgICAgKiBAcGFyYW0gez89fSBkb2N1bWVudFJlY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdwb3J0UnVsZXIucHJvdG90eXBlLmdldFZpZXdwb3J0UmVjdCA9IGZ1bmN0aW9uIChkb2N1bWVudFJlY3QpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50UmVjdCA9PT0gdm9pZCAwKSB7IGRvY3VtZW50UmVjdCA9IHRoaXMuX2RvY3VtZW50UmVjdDsgfVxuICAgICAgICAvLyBDYWNoZSB0aGUgZG9jdW1lbnQgYm91bmRpbmcgcmVjdCBzbyB0aGF0IHdlIGRvbid0IHJlY29tcHV0ZSBpdCBmb3IgbXVsdGlwbGUgY2FsbHMuXG4gICAgICAgIGlmICghZG9jdW1lbnRSZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVZpZXdwb3J0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIGRvY3VtZW50UmVjdCA9IHRoaXMuX2RvY3VtZW50UmVjdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgdGhlIGRvY3VtZW50IGVsZW1lbnQncyBib3VuZGluZyByZWN0IHJhdGhlciB0aGFuIHRoZSB3aW5kb3cgc2Nyb2xsIHByb3BlcnRpZXNcbiAgICAgICAgLy8gKGUuZy4gcGFnZVlPZmZzZXQsIHNjcm9sbFkpIGR1ZSB0byBpbiBpc3N1ZSBpbiBDaHJvbWUgYW5kIElFIHdoZXJlIHdpbmRvdyBzY3JvbGxcbiAgICAgICAgLy8gcHJvcGVydGllcyBhbmQgY2xpZW50IGNvb3JkaW5hdGVzIChib3VuZGluZ0NsaWVudFJlY3QsIGNsaWVudFgvWSwgZXRjLikgYXJlIGluIGRpZmZlcmVudFxuICAgICAgICAvLyBjb25jZXB0dWFsIHZpZXdwb3J0cy4gVW5kZXIgbW9zdCBjaXJjdW1zdGFuY2VzIHRoZXNlIHZpZXdwb3J0cyBhcmUgZXF1aXZhbGVudCwgYnV0IHRoZXlcbiAgICAgICAgLy8gY2FuIGRpc2FncmVlIHdoZW4gdGhlIHBhZ2UgaXMgcGluY2gtem9vbWVkIChvbiBkZXZpY2VzIHRoYXQgc3VwcG9ydCB0b3VjaCkuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00ODkyMDYjYzRcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBkb2N1bWVudEVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgYm9keSBiZWNhdXNlLCBieSBkZWZhdWx0ICh3aXRob3V0IGEgY3NzIHJlc2V0KVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZ2l2ZSB0aGUgZG9jdW1lbnQgYm9keSBhbiA4cHggbWFyZ2luLCB3aGljaCBpcyBub3QgaW5jbHVkZWQgaW5cbiAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcm9sbFBvc2l0aW9uID0gdGhpcy5nZXRWaWV3cG9ydFNjcm9sbFBvc2l0aW9uKGRvY3VtZW50UmVjdCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogc2Nyb2xsUG9zaXRpb24udG9wLFxuICAgICAgICAgICAgbGVmdDogc2Nyb2xsUG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIGJvdHRvbTogc2Nyb2xsUG9zaXRpb24udG9wICsgaGVpZ2h0LFxuICAgICAgICAgICAgcmlnaHQ6IHNjcm9sbFBvc2l0aW9uLmxlZnQgKyB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgKHRvcCwgbGVmdCkgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gez89fSBkb2N1bWVudFJlY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdwb3J0UnVsZXIucHJvdG90eXBlLmdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24gPSBmdW5jdGlvbiAoZG9jdW1lbnRSZWN0KSB7XG4gICAgICAgIGlmIChkb2N1bWVudFJlY3QgPT09IHZvaWQgMCkgeyBkb2N1bWVudFJlY3QgPSB0aGlzLl9kb2N1bWVudFJlY3Q7IH1cbiAgICAgICAgLy8gQ2FjaGUgdGhlIGRvY3VtZW50IGJvdW5kaW5nIHJlY3Qgc28gdGhhdCB3ZSBkb24ndCByZWNvbXB1dGUgaXQgZm9yIG11bHRpcGxlIGNhbGxzLlxuICAgICAgICBpZiAoIWRvY3VtZW50UmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVWaWV3cG9ydEdlb21ldHJ5KCk7XG4gICAgICAgICAgICBkb2N1bWVudFJlY3QgPSB0aGlzLl9kb2N1bWVudFJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHRvcC1sZWZ0LWNvcm5lciBvZiB0aGUgdmlld3BvcnQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICAvLyBib2R5LCBub3JtYWxseSBqdXN0IChzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApLiBIb3dldmVyLCBDaHJvbWUgYW5kIEZpcmVmb3ggZGlzYWdyZWUgYWJvdXRcbiAgICAgICAgLy8gd2hldGhlciBgZG9jdW1lbnQuYm9keWAgb3IgYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudGAgaXMgdGhlIHNjcm9sbGVkIGVsZW1lbnQsIHNvIHJlYWRpbmdcbiAgICAgICAgLy8gYHNjcm9sbFRvcGAgYW5kIGBzY3JvbGxMZWZ0YCBpcyBpbmNvbnNpc3RlbnQuIEhvd2V2ZXIsIHVzaW5nIHRoZSBib3VuZGluZyByZWN0IG9mXG4gICAgICAgIC8vIGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRgIHdvcmtzIGNvbnNpc3RlbnRseSwgd2hlcmUgdGhlIGB0b3BgIGFuZCBgbGVmdGAgdmFsdWVzIHdpbGxcbiAgICAgICAgLy8gZXF1YWwgbmVnYXRpdmUgdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9wID0gLWRvY3VtZW50UmVjdC50b3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgd2luZG93LnNjcm9sbFkgfHxcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVmdCA9IC1kb2N1bWVudFJlY3QubGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgd2luZG93LnNjcm9sbFggfHxcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWNoZXMgdGhlIGxhdGVzdCBjbGllbnQgcmVjdGFuZ2xlIG9mIHRoZSBkb2N1bWVudCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld3BvcnRSdWxlci5wcm90b3R5cGUuX2NhY2hlVmlld3BvcnRHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWN0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXdwb3J0UnVsZXI7XG59KCkpO1xuVmlld3BvcnRSdWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuVmlld3BvcnRSdWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFNjcm9sbERpc3BhdGNoZXIsIH0sXG5dOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHBhcmVudFJ1bGVyXG4gKiBAcGFyYW0gez99IHNjcm9sbERpc3BhdGNoZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIFZJRVdQT1JUX1JVTEVSX1BST1ZJREVSX0ZBQ1RPUlkocGFyZW50UnVsZXIsIHNjcm9sbERpc3BhdGNoZXIpIHtcbiAgICByZXR1cm4gcGFyZW50UnVsZXIgfHwgbmV3IFZpZXdwb3J0UnVsZXIoc2Nyb2xsRGlzcGF0Y2hlcik7XG59XG52YXIgVklFV1BPUlRfUlVMRVJfUFJPVklERVIgPSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIFZpZXdwb3J0UnVsZXIgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBWaWV3cG9ydFJ1bGVyLFxuICAgIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBWaWV3cG9ydFJ1bGVyXSwgU2Nyb2xsRGlzcGF0Y2hlcl0sXG4gICAgdXNlRmFjdG9yeTogVklFV1BPUlRfUlVMRVJfUFJPVklERVJfRkFDVE9SWVxufTtcbi8qKlxuICogSW5qZWN0aW9uIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZ2xvYmFsIHJpcHBsZSBvcHRpb25zLlxuICovXG52YXIgTURfUklQUExFX0dMT0JBTF9PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuKCdtZC1yaXBwbGUtZ2xvYmFsLW9wdGlvbnMnKTtcbnZhciBNZFJpcHBsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBydWxlclxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1cbiAgICAgKiBAcGFyYW0gez99IGdsb2JhbE9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFJpcHBsZShlbGVtZW50UmVmLCBuZ1pvbmUsIHJ1bGVyLCBwbGF0Zm9ybSwgZ2xvYmFsT3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0LCB0aGUgcmFkaXVzIGluIHBpeGVscyBvZiBmb3JlZ3JvdW5kIHJpcHBsZXMgd2hlbiBmdWxseSBleHBhbmRlZC4gSWYgdW5zZXQsIHRoZSByYWRpdXNcbiAgICAgICAgICogd2lsbCBiZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSByaXBwbGUgdG8gdGhlIGZ1cnRoZXN0IGNvcm5lciBvZiB0aGUgaG9zdCBlbGVtZW50J3NcbiAgICAgICAgICogYm91bmRpbmcgcmVjdGFuZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0LCB0aGUgbm9ybWFsIGR1cmF0aW9uIG9mIHJpcHBsZSBhbmltYXRpb25zIGlzIGRpdmlkZWQgYnkgdGhpcyB2YWx1ZS4gRm9yIGV4YW1wbGUsXG4gICAgICAgICAqIHNldHRpbmcgaXQgdG8gMC41IHdpbGwgY2F1c2UgdGhlIGFuaW1hdGlvbnMgdG8gdGFrZSB0d2ljZSBhcyBsb25nLlxuICAgICAgICAgKiBBIGNoYW5nZWQgc3BlZWRGYWN0b3Igd2lsbCBub3QgbW9kaWZ5IHRoZSBmYWRlLW91dCBkdXJhdGlvbiBvZiB0aGUgcmlwcGxlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3BlZWRGYWN0b3IgPSAxO1xuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlciA9IG5ldyBSaXBwbGVSZW5kZXJlcihlbGVtZW50UmVmLCBuZ1pvbmUsIHJ1bGVyLCBwbGF0Zm9ybSk7XG4gICAgICAgIHRoaXMuX2dsb2JhbE9wdGlvbnMgPSBnbG9iYWxPcHRpb25zID8gZ2xvYmFsT3B0aW9ucyA6IHt9O1xuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGVSZW5kZXJlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmlwcGxlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzWyd0cmlnZ2VyJ10gJiYgdGhpcy50cmlnZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5zZXRUcmlnZ2VyRWxlbWVudCh0aGlzLnRyaWdnZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZVJlbmRlcmVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmlwcGxlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU2V0IHRoZSB0cmlnZ2VyIGVsZW1lbnQgdG8gbnVsbCB0byBjbGVhbnVwIGFsbCBsaXN0ZW5lcnMuXG4gICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLnNldFRyaWdnZXJFbGVtZW50KG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGF1bmNoZXMgYSBtYW51YWwgcmlwcGxlIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHs/fSBwYWdlWFxuICAgICAqIEBwYXJhbSB7P30gcGFnZVlcbiAgICAgKiBAcGFyYW0gez89fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmlwcGxlLnByb3RvdHlwZS5sYXVuY2ggPSBmdW5jdGlvbiAocGFnZVgsIHBhZ2VZLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHRoaXMucmlwcGxlQ29uZmlnOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yaXBwbGVSZW5kZXJlci5mYWRlSW5SaXBwbGUocGFnZVgsIHBhZ2VZLCBjb25maWcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmFkZXMgb3V0IGFsbCBjdXJyZW50bHkgc2hvd2luZyByaXBwbGUgZWxlbWVudHMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJpcHBsZS5wcm90b3R5cGUuZmFkZU91dEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIuZmFkZU91dEFsbCgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmlwcGxlLnByb3RvdHlwZSwgXCJyaXBwbGVDb25maWdcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmlwcGxlIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZGlyZWN0aXZlJ3MgaW5wdXQgdmFsdWVzLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNlbnRlcmVkOiB0aGlzLmNlbnRlcmVkLFxuICAgICAgICAgICAgICAgIHNwZWVkRmFjdG9yOiB0aGlzLnNwZWVkRmFjdG9yICogKHRoaXMuX2dsb2JhbE9wdGlvbnMuYmFzZVNwZWVkRmFjdG9yIHx8IDEpLFxuICAgICAgICAgICAgICAgIHJhZGl1czogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3JcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJpcHBsZSByZW5kZXJlciB3aXRoIHRoZSBsYXRlc3QgcmlwcGxlIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJpcHBsZS5wcm90b3R5cGUuX3VwZGF0ZVJpcHBsZVJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5yaXBwbGVEaXNhYmxlZCA9IHRoaXMuX2dsb2JhbE9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIucmlwcGxlQ29uZmlnID0gdGhpcy5yaXBwbGVDb25maWc7XG4gICAgfTtcbiAgICByZXR1cm4gTWRSaXBwbGU7XG59KCkpO1xuTWRSaXBwbGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1yaXBwbGVdLCBbbWF0LXJpcHBsZV0sIFttZFJpcHBsZV0sIFttYXRSaXBwbGVdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21kUmlwcGxlJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtcmlwcGxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcmlwcGxlLXVuYm91bmRlZF0nOiAndW5ib3VuZGVkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRSaXBwbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogVmlld3BvcnRSdWxlciwgfSxcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01EX1JJUFBMRV9HTE9CQUxfT1BUSU9OUyxdIH0sXSB9LFxuXTsgfTtcbk1kUmlwcGxlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICd0cmlnZ2VyJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWRSaXBwbGVUcmlnZ2VyJyxdIH0sXSxcbiAgICAnY2VudGVyZWQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFJpcHBsZUNlbnRlcmVkJyxdIH0sXSxcbiAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFJpcHBsZURpc2FibGVkJyxdIH0sXSxcbiAgICAncmFkaXVzJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWRSaXBwbGVSYWRpdXMnLF0gfSxdLFxuICAgICdzcGVlZEZhY3Rvcic6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kUmlwcGxlU3BlZWRGYWN0b3InLF0gfSxdLFxuICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kUmlwcGxlQ29sb3InLF0gfSxdLFxuICAgICd1bmJvdW5kZWQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFJpcHBsZVVuYm91bmRlZCcsXSB9LF0sXG59O1xuLyoqXG4gKiBTZW5kcyBhbiBldmVudCB3aGVuIHRoZSBkaXJlY3RpdmUncyBlbGVtZW50IGlzIHNjcm9sbGVkLiBSZWdpc3RlcnMgaXRzZWxmIHdpdGggdGhlXG4gKiBTY3JvbGxEaXNwYXRjaGVyIHNlcnZpY2UgdG8gaW5jbHVkZSBpdHNlbGYgYXMgcGFydCBvZiBpdHMgY29sbGVjdGlvbiBvZiBzY3JvbGxpbmcgZXZlbnRzIHRoYXQgaXRcbiAqIGNhbiBiZSBsaXN0ZW5lZCB0byB0aHJvdWdoIHRoZSBzZXJ2aWNlLlxuICovXG52YXIgU2Nyb2xsYWJsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9zY3JvbGxcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNjcm9sbGFibGUoX2VsZW1lbnRSZWYsIF9zY3JvbGwsIF9uZ1pvbmUsIF9yZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3Njcm9sbCA9IF9zY3JvbGw7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50U2Nyb2xsZWQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNjcm9sbGFibGUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zY3JvbGxMaXN0ZW5lciA9IHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlbmRlcmVyLmxpc3RlbihfdGhpcy5nZXRFbGVtZW50UmVmKCkubmF0aXZlRWxlbWVudCwgJ3Njcm9sbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9lbGVtZW50U2Nyb2xsZWQubmV4dChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Njcm9sbC5yZWdpc3Rlcih0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2Nyb2xsYWJsZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbC5kZXJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbExpc3RlbmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdoZW4gYSBzY3JvbGwgZXZlbnQgaXMgZmlyZWQgb24gdGhlIGhvc3QgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNjcm9sbGFibGUucHJvdG90eXBlLmVsZW1lbnRTY3JvbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRTY3JvbGxlZC5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2Nyb2xsYWJsZS5wcm90b3R5cGUuZ2V0RWxlbWVudFJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWY7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsYWJsZTtcbn0oKSk7XG5TY3JvbGxhYmxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrLXNjcm9sbGFibGVdLCBbY2RrU2Nyb2xsYWJsZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblNjcm9sbGFibGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogU2Nyb2xsRGlzcGF0Y2hlciwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbl07IH07XG4vKipcbiAqIFN0cmF0ZWd5IHRoYXQgd2lsbCB1cGRhdGUgdGhlIGVsZW1lbnQgcG9zaXRpb24gYXMgdGhlIHVzZXIgaXMgc2Nyb2xsaW5nLlxuICovXG52YXIgUmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfc2Nyb2xsRGlzcGF0Y2hlclxuICAgICAqIEBwYXJhbSB7Pz19IF9zY3JvbGxUaHJvdHRsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneShfc2Nyb2xsRGlzcGF0Y2hlciwgX3Njcm9sbFRocm90dGxlKSB7XG4gICAgICAgIGlmIChfc2Nyb2xsVGhyb3R0bGUgPT09IHZvaWQgMCkgeyBfc2Nyb2xsVGhyb3R0bGUgPSAwOyB9XG4gICAgICAgIHRoaXMuX3Njcm9sbERpc3BhdGNoZXIgPSBfc2Nyb2xsRGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVGhyb3R0bGUgPSBfc2Nyb2xsVGhyb3R0bGU7XG4gICAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3ZlcmxheVJlZlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAob3ZlcmxheVJlZikge1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gb3ZlcmxheVJlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24gPSB0aGlzLl9zY3JvbGxEaXNwYXRjaGVyLnNjcm9sbGVkKHRoaXMuX3Njcm9sbFRocm90dGxlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX292ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5O1xufSgpKTtcbi8qKlxuICogU3RyYXRlZ3kgdGhhdCB3aWxsIGNsb3NlIHRoZSBvdmVybGF5IGFzIHNvb24gYXMgdGhlIHVzZXIgc3RhcnRzIHNjcm9sbGluZy5cbiAqL1xudmFyIENsb3NlU2Nyb2xsU3RyYXRlZ3kgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9zY3JvbGxEaXNwYXRjaGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xvc2VTY3JvbGxTdHJhdGVneShfc2Nyb2xsRGlzcGF0Y2hlcikge1xuICAgICAgICB0aGlzLl9zY3JvbGxEaXNwYXRjaGVyID0gX3Njcm9sbERpc3BhdGNoZXI7XG4gICAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3ZlcmxheVJlZlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvc2VTY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKG92ZXJsYXlSZWYpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IG92ZXJsYXlSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb3NlU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuX3Njcm9sbERpc3BhdGNoZXIuc2Nyb2xsZWQobnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDbG9zZVNjcm9sbFN0cmF0ZWd5LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDbG9zZVNjcm9sbFN0cmF0ZWd5O1xufSgpKTtcbi8qKlxuICogU2Nyb2xsIHN0cmF0ZWd5IHRoYXQgZG9lc24ndCBkbyBhbnl0aGluZy5cbiAqL1xudmFyIE5vb3BTY3JvbGxTdHJhdGVneSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vb3BTY3JvbGxTdHJhdGVneSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BTY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BTY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBOb29wU2Nyb2xsU3RyYXRlZ3k7XG59KCkpO1xuLyoqXG4gKiBTdHJhdGVneSB0aGF0IHdpbGwgcHJldmVudCB0aGUgdXNlciBmcm9tIHNjcm9sbGluZyB3aGlsZSB0aGUgb3ZlcmxheSBpcyB2aXNpYmxlLlxuICovXG52YXIgQmxvY2tTY3JvbGxTdHJhdGVneSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdwb3J0UnVsZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCbG9ja1Njcm9sbFN0cmF0ZWd5KF92aWV3cG9ydFJ1bGVyKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0UnVsZXIgPSBfdmlld3BvcnRSdWxlcjtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNIVE1MU3R5bGVzID0geyB0b3A6IG51bGwsIGxlZnQ6IG51bGwgfTtcbiAgICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmxvY2tTY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmxvY2tTY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FuQmVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1Njcm9sbFBvc2l0aW9uID0gdGhpcy5fdmlld3BvcnRSdWxlci5nZXRWaWV3cG9ydFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAvLyBDYWNoZSB0aGUgcHJldmlvdXMgaW5saW5lIHN0eWxlcyBpbiBjYXNlIHRoZSB1c2VyIGhhZCBzZXQgdGhlbS5cbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzSFRNTFN0eWxlcy5sZWZ0ID0gcm9vdC5zdHlsZS5sZWZ0O1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNIVE1MU3R5bGVzLnRvcCA9IHJvb3Quc3R5bGUudG9wO1xuICAgICAgICAgICAgLy8gTm90ZTogd2UncmUgdXNpbmcgdGhlIGBodG1sYCBub2RlLCBpbnN0ZWFkIG9mIHRoZSBgYm9keWAsIGJlY2F1c2UgdGhlIGBib2R5YCBtYXlcbiAgICAgICAgICAgIC8vIGhhdmUgdGhlIHVzZXIgYWdlbnQgbWFyZ2luLCB3aGVyZWFzIHRoZSBgaHRtbGAgaXMgZ3VhcmFudGVlZCBub3QgdG8gaGF2ZSBvbmUuXG4gICAgICAgICAgICByb290LnN0eWxlLmxlZnQgPSAtdGhpcy5fcHJldmlvdXNTY3JvbGxQb3NpdGlvbi5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgcm9vdC5zdHlsZS50b3AgPSAtdGhpcy5fcHJldmlvdXNTY3JvbGxQb3NpdGlvbi50b3AgKyBcInB4XCI7XG4gICAgICAgICAgICByb290LmNsYXNzTGlzdC5hZGQoJ2Nkay1nbG9iYWwtc2Nyb2xsYmxvY2snKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmxvY2tTY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUubGVmdCA9IHRoaXMuX3ByZXZpb3VzSFRNTFN0eWxlcy5sZWZ0O1xuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnRvcCA9IHRoaXMuX3ByZXZpb3VzSFRNTFN0eWxlcy50b3A7XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY2RrLWdsb2JhbC1zY3JvbGxibG9jaycpO1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbCh0aGlzLl9wcmV2aW91c1Njcm9sbFBvc2l0aW9uLmxlZnQsIHRoaXMuX3ByZXZpb3VzU2Nyb2xsUG9zaXRpb24udG9wKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCbG9ja1Njcm9sbFN0cmF0ZWd5LnByb3RvdHlwZS5fY2FuQmVFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTaW5jZSB0aGUgc2Nyb2xsIHN0cmF0ZWdpZXMgY2FuJ3QgYmUgc2luZ2xldG9ucywgd2UgaGF2ZSB0byB1c2UgYSBnbG9iYWwgQ1NTIGNsYXNzXG4gICAgICAgIC8vIChgY2RrLWdsb2JhbC1zY3JvbGxibG9ja2ApIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IHRyeSB0byBkaXNhYmxlIGdsb2JhbFxuICAgICAgICAvLyBzY3JvbGxpbmcgbXVsdGlwbGUgdGltZXMuXG4gICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdjZGstZ2xvYmFsLXNjcm9sbGJsb2NrJykgfHwgdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnRSdWxlci5nZXRWaWV3cG9ydFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIGJvZHkuc2Nyb2xsSGVpZ2h0ID4gdmlld3BvcnQuaGVpZ2h0IHx8IGJvZHkuc2Nyb2xsV2lkdGggPiB2aWV3cG9ydC53aWR0aDtcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja1Njcm9sbFN0cmF0ZWd5O1xufSgpKTtcbnZhciBTY3JvbGxEaXNwYXRjaE1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbERpc3BhdGNoTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gU2Nyb2xsRGlzcGF0Y2hNb2R1bGU7XG59KCkpO1xuU2Nyb2xsRGlzcGF0Y2hNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtQbGF0Zm9ybU1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1Njcm9sbGFibGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1Njcm9sbGFibGVdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1NDUk9MTF9ESVNQQVRDSEVSX1BST1ZJREVSXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU2Nyb2xsRGlzcGF0Y2hNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbnZhciBNZFJpcHBsZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmlwcGxlTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRSaXBwbGVNb2R1bGU7XG59KCkpO1xuTWRSaXBwbGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNZENvbW1vbk1vZHVsZSwgUGxhdGZvcm1Nb2R1bGUsIFNjcm9sbERpc3BhdGNoTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRSaXBwbGUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFJpcHBsZV0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbVklFV1BPUlRfUlVMRVJfUFJPVklERVJdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFJpcHBsZU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBzaG93cyBhIHNpbXBsaWZpZWQgY2hlY2tib3ggd2l0aG91dCBpbmNsdWRpbmcgYW55IGtpbmQgb2YgXCJyZWFsXCIgY2hlY2tib3guXG4gKiBNZWFudCB0byBiZSB1c2VkIHdoZW4gdGhlIGNoZWNrYm94IGlzIHB1cmVseSBkZWNvcmF0aXZlIGFuZCBhIGxhcmdlIG51bWJlciBvZiB0aGVtIHdpbGwgYmVcbiAqIGluY2x1ZGVkLCBzdWNoIGFzIGZvciB0aGUgb3B0aW9ucyBpbiBhIG11bHRpLXNlbGVjdC4gVXNlcyBubyBTVkdzIG9yIGNvbXBsZXggYW5pbWF0aW9ucy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBjb21wb25lbnQgd2lsbCBiZSBjb21wbGV0ZWx5IGludmlzaWJsZSB0byBzY3JlZW4tcmVhZGVyIHVzZXJzLiBUaGlzIGlzICpub3QqXG4gKiBpbnRlcmNoYW5nZWFibGUgd2l0aCA8bWQtY2hlY2tib3g+IGFuZCBzaG91bGQgKm5vdCogYmUgdXNlZCBpZiB0aGUgdXNlciB3b3VsZCBkaXJlY3RseSBpbnRlcmFjdFxuICogd2l0aCB0aGUgY2hlY2tib3guIFRoZSBwc2V1ZG8tY2hlY2tib3ggc2hvdWxkIG9ubHkgYmUgdXNlZCBhcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2ZcbiAqIG1vcmUgY29tcGxleCBjb21wb25lbnRzIHRoYXQgYXBwcm9wcmlhdGVseSBoYW5kbGUgc2VsZWN0ZWQgLyBjaGVja2VkIHN0YXRlLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFBzZXVkb0NoZWNrYm94ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRQc2V1ZG9DaGVja2JveChfZWxlbWVudFJlZiwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHN0YXRlIG9mIHRoZSBjaGVja2JveC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSAndW5jaGVja2VkJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGRpc2FibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbG9yID0gJ2FjY2VudCc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFBzZXVkb0NoZWNrYm94LnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBvZiB0aGUgY2hlY2tib3guXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hdGl2ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3MobmF0aXZlRWxlbWVudCwgXCJtYXQtXCIgKyB0aGlzLmNvbG9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhuYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTWRQc2V1ZG9DaGVja2JveDtcbn0oKSk7XG5NZFBzZXVkb0NoZWNrYm94LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1wc2V1ZG8tY2hlY2tib3gsIG1hdC1wc2V1ZG8tY2hlY2tib3gnLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1wc2V1ZG8tY2hlY2tib3h7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtib3JkZXI6MnB4IHNvbGlkO2JvcmRlci1yYWRpdXM6MnB4O2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNpdGlvbjpib3JkZXItY29sb3IgOTBtcyBjdWJpYy1iZXppZXIoMCwwLC4yLC4xKSxiYWNrZ3JvdW5kLWNvbG9yIDkwbXMgY3ViaWMtYmV6aWVyKDAsMCwuMiwuMSl9Lm1hdC1wc2V1ZG8tY2hlY2tib3g6OmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO29wYWNpdHk6MDtjb250ZW50OicnO2JvcmRlci1ib3R0b206MnB4IHNvbGlkIGN1cnJlbnRDb2xvcjt0cmFuc2l0aW9uOm9wYWNpdHkgOTBtcyBjdWJpYy1iZXppZXIoMCwwLC4yLC4xKX0ubWF0LXBzZXVkby1jaGVja2JveC5tYXQtcHNldWRvLWNoZWNrYm94LWNoZWNrZWQsLm1hdC1wc2V1ZG8tY2hlY2tib3gubWF0LXBzZXVkby1jaGVja2JveC1pbmRldGVybWluYXRle2JvcmRlcjpub25lfS5tYXQtcHNldWRvLWNoZWNrYm94LWRpc2FibGVke2N1cnNvcjpkZWZhdWx0fS5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGU6OmFmdGVye3RvcDo5cHg7bGVmdDoycHg7d2lkdGg6MTZweDtvcGFjaXR5OjF9Lm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZDo6YWZ0ZXJ7dG9wOjVweDtsZWZ0OjNweDt3aWR0aDoxMnB4O2hlaWdodDo1cHg7Ym9yZGVyLWxlZnQ6MnB4IHNvbGlkIGN1cnJlbnRDb2xvcjt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7b3BhY2l0eToxfSAvKiMgc291cmNlTWFwcGluZ1VSTD1wc2V1ZG8tY2hlY2tib3guY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICcnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcHNldWRvLWNoZWNrYm94XSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGVdJzogJ3N0YXRlID09PSBcImluZGV0ZXJtaW5hdGVcIicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXBzZXVkby1jaGVja2JveC1jaGVja2VkXSc6ICdzdGF0ZSA9PT0gXCJjaGVja2VkXCInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFBzZXVkb0NoZWNrYm94LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbl07IH07XG5NZFBzZXVkb0NoZWNrYm94LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdzdGF0ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NvbG9yJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbnZhciBNZFNlbGVjdGlvbk1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2VsZWN0aW9uTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRTZWxlY3Rpb25Nb2R1bGU7XG59KCkpO1xuTWRTZWxlY3Rpb25Nb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZFBzZXVkb0NoZWNrYm94XSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFBzZXVkb0NoZWNrYm94XVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNlbGVjdGlvbk1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBPcHRpb24gSURzIG5lZWQgdG8gYmUgdW5pcXVlIGFjcm9zcyBjb21wb25lbnRzLCBzbyB0aGlzIGNvdW50ZXIgZXhpc3RzIG91dHNpZGUgb2ZcbiAqIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xudmFyIF91bmlxdWVJZENvdW50ZXIgPSAwO1xuLyoqXG4gKiBFdmVudCBvYmplY3QgZW1pdHRlZCBieSBNZE9wdGlvbiB3aGVuIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuXG4gKi9cbnZhciBNZE9wdGlvblNlbGVjdGlvbkNoYW5nZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlXG4gICAgICogQHBhcmFtIHs/PX0gaXNVc2VySW5wdXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZE9wdGlvblNlbGVjdGlvbkNoYW5nZShzb3VyY2UsIGlzVXNlcklucHV0KSB7XG4gICAgICAgIGlmIChpc1VzZXJJbnB1dCA9PT0gdm9pZCAwKSB7IGlzVXNlcklucHV0ID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuaXNVc2VySW5wdXQgPSBpc1VzZXJJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIE1kT3B0aW9uU2VsZWN0aW9uQ2hhbmdlO1xufSgpKTtcbi8qKlxuICogU2luZ2xlIG9wdGlvbiBpbnNpZGUgb2YgYSBgPG1kLXNlbGVjdD5gIGVsZW1lbnQuXG4gKi9cbnZhciBNZE9wdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IF9pc0NvbXBhdGliaWxpdHlNb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRPcHRpb24oX2VsZW1lbnQsIF9pc0NvbXBhdGliaWxpdHlNb2RlKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5faXNDb21wYXRpYmlsaXR5TW9kZSA9IF9pc0NvbXBhdGliaWxpdHlNb2RlO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIG9wdGlvbiBpcyBkaXNhYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lkID0gXCJtZC1vcHRpb24tXCIgKyBfdW5pcXVlSWRDb3VudGVyKys7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB3cmFwcGluZyBjb21wb25lbnQgaXMgaW4gbXVsdGlwbGUgc2VsZWN0aW9uIG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm11bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIG9wdGlvbiBpcyBzZWxlY3RlZCBvciBkZXNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kT3B0aW9uLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBvcHRpb24uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRPcHRpb24ucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBvcHRpb24gaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zZWxlY3RlZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kT3B0aW9uLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBvcHRpb24gaXMgZGlzYWJsZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRPcHRpb24ucHJvdG90eXBlLCBcImFjdGl2ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3B0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUgYW5kIHJlYWR5IHRvIGJlIHNlbGVjdGVkLlxuICAgICAgICAgKiBBbiBhY3RpdmUgb3B0aW9uIGRpc3BsYXlzIHN0eWxlcyBhcyBpZiBpdCBpcyBmb2N1c2VkLCBidXQgdGhlXG4gICAgICAgICAqIGZvY3VzIGlzIGFjdHVhbGx5IHJldGFpbmVkIHNvbWV3aGVyZSBlbHNlLiBUaGlzIGNvbWVzIGluIGhhbmR5XG4gICAgICAgICAqIGZvciBjb21wb25lbnRzIGxpa2UgYXV0b2NvbXBsZXRlIHdoZXJlIGZvY3VzIG11c3QgcmVtYWluIG9uIHRoZSBpbnB1dC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kT3B0aW9uLnByb3RvdHlwZSwgXCJ2aWV3VmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXllZCB2YWx1ZSBvZiB0aGUgb3B0aW9uLiBJdCBpcyBuZWNlc3NhcnkgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgb3B0aW9uIGluIHRoZVxuICAgICAgICAgKiBzZWxlY3QncyB0cmlnZ2VyLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGthcmEpOiBBZGQgaW5wdXQgcHJvcGVydHkgYWx0ZXJuYXRpdmUgZm9yIG5vZGUgZW52cy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRIb3N0RWxlbWVudCgpLnRleHRDb250ZW50LnRyaW0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgb3B0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0U2VsZWN0aW9uQ2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyB0aGUgb3B0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbWl0U2VsZWN0aW9uQ2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgZm9jdXMgb250byB0aGlzIG9wdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ2V0SG9zdEVsZW1lbnQoKS5mb2N1cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyBkaXNwbGF5IHN0eWxlcyBvbiB0aGUgb3B0aW9uIHRvIG1ha2UgaXQgYXBwZWFyXG4gICAgICogYWN0aXZlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIHNvIGtleVxuICAgICAqIGV2ZW50cyB3aWxsIGRpc3BsYXkgdGhlIHByb3BlciBvcHRpb25zIGFzIGFjdGl2ZSBvbiBhcnJvdyBrZXkgZXZlbnRzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLnNldEFjdGl2ZVN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgZGlzcGxheSBzdHlsZXMgb24gdGhlIG9wdGlvbiB0aGF0IG1hZGUgaXQgYXBwZWFyXG4gICAgICogYWN0aXZlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIHNvIGtleVxuICAgICAqIGV2ZW50cyB3aWxsIGRpc3BsYXkgdGhlIHByb3BlciBvcHRpb25zIGFzIGFjdGl2ZSBvbiBhcnJvdyBrZXkgZXZlbnRzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLnNldEluYWN0aXZlU3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIG9wdGlvbiBpcyBzZWxlY3RlZCB3aGVuIGFjdGl2YXRlZCBmcm9tIHRoZSBrZXlib2FyZC5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE9wdGlvbi5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVOVEVSIHx8IGV2ZW50LmtleUNvZGUgPT09IFNQQUNFKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RWaWFJbnRlcmFjdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBvcHRpb24gd2hpbGUgaW5kaWNhdGluZyB0aGUgc2VsZWN0aW9uIGNhbWUgZnJvbSB0aGUgdXNlci4gVXNlZCB0b1xuICAgICAqIGRldGVybWluZSBpZiB0aGUgc2VsZWN0J3MgdmlldyAtPiBtb2RlbCBjYWxsYmFjayBzaG91bGQgYmUgaW52b2tlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5fc2VsZWN0VmlhSW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLm11bHRpcGxlID8gIXRoaXMuX3NlbGVjdGVkIDogdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29ycmVjdCB0YWJpbmRleCBmb3IgdGhlIG9wdGlvbiBkZXBlbmRpbmcgb24gZGlzYWJsZWQgc3RhdGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE9wdGlvbi5wcm90b3R5cGUuX2dldFRhYkluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/ICctMScgOiAnMCc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBob3N0IERPTSBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLl9nZXRIb3N0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHRoZSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Pz19IGlzVXNlcklucHV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE9wdGlvbi5wcm90b3R5cGUuX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChpc1VzZXJJbnB1dCkge1xuICAgICAgICBpZiAoaXNVc2VySW5wdXQgPT09IHZvaWQgMCkgeyBpc1VzZXJJbnB1dCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuZW1pdChuZXcgTWRPcHRpb25TZWxlY3Rpb25DaGFuZ2UodGhpcywgaXNVc2VySW5wdXQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNZE9wdGlvbjtcbn0oKSk7XG5NZE9wdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLW9wdGlvbiwgbWF0LW9wdGlvbicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIudGFiaW5kZXhdJzogJ19nZXRUYWJJbmRleCgpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2VsZWN0ZWRdJzogJ3NlbGVjdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtb3B0aW9uLW11bHRpcGxlXSc6ICdtdWx0aXBsZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWFjdGl2ZV0nOiAnYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tpZF0nOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1zZWxlY3RlZF0nOiAnc2VsZWN0ZWQudG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdkaXNhYmxlZC50b1N0cmluZygpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtb3B0aW9uLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19zZWxlY3RWaWFJbnRlcmFjdGlvbigpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duKSc6ICdfaGFuZGxlS2V5ZG93bigkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtb3B0aW9uXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxzcGFuIFtuZ1N3aXRjaF09XFxcIl9pc0NvbXBhdGliaWxpdHlNb2RlXFxcIiAqbmdJZj1cXFwibXVsdGlwbGVcXFwiPiA8bWF0LXBzZXVkby1jaGVja2JveCBjbGFzcz1cXFwibWF0LW9wdGlvbi1wc2V1ZG8tY2hlY2tib3hcXFwiICpuZ1N3aXRjaENhc2U9XFxcInRydWVcXFwiIFtzdGF0ZV09XFxcInNlbGVjdGVkID8gJ2NoZWNrZWQnIDogJydcXFwiIGNvbG9yPVxcXCJwcmltYXJ5XFxcIj48L21hdC1wc2V1ZG8tY2hlY2tib3g+IDxtZC1wc2V1ZG8tY2hlY2tib3ggY2xhc3M9XFxcIm1hdC1vcHRpb24tcHNldWRvLWNoZWNrYm94XFxcIiAqbmdTd2l0Y2hEZWZhdWx0IFtzdGF0ZV09XFxcInNlbGVjdGVkID8gJ2NoZWNrZWQnIDogJydcXFwiIGNvbG9yPVxcXCJwcmltYXJ5XFxcIj48L21kLXBzZXVkby1jaGVja2JveD4gPC9zcGFuPiA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IDxkaXYgY2xhc3M9XFxcIm1hdC1vcHRpb24tcmlwcGxlXFxcIiAqbmdJZj1cXFwiIWRpc2FibGVkXFxcIiBtZC1yaXBwbGUgW21kUmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIj4gPC9kaXY+IFwiLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRPcHRpb24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSxdIH0sXSB9LFxuXTsgfTtcbk1kT3B0aW9uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ29uU2VsZWN0aW9uQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG52YXIgTWRPcHRpb25Nb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE9wdGlvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kT3B0aW9uTW9kdWxlO1xufSgpKTtcbk1kT3B0aW9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWRSaXBwbGVNb2R1bGUsIENvbW1vbk1vZHVsZSwgTWRTZWxlY3Rpb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZE9wdGlvbl0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRPcHRpb25dXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kT3B0aW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIG51bGwgcG9ydGFsIHRvIGEgaG9zdC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGhyb3dOdWxsUG9ydGFsRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBwb3J0YWwgdG8gYXR0YWNoJyk7XG59XG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIHBvcnRhbCB0byBhIGhvc3QgdGhhdCBpcyBhbHJlYWR5IGF0dGFjaGVkLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0aHJvd1BvcnRhbEFscmVhZHlBdHRhY2hlZEVycm9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSG9zdCBhbHJlYWR5IGhhcyBhIHBvcnRhbCBhdHRhY2hlZCcpO1xufVxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gYXR0ZW1wdGluZyB0byBhdHRhY2ggYSBwb3J0YWwgdG8gYW4gYWxyZWFkeS1kaXNwb3NlZCBob3N0LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0aHJvd1BvcnRhbEhvc3RBbHJlYWR5RGlzcG9zZWRFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgUG9ydGFsSG9zdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkJyk7XG59XG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhbiB1bmtub3duIHBvcnRhbCB0eXBlLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0aHJvd1Vua25vd25Qb3J0YWxUeXBlRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIGF0dGFjaCBhbiB1bmtub3duIFBvcnRhbCB0eXBlLiBCYXNlUG9ydGFsSG9zdCBhY2NlcHRzIGVpdGhlcicgK1xuICAgICAgICAnYSBDb21wb25lbnRQb3J0YWwgb3IgYSBUZW1wbGF0ZVBvcnRhbC4nKTtcbn1cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGEgcG9ydGFsIHRvIGEgbnVsbCBob3N0LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0aHJvd051bGxQb3J0YWxIb3N0RXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIGF0dGFjaCBhIHBvcnRhbCB0byBhIG51bGwgUG9ydGFsSG9zdCcpO1xufVxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gYXR0ZW1wdGluZyB0byBkZXRhY2ggYSBwb3J0YWwgdGhhdCBpcyBub3QgYXR0YWNoZWQuXG4gKiBcXEBkb2NzLXByaXZhdGV3XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0aHJvd05vUG9ydGFsQXR0YWNoZWRFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gZGV0YWNoIGEgcG9ydGFsIHRoYXQgaXMgbm90IGF0dGFjaGVkIHRvIGEgaG9zdCcpO1xufVxuLyoqXG4gKiBBIGBQb3J0YWxgIGlzIHNvbWV0aGluZyB0aGF0IHlvdSB3YW50IHRvIHJlbmRlciBzb21ld2hlcmUgZWxzZS5cbiAqIEl0IGNhbiBiZSBhdHRhY2ggdG8gLyBkZXRhY2hlZCBmcm9tIGEgYFBvcnRhbEhvc3RgLlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBQb3J0YWwgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3J0YWwoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGlzIHBvcnRhbCB0byBhIGhvc3QuXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQb3J0YWwucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgIGlmIChob3N0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93TnVsbFBvcnRhbEhvc3RFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93UG9ydGFsQWxyZWFkeUF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRhY2hlZEhvc3QgPSBob3N0O1xuICAgICAgICByZXR1cm4gKGhvc3QuYXR0YWNoKHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGlzIHBvcnRhbCBmcm9tIGl0cyBob3N0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQb3J0YWwucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdCA9IHRoaXMuX2F0dGFjaGVkSG9zdDtcbiAgICAgICAgaWYgKGhvc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dOb1BvcnRhbEF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRhY2hlZEhvc3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gaG9zdC5kZXRhY2goKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb3J0YWwucHJvdG90eXBlLCBcImlzQXR0YWNoZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHBvcnRhbCBpcyBhdHRhY2hlZCB0byBhIGhvc3QuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2hlZEhvc3QgIT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUG9ydGFsSG9zdCByZWZlcmVuY2Ugd2l0aG91dCBwZXJmb3JtaW5nIGBhdHRhY2goKWAuIFRoaXMgaXMgdXNlZCBkaXJlY3RseSBieVxuICAgICAqIHRoZSBQb3J0YWxIb3N0IHdoZW4gaXQgaXMgcGVyZm9ybWluZyBhbiBgYXR0YWNoKClgIG9yIGBkZXRhY2goKWAuXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQb3J0YWwucHJvdG90eXBlLnNldEF0dGFjaGVkSG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgIHRoaXMuX2F0dGFjaGVkSG9zdCA9IGhvc3Q7XG4gICAgfTtcbiAgICByZXR1cm4gUG9ydGFsO1xufSgpKTtcbi8qKlxuICogQSBgQ29tcG9uZW50UG9ydGFsYCBpcyBhIHBvcnRhbCB0aGF0IGluc3RhbnRpYXRlcyBzb21lIENvbXBvbmVudCB1cG9uIGF0dGFjaG1lbnQuXG4gKi9cbnZhciBDb21wb25lbnRQb3J0YWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENvbXBvbmVudFBvcnRhbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7Pz19IHZpZXdDb250YWluZXJSZWZcbiAgICAgKiBAcGFyYW0gez89fSBpbmplY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudFBvcnRhbChjb21wb25lbnQsIHZpZXdDb250YWluZXJSZWYsIGluamVjdG9yKSB7XG4gICAgICAgIGlmICh2aWV3Q29udGFpbmVyUmVmID09PSB2b2lkIDApIHsgdmlld0NvbnRhaW5lclJlZiA9IG51bGw7IH1cbiAgICAgICAgaWYgKGluamVjdG9yID09PSB2b2lkIDApIHsgaW5qZWN0b3IgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgX3RoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIF90aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBvbmVudFBvcnRhbDtcbn0oUG9ydGFsKSk7XG4vKipcbiAqIEEgYFRlbXBsYXRlUG9ydGFsYCBpcyBhIHBvcnRhbCB0aGF0IHJlcHJlc2VudHMgc29tZSBlbWJlZGRlZCB0ZW1wbGF0ZSAoVGVtcGxhdGVSZWYpLlxuICovXG52YXIgVGVtcGxhdGVQb3J0YWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRlbXBsYXRlUG9ydGFsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDb250YWluZXJSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBvcnRhbCh0ZW1wbGF0ZSwgdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCBsb2NhbHMgZm9yIHRoZSBpbnN0YW50aWF0ZWQgZW1iZWRkZWQgdmlldy5cbiAgICAgICAgICogVGhlc2UgbG9jYWxzIGNhbiBiZSBzZWVuIGFzIFwiZXhwb3J0c1wiIGZvciB0aGUgdGVtcGxhdGUsIHN1Y2ggYXMgaG93IG5nRm9yIGhhc1xuICAgICAgICAgKiBpbmRleCAvIGV2ZW50IC8gb2RkLlxuICAgICAgICAgKiBTZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2RvY3MvdHMvbGF0ZXN0L2FwaS9jb3JlL0VtYmVkZGVkVmlld1JlZi1jbGFzcy5odG1sXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5sb2NhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGU7XG4gICAgICAgIF90aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW1wbGF0ZVBvcnRhbC5wcm90b3R5cGUsIFwib3JpZ2luXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlUmVmLmVsZW1lbnRSZWY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7Pz19IGxvY2Fsc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQb3J0YWwucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChob3N0LCBsb2NhbHMpIHtcbiAgICAgICAgdGhpcy5sb2NhbHMgPSBsb2NhbHMgPT0gbnVsbCA/IG5ldyBNYXAoKSA6IGxvY2FscztcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYXR0YWNoLmNhbGwodGhpcywgaG9zdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUG9ydGFsLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9jYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kZXRhY2guY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBUZW1wbGF0ZVBvcnRhbDtcbn0oUG9ydGFsKSk7XG4vKipcbiAqIFBhcnRpYWwgaW1wbGVtZW50YXRpb24gb2YgUG9ydGFsSG9zdCB0aGF0IG9ubHkgZGVhbHMgd2l0aCBhdHRhY2hpbmcgZWl0aGVyIGFcbiAqIENvbXBvbmVudFBvcnRhbCBvciBhIFRlbXBsYXRlUG9ydGFsLlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBCYXNlUG9ydGFsSG9zdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VQb3J0YWxIb3N0KCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIGhvc3QgaGFzIGFscmVhZHkgYmVlbiBwZXJtYW5lbnRseSBkaXNwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGhvc3QgaGFzIGFuIGF0dGFjaGVkIHBvcnRhbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5oYXNBdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYXR0YWNoZWRQb3J0YWw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBvcnRhbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZVBvcnRhbEhvc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgaWYgKCFwb3J0YWwpIHtcbiAgICAgICAgICAgIHRocm93TnVsbFBvcnRhbEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhyb3dQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvd1BvcnRhbEhvc3RBbHJlYWR5RGlzcG9zZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3J0YWwgaW5zdGFuY2VvZiBDb21wb25lbnRQb3J0YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaGVkUG9ydGFsID0gcG9ydGFsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoQ29tcG9uZW50UG9ydGFsKHBvcnRhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9ydGFsIGluc3RhbmNlb2YgVGVtcGxhdGVQb3J0YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaGVkUG9ydGFsID0gcG9ydGFsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoVGVtcGxhdGVQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvd1Vua25vd25Qb3J0YWxUeXBlRXJyb3IoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBwb3J0YWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5hdHRhY2hDb21wb25lbnRQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBwb3J0YWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5hdHRhY2hUZW1wbGF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRhY2hlZFBvcnRhbCkge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWRQb3J0YWwuc2V0QXR0YWNoZWRIb3N0KG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWRQb3J0YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludm9rZURpc3Bvc2VGbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnZva2VEaXNwb3NlRm4oKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuc2V0RGlzcG9zZUZuID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VGbiA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuX2ludm9rZURpc3Bvc2VGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VGbikge1xuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUZuKCk7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlRm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZVBvcnRhbEhvc3Q7XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgdmVyc2lvbiBvZiBhIGBUZW1wbGF0ZVBvcnRhbGAuIEJlY2F1c2UgdGhlIGRpcmVjdGl2ZSAqaXMqIGEgVGVtcGxhdGVQb3J0YWwsXG4gKiB0aGUgZGlyZWN0aXZlIGluc3RhbmNlIGl0c2VsZiBjYW4gYmUgYXR0YWNoZWQgdG8gYSBob3N0LCBlbmFibGluZyBkZWNsYXJhdGl2ZSB1c2Ugb2YgcG9ydGFscy5cbiAqXG4gKiBVc2FnZTpcbiAqIDxuZy10ZW1wbGF0ZSBwb3J0YWwgI2dyZWV0aW5nPlxuICogICA8cD4gSGVsbG8ge3tuYW1lfX0gPC9wPlxuICogPC9uZy10ZW1wbGF0ZT5cbiAqL1xudmFyIFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlUmVmXG4gICAgICogQHBhcmFtIHs/fSB2aWV3Q29udGFpbmVyUmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUodGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmU7XG59KFRlbXBsYXRlUG9ydGFsKSk7XG5UZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Nkay1wb3J0YWxdLCBbY2RrUG9ydGFsXSwgW3BvcnRhbF0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnY2RrUG9ydGFsJyxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgfSxcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG5dOyB9O1xuLyoqXG4gKiBEaXJlY3RpdmUgdmVyc2lvbiBvZiBhIFBvcnRhbEhvc3QuIEJlY2F1c2UgdGhlIGRpcmVjdGl2ZSAqaXMqIGEgUG9ydGFsSG9zdCwgcG9ydGFscyBjYW4gYmVcbiAqIGRpcmVjdGx5IGF0dGFjaGVkIHRvIGl0LCBlbmFibGluZyBkZWNsYXJhdGl2ZSB1c2UuXG4gKlxuICogVXNhZ2U6XG4gKiA8bmctdGVtcGxhdGUgW2Nka1BvcnRhbEhvc3RdPVwiZ3JlZXRpbmdcIj48L25nLXRlbXBsYXRlPlxuICovXG52YXIgUG9ydGFsSG9zdERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUG9ydGFsSG9zdERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IF92aWV3Q29udGFpbmVyUmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gUG9ydGFsSG9zdERpcmVjdGl2ZShfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBfdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgX3RoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiX2RlcHJlY2F0ZWRQb3J0YWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wb3J0YWw7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5wb3J0YWwgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicG9ydGFsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvcnRhbCBhc3NvY2lhdGVkIHdpdGggdGhlIFBvcnRhbCBob3N0LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwb3J0YWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9ydGFsKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hdHRhY2guY2FsbCh0aGlzLCBwb3J0YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcG9ydGFsID0gcG9ydGFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBvcnRhbEhvc3REaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcG9ydGFsID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgZ2l2ZW4gQ29tcG9uZW50UG9ydGFsIHRvIHRoaXMgUG9ydGFsSG9zdCB1c2luZyB0aGUgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHBvcnRhbCBob3N0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUuYXR0YWNoQ29tcG9uZW50UG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICBwb3J0YWwuc2V0QXR0YWNoZWRIb3N0KHRoaXMpO1xuICAgICAgICAvLyBJZiB0aGUgcG9ydGFsIHNwZWNpZmllcyBhbiBvcmlnaW4sIHVzZSB0aGF0IGFzIHRoZSBsb2dpY2FsIGxvY2F0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaW4gdGhlIGFwcGxpY2F0aW9uIHRyZWUuIE90aGVyd2lzZSB1c2UgdGhlIGxvY2F0aW9uIG9mIHRoaXMgUG9ydGFsSG9zdC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0NvbnRhaW5lclJlZiA9IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmICE9IG51bGwgP1xuICAgICAgICAgICAgcG9ydGFsLnZpZXdDb250YWluZXJSZWYgOlxuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShwb3J0YWwuY29tcG9uZW50KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmID0gdmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50RmFjdG9yeSwgdmlld0NvbnRhaW5lclJlZi5sZW5ndGgsIHBvcnRhbC5pbmplY3RvciB8fCB2aWV3Q29udGFpbmVyUmVmLnBhcmVudEluamVjdG9yKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXREaXNwb3NlRm4uY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZWYuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgdGhpcy5fcG9ydGFsID0gcG9ydGFsO1xuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBnaXZlbiBUZW1wbGF0ZVBvcnRhbCB0byB0aGlzIFBvcnRsSG9zdCBhcyBhbiBlbWJlZGRlZCBWaWV3LlxuICAgICAqIEBwYXJhbSB7P30gcG9ydGFsIFBvcnRhbCB0byBiZSBhdHRhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBvcnRhbEhvc3REaXJlY3RpdmUucHJvdG90eXBlLmF0dGFjaFRlbXBsYXRlUG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwb3J0YWwuc2V0QXR0YWNoZWRIb3N0KHRoaXMpO1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhwb3J0YWwudGVtcGxhdGVSZWYpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldERpc3Bvc2VGbi5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7IH0pO1xuICAgICAgICB0aGlzLl9wb3J0YWwgPSBwb3J0YWw7XG4gICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiByZXR1cm4gbG9jYWxzIGZyb20gdmlld1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcnRhbEhvc3REaXJlY3RpdmU7XG59KEJhc2VQb3J0YWxIb3N0KSk7XG5Qb3J0YWxIb3N0RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrUG9ydGFsSG9zdF0sIFtwb3J0YWxIb3N0XScsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ3BvcnRhbDogY2RrUG9ydGFsSG9zdCddXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblBvcnRhbEhvc3REaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuXTsgfTtcblBvcnRhbEhvc3REaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ19kZXByZWNhdGVkUG9ydGFsJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsncG9ydGFsSG9zdCcsXSB9LF0sXG59O1xudmFyIFBvcnRhbE1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvcnRhbE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFBvcnRhbE1vZHVsZTtcbn0oKSk7XG5Qb3J0YWxNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSwgUG9ydGFsSG9zdERpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUsIFBvcnRhbEhvc3REaXJlY3RpdmVdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Qb3J0YWxNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogT3ZlcmxheVN0YXRlIGlzIGEgYmFnIG9mIHZhbHVlcyBmb3IgZWl0aGVyIHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24gb3IgY3VycmVudCBzdGF0ZSBvZiBhblxuICogb3ZlcmxheS5cbiAqL1xudmFyIE92ZXJsYXlTdGF0ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlTdGF0ZSgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmF0ZWd5IHRvIGJlIHVzZWQgd2hlbiBoYW5kbGluZyBzY3JvbGwgZXZlbnRzIHdoaWxlIHRoZSBvdmVybGF5IGlzIG9wZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbFN0cmF0ZWd5ID0gbmV3IE5vb3BTY3JvbGxTdHJhdGVneSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgb3ZlcmxheSBoYXMgYSBiYWNrZHJvcC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQmFja2Ryb3AgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1c3RvbSBjbGFzcyB0byBhZGQgdG8gdGhlIGJhY2tkcm9wXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhY2tkcm9wQ2xhc3MgPSAnY2RrLW92ZXJsYXktZGFyay1iYWNrZHJvcCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlyZWN0aW9uIG9mIHRoZSB0ZXh0IGluIHRoZSBvdmVybGF5IHBhbmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAnbHRyJztcbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IGNvbmZpZ3VyYXRpb24gc3RpbGwgdG8gYWRkXG4gICAgICAgIC8vIC0gZm9jdXMgdHJhcFxuICAgICAgICAvLyAtIGRpc2FibGUgcG9pbnRlciBldmVudHNcbiAgICAgICAgLy8gLSB6LWluZGV4XG4gICAgfVxuICAgIHJldHVybiBPdmVybGF5U3RhdGU7XG59KCkpO1xuLyoqXG4gKiBBIFBvcnRhbEhvc3QgZm9yIGF0dGFjaGluZyBwb3J0YWxzIHRvIGFuIGFyYml0cmFyeSBET00gZWxlbWVudCBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyXG4gKiBhcHBsaWNhdGlvbiBjb250ZXh0LlxuICpcbiAqIFRoaXMgaXMgdGhlIG9ubHkgcGFydCBvZiB0aGUgcG9ydGFsIGNvcmUgdGhhdCBkaXJlY3RseSB0b3VjaGVzIHRoZSBET00uXG4gKi9cbnZhciBEb21Qb3J0YWxIb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEb21Qb3J0YWxIb3N0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2hvc3REb21FbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfYXBwUmVmXG4gICAgICogQHBhcmFtIHs/fSBfZGVmYXVsdEluamVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRG9tUG9ydGFsSG9zdChfaG9zdERvbUVsZW1lbnQsIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF9hcHBSZWYsIF9kZWZhdWx0SW5qZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2hvc3REb21FbGVtZW50ID0gX2hvc3REb21FbGVtZW50O1xuICAgICAgICBfdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgX3RoaXMuX2FwcFJlZiA9IF9hcHBSZWY7XG4gICAgICAgIF90aGlzLl9kZWZhdWx0SW5qZWN0b3IgPSBfZGVmYXVsdEluamVjdG9yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgZ2l2ZW4gQ29tcG9uZW50UG9ydGFsIHRvIERPTSBlbGVtZW50IHVzaW5nIHRoZSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIuXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbVBvcnRhbEhvc3QucHJvdG90eXBlLmF0dGFjaENvbXBvbmVudFBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShwb3J0YWwuY29tcG9uZW50KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50UmVmO1xuICAgICAgICAvLyBJZiB0aGUgcG9ydGFsIHNwZWNpZmllcyBhIFZpZXdDb250YWluZXJSZWYsIHdlIHdpbGwgdXNlIHRoYXQgYXMgdGhlIGF0dGFjaG1lbnQgcG9pbnRcbiAgICAgICAgLy8gZm9yIHRoZSBjb21wb25lbnQgKGluIHRlcm1zIG9mIEFuZ3VsYXIncyBjb21wb25lbnQgdHJlZSwgbm90IHJlbmRlcmluZykuXG4gICAgICAgIC8vIFdoZW4gdGhlIFZpZXdDb250YWluZXJSZWYgaXMgbWlzc2luZywgd2UgdXNlIHRoZSBmYWN0b3J5IHRvIGNyZWF0ZSB0aGUgY29tcG9uZW50IGRpcmVjdGx5XG4gICAgICAgIC8vIGFuZCB0aGVuIG1hbnVhbGx5IGF0dGFjaCB0aGUgdmlldyB0byB0aGUgYXBwbGljYXRpb24uXG4gICAgICAgIGlmIChwb3J0YWwudmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICAgICAgY29tcG9uZW50UmVmID0gcG9ydGFsLnZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudEZhY3RvcnksIHBvcnRhbC52aWV3Q29udGFpbmVyUmVmLmxlbmd0aCwgcG9ydGFsLmluamVjdG9yIHx8IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmLnBhcmVudEluamVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RGlzcG9zZUZuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvbmVudFJlZi5kZXN0cm95KCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50UmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUocG9ydGFsLmluamVjdG9yIHx8IHRoaXMuX2RlZmF1bHRJbmplY3Rvcik7XG4gICAgICAgICAgICB0aGlzLl9hcHBSZWYuYXR0YWNoVmlldyhjb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuICAgICAgICAgICAgdGhpcy5zZXREaXNwb3NlRm4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9hcHBSZWYuZGV0YWNoVmlldyhjb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBjb21wb25lbnQgaGFzIGJlZW4gaW5zdGFudGlhdGVkLCBzbyB3ZSBtb3ZlIGl0IHRvIHRoZSBsb2NhdGlvbiBpbiB0aGUgRE9NXG4gICAgICAgIC8vIHdoZXJlIHdlIHdhbnQgaXQgdG8gYmUgcmVuZGVyZWQuXG4gICAgICAgIHRoaXMuX2hvc3REb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2dldENvbXBvbmVudFJvb3ROb2RlKGNvbXBvbmVudFJlZikpO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYSB0ZW1wbGF0ZSBwb3J0YWwgdG8gdGhlIERPTSBhcyBhbiBlbWJlZGRlZCB2aWV3LlxuICAgICAqIEBwYXJhbSB7P30gcG9ydGFsIFBvcnRhbCB0byBiZSBhdHRhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbVBvcnRhbEhvc3QucHJvdG90eXBlLmF0dGFjaFRlbXBsYXRlUG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3Q29udGFpbmVyID0gcG9ydGFsLnZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdSZWYgPSB2aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhwb3J0YWwudGVtcGxhdGVSZWYpO1xuICAgICAgICB2aWV3UmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgLy8gVGhlIG1ldGhvZCBgY3JlYXRlRW1iZWRkZWRWaWV3YCB3aWxsIGFkZCB0aGUgdmlldyBhcyBhIGNoaWxkIG9mIHRoZSB2aWV3Q29udGFpbmVyLlxuICAgICAgICAvLyBCdXQgZm9yIHRoZSBEb21Qb3J0YWxIb3N0IHRoZSB2aWV3IGNhbiBiZSBhZGRlZCBldmVyeXdoZXJlIGluIHRoZSBET00gKGUuZyBPdmVybGF5IENvbnRhaW5lcilcbiAgICAgICAgLy8gVG8gbW92ZSB0aGUgdmlldyB0byB0aGUgc3BlY2lmaWVkIGhvc3QgZWxlbWVudC4gV2UganVzdCByZS1hcHBlbmQgdGhlIGV4aXN0aW5nIHJvb3Qgbm9kZXMuXG4gICAgICAgIHZpZXdSZWYucm9vdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHJvb3ROb2RlKSB7IHJldHVybiBfdGhpcy5faG9zdERvbUVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdE5vZGUpOyB9KTtcbiAgICAgICAgdGhpcy5zZXREaXNwb3NlRm4oKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gdmlld0NvbnRhaW5lci5pbmRleE9mKHZpZXdSZWYpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHZpZXdDb250YWluZXIucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogUmV0dXJuIGxvY2FscyBmcm9tIHZpZXcuXG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgb3V0IGEgcG9ydGFsIGZyb20gdGhlIERPTS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbVBvcnRhbEhvc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5faG9zdERvbUVsZW1lbnQucGFyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9ob3N0RG9tRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2hvc3REb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcm9vdCBIVE1MRWxlbWVudCBmb3IgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFJlZlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tUG9ydGFsSG9zdC5wcm90b3R5cGUuX2dldENvbXBvbmVudFJvb3ROb2RlID0gZnVuY3Rpb24gKGNvbXBvbmVudFJlZikge1xuICAgICAgICByZXR1cm4gKCgoY29tcG9uZW50UmVmLmhvc3RWaWV3KSkucm9vdE5vZGVzWzBdKTtcbiAgICB9O1xuICAgIHJldHVybiBEb21Qb3J0YWxIb3N0O1xufShCYXNlUG9ydGFsSG9zdCkpO1xuLyoqXG4gKiBSZWZlcmVuY2UgdG8gYW4gb3ZlcmxheSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCB0aGUgT3ZlcmxheSBzZXJ2aWNlLlxuICogVXNlZCB0byBtYW5pcHVsYXRlIG9yIGRpc3Bvc2Ugb2Ygc2FpZCBvdmVybGF5LlxuICovXG52YXIgT3ZlcmxheVJlZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3BvcnRhbEhvc3RcbiAgICAgKiBAcGFyYW0gez99IF9wYW5lXG4gICAgICogQHBhcmFtIHs/fSBfc3RhdGVcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPdmVybGF5UmVmKF9wb3J0YWxIb3N0LCBfcGFuZSwgX3N0YXRlLCBfbmdab25lKSB7XG4gICAgICAgIHRoaXMuX3BvcnRhbEhvc3QgPSBfcG9ydGFsSG9zdDtcbiAgICAgICAgdGhpcy5fcGFuZSA9IF9wYW5lO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IF9zdGF0ZTtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BDbGljayA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5fZGV0YWNobWVudHMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl9zdGF0ZS5zY3JvbGxTdHJhdGVneS5hdHRhY2godGhpcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPdmVybGF5UmVmLnByb3RvdHlwZSwgXCJvdmVybGF5RWxlbWVudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3ZlcmxheSdzIEhUTUwgZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFuZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdGhlIG92ZXJsYXkgdG8gYSBwb3J0YWwgaW5zdGFuY2UgYW5kIGFkZHMgdGhlIGJhY2tkcm9wLlxuICAgICAqIEBwYXJhbSB7P30gcG9ydGFsIFBvcnRhbCBpbnN0YW5jZSB0byB3aGljaCB0byBhdHRhY2ggdGhlIG92ZXJsYXkuXG4gICAgICogQHJldHVybiB7P30gVGhlIHBvcnRhbCBhdHRhY2htZW50IHJlc3VsdC5cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dGFjaFJlc3VsdCA9IHRoaXMuX3BvcnRhbEhvc3QuYXR0YWNoKHBvcnRhbCk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcGFuZSBlbGVtZW50IHdpdGggdGhlIGdpdmVuIHN0YXRlIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIHRoaXMuX3VwZGF0ZVN0YWNraW5nT3JkZXIoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5fYXR0YWNobWVudHMubmV4dCgpO1xuICAgICAgICB0aGlzLl9zdGF0ZS5zY3JvbGxTdHJhdGVneS5lbmFibGUoKTtcbiAgICAgICAgLy8gRW5hYmxlIHBvaW50ZXIgZXZlbnRzIGZvciB0aGUgb3ZlcmxheSBwYW5lIGVsZW1lbnQuXG4gICAgICAgIHRoaXMuX3RvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5oYXNCYWNrZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoQmFja2Ryb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0YWNoUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgYW4gb3ZlcmxheSBmcm9tIGEgcG9ydGFsLlxuICAgICAqIEByZXR1cm4gez99IFJlc29sdmVzIHdoZW4gdGhlIG92ZXJsYXkgaGFzIGJlZW4gZGV0YWNoZWQuXG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRldGFjaEJhY2tkcm9wKCk7XG4gICAgICAgIC8vIFdoZW4gdGhlIG92ZXJsYXkgaXMgZGV0YWNoZWQsIHRoZSBwYW5lIGVsZW1lbnQgc2hvdWxkIGRpc2FibGUgcG9pbnRlciBldmVudHMuXG4gICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBwYW5lIGVsZW1lbnQgd2lsbCBjb3ZlciB0aGUgcGFnZSBhbmQgZGlzYWJsZVxuICAgICAgICAvLyBwb2ludGVyIGV2ZW50cyB0aGVyZWZvcmUuIERlcGVuZHMgb24gdGhlIHBvc2l0aW9uIHN0cmF0ZWd5IGFuZCB0aGUgYXBwbGllZCBwYW5lIGJvdW5kYXJpZXMuXG4gICAgICAgIHRoaXMuX3RvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgICAgICB0aGlzLl9zdGF0ZS5zY3JvbGxTdHJhdGVneS5kaXNhYmxlKCk7XG4gICAgICAgIHRoaXMuX2RldGFjaG1lbnRzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbEhvc3QuZGV0YWNoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgdGhlIG92ZXJsYXkgZnJvbSB0aGUgRE9NLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnBvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnBvc2l0aW9uU3RyYXRlZ3kuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0YWNoQmFja2Ryb3AoKTtcbiAgICAgICAgdGhpcy5fcG9ydGFsSG9zdC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3N0YXRlLnNjcm9sbFN0cmF0ZWd5LmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5fZGV0YWNobWVudHMubmV4dCgpO1xuICAgICAgICB0aGlzLl9kZXRhY2htZW50cy5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLl9hdHRhY2htZW50cy5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIG92ZXJsYXkgaGFzIGJlZW4gYXR0YWNoZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5oYXNBdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbEhvc3QuaGFzQXR0YWNoZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdoZW4gdGhlIGJhY2tkcm9wIGhhcyBiZWVuIGNsaWNrZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5iYWNrZHJvcENsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2Ryb3BDbGljay5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdoZW4gdGhlIG92ZXJsYXkgaGFzIGJlZW4gYXR0YWNoZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5hdHRhY2htZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFjaG1lbnRzLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbiB0aGUgb3ZlcmxheSBoYXMgYmVlbiBkZXRhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmRldGFjaG1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGV0YWNobWVudHMuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRlIGNvbmZpZyBvZiB0aGUgb3ZlcmxheS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheSBiYXNlZCBvbiB0aGUgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnBvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnBvc2l0aW9uU3RyYXRlZ3kuYXBwbHkodGhpcy5fcGFuZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBvdmVybGF5IHBhbmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUudXBkYXRlRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wYW5lLnNldEF0dHJpYnV0ZSgnZGlyJywgdGhpcy5fc3RhdGUuZGlyZWN0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhlIG92ZXJsYXkgYmFzZWQgb24gdGhlIG92ZXJsYXkgY29uZmlnLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLndpZHRoIHx8IHRoaXMuX3N0YXRlLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lLnN0eWxlLndpZHRoID0gZm9ybWF0Q3NzVW5pdCh0aGlzLl9zdGF0ZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmhlaWdodCB8fCB0aGlzLl9zdGF0ZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3BhbmUuc3R5bGUuaGVpZ2h0ID0gZm9ybWF0Q3NzVW5pdCh0aGlzLl9zdGF0ZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5taW5XaWR0aCB8fCB0aGlzLl9zdGF0ZS5taW5XaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGFuZS5zdHlsZS5taW5XaWR0aCA9IGZvcm1hdENzc1VuaXQodGhpcy5fc3RhdGUubWluV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5taW5IZWlnaHQgfHwgdGhpcy5fc3RhdGUubWluSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lLnN0eWxlLm1pbkhlaWdodCA9IGZvcm1hdENzc1VuaXQodGhpcy5fc3RhdGUubWluSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgcG9pbnRlciBldmVudHMgZm9yIHRoZSBvdmVybGF5IHBhbmUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IGVuYWJsZVBvaW50ZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLl90b2dnbGVQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKGVuYWJsZVBvaW50ZXIpIHtcbiAgICAgICAgdGhpcy5fcGFuZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gZW5hYmxlUG9pbnRlciA/ICdhdXRvJyA6ICdub25lJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgYmFja2Ryb3AgZm9yIHRoaXMgb3ZlcmxheS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLl9hdHRhY2hCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjZGstb3ZlcmxheS1iYWNrZHJvcCcpO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLl9zdGF0ZS5iYWNrZHJvcENsYXNzKTtcbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBiYWNrZHJvcCBiZWZvcmUgdGhlIHBhbmUgaW4gdGhlIERPTSBvcmRlcixcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gaGFuZGxlIHN0YWNrZWQgb3ZlcmxheXMgcHJvcGVybHkuXG4gICAgICAgIHRoaXMuX3BhbmUucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5fYmFja2Ryb3BFbGVtZW50LCB0aGlzLl9wYW5lKTtcbiAgICAgICAgLy8gRm9yd2FyZCBiYWNrZHJvcCBjbGlja3Mgc3VjaCB0aGF0IHRoZSBjb25zdW1lciBvZiB0aGUgb3ZlcmxheSBjYW4gcGVyZm9ybSB3aGF0ZXZlclxuICAgICAgICAvLyBhY3Rpb24gZGVzaXJlZCB3aGVuIHN1Y2ggYSBjbGljayBvY2N1cnMgKHVzdWFsbHkgY2xvc2luZyB0aGUgb3ZlcmxheSkuXG4gICAgICAgIHRoaXMuX2JhY2tkcm9wRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9iYWNrZHJvcENsaWNrLm5leHQobnVsbCk7IH0pO1xuICAgICAgICAvLyBBZGQgY2xhc3MgdG8gZmFkZS1pbiB0aGUgYmFja2Ryb3AgYWZ0ZXIgb25lIGZyYW1lLlxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9iYWNrZHJvcEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYmFja2Ryb3BFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2Nkay1vdmVybGF5LWJhY2tkcm9wLXNob3dpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzdGFja2luZyBvcmRlciBvZiB0aGUgZWxlbWVudCwgbW92aW5nIGl0IHRvIHRoZSB0b3AgaWYgbmVjZXNzYXJ5LlxuICAgICAqIFRoaXMgaXMgcmVxdWlyZWQgaW4gY2FzZXMgd2hlcmUgb25lIG92ZXJsYXkgd2FzIGRldGFjaGVkLCB3aGlsZSBhbm90aGVyIG9uZSxcbiAgICAgKiB0aGF0IHNob3VsZCBiZSBiZWhpbmQgaXQsIHdhcyBkZXN0cm95ZWQuIFRoZSBuZXh0IHRpbWUgYm90aCBvZiB0aGVtIGFyZSBvcGVuZWQsXG4gICAgICogdGhlIHN0YWNraW5nIHdpbGwgYmUgd3JvbmcsIGJlY2F1c2UgdGhlIGRldGFjaGVkIGVsZW1lbnQncyBwYW5lIHdpbGwgc3RpbGwgYmVcbiAgICAgKiBpbiBpdHMgb3JpZ2luYWwgRE9NIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuX3VwZGF0ZVN0YWNraW5nT3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5lLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fcGFuZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaGVzIHRoZSBiYWNrZHJvcCAoaWYgYW55KSBhc3NvY2lhdGVkIHdpdGggdGhlIG92ZXJsYXkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5kZXRhY2hCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFja2Ryb3BUb0RldGFjaCA9IHRoaXMuX2JhY2tkcm9wRWxlbWVudDtcbiAgICAgICAgaWYgKGJhY2tkcm9wVG9EZXRhY2gpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbmlzaERldGFjaF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEl0IG1heSBub3QgYmUgYXR0YWNoZWQgdG8gYW55dGhpbmcgaW4gY2VydGFpbiBjYXNlcyAoZS5nLiB1bml0IHRlc3RzKS5cbiAgICAgICAgICAgICAgICBpZiAoYmFja2Ryb3BUb0RldGFjaCAmJiBiYWNrZHJvcFRvRGV0YWNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2Ryb3BUb0RldGFjaC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJhY2tkcm9wVG9EZXRhY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IGEgbmV3IHBvcnRhbCBoYXMgYmVlbiBhdHRhY2hlZCB0byB0aGlzIG92ZXJsYXkgc2luY2Ugd2Ugc3RhcnRlZFxuICAgICAgICAgICAgICAgIC8vIHJlbW92aW5nIHRoZSBiYWNrZHJvcC4gSWYgdGhhdCBpcyB0aGUgY2FzZSwgb25seSBjbGVhciB0aGUgYmFja2Ryb3AgcmVmZXJlbmNlIGlmIGl0XG4gICAgICAgICAgICAgICAgLy8gaXMgc3RpbGwgdGhlIHNhbWUgaW5zdGFuY2UgdGhhdCB3ZSBzdGFydGVkIHRvIHJlbW92ZS5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2JhY2tkcm9wRWxlbWVudCA9PSBiYWNrZHJvcFRvRGV0YWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9iYWNrZHJvcEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBiYWNrZHJvcFRvRGV0YWNoLmNsYXNzTGlzdC5yZW1vdmUoJ2Nkay1vdmVybGF5LWJhY2tkcm9wLXNob3dpbmcnKTtcbiAgICAgICAgICAgIGJhY2tkcm9wVG9EZXRhY2guY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9zdGF0ZS5iYWNrZHJvcENsYXNzKTtcbiAgICAgICAgICAgIGJhY2tkcm9wVG9EZXRhY2guYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZpbmlzaERldGFjaF8xKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBiYWNrZHJvcCBkb2Vzbid0IGhhdmUgYSB0cmFuc2l0aW9uLCB0aGUgYHRyYW5zaXRpb25lbmRgIGV2ZW50IHdvbid0IGZpcmUuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgbWFrZSBpdCB1bmNsaWNrYWJsZSBhbmQgd2UgdHJ5IHRvIHJlbW92ZSBpdCBhZnRlciBhIGRlbGF5LlxuICAgICAgICAgICAgYmFja2Ryb3BUb0RldGFjaC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgLy8gUnVuIHRoaXMgb3V0c2lkZSB0aGUgQW5ndWxhciB6b25lIGJlY2F1c2UgdGhlcmUncyBub3RoaW5nIHRoYXQgQW5ndWxhciBjYXJlcyBhYm91dC5cbiAgICAgICAgICAgIC8vIElmIGl0IHdlcmUgdG8gcnVuIGluc2lkZSB0aGUgQW5ndWxhciB6b25lLCBldmVyeSB0ZXN0IHRoYXQgdXNlZCBPdmVybGF5IHdvdWxkIGhhdmUgdG8gYmVcbiAgICAgICAgICAgIC8vIGVpdGhlciBhc3luYyBvciBmYWtlQXN5bmMuXG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmluaXNoRGV0YWNoXzEsIDUwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE92ZXJsYXlSZWY7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmb3JtYXRDc3NVbml0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAodmFsdWUpIDogdmFsdWUgKyBcInB4XCI7XG59XG4vKiogSG9yaXpvbnRhbCBkaW1lbnNpb24gb2YgYSBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSBwZXJpbWV0ZXIgb2YgdGhlIG9yaWdpbiBvciBvdmVybGF5IGVsZW1lbnQuICovXG4vKipcbiAqIFRoZSBwb2ludHMgb2YgdGhlIG9yaWdpbiBlbGVtZW50IGFuZCB0aGUgb3ZlcmxheSBlbGVtZW50IHRvIGNvbm5lY3QuXG4gKi9cbnZhciBDb25uZWN0aW9uUG9zaXRpb25QYWlyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW5cbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uUG9zaXRpb25QYWlyKG9yaWdpbiwgb3ZlcmxheSkge1xuICAgICAgICB0aGlzLm9yaWdpblggPSBvcmlnaW4ub3JpZ2luWDtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0gb3JpZ2luLm9yaWdpblk7XG4gICAgICAgIHRoaXMub3ZlcmxheVggPSBvdmVybGF5Lm92ZXJsYXlYO1xuICAgICAgICB0aGlzLm92ZXJsYXlZID0gb3ZlcmxheS5vdmVybGF5WTtcbiAgICB9XG4gICAgcmV0dXJuIENvbm5lY3Rpb25Qb3NpdGlvblBhaXI7XG59KCkpO1xuLyoqXG4gKiBTZXQgb2YgcHJvcGVydGllcyByZWdhcmRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBvcmlnaW4gYW5kIG92ZXJsYXkgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XG4gKiB3aXRoIHJlc3BlY3QgdG8gdGhlIGNvbnRhaW5pbmcgU2Nyb2xsYWJsZSBlbGVtZW50cy5cbiAqXG4gKiBUaGUgb3ZlcmxheSBhbmQgb3JpZ2luIGFyZSBjbGlwcGVkIGlmIGFueSBwYXJ0IG9mIHRoZWlyIGJvdW5kaW5nIGNsaWVudCByZWN0YW5nbGUgZXhjZWVkcyB0aGVcbiAqIGJvdW5kcyBvZiBhbnkgb25lIG9mIHRoZSBzdHJhdGVneSdzIFNjcm9sbGFibGUncyBib3VuZGluZyBjbGllbnQgcmVjdGFuZ2xlLlxuICpcbiAqIFRoZSBvdmVybGF5IGFuZCBvcmlnaW4gYXJlIG91dHNpZGUgdmlldyBpZiB0aGVyZSBpcyBubyBvdmVybGFwIGJldHdlZW4gdGhlaXIgYm91bmRpbmcgY2xpZW50XG4gKiByZWN0YW5nbGUgYW5kIGFueSBvbmUgb2YgdGhlIHN0cmF0ZWd5J3MgU2Nyb2xsYWJsZSdzIGJvdW5kaW5nIGNsaWVudCByZWN0YW5nbGUuXG4gKlxuICogICAgICAgLS0tLS0tLS0tLS0gICAgICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tXG4gKiAgICAgICB8IG91dHNpZGUgfCAgICAgICAgICAgICAgICAgICAgfCBjbGlwcGVkIHxcbiAqICAgICAgIHwgIHZpZXcgICB8ICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogICAgICAgfCAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgIHwgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgICAtLS0tLS0tLS0tICAgICAgICAgICAgICAgfCAgICAgLS0tLS0tLS0tLS0gICAgICAgIHxcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHwgICAgICBTY3JvbGxhYmxlICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICB8ICAgICAgU2Nyb2xsYWJsZSAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xudmFyIFNjcm9sbGFibGVWaWV3UHJvcGVydGllcyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbGFibGVWaWV3UHJvcGVydGllcygpIHtcbiAgICB9XG4gICAgcmV0dXJuIFNjcm9sbGFibGVWaWV3UHJvcGVydGllcztcbn0oKSk7XG4vKipcbiAqIFRoZSBjaGFuZ2UgZXZlbnQgZW1pdHRlZCBieSB0aGUgc3RyYXRlZ3kgd2hlbiBhIGZhbGxiYWNrIHBvc2l0aW9uIGlzIHVzZWQuXG4gKi9cbnZhciBDb25uZWN0ZWRPdmVybGF5UG9zaXRpb25DaGFuZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbm5lY3Rpb25QYWlyXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxhYmxlVmlld1Byb3BlcnRpZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb25uZWN0ZWRPdmVybGF5UG9zaXRpb25DaGFuZ2UoY29ubmVjdGlvblBhaXIsIHNjcm9sbGFibGVWaWV3UHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25QYWlyID0gY29ubmVjdGlvblBhaXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzID0gc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzO1xuICAgIH1cbiAgICByZXR1cm4gQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlO1xufSgpKTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ29ubmVjdGlvblBvc2l0aW9uUGFpciwgfSxcbiAgICB7IHR5cGU6IFNjcm9sbGFibGVWaWV3UHJvcGVydGllcywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBwb3NpdGlvbmluZyBvdmVybGF5cy4gVXNpbmcgdGhpcyBzdHJhdGVneSwgYW4gb3ZlcmxheSBpcyBnaXZlbiBhblxuICogaW1wbGljaXQgcG9zaXRpb24gcmVsYXRpdmUgc29tZSBvcmlnaW4gZWxlbWVudC4gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGRlZmluZWQgaW4gdGVybXMgb2ZcbiAqIGEgcG9pbnQgb24gdGhlIG9yaWdpbiBlbGVtZW50IHRoYXQgaXMgY29ubmVjdGVkIHRvIGEgcG9pbnQgb24gdGhlIG92ZXJsYXkgZWxlbWVudC4gRm9yIGV4YW1wbGUsXG4gKiBhIGJhc2ljIGRyb3Bkb3duIGlzIGNvbm5lY3RpbmcgdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0aGUgb3JpZ2luIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXJcbiAqIG9mIHRoZSBvdmVybGF5LlxuICovXG52YXIgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2Nvbm5lY3RlZFRvXG4gICAgICogQHBhcmFtIHs/fSBfb3JpZ2luUG9zXG4gICAgICogQHBhcmFtIHs/fSBfb3ZlcmxheVBvc1xuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdwb3J0UnVsZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KF9jb25uZWN0ZWRUbywgX29yaWdpblBvcywgX292ZXJsYXlQb3MsIF92aWV3cG9ydFJ1bGVyKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZFRvID0gX2Nvbm5lY3RlZFRvO1xuICAgICAgICB0aGlzLl9vcmlnaW5Qb3MgPSBfb3JpZ2luUG9zO1xuICAgICAgICB0aGlzLl9vdmVybGF5UG9zID0gX292ZXJsYXlQb3M7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0UnVsZXIgPSBfdmlld3BvcnRSdWxlcjtcbiAgICAgICAgdGhpcy5fZGlyID0gJ2x0cic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIG92ZXJsYXkgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgeC1heGlzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vZmZzZXRYID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgb3ZlcmxheSBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB5LWF4aXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29mZnNldFkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFNjcm9sbGFibGUgY29udGFpbmVycyB1c2VkIHRvIGNoZWNrIHNjcm9sbGFibGUgdmlldyBwcm9wZXJ0aWVzIG9uIHBvc2l0aW9uIGNoYW5nZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9yZGVyZWQgbGlzdCBvZiBwcmVmZXJyZWQgcG9zaXRpb25zLCBmcm9tIG1vc3QgdG8gbGVhc3QgZGVzaXJhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zID0gW107XG4gICAgICAgIHRoaXMuX29uUG9zaXRpb25DaGFuZ2UgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl9vcmlnaW4gPSB0aGlzLl9jb25uZWN0ZWRUby5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLndpdGhGYWxsYmFja1Bvc2l0aW9uKF9vcmlnaW5Qb3MsIF9vdmVybGF5UG9zKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLCBcIl9pc1J0bFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gUlRMIGNvbnRleHRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpciA9PT0gJ3J0bCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZSwgXCJvblBvc2l0aW9uQ2hhbmdlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIGNvbm5lY3Rpb24gcG9pbnQgY2hhbmdlcy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uUG9zaXRpb25DaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZSwgXCJwb3NpdGlvbnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogT3JkZXJlZCBsaXN0IG9mIHByZWZlcnJlZCBwb3NpdGlvbnMsIGZyb20gbW9zdCB0byBsZWFzdCBkZXNpcmFibGUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVmZXJyZWRQb3NpdGlvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRvIGJlIHVzZWQgdG8gZm9yIGFueSBjbGVhbnVwIGFmdGVyIHRoZSBlbGVtZW50IGdldHMgZGVzdHJveWVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheSBlbGVtZW50LCB1c2luZyB3aGljaGV2ZXIgcHJlZmVycmVkIHBvc2l0aW9uIHJlbGF0aXZlXG4gICAgICogdG8gdGhlIG9yaWdpbiBmaXRzIG9uLXNjcmVlbi5cbiAgICAgKiBcXEBkb2NzLXByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBFbGVtZW50IHRvIHdoaWNoIHRvIGFwcGx5IHRoZSBDU1Mgc3R5bGVzLlxuICAgICAqIEByZXR1cm4gez99IFJlc29sdmVzIHdoZW4gdGhlIHN0eWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIENhY2hlIHRoZSBvdmVybGF5IHBhbmUgZWxlbWVudCBpbiBjYXNlIHJlLWNhbGN1bGF0aW5nIHBvc2l0aW9uIGlzIG5lY2Vzc2FyeVxuICAgICAgICB0aGlzLl9wYW5lID0gZWxlbWVudDtcbiAgICAgICAgLy8gV2UgbmVlZCB0aGUgYm91bmRpbmcgcmVjdHMgZm9yIHRoZSBvcmlnaW4gYW5kIHRoZSBvdmVybGF5IHRvIGRldGVybWluZSBob3cgdG8gcG9zaXRpb25cbiAgICAgICAgLy8gdGhlIG92ZXJsYXkgcmVsYXRpdmUgdG8gdGhlIG9yaWdpbi5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luUmVjdCA9IHRoaXMuX29yaWdpbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3ZlcmxheVJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAvLyBXZSB1c2UgdGhlIHZpZXdwb3J0IHJlY3QgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwb3NpdGlvbiB3b3VsZCBnbyBvZmYtc2NyZWVuLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3cG9ydFJlY3QgPSB0aGlzLl92aWV3cG9ydFJ1bGVyLmdldFZpZXdwb3J0UmVjdCgpO1xuICAgICAgICAvLyBGYWxsYmFjayBwb2ludCBpZiBub25lIG9mIHRoZSBmYWxsYmFja3MgZml0IGludG8gdGhlIHZpZXdwb3J0LlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmYWxsYmFja1BvaW50ID0gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmFsbGJhY2tQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gcGxhY2UgdGhlIG92ZXJsYXkgaW4gdGhlIGZpcnN0IG9mIHRoZSBwcmVmZXJyZWQgcG9zaXRpb25zIHN1Y2ggdGhhdCB0aGVcbiAgICAgICAgLy8gb3ZlcmxheSBmaXRzIG9uLXNjcmVlbi5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3ByZWZlcnJlZFBvc2l0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBfYVtfaV07XG4gICAgICAgICAgICAvLyBHZXQgdGhlICh4LCB5KSBwb2ludCBvZiBjb25uZWN0aW9uIG9uIHRoZSBvcmlnaW4sIGFuZCB0aGVuIHVzZSB0aGF0IHRvIGdldCB0aGVcbiAgICAgICAgICAgIC8vICh0b3AsIGxlZnQpIGNvb3JkaW5hdGUgZm9yIHRoZSBvdmVybGF5IGF0IGBwb3NgLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luUG9pbnQgPSB0aGlzLl9nZXRPcmlnaW5Db25uZWN0aW9uUG9pbnQob3JpZ2luUmVjdCwgcG9zKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlQb2ludCA9IHRoaXMuX2dldE92ZXJsYXlQb2ludChvcmlnaW5Qb2ludCwgb3ZlcmxheVJlY3QsIHZpZXdwb3J0UmVjdCwgcG9zKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvdmVybGF5IGluIHRoZSBjYWxjdWxhdGVkIHBvc2l0aW9uIGZpdHMgb24tc2NyZWVuLCBwdXQgaXQgdGhlcmUgYW5kIHdlJ3JlIGRvbmUuXG4gICAgICAgICAgICBpZiAob3ZlcmxheVBvaW50LmZpdHNJblZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFBvc2l0aW9uKGVsZW1lbnQsIG92ZXJsYXlSZWN0LCBvdmVybGF5UG9pbnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbGFzdCBjb25uZWN0ZWQgcG9zaXRpb24gaW4gY2FzZSB0aGUgcG9zaXRpb24gbmVlZHMgdG8gYmUgcmUtY2FsY3VsYXRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0Q29ubmVjdGVkUG9zaXRpb24gPSBwb3M7XG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IHRoYXQgdGhlIHBvc2l0aW9uIGhhcyBiZWVuIGNoYW5nZWQgYWxvbmcgd2l0aCBpdHMgY2hhbmdlIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzID0gdGhpcy5nZXRTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zaXRpb25DaGFuZ2UgPSBuZXcgQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlKHBvcywgc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblBvc2l0aW9uQ2hhbmdlLm5leHQocG9zaXRpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmFsbGJhY2tQb2ludCB8fCBmYWxsYmFja1BvaW50LnZpc2libGVBcmVhIDwgb3ZlcmxheVBvaW50LnZpc2libGVBcmVhKSB7XG4gICAgICAgICAgICAgICAgZmFsbGJhY2tQb2ludCA9IG92ZXJsYXlQb2ludDtcbiAgICAgICAgICAgICAgICBmYWxsYmFja1Bvc2l0aW9uID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIHByZWZlcnJlZCBwb3NpdGlvbnMgd2VyZSBpbiB0aGUgdmlld3BvcnQsIHRha2UgdGhlIG9uZVxuICAgICAgICAvLyB3aXRoIHRoZSBsYXJnZXN0IHZpc2libGUgYXJlYS5cbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudFBvc2l0aW9uKGVsZW1lbnQsIG92ZXJsYXlSZWN0LCBmYWxsYmFja1BvaW50LCBmYWxsYmFja1Bvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgcmUtYWxpZ25zIHRoZSBvdmVybGF5IGVsZW1lbnQgd2l0aCB0aGUgdHJpZ2dlciBpbiBpdHMgbGFzdCBjYWxjdWxhdGVkIHBvc2l0aW9uLFxuICAgICAqIGV2ZW4gaWYgYSBwb3NpdGlvbiBoaWdoZXIgaW4gdGhlIFwicHJlZmVycmVkIHBvc2l0aW9uc1wiIGxpc3Qgd291bGQgbm93IGZpdC4gVGhpc1xuICAgICAqIGFsbG93cyBvbmUgdG8gcmUtYWxpZ24gdGhlIHBhbmVsIHdpdGhvdXQgY2hhbmdpbmcgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwYW5lbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnJlY2FsY3VsYXRlTGFzdFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5SZWN0ID0gdGhpcy5fb3JpZ2luLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5UmVjdCA9IHRoaXMuX3BhbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdwb3J0UmVjdCA9IHRoaXMuX3ZpZXdwb3J0UnVsZXIuZ2V0Vmlld3BvcnRSZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RQb3NpdGlvbiA9IHRoaXMuX2xhc3RDb25uZWN0ZWRQb3NpdGlvbiB8fCB0aGlzLl9wcmVmZXJyZWRQb3NpdGlvbnNbMF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpblBvaW50ID0gdGhpcy5fZ2V0T3JpZ2luQ29ubmVjdGlvblBvaW50KG9yaWdpblJlY3QsIGxhc3RQb3NpdGlvbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlQb2ludCA9IHRoaXMuX2dldE92ZXJsYXlQb2ludChvcmlnaW5Qb2ludCwgb3ZlcmxheVJlY3QsIHZpZXdwb3J0UmVjdCwgbGFzdFBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudFBvc2l0aW9uKHRoaXMuX3BhbmUsIG92ZXJsYXlSZWN0LCBvdmVybGF5UG9pbnQsIGxhc3RQb3NpdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IG9mIFNjcm9sbGFibGUgY29udGFpbmVycyB0aGF0IGhvc3QgdGhlIG9yaWdpbiBlbGVtZW50IHNvIHRoYXRcbiAgICAgKiBvbiByZXBvc2l0aW9uIHdlIGNhbiBldmFsdWF0ZSBpZiBpdCBvciB0aGUgb3ZlcmxheSBoYXMgYmVlbiBjbGlwcGVkIG9yIG91dHNpZGUgdmlldy4gRXZlcnlcbiAgICAgKiBTY3JvbGxhYmxlIG11c3QgYmUgYW4gYW5jZXN0b3IgZWxlbWVudCBvZiB0aGUgc3RyYXRlZ3kncyBvcmlnaW4gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IHNjcm9sbGFibGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS53aXRoU2Nyb2xsYWJsZUNvbnRhaW5lcnMgPSBmdW5jdGlvbiAoc2Nyb2xsYWJsZXMpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlcyA9IHNjcm9sbGFibGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBwcmVmZXJyZWQgZmFsbGJhY2sgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW5Qb3NcbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlQb3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLndpdGhGYWxsYmFja1Bvc2l0aW9uID0gZnVuY3Rpb24gKG9yaWdpblBvcywgb3ZlcmxheVBvcykge1xuICAgICAgICB0aGlzLl9wcmVmZXJyZWRQb3NpdGlvbnMucHVzaChuZXcgQ29ubmVjdGlvblBvc2l0aW9uUGFpcihvcmlnaW5Qb3MsIG92ZXJsYXlQb3MpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsYXlvdXQgZGlyZWN0aW9uIHNvIHRoZSBvdmVybGF5J3MgcG9zaXRpb24gY2FuIGJlIGFkanVzdGVkIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7P30gZGlyIE5ldyBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUud2l0aERpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgdGhpcy5fZGlyID0gZGlyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYW4gb2Zmc2V0IGZvciB0aGUgb3ZlcmxheSdzIGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHgtYXhpc1xuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0IE5ldyBvZmZzZXQgaW4gdGhlIFggYXhpcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLndpdGhPZmZzZXRYID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICB0aGlzLl9vZmZzZXRYID0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYW4gb2Zmc2V0IGZvciB0aGUgb3ZlcmxheSdzIGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHktYXhpc1xuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0IE5ldyBvZmZzZXQgaW4gdGhlIFkgYXhpcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLndpdGhPZmZzZXRZID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICB0aGlzLl9vZmZzZXRZID0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhvcml6b250YWwgKHgpIFwic3RhcnRcIiBkaW1lbnNpb24gYmFzZWQgb24gd2hldGhlciB0aGUgb3ZlcmxheSBpcyBpbiBhbiBSVEwgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gez99IHJlY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRTdGFydFggPSBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNSdGwgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaG9yaXpvbnRhbCAoeCkgXCJlbmRcIiBkaW1lbnNpb24gYmFzZWQgb24gd2hldGhlciB0aGUgb3ZlcmxheSBpcyBpbiBhbiBSVEwgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gez99IHJlY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRFbmRYID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUnRsID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlICh4LCB5KSBjb29yZGluYXRlIG9mIGEgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgb3JpZ2luIGJhc2VkIG9uIGEgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW5SZWN0XG4gICAgICogQHBhcmFtIHs/fSBwb3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRPcmlnaW5Db25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbiAob3JpZ2luUmVjdCwgcG9zKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpblN0YXJ0WCA9IHRoaXMuX2dldFN0YXJ0WChvcmlnaW5SZWN0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luRW5kWCA9IHRoaXMuX2dldEVuZFgob3JpZ2luUmVjdCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHg7XG4gICAgICAgIGlmIChwb3Mub3JpZ2luWCA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgeCA9IG9yaWdpblN0YXJ0WCArIChvcmlnaW5SZWN0LndpZHRoIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gcG9zLm9yaWdpblggPT0gJ3N0YXJ0JyA/IG9yaWdpblN0YXJ0WCA6IG9yaWdpbkVuZFg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geTtcbiAgICAgICAgaWYgKHBvcy5vcmlnaW5ZID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB5ID0gb3JpZ2luUmVjdC50b3AgKyAob3JpZ2luUmVjdC5oZWlnaHQgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHkgPSBwb3Mub3JpZ2luWSA9PSAndG9wJyA/IG9yaWdpblJlY3QudG9wIDogb3JpZ2luUmVjdC5ib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgKHgsIHkpIGNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgb3ZlcmxheSBnaXZlbiBhIGdpdmVuIHBvc2l0aW9uIGFuZFxuICAgICAqIG9yaWdpbiBwb2ludCB0byB3aGljaCB0aGUgb3ZlcmxheSBzaG91bGQgYmUgY29ubmVjdGVkLCBhcyB3ZWxsIGFzIGhvdyBtdWNoIG9mIHRoZSBlbGVtZW50XG4gICAgICogd291bGQgYmUgaW5zaWRlIHRoZSB2aWV3cG9ydCBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luUG9pbnRcbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlSZWN0XG4gICAgICogQHBhcmFtIHs/fSB2aWV3cG9ydFJlY3RcbiAgICAgKiBAcGFyYW0gez99IHBvc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuX2dldE92ZXJsYXlQb2ludCA9IGZ1bmN0aW9uIChvcmlnaW5Qb2ludCwgb3ZlcmxheVJlY3QsIHZpZXdwb3J0UmVjdCwgcG9zKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgKG92ZXJsYXlTdGFydFgsIG92ZXJsYXlTdGFydFkpLCB0aGUgc3RhcnQgb2YgdGhlIHBvdGVudGlhbCBvdmVybGF5IHBvc2l0aW9uXG4gICAgICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW4gcG9pbnQuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlTdGFydFg7XG4gICAgICAgIGlmIChwb3Mub3ZlcmxheVggPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFggPSAtb3ZlcmxheVJlY3Qud2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcy5vdmVybGF5WCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgb3ZlcmxheVN0YXJ0WCA9IHRoaXMuX2lzUnRsID8gLW92ZXJsYXlSZWN0LndpZHRoIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFggPSB0aGlzLl9pc1J0bCA/IDAgOiAtb3ZlcmxheVJlY3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3ZlcmxheVN0YXJ0WTtcbiAgICAgICAgaWYgKHBvcy5vdmVybGF5WSA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgb3ZlcmxheVN0YXJ0WSA9IC1vdmVybGF5UmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3ZlcmxheVN0YXJ0WSA9IHBvcy5vdmVybGF5WSA9PSAndG9wJyA/IDAgOiAtb3ZlcmxheVJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSAoeCwgeSkgY29vcmRpbmF0ZXMgb2YgdGhlIG92ZXJsYXkuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHggPSBvcmlnaW5Qb2ludC54ICsgb3ZlcmxheVN0YXJ0WCArIHRoaXMuX29mZnNldFg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHkgPSBvcmlnaW5Qb2ludC55ICsgb3ZlcmxheVN0YXJ0WSArIHRoaXMuX29mZnNldFk7XG4gICAgICAgIC8vIEhvdyBtdWNoIHRoZSBvdmVybGF5IHdvdWxkIG92ZXJmbG93IGF0IHRoaXMgcG9zaXRpb24sIG9uIGVhY2ggc2lkZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVmdE92ZXJmbG93ID0gMCAtIHg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0T3ZlcmZsb3cgPSAoeCArIG92ZXJsYXlSZWN0LndpZHRoKSAtIHZpZXdwb3J0UmVjdC53aWR0aDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9wT3ZlcmZsb3cgPSAwIC0geTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm90dG9tT3ZlcmZsb3cgPSAoeSArIG92ZXJsYXlSZWN0LmhlaWdodCkgLSB2aWV3cG9ydFJlY3QuaGVpZ2h0O1xuICAgICAgICAvLyBWaXNpYmxlIHBhcnRzIG9mIHRoZSBlbGVtZW50IG9uIGVhY2ggYXhpcy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaWJsZVdpZHRoID0gdGhpcy5fc3VidHJhY3RPdmVyZmxvd3Mob3ZlcmxheVJlY3Qud2lkdGgsIGxlZnRPdmVyZmxvdywgcmlnaHRPdmVyZmxvdyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2libGVIZWlnaHQgPSB0aGlzLl9zdWJ0cmFjdE92ZXJmbG93cyhvdmVybGF5UmVjdC5oZWlnaHQsIHRvcE92ZXJmbG93LCBib3R0b21PdmVyZmxvdyk7XG4gICAgICAgIC8vIFRoZSBhcmVhIG9mIHRoZSBlbGVtZW50IHRoYXQncyB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpYmxlQXJlYSA9IHZpc2libGVXaWR0aCAqIHZpc2libGVIZWlnaHQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpdHNJblZpZXdwb3J0ID0gKG92ZXJsYXlSZWN0LndpZHRoICogb3ZlcmxheVJlY3QuaGVpZ2h0KSA9PT0gdmlzaWJsZUFyZWE7XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHksIGZpdHNJblZpZXdwb3J0OiBmaXRzSW5WaWV3cG9ydCwgdmlzaWJsZUFyZWE6IHZpc2libGVBcmVhIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3IHByb3BlcnRpZXMgb2YgdGhlIHRyaWdnZXIgYW5kIG92ZXJsYXksIGluY2x1ZGluZyB3aGV0aGVyIHRoZXkgYXJlIGNsaXBwZWRcbiAgICAgKiBvciBjb21wbGV0ZWx5IG91dHNpZGUgdGhlIHZpZXcgb2YgYW55IG9mIHRoZSBzdHJhdGVneSdzIHNjcm9sbGFibGVzLlxuICAgICAqIEBwYXJhbSB7P30gb3ZlcmxheVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuZ2V0U2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luQm91bmRzID0gdGhpcy5fZ2V0RWxlbWVudEJvdW5kcyh0aGlzLl9vcmlnaW4pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5Qm91bmRzID0gdGhpcy5fZ2V0RWxlbWVudEJvdW5kcyhvdmVybGF5KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2Nyb2xsQ29udGFpbmVyQm91bmRzID0gdGhpcy5zY3JvbGxhYmxlcy5tYXAoZnVuY3Rpb24gKHNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ2V0RWxlbWVudEJvdW5kcyhzY3JvbGxhYmxlLmdldEVsZW1lbnRSZWYoKS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc09yaWdpbkNsaXBwZWQ6IHRoaXMuaXNFbGVtZW50Q2xpcHBlZChvcmlnaW5Cb3VuZHMsIHNjcm9sbENvbnRhaW5lckJvdW5kcyksXG4gICAgICAgICAgICBpc09yaWdpbk91dHNpZGVWaWV3OiB0aGlzLmlzRWxlbWVudE91dHNpZGVWaWV3KG9yaWdpbkJvdW5kcywgc2Nyb2xsQ29udGFpbmVyQm91bmRzKSxcbiAgICAgICAgICAgIGlzT3ZlcmxheUNsaXBwZWQ6IHRoaXMuaXNFbGVtZW50Q2xpcHBlZChvdmVybGF5Qm91bmRzLCBzY3JvbGxDb250YWluZXJCb3VuZHMpLFxuICAgICAgICAgICAgaXNPdmVybGF5T3V0c2lkZVZpZXc6IHRoaXMuaXNFbGVtZW50T3V0c2lkZVZpZXcob3ZlcmxheUJvdW5kcywgc2Nyb2xsQ29udGFpbmVyQm91bmRzKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgY29tcGxldGVseSBvdXQgb2YgdGhlIHZpZXcgb2YgYW55IG9mIHRoZSBjb250YWluZXJzLlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudEJvdW5kc1xuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyc0JvdW5kc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuaXNFbGVtZW50T3V0c2lkZVZpZXcgPSBmdW5jdGlvbiAoZWxlbWVudEJvdW5kcywgY29udGFpbmVyc0JvdW5kcykge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyc0JvdW5kcy5zb21lKGZ1bmN0aW9uIChjb250YWluZXJCb3VuZHMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHNpZGVBYm92ZSA9IGVsZW1lbnRCb3VuZHMuYm90dG9tIDwgY29udGFpbmVyQm91bmRzLnRvcDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHNpZGVCZWxvdyA9IGVsZW1lbnRCb3VuZHMudG9wID4gY29udGFpbmVyQm91bmRzLmJvdHRvbTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHNpZGVMZWZ0ID0gZWxlbWVudEJvdW5kcy5yaWdodCA8IGNvbnRhaW5lckJvdW5kcy5sZWZ0O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0c2lkZVJpZ2h0ID0gZWxlbWVudEJvdW5kcy5sZWZ0ID4gY29udGFpbmVyQm91bmRzLnJpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIG91dHNpZGVBYm92ZSB8fCBvdXRzaWRlQmVsb3cgfHwgb3V0c2lkZUxlZnQgfHwgb3V0c2lkZVJpZ2h0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgY2xpcHBlZCBieSBhbnkgb2YgdGhlIGNvbnRhaW5lcnMuXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50Qm91bmRzXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJzQm91bmRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5pc0VsZW1lbnRDbGlwcGVkID0gZnVuY3Rpb24gKGVsZW1lbnRCb3VuZHMsIGNvbnRhaW5lcnNCb3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcnNCb3VuZHMuc29tZShmdW5jdGlvbiAoY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGlwcGVkQWJvdmUgPSBlbGVtZW50Qm91bmRzLnRvcCA8IGNvbnRhaW5lckJvdW5kcy50b3A7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGlwcGVkQmVsb3cgPSBlbGVtZW50Qm91bmRzLmJvdHRvbSA+IGNvbnRhaW5lckJvdW5kcy5ib3R0b207XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGlwcGVkTGVmdCA9IGVsZW1lbnRCb3VuZHMubGVmdCA8IGNvbnRhaW5lckJvdW5kcy5sZWZ0O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xpcHBlZFJpZ2h0ID0gZWxlbWVudEJvdW5kcy5yaWdodCA+IGNvbnRhaW5lckJvdW5kcy5yaWdodDtcbiAgICAgICAgICAgIHJldHVybiBjbGlwcGVkQWJvdmUgfHwgY2xpcHBlZEJlbG93IHx8IGNsaXBwZWRMZWZ0IHx8IGNsaXBwZWRSaWdodDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQaHlzaWNhbGx5IHBvc2l0aW9ucyB0aGUgb3ZlcmxheSBlbGVtZW50IHRvIHRoZSBnaXZlbiBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gb3ZlcmxheVJlY3RcbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlQb2ludFxuICAgICAqIEBwYXJhbSB7P30gcG9zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fc2V0RWxlbWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIG92ZXJsYXlSZWN0LCBvdmVybGF5UG9pbnQsIHBvcykge1xuICAgICAgICAvLyBXZSB3YW50IHRvIHNldCBlaXRoZXIgYHRvcGAgb3IgYGJvdHRvbWAgYmFzZWQgb24gd2hldGhlciB0aGUgb3ZlcmxheSB3YW50cyB0byBhcHBlYXIgYWJvdmVcbiAgICAgICAgLy8gb3IgYmVsb3cgdGhlIG9yaWdpbiBhbmQgdGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgZWxlbWVudCB3aWxsIGV4cGFuZC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmVydGljYWxTdHlsZVByb3BlcnR5ID0gcG9zLm92ZXJsYXlZID09PSAnYm90dG9tJyA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgYGJvdHRvbWAsIHdlIGFkanVzdCB0aGUgeSBwb3NpdGlvbiBzdWNoIHRoYXQgaXQgaXMgdGhlIGRpc3RhbmNlXG4gICAgICAgIC8vIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgdmlld3BvcnQgcmF0aGVyIHRoYW4gdGhlIHRvcC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geSA9IHZlcnRpY2FsU3R5bGVQcm9wZXJ0eSA9PT0gJ3RvcCcgP1xuICAgICAgICAgICAgb3ZlcmxheVBvaW50LnkgOlxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAtIChvdmVybGF5UG9pbnQueSArIG92ZXJsYXlSZWN0LmhlaWdodCk7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gc2V0IGVpdGhlciBgbGVmdGAgb3IgYHJpZ2h0YCBiYXNlZCBvbiB3aGV0aGVyIHRoZSBvdmVybGF5IHdhbnRzIHRvIGFwcGVhciBcImJlZm9yZVwiXG4gICAgICAgIC8vIG9yIFwiYWZ0ZXJcIiB0aGUgb3JpZ2luLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIGVsZW1lbnQgd2lsbCBleHBhbmQuXG4gICAgICAgIC8vIEZvciB0aGUgaG9yaXpvbnRhbCBheGlzLCB0aGUgbWVhbmluZyBvZiBcImJlZm9yZVwiIGFuZCBcImFmdGVyXCIgY2hhbmdlIGJhc2VkIG9uIHdoZXRoZXIgdGhlXG4gICAgICAgIC8vIHBhZ2UgaXMgaW4gUlRMIG9yIExUUi5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9yaXpvbnRhbFN0eWxlUHJvcGVydHk7XG4gICAgICAgIGlmICh0aGlzLl9kaXIgPT09ICdydGwnKSB7XG4gICAgICAgICAgICBob3Jpem9udGFsU3R5bGVQcm9wZXJ0eSA9IHBvcy5vdmVybGF5WCA9PT0gJ2VuZCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9yaXpvbnRhbFN0eWxlUHJvcGVydHkgPSBwb3Mub3ZlcmxheVggPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHdlJ3JlIHNldHRpbmcgYHJpZ2h0YCwgd2UgYWRqdXN0IHRoZSB4IHBvc2l0aW9uIHN1Y2ggdGhhdCBpdCBpcyB0aGUgZGlzdGFuY2VcbiAgICAgICAgLy8gZnJvbSB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgdmlld3BvcnQgcmF0aGVyIHRoYW4gdGhlIGxlZnQgZWRnZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geCA9IGhvcml6b250YWxTdHlsZVByb3BlcnR5ID09PSAnbGVmdCcgP1xuICAgICAgICAgICAgb3ZlcmxheVBvaW50LnggOlxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gKG92ZXJsYXlQb2ludC54ICsgb3ZlcmxheVJlY3Qud2lkdGgpO1xuICAgICAgICAvLyBSZXNldCBhbnkgZXhpc3Rpbmcgc3R5bGVzLiBUaGlzIGlzIG5lY2Vzc2FyeSBpbiBjYXNlIHRoZSBwcmVmZXJyZWQgcG9zaXRpb24gaGFzXG4gICAgICAgIC8vIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYGFwcGx5YC5cbiAgICAgICAgWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBlbGVtZW50LnN0eWxlW3BdID0gbnVsbDsgfSk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbdmVydGljYWxTdHlsZVByb3BlcnR5XSA9IHkgKyBcInB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbaG9yaXpvbnRhbFN0eWxlUHJvcGVydHldID0geCArIFwicHhcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIHBvc2l0aW9ucyBvZiB0aGUgcHJvdmlkZWQgZWxlbWVudCB3aXRoIHJlc3BlY3QgdG8gdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuX2dldEVsZW1lbnRCb3VuZHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib3VuZGluZ0NsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBib3VuZGluZ0NsaWVudFJlY3QudG9wLFxuICAgICAgICAgICAgcmlnaHQ6IGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0ICsgYm91bmRpbmdDbGllbnRSZWN0LndpZHRoLFxuICAgICAgICAgICAgYm90dG9tOiBib3VuZGluZ0NsaWVudFJlY3QudG9wICsgYm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIGFtb3VudCB0aGF0IGFuIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgb24gYW4gYXhpcyBmcm9tIGl0J3MgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7P30gbGVuZ3RoXG4gICAgICogQHBhcmFtIHsuLi4/fSBvdmVyZmxvd3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9zdWJ0cmFjdE92ZXJmbG93cyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIG92ZXJmbG93cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgb3ZlcmZsb3dzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdmVyZmxvd3MucmVkdWNlKGZ1bmN0aW9uIChjdXJyZW50VmFsdWUsIGN1cnJlbnRPdmVyZmxvdykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSAtIE1hdGgubWF4KGN1cnJlbnRPdmVyZmxvdywgMCk7XG4gICAgICAgIH0sIGxlbmd0aCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneTtcbn0oKSk7XG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIHBvc2l0aW9uaW5nIG92ZXJsYXlzLiBVc2luZyB0aGlzIHN0cmF0ZWd5LCBhbiBvdmVybGF5IGlzIGdpdmVuIGFuXG4gKiBleHBsaWNpdCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYnJvd3NlcidzIHZpZXdwb3J0LiBXZSB1c2UgZmxleGJveCwgaW5zdGVhZCBvZlxuICogdHJhbnNmb3JtcywgaW4gb3JkZXIgdG8gYXZvaWQgaXNzdWVzIHdpdGggc3VicGl4ZWwgcmVuZGVyaW5nIHdoaWNoIGNhbiBjYXVzZSB0aGVcbiAqIGVsZW1lbnQgdG8gYmVjb21lIGJsdXJyeS5cbiAqL1xudmFyIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5KCkge1xuICAgICAgICB0aGlzLl9jc3NQb3NpdGlvbiA9ICdzdGF0aWMnO1xuICAgICAgICB0aGlzLl90b3BPZmZzZXQgPSAnJztcbiAgICAgICAgdGhpcy5fYm90dG9tT2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX2xlZnRPZmZzZXQgPSAnJztcbiAgICAgICAgdGhpcy5fcmlnaHRPZmZzZXQgPSAnJztcbiAgICAgICAgdGhpcy5fYWxpZ25JdGVtcyA9ICcnO1xuICAgICAgICB0aGlzLl9qdXN0aWZ5Q29udGVudCA9ICcnO1xuICAgICAgICB0aGlzLl93aWR0aCA9ICcnO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5LiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IHZlcnRpY2FsIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWUgTmV3IHRvcCBvZmZzZXQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS50b3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYm90dG9tT2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX3RvcE9mZnNldCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9hbGlnbkl0ZW1zID0gJ2ZsZXgtc3RhcnQnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkuIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlIE5ldyBsZWZ0IG9mZnNldC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmxlZnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmlnaHRPZmZzZXQgPSAnJztcbiAgICAgICAgdGhpcy5fbGVmdE9mZnNldCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9qdXN0aWZ5Q29udGVudCA9ICdmbGV4LXN0YXJ0JztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib3R0b20gcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkuIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgdmVydGljYWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZSBOZXcgYm90dG9tIG9mZnNldC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmJvdHRvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl90b3BPZmZzZXQgPSAnJztcbiAgICAgICAgdGhpcy5fYm90dG9tT2Zmc2V0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXMgPSAnZmxleC1lbmQnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5LiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IGhvcml6b250YWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZSBOZXcgcmlnaHQgb2Zmc2V0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUucmlnaHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbGVmdE9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl9yaWdodE9mZnNldCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9qdXN0aWZ5Q29udGVudCA9ICdmbGV4LWVuZCc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3ZlcmxheSB3aWR0aCBhbmQgY2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCB3aWR0aC5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlIE5ldyB3aWR0aCBmb3IgdGhlIG92ZXJsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIC8vIFdoZW4gdGhlIHdpZHRoIGlzIDEwMCUsIHdlIHNob3VsZCByZXNldCB0aGUgYGxlZnRgIGFuZCB0aGUgb2Zmc2V0LFxuICAgICAgICAvLyBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCB0aGUgZWxlbWVudCBpcyBmbHVzaCBhZ2FpbnN0IHRoZSB2aWV3cG9ydCBlZGdlLlxuICAgICAgICBpZiAodmFsdWUgPT09ICcxMDAlJykge1xuICAgICAgICAgICAgdGhpcy5sZWZ0KCcwcHgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG92ZXJsYXkgaGVpZ2h0IGFuZCBjbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IGhlaWdodC5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlIE5ldyBoZWlnaHQgZm9yIHRoZSBvdmVybGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgIC8vIFdoZW4gdGhlIGhlaWdodCBpcyAxMDAlLCB3ZSBzaG91bGQgcmVzZXQgdGhlIGB0b3BgIGFuZCB0aGUgb2Zmc2V0LFxuICAgICAgICAvLyBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCB0aGUgZWxlbWVudCBpcyBmbHVzaCBhZ2FpbnN0IHRoZSB2aWV3cG9ydCBlZGdlLlxuICAgICAgICBpZiAodmFsdWUgPT09ICcxMDAlJykge1xuICAgICAgICAgICAgdGhpcy50b3AoJzBweCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2VudGVycyB0aGUgb3ZlcmxheSBob3Jpem9udGFsbHkgd2l0aCBhbiBvcHRpb25hbCBvZmZzZXQuXG4gICAgICogQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCBob3Jpem9udGFsIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/PX0gb2Zmc2V0IE92ZXJsYXkgb2Zmc2V0IGZyb20gdGhlIGhvcml6b250YWwgY2VudGVyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuY2VudGVySG9yaXpvbnRhbGx5ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gJyc7IH1cbiAgICAgICAgdGhpcy5sZWZ0KG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2p1c3RpZnlDb250ZW50ID0gJ2NlbnRlcic7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2VudGVycyB0aGUgb3ZlcmxheSB2ZXJ0aWNhbGx5IHdpdGggYW4gb3B0aW9uYWwgb2Zmc2V0LlxuICAgICAqIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgdmVydGljYWwgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez89fSBvZmZzZXQgT3ZlcmxheSBvZmZzZXQgZnJvbSB0aGUgdmVydGljYWwgY2VudGVyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuY2VudGVyVmVydGljYWxseSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9ICcnOyB9XG4gICAgICAgIHRoaXMudG9wKG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXMgPSAnY2VudGVyJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIGVsZW1lbnQuXG4gICAgICogXFxAZG9jcy1wcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgRWxlbWVudCB0byB3aGljaCB0byBhcHBseSB0aGUgQ1NTLlxuICAgICAqIEByZXR1cm4gez99IFJlc29sdmVkIHdoZW4gdGhlIHN0eWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fd3JhcHBlcikge1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdjZGstZ2xvYmFsLW92ZXJsYXktd3JhcHBlcicpO1xuICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl93cmFwcGVyLCBlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gZWxlbWVudC5zdHlsZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50U3R5bGVzID0gKChlbGVtZW50LnBhcmVudE5vZGUpKS5zdHlsZTtcbiAgICAgICAgc3R5bGVzLnBvc2l0aW9uID0gdGhpcy5fY3NzUG9zaXRpb247XG4gICAgICAgIHN0eWxlcy5tYXJnaW5Ub3AgPSB0aGlzLl90b3BPZmZzZXQ7XG4gICAgICAgIHN0eWxlcy5tYXJnaW5MZWZ0ID0gdGhpcy5fbGVmdE9mZnNldDtcbiAgICAgICAgc3R5bGVzLm1hcmdpbkJvdHRvbSA9IHRoaXMuX2JvdHRvbU9mZnNldDtcbiAgICAgICAgc3R5bGVzLm1hcmdpblJpZ2h0ID0gdGhpcy5fcmlnaHRPZmZzZXQ7XG4gICAgICAgIHN0eWxlcy53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICBzdHlsZXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICBwYXJlbnRTdHlsZXMuanVzdGlmeUNvbnRlbnQgPSB0aGlzLl9qdXN0aWZ5Q29udGVudDtcbiAgICAgICAgcGFyZW50U3R5bGVzLmFsaWduSXRlbXMgPSB0aGlzLl9hbGlnbkl0ZW1zO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgd3JhcHBlciBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93cmFwcGVyICYmIHRoaXMuX3dyYXBwZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3dyYXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5O1xufSgpKTtcbi8qKlxuICogQnVpbGRlciBmb3Igb3ZlcmxheSBwb3NpdGlvbiBzdHJhdGVneS5cbiAqL1xudmFyIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF92aWV3cG9ydFJ1bGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gT3ZlcmxheVBvc2l0aW9uQnVpbGRlcihfdmlld3BvcnRSdWxlcikge1xuICAgICAgICB0aGlzLl92aWV3cG9ydFJ1bGVyID0gX3ZpZXdwb3J0UnVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBnbG9iYWwgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UG9zaXRpb25CdWlsZGVyLnByb3RvdHlwZS5nbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2xvYmFsUG9zaXRpb25TdHJhdGVneSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlbGF0aXZlIHBvc2l0aW9uIHN0cmF0ZWd5LlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luUG9zXG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5UG9zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UG9zaXRpb25CdWlsZGVyLnByb3RvdHlwZS5jb25uZWN0ZWRUbyA9IGZ1bmN0aW9uIChlbGVtZW50UmVmLCBvcmlnaW5Qb3MsIG92ZXJsYXlQb3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KGVsZW1lbnRSZWYsIG9yaWdpblBvcywgb3ZlcmxheVBvcywgdGhpcy5fdmlld3BvcnRSdWxlcik7XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcmxheVBvc2l0aW9uQnVpbGRlcjtcbn0oKSk7XG5PdmVybGF5UG9zaXRpb25CdWlsZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5PdmVybGF5UG9zaXRpb25CdWlsZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVmlld3BvcnRSdWxlciwgfSxcbl07IH07XG4vKipcbiAqIFRoZSBPdmVybGF5Q29udGFpbmVyIGlzIHRoZSBjb250YWluZXIgaW4gd2hpY2ggYWxsIG92ZXJsYXlzIHdpbGwgbG9hZC5cbiAqIEl0IHNob3VsZCBiZSBwcm92aWRlZCBpbiB0aGUgcm9vdCBjb21wb25lbnQgdG8gZW5zdXJlIGl0IGlzIHByb3Blcmx5IHNoYXJlZC5cbiAqL1xudmFyIE92ZXJsYXlDb250YWluZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5Q29udGFpbmVyKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3ZlcmxheUNvbnRhaW5lci5wcm90b3R5cGUsIFwidGhlbWVDbGFzc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYXNlIHRoZW1lIHRvIGJlIGFwcGxpZWQgdG8gYWxsIG92ZXJsYXktYmFzZWQgY29tcG9uZW50cy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdGhlbWVDbGFzczsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl90aGVtZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90aGVtZUNsYXNzID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIG92ZXJsYXkgY29udGFpbmVyIGVsZW1lbnQuICBJdCB3aWxsIGxhemlseVxuICAgICAqIGNyZWF0ZSB0aGUgZWxlbWVudCB0aGUgZmlyc3QgdGltZSAgaXQgaXMgY2FsbGVkIHRvIGZhY2lsaXRhdGUgdXNpbmdcbiAgICAgKiB0aGUgY29udGFpbmVyIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgICAgKiBAcmV0dXJuIHs/fSB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKi9cbiAgICBPdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5nZXRDb250YWluZXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXJFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBvdmVybGF5IGNvbnRhaW5lciBlbGVtZW50LCB3aGljaCBpcyBzaW1wbHkgYSBkaXZcbiAgICAgKiB3aXRoIHRoZSAnY2RrLW92ZXJsYXktY29udGFpbmVyJyBjbGFzcyBvbiB0aGUgZG9jdW1lbnQgYm9keS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlDb250YWluZXIucHJvdG90eXBlLl9jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnY2RrLW92ZXJsYXktY29udGFpbmVyJyk7XG4gICAgICAgIGlmICh0aGlzLl90aGVtZUNsYXNzKSB7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLl90aGVtZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQgPSBjb250YWluZXI7XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcmxheUNvbnRhaW5lcjtcbn0oKSk7XG5PdmVybGF5Q29udGFpbmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5PdmVybGF5Q29udGFpbmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEBwYXJhbSB7P30gcGFyZW50Q29udGFpbmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudENvbnRhaW5lcikge1xuICAgIHJldHVybiBwYXJlbnRDb250YWluZXIgfHwgbmV3IE92ZXJsYXlDb250YWluZXIoKTtcbn1cbnZhciBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIE92ZXJsYXlDb250YWluZXIgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBPdmVybGF5Q29udGFpbmVyLFxuICAgIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBPdmVybGF5Q29udGFpbmVyXV0sXG4gICAgdXNlRmFjdG9yeTogT1ZFUkxBWV9DT05UQUlORVJfUFJPVklERVJfRkFDVE9SWVxufTtcbi8qKlxuICogTmV4dCBvdmVybGF5IHVuaXF1ZSBJRC5cbiAqL1xudmFyIG5leHRVbmlxdWVJZCA9IDA7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0YXRlIGZvciBuZXdseSBjcmVhdGVkIG92ZXJsYXlzLlxuICovXG52YXIgZGVmYXVsdFN0YXRlID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuLyoqXG4gKiBTZXJ2aWNlIHRvIGNyZWF0ZSBPdmVybGF5cy4gT3ZlcmxheXMgYXJlIGR5bmFtaWNhbGx5IGFkZGVkIHBpZWNlcyBvZiBmbG9hdGluZyBVSSwgbWVhbnQgdG8gYmVcbiAqIHVzZWQgYXMgYSBsb3ctbGV2ZWwgYnVpbGRpbmcgYnVpbGRpbmcgYmxvY2sgZm9yIG90aGVyIGNvbXBvbmVudHMuIERpYWxvZ3MsIHRvb2x0aXBzLCBtZW51cyxcbiAqIHNlbGVjdHMsIGV0Yy4gY2FuIGFsbCBiZSBidWlsdCB1c2luZyBvdmVybGF5cy4gVGhlIHNlcnZpY2Ugc2hvdWxkIHByaW1hcmlseSBiZSB1c2VkIGJ5IGF1dGhvcnNcbiAqIG9mIHJlLXVzYWJsZSBjb21wb25lbnRzIHJhdGhlciB0aGFuIGRldmVsb3BlcnMgYnVpbGRpbmcgZW5kLXVzZXIgYXBwbGljYXRpb25zLlxuICpcbiAqIEFuIG92ZXJsYXkgKmlzKiBhIFBvcnRhbEhvc3QsIHNvIGFueSBraW5kIG9mIFBvcnRhbCBjYW4gYmUgbG9hZGVkIGludG8gb25lLlxuICovXG52YXIgT3ZlcmxheSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX292ZXJsYXlDb250YWluZXJcbiAgICAgKiBAcGFyYW0gez99IF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IF9wb3NpdGlvbkJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gez99IF9hcHBSZWZcbiAgICAgKiBAcGFyYW0gez99IF9pbmplY3RvclxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE92ZXJsYXkoX292ZXJsYXlDb250YWluZXIsIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF9wb3NpdGlvbkJ1aWxkZXIsIF9hcHBSZWYsIF9pbmplY3RvciwgX25nWm9uZSkge1xuICAgICAgICB0aGlzLl9vdmVybGF5Q29udGFpbmVyID0gX292ZXJsYXlDb250YWluZXI7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQnVpbGRlciA9IF9wb3NpdGlvbkJ1aWxkZXI7XG4gICAgICAgIHRoaXMuX2FwcFJlZiA9IF9hcHBSZWY7XG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHs/PX0gc3RhdGUgU3RhdGUgdG8gYXBwbHkgdG8gdGhlIG92ZXJsYXkuXG4gICAgICogQHJldHVybiB7P30gUmVmZXJlbmNlIHRvIHRoZSBjcmVhdGVkIG92ZXJsYXkuXG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHN0YXRlJCQxKSB7XG4gICAgICAgIGlmIChzdGF0ZSQkMSA9PT0gdm9pZCAwKSB7IHN0YXRlJCQxID0gZGVmYXVsdFN0YXRlOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVPdmVybGF5UmVmKHRoaXMuX2NyZWF0ZVBhbmVFbGVtZW50KCksIHN0YXRlJCQxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwb3NpdGlvbiBidWlsZGVyIHRoYXQgY2FuIGJlIHVzZWQsIHZpYSBmbHVlbnQgQVBJLFxuICAgICAqIHRvIGNvbnN0cnVjdCBhbmQgY29uZmlndXJlIGEgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uQnVpbGRlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIERPTSBlbGVtZW50IGZvciBhbiBvdmVybGF5IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBvdmVybGF5IGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJuIHs/fSBOZXdseS1jcmVhdGVkIHBhbmUgZWxlbWVudFxuICAgICAqL1xuICAgIE92ZXJsYXkucHJvdG90eXBlLl9jcmVhdGVQYW5lRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFuZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwYW5lLmlkID0gXCJjZGstb3ZlcmxheS1cIiArIG5leHRVbmlxdWVJZCsrO1xuICAgICAgICBwYW5lLmNsYXNzTGlzdC5hZGQoJ2Nkay1vdmVybGF5LXBhbmUnKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheUNvbnRhaW5lci5nZXRDb250YWluZXJFbGVtZW50KCkuYXBwZW5kQ2hpbGQocGFuZSk7XG4gICAgICAgIHJldHVybiBwYW5lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRG9tUG9ydGFsSG9zdCBpbnRvIHdoaWNoIHRoZSBvdmVybGF5IGNvbnRlbnQgY2FuIGJlIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gez99IHBhbmUgVGhlIERPTSBlbGVtZW50IHRvIHR1cm4gaW50byBhIHBvcnRhbCBob3N0LlxuICAgICAqIEByZXR1cm4gez99IEEgcG9ydGFsIGhvc3QgZm9yIHRoZSBnaXZlbiBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBPdmVybGF5LnByb3RvdHlwZS5fY3JlYXRlUG9ydGFsSG9zdCA9IGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9tUG9ydGFsSG9zdChwYW5lLCB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIHRoaXMuX2FwcFJlZiwgdGhpcy5faW5qZWN0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPdmVybGF5UmVmIGZvciBhbiBvdmVybGF5IGluIHRoZSBnaXZlbiBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IHBhbmUgRE9NIGVsZW1lbnQgZm9yIHRoZSBvdmVybGF5XG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXlSZWYgPSBmdW5jdGlvbiAocGFuZSwgc3RhdGUkJDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdmVybGF5UmVmKHRoaXMuX2NyZWF0ZVBvcnRhbEhvc3QocGFuZSksIHBhbmUsIHN0YXRlJCQxLCB0aGlzLl9uZ1pvbmUpO1xuICAgIH07XG4gICAgcmV0dXJuIE92ZXJsYXk7XG59KCkpO1xuT3ZlcmxheS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuT3ZlcmxheS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE92ZXJsYXlDb250YWluZXIsIH0sXG4gICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBPdmVybGF5UG9zaXRpb25CdWlsZGVyLCB9LFxuICAgIHsgdHlwZTogQXBwbGljYXRpb25SZWYsIH0sXG4gICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbl07IH07XG4vKipcbiAqIFByb3ZpZGVycyBmb3IgT3ZlcmxheSBhbmQgaXRzIHJlbGF0ZWQgaW5qZWN0YWJsZXMuXG4gKi9cbnZhciBPVkVSTEFZX1BST1ZJREVSUyA9IFtcbiAgICBPdmVybGF5LFxuICAgIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIsXG4gICAgVklFV1BPUlRfUlVMRVJfUFJPVklERVIsXG4gICAgT1ZFUkxBWV9DT05UQUlORVJfUFJPVklERVIsXG5dO1xuLyoqXG4gKiBEZWZhdWx0IHNldCBvZiBwb3NpdGlvbnMgZm9yIHRoZSBvdmVybGF5LiBGb2xsb3dzIHRoZSBiZWhhdmlvciBvZiBhIGRyb3Bkb3duLlxuICovXG52YXIgZGVmYXVsdFBvc2l0aW9uTGlzdCA9IFtcbiAgICBuZXcgQ29ubmVjdGlvblBvc2l0aW9uUGFpcih7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nIH0sIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAndG9wJyB9KSxcbiAgICBuZXcgQ29ubmVjdGlvblBvc2l0aW9uUGFpcih7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICd0b3AnIH0sIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnYm90dG9tJyB9KSxcbl07XG4vKipcbiAqIERpcmVjdGl2ZSBhcHBsaWVkIHRvIGFuIGVsZW1lbnQgdG8gbWFrZSBpdCB1c2FibGUgYXMgYW4gb3JpZ2luIGZvciBhbiBPdmVybGF5IHVzaW5nIGFcbiAqIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kuXG4gKi9cbnZhciBPdmVybGF5T3JpZ2luID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gT3ZlcmxheU9yaWdpbihlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgfVxuICAgIHJldHVybiBPdmVybGF5T3JpZ2luO1xufSgpKTtcbk92ZXJsYXlPcmlnaW4uZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGstb3ZlcmxheS1vcmlnaW5dLCBbb3ZlcmxheS1vcmlnaW5dLCBbY2RrT3ZlcmxheU9yaWdpbl0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnY2RrT3ZlcmxheU9yaWdpbicsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk92ZXJsYXlPcmlnaW4uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHRvIGZhY2lsaXRhdGUgZGVjbGFyYXRpdmUgY3JlYXRpb24gb2YgYW4gT3ZlcmxheSB1c2luZyBhIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kuXG4gKi9cbnZhciBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfb3ZlcmxheVxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfc2Nyb2xsRGlzcGF0Y2hlclxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVSZWZcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDb250YWluZXJSZWZcbiAgICAgKiBAcGFyYW0gez99IF9kaXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlKF9vdmVybGF5LCBfcmVuZGVyZXIsIF9zY3JvbGxEaXNwYXRjaGVyLCB0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZiwgX2Rpcikge1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gX292ZXJsYXk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9zY3JvbGxEaXNwYXRjaGVyID0gX3Njcm9sbERpc3BhdGNoZXI7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX2hhc0JhY2tkcm9wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29mZnNldFggPSAwO1xuICAgICAgICB0aGlzLl9vZmZzZXRZID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmF0ZWd5IHRvIGJlIHVzZWQgd2hlbiBoYW5kbGluZyBzY3JvbGwgZXZlbnRzIHdoaWxlIHRoZSBvdmVybGF5IGlzIG9wZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbFN0cmF0ZWd5ID0gbmV3IFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneSh0aGlzLl9zY3JvbGxEaXNwYXRjaGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIG92ZXJsYXkgaXMgb3Blbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYWNrZHJvcENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBwb3NpdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIG92ZXJsYXkgaGFzIGJlZW4gYXR0YWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0dGFjaCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3ZlcmxheSBoYXMgYmVlbiBkZXRhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGV0YWNoID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZVBvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRYXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgb3ZlcmxheSBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB4LWF4aXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldFg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG9mZnNldFhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9mZnNldFgpIHtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldFggPSBvZmZzZXRYO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24ud2l0aE9mZnNldFgob2Zmc2V0WCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRZXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgb3ZlcmxheSBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB5LWF4aXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldFk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG9mZnNldFlcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9mZnNldFkpIHtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldFkgPSBvZmZzZXRZO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24ud2l0aE9mZnNldFkob2Zmc2V0WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJoYXNCYWNrZHJvcFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3ZlcmxheSBzaG91bGQgYXR0YWNoIGEgYmFja2Ryb3AuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNCYWNrZHJvcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNCYWNrZHJvcCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvdmVybGF5UmVmXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhc3NvY2lhdGVkIG92ZXJsYXkgcmVmZXJlbmNlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcImRpclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZWxlbWVudCdzIGxheW91dCBkaXJlY3Rpb24uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveU92ZXJsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snb3BlbiddKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4gPyB0aGlzLl9hdHRhY2hPdmVybGF5KCkgOiB0aGlzLl9kZXRhY2hPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb3ZlcmxheVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wb3NpdGlvbnMgfHwgIXRoaXMucG9zaXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBkZWZhdWx0UG9zaXRpb25MaXN0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZSh0aGlzLl9idWlsZENvbmZpZygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgb3ZlcmxheSBjb25maWcgYmFzZWQgb24gdGhlIGRpcmVjdGl2ZSdzIGlucHV0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2J1aWxkQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5Q29uZmlnID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy53aWR0aCB8fCB0aGlzLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBvdmVybGF5Q29uZmlnLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgfHwgdGhpcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIG92ZXJsYXlDb25maWcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWluV2lkdGggfHwgdGhpcy5taW5XaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3ZlcmxheUNvbmZpZy5taW5XaWR0aCA9IHRoaXMubWluV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWluSGVpZ2h0IHx8IHRoaXMubWluSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICBvdmVybGF5Q29uZmlnLm1pbkhlaWdodCA9IHRoaXMubWluSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIG92ZXJsYXlDb25maWcuaGFzQmFja2Ryb3AgPSB0aGlzLmhhc0JhY2tkcm9wO1xuICAgICAgICBpZiAodGhpcy5iYWNrZHJvcENsYXNzKSB7XG4gICAgICAgICAgICBvdmVybGF5Q29uZmlnLmJhY2tkcm9wQ2xhc3MgPSB0aGlzLmJhY2tkcm9wQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAodGhpcy5fY3JlYXRlUG9zaXRpb25TdHJhdGVneSgpKTtcbiAgICAgICAgb3ZlcmxheUNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fcG9zaXRpb247XG4gICAgICAgIG92ZXJsYXlDb25maWcuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLnNjcm9sbFN0cmF0ZWd5O1xuICAgICAgICByZXR1cm4gb3ZlcmxheUNvbmZpZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIHN0cmF0ZWd5IG9mIHRoZSBvdmVybGF5IHRvIGJlIHNldCBvbiB0aGUgb3ZlcmxheSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLl9jcmVhdGVQb3NpdGlvblN0cmF0ZWd5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3MgPSB0aGlzLnBvc2l0aW9uc1swXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luUG9pbnQgPSB7IG9yaWdpblg6IHBvcy5vcmlnaW5YLCBvcmlnaW5ZOiBwb3Mub3JpZ2luWSB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5UG9pbnQgPSB7IG92ZXJsYXlYOiBwb3Mub3ZlcmxheVgsIG92ZXJsYXlZOiBwb3Mub3ZlcmxheVkgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgICAgICAgIC5jb25uZWN0ZWRUbyh0aGlzLm9yaWdpbi5lbGVtZW50UmVmLCBvcmlnaW5Qb2ludCwgb3ZlcmxheVBvaW50KVxuICAgICAgICAgICAgLndpdGhPZmZzZXRYKHRoaXMub2Zmc2V0WClcbiAgICAgICAgICAgIC53aXRoT2Zmc2V0WSh0aGlzLm9mZnNldFkpO1xuICAgICAgICB0aGlzLl9oYW5kbGVQb3NpdGlvbkNoYW5nZXMoc3RyYXRlZ3kpO1xuICAgICAgICByZXR1cm4gc3RyYXRlZ3k7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0cmF0ZWd5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5faGFuZGxlUG9zaXRpb25DaGFuZ2VzID0gZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDE7IGkgPCB0aGlzLnBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3RyYXRlZ3kud2l0aEZhbGxiYWNrUG9zaXRpb24oeyBvcmlnaW5YOiB0aGlzLnBvc2l0aW9uc1tpXS5vcmlnaW5YLCBvcmlnaW5ZOiB0aGlzLnBvc2l0aW9uc1tpXS5vcmlnaW5ZIH0sIHsgb3ZlcmxheVg6IHRoaXMucG9zaXRpb25zW2ldLm92ZXJsYXlYLCBvdmVybGF5WTogdGhpcy5wb3NpdGlvbnNbaV0ub3ZlcmxheVkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24gPVxuICAgICAgICAgICAgc3RyYXRlZ3kub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gX3RoaXMucG9zaXRpb25DaGFuZ2UuZW1pdChwb3MpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBvdmVybGF5IGFuZCBzdWJzY3JpYmVzIHRvIGJhY2tkcm9wIGNsaWNrcyBpZiBiYWNrZHJvcCBleGlzdHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLl9hdHRhY2hPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb3NpdGlvbi53aXRoRGlyZWN0aW9uKHRoaXMuZGlyKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5nZXRTdGF0ZSgpLmRpcmVjdGlvbiA9IHRoaXMuZGlyO1xuICAgICAgICB0aGlzLl9pbml0RXNjYXBlTGlzdGVuZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3RlbXBsYXRlUG9ydGFsKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoLmVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNCYWNrZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24gPSB0aGlzLl9vdmVybGF5UmVmLmJhY2tkcm9wQ2xpY2soKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmJhY2tkcm9wQ2xpY2suZW1pdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaGVzIHRoZSBvdmVybGF5IGFuZCB1bnN1YnNjcmliZXMgdG8gYmFja2Ryb3AgY2xpY2tzIGlmIGJhY2tkcm9wIGV4aXN0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2RldGFjaE92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2guZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZXNjYXBlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VzY2FwZUxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBvdmVybGF5IGNyZWF0ZWQgYnkgdGhpcyBkaXJlY3RpdmUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fZGVzdHJveU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lc2NhcGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fZXNjYXBlTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZXZlbnQgbGlzdGVuZXIgdGhhdCBjbG9zZXMgdGhlIG92ZXJsYXkgd2hlbiBwcmVzc2luZyBFc2NhcGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5faW5pdEVzY2FwZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9lc2NhcGVMaXN0ZW5lciA9IHRoaXMuX3JlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9kZXRhY2hPdmVybGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmU7XG59KCkpO1xuQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Nkay1jb25uZWN0ZWQtb3ZlcmxheV0sIFtjb25uZWN0ZWQtb3ZlcmxheV0sIFtjZGtDb25uZWN0ZWRPdmVybGF5XScsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdjZGtDb25uZWN0ZWRPdmVybGF5J1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Db25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogT3ZlcmxheSwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IFNjcm9sbERpc3BhdGNoZXIsIH0sXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgfSxcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgeyB0eXBlOiBEaXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbkNvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ29yaWdpbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAncG9zaXRpb25zJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdvZmZzZXRYJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdvZmZzZXRZJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd3aWR0aCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaGVpZ2h0JzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtaW5XaWR0aCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbWluSGVpZ2h0JzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdiYWNrZHJvcENsYXNzJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzY3JvbGxTdHJhdGVneSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnb3Blbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaGFzQmFja2Ryb3AnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2JhY2tkcm9wQ2xpY2snOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdwb3NpdGlvbkNoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2F0dGFjaCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2RldGFjaCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xudmFyIE92ZXJsYXlNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gT3ZlcmxheU1vZHVsZTtcbn0oKSk7XG5PdmVybGF5TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbUG9ydGFsTW9kdWxlLCBTY3JvbGxEaXNwYXRjaE1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0Nvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUsIE92ZXJsYXlPcmlnaW4sIFNjcm9sbERpc3BhdGNoTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLCBPdmVybGF5T3JpZ2luXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtPVkVSTEFZX1BST1ZJREVSU10sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk92ZXJsYXlNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogVXRpbGl0eSBmb3IgY2hlY2tpbmcgdGhlIGludGVyYWN0aXZpdHkgb2YgYW4gZWxlbWVudCwgc3VjaCBhcyB3aGV0aGVyIGlzIGlzIGZvY3VzYWJsZSBvclxuICogdGFiYmFibGUuXG4gKi9cbnZhciBJbnRlcmFjdGl2aXR5Q2hlY2tlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3BsYXRmb3JtXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW50ZXJhY3Rpdml0eUNoZWNrZXIoX3BsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gX3BsYXRmb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7P30gV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBJbnRlcmFjdGl2aXR5Q2hlY2tlci5wcm90b3R5cGUuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIFRoaXMgZG9lcyBub3QgY2FwdHVyZSBzb21lIGNhc2VzLCBzdWNoIGFzIGEgbm9uLWZvcm0gY29udHJvbCB3aXRoIGEgZGlzYWJsZWQgYXR0cmlidXRlIG9yXG4gICAgICAgIC8vIGEgZm9ybSBjb250cm9sIGluc2lkZSBvZiBhIGRpc2FibGVkIGZvcm0sIGJ1dCBzaG91bGQgY2FwdHVyZSB0aGUgbW9zdCBjb21tb24gY2FzZXMuXG4gICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIHZpc2libGUgZm9yIHRoZSBwdXJwb3NlcyBvZiBpbnRlcmFjdGl2aXR5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGNhcHR1cmUgc3RhdGVzIGxpa2UgYGRpc3BsYXk6IG5vbmVgIGFuZCBgdmlzaWJpbGl0eTogaGlkZGVuYCwgYnV0IG5vdCB0aGluZ3MgbGlrZVxuICAgICAqIGJlaW5nIGNsaXBwZWQgYnkgYW4gYG92ZXJmbG93OiBoaWRkZW5gIHBhcmVudCBvciBiZWluZyBvdXRzaWRlIHRoZSB2aWV3cG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99IFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBJbnRlcmFjdGl2aXR5Q2hlY2tlci5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGhhc0dlb21ldHJ5KGVsZW1lbnQpICYmIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudmlzaWJpbGl0eSA9PT0gJ3Zpc2libGUnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgY2FuIGJlIHJlYWNoZWQgdmlhIFRhYiBrZXkuXG4gICAgICogQXNzdW1lcyB0aGF0IHRoZSBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZCB3aXRoIGlzRm9jdXNhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50IEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHs/fSBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHRhYmJhYmxlLlxuICAgICAqL1xuICAgIEludGVyYWN0aXZpdHlDaGVja2VyLnByb3RvdHlwZS5pc1RhYmJhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnJhbWVFbGVtZW50ID0gKGdldFdpbmRvdyhlbGVtZW50KS5mcmFtZUVsZW1lbnQpO1xuICAgICAgICBpZiAoZnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmcmFtZVR5cGUgPSBmcmFtZUVsZW1lbnQgJiYgZnJhbWVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAvLyBGcmFtZSBlbGVtZW50cyBpbmhlcml0IHRoZWlyIHRhYmluZGV4IG9udG8gYWxsIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgICAgICAgaWYgKGdldFRhYkluZGV4VmFsdWUoZnJhbWVFbGVtZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZWJraXQgYW5kIEJsaW5rIGNvbnNpZGVyIGFueXRoaW5nIGluc2lkZSBvZiBhbiA8b2JqZWN0PiBlbGVtZW50IGFzIG5vbi10YWJiYWJsZS5cbiAgICAgICAgICAgIGlmICgodGhpcy5fcGxhdGZvcm0uQkxJTksgfHwgdGhpcy5fcGxhdGZvcm0uV0VCS0lUKSAmJiBmcmFtZVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Via2l0IGFuZCBCbGluayBkaXNhYmxlIHRhYmJpbmcgdG8gYW4gZWxlbWVudCBpbnNpZGUgb2YgYW4gaW52aXNpYmxlIGZyYW1lLlxuICAgICAgICAgICAgaWYgKCh0aGlzLl9wbGF0Zm9ybS5CTElOSyB8fCB0aGlzLl9wbGF0Zm9ybS5XRUJLSVQpICYmICF0aGlzLmlzVmlzaWJsZShmcmFtZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWJJbmRleFZhbHVlID0gZ2V0VGFiSW5kZXhWYWx1ZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhYkluZGV4VmFsdWUgIT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ2lmcmFtZScpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmcmFtZXMgbWF5IGJlIHRhYmJhYmxlIGRlcGVuZGluZyBvbiBjb250ZW50LCBidXQgaXQncyBub3QgcG9zc2libHkgdG8gcmVsaWFibHlcbiAgICAgICAgICAgIC8vIGludmVzdGlnYXRlIHRoZSBjb250ZW50IG9mIHRoZSBmcmFtZXMuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpKSB7XG4gICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCBhbiA8YXVkaW8+IGVsZW1lbnQgd2l0aG91dCB0aGUgY29udHJvbHMgZW5hYmxlZCBpcyBub3QgdGFiYmFibGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGxhdGZvcm0uQkxJTkspIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBCbGluayA8YXVkaW8gY29udHJvbHM+IGVsZW1lbnRzIGFyZSBhbHdheXMgdGFiYmFibGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpICYmIHRoaXMuX3BsYXRmb3JtLlRSSURFTlQpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBUcmlkZW50IGEgPHZpZGVvPiBlbGVtZW50IHdpdGhvdXQgdGhlIGNvbnRyb2xzIGVuYWJsZWQgaXMgbm90IHRhYmJhYmxlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BsYXRmb3JtLkJMSU5LIHx8IHRoaXMuX3BsYXRmb3JtLkZJUkVGT1gpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBDaHJvbWUgYW5kIEZpcmVmb3ggPHZpZGVvIGNvbnRyb2xzPiBlbGVtZW50cyBhcmUgYWx3YXlzIHRhYmJhYmxlLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ29iamVjdCcgJiYgKHRoaXMuX3BsYXRmb3JtLkJMSU5LIHx8IHRoaXMuX3BsYXRmb3JtLldFQktJVCkpIHtcbiAgICAgICAgICAgIC8vIEluIGFsbCBCbGluayBhbmQgV2ViS2l0IGJhc2VkIGJyb3dzZXJzIDxvYmplY3Q+IGVsZW1lbnRzIGFyZSBuZXZlciB0YWJiYWJsZS5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBpT1MgdGhlIGJyb3dzZXIgb25seSBjb25zaWRlcnMgc29tZSBzcGVjaWZpYyBlbGVtZW50cyBhcyB0YWJiYWJsZS5cbiAgICAgICAgaWYgKHRoaXMuX3BsYXRmb3JtLldFQktJVCAmJiB0aGlzLl9wbGF0Zm9ybS5JT1MgJiYgIWlzUG90ZW50aWFsbHlUYWJiYWJsZUlPUyhlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50LnRhYkluZGV4ID49IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBjYW4gYmUgZm9jdXNlZCBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7P30gV2hldGhlciB0aGUgZWxlbWVudCBpcyBmb2N1c2FibGUuXG4gICAgICovXG4gICAgSW50ZXJhY3Rpdml0eUNoZWNrZXIucHJvdG90eXBlLmlzRm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBjaGVja3MgaW4gb3JkZXIgb2YgbGVmdCB0byBtb3N0IGV4cGVuc2l2ZS5cbiAgICAgICAgLy8gQWdhaW4sIG5haXZlIGFwcHJvYWNoIHRoYXQgZG9lcyBub3QgY2FwdHVyZSBtYW55IGVkZ2UgY2FzZXMgYW5kIGJyb3dzZXIgcXVpcmtzLlxuICAgICAgICByZXR1cm4gaXNQb3RlbnRpYWxseUZvY3VzYWJsZShlbGVtZW50KSAmJiAhdGhpcy5pc0Rpc2FibGVkKGVsZW1lbnQpICYmIHRoaXMuaXNWaXNpYmxlKGVsZW1lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVyYWN0aXZpdHlDaGVja2VyO1xufSgpKTtcbkludGVyYWN0aXZpdHlDaGVja2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5JbnRlcmFjdGl2aXR5Q2hlY2tlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCB9LFxuXTsgfTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBlbGVtZW50IGhhcyBhbnkgZ2VvbWV0cnkgLyByZWN0YW5nbGVzLlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBoYXNHZW9tZXRyeShlbGVtZW50KSB7XG4gICAgLy8gVXNlIGxvZ2ljIGZyb20galF1ZXJ5IHRvIGNoZWNrIGZvciBhbiBpbnZpc2libGUgZWxlbWVudC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2Nzcy9oaWRkZW5WaXNpYmxlU2VsZWN0b3JzLmpzI0wxMlxuICAgIHJldHVybiAhIShlbGVtZW50Lm9mZnNldFdpZHRoIHx8IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCdzXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlRm9ybUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSA9PT0gJ2lucHV0JyB8fFxuICAgICAgICBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgbm9kZU5hbWUgPT09ICdidXR0b24nIHx8XG4gICAgICAgIG5vZGVOYW1lID09PSAndGV4dGFyZWEnO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhbiA8aW5wdXQgdHlwZT1cImhpZGRlblwiPi5cbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNIaWRkZW5JbnB1dChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGlzSW5wdXRFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQudHlwZSA9PSAnaGlkZGVuJztcbn1cbi8qKlxuICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgYW4gYW5jaG9yIHRoYXQgaGFzIGFuIGhyZWYgYXR0cmlidXRlLlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0FuY2hvcldpdGhIcmVmKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gaXNBbmNob3JFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdocmVmJyk7XG59XG4vKipcbiAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIGlucHV0IGVsZW1lbnQuXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09ICdpbnB1dCc7XG59XG4vKipcbiAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIGFuY2hvciBlbGVtZW50LlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0FuY2hvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2EnO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBoYXMgYSB2YWxpZCB0YWJpbmRleC5cbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaGFzVmFsaWRUYWJJbmRleChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCBlbGVtZW50LnRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIC8vIElFMTEgcGFyc2VzIHRhYmluZGV4PVwiXCIgYXMgdGhlIHZhbHVlIFwiLTMyNzY4XCJcbiAgICBpZiAodGFiSW5kZXggPT0gJy0zMjc2OCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gISEodGFiSW5kZXggJiYgIWlzTmFOKHBhcnNlSW50KHRhYkluZGV4LCAxMCkpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyc2VkIHRhYmluZGV4IGZyb20gdGhlIGVsZW1lbnQgYXR0cmlidXRlcyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVcbiAqIGV2YWx1YXRlZCB0YWJpbmRleCBmcm9tIHRoZSBicm93c2VycyBkZWZhdWx0cy5cbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0VGFiSW5kZXhWYWx1ZShlbGVtZW50KSB7XG4gICAgaWYgKCFoYXNWYWxpZFRhYkluZGV4KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTZWUgYnJvd3NlciBpc3N1ZSBpbiBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFiSW5kZXggPSBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuICAgIHJldHVybiBpc05hTih0YWJJbmRleCkgPyAtMSA6IHRhYkluZGV4O1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaXMgcG90ZW50aWFsbHkgdGFiYmFibGUgb24gaU9TXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzUG90ZW50aWFsbHlUYWJiYWJsZUlPUyhlbGVtZW50KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXRUeXBlID0gbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgKChlbGVtZW50KSkudHlwZTtcbiAgICByZXR1cm4gaW5wdXRUeXBlID09PSAndGV4dCdcbiAgICAgICAgfHwgaW5wdXRUeXBlID09PSAncGFzc3dvcmQnXG4gICAgICAgIHx8IG5vZGVOYW1lID09PSAnc2VsZWN0J1xuICAgICAgICB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJztcbn1cbi8qKlxuICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgcG90ZW50aWFsbHkgZm9jdXNhYmxlIHdpdGhvdXQgdGFraW5nIGN1cnJlbnQgdmlzaWJsZS9kaXNhYmxlZCBzdGF0ZVxuICogaW50byBhY2NvdW50LlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1BvdGVudGlhbGx5Rm9jdXNhYmxlKGVsZW1lbnQpIHtcbiAgICAvLyBJbnB1dHMgYXJlIHBvdGVudGlhbGx5IGZvY3VzYWJsZSAqdW5sZXNzKiB0aGV5J3JlIHR5cGU9XCJoaWRkZW5cIi5cbiAgICBpZiAoaXNIaWRkZW5JbnB1dChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc05hdGl2ZUZvcm1FbGVtZW50KGVsZW1lbnQpIHx8XG4gICAgICAgIGlzQW5jaG9yV2l0aEhyZWYoZWxlbWVudCkgfHxcbiAgICAgICAgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpIHx8XG4gICAgICAgIGhhc1ZhbGlkVGFiSW5kZXgoZWxlbWVudCk7XG59XG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB3aW5kb3cgb2YgYSBET00gbm9kZSB3aXRoIHJlZ2FyZHMgb2YgYmVpbmcgaW5zaWRlIG9mIGFuIGlmcmFtZS5cbiAqIEBwYXJhbSB7P30gbm9kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn1cbi8qKlxuICogQ2xhc3MgdGhhdCBhbGxvd3MgZm9yIHRyYXBwaW5nIGZvY3VzIHdpdGhpbiBhIERPTSBlbGVtZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgY3VycmVudGx5IHVzZXMgYSB2ZXJ5IHNpbXBsZSAobmFpdmUpIGFwcHJvYWNoIHRvIGZvY3VzIHRyYXBwaW5nLlxuICogSXQgYXNzdW1lcyB0aGF0IHRoZSB0YWIgb3JkZXIgaXMgdGhlIHNhbWUgYXMgRE9NIG9yZGVyLCB3aGljaCBpcyBub3QgbmVjZXNzYXJpbHkgdHJ1ZS5cbiAqIFRoaW5ncyBsaWtlIHRhYkluZGV4ID4gMCwgZmxleCBgb3JkZXJgLCBhbmQgc2hhZG93IHJvb3RzIGNhbiBjYXVzZSB0byB0d28gdG8gbWlzYWxpZ24uXG4gKiBUaGlzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIG1vcmUgaW50ZWxsaWdlbnQgc29sdXRpb24gYmVmb3JlIHRoZSBsaWJyYXJ5IGlzIGNvbnNpZGVyZWQgc3RhYmxlLlxuICovXG52YXIgRm9jdXNUcmFwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX2NoZWNrZXJcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKiBAcGFyYW0gez89fSBkZWZlckFuY2hvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGb2N1c1RyYXAoX2VsZW1lbnQsIF9jaGVja2VyLCBfbmdab25lLCBkZWZlckFuY2hvcnMpIHtcbiAgICAgICAgaWYgKGRlZmVyQW5jaG9ycyA9PT0gdm9pZCAwKSB7IGRlZmVyQW5jaG9ycyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fY2hlY2tlciA9IF9jaGVja2VyO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFkZWZlckFuY2hvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoQW5jaG9ycygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb2N1c1RyYXAucHJvdG90eXBlLCBcImVuYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgZm9jdXMgdHJhcCBpcyBhY3RpdmUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVkID0gdmFsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0QW5jaG9yICYmIHRoaXMuX2VuZEFuY2hvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0QW5jaG9yLnRhYkluZGV4ID0gdGhpcy5fZW5kQW5jaG9yLnRhYkluZGV4ID0gdGhpcy5fZW5hYmxlZCA/IDAgOiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGZvY3VzIHRyYXAgYnkgY2xlYW5pbmcgdXAgdGhlIGFuY2hvcnMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGFydEFuY2hvciAmJiB0aGlzLl9zdGFydEFuY2hvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydEFuY2hvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3N0YXJ0QW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZW5kQW5jaG9yICYmIHRoaXMuX2VuZEFuY2hvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmRBbmNob3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9lbmRBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXJ0QW5jaG9yID0gdGhpcy5fZW5kQW5jaG9yID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIGFuY2hvcnMgaW50byB0aGUgRE9NLiBUaGlzIGlzIHVzdWFsbHkgZG9uZSBhdXRvbWF0aWNhbGx5XG4gICAgICogaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgY2FuIGJlIGRlZmVycmVkIGZvciBjYXNlcyBsaWtlIGRpcmVjdGl2ZXMgd2l0aCBgKm5nSWZgLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNUcmFwLnByb3RvdHlwZS5hdHRhY2hBbmNob3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0QW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydEFuY2hvciA9IHRoaXMuX2NyZWF0ZUFuY2hvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW5kQW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmRBbmNob3IgPSB0aGlzLl9jcmVhdGVBbmNob3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3N0YXJ0QW5jaG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZm9jdXNMYXN0VGFiYmFibGVFbGVtZW50KCk7IH0pO1xuICAgICAgICAgICAgX3RoaXMuX2VuZEFuY2hvci5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoKTsgfSk7XG4gICAgICAgICAgICBfdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShfdGhpcy5fc3RhcnRBbmNob3IsIF90aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICAgIF90aGlzLl9lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKF90aGlzLl9lbmRBbmNob3IsIF90aGlzLl9lbGVtZW50Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuZm9jdXNJbml0aWFsRWxlbWVudFdoZW5SZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkuZmlyc3QoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZm9jdXNJbml0aWFsRWxlbWVudCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciBtaWNyb3Rhc2sgcXVldWUgdG8gZW1wdHksIHRoZW4gZm9jdXNlc1xuICAgICAqIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnRXaGVuUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgbWljcm90YXNrIHF1ZXVlIHRvIGVtcHR5LCB0aGVuIGZvY3VzZXNcbiAgICAgKiB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudFdoZW5SZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkuZmlyc3QoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZm9jdXNMYXN0VGFiYmFibGVFbGVtZW50KCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzcGVjaWZpZWQgYm91bmRhcnkgZWxlbWVudCBvZiB0aGUgdHJhcHBlZCByZWdpb24uXG4gICAgICogQHBhcmFtIHs/fSBib3VuZCBUaGUgYm91bmRhcnkgdG8gZ2V0IChzdGFydCBvciBlbmQgb2YgdHJhcHBlZCByZWdpb24pLlxuICAgICAqIEByZXR1cm4gez99IFRoZSBib3VuZGFyeSBlbGVtZW50LlxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuX2dldFJlZ2lvbkJvdW5kYXJ5ID0gZnVuY3Rpb24gKGJvdW5kKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcmtlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbY2RrLWZvY3VzLXJlZ2lvbi1cIiArIGJvdW5kICsgXCJdXCIpKS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2Nkay1mb2N1cy1cIiArIGJvdW5kICsgXCJdXCIpKSk7XG4gICAgICAgIG1hcmtlcnMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoXCJjZGstZm9jdXMtXCIgKyBib3VuZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGb3VuZCB1c2Ugb2YgZGVwcmVjYXRlZCBhdHRyaWJ1dGUgJ2Nkay1mb2N1cy1cIiArIGJvdW5kICsgXCInLFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiIHVzZSAnY2RrLWZvY3VzLXJlZ2lvbi1cIiArIGJvdW5kICsgXCInIGluc3RlYWQuXCIpLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYm91bmQgPT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtlcnMubGVuZ3RoID8gbWFya2Vyc1swXSA6IHRoaXMuX2dldEZpcnN0VGFiYmFibGVFbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJzLmxlbmd0aCA/XG4gICAgICAgICAgICBtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0gOiB0aGlzLl9nZXRMYXN0VGFiYmFibGVFbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBmb2N1c2VkIHdoZW4gdGhlIGZvY3VzIHRyYXAgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzSW5pdGlhbEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZGlyZWN0VG9FbGVtZW50ID0gKHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcignW2Nkay1mb2N1cy1pbml0aWFsXScpKTtcbiAgICAgICAgaWYgKHJlZGlyZWN0VG9FbGVtZW50KSB7XG4gICAgICAgICAgICByZWRpcmVjdFRvRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBmb2N1cyB0cmFwIHJlZ2lvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVkaXJlY3RUb0VsZW1lbnQgPSB0aGlzLl9nZXRSZWdpb25Cb3VuZGFyeSgnc3RhcnQnKTtcbiAgICAgICAgaWYgKHJlZGlyZWN0VG9FbGVtZW50KSB7XG4gICAgICAgICAgICByZWRpcmVjdFRvRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBsYXN0IHRhYmJhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBmb2N1cyB0cmFwIHJlZ2lvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuZm9jdXNMYXN0VGFiYmFibGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWRpcmVjdFRvRWxlbWVudCA9IHRoaXMuX2dldFJlZ2lvbkJvdW5kYXJ5KCdlbmQnKTtcbiAgICAgICAgaWYgKHJlZGlyZWN0VG9FbGVtZW50KSB7XG4gICAgICAgICAgICByZWRpcmVjdFRvRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQgZnJvbSBhIERPTSBzdWJ0cmVlIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7P30gcm9vdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNUcmFwLnByb3RvdHlwZS5fZ2V0Rmlyc3RUYWJiYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tlci5pc0ZvY3VzYWJsZShyb290KSAmJiB0aGlzLl9jaGVja2VyLmlzVGFiYmFibGUocm9vdCkpIHtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdGUgaW4gRE9NIG9yZGVyLiBOb3RlIHRoYXQgSUUgZG9lc24ndCBoYXZlIGBjaGlsZHJlbmAgZm9yIFNWRyBzbyB3ZSBmYWxsXG4gICAgICAgIC8vIGJhY2sgdG8gYGNoaWxkTm9kZXNgIHdoaWNoIGluY2x1ZGVzIHRleHQgbm9kZXMsIGNvbW1lbnRzIGV0Yy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSByb290LmNoaWxkcmVuIHx8IHJvb3QuY2hpbGROb2RlcztcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWJiYWJsZUNoaWxkID0gY2hpbGRyZW5baV0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFID9cbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRGaXJzdFRhYmJhYmxlRWxlbWVudCgvKiogQHR5cGUgez99ICovIChjaGlsZHJlbltpXSkpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFiYmFibGVDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IGZyb20gYSBET00gc3VidHJlZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0gez99IHJvb3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuX2dldExhc3RUYWJiYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tlci5pc0ZvY3VzYWJsZShyb290KSAmJiB0aGlzLl9jaGVja2VyLmlzVGFiYmFibGUocm9vdCkpIHtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdGUgaW4gcmV2ZXJzZSBET00gb3JkZXIuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbiB8fCByb290LmNoaWxkTm9kZXM7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWJiYWJsZUNoaWxkID0gY2hpbGRyZW5baV0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFID9cbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRMYXN0VGFiYmFibGVFbGVtZW50KC8qKiBAdHlwZSB7P30gKi8gKGNoaWxkcmVuW2ldKSkgOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICBpZiAodGFiYmFibGVDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YWJiYWJsZUNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbmNob3IgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuX2NyZWF0ZUFuY2hvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGFuY2hvci50YWJJbmRleCA9IHRoaXMuX2VuYWJsZWQgPyAwIDogLTE7XG4gICAgICAgIGFuY2hvci5jbGFzc0xpc3QuYWRkKCdjZGstdmlzdWFsbHktaGlkZGVuJyk7XG4gICAgICAgIGFuY2hvci5jbGFzc0xpc3QuYWRkKCdjZGstZm9jdXMtdHJhcC1hbmNob3InKTtcbiAgICAgICAgcmV0dXJuIGFuY2hvcjtcbiAgICB9O1xuICAgIHJldHVybiBGb2N1c1RyYXA7XG59KCkpO1xuLyoqXG4gKiBGYWN0b3J5IHRoYXQgYWxsb3dzIGVhc3kgaW5zdGFudGlhdGlvbiBvZiBmb2N1cyB0cmFwcy5cbiAqL1xudmFyIEZvY3VzVHJhcEZhY3RvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jaGVja2VyXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICovXG4gICAgZnVuY3Rpb24gRm9jdXNUcmFwRmFjdG9yeShfY2hlY2tlciwgX25nWm9uZSkge1xuICAgICAgICB0aGlzLl9jaGVja2VyID0gX2NoZWNrZXI7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmVyQW5jaG9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNUcmFwRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGRlZmVyQW5jaG9ycykge1xuICAgICAgICBpZiAoZGVmZXJBbmNob3JzID09PSB2b2lkIDApIHsgZGVmZXJBbmNob3JzID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoZWxlbWVudCwgdGhpcy5fY2hlY2tlciwgdGhpcy5fbmdab25lLCBkZWZlckFuY2hvcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvY3VzVHJhcEZhY3Rvcnk7XG59KCkpO1xuRm9jdXNUcmFwRmFjdG9yeS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuRm9jdXNUcmFwRmFjdG9yeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEludGVyYWN0aXZpdHlDaGVja2VyLCB9LFxuICAgIHsgdHlwZTogTmdab25lLCB9LFxuXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIGZvciB0cmFwcGluZyBmb2N1cyB3aXRoaW4gYSByZWdpb24uXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c1RyYXBGYWN0b3J5XG4gICAgICovXG4gICAgZnVuY3Rpb24gRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZShfZWxlbWVudFJlZiwgX2ZvY3VzVHJhcEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9mb2N1c1RyYXBGYWN0b3J5ID0gX2ZvY3VzVHJhcEZhY3Rvcnk7XG4gICAgICAgIHRoaXMuZm9jdXNUcmFwID0gdGhpcy5fZm9jdXNUcmFwRmFjdG9yeS5jcmVhdGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0cnVlKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGZvY3VzIHRyYXAgaXMgYWN0aXZlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5mb2N1c1RyYXAuZW5hYmxlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLmVuYWJsZWQgPSAhY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNUcmFwLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvY3VzVHJhcC5hdHRhY2hBbmNob3JzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZTtcbn0oKSk7XG5Gb2N1c1RyYXBEZXByZWNhdGVkRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdjZGstZm9jdXMtdHJhcCcsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogRm9jdXNUcmFwRmFjdG9yeSwgfSxcbl07IH07XG5Gb2N1c1RyYXBEZXByZWNhdGVkRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG4vKipcbiAqIERpcmVjdGl2ZSBmb3IgdHJhcHBpbmcgZm9jdXMgd2l0aGluIGEgcmVnaW9uLlxuICovXG52YXIgRm9jdXNUcmFwRGlyZWN0aXZlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX2ZvY3VzVHJhcEZhY3RvcnlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGb2N1c1RyYXBEaXJlY3RpdmUoX2VsZW1lbnRSZWYsIF9mb2N1c1RyYXBGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fZm9jdXNUcmFwRmFjdG9yeSA9IF9mb2N1c1RyYXBGYWN0b3J5O1xuICAgICAgICB0aGlzLmZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb2N1c1RyYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgZm9jdXMgdHJhcCBpcyBhY3RpdmUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9jdXNUcmFwLmVuYWJsZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLmZvY3VzVHJhcC5lbmFibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvY3VzVHJhcC5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcERpcmVjdGl2ZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvY3VzVHJhcC5hdHRhY2hBbmNob3JzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRm9jdXNUcmFwRGlyZWN0aXZlO1xufSgpKTtcbkZvY3VzVHJhcERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Nka1RyYXBGb2N1c10nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnY2RrVHJhcEZvY3VzJyxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuRm9jdXNUcmFwRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IEZvY3VzVHJhcEZhY3RvcnksIH0sXG5dOyB9O1xuRm9jdXNUcmFwRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdlbmFibGVkJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnY2RrVHJhcEZvY3VzJyxdIH0sXSxcbn07XG52YXIgTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbignbGl2ZUFubm91bmNlckVsZW1lbnQnKTtcbnZhciBMaXZlQW5ub3VuY2VyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50VG9rZW5cbiAgICAgKiBAcGFyYW0gez99IHBsYXRmb3JtXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGl2ZUFubm91bmNlcihlbGVtZW50VG9rZW4sIHBsYXRmb3JtKSB7XG4gICAgICAgIC8vIE9ubHkgZG8gYW55dGhpbmcgaWYgd2UncmUgb24gdGhlIGJyb3dzZXIgcGxhdGZvcm0uXG4gICAgICAgIGlmIChwbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIGluamVjdCB0aGUgbGl2ZSBlbGVtZW50IGFzIGBhbnlgIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBjYW5ub3QgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyBicm93c2VyIGdsb2JhbHMgKEhUTUxFbGVtZW50KSBvbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMsIHNpbmNlIGhhdmluZyBhIGNsYXNzIGRlY29yYXRvclxuICAgICAgICAgICAgLy8gY2F1c2VzIFR5cGVTY3JpcHQgdG8gcHJlc2VydmUgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSB0eXBlcy5cbiAgICAgICAgICAgIHRoaXMuX2xpdmVFbGVtZW50ID0gZWxlbWVudFRva2VuIHx8IHRoaXMuX2NyZWF0ZUxpdmVFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQW5ub3VuY2VzIGEgbWVzc2FnZSB0byBzY3JlZW5yZWFkZXJzLlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZSBNZXNzYWdlIHRvIGJlIGFubm91bmNlZCB0byB0aGUgc2NyZWVucmVhZGVyXG4gICAgICogQHBhcmFtIHs/PX0gcG9saXRlbmVzcyBUaGUgcG9saXRlbmVzcyBvZiB0aGUgYW5ub3VuY2VyIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpdmVBbm5vdW5jZXIucHJvdG90eXBlLmFubm91bmNlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHBvbGl0ZW5lc3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHBvbGl0ZW5lc3MgPT09IHZvaWQgMCkgeyBwb2xpdGVuZXNzID0gJ3BvbGl0ZSc7IH1cbiAgICAgICAgdGhpcy5fbGl2ZUVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgLy8gVE9ETzogZW5zdXJlIGNoYW5naW5nIHRoZSBwb2xpdGVuZXNzIHdvcmtzIG9uIGFsbCBlbnZpcm9ubWVudHMgd2Ugc3VwcG9ydC5cbiAgICAgICAgdGhpcy5fbGl2ZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCBwb2xpdGVuZXNzKTtcbiAgICAgICAgLy8gVGhpcyAxMDBtcyB0aW1lb3V0IGlzIG5lY2Vzc2FyeSBmb3Igc29tZSBicm93c2VyICsgc2NyZWVuLXJlYWRlciBjb21iaW5hdGlvbnM6XG4gICAgICAgIC8vIC0gQm90aCBKQVdTIGFuZCBOVkRBIG92ZXIgSUUxMSB3aWxsIG5vdCBhbm5vdW5jZSBhbnl0aGluZyB3aXRob3V0IGEgbm9uLXplcm8gdGltZW91dC5cbiAgICAgICAgLy8gLSBXaXRoIENocm9tZSBhbmQgSUUxMSB3aXRoIE5WREEgb3IgSkFXUywgYSByZXBlYXRlZCAoaWRlbnRpY2FsKSBtZXNzYWdlIHdvbid0IGJlIHJlYWQgYVxuICAgICAgICAvLyAgIHNlY29uZCB0aW1lIHdpdGhvdXQgY2xlYXJpbmcgYW5kIHRoZW4gdXNpbmcgYSBub24temVybyBkZWxheS5cbiAgICAgICAgLy8gKHVzaW5nIEpBV1MgMTcgYXQgdGltZSBvZiB0aGlzIHdyaXRpbmcpLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9saXZlRWxlbWVudC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7IH0sIDEwMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBhcmlhLWxpdmUgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXZlQW5ub3VuY2VyLnByb3RvdHlwZS5fcmVtb3ZlTGl2ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXZlRWxlbWVudCAmJiB0aGlzLl9saXZlRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9saXZlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2xpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXZlQW5ub3VuY2VyLnByb3RvdHlwZS5fY3JlYXRlTGl2ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpdmVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBsaXZlRWwuY2xhc3NMaXN0LmFkZCgnY2RrLXZpc3VhbGx5LWhpZGRlbicpO1xuICAgICAgICBsaXZlRWwuc2V0QXR0cmlidXRlKCdhcmlhLWF0b21pYycsICd0cnVlJyk7XG4gICAgICAgIGxpdmVFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaXZlRWwpO1xuICAgICAgICByZXR1cm4gbGl2ZUVsO1xuICAgIH07XG4gICAgcmV0dXJuIExpdmVBbm5vdW5jZXI7XG59KCkpO1xuTGl2ZUFubm91bmNlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTGl2ZUFubm91bmNlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtMSVZFX0FOTk9VTkNFUl9FTEVNRU5UX1RPS0VOLF0gfSxdIH0sXG4gICAgeyB0eXBlOiBQbGF0Zm9ybSwgfSxcbl07IH07XG4vKipcbiAqIEBwYXJhbSB7P30gcGFyZW50RGlzcGF0Y2hlclxuICogQHBhcmFtIHs/fSBsaXZlRWxlbWVudFxuICogQHBhcmFtIHs/fSBwbGF0Zm9ybVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gTElWRV9BTk5PVU5DRVJfUFJPVklERVJfRkFDVE9SWShwYXJlbnREaXNwYXRjaGVyLCBsaXZlRWxlbWVudCwgcGxhdGZvcm0pIHtcbiAgICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgTGl2ZUFubm91bmNlcihsaXZlRWxlbWVudCwgcGxhdGZvcm0pO1xufVxudmFyIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSID0ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBMaXZlQW5ub3VuY2VyIGF2YWlsYWJsZSwgdXNlIHRoYXQuIE90aGVyd2lzZSwgcHJvdmlkZSBhIG5ldyBvbmUuXG4gICAgcHJvdmlkZTogTGl2ZUFubm91bmNlcixcbiAgICBkZXBzOiBbXG4gICAgICAgIFtuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIExpdmVBbm5vdW5jZXJdLFxuICAgICAgICBbbmV3IE9wdGlvbmFsKCksIG5ldyBJbmplY3QoTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTildLFxuICAgICAgICBQbGF0Zm9ybSxcbiAgICBdLFxuICAgIHVzZUZhY3Rvcnk6IExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSX0ZBQ1RPUllcbn07XG52YXIgQTExeU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEExMXlNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBBMTF5TW9kdWxlO1xufSgpKTtcbkExMXlNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIFBsYXRmb3JtTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtGb2N1c1RyYXBEaXJlY3RpdmUsIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtGb2N1c1RyYXBEaXJlY3RpdmUsIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmVdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0ludGVyYWN0aXZpdHlDaGVja2VyLCBGb2N1c1RyYXBGYWN0b3J5LCBMSVZFX0FOTk9VTkNFUl9QUk9WSURFUl1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQTExeU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBUaGUgRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIgaXMgdGhlIGFsdGVybmF0aXZlIHRvIE92ZXJsYXlDb250YWluZXJcbiAqIHRoYXQgc3VwcG9ydHMgY29ycmVjdCBkaXNwbGF5aW5nIG9mIG92ZXJsYXkgZWxlbWVudHMgaW4gRnVsbHNjcmVlbiBtb2RlXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9yZXF1ZXN0RnVsbFNjcmVlblxuICogSXQgc2hvdWxkIGJlIHByb3ZpZGVkIGluIHRoZSByb290IGNvbXBvbmVudCB0aGF0IHdheTpcbiAqIHByb3ZpZGVyczogW1xuICogICB7cHJvdmlkZTogT3ZlcmxheUNvbnRhaW5lciwgdXNlQ2xhc3M6IEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyfVxuICogXSxcbiAqL1xudmFyIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5fY3JlYXRlQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jcmVhdGVDb250YWluZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50Rm9yRnVsbHNjcmVlbkNoYW5nZSgpO1xuICAgICAgICB0aGlzLl9hZGRGdWxsc2NyZWVuQ2hhbmdlTGlzdGVuZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2FkanVzdFBhcmVudEZvckZ1bGxzY3JlZW5DaGFuZ2UoKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5fYWRqdXN0UGFyZW50Rm9yRnVsbHNjcmVlbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVsbHNjcmVlbkVsZW1lbnQgPSB0aGlzLmdldEZ1bGxzY3JlZW5FbGVtZW50KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudCA9IGZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXJFbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5fYWRkRnVsbHNjcmVlbkNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKGRvY3VtZW50KSkubW96RnVsbFNjcmVlbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChkb2N1bWVudCkpLm1zRnVsbHNjcmVlbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ01TRnVsbHNjcmVlbkNoYW5nZScsIGZuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcGFnZSBpcyBwdXQgaW50byBmdWxsc2NyZWVuIG1vZGUsIGEgc3BlY2lmaWMgZWxlbWVudCBpcyBzcGVjaWZpZWQuXG4gICAgICogT25seSB0aGF0IGVsZW1lbnQgYW5kIGl0cyBjaGlsZHJlbiBhcmUgdmlzaWJsZSB3aGVuIGluIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5nZXRGdWxsc2NyZWVuRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgKChkb2N1bWVudCkpLm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICAoKGRvY3VtZW50KSkubXNGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lcjtcbn0oT3ZlcmxheUNvbnRhaW5lcikpO1xuRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgR2VzdHVyZUNvbmZpZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoR2VzdHVyZUNvbmZpZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHZXN0dXJlQ29uZmlnKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5faGFtbWVyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoKHdpbmRvdykpLkhhbW1lciA6IG51bGw7XG4gICAgICAgIC8qIExpc3Qgb2YgbmV3IGV2ZW50IG5hbWVzIHRvIGFkZCB0byB0aGUgZ2VzdHVyZSBzdXBwb3J0IGxpc3QgKi9cbiAgICAgICAgX3RoaXMuZXZlbnRzID0gX3RoaXMuX2hhbW1lciA/IFtcbiAgICAgICAgICAgICdsb25ncHJlc3MnLFxuICAgICAgICAgICAgJ3NsaWRlJyxcbiAgICAgICAgICAgICdzbGlkZXN0YXJ0JyxcbiAgICAgICAgICAgICdzbGlkZWVuZCcsXG4gICAgICAgICAgICAnc2xpZGVyaWdodCcsXG4gICAgICAgICAgICAnc2xpZGVsZWZ0J1xuICAgICAgICBdIDogW107XG4gICAgICAgIGlmICghX3RoaXMuX2hhbW1lciAmJiBpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBIYW1tZXJKUy4gQ2VydGFpbiBBbmd1bGFyIE1hdGVyaWFsICcgK1xuICAgICAgICAgICAgICAgICdjb21wb25lbnRzIG1heSBub3Qgd29yayBjb3JyZWN0bHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgSGFtbWVyIGluc3RhbmNlIG1hbnVhbGx5IHRvIGFkZCBjdXN0b20gcmVjb2duaXplcnMgdGhhdCBtYXRjaCB0aGUgTWF0ZXJpYWwgRGVzaWduIHNwZWMuXG4gICAgICpcbiAgICAgKiBPdXIgZ2VzdHVyZSBuYW1lcyBjb21lIGZyb20gdGhlIE1hdGVyaWFsIERlc2lnbiBnZXN0dXJlcyBzcGVjOlxuICAgICAqIGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvcGF0dGVybnMvZ2VzdHVyZXMuaHRtbCNnZXN0dXJlcy10b3VjaC1tZWNoYW5pY3NcbiAgICAgKlxuICAgICAqIE1vcmUgaW5mb3JtYXRpb24gb24gZGVmYXVsdCByZWNvZ25pemVycyBjYW4gYmUgZm91bmQgaW4gSGFtbWVyIGRvY3M6XG4gICAgICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemVyLXBhbi9cbiAgICAgKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlY29nbml6ZXItcHJlc3MvXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgRWxlbWVudCB0byB3aGljaCB0byBhc3NpZ24gdGhlIG5ldyBIYW1tZXJKUyBnZXN0dXJlcy5cbiAgICAgKiBAcmV0dXJuIHs/fSBOZXdseS1jcmVhdGVkIEhhbW1lckpTIGluc3RhbmNlLlxuICAgICAqL1xuICAgIEdlc3R1cmVDb25maWcucHJvdG90eXBlLmJ1aWxkSGFtbWVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWMgPSBuZXcgdGhpcy5faGFtbWVyKGVsZW1lbnQpO1xuICAgICAgICAvLyBEZWZhdWx0IEhhbW1lciBSZWNvZ25pemVycy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFuID0gbmV3IHRoaXMuX2hhbW1lci5QYW4oKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3dpcGUgPSBuZXcgdGhpcy5faGFtbWVyLlN3aXBlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXNzID0gbmV3IHRoaXMuX2hhbW1lci5QcmVzcygpO1xuICAgICAgICAvLyBOb3RpY2UgdGhhdCBhIEhhbW1lckpTIHJlY29nbml6ZXIgY2FuIG9ubHkgZGVwZW5kIG9uIG9uZSBvdGhlciByZWNvZ25pemVyIG9uY2UuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgcHJldmlvdXMgYHJlY29nbml6ZVdpdGhgIHdpbGwgYmUgZHJvcHBlZC5cbiAgICAgICAgLy8gVE9ETzogQ29uZmlybSB0aHJlc2hvbGQgbnVtYmVycyB3aXRoIE1hdGVyaWFsIERlc2lnbiBVWCBUZWFtXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNsaWRlID0gdGhpcy5fY3JlYXRlUmVjb2duaXplcihwYW4sIHsgZXZlbnQ6ICdzbGlkZScsIHRocmVzaG9sZDogMCB9LCBzd2lwZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvbmdwcmVzcyA9IHRoaXMuX2NyZWF0ZVJlY29nbml6ZXIocHJlc3MsIHsgZXZlbnQ6ICdsb25ncHJlc3MnLCB0aW1lOiA1MDAgfSk7XG4gICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBgcGFuYCBldmVudCB0byB1c2UgdGhlIHN3aXBlIGV2ZW50LlxuICAgICAgICBwYW4ucmVjb2duaXplV2l0aChzd2lwZSk7XG4gICAgICAgIC8vIEFkZCBjdXN0b21pemVkIGdlc3R1cmVzIHRvIEhhbW1lciBtYW5hZ2VyXG4gICAgICAgIG1jLmFkZChbc3dpcGUsIHByZXNzLCBwYW4sIHNsaWRlLCBsb25ncHJlc3NdKTtcbiAgICAgICAgcmV0dXJuIChtYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJlY29nbml6ZXIsIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBkZWZhdWx0IHJlY29nbml6ZXJzIG9mIEhhbW1lckpTXG4gICAgICogQHBhcmFtIHs/fSBiYXNlXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHsuLi4/fSBpbmhlcml0YW5jZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEdlc3R1cmVDb25maWcucHJvdG90eXBlLl9jcmVhdGVSZWNvZ25pemVyID0gZnVuY3Rpb24gKGJhc2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGluaGVyaXRhbmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaW5oZXJpdGFuY2VzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY29nbml6ZXIgPSBuZXcgKChiYXNlLmNvbnN0cnVjdG9yKSkob3B0aW9ucyk7XG4gICAgICAgIGluaGVyaXRhbmNlcy5wdXNoKGJhc2UpO1xuICAgICAgICBpbmhlcml0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW0pOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfTtcbiAgICByZXR1cm4gR2VzdHVyZUNvbmZpZztcbn0oSGFtbWVyR2VzdHVyZUNvbmZpZykpO1xuR2VzdHVyZUNvbmZpZy5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuR2VzdHVyZUNvbmZpZy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBDbGFzcyB0byBiZSB1c2VkIHRvIHBvd2VyIHNlbGVjdGluZyBvbmUgb3IgbW9yZSBvcHRpb25zIGZyb20gYSBsaXN0LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBTZWxlY3Rpb25Nb2RlbCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9pc011bHRpXG4gICAgICogQHBhcmFtIHs/PX0gaW5pdGlhbGx5U2VsZWN0ZWRWYWx1ZXNcbiAgICAgKiBAcGFyYW0gez89fSBfZW1pdENoYW5nZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25Nb2RlbChfaXNNdWx0aSwgaW5pdGlhbGx5U2VsZWN0ZWRWYWx1ZXMsIF9lbWl0Q2hhbmdlcykge1xuICAgICAgICBpZiAoX2lzTXVsdGkgPT09IHZvaWQgMCkgeyBfaXNNdWx0aSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChfZW1pdENoYW5nZXMgPT09IHZvaWQgMCkgeyBfZW1pdENoYW5nZXMgPSB0cnVlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2lzTXVsdGkgPSBfaXNNdWx0aTtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZXMgPSBfZW1pdENoYW5nZXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50bHktc2VsZWN0ZWQgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2VsZWN0ZWQgb3B0aW9ucyB0aGF0IGhhdmVuJ3QgYmVlbiBlbWl0dGVkIGJ5IHRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kZXNlbGVjdGVkVG9FbWl0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRoYXQgaGF2ZW4ndCBiZWVuIGVtaXR0ZWQgYnkgdGhlIGNoYW5nZSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkVG9FbWl0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMuX2VtaXRDaGFuZ2VzID8gbmV3IFN1YmplY3QoKSA6IG51bGw7XG4gICAgICAgIGlmIChpbml0aWFsbHlTZWxlY3RlZFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKF9pc011bHRpKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGx5U2VsZWN0ZWRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLl9tYXJrU2VsZWN0ZWQodmFsdWUpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtTZWxlY3RlZChpbml0aWFsbHlTZWxlY3RlZFZhbHVlc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgYXJyYXkgaW4gb3JkZXIgdG8gYXZvaWQgZmlyaW5nIHRoZSBjaGFuZ2UgZXZlbnQgZm9yIHByZXNlbGVjdGVkIHZhbHVlcy5cbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkVG9FbWl0Lmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3RlZCB2YWx1ZShzKS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gQXJyYXkuZnJvbSh0aGlzLl9zZWxlY3Rpb24udmFsdWVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgdmFsdWUgb3IgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbWFya1NlbGVjdGVkKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgYSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3VubWFya1NlbGVjdGVkKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGEgdmFsdWUgYmV0d2VlbiBzZWxlY3RlZCBhbmQgZGVzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCh2YWx1ZSkgPyB0aGlzLmRlc2VsZWN0KHZhbHVlKSA6IHRoaXMuc2VsZWN0KHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgb2YgdGhlIHNlbGVjdGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdW5tYXJrQWxsKCk7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgdmFsdWUgaXMgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbi5oYXModmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtb2RlbCBkb2VzIG5vdCBoYXZlIGEgdmFsdWUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbi5zaXplID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtb2RlbCBoYXMgYSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBzZWxlY3RlZCB2YWx1ZXMgYmFzZWQgb24gYSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHs/PX0gcHJlZGljYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzTXVsdGkgJiYgdGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQuc29ydChwcmVkaWNhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIGNoYW5nZSBldmVudCBhbmQgY2xlYXJzIHRoZSByZWNvcmRzIG9mIHNlbGVjdGVkIGFuZCBkZXNlbGVjdGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRUb0VtaXQubGVuZ3RoIHx8IHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudERhdGEgPSBuZXcgU2VsZWN0aW9uQ2hhbmdlKHRoaXMuX3NlbGVjdGVkVG9FbWl0LCB0aGlzLl9kZXNlbGVjdGVkVG9FbWl0KTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UubmV4dChldmVudERhdGEpO1xuICAgICAgICAgICAgdGhpcy5fZGVzZWxlY3RlZFRvRW1pdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRUb0VtaXQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgdmFsdWUuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLl9tYXJrU2VsZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzTXVsdGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bm1hcmtBbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbi5hZGQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRUb0VtaXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyBhIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5fdW5tYXJrU2VsZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbi5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzZWxlY3RlZFRvRW1pdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIG91dCB0aGUgc2VsZWN0ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLl91bm1hcmtBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMuX3VubWFya1NlbGVjdGVkKHZhbHVlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTZWxlY3Rpb25Nb2RlbDtcbn0oKSk7XG4vKipcbiAqIERlc2NyaWJlcyBhbiBldmVudCBlbWl0dGVkIHdoZW4gdGhlIHZhbHVlIG9mIGEgTWRTZWxlY3Rpb25Nb2RlbCBoYXMgY2hhbmdlZC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgU2VsZWN0aW9uQ2hhbmdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gYWRkZWRcbiAgICAgKiBAcGFyYW0gez89fSByZW1vdmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uQ2hhbmdlKGFkZGVkLCByZW1vdmVkKSB7XG4gICAgICAgIHRoaXMuYWRkZWQgPSBhZGRlZDtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG4gICAgcmV0dXJuIFNlbGVjdGlvbkNoYW5nZTtcbn0oKSk7XG4vKipcbiAqIFNjcmVlbnJlYWRlcnMgd2lsbCBvZnRlbiBmaXJlIGZha2UgbW91c2Vkb3duIGV2ZW50cyB3aGVuIGEgZm9jdXNhYmxlIGVsZW1lbnRcbiAqIGlzIGFjdGl2YXRlZCB1c2luZyB0aGUga2V5Ym9hcmQuIFdlIGNhbiB0eXBpY2FsbHkgZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVzZSBmYWtlZFxuICogbW91c2Vkb3duIGV2ZW50cyBhbmQgcmVhbCBtb3VzZWRvd24gZXZlbnRzIHVzaW5nIHRoZSBcImJ1dHRvbnNcIiBwcm9wZXJ0eS4gV2hpbGVcbiAqIHJlYWwgbW91c2Vkb3ducyB3aWxsIGluZGljYXRlIHRoZSBtb3VzZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZCAoZS5nLiBcIjFcIiBmb3JcbiAqIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiksIGZha2VkIG1vdXNlZG93bnMgd2lsbCB1c3VhbGx5IHNldCB0aGUgcHJvcGVydHkgdmFsdWUgdG8gMC5cbiAqIEBwYXJhbSB7P30gZXZlbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuYnV0dG9ucyA9PT0gMDtcbn1cbi8qKlxuICogQ2xhc3MgdG8gY29vcmRpbmF0ZSB1bmlxdWUgc2VsZWN0aW9uIGJhc2VkIG9uIG5hbWUuXG4gKiBJbnRlbmRlZCB0byBiZSBjb25zdW1lZCBhcyBhbiBBbmd1bGFyIHNlcnZpY2UuXG4gKiBUaGlzIHNlcnZpY2UgaXMgbmVlZGVkIGJlY2F1c2UgbmF0aXZlIHJhZGlvIGNoYW5nZSBldmVudHMgYXJlIG9ubHkgZmlyZWQgb24gdGhlIGl0ZW0gY3VycmVudGx5XG4gKiBiZWluZyBzZWxlY3RlZCwgYW5kIHdlIHN0aWxsIG5lZWQgdG8gdW5jaGVjayB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLlxuICpcbiAqIFRoaXMgc2VydmljZSBkb2VzIG5vdCAqc3RvcmUqIGFueSBJRHMgYW5kIG5hbWVzIGJlY2F1c2UgdGhleSBtYXkgY2hhbmdlIGF0IGFueSB0aW1lLCBzbyBpdCBpc1xuICogbGVzcyBlcnJvci1wcm9uZSBpZiB0aGV5IGFyZSBzaW1wbHkgcGFzc2VkIHRocm91Z2ggd2hlbiB0aGUgZXZlbnRzIG9jY3VyLlxuICovXG52YXIgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIoKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgb3RoZXIgaXRlbXMgdGhhdCBzZWxlY3Rpb24gZm9yIHRoZSBnaXZlbiBuYW1lIGhhcyBiZWVuIHNldC5cbiAgICAgKiBAcGFyYW0gez99IGlkIElEIG9mIHRoZSBpdGVtLlxuICAgICAqIEBwYXJhbSB7P30gbmFtZSBOYW1lIG9mIHRoZSBpdGVtLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGlkLCBuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9saXN0ZW5lcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBsaXN0ZW5lcihpZCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgZnV0dXJlIGNoYW5nZXMgdG8gaXRlbSBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIHs/fSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyO1xufSgpKTtcblVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQHBhcmFtIHs/fSBwYXJlbnREaXNwYXRjaGVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWShwYXJlbnREaXNwYXRjaGVyKSB7XG4gICAgcmV0dXJuIHBhcmVudERpc3BhdGNoZXIgfHwgbmV3IFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIoKTtcbn1cbnZhciBVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVIgPSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIGRpc3BhdGNoZXIgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLFxuICAgIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyXV0sXG4gICAgdXNlRmFjdG9yeTogVU5JUVVFX1NFTEVDVElPTl9ESVNQQVRDSEVSX1BST1ZJREVSX0ZBQ1RPUllcbn07XG4vLyBUaGlzIGlzIHRoZSB2YWx1ZSB1c2VkIGJ5IEFuZ3VsYXJKUyBNYXRlcmlhbC4gVGhyb3VnaCB0cmlhbCBhbmQgZXJyb3IgKG9uIGlQaG9uZSA2UykgdGhleSBmb3VuZFxuLy8gdGhhdCBhIHZhbHVlIG9mIGFyb3VuZCA2NTBtcyBzZWVtcyBhcHByb3ByaWF0ZS5cbnZhciBUT1VDSF9CVUZGRVJfTVMgPSA2NTA7XG4vKipcbiAqIE1vbml0b3JzIG1vdXNlIGFuZCBrZXlib2FyZCBldmVudHMgdG8gZGV0ZXJtaW5lIHRoZSBjYXVzZSBvZiBmb2N1cyBldmVudHMuXG4gKi9cbnZhciBGb2N1c09yaWdpbk1vbml0b3IgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IF9wbGF0Zm9ybVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZvY3VzT3JpZ2luTW9uaXRvcihfbmdab25lLCBfcGxhdGZvcm0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9jdXMgb3JpZ2luIHRoYXQgdGhlIG5leHQgZm9jdXMgZXZlbnQgaXMgYSByZXN1bHQgb2YuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vcmlnaW4gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgd2luZG93IGhhcyBqdXN0IGJlZW4gZm9jdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3dpbmRvd0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlYWsgbWFwIG9mIGVsZW1lbnRzIGJlaW5nIG1vbml0b3JlZCB0byB0aGVpciBpbmZvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZWxlbWVudEluZm8gPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3JlZ2lzdGVyRG9jdW1lbnRFdmVudHMoKTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vbml0b3JzIGZvY3VzIG9uIGFuIGVsZW1lbnQgYW5kIGFwcGxpZXMgYXBwcm9wcmlhdGUgQ1NTIGNsYXNzZXMuXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIG1vbml0b3JcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyIFRoZSByZW5kZXJlciB0byB1c2UgdG8gYXBwbHkgQ1NTIGNsYXNzZXMgdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHs/fSBjaGVja0NoaWxkcmVuIFdoZXRoZXIgdG8gY291bnQgdGhlIGVsZW1lbnQgYXMgZm9jdXNlZCB3aGVuIGl0cyBjaGlsZHJlbiBhcmUgZm9jdXNlZC5cbiAgICAgKiBAcmV0dXJuIHs/fSBBbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbiB0aGUgZm9jdXMgc3RhdGUgb2YgdGhlIGVsZW1lbnQgY2hhbmdlcy5cbiAgICAgKiAgICAgV2hlbiB0aGUgZWxlbWVudCBpcyBibHVycmVkLCBudWxsIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBGb2N1c09yaWdpbk1vbml0b3IucHJvdG90eXBlLm1vbml0b3IgPSBmdW5jdGlvbiAoZWxlbWVudCwgcmVuZGVyZXIsIGNoZWNrQ2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB3ZSdyZSBub3Qgb24gdGhlIGJyb3dzZXIgcGxhdGZvcm0uXG4gICAgICAgIGlmICghdGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFscmVhZHkgbW9uaXRvcmluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50SW5mby5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZm9fMSA9IHRoaXMuX2VsZW1lbnRJbmZvLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGluZm9fMS5jaGVja0NoaWxkcmVuID0gY2hlY2tDaGlsZHJlbjtcbiAgICAgICAgICAgIHJldHVybiBpbmZvXzEuc3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgbW9uaXRvcmVkIGVsZW1lbnQgaW5mby5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5mbyA9IHtcbiAgICAgICAgICAgIHVubGlzdGVuOiBudWxsLFxuICAgICAgICAgICAgY2hlY2tDaGlsZHJlbjogY2hlY2tDaGlsZHJlbixcbiAgICAgICAgICAgIHJlbmRlcmVyOiByZW5kZXJlcixcbiAgICAgICAgICAgIHN1YmplY3Q6IG5ldyBTdWJqZWN0KClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZWxlbWVudEluZm8uc2V0KGVsZW1lbnQsIGluZm8pO1xuICAgICAgICAvLyBTdGFydCBsaXN0ZW5pbmcuIFdlIG5lZWQgdG8gbGlzdGVuIGluIGNhcHR1cmUgcGhhc2Ugc2luY2UgZm9jdXMgZXZlbnRzIGRvbid0IGJ1YmJsZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9jdXNMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuX29uRm9jdXMoZXZlbnQsIGVsZW1lbnQpOyB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBibHVyTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLl9vbkJsdXIoZXZlbnQsIGVsZW1lbnQpOyB9O1xuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZvY3VzTGlzdGVuZXIsIHRydWUpO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgYmx1ckxpc3RlbmVyLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBhbiB1bmxpc3RlbiBmdW5jdGlvbiBmb3IgbGF0ZXIuXG4gICAgICAgIGluZm8udW5saXN0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZm9jdXNMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBibHVyTGlzdGVuZXIsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5mby5zdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcHMgbW9uaXRvcmluZyBhbiBlbGVtZW50IGFuZCByZW1vdmVzIGFsbCBmb2N1cyBjbGFzc2VzLlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBUaGUgZWxlbWVudCB0byBzdG9wIG1vbml0b3JpbmcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c09yaWdpbk1vbml0b3IucHJvdG90eXBlLnN0b3BNb25pdG9yaW5nID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudEluZm8gPSB0aGlzLl9lbGVtZW50SW5mby5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50SW5mbykge1xuICAgICAgICAgICAgZWxlbWVudEluZm8udW5saXN0ZW4oKTtcbiAgICAgICAgICAgIGVsZW1lbnRJbmZvLnN1YmplY3QuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldENsYXNzZXMoZWxlbWVudCwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50SW5mby5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGVsZW1lbnQgdmlhIHRoZSBzcGVjaWZpZWQgZm9jdXMgb3JpZ2luLlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBUaGUgZWxlbWVudCB0byBmb2N1cy5cbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyIFRoZSByZW5kZXJlciB0byB1c2UgdG8gaW52b2tlIHRoZSBmb2N1cyBtZXRob2Qgb24gdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW4gVGhlIGZvY3VzIG9yaWdpbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuZm9jdXNWaWEgPSBmdW5jdGlvbiAoZWxlbWVudCwgcmVuZGVyZXIsIG9yaWdpbikge1xuICAgICAgICB0aGlzLl9zZXRPcmlnaW5Gb3JDdXJyZW50RXZlbnRRdWV1ZShvcmlnaW4pO1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBkb2N1bWVudCBhbmQgd2luZG93LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNPcmlnaW5Nb25pdG9yLnByb3RvdHlwZS5fcmVnaXN0ZXJEb2N1bWVudEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB3ZSdyZSBub3Qgb24gdGhlIGJyb3dzZXIgcGxhdGZvcm0uXG4gICAgICAgIGlmICghdGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogd2UgbGlzdGVuIHRvIGV2ZW50cyBpbiB0aGUgY2FwdHVyZSBwaGFzZSBzbyB3ZSBjYW4gZGV0ZWN0IHRoZW0gZXZlbiBpZiB0aGUgdXNlciBzdG9wc1xuICAgICAgICAvLyBwcm9wYWdhdGlvbi5cbiAgICAgICAgLy8gT24ga2V5ZG93biByZWNvcmQgdGhlIG9yaWdpbiBhbmQgY2xlYXIgYW55IHRvdWNoIGV2ZW50IHRoYXQgbWF5IGJlIGluIHByb2dyZXNzLlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2xhc3RUb3VjaFRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5fc2V0T3JpZ2luRm9yQ3VycmVudEV2ZW50UXVldWUoJ2tleWJvYXJkJyk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICAvLyBPbiBtb3VzZWRvd24gcmVjb3JkIHRoZSBvcmlnaW4gb25seSBpZiB0aGVyZSBpcyBub3QgdG91Y2ggdGFyZ2V0LCBzaW5jZSBhIG1vdXNlZG93biBjYW5cbiAgICAgICAgLy8gaGFwcGVuIGFzIGEgcmVzdWx0IG9mIGEgdG91Y2ggZXZlbnQuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2xhc3RUb3VjaFRhcmdldCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZXRPcmlnaW5Gb3JDdXJyZW50RXZlbnRRdWV1ZSgnbW91c2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIC8vIFdoZW4gdGhlIHRvdWNoc3RhcnQgZXZlbnQgZmlyZXMgdGhlIGZvY3VzIGV2ZW50IGlzIG5vdCB5ZXQgaW4gdGhlIGV2ZW50IHF1ZXVlLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIHdlIGNhbid0IHJlbHkgb24gdGhlIHRyaWNrIHVzZWQgYWJvdmUgKHNldHRpbmcgdGltZW91dCBvZiAwbXMpLiBJbnN0ZWFkIHdlIHdhaXQgNjUwbXMgdG9cbiAgICAgICAgLy8gc2VlIGlmIGEgZm9jdXMgaGFwcGVucy5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl90b3VjaFRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5fdG91Y2hUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9sYXN0VG91Y2hUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBfdGhpcy5fdG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbGFzdFRvdWNoVGFyZ2V0ID0gbnVsbDsgfSwgVE9VQ0hfQlVGRkVSX01TKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIC8vIE1ha2UgYSBub3RlIG9mIHdoZW4gdGhlIHdpbmRvdyByZWdhaW5zIGZvY3VzLCBzbyB3ZSBjYW4gcmVzdG9yZSB0aGUgb3JpZ2luIGluZm8gZm9yIHRoZVxuICAgICAgICAvLyBmb2N1c2VkIGVsZW1lbnQuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl93aW5kb3dGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3dpbmRvd0ZvY3VzZWQgPSBmYWxzZTsgfSwgMCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZm9jdXMgY2xhc3NlcyBvbiB0aGUgZWxlbWVudCBiYXNlZCBvbiB0aGUgZ2l2ZW4gZm9jdXMgb3JpZ2luLlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBUaGUgZWxlbWVudCB0byB1cGRhdGUgdGhlIGNsYXNzZXMgb24uXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW4gVGhlIGZvY3VzIG9yaWdpbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuX3NldENsYXNzZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3JpZ2luKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlcmVyID0gdGhpcy5fZWxlbWVudEluZm8uZ2V0KGVsZW1lbnQpLnJlbmRlcmVyO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIHNob3VsZFNldCkge1xuICAgICAgICAgICAgc2hvdWxkU2V0ID8gcmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSA6IHJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRvZ2dsZUNsYXNzKCdjZGstZm9jdXNlZCcsICEhb3JpZ2luKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoJ2Nkay10b3VjaC1mb2N1c2VkJywgb3JpZ2luID09PSAndG91Y2gnKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoJ2Nkay1rZXlib2FyZC1mb2N1c2VkJywgb3JpZ2luID09PSAna2V5Ym9hcmQnKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoJ2Nkay1tb3VzZS1mb2N1c2VkJywgb3JpZ2luID09PSAnbW91c2UnKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoJ2Nkay1wcm9ncmFtLWZvY3VzZWQnLCBvcmlnaW4gPT09ICdwcm9ncmFtJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcmlnaW4gYW5kIHNjaGVkdWxlcyBhbiBhc3luYyBmdW5jdGlvbiB0byBjbGVhciBpdCBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBxdWV1ZS5cbiAgICAgKiBAcGFyYW0gez99IG9yaWdpbiBUaGUgb3JpZ2luIHRvIHNldC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuX3NldE9yaWdpbkZvckN1cnJlbnRFdmVudFF1ZXVlID0gZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29yaWdpbiA9IG51bGw7IH0sIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGZvY3VzIGV2ZW50IHdhcyBjYXVzZWQgYnkgYSB0b3VjaHN0YXJ0IGV2ZW50LlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnQgVGhlIGZvY3VzIGV2ZW50IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4gez99IFdoZXRoZXIgdGhlIGV2ZW50IHdhcyBjYXVzZWQgYnkgYSB0b3VjaC5cbiAgICAgKi9cbiAgICBGb2N1c09yaWdpbk1vbml0b3IucHJvdG90eXBlLl93YXNDYXVzZWRCeVRvdWNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIE5vdGUobW1hbGVyYmEpOiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCBxdWl0ZSBwZXJmZWN0LCB0aGVyZSBpcyBhIHNtYWxsIGVkZ2UgY2FzZS5cbiAgICAgICAgLy8gQ29uc2lkZXIgdGhlIGZvbGxvd2luZyBkb20gc3RydWN0dXJlOlxuICAgICAgICAvL1xuICAgICAgICAvLyA8ZGl2ICNwYXJlbnQgdGFiaW5kZXg9XCIwXCIgY2RrRm9jdXNDbGFzc2VzPlxuICAgICAgICAvLyAgIDxkaXYgI2NoaWxkIChjbGljayk9XCIjcGFyZW50LmZvY3VzKClcIj48L2Rpdj5cbiAgICAgICAgLy8gPC9kaXY+XG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHRvdWNoZXMgdGhlICNjaGlsZCBlbGVtZW50IGFuZCB0aGUgI3BhcmVudCBpcyBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzZWQgYXMgYVxuICAgICAgICAvLyByZXN1bHQsIHRoaXMgY29kZSB3aWxsIHN0aWxsIGNvbnNpZGVyIGl0IHRvIGhhdmUgYmVlbiBjYXVzZWQgYnkgdGhlIHRvdWNoIGV2ZW50IGFuZCB3aWxsXG4gICAgICAgIC8vIGFwcGx5IHRoZSBjZGstdG91Y2gtZm9jdXNlZCBjbGFzcyByYXRoZXIgdGhhbiB0aGUgY2RrLXByb2dyYW0tZm9jdXNlZCBjbGFzcy4gVGhpcyBpcyBhXG4gICAgICAgIC8vIHJlbGF0aXZlbHkgc21hbGwgZWRnZS1jYXNlIHRoYXQgY2FuIGJlIHdvcmtlZCBhcm91bmQgYnkgdXNpbmdcbiAgICAgICAgLy8gZm9jdXNWaWEocGFyZW50RWwsIHJlbmRlcmVyLCAgJ3Byb2dyYW0nKSB0byBmb2N1cyB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHdlIGRlY2lkZSB0aGF0IHdlIGFic29sdXRlbHkgbXVzdCBoYW5kbGUgdGhpcyBjYXNlIGNvcnJlY3RseSwgd2UgY2FuIGRvIHNvIGJ5IGxpc3RlbmluZ1xuICAgICAgICAvLyBmb3IgdGhlIGZpcnN0IGZvY3VzIGV2ZW50IGFmdGVyIHRoZSB0b3VjaHN0YXJ0LCBhbmQgdGhlbiB0aGUgZmlyc3QgYmx1ciBldmVudCBhZnRlciB0aGF0XG4gICAgICAgIC8vIGZvY3VzIGV2ZW50LiBXaGVuIHRoYXQgYmx1ciBldmVudCBmaXJlcyB3ZSBrbm93IHRoYXQgd2hhdGV2ZXIgZm9sbG93cyBpcyBub3QgYSByZXN1bHQgb2YgdGhlXG4gICAgICAgIC8vIHRvdWNoc3RhcnQuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvY3VzVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFzdFRvdWNoVGFyZ2V0IGluc3RhbmNlb2YgTm9kZSAmJiBmb2N1c1RhcmdldCBpbnN0YW5jZW9mIE5vZGUgJiZcbiAgICAgICAgICAgIChmb2N1c1RhcmdldCA9PT0gdGhpcy5fbGFzdFRvdWNoVGFyZ2V0IHx8IGZvY3VzVGFyZ2V0LmNvbnRhaW5zKHRoaXMuX2xhc3RUb3VjaFRhcmdldCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBmb2N1cyBldmVudHMgb24gYSByZWdpc3RlcmVkIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHs/fSBldmVudCBUaGUgZm9jdXMgZXZlbnQuXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50IFRoZSBtb25pdG9yZWQgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgLy8gTk9URShtbWFsZXJiYSk6IFdlIGN1cnJlbnRseSBzZXQgdGhlIGNsYXNzZXMgYmFzZWQgb24gdGhlIGZvY3VzIG9yaWdpbiBvZiB0aGUgbW9zdCByZWNlbnRcbiAgICAgICAgLy8gZm9jdXMgZXZlbnQgYWZmZWN0aW5nIHRoZSBtb25pdG9yZWQgZWxlbWVudC4gSWYgd2Ugd2FudCB0byB1c2UgdGhlIG9yaWdpbiBvZiB0aGUgZmlyc3QgZXZlbnRcbiAgICAgICAgLy8gaW5zdGVhZCB3ZSBzaG91bGQgY2hlY2sgZm9yIHRoZSBjZGstZm9jdXNlZCBjbGFzcyBoZXJlIGFuZCByZXR1cm4gaWYgdGhlIGVsZW1lbnQgYWxyZWFkeSBoYXNcbiAgICAgICAgLy8gaXQuIChUaGlzIG9ubHkgbWF0dGVycyBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGluY2x1ZGVzQ2hpbGRyZW4gPSB0cnVlKS5cbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBjb3VudGluZyBjaGlsZC1lbGVtZW50LWZvY3VzIGFzIGZvY3VzZWQsIG1ha2Ugc3VyZSB0aGF0IHRoZSBldmVudCB0YXJnZXQgaXMgdGhlXG4gICAgICAgIC8vIG1vbml0b3JlZCBlbGVtZW50IGl0c2VsZi5cbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50SW5mby5nZXQoZWxlbWVudCkuY2hlY2tDaGlsZHJlbiAmJiBlbGVtZW50ICE9PSBldmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBkZXRlY3QgYSBjYXVzZSBmb3IgdGhlIGZvY3VzIGV2ZW50LCBpdCdzIGR1ZSB0byBvbmUgb2YgdGhyZWUgcmVhc29uczpcbiAgICAgICAgLy8gMSkgVGhlIHdpbmRvdyBoYXMganVzdCByZWdhaW5lZCBmb2N1cywgaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIHJlc3RvcmUgdGhlIGZvY3VzZWQgc3RhdGUgb2ZcbiAgICAgICAgLy8gICAgdGhlIGVsZW1lbnQgZnJvbSBiZWZvcmUgdGhlIHdpbmRvdyBibHVycmVkLlxuICAgICAgICAvLyAyKSBJdCB3YXMgY2F1c2VkIGJ5IGEgdG91Y2ggZXZlbnQsIGluIHdoaWNoIGNhc2Ugd2UgbWFyayB0aGUgb3JpZ2luIGFzICd0b3VjaCcuXG4gICAgICAgIC8vIDMpIFRoZSBlbGVtZW50IHdhcyBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzZWQsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIG1hcmsgdGhlIG9yaWdpbiBhc1xuICAgICAgICAvLyAgICAncHJvZ3JhbScuXG4gICAgICAgIGlmICghdGhpcy5fb3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd2luZG93Rm9jdXNlZCAmJiB0aGlzLl9sYXN0Rm9jdXNPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW4gPSB0aGlzLl9sYXN0Rm9jdXNPcmlnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl93YXNDYXVzZWRCeVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbiA9ICd0b3VjaCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW4gPSAncHJvZ3JhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q2xhc3NlcyhlbGVtZW50LCB0aGlzLl9vcmlnaW4pO1xuICAgICAgICB0aGlzLl9lbGVtZW50SW5mby5nZXQoZWxlbWVudCkuc3ViamVjdC5uZXh0KHRoaXMuX29yaWdpbik7XG4gICAgICAgIHRoaXMuX2xhc3RGb2N1c09yaWdpbiA9IHRoaXMuX29yaWdpbjtcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYmx1ciBldmVudHMgb24gYSByZWdpc3RlcmVkIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHs/fSBldmVudCBUaGUgYmx1ciBldmVudC5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgVGhlIG1vbml0b3JlZCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNPcmlnaW5Nb25pdG9yLnByb3RvdHlwZS5fb25CbHVyID0gZnVuY3Rpb24gKGV2ZW50LCBlbGVtZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBjb3VudGluZyBjaGlsZC1lbGVtZW50LWZvY3VzIGFzIGZvY3VzZWQsIG1ha2Ugc3VyZSB0aGF0IHdlIGFyZW4ndCBqdXN0IGJsdXJyaW5nIGluXG4gICAgICAgIC8vIG9yZGVyIHRvIGZvY3VzIGFub3RoZXIgY2hpbGQgb2YgdGhlIG1vbml0b3JlZCBlbGVtZW50LlxuICAgICAgICBpZiAodGhpcy5fZWxlbWVudEluZm8uZ2V0KGVsZW1lbnQpLmNoZWNrQ2hpbGRyZW4gJiYgZXZlbnQucmVsYXRlZFRhcmdldCBpbnN0YW5jZW9mIE5vZGUgJiZcbiAgICAgICAgICAgIGVsZW1lbnQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRDbGFzc2VzKGVsZW1lbnQsIG51bGwpO1xuICAgICAgICB0aGlzLl9lbGVtZW50SW5mby5nZXQoZWxlbWVudCkuc3ViamVjdC5uZXh0KG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvY3VzT3JpZ2luTW9uaXRvcjtcbn0oKSk7XG5Gb2N1c09yaWdpbk1vbml0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkZvY3VzT3JpZ2luTW9uaXRvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCB9LFxuXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHRoYXQgZGV0ZXJtaW5lcyBob3cgYSBwYXJ0aWN1bGFyIGVsZW1lbnQgd2FzIGZvY3VzZWQgKHZpYSBrZXlib2FyZCwgbW91c2UsIHRvdWNoLCBvclxuICogcHJvZ3JhbW1hdGljYWxseSkgYW5kIGFkZHMgY29ycmVzcG9uZGluZyBjbGFzc2VzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gdmFyaWFudHMgb2YgdGhpcyBkaXJlY3RpdmU6XG4gKiAxKSBjZGtNb25pdG9yRWxlbWVudEZvY3VzOiBkb2VzIG5vdCBjb25zaWRlciBhbiBlbGVtZW50IHRvIGJlIGZvY3VzZWQgaWYgb25lIG9mIGl0cyBjaGlsZHJlbiBpc1xuICogICAgZm9jdXNlZC5cbiAqIDIpIGNka01vbml0b3JTdWJ0cmVlRm9jdXM6IGNvbnNpZGVycyBhbiBlbGVtZW50IGZvY3VzZWQgaWYgaXQgb3IgYW55IG9mIGl0cyBjaGlsZHJlbiBhcmUgZm9jdXNlZC5cbiAqL1xudmFyIENka01vbml0b3JGb2N1cyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c09yaWdpbk1vbml0b3JcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2RrTW9uaXRvckZvY3VzKF9lbGVtZW50UmVmLCBfZm9jdXNPcmlnaW5Nb25pdG9yLCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvciA9IF9mb2N1c09yaWdpbk1vbml0b3I7XG4gICAgICAgIHRoaXMuY2RrRm9jdXNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvci5tb25pdG9yKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgcmVuZGVyZXIsIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Nka01vbml0b3JTdWJ0cmVlRm9jdXMnKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKG9yaWdpbikgeyByZXR1cm4gX3RoaXMuY2RrRm9jdXNDaGFuZ2UuZW1pdChvcmlnaW4pOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDZGtNb25pdG9yRm9jdXMucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3Iuc3RvcE1vbml0b3JpbmcodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBDZGtNb25pdG9yRm9jdXM7XG59KCkpO1xuQ2RrTW9uaXRvckZvY3VzLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrTW9uaXRvckVsZW1lbnRGb2N1c10sIFtjZGtNb25pdG9yU3VidHJlZUZvY3VzXScsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNka01vbml0b3JGb2N1cy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c09yaWdpbk1vbml0b3IsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG5dOyB9O1xuQ2RrTW9uaXRvckZvY3VzLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdjZGtGb2N1c0NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBAcGFyYW0gez99IHBhcmVudERpc3BhdGNoZXJcbiAqIEBwYXJhbSB7P30gbmdab25lXG4gKiBAcGFyYW0gez99IHBsYXRmb3JtXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBGT0NVU19PUklHSU5fTU9OSVRPUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudERpc3BhdGNoZXIsIG5nWm9uZSwgcGxhdGZvcm0pIHtcbiAgICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgRm9jdXNPcmlnaW5Nb25pdG9yKG5nWm9uZSwgcGxhdGZvcm0pO1xufVxudmFyIEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSID0ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBGb2N1c09yaWdpbk1vbml0b3IgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBGb2N1c09yaWdpbk1vbml0b3IsXG4gICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIEZvY3VzT3JpZ2luTW9uaXRvcl0sIE5nWm9uZSwgUGxhdGZvcm1dLFxuICAgIHVzZUZhY3Rvcnk6IEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSX0ZBQ1RPUllcbn07XG4vKipcbiAqIEFwcGxpZXMgYSBDU1MgdHJhbnNmb3JtIHRvIGFuIGVsZW1lbnQsIGluY2x1ZGluZyBicm93c2VyLXByZWZpeGVkIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gdHJhbnNmb3JtVmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q3NzVHJhbnNmb3JtKGVsZW1lbnQsIHRyYW5zZm9ybVZhbHVlKSB7XG4gICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdHJpbSB0aGUgcmVzdWx0LCBiZWNhdXNlIHRoZSBicm93c2VyIHdpbGwgaWdub3JlIHRoZSBzZXQgb3BlcmF0aW9uXG4gICAgLy8gaWYgdGhlIHN0cmluZyBjb250YWlucyBvbmx5IHdoaXRlc3BhY2UuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0cmFuc2Zvcm1WYWx1ZS50cmltKCk7XG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZTtcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHZhbHVlO1xufVxudmFyIFN0eWxlTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBTdHlsZU1vZHVsZTtcbn0oKSk7XG5TdHlsZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1BsYXRmb3JtTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtDZGtNb25pdG9yRm9jdXNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDZGtNb25pdG9yRm9jdXNdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0ZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU3R5bGVNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBBbmltYXRpb25DdXJ2ZXMgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25DdXJ2ZXMoKSB7XG4gICAgfVxuICAgIHJldHVybiBBbmltYXRpb25DdXJ2ZXM7XG59KCkpO1xuQW5pbWF0aW9uQ3VydmVzLlNUQU5EQVJEX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDAuMiwxKSc7XG5BbmltYXRpb25DdXJ2ZXMuREVDRUxFUkFUSU9OX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjAsMC4wLDAuMiwxKSc7XG5BbmltYXRpb25DdXJ2ZXMuQUNDRUxFUkFUSU9OX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDEsMSknO1xuQW5pbWF0aW9uQ3VydmVzLlNIQVJQX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDAuNiwxKSc7XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgQW5pbWF0aW9uRHVyYXRpb25zID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uRHVyYXRpb25zKCkge1xuICAgIH1cbiAgICByZXR1cm4gQW5pbWF0aW9uRHVyYXRpb25zO1xufSgpKTtcbkFuaW1hdGlvbkR1cmF0aW9ucy5DT01QTEVYID0gJzM3NW1zJztcbkFuaW1hdGlvbkR1cmF0aW9ucy5FTlRFUklORyA9ICcyMjVtcyc7XG5BbmltYXRpb25EdXJhdGlvbnMuRVhJVElORyA9ICcxOTVtcyc7XG4vKipcbiAqIENvZXJjZXMgYSBkYXRhLWJvdW5kIHZhbHVlICh0eXBpY2FsbHkgYSBzdHJpbmcpIHRvIGEgbnVtYmVyLlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHBhcmFtIHs/PX0gZmFsbGJhY2tWYWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29lcmNlTnVtYmVyUHJvcGVydHkodmFsdWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgICBpZiAoZmFsbGJhY2tWYWx1ZSA9PT0gdm9pZCAwKSB7IGZhbGxiYWNrVmFsdWUgPSAwOyB9XG4gICAgLy8gcGFyc2VGbG9hdCh2YWx1ZSkgaGFuZGxlcyBtb3N0IG9mIHRoZSBjYXNlcyB3ZSdyZSBpbnRlcmVzdGVkIGluIChpdCB0cmVhdHMgbnVsbCwgZW1wdHkgc3RyaW5nLFxuICAgIC8vIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcyBhcyBOYU4sIHdoZXJlIE51bWJlciBqdXN0IHVzZXMgMCkgYnV0IGl0IGNvbnNpZGVycyB0aGUgc3RyaW5nXG4gICAgLy8gJzEyM2hlbGxvJyB0byBiZSBhIHZhbGlkIG51bWJlci4gVGhlcmVmb3JlIHdlIGFsc28gY2hlY2sgaWYgTnVtYmVyKHZhbHVlKSBpcyBOYU4uXG4gICAgcmV0dXJuIGlzTmFOKHBhcnNlRmxvYXQoLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpKSkgfHwgaXNOYU4oTnVtYmVyKHZhbHVlKSkgPyBmYWxsYmFja1ZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbn1cbi8qKlxuICogQWRhcHRzIHR5cGUgYERgIHRvIGJlIHVzYWJsZSBhcyBhIGRhdGUgYnkgY2RrLWJhc2VkIGNvbXBvbmVudHMgdGhhdCB3b3JrIHdpdGggZGF0ZXMuXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIERhdGVBZGFwdGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZUFkYXB0ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHllYXIgY29tcG9uZW50IG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSB0byBleHRyYWN0IHRoZSB5ZWFyIGZyb20uXG4gICAgICogQHJldHVybiB7P30gVGhlIHllYXIgY29tcG9uZW50LlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXRZZWFyID0gZnVuY3Rpb24gKGRhdGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtb250aCBjb21wb25lbnQgb2YgdGhlIGdpdmVuIGRhdGUuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBkYXRlIFRoZSBkYXRlIHRvIGV4dHJhY3QgdGhlIG1vbnRoIGZyb20uXG4gICAgICogQHJldHVybiB7P30gVGhlIG1vbnRoIGNvbXBvbmVudCAoMC1pbmRleGVkLCAwID0gSmFudWFyeSkuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldE1vbnRoID0gZnVuY3Rpb24gKGRhdGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRlIG9mIHRoZSBtb250aCBjb21wb25lbnQgb2YgdGhlIGdpdmVuIGRhdGUuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBkYXRlIFRoZSBkYXRlIHRvIGV4dHJhY3QgdGhlIGRhdGUgb2YgdGhlIG1vbnRoIGZyb20uXG4gICAgICogQHJldHVybiB7P30gVGhlIG1vbnRoIGNvbXBvbmVudCAoMS1pbmRleGVkLCAxID0gZmlyc3Qgb2YgbW9udGgpLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKGRhdGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXkgb2YgdGhlIHdlZWsgY29tcG9uZW50IG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSB0byBleHRyYWN0IHRoZSBkYXkgb2YgdGhlIHdlZWsgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgbW9udGggY29tcG9uZW50ICgwLWluZGV4ZWQsIDAgPSBTdW5kYXkpLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXREYXlPZldlZWsgPSBmdW5jdGlvbiAoZGF0ZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIG5hbWVzIGZvciB0aGUgbW9udGhzLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGUgVGhlIG5hbWluZyBzdHlsZSAoZS5nLiBsb25nID0gJ0phbnVhcnknLCBzaG9ydCA9ICdKYW4nLCBuYXJyb3cgPSAnSicpLlxuICAgICAqIEByZXR1cm4gez99IEFuIG9yZGVyZWQgbGlzdCBvZiBhbGwgbW9udGggbmFtZXMsIHN0YXJ0aW5nIHdpdGggSmFudWFyeS5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0TW9udGhOYW1lcyA9IGZ1bmN0aW9uIChzdHlsZSQkMSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIG5hbWVzIGZvciB0aGUgZGF0ZXMgb2YgdGhlIG1vbnRoLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm4gez99IEFuIG9yZGVyZWQgbGlzdCBvZiBhbGwgZGF0ZSBvZiB0aGUgbW9udGggbmFtZXMsIHN0YXJ0aW5nIHdpdGggJzEnLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXREYXRlTmFtZXMgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgbmFtZXMgZm9yIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGUgVGhlIG5hbWluZyBzdHlsZSAoZS5nLiBsb25nID0gJ1N1bmRheScsIHNob3J0ID0gJ1N1bicsIG5hcnJvdyA9ICdTJykuXG4gICAgICogQHJldHVybiB7P30gQW4gb3JkZXJlZCBsaXN0IG9mIGFsbCB3ZWVrZGF5IG5hbWVzLCBzdGFydGluZyB3aXRoIFN1bmRheS5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF5T2ZXZWVrTmFtZXMgPSBmdW5jdGlvbiAoc3R5bGUkJDEpIHsgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIGZvciB0aGUgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGRhdGUgVGhlIGRhdGUgdG8gZ2V0IHRoZSB5ZWFyIG5hbWUgZm9yLlxuICAgICAqIEByZXR1cm4gez99IFRoZSBuYW1lIG9mIHRoZSBnaXZlbiB5ZWFyIChlLmcuICcyMDE3JykuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldFllYXJOYW1lID0gZnVuY3Rpb24gKGRhdGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybiB7P30gVGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMC1pbmRleGVkLCAwID0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0Rmlyc3REYXlPZldlZWsgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSB3aG9zZSBtb250aCBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXROdW1EYXlzSW5Nb250aCA9IGZ1bmN0aW9uIChkYXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSB0byBjbG9uZVxuICAgICAqIEByZXR1cm4gez99IEEgbmV3IGRhdGUgZXF1YWwgdG8gdGhlIGdpdmVuIGRhdGUuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKGRhdGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGF0ZSB3aXRoIHRoZSBnaXZlbiB5ZWFyLCBtb250aCwgYW5kIGRhdGUuIERvZXMgbm90IGFsbG93IG92ZXIvdW5kZXItZmxvdyBvZiB0aGVcbiAgICAgKiBtb250aCBhbmQgZGF0ZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHllYXIgVGhlIGZ1bGwgeWVhciBvZiB0aGUgZGF0ZS4gKGUuZy4gODkgbWVhbnMgdGhlIHllYXIgODksIG5vdCB0aGUgeWVhciAxOTg5KS5cbiAgICAgKiBAcGFyYW0gez99IG1vbnRoIFRoZSBtb250aCBvZiB0aGUgZGF0ZSAoMC1pbmRleGVkLCAwID0gSmFudWFyeSkuIE11c3QgYmUgYW4gaW50ZWdlciAwIC0gMTEuXG4gICAgICogQHBhcmFtIHs/fSBkYXRlIFRoZSBkYXRlIG9mIG1vbnRoIG9mIHRoZSBkYXRlLiBNdXN0IGJlIGFuIGludGVnZXIgMSAtIGxlbmd0aCBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICogQHJldHVybiB7P30gVGhlIG5ldyBkYXRlLCBvciBudWxsIGlmIGludmFsaWQuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZURhdGUgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgsIGRhdGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRvZGF5J3MgZGF0ZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJuIHs/fSBUb2RheSdzIGRhdGUuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLnRvZGF5ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGRhdGUgZnJvbSBhIHZhbHVlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWUgVGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEBwYXJhbSB7P30gcGFyc2VGb3JtYXQgVGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgdmFsdWUgYmVpbmcgcGFyc2VkXG4gICAgICogICAgICh0eXBlIGlzIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudCkuXG4gICAgICogQHJldHVybiB7P30gVGhlIHBhcnNlZCBkYXRlLCBvciBudWxsIGlmIGRhdGUgY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodmFsdWUsIHBhcnNlRm9ybWF0KSB7IH07XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIGRhdGUgYXMgYSBzdHJpbmcuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBkYXRlIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcGFyYW0gez99IGRpc3BsYXlGb3JtYXQgVGhlIGZvcm1hdCB0byB1c2UgdG8gZGlzcGxheSB0aGUgZGF0ZSBhcyBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgcGFyc2VkIGRhdGUsIG9yIG51bGwgaWYgZGF0ZSBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgZGlzcGxheUZvcm1hdCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIG51bWJlciBvZiB5ZWFycyB0byB0aGUgZGF0ZS4gWWVhcnMgYXJlIGNvdW50ZWQgYXMgaWYgZmxpcHBpbmcgMTIgcGFnZXMgb24gdGhlXG4gICAgICogY2FsZW5kYXIgZm9yIGVhY2ggeWVhciBhbmQgdGhlbiBmaW5kaW5nIHRoZSBjbG9zZXN0IGRhdGUgaW4gdGhlIG5ldyBtb250aC4gRm9yIGV4YW1wbGUgd2hlblxuICAgICAqIGFkZGluZyAxIHllYXIgdG8gRmViIDI5LCAyMDE2LCB0aGUgcmVzdWx0aW5nIGRhdGUgd2lsbCBiZSBGZWIgMjgsIDIwMTcuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBkYXRlIFRoZSBkYXRlIHRvIGFkZCB5ZWFycyB0by5cbiAgICAgKiBAcGFyYW0gez99IHllYXJzIFRoZSBudW1iZXIgb2YgeWVhcnMgdG8gYWRkIChtYXkgYmUgbmVnYXRpdmUpLlxuICAgICAqIEByZXR1cm4gez99IEEgbmV3IGRhdGUgZXF1YWwgdG8gdGhlIGdpdmVuIG9uZSB3aXRoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHllYXJzIGFkZGVkLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5hZGRDYWxlbmRhclllYXJzID0gZnVuY3Rpb24gKGRhdGUsIHllYXJzKSB7IH07XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1vbnRocyB0byB0aGUgZGF0ZS4gTW9udGhzIGFyZSBjb3VudGVkIGFzIGlmIGZsaXBwaW5nIGEgcGFnZSBvbiB0aGVcbiAgICAgKiBjYWxlbmRhciBmb3IgZWFjaCBtb250aCBhbmQgdGhlbiBmaW5kaW5nIHRoZSBjbG9zZXN0IGRhdGUgaW4gdGhlIG5ldyBtb250aC4gRm9yIGV4YW1wbGUgd2hlblxuICAgICAqIGFkZGluZyAxIG1vbnRoIHRvIEphbiAzMSwgMjAxNywgdGhlIHJlc3VsdGluZyBkYXRlIHdpbGwgYmUgRmViIDI4LCAyMDE3LlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSB0byBhZGQgbW9udGhzIHRvLlxuICAgICAqIEBwYXJhbSB7P30gbW9udGhzIFRoZSBudW1iZXIgb2YgbW9udGhzIHRvIGFkZCAobWF5IGJlIG5lZ2F0aXZlKS5cbiAgICAgKiBAcmV0dXJuIHs/fSBBIG5ldyBkYXRlIGVxdWFsIHRvIHRoZSBnaXZlbiBvbmUgd2l0aCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtb250aHMgYWRkZWQuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmFkZENhbGVuZGFyTW9udGhzID0gZnVuY3Rpb24gKGRhdGUsIG1vbnRocykgeyB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIG51bWJlciBvZiBkYXlzIHRvIHRoZSBkYXRlLiBEYXlzIGFyZSBjb3VudGVkIGFzIGlmIG1vdmluZyBvbmUgY2VsbCBvbiB0aGVcbiAgICAgKiBjYWxlbmRhciBmb3IgZWFjaCBkYXkuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBkYXRlIFRoZSBkYXRlIHRvIGFkZCBkYXlzIHRvLlxuICAgICAqIEBwYXJhbSB7P30gZGF5cyBUaGUgbnVtYmVyIG9mIGRheXMgdG8gYWRkIChtYXkgYmUgbmVnYXRpdmUpLlxuICAgICAqIEByZXR1cm4gez99IEEgbmV3IGRhdGUgZXF1YWwgdG8gdGhlIGdpdmVuIG9uZSB3aXRoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRheXMgYWRkZWQuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmFkZENhbGVuZGFyRGF5cyA9IGZ1bmN0aW9uIChkYXRlLCBkYXlzKSB7IH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUkZDIDMzMzkgY29tcGF0aWJsZSBkYXRlIHN0cmluZyAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkpICBmb3IgdGhlIGdpdmVuXG4gICAgICogZGF0ZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGRhdGUgVGhlIGRhdGUgdG8gZ2V0IHRoZSBJU08gZGF0ZSBzdHJpbmcgZm9yLlxuICAgICAqIEByZXR1cm4gez99IFRoZSBJU08gZGF0ZSBzdHJpbmcgZGF0ZSBzdHJpbmcuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldElTT0RhdGVTdHJpbmcgPSBmdW5jdGlvbiAoZGF0ZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxvY2FsZSB1c2VkIGZvciBhbGwgZGF0ZXMuXG4gICAgICogQHBhcmFtIHs/fSBsb2NhbGUgVGhlIG5ldyBsb2NhbGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuc2V0TG9jYWxlID0gZnVuY3Rpb24gKGxvY2FsZSkge1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHR3byBkYXRlcy5cbiAgICAgKiBAcGFyYW0gez99IGZpcnN0IFRoZSBmaXJzdCBkYXRlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHs/fSBzZWNvbmQgVGhlIHNlY29uZCBkYXRlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybiB7P30gMCBpZiB0aGUgZGF0ZXMgYXJlIGVxdWFsLCBhIG51bWJlciBsZXNzIHRoYW4gMCBpZiB0aGUgZmlyc3QgZGF0ZSBpcyBlYXJsaWVyLFxuICAgICAqICAgICBhIG51bWJlciBncmVhdGVyIHRoYW4gMCBpZiB0aGUgZmlyc3QgZGF0ZSBpcyBsYXRlci5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuY29tcGFyZURhdGUgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRZZWFyKGZpcnN0KSAtIHRoaXMuZ2V0WWVhcihzZWNvbmQpIHx8XG4gICAgICAgICAgICB0aGlzLmdldE1vbnRoKGZpcnN0KSAtIHRoaXMuZ2V0TW9udGgoc2Vjb25kKSB8fFxuICAgICAgICAgICAgdGhpcy5nZXREYXRlKGZpcnN0KSAtIHRoaXMuZ2V0RGF0ZShzZWNvbmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHR3byBkYXRlcyBhcmUgZXF1YWwuXG4gICAgICogQHBhcmFtIHs/fSBmaXJzdCBUaGUgZmlyc3QgZGF0ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gez99IHNlY29uZCBUaGUgc2Vjb25kIGRhdGUgdG8gY2hlY2suXG4gICAgICogICAgIE51bGwgZGF0ZXMgYXJlIGNvbnNpZGVyZWQgZXF1YWwgdG8gb3RoZXIgbnVsbCBkYXRlcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5zYW1lRGF0ZSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiBmaXJzdCAmJiBzZWNvbmQgPyAhdGhpcy5jb21wYXJlRGF0ZShmaXJzdCwgc2Vjb25kKSA6IGZpcnN0ID09IHNlY29uZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsYW1wIHRoZSBnaXZlbiBkYXRlIGJldHdlZW4gbWluIGFuZCBtYXggZGF0ZXMuXG4gICAgICogQHBhcmFtIHs/fSBkYXRlIFRoZSBkYXRlIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7Pz19IG1pbiBUaGUgbWluaW11bSB2YWx1ZSB0byBhbGxvdy4gSWYgbnVsbCBvciBvbWl0dGVkIG5vIG1pbiBpcyBlbmZvcmNlZC5cbiAgICAgKiBAcGFyYW0gez89fSBtYXggVGhlIG1heGltdW0gdmFsdWUgdG8gYWxsb3cuIElmIG51bGwgb3Igb21pdHRlZCBubyBtYXggaXMgZW5mb3JjZWQuXG4gICAgICogQHJldHVybiB7P30gYG1pbmAgaWYgYGRhdGVgIGlzIGxlc3MgdGhhbiBgbWluYCwgYG1heGAgaWYgZGF0ZSBpcyBncmVhdGVyIHRoYW4gYG1heGAsXG4gICAgICogICAgIG90aGVyd2lzZSBgZGF0ZWAuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmNsYW1wRGF0ZSA9IGZ1bmN0aW9uIChkYXRlLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAobWluICYmIHRoaXMuY29tcGFyZURhdGUoZGF0ZSwgbWluKSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCAmJiB0aGlzLmNvbXBhcmVEYXRlKGRhdGUsIG1heCkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVBZGFwdGVyO1xufSgpKTtcbi8qKlxuICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgSW50bCBBUEkuXG4gKi9cbnZhciBTVVBQT1JUU19JTlRMX0FQSSA9IHR5cGVvZiBJbnRsICE9ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBtb250aCBuYW1lcyB0byB1c2UgaWYgSW50bCBBUEkgaXMgbm90IGF2YWlsYWJsZS5cbiAqL1xudmFyIERFRkFVTFRfTU9OVEhfTkFNRVMgPSB7XG4gICAgJ2xvbmcnOiBbXG4gICAgICAgICdKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsXG4gICAgICAgICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ1xuICAgIF0sXG4gICAgJ3Nob3J0JzogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICAgICduYXJyb3cnOiBbJ0onLCAnRicsICdNJywgJ0EnLCAnTScsICdKJywgJ0onLCAnQScsICdTJywgJ08nLCAnTicsICdEJ11cbn07XG4vKipcbiAqIFRoZSBkZWZhdWx0IGRhdGUgbmFtZXMgdG8gdXNlIGlmIEludGwgQVBJIGlzIG5vdCBhdmFpbGFibGUuXG4gKi9cbnZhciBERUZBVUxUX0RBVEVfTkFNRVMgPSByYW5nZSgzMSwgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIFN0cmluZyhpICsgMSk7IH0pO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBkYXkgb2YgdGhlIHdlZWsgbmFtZXMgdG8gdXNlIGlmIEludGwgQVBJIGlzIG5vdCBhdmFpbGFibGUuXG4gKi9cbnZhciBERUZBVUxUX0RBWV9PRl9XRUVLX05BTUVTID0ge1xuICAgICdsb25nJzogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuICAgICdzaG9ydCc6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gICAgJ25hcnJvdyc6IFsnUycsICdNJywgJ1QnLCAnVycsICdUJywgJ0YnLCAnUyddXG59O1xuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGFuZCBmaWxscyBpdCB3aXRoIHZhbHVlcy5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IGxlbmd0aFxuICogQHBhcmFtIHs/fSB2YWx1ZUZ1bmN0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByYW5nZShsZW5ndGgsIHZhbHVlRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkobGVuZ3RoKSkubWFwKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiB2YWx1ZUZ1bmN0aW9uKGkpOyB9KTtcbn1cbi8qKlxuICogQWRhcHRzIHRoZSBuYXRpdmUgSlMgRGF0ZSBmb3IgdXNlIHdpdGggY2RrLWJhc2VkIGNvbXBvbmVudHMgdGhhdCB3b3JrIHdpdGggZGF0ZXMuXG4gKi9cbnZhciBOYXRpdmVEYXRlQWRhcHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTmF0aXZlRGF0ZUFkYXB0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmF0aXZlRGF0ZUFkYXB0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0WWVhciA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXRNb250aCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF5T2ZXZWVrID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0TW9udGhOYW1lcyA9IGZ1bmN0aW9uIChzdHlsZSQkMSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR0Zl8xID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIHsgbW9udGg6IHN0eWxlJCQxIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlKDEyLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4gX3RoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKGR0Zl8xLmZvcm1hdChuZXcgRGF0ZSgyMDE3LCBpLCAxKSkpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gREVGQVVMVF9NT05USF9OQU1FU1tzdHlsZSQkMV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXREYXRlTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHRmXzIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwgeyBkYXk6ICdudW1lcmljJyB9KTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZSgzMSwgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIF90aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkdGZfMi5mb3JtYXQobmV3IERhdGUoMjAxNywgMCwgaSArIDEpKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBERUZBVUxUX0RBVEVfTkFNRVM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF5T2ZXZWVrTmFtZXMgPSBmdW5jdGlvbiAoc3R5bGUkJDEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKFNVUFBPUlRTX0lOVExfQVBJKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdGZfMyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7IHdlZWtkYXk6IHN0eWxlJCQxIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlKDcsIGZ1bmN0aW9uIChpKSB7IHJldHVybiBfdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoZHRmXzMuZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDAsIGkgKyAxKSkpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gREVGQVVMVF9EQVlfT0ZfV0VFS19OQU1FU1tzdHlsZSQkMV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXRZZWFyTmFtZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIHsgeWVhcjogJ251bWVyaWMnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKGR0Zi5mb3JtYXQoZGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5nZXRZZWFyKGRhdGUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldEZpcnN0RGF5T2ZXZWVrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBjYW4ndCB0ZWxsIHVzaW5nIG5hdGl2ZSBKUyBEYXRlIHdoYXQgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBpcywgd2UgZGVmYXVsdCB0byBTdW5kYXkuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0TnVtRGF5c0luTW9udGggPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRlKHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3codGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpICsgMSwgMCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEYXRlKHRoaXMuZ2V0WWVhcihkYXRlKSwgdGhpcy5nZXRNb250aChkYXRlKSwgdGhpcy5nZXREYXRlKGRhdGUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30geWVhclxuICAgICAqIEBwYXJhbSB7P30gbW9udGhcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVEYXRlID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkYXRlKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIG1vbnRoIGFuZCBkYXRlIChleGNlcHQgdXBwZXIgYm91bmQgb24gZGF0ZSB3aGljaCB3ZSBoYXZlIHRvIGNoZWNrIGFmdGVyXG4gICAgICAgIC8vIGNyZWF0aW5nIHRoZSBEYXRlKS5cbiAgICAgICAgaWYgKG1vbnRoIDwgMCB8fCBtb250aCA+IDExIHx8IGRhdGUgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93KHllYXIsIG1vbnRoLCBkYXRlKTtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgZGF0ZSB3YXNuJ3QgYWJvdmUgdGhlIHVwcGVyIGJvdW5kIGZvciB0aGUgbW9udGgsIGNhdXNpbmcgdGhlIG1vbnRoIHRvXG4gICAgICAgIC8vIG92ZXJmbG93LlxuICAgICAgICBpZiAocmVzdWx0LmdldE1vbnRoKCkgIT0gbW9udGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBwYXJzZUZvcm1hdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHZhbHVlLCBwYXJzZUZvcm1hdCkge1xuICAgICAgICAvLyBXZSBoYXZlIG5vIHdheSB1c2luZyB0aGUgbmF0aXZlIEpTIERhdGUgdG8gc2V0IHRoZSBwYXJzZSBmb3JtYXQgb3IgbG9jYWxlLCBzbyB3ZSBpZ25vcmUgdGhlc2VcbiAgICAgICAgLy8gcGFyYW1ldGVycy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZXN0YW1wID0gdHlwZW9mIHZhbHVlID09ICdudW1iZXInID8gdmFsdWUgOiBEYXRlLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKHRpbWVzdGFtcCkgPyBudWxsIDogbmV3IERhdGUodGltZXN0YW1wKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEBwYXJhbSB7P30gZGlzcGxheUZvcm1hdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBkaXNwbGF5Rm9ybWF0KSB7XG4gICAgICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIGRpc3BsYXlGb3JtYXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKGR0Zi5mb3JtYXQoZGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkYXRlLnRvRGF0ZVN0cmluZygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEBwYXJhbSB7P30geWVhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5hZGRDYWxlbmRhclllYXJzID0gZnVuY3Rpb24gKGRhdGUsIHllYXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZENhbGVuZGFyTW9udGhzKGRhdGUsIHllYXJzICogMTIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHBhcmFtIHs/fSBtb250aHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5hZGRDYWxlbmRhck1vbnRocyA9IGZ1bmN0aW9uIChkYXRlLCBtb250aHMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3RGF0ZSA9IHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3codGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpICsgbW9udGhzLCB0aGlzLmdldERhdGUoZGF0ZSkpO1xuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRvIHdpbmQgdXAgaW4gdGhlIHdyb25nIG1vbnRoIGlmIHRoZSBvcmlnaW5hbCBtb250aCBoYXMgbW9yZSBkYXlzIHRoYW4gdGhlIG5ld1xuICAgICAgICAvLyBtb250aC4gSW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gZ28gdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSBkZXNpcmVkIG1vbnRoLlxuICAgICAgICAvLyBOb3RlOiB0aGUgYWRkaXRpb25hbCArIDEyICUgMTIgZW5zdXJlcyB3ZSBlbmQgdXAgd2l0aCBhIHBvc2l0aXZlIG51bWJlciwgc2luY2UgSlMgJSBkb2Vzbid0XG4gICAgICAgIC8vIGd1YXJhbnRlZSB0aGlzLlxuICAgICAgICBpZiAodGhpcy5nZXRNb250aChuZXdEYXRlKSAhPSAoKHRoaXMuZ2V0TW9udGgoZGF0ZSkgKyBtb250aHMpICUgMTIgKyAxMikgJSAxMikge1xuICAgICAgICAgICAgbmV3RGF0ZSA9IHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3codGhpcy5nZXRZZWFyKG5ld0RhdGUpLCB0aGlzLmdldE1vbnRoKG5ld0RhdGUpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEBwYXJhbSB7P30gZGF5c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmFkZENhbGVuZGFyRGF5cyA9IGZ1bmN0aW9uIChkYXRlLCBkYXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93KHRoaXMuZ2V0WWVhcihkYXRlKSwgdGhpcy5nZXRNb250aChkYXRlKSwgdGhpcy5nZXREYXRlKGRhdGUpICsgZGF5cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXRJU09EYXRlU3RyaW5nID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgIHRoaXMuXzJkaWdpdChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgICAgICAgIHRoaXMuXzJkaWdpdChkYXRlLmdldFVUQ0RhdGUoKSlcbiAgICAgICAgXS5qb2luKCctJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGF0ZSBidXQgYWxsb3dzIHRoZSBtb250aCBhbmQgZGF0ZSB0byBvdmVyZmxvdy5cbiAgICAgKiBAcGFyYW0gez99IHllYXJcbiAgICAgKiBAcGFyYW0gez99IG1vbnRoXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3cgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgsIGRhdGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRhdGUpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGNvcnJlY3QgZm9yIHRoZSBmYWN0IHRoYXQgSlMgbmF0aXZlIERhdGUgdHJlYXRzIHllYXJzIGluIHJhbmdlIFswLCA5OV0gYXNcbiAgICAgICAgLy8gYWJicmV2aWF0aW9ucyBmb3IgMTl4eC5cbiAgICAgICAgaWYgKHllYXIgPj0gMCAmJiB5ZWFyIDwgMTAwKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIodGhpcy5nZXRZZWFyKHJlc3VsdCkgLSAxOTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFkcyBhIG51bWJlciB0byBtYWtlIGl0IHR3byBkaWdpdHMuXG4gICAgICogQHBhcmFtIHs/fSBuIFRoZSBudW1iZXIgdG8gcGFkLlxuICAgICAqIEByZXR1cm4gez99IFRoZSBwYWRkZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5fMmRpZ2l0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuICgnMDAnICsgbikuc2xpY2UoLTIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RyaXAgb3V0IHVuaWNvZGUgTFRSIGFuZCBSVEwgY2hhcmFjdGVycy4gRWRnZSBhbmQgSUUgaW5zZXJ0IHRoZXNlIGludG8gZm9ybWF0dGVkIGRhdGVzIHdoaWxlXG4gICAgICogb3RoZXIgYnJvd3NlcnMgZG8gbm90LiBXZSByZW1vdmUgdGhlbSB0byBtYWtlIG91dHB1dCBjb25zaXN0ZW50IGFuZCBiZWNhdXNlIHRoZXkgaW50ZXJmZXJlIHdpdGhcbiAgICAgKiBkYXRlIHBhcnNpbmcuXG4gICAgICogQHBhcmFtIHs/fSBzIFRoZSBzdHJpbmcgdG8gc3RyaXAgZGlyZWN0aW9uIGNoYXJhY3RlcnMgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgc3RyaXBwZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMgPSBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bXFx1MjAwZVxcdTIwMGZdL2csICcnKTtcbiAgICB9O1xuICAgIHJldHVybiBOYXRpdmVEYXRlQWRhcHRlcjtcbn0oRGF0ZUFkYXB0ZXIpKTtcbnZhciBNRF9EQVRFX0ZPUk1BVFMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ21kLWRhdGUtZm9ybWF0cycpO1xudmFyIE1EX05BVElWRV9EQVRFX0ZPUk1BVFMgPSB7XG4gICAgcGFyc2U6IHtcbiAgICAgICAgZGF0ZUlucHV0OiBudWxsLFxuICAgIH0sXG4gICAgZGlzcGxheToge1xuICAgICAgICBkYXRlSW5wdXQ6IHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ251bWVyaWMnLCBkYXk6ICdudW1lcmljJyB9LFxuICAgICAgICBtb250aFllYXJMYWJlbDogeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnIH0sXG4gICAgICAgIGRhdGVBMTF5TGFiZWw6IHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9LFxuICAgICAgICBtb250aFllYXJBMTF5TGFiZWw6IHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnIH0sXG4gICAgfVxufTtcbnZhciBOYXRpdmVEYXRlTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmF0aXZlRGF0ZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE5hdGl2ZURhdGVNb2R1bGU7XG59KCkpO1xuTmF0aXZlRGF0ZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBEYXRlQWRhcHRlciwgdXNlQ2xhc3M6IE5hdGl2ZURhdGVBZGFwdGVyIH1dLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5OYXRpdmVEYXRlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWROYXRpdmVEYXRlTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWROYXRpdmVEYXRlTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWROYXRpdmVEYXRlTW9kdWxlO1xufSgpKTtcbk1kTmF0aXZlRGF0ZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW05hdGl2ZURhdGVNb2R1bGVdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTURfREFURV9GT1JNQVRTLCB1c2VWYWx1ZTogTURfTkFUSVZFX0RBVEVfRk9STUFUUyB9XSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWROYXRpdmVEYXRlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWRDb3JlTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDb3JlTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDb3JlTW9kdWxlO1xufSgpKTtcbk1kQ29yZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBNZExpbmVNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFJ0bE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRSaXBwbGVNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE9ic2VydmVDb250ZW50TW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBQb3J0YWxNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIEExMXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kT3B0aW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZFNlbGVjdGlvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRMaW5lTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBSdGxNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kUmlwcGxlTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBPYnNlcnZlQ29udGVudE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgUG9ydGFsTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBPdmVybGF5TW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBBMTF5TW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZE9wdGlvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRTZWxlY3Rpb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDb3JlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFByb3ZpZGVyIEV4cHJlc3Npb24gdGhhdCBhbGxvd3MgbWQtYnV0dG9uLXRvZ2dsZS1ncm91cCB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICogVGhpcyBhbGxvd3MgaXQgdG8gc3VwcG9ydCBbKG5nTW9kZWwpXS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTURfQlVUVE9OX1RPR0dMRV9HUk9VUF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZEJ1dHRvblRvZ2dsZUdyb3VwOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBfdW5pcXVlSWRDb3VudGVyJDEgPSAwO1xuLyoqXG4gKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWRCdXR0b25Ub2dnbGUuXG4gKi9cbnZhciBNZEJ1dHRvblRvZ2dsZUNoYW5nZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uVG9nZ2xlQ2hhbmdlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRCdXR0b25Ub2dnbGVDaGFuZ2U7XG59KCkpO1xuLyoqXG4gKiBFeGNsdXNpdmUgc2VsZWN0aW9uIGJ1dHRvbiB0b2dnbGUgZ3JvdXAgdGhhdCBiZWhhdmVzIGxpa2UgYSByYWRpby1idXR0b24gZ3JvdXAuXG4gKi9cbnZhciBNZEJ1dHRvblRvZ2dsZUdyb3VwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGVHcm91cCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIGJ1dHRvbiB0b2dnbGUgZ3JvdXAuIFNob3VsZCBtYXRjaCBjdXJyZW50bHkgc2VsZWN0ZWQgYnV0dG9uIHRvZ2dsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIVE1MIG5hbWUgYXR0cmlidXRlIGFwcGxpZWQgdG8gdG9nZ2xlcyBpbiB0aGlzIGdyb3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibWQtYnV0dG9uLXRvZ2dsZS1ncm91cC1cIiArIF91bmlxdWVJZENvdW50ZXIkMSsrO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgYWxsIHRvZ2dsZXMgaW4gdGhlIGdyb3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYnV0dG9uIHRvZ2dsZSBncm91cCBzaG91bGQgYmUgdmVydGljYWwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92ZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBidXR0b24gdG9nZ2xlLCBzaG91bGQgbWF0Y2ggdGhlIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYnV0dG9uIHRvZ2dsZSBncm91cCBpcyBpbml0aWFsaXplZCBvciBub3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWV0aG9kIHRvIGJlIGNhbGxlZCBpbiBvcmRlciB0byB1cGRhdGUgbmdNb2RlbC5cbiAgICAgICAgICogTm93IGBuZ01vZGVsYCBiaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbXVsdGlwbGUgc2VsZWN0aW9uIG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuID0gZnVuY3Rpb24gKHZhbHVlKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvblRvdWNoIGZ1bmN0aW9uIHJlZ2lzdGVyZWQgdmlhIHJlZ2lzdGVyT25Ub3VjaCAoQ29udHJvbFZhbHVlQWNjZXNzb3IpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGlsZCBidXR0b24gdG9nZ2xlIGJ1dHRvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9idXR0b25Ub2dnbGVzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgZ3JvdXAncyB2YWx1ZSBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBuYW1lYCBhdHRyaWJ1dGUgZm9yIHRoZSB1bmRlcmx5aW5nIGBpbnB1dGAgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQnV0dG9uVG9nZ2xlTmFtZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRvZ2dsZSBncm91cCBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcInZlcnRpY2FsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRvZ2dsZSBncm91cCBpcyB2ZXJ0aWNhbC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRpY2FsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlIG9mIHRoZSB0b2dnbGUgZ3JvdXAuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmV3VmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgIT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGVkQnV0dG9uVG9nZ2xlRnJvbVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBlbWl0IGEgY2hhbmdlIGV2ZW50IGlmIHRoZSB2aWV3IGlzIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBlbWl0IGEgY2hhbmdlIGV2ZW50IGZvciB0aGUgaW5pdGlhbCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdG9nZ2xlIGdyb3VwIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNlbGVjdGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBzZWxlY3RlZCA/IHNlbGVjdGVkLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiAhc2VsZWN0ZWQuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLl91cGRhdGVCdXR0b25Ub2dnbGVOYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2J1dHRvblRvZ2dsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1dHRvblRvZ2dsZXMuZm9yRWFjaChmdW5jdGlvbiAodG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLm5hbWUgPSBfdGhpcy5fbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLl91cGRhdGVTZWxlY3RlZEJ1dHRvblRvZ2dsZUZyb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNBbHJlYWR5U2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3RlZCAhPSBudWxsICYmIHRoaXMuX3NlbGVjdGVkLnZhbHVlID09IHRoaXMuX3ZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fYnV0dG9uVG9nZ2xlcyAhPSBudWxsICYmICFpc0FscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hpbmdCdXR0b25Ub2dnbGUgPSB0aGlzLl9idXR0b25Ub2dnbGVzLmZpbHRlcihmdW5jdGlvbiAoYnV0dG9uVG9nZ2xlKSB7IHJldHVybiBidXR0b25Ub2dnbGUudmFsdWUgPT0gX3RoaXMuX3ZhbHVlOyB9KVswXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ0J1dHRvblRvZ2dsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBtYXRjaGluZ0J1dHRvblRvZ2dsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1dHRvblRvZ2dsZXMuZm9yRWFjaChmdW5jdGlvbiAoYnV0dG9uVG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblRvZ2dsZS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGNoYW5nZSBldmVudCB3aXRoIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCBncm91cCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLl9lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV2ZW50ID0gbmV3IE1kQnV0dG9uVG9nZ2xlQ2hhbmdlKCk7XG4gICAgICAgIGV2ZW50LnNvdXJjZSA9IHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICBldmVudC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtb2RlbCB2YWx1ZS4gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlIFZhbHVlIHRvIGJlIHNldCB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGZuIE9uIGNoYW5nZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb250cm9sIGhhcyBiZWVuIHRvdWNoZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGZuIE9uIHRvdWNoIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBpc0Rpc2FibGVkIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gTWRCdXR0b25Ub2dnbGVHcm91cDtcbn0oKSk7XG5NZEJ1dHRvblRvZ2dsZUdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1idXR0b24tdG9nZ2xlLWdyb3VwOm5vdChbbXVsdGlwbGVdKSwgbWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXA6bm90KFttdWx0aXBsZV0pJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9CVVRUT05fVE9HR0xFX0dST1VQX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXBdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdyYWRpb2dyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYnV0dG9uLXRvZ2dsZS12ZXJ0aWNhbF0nOiAndmVydGljYWwnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21kQnV0dG9uVG9nZ2xlR3JvdXAnLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEJ1dHRvblRvZ2dsZUdyb3VwLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG5NZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdfYnV0dG9uVG9nZ2xlcyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW2ZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRCdXR0b25Ub2dnbGU7IH0pLF0gfSxdLFxuICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndmVydGljYWwnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzZWxlY3RlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnY2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG4vKipcbiAqIE11bHRpcGxlIHNlbGVjdGlvbiBidXR0b24tdG9nZ2xlIGdyb3VwLiBgbmdNb2RlbGAgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIG1vZGUuXG4gKi9cbnZhciBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyBhbGwgdG9nZ2xlcyBpbiB0aGUgZ3JvdXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBidXR0b24gdG9nZ2xlIGdyb3VwIHNob3VsZCBiZSB2ZXJ0aWNhbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ZlcnRpY2FsID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRvZ2dsZSBncm91cCBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSA/IHRydWUgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB0b2dnbGUgZ3JvdXAgaXMgdmVydGljYWwuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJ0aWNhbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92ZXJ0aWNhbCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGU7XG59KCkpO1xuTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1idXR0b24tdG9nZ2xlLWdyb3VwW211bHRpcGxlXSwgbWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXBbbXVsdGlwbGVdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21kQnV0dG9uVG9nZ2xlR3JvdXAnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYnV0dG9uLXRvZ2dsZS1ncm91cF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWJ1dHRvbi10b2dnbGUtdmVydGljYWxdJzogJ3ZlcnRpY2FsJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG5NZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2Rpc2FibGVkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd2ZXJ0aWNhbCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG4vKipcbiAqIFNpbmdsZSBidXR0b24gaW5zaWRlIG9mIGEgdG9nZ2xlIGdyb3VwLlxuICovXG52YXIgTWRCdXR0b25Ub2dnbGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRvZ2dsZUdyb3VwXG4gICAgICogQHBhcmFtIHs/fSB0b2dnbGVHcm91cE11bHRpcGxlXG4gICAgICogQHBhcmFtIHs/fSBfYnV0dG9uVG9nZ2xlRGlzcGF0Y2hlclxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX2ZvY3VzT3JpZ2luTW9uaXRvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uVG9nZ2xlKHRvZ2dsZUdyb3VwLCB0b2dnbGVHcm91cE11bHRpcGxlLCBfYnV0dG9uVG9nZ2xlRGlzcGF0Y2hlciwgX3JlbmRlcmVyLCBfZWxlbWVudFJlZiwgX2ZvY3VzT3JpZ2luTW9uaXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9idXR0b25Ub2dnbGVEaXNwYXRjaGVyID0gX2J1dHRvblRvZ2dsZURpc3BhdGNoZXI7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvciA9IF9mb2N1c09yaWdpbk1vbml0b3I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGJ1dHRvbiB0b2dnbGUgaXMgY2hlY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgYnV0dG9uIHRvZ2dsZSBpcyBkaXNhYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlIGFzc2lnbmVkIHRvIHRoaXMgYnV0dG9uIHRvZ2dsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBidXR0b24gdG9nZ2xlIGlzIGEgc2luZ2xlIHNlbGVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzU2luZ2xlU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBncm91cCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAgPSB0b2dnbGVHcm91cDtcbiAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVHcm91cE11bHRpcGxlID0gdG9nZ2xlR3JvdXBNdWx0aXBsZTtcbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXApIHtcbiAgICAgICAgICAgIF9idXR0b25Ub2dnbGVEaXNwYXRjaGVyLmxpc3RlbihmdW5jdGlvbiAoaWQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gX3RoaXMuaWQgJiYgbmFtZSA9PSBfdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSAncmFkaW8nO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5idXR0b25Ub2dnbGVHcm91cC5uYW1lO1xuICAgICAgICAgICAgdGhpcy5faXNTaW5nbGVTZWxlY3RvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZXJlIGlzIG5vIGdyb3VwIGF0IGFsbCwgdHJlYXQgdGhlIGJ1dHRvbiB0b2dnbGUgYXMgYSBjaGVja2JveCBzbyBpdCBjYW4gYmVcbiAgICAgICAgICAgIC8vIHRvZ2dsZWQgb24gb3Igb2ZmLlxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgICAgICB0aGlzLl9pc1NpbmdsZVNlbGVjdG9yID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuaXF1ZSBJRCBmb3IgdGhlIHVuZGVybHlpbmcgYGlucHV0YCBlbGVtZW50LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZCArIFwiLWlucHV0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBidXR0b24gaXMgY2hlY2tlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5ld0NoZWNrZWRTdGF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3Q2hlY2tlZFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaW5nbGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBidXR0b24gdG9nZ2xlcyB3aXRoIHRoZSBzYW1lIG5hbWUgKGluIHRoZSBzYW1lIGdyb3VwKSB0byB1bi1jaGVjay5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnV0dG9uVG9nZ2xlRGlzcGF0Y2hlci5ub3RpZnkodGhpcy5pZCwgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gbmV3Q2hlY2tlZFN0YXRlO1xuICAgICAgICAgICAgaWYgKG5ld0NoZWNrZWRTdGF0ZSAmJiB0aGlzLl9pc1NpbmdsZVNlbGVjdG9yICYmIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAudmFsdWUgIT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAuc2VsZWN0ZWQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1kQnV0dG9uVG9nZ2xlR3JvdXAgcmVhZHMgdGhpcyB0byBhc3NpZ24gaXRzIG93biB2YWx1ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwICE9IG51bGwgJiYgdGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBidXR0b24gaXMgZGlzYWJsZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZCB8fCAodGhpcy5idXR0b25Ub2dnbGVHcm91cCAhPSBudWxsICYmIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAuZGlzYWJsZWQpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSAhPSBudWxsICYmIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZS5kaXNhYmxlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpID8gdHJ1ZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gXCJtZC1idXR0b24tdG9nZ2xlLVwiICsgX3VuaXF1ZUlkQ291bnRlciQxKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAgJiYgdGhpcy5fdmFsdWUgPT0gdGhpcy5idXR0b25Ub2dnbGVHcm91cC52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLm1vbml0b3IodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLl9yZW5kZXJlciwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBidXR0b24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGJ1dHRvbiB0b2dnbGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUuX3RvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgYnV0dG9uIHRvZ2dsZSBkdWUgdG8gYW4gaW50ZXJhY3Rpb24gd2l0aCB0aGUgdW5kZXJseWluZyBuYXRpdmUgaW5wdXQuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLl9vbklucHV0Q2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5faXNTaW5nbGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgLy8gUHJvcGFnYXRlIHRoZSBjaGFuZ2Ugb25lLXdheSB2aWEgdGhlIGdyb3VwLCB3aGljaCB3aWxsIGluIHR1cm4gbWFyayB0aGlzXG4gICAgICAgICAgICAvLyBidXR0b24gdG9nZ2xlIGFzIGNoZWNrZWQuXG4gICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVHcm91cC5zZWxlY3RlZCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLm9uVG91Y2hlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1pdCBhIGNoYW5nZSBldmVudCB3aGVuIHRoZSBuYXRpdmUgaW5wdXQgZG9lcy5cbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUuX29uSW5wdXRDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHN0b3AgcHJvcGFnYXRpb24gZm9yIGNsaWNrIGV2ZW50cyBvbiB0aGUgdmlzdWFsIGhpZGRlbiBpbnB1dCBlbGVtZW50LlxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB3aGVuIGEgdXNlciBjbGlja3Mgb24gYSBsYWJlbCBlbGVtZW50LCBhIGdlbmVyYXRlZCBjbGljayBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGRpc3BhdGNoZWQgb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gU2luY2Ugd2UgYXJlIHVzaW5nIGEgbGFiZWwgZWxlbWVudCBhcyBvdXJcbiAgICAgICAgLy8gcm9vdCBjb250YWluZXIsIHRoZSBjbGljayBldmVudCBvbiB0aGUgYHNsaWRlLXRvZ2dsZWAgd2lsbCBiZSBleGVjdXRlZCB0d2ljZS5cbiAgICAgICAgLy8gVGhlIHJlYWwgY2xpY2sgZXZlbnQgd2lsbCBidWJibGUgdXAsIGFuZCB0aGUgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IGFsc28gdHJpZXMgdG8gYnViYmxlIHVwLlxuICAgICAgICAvLyBUaGlzIHdpbGwgbGVhZCB0byBtdWx0aXBsZSBjbGljayBldmVudHMuXG4gICAgICAgIC8vIFByZXZlbnRpbmcgYnViYmxpbmcgZm9yIHRoZSBzZWNvbmQgZXZlbnQgd2lsbCBzb2x2ZSB0aGF0IGlzc3VlLlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGNoYW5nZSBldmVudCB3aXRoIGN1cnJlbnQgdmFsdWUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSBuZXcgTWRCdXR0b25Ub2dnbGVDaGFuZ2UoKTtcbiAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcztcbiAgICAgICAgZXZlbnQudmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRCdXR0b25Ub2dnbGU7XG59KCkpO1xuTWRCdXR0b25Ub2dnbGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1idXR0b24tdG9nZ2xlLCBtYXQtYnV0dG9uLXRvZ2dsZScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGxhYmVsIFthdHRyLmZvcl09XFxcImlucHV0SWRcXFwiIGNsYXNzPVxcXCJtYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbFxcXCI+IDxpbnB1dCAjaW5wdXQgY2xhc3M9XFxcIm1hdC1idXR0b24tdG9nZ2xlLWlucHV0IGNkay12aXN1YWxseS1oaWRkZW5cXFwiIFt0eXBlXT1cXFwiX3R5cGVcXFwiIFtpZF09XFxcImlucHV0SWRcXFwiIFtjaGVja2VkXT1cXFwiY2hlY2tlZFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFtuYW1lXT1cXFwibmFtZVxcXCIgKGNoYW5nZSk9XFxcIl9vbklucHV0Q2hhbmdlKCRldmVudClcXFwiIChjbGljayk9XFxcIl9vbklucHV0Q2xpY2soJGV2ZW50KVxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1idXR0b24tdG9nZ2xlLWxhYmVsLWNvbnRlbnRcXFwiPiA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IDwvZGl2PiA8L2xhYmVsPiA8IS0tIHRoZSB0b3VjaHN0YXJ0IGhhbmRsZXIgcHJldmVudHMgdGhlIG92ZXJsYXkgZnJvbSBjYXB0dXJpbmcgdGhlIGluaXRpYWwgdGFwIG9uIHRvdWNoIGRldmljZXMgLS0+IDxkaXYgY2xhc3M9XFxcIm1hdC1idXR0b24tdG9nZ2xlLWZvY3VzLW92ZXJsYXlcXFwiICh0b3VjaHN0YXJ0KT1cXFwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcXFwiPjwvZGl2PiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtYnV0dG9uLXRvZ2dsZS1ncm91cHtib3gtc2hhZG93OjAgM3B4IDFweCAtMnB4IHJnYmEoMCwwLDAsLjIpLDAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCA1cHggMCByZ2JhKDAsMCwwLC4xMik7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7Ym9yZGVyLXJhZGl1czoycHg7Y3Vyc29yOnBvaW50ZXI7d2hpdGUtc3BhY2U6bm93cmFwfS5tYXQtYnV0dG9uLXRvZ2dsZS12ZXJ0aWNhbHtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Lm1hdC1idXR0b24tdG9nZ2xlLXZlcnRpY2FsIC5tYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50e2Rpc3BsYXk6YmxvY2t9Lm1hdC1idXR0b24tdG9nZ2xlLWRpc2FibGVkIC5tYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50e2N1cnNvcjpkZWZhdWx0fS5tYXQtYnV0dG9uLXRvZ2dsZXt3aGl0ZS1zcGFjZTpub3dyYXA7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LWJ1dHRvbi10b2dnbGUuY2RrLWtleWJvYXJkLWZvY3VzZWQgLm1hdC1idXR0b24tdG9nZ2xlLWZvY3VzLW92ZXJsYXl7b3BhY2l0eToxfS5tYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50ey13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jaztsaW5lLWhlaWdodDozNnB4O3BhZGRpbmc6MCAxNnB4O2N1cnNvcjpwb2ludGVyfS5tYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50Pip7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tYXQtYnV0dG9uLXRvZ2dsZS1mb2N1cy1vdmVybGF5e2JvcmRlci1yYWRpdXM6aW5oZXJpdDtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLXRvZ2dsZS5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYnV0dG9uLXRvZ2dsZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQnV0dG9uVG9nZ2xlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTWRCdXR0b25Ub2dnbGVHcm91cCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlciwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c09yaWdpbk1vbml0b3IsIH0sXG5dOyB9O1xuTWRCdXR0b25Ub2dnbGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ19pbnB1dEVsZW1lbnQnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnaW5wdXQnLF0gfSxdLFxuICAgICdpZCc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nIH0sIHsgdHlwZTogSW5wdXQgfSxdLFxuICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdjaGVja2VkJzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubWF0LWJ1dHRvbi10b2dnbGUtY2hlY2tlZCcsXSB9LCB7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2Rpc2FibGVkJzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubWF0LWJ1dHRvbi10b2dnbGUtZGlzYWJsZWQnLF0gfSwgeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xudmFyIE1kQnV0dG9uVG9nZ2xlTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEJ1dHRvblRvZ2dsZU1vZHVsZTtcbn0oKSk7XG5NZEJ1dHRvblRvZ2dsZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0Zvcm1zTW9kdWxlLCBNZENvbW1vbk1vZHVsZSwgU3R5bGVNb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRCdXR0b25Ub2dnbGVHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICBNZEJ1dHRvblRvZ2dsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZEJ1dHRvblRvZ2dsZUdyb3VwLCBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUsIE1kQnV0dG9uVG9nZ2xlXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVJdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQnV0dG9uVG9nZ2xlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIE1peGluIHRvIGF1Z21lbnQgYSBkaXJlY3RpdmUgd2l0aCBhIGBkaXNhYmxlZGAgcHJvcGVydHkuXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBiYXNlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtaXhpbkRpc2FibGVkKGJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgfShiYXNlKSk7XG59XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEJ1dHRvbkNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRCdXR0b25Dc3NNYXRTdHlsZXI7XG59KCkpO1xuTWRCdXR0b25Dc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvblttZC1idXR0b25dLCBidXR0b25bbWF0LWJ1dHRvbl0sIGFbbWQtYnV0dG9uXSwgYVttYXQtYnV0dG9uXScsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWJ1dHRvbicgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEJ1dHRvbkNzc01hdFN0eWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFJhaXNlZEJ1dHRvbkNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyO1xufSgpKTtcbk1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbWQtcmFpc2VkLWJ1dHRvbl0sIGJ1dHRvblttYXQtcmFpc2VkLWJ1dHRvbl0sICcgK1xuICAgICAgICAgICAgICAgICAgICAnYVttZC1yYWlzZWQtYnV0dG9uXSwgYVttYXQtcmFpc2VkLWJ1dHRvbl0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21hdC1yYWlzZWQtYnV0dG9uJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXI7XG59KCkpO1xuTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbWQtaWNvbi1idXR0b25dLCBidXR0b25bbWF0LWljb24tYnV0dG9uXSwgYVttZC1pY29uLWJ1dHRvbl0sIGFbbWF0LWljb24tYnV0dG9uXScsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWljb24tYnV0dG9uJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRGYWJDc3NNYXRTdHlsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEZhYkNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kRmFiQ3NzTWF0U3R5bGVyO1xufSgpKTtcbk1kRmFiQ3NzTWF0U3R5bGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbWQtZmFiXSwgYnV0dG9uW21hdC1mYWJdLCBhW21kLWZhYl0sIGFbbWF0LWZhYl0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21hdC1mYWInIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRGYWJDc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTWluaUZhYkNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTWluaUZhYkNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTWluaUZhYkNzc01hdFN0eWxlcjtcbn0oKSk7XG5NZE1pbmlGYWJDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvblttZC1taW5pLWZhYl0sIGJ1dHRvblttYXQtbWluaS1mYWJdLCBhW21kLW1pbmktZmFiXSwgYVttYXQtbWluaS1mYWJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtbWluaS1mYWInIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRNaW5pRmFiQ3NzTWF0U3R5bGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWRCdXR0b25CYXNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25CYXNlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRCdXR0b25CYXNlO1xufSgpKTtcbnZhciBfTWRCdXR0b25NaXhpbkJhc2UgPSBtaXhpbkRpc2FibGVkKE1kQnV0dG9uQmFzZSk7XG4vKipcbiAqIE1hdGVyaWFsIGRlc2lnbiBidXR0b24uXG4gKi9cbnZhciBNZEJ1dHRvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRCdXR0b24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfcGxhdGZvcm1cbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c09yaWdpbk1vbml0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZEJ1dHRvbihfZWxlbWVudFJlZiwgX3JlbmRlcmVyLCBfcGxhdGZvcm0sIF9mb2N1c09yaWdpbk1vbml0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgX3RoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICBfdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIF90aGlzLl9mb2N1c09yaWdpbk1vbml0b3IgPSBfZm9jdXNPcmlnaW5Nb25pdG9yO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYnV0dG9uIGlzIHJvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2lzUm91bmRCdXR0b24gPSBfdGhpcy5faGFzQXR0cmlidXRlV2l0aFByZWZpeCgnZmFiJywgJ21pbmktZmFiJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBidXR0b24gaXMgaWNvbiBidXR0b24uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5faXNJY29uQnV0dG9uID0gX3RoaXMuX2hhc0F0dHJpYnV0ZVdpdGhQcmVmaXgoJ2ljb24tYnV0dG9uJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IG9uIGNsaWNrIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9kaXNhYmxlUmlwcGxlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9mb2N1c09yaWdpbk1vbml0b3IubW9uaXRvcihfdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBfdGhpcy5fcmVuZGVyZXIsIHRydWUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvbi5wcm90b3R5cGUsIFwiZGlzYWJsZVJpcHBsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IGZvciB0aGlzIGJ1dHRvbiBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLl9kaXNhYmxlUmlwcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHYpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLnN0b3BNb25pdG9yaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b24ucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xvciBvZiB0aGUgYnV0dG9uLiBDYW4gYmUgYHByaW1hcnlgLCBgYWNjZW50YCwgb3IgYHdhcm5gLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2xvcjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuZXdDb2xvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl91cGRhdGVDb2xvciA9IGZ1bmN0aW9uIChuZXdDb2xvcikge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IodGhpcy5fY29sb3IsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKG5ld0NvbG9yLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29sb3JcbiAgICAgKiBAcGFyYW0gez99IGlzQWRkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuX3NldEVsZW1lbnRDb2xvciA9IGZ1bmN0aW9uIChjb2xvciwgaXNBZGQpIHtcbiAgICAgICAgaWYgKGNvbG9yICE9IG51bGwgJiYgY29sb3IgIT0gJycpIHtcbiAgICAgICAgICAgIGlmIChpc0FkZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2dldEhvc3RFbGVtZW50KCksIFwibWF0LVwiICsgY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZ2V0SG9zdEVsZW1lbnQoKSwgXCJtYXQtXCIgKyBjb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGJ1dHRvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ2V0SG9zdEVsZW1lbnQoKS5mb2N1cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuX2dldEhvc3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuX2lzUmlwcGxlRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVSaXBwbGUgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgYnV0dG9uIGhhcyBvbmUgb2YgdGhlIGdpdmVuIGF0dHJpYnV0ZXNcbiAgICAgKiB3aXRoIGVpdGhlciBhbiAnbWQtJyBvciAnbWF0LScgcHJlZml4LlxuICAgICAqIEBwYXJhbSB7Li4uP30gdW5wcmVmaXhlZEF0dHJpYnV0ZU5hbWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuX2hhc0F0dHJpYnV0ZVdpdGhQcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1bnByZWZpeGVkQXR0cmlidXRlTmFtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHVucHJlZml4ZWRBdHRyaWJ1dGVOYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vdCBvbiB0aGUgYnJvd3Nlciwgc2F5IHRoYXQgdGhlcmUgYXJlIG5vbmUgb2YgdGhlIGF0dHJpYnV0ZXMgcHJlc2VudC5cbiAgICAgICAgLy8gU2luY2UgdGhlc2Ugb25seSBhZmZlY3QgaG93IHRoZSByaXBwbGUgZGlzcGxheXMgKGFuZCByaXBwbGVzIG9ubHkgaGFwcGVuIG9uIHRoZSBjbGllbnQpLFxuICAgICAgICAvLyBkZXRlY3RpbmcgdGhlc2UgYXR0cmlidXRlcyBpc24ndCBuZWNlc3Nhcnkgd2hlbiBub3Qgb24gdGhlIGJyb3dzZXIuXG4gICAgICAgIGlmICghdGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVucHJlZml4ZWRBdHRyaWJ1dGVOYW1lcy5zb21lKGZ1bmN0aW9uIChzdWZmaXgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsID0gX3RoaXMuX2dldEhvc3RFbGVtZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKCdtZC0nICsgc3VmZml4KSB8fCBlbC5oYXNBdHRyaWJ1dGUoJ21hdC0nICsgc3VmZml4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRCdXR0b247XG59KF9NZEJ1dHRvbk1peGluQmFzZSkpO1xuTWRCdXR0b24uZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdidXR0b25bbWQtYnV0dG9uXSwgYnV0dG9uW21kLXJhaXNlZC1idXR0b25dLCBidXR0b25bbWQtaWNvbi1idXR0b25dLCcgK1xuICAgICAgICAgICAgICAgICAgICAnYnV0dG9uW21kLWZhYl0sIGJ1dHRvblttZC1taW5pLWZhYl0sJyArXG4gICAgICAgICAgICAgICAgICAgICdidXR0b25bbWF0LWJ1dHRvbl0sIGJ1dHRvblttYXQtcmFpc2VkLWJ1dHRvbl0sIGJ1dHRvblttYXQtaWNvbi1idXR0b25dLCcgK1xuICAgICAgICAgICAgICAgICAgICAnYnV0dG9uW21hdC1mYWJdLCBidXR0b25bbWF0LW1pbmktZmFiXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2Rpc2FibGVkXSc6ICdkaXNhYmxlZCB8fCBudWxsJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxzcGFuIGNsYXNzPVxcXCJtYXQtYnV0dG9uLXdyYXBwZXJcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L3NwYW4+IDxkaXYgbWQtcmlwcGxlIGNsYXNzPVxcXCJtYXQtYnV0dG9uLXJpcHBsZVxcXCIgW2NsYXNzLm1hdC1idXR0b24tcmlwcGxlLXJvdW5kXT1cXFwiX2lzUm91bmRCdXR0b24gfHwgX2lzSWNvbkJ1dHRvblxcXCIgW21kUmlwcGxlRGlzYWJsZWRdPVxcXCJfaXNSaXBwbGVEaXNhYmxlZCgpXFxcIiBbbWRSaXBwbGVDZW50ZXJlZF09XFxcIl9pc0ljb25CdXR0b25cXFwiIFttZFJpcHBsZVRyaWdnZXJdPVxcXCJfZ2V0SG9zdEVsZW1lbnQoKVxcXCI+PC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheVxcXCI+PC9kaXY+IFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1idXR0b24sLm1hdC1mYWIsLm1hdC1pY29uLWJ1dHRvbiwubWF0LW1pbmktZmFiLC5tYXQtcmFpc2VkLWJ1dHRvbntib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246cmVsYXRpdmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2N1cnNvcjpwb2ludGVyO291dGxpbmU6MDtib3JkZXI6bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jazt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1kZWNvcmF0aW9uOm5vbmU7dmVydGljYWwtYWxpZ246YmFzZWxpbmU7Zm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXdlaWdodDo1MDA7dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luOjA7bWluLXdpZHRoOjg4cHg7bGluZS1oZWlnaHQ6MzZweDtwYWRkaW5nOjAgMTZweDtib3JkZXItcmFkaXVzOjJweH1bZGlzYWJsZWRdLm1hdC1idXR0b24sW2Rpc2FibGVkXS5tYXQtZmFiLFtkaXNhYmxlZF0ubWF0LWljb24tYnV0dG9uLFtkaXNhYmxlZF0ubWF0LW1pbmktZmFiLFtkaXNhYmxlZF0ubWF0LXJhaXNlZC1idXR0b257Y3Vyc29yOmRlZmF1bHR9LmNkay1rZXlib2FyZC1mb2N1c2VkLm1hdC1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwuY2RrLWtleWJvYXJkLWZvY3VzZWQubWF0LWZhYiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5jZGsta2V5Ym9hcmQtZm9jdXNlZC5tYXQtaWNvbi1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwuY2RrLWtleWJvYXJkLWZvY3VzZWQubWF0LW1pbmktZmFiIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLmNkay1rZXlib2FyZC1mb2N1c2VkLm1hdC1yYWlzZWQtYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7b3BhY2l0eToxfS5tYXQtYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLC5tYXQtZmFiOjotbW96LWZvY3VzLWlubmVyLC5tYXQtaWNvbi1idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsLm1hdC1taW5pLWZhYjo6LW1vei1mb2N1cy1pbm5lciwubWF0LXJhaXNlZC1idXR0b246Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyOjB9Lm1hdC1mYWIsLm1hdC1taW5pLWZhYiwubWF0LXJhaXNlZC1idXR0b257Ym94LXNoYWRvdzowIDNweCAxcHggLTJweCByZ2JhKDAsMCwwLC4yKSwwIDJweCAycHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMTIpO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKSxib3gtc2hhZG93IDI4MG1zIGN1YmljLWJlemllciguNCwwLC4yLDEpfS5tYXQtZmFiOm5vdChbZGlzYWJsZWRdKTphY3RpdmUsLm1hdC1taW5pLWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZlLC5tYXQtcmFpc2VkLWJ1dHRvbjpub3QoW2Rpc2FibGVkXSk6YWN0aXZle2JveC1zaGFkb3c6MCA1cHggNXB4IC0zcHggcmdiYSgwLDAsMCwuMiksMCA4cHggMTBweCAxcHggcmdiYSgwLDAsMCwuMTQpLDAgM3B4IDE0cHggMnB4IHJnYmEoMCwwLDAsLjEyKX1bZGlzYWJsZWRdLm1hdC1mYWIsW2Rpc2FibGVkXS5tYXQtbWluaS1mYWIsW2Rpc2FibGVkXS5tYXQtcmFpc2VkLWJ1dHRvbntib3gtc2hhZG93Om5vbmV9Lm1hdC1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWljb24tYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7dHJhbnNpdGlvbjpub25lO29wYWNpdHk6MH0ubWF0LWJ1dHRvbjpob3ZlciAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5e29wYWNpdHk6MX0ubWF0LWZhYntib3gtc2hhZG93OjAgM3B4IDVweCAtMXB4IHJnYmEoMCwwLDAsLjIpLDAgNnB4IDEwcHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggMThweCAwIHJnYmEoMCwwLDAsLjEyKTttaW4td2lkdGg6MDtib3JkZXItcmFkaXVzOjUwJTt3aWR0aDo1NnB4O2hlaWdodDo1NnB4O3BhZGRpbmc6MDtmbGV4LXNocmluazowfS5tYXQtZmFiOm5vdChbZGlzYWJsZWRdKTphY3RpdmV7Ym94LXNoYWRvdzowIDdweCA4cHggLTRweCByZ2JhKDAsMCwwLC4yKSwwIDEycHggMTdweCAycHggcmdiYSgwLDAsMCwuMTQpLDAgNXB4IDIycHggNHB4IHJnYmEoMCwwLDAsLjEyKX0ubWF0LWZhYiAubWF0LWljb24sLm1hdC1mYWIgaXtwYWRkaW5nOjE2cHggMDtsaW5lLWhlaWdodDoyNHB4fS5tYXQtbWluaS1mYWJ7Ym94LXNoYWRvdzowIDNweCA1cHggLTFweCByZ2JhKDAsMCwwLC4yKSwwIDZweCAxMHB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDE4cHggMCByZ2JhKDAsMCwwLC4xMik7bWluLXdpZHRoOjA7Ym9yZGVyLXJhZGl1czo1MCU7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDtwYWRkaW5nOjA7ZmxleC1zaHJpbms6MH0ubWF0LW1pbmktZmFiOm5vdChbZGlzYWJsZWRdKTphY3RpdmV7Ym94LXNoYWRvdzowIDdweCA4cHggLTRweCByZ2JhKDAsMCwwLC4yKSwwIDEycHggMTdweCAycHggcmdiYSgwLDAsMCwuMTQpLDAgNXB4IDIycHggNHB4IHJnYmEoMCwwLDAsLjEyKX0ubWF0LW1pbmktZmFiIC5tYXQtaWNvbiwubWF0LW1pbmktZmFiIGl7cGFkZGluZzo4cHggMDtsaW5lLWhlaWdodDoyNHB4fS5tYXQtaWNvbi1idXR0b257cGFkZGluZzowO21pbi13aWR0aDowO3dpZHRoOjQwcHg7aGVpZ2h0OjQwcHg7ZmxleC1zaHJpbms6MDtsaW5lLWhlaWdodDo0MHB4O2JvcmRlci1yYWRpdXM6NTAlfS5tYXQtaWNvbi1idXR0b24gLm1hdC1pY29uLC5tYXQtaWNvbi1idXR0b24gaXtsaW5lLWhlaWdodDoyNHB4fS5tYXQtYnV0dG9uLC5tYXQtaWNvbi1idXR0b24sLm1hdC1yYWlzZWQtYnV0dG9ue2NvbG9yOmN1cnJlbnRDb2xvcn0ubWF0LWJ1dHRvbiAubWF0LWJ1dHRvbi13cmFwcGVyPiosLm1hdC1pY29uLWJ1dHRvbiAubWF0LWJ1dHRvbi13cmFwcGVyPiosLm1hdC1yYWlzZWQtYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+Knt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWJ1dHRvbi1yaXBwbGV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO2JvdHRvbTowO3JpZ2h0OjA7cG9pbnRlci1ldmVudHM6bm9uZX0ubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5e2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMTIpO2JvcmRlci1yYWRpdXM6aW5oZXJpdDtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC4ycyBjdWJpYy1iZXppZXIoLjM1LDAsLjI1LDEpLGJhY2tncm91bmQtY29sb3IgLjJzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjU1LDI1NSwyNTUsLjUpfX0ubWF0LWJ1dHRvbi1yaXBwbGUtcm91bmR7Ym9yZGVyLXJhZGl1czo1MCU7ei1pbmRleDoxfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtYnV0dG9uLC5tYXQtZmFiLC5tYXQtaWNvbi1idXR0b24sLm1hdC1taW5pLWZhYiwubWF0LXJhaXNlZC1idXR0b257b3V0bGluZTpzb2xpZCAxcHh9fSAvKiMgc291cmNlTWFwcGluZ1VSTD1idXR0b24uY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2Rpc2FibGVkJ10sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRCdXR0b24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogUGxhdGZvcm0sIH0sXG4gICAgeyB0eXBlOiBGb2N1c09yaWdpbk1vbml0b3IsIH0sXG5dOyB9O1xuTWRCdXR0b24ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2Rpc2FibGVSaXBwbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NvbG9yJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbi8qKlxuICogUmFpc2VkIE1hdGVyaWFsIGRlc2lnbiBidXR0b24uXG4gKi9cbnZhciBNZEFuY2hvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRBbmNob3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1cbiAgICAgKiBAcGFyYW0gez99IGZvY3VzT3JpZ2luTW9uaXRvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kQW5jaG9yKGVsZW1lbnRSZWYsIHJlbmRlcmVyLCBwbGF0Zm9ybSwgZm9jdXNPcmlnaW5Nb25pdG9yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50UmVmLCByZW5kZXJlciwgcGxhdGZvcm0sIGZvY3VzT3JpZ2luTW9uaXRvcikgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQW5jaG9yLnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBkb2NzLXByaXZhdGVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyAtMSA6IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEFuY2hvci5wcm90b3R5cGUsIFwiX2lzQXJpYURpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBbmNob3IucHJvdG90eXBlLl9oYWx0RGlzYWJsZWRFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQSBkaXNhYmxlZCBidXR0b24gc2hvdWxkbid0IGFwcGx5IGFueSBhY3Rpb25zXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZEFuY2hvcjtcbn0oTWRCdXR0b24pKTtcbk1kQW5jaG9yLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiBcImFbbWQtYnV0dG9uXSwgYVttZC1yYWlzZWQtYnV0dG9uXSwgYVttZC1pY29uLWJ1dHRvbl0sIGFbbWQtZmFiXSwgYVttZC1taW5pLWZhYl0sXFxuICAgICAgICAgICAgIGFbbWF0LWJ1dHRvbl0sIGFbbWF0LXJhaXNlZC1idXR0b25dLCBhW21hdC1pY29uLWJ1dHRvbl0sIGFbbWF0LWZhYl0sIGFbbWF0LW1pbmktZmFiXVwiLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmRpc2FibGVkXSc6ICdkaXNhYmxlZCB8fCBudWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ19pc0FyaWFEaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19oYWx0RGlzYWJsZWRFdmVudHMoJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8c3BhbiBjbGFzcz1cXFwibWF0LWJ1dHRvbi13cmFwcGVyXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPiA8ZGl2IG1kLXJpcHBsZSBjbGFzcz1cXFwibWF0LWJ1dHRvbi1yaXBwbGVcXFwiIFtjbGFzcy5tYXQtYnV0dG9uLXJpcHBsZS1yb3VuZF09XFxcIl9pc1JvdW5kQnV0dG9uIHx8IF9pc0ljb25CdXR0b25cXFwiIFttZFJpcHBsZURpc2FibGVkXT1cXFwiX2lzUmlwcGxlRGlzYWJsZWQoKVxcXCIgW21kUmlwcGxlQ2VudGVyZWRdPVxcXCJfaXNJY29uQnV0dG9uXFxcIiBbbWRSaXBwbGVUcmlnZ2VyXT1cXFwiX2dldEhvc3RFbGVtZW50KClcXFwiPjwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJtYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXlcXFwiPjwvZGl2PiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtYnV0dG9uLC5tYXQtZmFiLC5tYXQtaWNvbi1idXR0b24sLm1hdC1taW5pLWZhYiwubWF0LXJhaXNlZC1idXR0b257Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtjdXJzb3I6cG9pbnRlcjtvdXRsaW5lOjA7Ym9yZGVyOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwO3RleHQtZGVjb3JhdGlvbjpub25lO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NTAwO3RleHQtYWxpZ246Y2VudGVyO21hcmdpbjowO21pbi13aWR0aDo4OHB4O2xpbmUtaGVpZ2h0OjM2cHg7cGFkZGluZzowIDE2cHg7Ym9yZGVyLXJhZGl1czoycHh9W2Rpc2FibGVkXS5tYXQtYnV0dG9uLFtkaXNhYmxlZF0ubWF0LWZhYixbZGlzYWJsZWRdLm1hdC1pY29uLWJ1dHRvbixbZGlzYWJsZWRdLm1hdC1taW5pLWZhYixbZGlzYWJsZWRdLm1hdC1yYWlzZWQtYnV0dG9ue2N1cnNvcjpkZWZhdWx0fS5jZGsta2V5Ym9hcmQtZm9jdXNlZC5tYXQtYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLmNkay1rZXlib2FyZC1mb2N1c2VkLm1hdC1mYWIgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwuY2RrLWtleWJvYXJkLWZvY3VzZWQubWF0LWljb24tYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLmNkay1rZXlib2FyZC1mb2N1c2VkLm1hdC1taW5pLWZhYiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5jZGsta2V5Ym9hcmQtZm9jdXNlZC5tYXQtcmFpc2VkLWJ1dHRvbiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5e29wYWNpdHk6MX0ubWF0LWJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lciwubWF0LWZhYjo6LW1vei1mb2N1cy1pbm5lciwubWF0LWljb24tYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLC5tYXQtbWluaS1mYWI6Oi1tb3otZm9jdXMtaW5uZXIsLm1hdC1yYWlzZWQtYnV0dG9uOjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowfS5tYXQtZmFiLC5tYXQtbWluaS1mYWIsLm1hdC1yYWlzZWQtYnV0dG9ue2JveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLDAsMCwuMiksMCAycHggMnB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDVweCAwIHJnYmEoMCwwLDAsLjEyKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zaXRpb246YmFja2dyb3VuZCAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYm94LXNoYWRvdyAyODBtcyBjdWJpYy1iZXppZXIoLjQsMCwuMiwxKX0ubWF0LWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZlLC5tYXQtbWluaS1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZSwubWF0LXJhaXNlZC1idXR0b246bm90KFtkaXNhYmxlZF0pOmFjdGl2ZXtib3gtc2hhZG93OjAgNXB4IDVweCAtM3B4IHJnYmEoMCwwLDAsLjIpLDAgOHB4IDEwcHggMXB4IHJnYmEoMCwwLDAsLjE0KSwwIDNweCAxNHB4IDJweCByZ2JhKDAsMCwwLC4xMil9W2Rpc2FibGVkXS5tYXQtZmFiLFtkaXNhYmxlZF0ubWF0LW1pbmktZmFiLFtkaXNhYmxlZF0ubWF0LXJhaXNlZC1idXR0b257Ym94LXNoYWRvdzpub25lfS5tYXQtYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1pY29uLWJ1dHRvbiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5e3RyYW5zaXRpb246bm9uZTtvcGFjaXR5OjB9Lm1hdC1idXR0b246aG92ZXIgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXtvcGFjaXR5OjF9Lm1hdC1mYWJ7Ym94LXNoYWRvdzowIDNweCA1cHggLTFweCByZ2JhKDAsMCwwLC4yKSwwIDZweCAxMHB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDE4cHggMCByZ2JhKDAsMCwwLC4xMik7bWluLXdpZHRoOjA7Ym9yZGVyLXJhZGl1czo1MCU7d2lkdGg6NTZweDtoZWlnaHQ6NTZweDtwYWRkaW5nOjA7ZmxleC1zaHJpbms6MH0ubWF0LWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZle2JveC1zaGFkb3c6MCA3cHggOHB4IC00cHggcmdiYSgwLDAsMCwuMiksMCAxMnB4IDE3cHggMnB4IHJnYmEoMCwwLDAsLjE0KSwwIDVweCAyMnB4IDRweCByZ2JhKDAsMCwwLC4xMil9Lm1hdC1mYWIgLm1hdC1pY29uLC5tYXQtZmFiIGl7cGFkZGluZzoxNnB4IDA7bGluZS1oZWlnaHQ6MjRweH0ubWF0LW1pbmktZmFie2JveC1zaGFkb3c6MCAzcHggNXB4IC0xcHggcmdiYSgwLDAsMCwuMiksMCA2cHggMTBweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCAxOHB4IDAgcmdiYSgwLDAsMCwuMTIpO21pbi13aWR0aDowO2JvcmRlci1yYWRpdXM6NTAlO3dpZHRoOjQwcHg7aGVpZ2h0OjQwcHg7cGFkZGluZzowO2ZsZXgtc2hyaW5rOjB9Lm1hdC1taW5pLWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZle2JveC1zaGFkb3c6MCA3cHggOHB4IC00cHggcmdiYSgwLDAsMCwuMiksMCAxMnB4IDE3cHggMnB4IHJnYmEoMCwwLDAsLjE0KSwwIDVweCAyMnB4IDRweCByZ2JhKDAsMCwwLC4xMil9Lm1hdC1taW5pLWZhYiAubWF0LWljb24sLm1hdC1taW5pLWZhYiBpe3BhZGRpbmc6OHB4IDA7bGluZS1oZWlnaHQ6MjRweH0ubWF0LWljb24tYnV0dG9ue3BhZGRpbmc6MDttaW4td2lkdGg6MDt3aWR0aDo0MHB4O2hlaWdodDo0MHB4O2ZsZXgtc2hyaW5rOjA7bGluZS1oZWlnaHQ6NDBweDtib3JkZXItcmFkaXVzOjUwJX0ubWF0LWljb24tYnV0dG9uIC5tYXQtaWNvbiwubWF0LWljb24tYnV0dG9uIGl7bGluZS1oZWlnaHQ6MjRweH0ubWF0LWJ1dHRvbiwubWF0LWljb24tYnV0dG9uLC5tYXQtcmFpc2VkLWJ1dHRvbntjb2xvcjpjdXJyZW50Q29sb3J9Lm1hdC1idXR0b24gLm1hdC1idXR0b24td3JhcHBlcj4qLC5tYXQtaWNvbi1idXR0b24gLm1hdC1idXR0b24td3JhcHBlcj4qLC5tYXQtcmFpc2VkLWJ1dHRvbiAubWF0LWJ1dHRvbi13cmFwcGVyPip7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b24tcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtib3R0b206MDtyaWdodDowO3BvaW50ZXItZXZlbnRzOm5vbmV9Lm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjEyKTtib3JkZXItcmFkaXVzOmluaGVyaXQ7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuMnMgY3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKSxiYWNrZ3JvdW5kLWNvbG9yIC4ycyBjdWJpYy1iZXppZXIoLjM1LDAsLjI1LDEpfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDI1NSwyNTUsMjU1LC41KX19Lm1hdC1idXR0b24tcmlwcGxlLXJvdW5ke2JvcmRlci1yYWRpdXM6NTAlO3otaW5kZXg6MX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LWJ1dHRvbiwubWF0LWZhYiwubWF0LWljb24tYnV0dG9uLC5tYXQtbWluaS1mYWIsLm1hdC1yYWlzZWQtYnV0dG9ue291dGxpbmU6c29saWQgMXB4fX0gLyojIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRBbmNob3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogUGxhdGZvcm0sIH0sXG4gICAgeyB0eXBlOiBGb2N1c09yaWdpbk1vbml0b3IsIH0sXG5dOyB9O1xuTWRBbmNob3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3RhYkluZGV4JzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsndGFiSW5kZXgnLF0gfSxdLFxufTtcbnZhciBNZEJ1dHRvbk1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRCdXR0b25Nb2R1bGU7XG59KCkpO1xuTWRCdXR0b25Nb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZFJpcHBsZU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFN0eWxlTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBNZEJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgTWRBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgIE1kQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZEJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWRGYWJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kTWluaUZhYkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBNZEJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgTWRBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgIE1kQnV0dG9uQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZFJhaXNlZEJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZEZhYkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWRNaW5pRmFiQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQnV0dG9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIE1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBpbnRlZ2VyIHVzZWQgdG8gYXV0by1nZW5lcmF0ZSB1bmlxdWUgaWRzIGZvciBjaGVja2JveCBjb21wb25lbnRzLlxuICovXG52YXIgbmV4dElkID0gMDtcbi8qKlxuICogUHJvdmlkZXIgRXhwcmVzc2lvbiB0aGF0IGFsbG93cyBtZC1jaGVja2JveCB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICogVGhpcyBhbGxvd3MgaXQgdG8gc3VwcG9ydCBbKG5nTW9kZWwpXS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTURfQ0hFQ0tCT1hfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZENoZWNrYm94OyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBUcmFuc2l0aW9uQ2hlY2tTdGF0ZSA9IHt9O1xuVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5pdCA9IDA7XG5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkID0gMTtcblRyYW5zaXRpb25DaGVja1N0YXRlLlVuY2hlY2tlZCA9IDI7XG5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5JbmRldGVybWluYXRlID0gMztcblRyYW5zaXRpb25DaGVja1N0YXRlW1RyYW5zaXRpb25DaGVja1N0YXRlLkluaXRdID0gXCJJbml0XCI7XG5UcmFuc2l0aW9uQ2hlY2tTdGF0ZVtUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkXSA9IFwiQ2hlY2tlZFwiO1xuVHJhbnNpdGlvbkNoZWNrU3RhdGVbVHJhbnNpdGlvbkNoZWNrU3RhdGUuVW5jaGVja2VkXSA9IFwiVW5jaGVja2VkXCI7XG5UcmFuc2l0aW9uQ2hlY2tTdGF0ZVtUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5JbmRldGVybWluYXRlXSA9IFwiSW5kZXRlcm1pbmF0ZVwiO1xuLyoqXG4gKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWRDaGVja2JveC5cbiAqL1xudmFyIE1kQ2hlY2tib3hDaGFuZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENoZWNrYm94Q2hhbmdlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDaGVja2JveENoYW5nZTtcbn0oKSk7XG52YXIgTWRDaGVja2JveEJhc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENoZWNrYm94QmFzZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ2hlY2tib3hCYXNlO1xufSgpKTtcbnZhciBfTWRDaGVja2JveE1peGluQmFzZSA9IG1peGluRGlzYWJsZWQoTWRDaGVja2JveEJhc2UpO1xuLyoqXG4gKiBBIG1hdGVyaWFsIGRlc2lnbiBjaGVja2JveCBjb21wb25lbnQuIFN1cHBvcnRzIGFsbCBvZiB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBIVE1MNSBjaGVja2JveCxcbiAqIGFuZCBleHBvc2VzIGEgc2ltaWxhciBBUEkuIEEgTWRDaGVja2JveCBjYW4gYmUgZWl0aGVyIGNoZWNrZWQsIHVuY2hlY2tlZCwgaW5kZXRlcm1pbmF0ZSwgb3JcbiAqIGRpc2FibGVkLiBOb3RlIHRoYXQgYWxsIGFkZGl0aW9uYWwgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzIGFyZSB0YWtlbiBjYXJlIG9mIGJ5IHRoZSBjb21wb25lbnQsXG4gKiBzbyB0aGVyZSBpcyBubyBuZWVkIHRvIHByb3ZpZGUgdGhlbSB5b3Vyc2VsZi4gSG93ZXZlciwgaWYgeW91IHdhbnQgdG8gb21pdCBhIGxhYmVsIGFuZCBzdGlsbFxuICogaGF2ZSB0aGUgY2hlY2tib3ggYmUgYWNjZXNzaWJsZSwgeW91IG1heSBzdXBwbHkgYW4gW2FyaWEtbGFiZWxdIGlucHV0LlxuICogU2VlOiBodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL2NvbXBvbmVudHMvc2VsZWN0aW9uLWNvbnRyb2xzLmh0bWxcbiAqL1xudmFyIE1kQ2hlY2tib3ggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kQ2hlY2tib3gsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfY2hhbmdlRGV0ZWN0b3JSZWZcbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c09yaWdpbk1vbml0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZENoZWNrYm94KF9yZW5kZXJlciwgX2VsZW1lbnRSZWYsIF9jaGFuZ2VEZXRlY3RvclJlZiwgX2ZvY3VzT3JpZ2luTW9uaXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIF90aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIF90aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgX3RoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvciA9IF9mb2N1c09yaWdpbk1vbml0b3I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2hlZCB0byB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgZWxlbWVudC4gSW4gbW9zdCBjYXNlcywgYXJpYWwtbGFiZWxsZWRieSB3aWxsXG4gICAgICAgICAqIHRha2UgcHJlY2VkZW5jZSBzbyB0aGlzIG1heSBiZSBvbWl0dGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYXJpYUxhYmVsID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VycyBjYW4gc3BlY2lmeSB0aGUgYGFyaWEtbGFiZWxsZWRieWAgYXR0cmlidXRlIHdoaWNoIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRoZSBpbnB1dCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5hcmlhTGFiZWxsZWRieSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHVuaXF1ZSBpZCBmb3IgdGhlIGNoZWNrYm94LiBJZiBvbmUgaXMgbm90IHN1cHBsaWVkLCBpdCBpcyBhdXRvLWdlbmVyYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmlkID0gXCJtZC1jaGVja2JveC1cIiArICsrbmV4dElkO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbGFiZWwgc2hvdWxkIGFwcGVhciBhZnRlciBvciBiZWZvcmUgdGhlIGNoZWNrYm94LiBEZWZhdWx0cyB0byAnYWZ0ZXInXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5sYWJlbFBvc2l0aW9uID0gJ2FmdGVyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRhYmluZGV4IHZhbHVlIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIGlucHV0IGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy50YWJJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIHZhbHVlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiBwcmVzZW50XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2hlY2tib3gncyBgY2hlY2tlZGAgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2hlY2tib3gncyBgaW5kZXRlcm1pbmF0ZWAgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgYmx1cnJlZC4gTmVlZGVkIHRvIHByb3Blcmx5IGltcGxlbWVudCBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgICAgICogXFxAZG9jcy1wcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIF90aGlzLl9jdXJyZW50QW5pbWF0aW9uQ2xhc3MgPSAnJztcbiAgICAgICAgX3RoaXMuX2N1cnJlbnRDaGVja1N0YXRlID0gVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5pdDtcbiAgICAgICAgX3RoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmdW5jdGlvbiAodmFsdWUpIHsgfTtcbiAgICAgICAgX3RoaXMuY29sb3IgPSAnYWNjZW50JztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwiZGlzYWJsZVJpcHBsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IGZvciB0aGlzIGNoZWNrYm94IGlzIGRpc2FibGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlUmlwcGxlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZVJpcHBsZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoZWNrYm94LnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElEIG9mIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCBpbnNpZGUgYDxtZC1jaGVja2JveD5gXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcImlucHV0LVwiICsgdGhpcy5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcInJlcXVpcmVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIHJlcXVpcmVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXF1aXJlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3JlcXVpcmVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImFsaWduXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBjaGVja2JveCBzaG91bGQgYXBwZWFyIGJlZm9yZSBvciBhZnRlciB0aGUgbGFiZWwuXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGFsaWduIHJlZmVycyB0byB0aGUgY2hlY2tib3ggcmVsYXRpdmUgdG8gdGhlIGxhYmVsLCB3aGlsZSBsYWJlbFBvc2l0aW9uIHJlZmVycyB0byB0aGVcbiAgICAgICAgICAgIC8vIGxhYmVsIHJlbGF0aXZlIHRvIHRoZSBjaGVja2JveC4gQXMgc3VjaCwgdGhleSBhcmUgaW52ZXJ0ZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09ICdhZnRlcicgPyAnc3RhcnQnIDogJ2VuZCc7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxQb3NpdGlvbiA9ICh2ID09ICdzdGFydCcpID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjaGVja2JveCBoYXMgbGFiZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9oYXNMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFiZWxUZXh0ID0gdGhpcy5fbGFiZWxXcmFwcGVyLm5hdGl2ZUVsZW1lbnQudGV4dENvbnRlbnQgfHwgJyc7XG4gICAgICAgIHJldHVybiAhIWxhYmVsVGV4dC50cmltKCkubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvclxuICAgICAgICAgICAgLm1vbml0b3IodGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHRoaXMuX3JlbmRlcmVyLCBmYWxzZSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGZvY3VzT3JpZ2luKSB7IHJldHVybiBfdGhpcy5fb25JbnB1dEZvY3VzQ2hhbmdlKGZvY3VzT3JpZ2luKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3Iuc3RvcE1vbml0b3JpbmcodGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImNoZWNrZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2hlY2tib3ggaXMgY2hlY2tlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNoZWNrZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGNoZWNrZWQpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2VkICE9IHRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwiaW5kZXRlcm1pbmF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjaGVja2JveCBpcyBpbmRldGVybWluYXRlLiBUaGlzIGlzIGFsc28ga25vd24gYXMgXCJtaXhlZFwiIG1vZGUgYW5kIGNhbiBiZSB1c2VkIHRvXG4gICAgICAgICAqIHJlcHJlc2VudCBhIGNoZWNrYm94IHdpdGggdGhyZWUgc3RhdGVzLCBlLmcuIGEgY2hlY2tib3ggdGhhdCByZXByZXNlbnRzIGEgbmVzdGVkIGxpc3Qgb2ZcbiAgICAgICAgICogY2hlY2thYmxlIGl0ZW1zLiBOb3RlIHRoYXQgd2hlbmV2ZXIgY2hlY2tib3ggaXMgbWFudWFsbHkgY2xpY2tlZCwgaW5kZXRlcm1pbmF0ZSBpcyBpbW1lZGlhdGVseVxuICAgICAgICAgKiBzZXQgdG8gZmFsc2UuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRldGVybWluYXRlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRldGVybWluYXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpbmRldGVybWluYXRlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFuZ2VkID0gaW5kZXRlcm1pbmF0ZSAhPSB0aGlzLl9pbmRldGVybWluYXRlO1xuICAgICAgICAgICAgdGhpcy5faW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRldGVybWluYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25DaGVja1N0YXRlKFRyYW5zaXRpb25DaGVja1N0YXRlLkluZGV0ZXJtaW5hdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkNoZWNrU3RhdGUodGhpcy5jaGVja2VkID8gVHJhbnNpdGlvbkNoZWNrU3RhdGUuQ2hlY2tlZCA6IFRyYW5zaXRpb25DaGVja1N0YXRlLlVuY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXRlcm1pbmF0ZUNoYW5nZS5lbWl0KHRoaXMuX2luZGV0ZXJtaW5hdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIG9mIHRoZSBidXR0b24uIENhbiBiZSBgcHJpbWFyeWAsIGBhY2NlbnRgLCBvciBgd2FybmAuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fdXBkYXRlQ29sb3IodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5ld0NvbG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fdXBkYXRlQ29sb3IgPSBmdW5jdGlvbiAobmV3Q29sb3IpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKHRoaXMuX2NvbG9yLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcihuZXdDb2xvciwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gbmV3Q29sb3I7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbG9yXG4gICAgICogQHBhcmFtIHs/fSBpc0FkZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX3NldEVsZW1lbnRDb2xvciA9IGZ1bmN0aW9uIChjb2xvciwgaXNBZGQpIHtcbiAgICAgICAgaWYgKGNvbG9yICE9IG51bGwgJiYgY29sb3IgIT0gJycpIHtcbiAgICAgICAgICAgIGlmIChpc0FkZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJtYXQtXCIgKyBjb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwibWF0LVwiICsgY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9pc1JpcHBsZURpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlUmlwcGxlIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtb2RlbCB2YWx1ZS4gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlIFZhbHVlIHRvIGJlIHNldCB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBjaGFuZ2UuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb250cm9sIGhhcyBiZWVuIHRvdWNoZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjaGVja2JveCBpcyB0b3VjaGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNoZWNrYm94J3MgZGlzYWJsZWQgc3RhdGUuIEltcGxlbWVudGVkIGFzIGEgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWQgV2hldGhlciB0aGUgY2hlY2tib3ggc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmV3U3RhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl90cmFuc2l0aW9uQ2hlY2tTdGF0ZSA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRTdGF0ZSA9IHRoaXMuX2N1cnJlbnRDaGVja1N0YXRlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50UmVmID0gdGhpcy5fZWxlbWVudFJlZjtcbiAgICAgICAgaWYgKG9sZFN0YXRlID09PSBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50QW5pbWF0aW9uQ2xhc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLl9jdXJyZW50QW5pbWF0aW9uQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcyA9IHRoaXMuX2dldEFuaW1hdGlvbkNsYXNzRm9yQ2hlY2tTdGF0ZVRyYW5zaXRpb24ob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5fY3VycmVudENoZWNrU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSBuZXcgTWRDaGVja2JveENoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC5jaGVja2VkID0gdGhpcy5jaGVja2VkO1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuKHRoaXMuY2hlY2tlZCk7XG4gICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBmb2N1cyBjaGFuZ2VzIGZvciB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IGZvY3VzT3JpZ2luXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fb25JbnB1dEZvY3VzQ2hhbmdlID0gZnVuY3Rpb24gKGZvY3VzT3JpZ2luKSB7XG4gICAgICAgIGlmICghdGhpcy5fZm9jdXNSaXBwbGUgJiYgZm9jdXNPcmlnaW4gPT09ICdrZXlib2FyZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzUmlwcGxlID0gdGhpcy5fcmlwcGxlLmxhdW5jaCgwLCAwLCB7IHBlcnNpc3RlbnQ6IHRydWUsIGNlbnRlcmVkOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFmb2N1c09yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRm9jdXNSaXBwbGUoKTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGBjaGVja2VkYCBzdGF0ZSBvZiB0aGUgY2hlY2tib3guXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIGZvciBjaGVja2JveCBpbnB1dCBlbGVtZW50LlxuICAgICAqIFRvZ2dsZXMgY2hlY2tlZCBzdGF0ZSBpZiBlbGVtZW50IGlzIG5vdCBkaXNhYmxlZC5cbiAgICAgKiBEbyBub3QgdG9nZ2xlIG9uIChjaGFuZ2UpIGV2ZW50IHNpbmNlIElFIGRvZXNuJ3QgZmlyZSBjaGFuZ2UgZXZlbnQgd2hlblxuICAgICAqICAgaW5kZXRlcm1pbmF0ZSBjaGVja2JveCBpcyBjbGlja2VkLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9vbklucHV0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gV2UgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIGZvciBjbGljayBldmVudHMgb24gdGhlIHZpc3VhbCBoaWRkZW4gaW5wdXQgZWxlbWVudC5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgbGFiZWwgZWxlbWVudCwgYSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBkaXNwYXRjaGVkIG9uIHRoZSBhc3NvY2lhdGVkIGlucHV0IGVsZW1lbnQuIFNpbmNlIHdlIGFyZSB1c2luZyBhIGxhYmVsIGVsZW1lbnQgYXMgb3VyXG4gICAgICAgIC8vIHJvb3QgY29udGFpbmVyLCB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIGBjaGVja2JveGAgd2lsbCBiZSBleGVjdXRlZCB0d2ljZS5cbiAgICAgICAgLy8gVGhlIHJlYWwgY2xpY2sgZXZlbnQgd2lsbCBidWJibGUgdXAsIGFuZCB0aGUgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IGFsc28gdHJpZXMgdG8gYnViYmxlIHVwLlxuICAgICAgICAvLyBUaGlzIHdpbGwgbGVhZCB0byBtdWx0aXBsZSBjbGljayBldmVudHMuXG4gICAgICAgIC8vIFByZXZlbnRpbmcgYnViYmxpbmcgZm9yIHRoZSBzZWNvbmQgZXZlbnQgd2lsbCBzb2x2ZSB0aGF0IGlzc3VlLlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRm9jdXNSaXBwbGUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHVzZXIgbWFudWFsbHkgY2xpY2sgb24gdGhlIGNoZWNrYm94LCBgaW5kZXRlcm1pbmF0ZWAgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5kZXRlcm1pbmF0ZUNoYW5nZS5lbWl0KF90aGlzLl9pbmRldGVybWluYXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uQ2hlY2tTdGF0ZSh0aGlzLl9jaGVja2VkID8gVHJhbnNpdGlvbkNoZWNrU3RhdGUuQ2hlY2tlZCA6IFRyYW5zaXRpb25DaGVja1N0YXRlLlVuY2hlY2tlZCk7XG4gICAgICAgICAgICAvLyBFbWl0IG91ciBjdXN0b20gY2hhbmdlIGV2ZW50IGlmIHRoZSBuYXRpdmUgaW5wdXQgZW1pdHRlZCBvbmUuXG4gICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gb25seSBlbWl0IGl0LCBpZiB0aGUgbmF0aXZlIGlucHV0IHRyaWdnZXJlZCBvbmUsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCwgd2hlbiB0aGUgYGNoZWNrZWRgIHZhcmlhYmxlIGNoYW5nZXMgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgY2hlY2tib3guXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLmZvY3VzVmlhKHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LCB0aGlzLl9yZW5kZXJlciwgJ2tleWJvYXJkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fb25JbnRlcmFjdGlvbkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIGFsd2F5cyBoYXZlIHRvIHN0b3AgcHJvcGFnYXRpb24gb24gdGhlIGNoYW5nZSBldmVudC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBjaGFuZ2UgZXZlbnQsIGZyb20gdGhlIGlucHV0IGVsZW1lbnQsIHdpbGwgYnViYmxlIHVwIGFuZFxuICAgICAgICAvLyBlbWl0IGl0cyBldmVudCBvYmplY3QgdG8gdGhlIGBjaGFuZ2VgIG91dHB1dC5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9sZFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBuZXdTdGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX2dldEFuaW1hdGlvbkNsYXNzRm9yQ2hlY2tTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1TdWZmaXg7XG4gICAgICAgIHN3aXRjaCAob2xkU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5pdDpcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZWRnZSBjYXNlIHdoZXJlIHVzZXIgaW50ZXJhY3RzIHdpdGggY2hlY2tib3ggdGhhdCBkb2VzIG5vdCBoYXZlIFsobmdNb2RlbCldIG9yXG4gICAgICAgICAgICAgICAgLy8gW2NoZWNrZWRdIGJvdW5kIHRvIGl0LlxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gVHJhbnNpdGlvbkNoZWNrU3RhdGUuQ2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBhbmltU3VmZml4ID0gJ3VuY2hlY2tlZC1jaGVja2VkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3U3RhdGUgPT0gVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBhbmltU3VmZml4ID0gJ3VuY2hlY2tlZC1pbmRldGVybWluYXRlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRyYW5zaXRpb25DaGVja1N0YXRlLlVuY2hlY2tlZDpcbiAgICAgICAgICAgICAgICBhbmltU3VmZml4ID0gbmV3U3RhdGUgPT09IFRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQgP1xuICAgICAgICAgICAgICAgICAgICAndW5jaGVja2VkLWNoZWNrZWQnIDogJ3VuY2hlY2tlZC1pbmRldGVybWluYXRlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVHJhbnNpdGlvbkNoZWNrU3RhdGUuQ2hlY2tlZDpcbiAgICAgICAgICAgICAgICBhbmltU3VmZml4ID0gbmV3U3RhdGUgPT09IFRyYW5zaXRpb25DaGVja1N0YXRlLlVuY2hlY2tlZCA/XG4gICAgICAgICAgICAgICAgICAgICdjaGVja2VkLXVuY2hlY2tlZCcgOiAnY2hlY2tlZC1pbmRldGVybWluYXRlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5kZXRlcm1pbmF0ZTpcbiAgICAgICAgICAgICAgICBhbmltU3VmZml4ID0gbmV3U3RhdGUgPT09IFRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQgP1xuICAgICAgICAgICAgICAgICAgICAnaW5kZXRlcm1pbmF0ZS1jaGVja2VkJyA6ICdpbmRldGVybWluYXRlLXVuY2hlY2tlZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwibWF0LWNoZWNrYm94LWFuaW0tXCIgKyBhbmltU3VmZml4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmFkZXMgb3V0IHRoZSBmb2N1cyBzdGF0ZSByaXBwbGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fcmVtb3ZlRm9jdXNSaXBwbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9mb2N1c1JpcHBsZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNSaXBwbGUuZmFkZU91dCgpO1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNSaXBwbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWRDaGVja2JveDtcbn0oX01kQ2hlY2tib3hNaXhpbkJhc2UpKTtcbk1kQ2hlY2tib3guZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1jaGVja2JveCwgbWF0LWNoZWNrYm94JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bGFiZWwgY2xhc3M9XFxcIm1hdC1jaGVja2JveC1sYXlvdXRcXFwiICNsYWJlbD4gPGRpdiBjbGFzcz1cXFwibWF0LWNoZWNrYm94LWlubmVyLWNvbnRhaW5lclxcXCIgW2NsYXNzLm1hdC1jaGVja2JveC1pbm5lci1jb250YWluZXItbm8tc2lkZS1tYXJnaW5dPVxcXCIhX2hhc0xhYmVsKClcXFwiPiA8aW5wdXQgI2lucHV0IGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtaW5wdXQgY2RrLXZpc3VhbGx5LWhpZGRlblxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIFtpZF09XFxcImlucHV0SWRcXFwiIFtyZXF1aXJlZF09XFxcInJlcXVpcmVkXFxcIiBbY2hlY2tlZF09XFxcImNoZWNrZWRcXFwiIFt2YWx1ZV09XFxcInZhbHVlXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW25hbWVdPVxcXCJuYW1lXFxcIiBbdGFiSW5kZXhdPVxcXCJ0YWJJbmRleFxcXCIgW2luZGV0ZXJtaW5hdGVdPVxcXCJpbmRldGVybWluYXRlXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiYXJpYUxhYmVsXFxcIiBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVxcXCJhcmlhTGFiZWxsZWRieVxcXCIgKGNoYW5nZSk9XFxcIl9vbkludGVyYWN0aW9uRXZlbnQoJGV2ZW50KVxcXCIgKGNsaWNrKT1cXFwiX29uSW5wdXRDbGljaygkZXZlbnQpXFxcIj4gPGRpdiBtZC1yaXBwbGUgY2xhc3M9XFxcIm1hdC1jaGVja2JveC1yaXBwbGVcXFwiIFttZFJpcHBsZVRyaWdnZXJdPVxcXCJsYWJlbFxcXCIgW21kUmlwcGxlRGlzYWJsZWRdPVxcXCJfaXNSaXBwbGVEaXNhYmxlZCgpXFxcIiBbbWRSaXBwbGVDZW50ZXJlZF09XFxcInRydWVcXFwiPjwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtZnJhbWVcXFwiPjwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtYmFja2dyb3VuZFxcXCI+IDxzdmcgdmVyc2lvbj1cXFwiMS4xXFxcIiBjbGFzcz1cXFwibWF0LWNoZWNrYm94LWNoZWNrbWFya1xcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPiA8cGF0aCBjbGFzcz1cXFwibWF0LWNoZWNrYm94LWNoZWNrbWFyay1wYXRoXFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIndoaXRlXFxcIiBkPVxcXCJNNC4xLDEyLjcgOSwxNy42IDIwLjMsNi4zXFxcIi8+IDwvc3ZnPiA8IS0tIEVsZW1lbnQgZm9yIHJlbmRlcmluZyB0aGUgaW5kZXRlcm1pbmF0ZSBzdGF0ZSBjaGVja2JveC4gLS0+IDxkaXYgY2xhc3M9XFxcIm1hdC1jaGVja2JveC1taXhlZG1hcmtcXFwiPjwvZGl2PiA8L2Rpdj4gPC9kaXY+IDxzcGFuIGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtbGFiZWxcXFwiICNsYWJlbFdyYXBwZXI+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9zcGFuPiA8L2xhYmVsPiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIkBrZXlmcmFtZXMgbWF0LWNoZWNrYm94LWZhZGUtaW4tYmFja2dyb3VuZHswJXtvcGFjaXR5OjB9NTAle29wYWNpdHk6MX19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtZmFkZS1vdXQtYmFja2dyb3VuZHswJSw1MCV7b3BhY2l0eToxfTEwMCV7b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC11bmNoZWNrZWQtY2hlY2tlZC1jaGVja21hcmstcGF0aHswJSw1MCV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjIuOTEwMjZ9NTAle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAsMCwuMiwuMSl9MTAwJXtzdHJva2UtZGFzaG9mZnNldDowfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC11bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZS1taXhlZG1hcmt7MCUsNjguMiV7dHJhbnNmb3JtOnNjYWxlWCgwKX02OC4yJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLDAsMCwxKX0xMDAle3RyYW5zZm9ybTpzY2FsZVgoMSl9fUBrZXlmcmFtZXMgbWF0LWNoZWNrYm94LWNoZWNrZWQtdW5jaGVja2VkLWNoZWNrbWFyay1wYXRoe2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjQsMCwxLDEpO3N0cm9rZS1kYXNob2Zmc2V0OjB9dG97c3Ryb2tlLWRhc2hvZmZzZXQ6LTIyLjkxMDI2fX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1jaGVja2VkLWluZGV0ZXJtaW5hdGUtY2hlY2ttYXJre2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMCwwLC4yLC4xKTtvcGFjaXR5OjE7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3tvcGFjaXR5OjA7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9fUBrZXlmcmFtZXMgbWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUtY2hlY2tlZC1jaGVja21hcmt7ZnJvbXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMTQsMCwwLDEpO29wYWNpdHk6MDt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX10b3tvcGFjaXR5OjE7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1jaGVja2VkLWluZGV0ZXJtaW5hdGUtbWl4ZWRtYXJre2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMCwwLC4yLC4xKTtvcGFjaXR5OjA7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfXRve29wYWNpdHk6MTt0cmFuc2Zvcm06cm90YXRlKDApfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1pbmRldGVybWluYXRlLWNoZWNrZWQtbWl4ZWRtYXJre2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjE0LDAsMCwxKTtvcGFjaXR5OjE7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3tvcGFjaXR5OjA7dHJhbnNmb3JtOnJvdGF0ZSgzMTVkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1pbmRldGVybWluYXRlLXVuY2hlY2tlZC1taXhlZG1hcmt7MCV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZVgoMSl9MTAwJSwzMi44JXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlWCgwKX19Lm1hdC1jaGVja2JveC1iYWNrZ3JvdW5kLC5tYXQtY2hlY2tib3gtY2hlY2ttYXJrLC5tYXQtY2hlY2tib3gtZnJhbWV7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9Lm1hdC1jaGVja2JveC1jaGVja21hcmssLm1hdC1jaGVja2JveC1taXhlZG1hcmt7d2lkdGg6Y2FsYygxMDAlIC0gNHB4KX0ubWF0LWNoZWNrYm94LWJhY2tncm91bmQsLm1hdC1jaGVja2JveC1mcmFtZXtib3JkZXItcmFkaXVzOjJweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9pbnRlci1ldmVudHM6bm9uZX0ubWF0LWNoZWNrYm94e2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKSxib3gtc2hhZG93IDI4MG1zIGN1YmljLWJlemllciguNCwwLC4yLDEpO2N1cnNvcjpwb2ludGVyfS5tYXQtY2hlY2tib3gtbGF5b3V0e2N1cnNvcjppbmhlcml0O2FsaWduLWl0ZW1zOmJhc2VsaW5lO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtkaXNwbGF5OmlubGluZS1mbGV4fS5tYXQtY2hlY2tib3gtaW5uZXItY29udGFpbmVye2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDoyMHB4O2xpbmUtaGVpZ2h0OjA7bWFyZ2luOmF1dG87bWFyZ2luLXJpZ2h0OjhweDtvcmRlcjowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MjBweDtmbGV4LXNocmluazowfVtkaXI9cnRsXSAubWF0LWNoZWNrYm94LWlubmVyLWNvbnRhaW5lcnttYXJnaW4tbGVmdDo4cHg7bWFyZ2luLXJpZ2h0OmF1dG99Lm1hdC1jaGVja2JveC1pbm5lci1jb250YWluZXItbm8tc2lkZS1tYXJnaW57bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0ubWF0LWNoZWNrYm94LWxheW91dCAubWF0LWNoZWNrYm94LWxhYmVse2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1jaGVja2JveC1mcmFtZXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O3RyYW5zaXRpb246Ym9yZGVyLWNvbG9yIDkwbXMgY3ViaWMtYmV6aWVyKDAsMCwuMiwuMSk7Ym9yZGVyLXdpZHRoOjJweDtib3JkZXItc3R5bGU6c29saWR9Lm1hdC1jaGVja2JveC1iYWNrZ3JvdW5ke2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmlubGluZS1mbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDkwbXMgY3ViaWMtYmV6aWVyKDAsMCwuMiwuMSksb3BhY2l0eSA5MG1zIGN1YmljLWJlemllcigwLDAsLjIsLjEpfS5tYXQtY2hlY2tib3gtY2hlY2ttYXJre3dpZHRoOjEwMCV9Lm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aHtzdHJva2UtZGFzaG9mZnNldDoyMi45MTAyNjtzdHJva2UtZGFzaGFycmF5OjIyLjkxMDI2O3N0cm9rZS13aWR0aDoyLjY2NjY3cHh9Lm1hdC1jaGVja2JveC1taXhlZG1hcmt7aGVpZ2h0OjJweDtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlWCgwKSByb3RhdGUoMCl9Lm1hdC1jaGVja2JveC1sYWJlbC1iZWZvcmUgLm1hdC1jaGVja2JveC1pbm5lci1jb250YWluZXJ7b3JkZXI6MTttYXJnaW4tbGVmdDo4cHg7bWFyZ2luLXJpZ2h0OmF1dG99W2Rpcj1ydGxdIC5tYXQtY2hlY2tib3gtbGFiZWwtYmVmb3JlIC5tYXQtY2hlY2tib3gtaW5uZXItY29udGFpbmVye21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OjhweH0ubWF0LWNoZWNrYm94LWNoZWNrZWQgLm1hdC1jaGVja2JveC1jaGVja21hcmt7b3BhY2l0eToxfS5tYXQtY2hlY2tib3gtY2hlY2tlZCAubWF0LWNoZWNrYm94LWNoZWNrbWFyay1wYXRoe3N0cm9rZS1kYXNob2Zmc2V0OjB9Lm1hdC1jaGVja2JveC1jaGVja2VkIC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre3RyYW5zZm9ybTpzY2FsZVgoMSkgcm90YXRlKC00NWRlZyl9Lm1hdC1jaGVja2JveC1pbmRldGVybWluYXRlIC5tYXQtY2hlY2tib3gtY2hlY2ttYXJre29wYWNpdHk6MDt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0ubWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aHtzdHJva2UtZGFzaG9mZnNldDowfS5tYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZSAubWF0LWNoZWNrYm94LW1peGVkbWFya3tvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlWCgxKSByb3RhdGUoMCl9Lm1hdC1jaGVja2JveC11bmNoZWNrZWQgLm1hdC1jaGVja2JveC1iYWNrZ3JvdW5ke2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9Lm1hdC1jaGVja2JveC1kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdH0ubWF0LWNoZWNrYm94LWFuaW0tdW5jaGVja2VkLWNoZWNrZWQgLm1hdC1jaGVja2JveC1iYWNrZ3JvdW5ke2FuaW1hdGlvbjoxODBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWZhZGUtaW4tYmFja2dyb3VuZH0ubWF0LWNoZWNrYm94LWFuaW0tdW5jaGVja2VkLWNoZWNrZWQgLm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aHthbmltYXRpb246MTgwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC11bmNoZWNrZWQtY2hlY2tlZC1jaGVja21hcmstcGF0aH0ubWF0LWNoZWNrYm94LWFuaW0tdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1iYWNrZ3JvdW5ke2FuaW1hdGlvbjoxODBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWZhZGUtaW4tYmFja2dyb3VuZH0ubWF0LWNoZWNrYm94LWFuaW0tdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1taXhlZG1hcmt7YW5pbWF0aW9uOjkwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC11bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZS1taXhlZG1hcmt9Lm1hdC1jaGVja2JveC1hbmltLWNoZWNrZWQtdW5jaGVja2VkIC5tYXQtY2hlY2tib3gtYmFja2dyb3VuZHthbmltYXRpb246MTgwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1mYWRlLW91dC1iYWNrZ3JvdW5kfS5tYXQtY2hlY2tib3gtYW5pbS1jaGVja2VkLXVuY2hlY2tlZCAubWF0LWNoZWNrYm94LWNoZWNrbWFyay1wYXRoe2FuaW1hdGlvbjo5MG1zIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtY2hlY2tlZC11bmNoZWNrZWQtY2hlY2ttYXJrLXBhdGh9Lm1hdC1jaGVja2JveC1hbmltLWNoZWNrZWQtaW5kZXRlcm1pbmF0ZSAubWF0LWNoZWNrYm94LWNoZWNrbWFya3thbmltYXRpb246OTBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWNoZWNrZWQtaW5kZXRlcm1pbmF0ZS1jaGVja21hcmt9Lm1hdC1jaGVja2JveC1hbmltLWNoZWNrZWQtaW5kZXRlcm1pbmF0ZSAubWF0LWNoZWNrYm94LW1peGVkbWFya3thbmltYXRpb246OTBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWNoZWNrZWQtaW5kZXRlcm1pbmF0ZS1taXhlZG1hcmt9Lm1hdC1jaGVja2JveC1hbmltLWluZGV0ZXJtaW5hdGUtY2hlY2tlZCAubWF0LWNoZWNrYm94LWNoZWNrbWFya3thbmltYXRpb246LjVzIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZS1jaGVja2VkLWNoZWNrbWFya30ubWF0LWNoZWNrYm94LWFuaW0taW5kZXRlcm1pbmF0ZS1jaGVja2VkIC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre2FuaW1hdGlvbjouNXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1pbmRldGVybWluYXRlLWNoZWNrZWQtbWl4ZWRtYXJrfS5tYXQtY2hlY2tib3gtYW5pbS1pbmRldGVybWluYXRlLXVuY2hlY2tlZCAubWF0LWNoZWNrYm94LWJhY2tncm91bmR7YW5pbWF0aW9uOjE4MG1zIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtZmFkZS1vdXQtYmFja2dyb3VuZH0ubWF0LWNoZWNrYm94LWFuaW0taW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQgLm1hdC1jaGVja2JveC1taXhlZG1hcmt7YW5pbWF0aW9uOi4zcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUtdW5jaGVja2VkLW1peGVkbWFya30ubWF0LWNoZWNrYm94LWlucHV0e2JvdHRvbTowO2xlZnQ6NTAlfS5tYXQtY2hlY2tib3gtcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTE1cHg7dG9wOi0xNXB4O3JpZ2h0Oi0xNXB4O2JvdHRvbTotMTVweDtib3JkZXItcmFkaXVzOjUwJTt6LWluZGV4OjE7cG9pbnRlci1ldmVudHM6bm9uZX0gLyojIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tib3guY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LWNoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZV0nOiAnaW5kZXRlcm1pbmF0ZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoZWNrYm94LWNoZWNrZWRdJzogJ2NoZWNrZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGVja2JveC1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGVja2JveC1sYWJlbC1iZWZvcmVdJzogJ2xhYmVsUG9zaXRpb24gPT0gXCJiZWZvcmVcIicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9DSEVDS0JPWF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2hlY2tib3guY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c09yaWdpbk1vbml0b3IsIH0sXG5dOyB9O1xuTWRDaGVja2JveC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnYXJpYUxhYmVsJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnYXJpYS1sYWJlbCcsXSB9LF0sXG4gICAgJ2FyaWFMYWJlbGxlZGJ5JzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnYXJpYS1sYWJlbGxlZGJ5JyxdIH0sXSxcbiAgICAnaWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2Rpc2FibGVSaXBwbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3JlcXVpcmVkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdhbGlnbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbGFiZWxQb3NpdGlvbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndGFiSW5kZXgnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2luZGV0ZXJtaW5hdGVDaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnX2lucHV0RWxlbWVudCc6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydpbnB1dCcsXSB9LF0sXG4gICAgJ19sYWJlbFdyYXBwZXInOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnbGFiZWxXcmFwcGVyJyxdIH0sXSxcbiAgICAnX3JpcHBsZSc6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW01kUmlwcGxlLF0gfSxdLFxuICAgICdjaGVja2VkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdpbmRldGVybWluYXRlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG52YXIgTWRDaGVja2JveE1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2hlY2tib3hNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENoZWNrYm94TW9kdWxlO1xufSgpKTtcbk1kQ2hlY2tib3hNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1kUmlwcGxlTW9kdWxlLCBNZENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kQ2hlY2tib3gsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZENoZWNrYm94XSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtGb2N1c09yaWdpbk1vbml0b3JdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2hlY2tib3hNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogUHJvdmlkZXIgRXhwcmVzc2lvbiB0aGF0IGFsbG93cyBtZC1yYWRpby1ncm91cCB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLiBUaGlzXG4gKiBhbGxvd3MgaXQgdG8gc3VwcG9ydCBbKG5nTW9kZWwpXSBhbmQgbmdDb250cm9sLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNRF9SQURJT19HUk9VUF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kUmFkaW9Hcm91cDsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgX3VuaXF1ZUlkQ291bnRlciQyID0gMDtcbi8qKlxuICogQ2hhbmdlIGV2ZW50IG9iamVjdCBlbWl0dGVkIGJ5IE1kUmFkaW8gYW5kIE1kUmFkaW9Hcm91cC5cbiAqL1xudmFyIE1kUmFkaW9DaGFuZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFJhZGlvQ2hhbmdlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRSYWRpb0NoYW5nZTtcbn0oKSk7XG52YXIgTWRSYWRpb0dyb3VwQmFzZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmFkaW9Hcm91cEJhc2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFJhZGlvR3JvdXBCYXNlO1xufSgpKTtcbnZhciBfTWRSYWRpb0dyb3VwTWl4aW5CYXNlID0gbWl4aW5EaXNhYmxlZChNZFJhZGlvR3JvdXBCYXNlKTtcbi8qKlxuICogQSBncm91cCBvZiByYWRpbyBidXR0b25zLiBNYXkgY29udGFpbiBvbmUgb3IgbW9yZSBgPG1kLXJhZGlvLWJ1dHRvbj5gIGVsZW1lbnRzLlxuICovXG52YXIgTWRSYWRpb0dyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFJhZGlvR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRSYWRpb0dyb3VwKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0ZWQgdmFsdWUgZm9yIGdyb3VwLiBTaG91bGQgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBzZWxlY3RlZCByYWRpbyBidXR0b24gaWYgdGhlcmUgKmlzKlxuICAgICAgICAgKiBhIGNvcnJlc3BvbmRpbmcgcmFkaW8gYnV0dG9uIHdpdGggYSBtYXRjaGluZyB2YWx1ZS4gSWYgdGhlcmUgaXMgKm5vdCogc3VjaCBhIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICogcmFkaW8gYnV0dG9uLCB0aGlzIHZhbHVlIHBlcnNpc3RzIHRvIGJlIGFwcGxpZWQgaW4gY2FzZSBhIG5ldyByYWRpbyBidXR0b24gaXMgYWRkZWQgd2l0aCBhXG4gICAgICAgICAqIG1hdGNoaW5nIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIVE1MIG5hbWUgYXR0cmlidXRlIGFwcGxpZWQgdG8gcmFkaW8gYnV0dG9ucyBpbiB0aGlzIGdyb3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX25hbWUgPSBcIm1kLXJhZGlvLWdyb3VwLVwiICsgX3VuaXF1ZUlkQ291bnRlciQyKys7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIHJhZGlvIGJ1dHRvbi4gU2hvdWxkIG1hdGNoIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGB2YWx1ZWAgaGFzIGJlZW4gc2V0IHRvIGl0cyBpbml0aWFsIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtZXRob2QgdG8gYmUgY2FsbGVkIGluIG9yZGVyIHRvIHVwZGF0ZSBuZ01vZGVsXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogb25Ub3VjaCBmdW5jdGlvbiByZWdpc3RlcmVkIHZpYSByZWdpc3Rlck9uVG91Y2ggKENvbnRyb2xWYWx1ZUFjY2Vzc29yKS5cbiAgICAgICAgICogXFxAZG9jcy1wcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGdyb3VwIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgICAqIENoYW5nZSBldmVudHMgYXJlIG9ubHkgZW1pdHRlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIGR1ZSB0byB1c2VyIGludGVyYWN0aW9uIHdpdGhcbiAgICAgICAgICogYSByYWRpbyBidXR0b24gKHRoZSBzYW1lIGJlaGF2aW9yIGFzIGA8aW5wdXQgdHlwZS1cInJhZGlvXCI+YCkuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGlsZCByYWRpbyBidXR0b25zLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3JhZGlvcyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBsYWJlbHMgc2hvdWxkIGFwcGVhciBhZnRlciBvciBiZWZvcmUgdGhlIHJhZGlvLWJ1dHRvbnMuIERlZmF1bHRzIHRvICdhZnRlcidcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmxhYmVsUG9zaXRpb24gPSAnYWZ0ZXInO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvR3JvdXAucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGUgcmFkaW8gYnV0dG9uIGdyb3VwLiBBbGwgcmFkaW8gYnV0dG9ucyBpbnNpZGUgdGhpcyBncm91cCB3aWxsIHVzZSB0aGlzIG5hbWUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hbWU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmFkaW9CdXR0b25OYW1lcygpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJhbGlnblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlnbm1lbnQgb2YgdGhlIHJhZGlvLWJ1dHRvbnMgcmVsYXRpdmUgdG8gdGhlaXIgbGFiZWxzLiBDYW4gYmUgJ2JlZm9yZScgb3IgJ2FmdGVyJy5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gYWxpZ24gcmVmZXJzIHRvIHRoZSBjaGVja2JveCByZWxhdGl2ZSB0byB0aGUgbGFiZWwsIHdoaWxlIGxhYmVsUG9zaXRpb24gcmVmZXJzIHRvIHRoZVxuICAgICAgICAgICAgLy8gbGFiZWwgcmVsYXRpdmUgdG8gdGhlIGNoZWNrYm94LiBBcyBzdWNoLCB0aGV5IGFyZSBpbnZlcnRlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsUG9zaXRpb24gPT0gJ2FmdGVyJyA/ICdzdGFydCcgOiAnZW5kJztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5sYWJlbFBvc2l0aW9uID0gKHYgPT0gJ3N0YXJ0JykgPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvR3JvdXAucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlIG9mIHRoZSByYWRpbyBidXR0b24uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZSAhPSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIFNldCB0aGlzIGJlZm9yZSBwcm9jZWVkaW5nIHRvIGVuc3VyZSBubyBjaXJjdWxhciBsb29wIG9jY3VycyB3aXRoIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGVkUmFkaW9Gcm9tVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1NlbGVjdGVkUmFkaW9CdXR0b24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLl9jaGVja1NlbGVjdGVkUmFkaW9CdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkICYmICF0aGlzLl9zZWxlY3RlZC5jaGVja2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgcmFkaW8gYnV0dG9uIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zZWxlY3RlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gc2VsZWN0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNlbGVjdGVkID8gc2VsZWN0ZWQudmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tTZWxlY3RlZFJhZGlvQnV0dG9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgcHJvcGVydGllcyBvbmNlIGNvbnRlbnQgY2hpbGRyZW4gYXJlIGF2YWlsYWJsZS5cbiAgICAgKiBUaGlzIGFsbG93cyB1cyB0byBwcm9wYWdhdGUgcmVsZXZhbnQgYXR0cmlidXRlcyB0byBhc3NvY2lhdGVkIGJ1dHRvbnMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTWFyayB0aGlzIGNvbXBvbmVudCBhcyBpbml0aWFsaXplZCBpbiBBZnRlckNvbnRlbnRJbml0IGJlY2F1c2UgdGhlIGluaXRpYWwgdmFsdWUgY2FuXG4gICAgICAgIC8vIHBvc3NpYmx5IGJlIHNldCBieSBOZ01vZGVsIG9uIE1kUmFkaW9Hcm91cCwgYW5kIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIE9uSW5pdCBvZiB0aGVcbiAgICAgICAgLy8gTmdNb2RlbCBvY2N1cnMgKmFmdGVyKiB0aGUgT25Jbml0IG9mIHRoZSBNZFJhZGlvR3JvdXAuXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFyayB0aGlzIGdyb3VwIGFzIGJlaW5nIFwidG91Y2hlZFwiIChmb3IgbmdNb2RlbCkuIE1lYW50IHRvIGJlIGNhbGxlZCBieSB0aGUgY29udGFpbmVkXG4gICAgICogcmFkaW8gYnV0dG9ucyB1cG9uIHRoZWlyIGJsdXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLl90b3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub25Ub3VjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVJhZGlvQnV0dG9uTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpb3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhZGlvcy5mb3JFYWNoKGZ1bmN0aW9uIChyYWRpbykge1xuICAgICAgICAgICAgICAgIHJhZGlvLm5hbWUgPSBfdGhpcy5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcmFkaW8gYnV0dG9uIGZyb20gdGhlIGludGVybmFsIF92YWx1ZSBzdGF0ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVNlbGVjdGVkUmFkaW9Gcm9tVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBhbHJlYWR5IG1hdGNoZXMgdGhlIHNlbGVjdGVkIHJhZGlvLCBkbyBub3RoaW5nLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0FscmVhZHlTZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGVkICE9IG51bGwgJiYgdGhpcy5fc2VsZWN0ZWQudmFsdWUgPT0gdGhpcy5fdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpb3MgIT0gbnVsbCAmJiAhaXNBbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JhZGlvcy5mb3JFYWNoKGZ1bmN0aW9uIChyYWRpbykge1xuICAgICAgICAgICAgICAgIHJhZGlvLmNoZWNrZWQgPSBfdGhpcy52YWx1ZSA9PSByYWRpby52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmFkaW8uY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VsZWN0ZWQgPSByYWRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggY2hhbmdlIGV2ZW50IHdpdGggY3VycmVudCBzZWxlY3Rpb24gYW5kIGdyb3VwIHZhbHVlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSBuZXcgTWRSYWRpb0NoYW5nZSgpO1xuICAgICAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgICAgICAgICBldmVudC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1vZGVsIHZhbHVlLiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgbW9kZWwgdmFsdWUgY2hhbmdlcy5cbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7P30gZm4gQ2FsbGJhY2sgdG8gYmUgcmVnaXN0ZXJlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgY29udHJvbCBpcyB0b3VjaGVkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBmbiBDYWxsYmFjayB0byBiZSByZWdpc3RlcmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIGNvbnRyb2wuIEltcGxlbWVudGVkIGFzIGEgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWQgV2hldGhlciB0aGUgY29udHJvbCBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9O1xuICAgIHJldHVybiBNZFJhZGlvR3JvdXA7XG59KF9NZFJhZGlvR3JvdXBNaXhpbkJhc2UpKTtcbk1kUmFkaW9Hcm91cC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtcmFkaW8tZ3JvdXAsIG1hdC1yYWRpby1ncm91cCcsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfUkFESU9fR1JPVVBfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdyYWRpb2dyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcmFkaW8tZ3JvdXBdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2Rpc2FibGVkJ10sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUmFkaW9Hcm91cC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuTWRSYWRpb0dyb3VwLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdjaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdfcmFkaW9zJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZFJhZGlvQnV0dG9uOyB9KSxdIH0sXSxcbiAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnYWxpZ24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2xhYmVsUG9zaXRpb24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzZWxlY3RlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG4vKipcbiAqIEEgcmFkaW8tYnV0dG9uLiBNYXkgYmUgaW5zaWRlIG9mXG4gKi9cbnZhciBNZFJhZGlvQnV0dG9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByYWRpb0dyb3VwXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZm9jdXNPcmlnaW5Nb25pdG9yXG4gICAgICogQHBhcmFtIHs/fSBfcmFkaW9EaXNwYXRjaGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRSYWRpb0J1dHRvbihyYWRpb0dyb3VwLCBfZWxlbWVudFJlZiwgX3JlbmRlcmVyLCBfZm9jdXNPcmlnaW5Nb25pdG9yLCBfcmFkaW9EaXNwYXRjaGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEFzc2VydGlvbnMuIElkZWFsbHkgdGhlc2Ugc2hvdWxkIGJlIHN0cmlwcGVkIG91dCBieSB0aGUgY29tcGlsZXIuXG4gICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiBBc3NlcnQgdGhhdCB0aGVyZSdzIG5vIG5hbWUgYmluZGluZyBBTkQgYSBwYXJlbnQgcmFkaW8gZ3JvdXAuXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvciA9IF9mb2N1c09yaWdpbk1vbml0b3I7XG4gICAgICAgIHRoaXMuX3JhZGlvRGlzcGF0Y2hlciA9IF9yYWRpb0Rpc3BhdGNoZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIElEIGZvciB0aGUgcmFkaW8gYnV0dG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IFwibWQtcmFkaW8tXCIgKyBfdW5pcXVlSWRDb3VudGVyJDIrKztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2hlY2tlZCBzdGF0ZSBvZiB0aGlzIHJhZGlvIGJ1dHRvbiBjaGFuZ2VzLlxuICAgICAgICAgKiBDaGFuZ2UgZXZlbnRzIGFyZSBvbmx5IGVtaXR0ZWQgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyBkdWUgdG8gdXNlciBpbnRlcmFjdGlvbiB3aXRoXG4gICAgICAgICAqIHRoZSByYWRpbyBidXR0b24gKHRoZSBzYW1lIGJlaGF2aW9yIGFzIGA8aW5wdXQgdHlwZS1cInJhZGlvXCI+YCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyByYWRpbyBpcyBjaGVja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgYXNzaWduZWQgdG8gdGhpcyByYWRpby5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yYWRpb0dyb3VwID0gcmFkaW9Hcm91cDtcbiAgICAgICAgX3JhZGlvRGlzcGF0Y2hlci5saXN0ZW4oZnVuY3Rpb24gKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAoaWQgIT0gX3RoaXMuaWQgJiYgbmFtZSA9PSBfdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImRpc2FibGVSaXBwbGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgcmlwcGxlIGVmZmVjdCBmb3IgdGhpcyByYWRpbyBidXR0b24gaXMgZGlzYWJsZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVSaXBwbGU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlUmlwcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImNoZWNrZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHJhZGlvIGJ1dHRvbiBpcyBjaGVja2VkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tlZDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmV3Q2hlY2tlZFN0YXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdDaGVja2VkU3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja2VkICE9IG5ld0NoZWNrZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSBuZXdDaGVja2VkU3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrZWRTdGF0ZSAmJiB0aGlzLnJhZGlvR3JvdXAgJiYgdGhpcy5yYWRpb0dyb3VwLnZhbHVlICE9IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLnNlbGVjdGVkID0gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW5ld0NoZWNrZWRTdGF0ZSAmJiB0aGlzLnJhZGlvR3JvdXAgJiYgdGhpcy5yYWRpb0dyb3VwLnZhbHVlID09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bmNoZWNraW5nIHRoZSBzZWxlY3RlZCByYWRpbyBidXR0b24sIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgcmFkaW9cbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgb24gdGhlIGdyb3VwLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbGwgcmFkaW8gYnV0dG9ucyB3aXRoIHRoZSBzYW1lIG5hbWUgdG8gdW4tY2hlY2suXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhZGlvRGlzcGF0Y2hlci5ub3RpZnkodGhpcy5pZCwgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFsdWUgb2YgdGhpcyByYWRpbyBidXR0b24uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJhZGlvR3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNoZWNrZWQgd2hlbiB0aGUgdmFsdWUgY2hhbmdlZCB0byBtYXRjaCB0aGUgcmFkaW8gZ3JvdXAncyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gdGhpcy5yYWRpb0dyb3VwLnZhbHVlID09IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cC5zZWxlY3RlZCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJhbGlnblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmFkaW8tYnV0dG9uIHNob3VsZCBhcHBlYXIgYmVmb3JlIG9yIGFmdGVyIHRoZSBsYWJlbC5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gYWxpZ24gcmVmZXJzIHRvIHRoZSBjaGVja2JveCByZWxhdGl2ZSB0byB0aGUgbGFiZWwsIHdoaWxlIGxhYmVsUG9zaXRpb24gcmVmZXJzIHRvIHRoZVxuICAgICAgICAgICAgLy8gbGFiZWwgcmVsYXRpdmUgdG8gdGhlIGNoZWNrYm94LiBBcyBzdWNoLCB0aGV5IGFyZSBpbnZlcnRlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsUG9zaXRpb24gPT0gJ2FmdGVyJyA/ICdzdGFydCcgOiAnZW5kJztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5sYWJlbFBvc2l0aW9uID0gKHYgPT0gJ3N0YXJ0JykgPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJsYWJlbFBvc2l0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBhcHBlYXIgYWZ0ZXIgb3IgYmVmb3JlIHRoZSByYWRpbyBidXR0b24uIERlZmF1bHRzIHRvICdhZnRlcidcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsUG9zaXRpb24gfHwgKHRoaXMucmFkaW9Hcm91cCAmJiB0aGlzLnJhZGlvR3JvdXAubGFiZWxQb3NpdGlvbikgfHwgJ2FmdGVyJztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbFBvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByYWRpbyBidXR0b24gaXMgZGlzYWJsZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZCB8fCAodGhpcy5yYWRpb0dyb3VwICE9IG51bGwgJiYgdGhpcy5yYWRpb0dyb3VwLmRpc2FibGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElEIG9mIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCBpbnNpZGUgYDxtZC1yYWRpby1idXR0b24+YFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZCArIFwiLWlucHV0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIHJhZGlvIGJ1dHRvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3IuZm9jdXNWaWEodGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHRoaXMuX3JlbmRlcmVyLCAna2V5Ym9hcmQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJhZGlvR3JvdXApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSByYWRpbyBpcyBpbnNpZGUgYSByYWRpbyBncm91cCwgZGV0ZXJtaW5lIGlmIGl0IHNob3VsZCBiZSBjaGVja2VkXG4gICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSB0aGlzLnJhZGlvR3JvdXAudmFsdWUgPT09IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgLy8gQ29weSBuYW1lIGZyb20gcGFyZW50IHJhZGlvIGdyb3VwXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLnJhZGlvR3JvdXAubmFtZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvclxuICAgICAgICAgICAgLm1vbml0b3IodGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHRoaXMuX3JlbmRlcmVyLCBmYWxzZSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGZvY3VzT3JpZ2luKSB7IHJldHVybiBfdGhpcy5fb25JbnB1dEZvY3VzQ2hhbmdlKGZvY3VzT3JpZ2luKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3Iuc3RvcE1vbml0b3JpbmcodGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggY2hhbmdlIGV2ZW50IHdpdGggY3VycmVudCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLl9lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV2ZW50ID0gbmV3IE1kUmFkaW9DaGFuZ2UoKTtcbiAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcztcbiAgICAgICAgZXZlbnQudmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLl9pc1JpcHBsZURpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlUmlwcGxlIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fb25JbnB1dENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBmb3IgY2xpY2sgZXZlbnRzIG9uIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0IGVsZW1lbnQuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIGxhYmVsIGVsZW1lbnQsIGEgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZGlzcGF0Y2hlZCBvbiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBlbGVtZW50LiBTaW5jZSB3ZSBhcmUgdXNpbmcgYSBsYWJlbCBlbGVtZW50IGFzIG91clxuICAgICAgICAvLyByb290IGNvbnRhaW5lciwgdGhlIGNsaWNrIGV2ZW50IG9uIHRoZSBgcmFkaW8tYnV0dG9uYCB3aWxsIGJlIGV4ZWN1dGVkIHR3aWNlLlxuICAgICAgICAvLyBUaGUgcmVhbCBjbGljayBldmVudCB3aWxsIGJ1YmJsZSB1cCwgYW5kIHRoZSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgYWxzbyB0cmllcyB0byBidWJibGUgdXAuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBsZWFkIHRvIG11bHRpcGxlIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgLy8gUHJldmVudGluZyBidWJibGluZyBmb3IgdGhlIHNlY29uZCBldmVudCB3aWxsIHNvbHZlIHRoYXQgaXNzdWUuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHJhZGlvIGJ1dHRvbiByZWNlaXZlZCBhIGNsaWNrIG9yIHRoZSBpbnB1dCByZWNvZ25pemVkIGFueSBjaGFuZ2UuXG4gICAgICogQ2xpY2tpbmcgb24gYSBsYWJlbCBlbGVtZW50LCB3aWxsIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUuX29uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBvbiB0aGUgY2hhbmdlIGV2ZW50LlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGNoYW5nZSBldmVudCwgZnJvbSB0aGUgaW5wdXQgZWxlbWVudCwgd2lsbCBidWJibGUgdXAgYW5kXG4gICAgICAgIC8vIGVtaXQgaXRzIGV2ZW50IG9iamVjdCB0byB0aGUgYGNoYW5nZWAgb3V0cHV0LlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ3JvdXBWYWx1ZUNoYW5nZWQgPSB0aGlzLnJhZGlvR3JvdXAgJiYgdGhpcy52YWx1ZSAhPSB0aGlzLnJhZGlvR3JvdXAudmFsdWU7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICBpZiAodGhpcy5yYWRpb0dyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4odGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuX3RvdWNoKCk7XG4gICAgICAgICAgICBpZiAoZ3JvdXBWYWx1ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIGZvY3VzIGNoYW5nZXMgZm9yIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7P30gZm9jdXNPcmlnaW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLl9vbklucHV0Rm9jdXNDaGFuZ2UgPSBmdW5jdGlvbiAoZm9jdXNPcmlnaW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mb2N1c1JpcHBsZSAmJiBmb2N1c09yaWdpbiA9PT0gJ2tleWJvYXJkJykge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNSaXBwbGUgPSB0aGlzLl9yaXBwbGUubGF1bmNoKDAsIDAsIHsgcGVyc2lzdGVudDogdHJ1ZSwgY2VudGVyZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWZvY3VzT3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYWRpb0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLl90b3VjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzUmlwcGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNSaXBwbGUuZmFkZU91dCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUmlwcGxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kUmFkaW9CdXR0b247XG59KCkpO1xuTWRSYWRpb0J1dHRvbi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLXJhZGlvLWJ1dHRvbiwgbWF0LXJhZGlvLWJ1dHRvbicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPCEtLSBUT0RPKGplbGJvdXJuKTogcmVuZGVyIHRoZSByYWRpbyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgY29udGVudCAtLT4gPCEtLSBUT0RPKG10bGluKTogRXZhbHVhdGUgdHJhZGUtb2ZmcyBvZiB1c2luZyBuYXRpdmUgcmFkaW8gdnMuIGNvc3Qgb2YgYWRkaXRpb25hbCBiaW5kaW5ncy4gLS0+IDxsYWJlbCBbYXR0ci5mb3JdPVxcXCJpbnB1dElkXFxcIiBjbGFzcz1cXFwibWF0LXJhZGlvLWxhYmVsXFxcIiAjbGFiZWw+IDwhLS0gVGhlIGFjdHVhbCAncmFkaW8nIHBhcnQgb2YgdGhlIGNvbnRyb2wuIC0tPiA8ZGl2IGNsYXNzPVxcXCJtYXQtcmFkaW8tY29udGFpbmVyXFxcIj4gPGRpdiBjbGFzcz1cXFwibWF0LXJhZGlvLW91dGVyLWNpcmNsZVxcXCI+PC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1hdC1yYWRpby1pbm5lci1jaXJjbGVcXFwiPjwvZGl2PiA8ZGl2IG1kLXJpcHBsZSBjbGFzcz1cXFwibWF0LXJhZGlvLXJpcHBsZVxcXCIgW21kUmlwcGxlVHJpZ2dlcl09XFxcImxhYmVsXFxcIiBbbWRSaXBwbGVEaXNhYmxlZF09XFxcIl9pc1JpcHBsZURpc2FibGVkKClcXFwiIFttZFJpcHBsZUNlbnRlcmVkXT1cXFwidHJ1ZVxcXCI+PC9kaXY+IDwvZGl2PiA8aW5wdXQgI2lucHV0IGNsYXNzPVxcXCJtYXQtcmFkaW8taW5wdXQgY2RrLXZpc3VhbGx5LWhpZGRlblxcXCIgdHlwZT1cXFwicmFkaW9cXFwiIFtpZF09XFxcImlucHV0SWRcXFwiIFtjaGVja2VkXT1cXFwiY2hlY2tlZFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFtuYW1lXT1cXFwibmFtZVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcImFyaWFMYWJlbFxcXCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cXFwiYXJpYUxhYmVsbGVkYnlcXFwiIChjaGFuZ2UpPVxcXCJfb25JbnB1dENoYW5nZSgkZXZlbnQpXFxcIiAoY2xpY2spPVxcXCJfb25JbnB1dENsaWNrKCRldmVudClcXFwiPiA8IS0tIFRoZSBsYWJlbCBjb250ZW50IGZvciByYWRpbyBjb250cm9sLiAtLT4gPGRpdiBjbGFzcz1cXFwibWF0LXJhZGlvLWxhYmVsLWNvbnRlbnRcXFwiIFtjbGFzcy5tYXQtcmFkaW8tbGFiZWwtYmVmb3JlXT1cXFwibGFiZWxQb3NpdGlvbiA9PSAnYmVmb3JlJ1xcXCI+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9kaXY+IDwvbGFiZWw+IFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1yYWRpby1idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZn0ubWF0LXJhZGlvLWxhYmVse2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6aW5saW5lLWZsZXg7YWxpZ24taXRlbXM6YmFzZWxpbmU7d2hpdGUtc3BhY2U6bm93cmFwfS5tYXQtcmFkaW8tY29udGFpbmVye2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MjBweDtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoyMHB4O3RvcDoycHh9Lm1hdC1yYWRpby1vdXRlci1jaXJjbGV7Ym94LXNpemluZzpib3JkZXItYm94O2hlaWdodDoyMHB4O2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt0cmFuc2l0aW9uOmJvcmRlci1jb2xvciBlYXNlIDI4MG1zO3dpZHRoOjIwcHg7Ym9yZGVyLXdpZHRoOjJweDtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXJhZGl1czo1MCV9Lm1hdC1yYWRpby1pbm5lci1jaXJjbGV7Ym9yZGVyLXJhZGl1czo1MCU7Ym94LXNpemluZzpib3JkZXItYm94O2hlaWdodDoyMHB4O2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt0cmFuc2l0aW9uOnRyYW5zZm9ybSBlYXNlIDI4MG1zLGJhY2tncm91bmQtY29sb3IgZWFzZSAyODBtczt0cmFuc2Zvcm06c2NhbGUoMCk7d2lkdGg6MjBweH0ubWF0LXJhZGlvLWNoZWNrZWQgLm1hdC1yYWRpby1pbm5lci1jaXJjbGV7dHJhbnNmb3JtOnNjYWxlKC41KX0ubWF0LXJhZGlvLWxhYmVsLWNvbnRlbnR7ZGlzcGxheTppbmxpbmUtYmxvY2s7b3JkZXI6MDtsaW5lLWhlaWdodDppbmhlcml0O3BhZGRpbmctbGVmdDo4cHg7cGFkZGluZy1yaWdodDowfVtkaXI9cnRsXSAubWF0LXJhZGlvLWxhYmVsLWNvbnRlbnR7cGFkZGluZy1yaWdodDo4cHg7cGFkZGluZy1sZWZ0OjB9Lm1hdC1yYWRpby1sYWJlbC1jb250ZW50Lm1hdC1yYWRpby1sYWJlbC1iZWZvcmV7b3JkZXI6LTE7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDo4cHh9W2Rpcj1ydGxdIC5tYXQtcmFkaW8tbGFiZWwtY29udGVudC5tYXQtcmFkaW8tbGFiZWwtYmVmb3Jle3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLWxlZnQ6OHB4fS5tYXQtcmFkaW8tZGlzYWJsZWQsLm1hdC1yYWRpby1kaXNhYmxlZCAubWF0LXJhZGlvLWxhYmVse2N1cnNvcjpkZWZhdWx0fS5tYXQtcmFkaW8tcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTE1cHg7dG9wOi0xNXB4O3JpZ2h0Oi0xNXB4O2JvdHRvbTotMTVweDtib3JkZXItcmFkaXVzOjUwJTt6LWluZGV4OjE7cG9pbnRlci1ldmVudHM6bm9uZX0gLyojIHNvdXJjZU1hcHBpbmdVUkw9cmFkaW8uY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXJhZGlvLWJ1dHRvbl0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXJhZGlvLWNoZWNrZWRdJzogJ2NoZWNrZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1yYWRpby1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuaWRdJzogJ2lkJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUmFkaW9CdXR0b24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBNZFJhZGlvR3JvdXAsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEZvY3VzT3JpZ2luTW9uaXRvciwgfSxcbiAgICB7IHR5cGU6IFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIsIH0sXG5dOyB9O1xuTWRSYWRpb0J1dHRvbi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnaWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2FyaWFMYWJlbCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2FyaWEtbGFiZWwnLF0gfSxdLFxuICAgICdhcmlhTGFiZWxsZWRieSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2FyaWEtbGFiZWxsZWRieScsXSB9LF0sXG4gICAgJ2Rpc2FibGVSaXBwbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NoZWNrZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdhbGlnbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbGFiZWxQb3NpdGlvbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ19yaXBwbGUnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtNZFJpcHBsZSxdIH0sXSxcbiAgICAnX2lucHV0RWxlbWVudCc6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydpbnB1dCcsXSB9LF0sXG59O1xudmFyIE1kUmFkaW9Nb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFJhZGlvTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRSYWRpb01vZHVsZTtcbn0oKSk7XG5NZFJhZGlvTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNZFJpcHBsZU1vZHVsZSwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZFJhZGlvR3JvdXAsIE1kUmFkaW9CdXR0b24sIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVIsIFZJRVdQT1JUX1JVTEVSX1BST1ZJREVSLCBGb2N1c09yaWdpbk1vbml0b3JdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kUmFkaW9Hcm91cCwgTWRSYWRpb0J1dHRvbl0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUmFkaW9Nb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIGtleWJvYXJkIGV2ZW50cyBmb3Igc2VsZWN0YWJsZSBsaXN0cy4gSWYgeW91IHBhc3MgaXQgYSBxdWVyeSBsaXN0XG4gKiBvZiBpdGVtcywgaXQgd2lsbCBzZXQgdGhlIGFjdGl2ZSBpdGVtIGNvcnJlY3RseSB3aGVuIGFycm93IGV2ZW50cyBvY2N1ci5cbiAqL1xudmFyIExpc3RLZXlNYW5hZ2VyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfaXRlbXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXN0S2V5TWFuYWdlcihfaXRlbXMpIHtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBfaXRlbXM7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RhYk91dCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX3dyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHVybnMgb24gd3JhcHBpbmcgbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBhY3RpdmUgaXRlbSB3aWxsIHdyYXAgdG9cbiAgICAgKiB0aGUgb3RoZXIgZW5kIG9mIGxpc3Qgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBpdGVtcyBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIExpc3RLZXlNYW5hZ2VyIHRoYXQgdGhlIG1ldGhvZCB3YXMgY2FsbGVkIG9uLlxuICAgICAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS53aXRoV3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fd3JhcCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGl0ZW0gYXQgdGhlIGluZGV4IHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBpdGVtIHRvIGJlIHNldCBhcyBhY3RpdmUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbSA9IHRoaXMuX2l0ZW1zLnRvQXJyYXkoKVtpbmRleF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSBkZXBlbmRpbmcgb24gdGhlIGtleSBldmVudCBwYXNzZWQgaW4uXG4gICAgICogQHBhcmFtIHs/fSBldmVudCBLZXlib2FyZCBldmVudCB0byBiZSB1c2VkIGZvciBkZXRlcm1pbmluZyB3aGljaCBlbGVtZW50IHNob3VsZCBiZSBhY3RpdmUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUub25LZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV4dEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcmV2aW91c0l0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVEFCOlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBzaG91bGRuJ3QgcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24gb24gdGFiLlxuICAgICAgICAgICAgICAgIHRoaXMuX3RhYk91dC5uZXh0KG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLCBcImFjdGl2ZUl0ZW1JbmRleFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlSXRlbUluZGV4O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLCBcImFjdGl2ZUl0ZW1cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlSXRlbTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGZpcnN0IGVuYWJsZWQgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS5zZXRGaXJzdEl0ZW1BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW1CeUluZGV4KDAsIDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGxhc3QgZW5hYmxlZCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLnNldExhc3RJdGVtQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtQnlJbmRleCh0aGlzLl9pdGVtcy5sZW5ndGggLSAxLCAtMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgbmV4dCBlbmFibGVkIGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0TmV4dEl0ZW1BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9PT0gbnVsbCA/IHRoaXMuc2V0Rmlyc3RJdGVtQWN0aXZlKCkgOiB0aGlzLl9zZXRBY3RpdmVJdGVtQnlEZWx0YSgxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIGEgcHJldmlvdXMgZW5hYmxlZCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLnNldFByZXZpb3VzSXRlbUFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID09PSBudWxsICYmIHRoaXMuX3dyYXAgPyB0aGlzLnNldExhc3RJdGVtQWN0aXZlKClcbiAgICAgICAgICAgIDogdGhpcy5fc2V0QWN0aXZlSXRlbUJ5RGVsdGEoLTEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHNldHRpbmcgb2YgdGhlIGFjdGl2ZUl0ZW1JbmRleCB3aXRob3V0IGFueSBvdGhlciBlZmZlY3RzLlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXggVGhlIG5ldyBhY3RpdmVJdGVtSW5kZXguXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUudXBkYXRlQWN0aXZlSXRlbUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZSwgXCJ0YWJPdXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFueSB0aW1lIHRoZSBUQUIga2V5IGlzIHByZXNzZWQsIHNvIGNvbXBvbmVudHMgY2FuIHJlYWN0XG4gICAgICAgICAqIHdoZW4gZm9jdXMgaXMgc2hpZnRlZCBvZmYgb2YgdGhlIGxpc3QuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YWJPdXQuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGFjdGl2ZSBpdGVtLCBnaXZlbiBhIGxpc3Qgb2YgaXRlbXMgYW5kIHRoZSBkZWx0YSBiZXR3ZWVuIHRoZVxuICAgICAqIGN1cnJlbnRseSBhY3RpdmUgaXRlbSBhbmQgdGhlIG5ldyBhY3RpdmUgaXRlbS4gSXQgd2lsbCBjYWxjdWxhdGUgZGlmZmVyZW50bHlcbiAgICAgKiBkZXBlbmRpbmcgb24gd2hldGhlciB3cmFwIG1vZGUgaXMgdHVybmVkIG9uLlxuICAgICAqIEBwYXJhbSB7P30gZGVsdGFcbiAgICAgKiBAcGFyYW0gez89fSBpdGVtc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLl9zZXRBY3RpdmVJdGVtQnlEZWx0YSA9IGZ1bmN0aW9uIChkZWx0YSwgaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSB0aGlzLl9pdGVtcy50b0FycmF5KCk7IH1cbiAgICAgICAgdGhpcy5fd3JhcCA/IHRoaXMuX3NldEFjdGl2ZUluV3JhcE1vZGUoZGVsdGEsIGl0ZW1zKVxuICAgICAgICAgICAgOiB0aGlzLl9zZXRBY3RpdmVJbkRlZmF1bHRNb2RlKGRlbHRhLCBpdGVtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSBwcm9wZXJseSBnaXZlbiBcIndyYXBcIiBtb2RlLiBJbiBvdGhlciB3b3JkcywgaXQgd2lsbCBjb250aW51ZSB0byBtb3ZlXG4gICAgICogZG93biB0aGUgbGlzdCB1bnRpbCBpdCBmaW5kcyBhbiBpdGVtIHRoYXQgaXMgbm90IGRpc2FibGVkLCBhbmQgaXQgd2lsbCB3cmFwIGlmIGl0XG4gICAgICogZW5jb3VudGVycyBlaXRoZXIgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7P30gZGVsdGFcbiAgICAgKiBAcGFyYW0gez99IGl0ZW1zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuX3NldEFjdGl2ZUluV3JhcE1vZGUgPSBmdW5jdGlvbiAoZGVsdGEsIGl0ZW1zKSB7XG4gICAgICAgIC8vIHdoZW4gYWN0aXZlIGl0ZW0gd291bGQgbGVhdmUgbWVudSwgd3JhcCB0byBiZWdpbm5pbmcgb3IgZW5kXG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9XG4gICAgICAgICAgICAodGhpcy5fYWN0aXZlSXRlbUluZGV4ICsgZGVsdGEgKyBpdGVtcy5sZW5ndGgpICUgaXRlbXMubGVuZ3RoO1xuICAgICAgICAvLyBza2lwIGFsbCBkaXNhYmxlZCBtZW51IGl0ZW1zIHJlY3Vyc2l2ZWx5IHVudGlsIGFuIGVuYWJsZWQgb25lIGlzIHJlYWNoZWRcbiAgICAgICAgaWYgKGl0ZW1zW3RoaXMuX2FjdGl2ZUl0ZW1JbmRleF0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZUluV3JhcE1vZGUoZGVsdGEsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlSXRlbSh0aGlzLl9hY3RpdmVJdGVtSW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSBwcm9wZXJseSBnaXZlbiB0aGUgZGVmYXVsdCBtb2RlLiBJbiBvdGhlciB3b3JkcywgaXQgd2lsbFxuICAgICAqIGNvbnRpbnVlIHRvIG1vdmUgZG93biB0aGUgbGlzdCB1bnRpbCBpdCBmaW5kcyBhbiBpdGVtIHRoYXQgaXMgbm90IGRpc2FibGVkLiBJZlxuICAgICAqIGl0IGVuY291bnRlcnMgZWl0aGVyIGVuZCBvZiB0aGUgbGlzdCwgaXQgd2lsbCBzdG9wIGFuZCBub3Qgd3JhcC5cbiAgICAgKiBAcGFyYW0gez99IGRlbHRhXG4gICAgICogQHBhcmFtIHs/fSBpdGVtc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLl9zZXRBY3RpdmVJbkRlZmF1bHRNb2RlID0gZnVuY3Rpb24gKGRlbHRhLCBpdGVtcykge1xuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtQnlJbmRleCh0aGlzLl9hY3RpdmVJdGVtSW5kZXggKyBkZWx0YSwgZGVsdGEsIGl0ZW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBmaXJzdCBlbmFibGVkIGl0ZW0gc3RhcnRpbmcgYXQgdGhlIGluZGV4IHNwZWNpZmllZC4gSWYgdGhlXG4gICAgICogaXRlbSBpcyBkaXNhYmxlZCwgaXQgd2lsbCBtb3ZlIGluIHRoZSBmYWxsYmFja0RlbHRhIGRpcmVjdGlvbiB1bnRpbCBpdCBlaXRoZXJcbiAgICAgKiBmaW5kcyBhbiBlbmFibGVkIGl0ZW0gb3IgZW5jb3VudGVycyB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcGFyYW0gez99IGZhbGxiYWNrRGVsdGFcbiAgICAgKiBAcGFyYW0gez89fSBpdGVtc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLl9zZXRBY3RpdmVJdGVtQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgZmFsbGJhY2tEZWx0YSwgaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSB0aGlzLl9pdGVtcy50b0FycmF5KCk7IH1cbiAgICAgICAgaWYgKCFpdGVtc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXRlbXNbaW5kZXhdLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpbmRleCArPSBmYWxsYmFja0RlbHRhO1xuICAgICAgICAgICAgaWYgKCFpdGVtc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXN0S2V5TWFuYWdlcjtcbn0oKSk7XG52YXIgRm9jdXNLZXlNYW5hZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGb2N1c0tleU1hbmFnZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpdGVtc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZvY3VzS2V5TWFuYWdlcihpdGVtcykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaXRlbXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogSXQgYWxzbyBhZGRzIGZvY3VzZXMgdGhlIG5ld2x5IGFjdGl2ZSBpdGVtLlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzS2V5TWFuYWdlci5wcm90b3R5cGUuc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldEFjdGl2ZUl0ZW0uY2FsbCh0aGlzLCBpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRm9jdXNLZXlNYW5hZ2VyO1xufShMaXN0S2V5TWFuYWdlcikpO1xuLyoqXG4gKiBUaGlzIGFuaW1hdGlvbiBzaHJpbmtzIHRoZSBwbGFjZWhvbGRlciB0ZXh0IHRvIDc1JSBvZiBpdHMgbm9ybWFsIHNpemUgYW5kIHRyYW5zbGF0ZXNcbiAqIGl0IHRvIGVpdGhlciB0aGUgdG9wIGxlZnQgY29ybmVyIChsdHIpIG9yIHRvcCByaWdodCBjb3JuZXIgKHJ0bCkgb2YgdGhlIHRyaWdnZXIsXG4gKiBkZXBlbmRpbmcgb24gdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAqL1xudmFyIHRyYW5zZm9ybVBsYWNlaG9sZGVyID0gdHJpZ2dlcigndHJhbnNmb3JtUGxhY2Vob2xkZXInLCBbXG4gICAgc3RhdGUoJ2Zsb2F0aW5nLWx0cicsIHN0eWxlKHtcbiAgICAgICAgdG9wOiAnLTIycHgnLFxuICAgICAgICBsZWZ0OiAnLTJweCcsXG4gICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjc1KVwiXG4gICAgfSkpLFxuICAgIHN0YXRlKCdmbG9hdGluZy1ydGwnLCBzdHlsZSh7XG4gICAgICAgIHRvcDogJy0yMnB4JyxcbiAgICAgICAgbGVmdDogJzJweCcsXG4gICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjc1KVwiXG4gICAgfSkpLFxuICAgIHRyYW5zaXRpb24oJyogPT4gKicsIGFuaW1hdGUoXCI0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKVwiKSlcbl0pO1xuLyoqXG4gKiBUaGlzIGFuaW1hdGlvbiB0cmFuc2Zvcm1zIHRoZSBzZWxlY3QncyBvdmVybGF5IHBhbmVsIG9uIGFuZCBvZmYgdGhlIHBhZ2UuXG4gKlxuICogV2hlbiB0aGUgcGFuZWwgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSwgaXQgZXhwYW5kcyBpdHMgd2lkdGggMzJweCwgc2NhbGVzIGl0IHVwIHRvXG4gKiAxMDAlIG9uIHRoZSBZIGF4aXMsIGZhZGVzIGluIGl0cyBib3JkZXIsIGFuZCB0cmFuc2xhdGVzIHNsaWdodGx5IHVwIGFuZCB0byB0aGVcbiAqIHNpZGUgdG8gZW5zdXJlIHRoZSBvcHRpb24gdGV4dCBjb3JyZWN0bHkgb3ZlcmxhcHMgdGhlIHRyaWdnZXIgdGV4dC5cbiAqXG4gKiBXaGVuIHRoZSBwYW5lbCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSwgaXQgc2ltcGx5IGZhZGVzIG91dCBsaW5lYXJseS5cbiAqL1xudmFyIHRyYW5zZm9ybVBhbmVsID0gdHJpZ2dlcigndHJhbnNmb3JtUGFuZWwnLCBbXG4gICAgc3RhdGUoJ3Nob3dpbmcnLCBzdHlsZSh7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIG1pbldpZHRoOiAnY2FsYygxMDAlICsgMzJweCknLFxuICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGVZKDEpXCJcbiAgICB9KSksXG4gICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW1xuICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgbWluV2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZVkoMClcIlxuICAgICAgICB9KSxcbiAgICAgICAgYW5pbWF0ZShcIjE1MG1zIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpXCIpXG4gICAgXSksXG4gICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xuICAgICAgICBhbmltYXRlKCcyNTBtcyAxMDBtcyBsaW5lYXInLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXG4gICAgXSlcbl0pO1xuLyoqXG4gKiBUaGlzIGFuaW1hdGlvbiBmYWRlcyBpbiB0aGUgYmFja2dyb3VuZCBjb2xvciBhbmQgdGV4dCBjb250ZW50IG9mIHRoZVxuICogc2VsZWN0J3Mgb3B0aW9ucy4gSXQgaXMgdGltZSBkZWxheWVkIHRvIG9jY3VyIDEwMG1zIGFmdGVyIHRoZSBvdmVybGF5XG4gKiBwYW5lbCBoYXMgdHJhbnNmb3JtZWQgaW4uXG4gKi9cbnZhciBmYWRlSW5Db250ZW50ID0gdHJpZ2dlcignZmFkZUluQ29udGVudCcsIFtcbiAgICBzdGF0ZSgnc2hvd2luZycsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSksXG4gICAgdHJhbnNpdGlvbigndm9pZCA9PiBzaG93aW5nJywgW1xuICAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICAgIGFuaW1hdGUoXCIxNTBtcyAxMDBtcyBjdWJpYy1iZXppZXIoMC41NSwgMCwgMC41NSwgMC4yKVwiKVxuICAgIF0pXG5dKTtcbi8qKlxuICogUmV0dXJucyBhbiBleGNlcHRpb24gdG8gYmUgdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBjaGFuZ2UgYSBzXG4gKiBlbGVjdCdzIGBtdWx0aXBsZWAgb3B0aW9uIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRNZFNlbGVjdER5bmFtaWNNdWx0aXBsZUVycm9yKCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0Nhbm5vdCBjaGFuZ2UgYG11bHRpcGxlYCBtb2RlIG9mIHNlbGVjdCBhZnRlciBpbml0aWFsaXphdGlvbi4nKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBleGNlcHRpb24gdG8gYmUgdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhc3NpZ24gYSBub24tYXJyYXkgdmFsdWUgdG8gYSBzZWxlY3RcbiAqIGluIGBtdWx0aXBsZWAgbW9kZS4gTm90ZSB0aGF0IGB1bmRlZmluZWRgIGFuZCBgbnVsbGAgYXJlIHN0aWxsIHZhbGlkIHZhbHVlcyB0byBhbGxvdyBmb3JcbiAqIHJlc2V0dGluZyB0aGUgdmFsdWUuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE1kU2VsZWN0Tm9uQXJyYXlWYWx1ZUVycm9yKCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0Nhbm5vdCBhc3NpZ24gdHJ1dGh5IG5vbi1hcnJheSB2YWx1ZSB0byBzZWxlY3QgaW4gYG11bHRpcGxlYCBtb2RlLicpO1xufVxuLyoqXG4gKiBUaGUgZml4ZWQgaGVpZ2h0IG9mIGV2ZXJ5IG9wdGlvbiBlbGVtZW50LlxuICovXG52YXIgU0VMRUNUX09QVElPTl9IRUlHSFQgPSA0ODtcbi8qKlxuICogVGhlIG1heCBoZWlnaHQgb2YgdGhlIHNlbGVjdCdzIG92ZXJsYXkgcGFuZWxcbiAqL1xudmFyIFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUID0gMjU2O1xuLyoqXG4gKiBUaGUgbWF4IG51bWJlciBvZiBvcHRpb25zIHZpc2libGUgYXQgb25jZSBpbiB0aGUgc2VsZWN0IHBhbmVsLlxuICovXG52YXIgU0VMRUNUX01BWF9PUFRJT05TX0RJU1BMQVlFRCA9IDU7XG4vKipcbiAqIFRoZSBmaXhlZCBoZWlnaHQgb2YgdGhlIHNlbGVjdCdzIHRyaWdnZXIgZWxlbWVudC5cbiAqL1xudmFyIFNFTEVDVF9UUklHR0VSX0hFSUdIVCA9IDMwO1xuLyoqXG4gKiBNdXN0IGFkanVzdCBmb3IgdGhlIGRpZmZlcmVuY2UgaW4gaGVpZ2h0IGJldHdlZW4gdGhlIG9wdGlvbiBhbmQgdGhlIHRyaWdnZXIsXG4gKiBzbyB0aGUgdGV4dCB3aWxsIGFsaWduIG9uIHRoZSB5IGF4aXMuXG4gKiAoU0VMRUNUX09QVElPTl9IRUlHSFQgKDQ4KSAtIFNFTEVDVF9UUklHR0VSX0hFSUdIVCAoMzApKSAvIDIgPSA5XG4gKi9cbnZhciBTRUxFQ1RfT1BUSU9OX0hFSUdIVF9BREpVU1RNRU5UID0gOTtcbi8qKlxuICogVGhlIHBhbmVsJ3MgcGFkZGluZyBvbiB0aGUgeC1heGlzXG4gKi9cbnZhciBTRUxFQ1RfUEFORUxfUEFERElOR19YID0gMTY7XG4vKipcbiAqIERpc3RhbmNlIGJldHdlZW4gdGhlIHBhbmVsIGVkZ2UgYW5kIHRoZSBvcHRpb24gdGV4dCBpblxuICogbXVsdGktc2VsZWN0aW9uIG1vZGUuXG4gKlxuICogKFNFTEVDVF9QQURESU5HICogMS43NSkgKyAyMCA9IDQ4XG4gKiBUaGUgcGFkZGluZyBpcyBtdWx0aXBsaWVkIGJ5IDEuNzUgYmVjYXVzZSB0aGUgY2hlY2tib3gncyBtYXJnaW4gaXMgaGFsZiB0aGUgcGFkZGluZywgYW5kXG4gKiB0aGUgYnJvd3NlciBhZGRzIH40cHgsIGJlY2F1c2Ugd2UncmUgdXNpbmcgaW5saW5lIGVsZW1lbnRzLlxuICogVGhlIGNoZWNrYm94IHdpZHRoIGlzIDIwcHguXG4gKi9cbnZhciBTRUxFQ1RfTVVMVElQTEVfUEFORUxfUEFERElOR19YID0gU0VMRUNUX1BBTkVMX1BBRERJTkdfWCAqIDEuNzUgKyAyMDtcbi8qKlxuICogVGhlIHBhbmVsJ3MgcGFkZGluZyBvbiB0aGUgeS1heGlzLiBUaGlzIHBhZGRpbmcgaW5kaWNhdGVzIHRoZXJlIGFyZSBtb3JlXG4gKiBvcHRpb25zIGF2YWlsYWJsZSBpZiB5b3Ugc2Nyb2xsLlxuICovXG52YXIgU0VMRUNUX1BBTkVMX1BBRERJTkdfWSA9IDE2O1xuLyoqXG4gKiBUaGUgc2VsZWN0IHBhbmVsIHdpbGwgb25seSBcImZpdFwiIGluc2lkZSB0aGUgdmlld3BvcnQgaWYgaXQgaXMgcG9zaXRpb25lZCBhdFxuICogdGhpcyB2YWx1ZSBvciBtb3JlIGF3YXkgZnJvbSB0aGUgdmlld3BvcnQgYm91bmRhcnkuXG4gKi9cbnZhciBTRUxFQ1RfUEFORUxfVklFV1BPUlRfUEFERElORyA9IDg7XG4vKipcbiAqIENoYW5nZSBldmVudCBvYmplY3QgdGhhdCBpcyBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAqL1xudmFyIE1kU2VsZWN0Q2hhbmdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRTZWxlY3RDaGFuZ2Uoc291cmNlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTWRTZWxlY3RDaGFuZ2U7XG59KCkpO1xudmFyIE1kU2VsZWN0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfdmlld3BvcnRSdWxlclxuICAgICAqIEBwYXJhbSB7P30gX2NoYW5nZURldGVjdG9yUmVmXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICogQHBhcmFtIHs/fSBfY29udHJvbFxuICAgICAqIEBwYXJhbSB7P30gdGFiSW5kZXhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFNlbGVjdChfZWxlbWVudCwgX3JlbmRlcmVyLCBfdmlld3BvcnRSdWxlciwgX2NoYW5nZURldGVjdG9yUmVmLCBfZGlyLCBfY29udHJvbCwgdGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRSdWxlciA9IF92aWV3cG9ydFJ1bGVyO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgdGhpcy5fY29udHJvbCA9IF9jb250cm9sO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG92ZXJsYXkgcGFuZWwgaXMgb3Blbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBmaWxsaW5nIG91dCB0aGUgc2VsZWN0IGlzIHJlcXVpcmVkIGluIHRoZSBmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHNlbGVjdCBpcyBkaXNhYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IHBhbmVsLCBjYWxjdWxhdGVkIHRvIGNlbnRlciB0aGUgc2VsZWN0ZWQgb3B0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBpbiBtdWx0aXBsZSBzZWxlY3Rpb24gbW9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX211bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW5pbWF0aW9uIHN0YXRlIG9mIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyU3RhdGUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gdmFsdWUgY2hhbmdlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gc2VsZWN0IGhhcyBiZWVuIHRvdWNoZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRHMgb2YgY2hpbGQgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFyaWEtb3ducyBhdHRyaWJ1dGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vcHRpb25JZHMgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0IHBhbmVsJ3MgdHJhbnNmb3JtLW9yaWdpbiBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICd0b3AnO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgcGFuZWwncyBhbmltYXRpb24gaXMgZG9uZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3BhbmVsRG9uZUFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHktb2Zmc2V0IG9mIHRoZSBvdmVybGF5IHBhbmVsIGluIHJlbGF0aW9uIHRvIHRoZSB0cmlnZ2VyJ3MgdG9wIHN0YXJ0IGNvcm5lci5cbiAgICAgICAgICogVGhpcyBtdXN0IGJlIGFkanVzdGVkIHRvIGFsaWduIHRoZSBzZWxlY3RlZCBvcHRpb24gdGV4dCBvdmVyIHRoZSB0cmlnZ2VyIHRleHQuXG4gICAgICAgICAqIHdoZW4gdGhlIHBhbmVsIG9wZW5zLiBXaWxsIGNoYW5nZSBiYXNlZCBvbiB0aGUgeS1wb3NpdGlvbiBvZiB0aGUgc2VsZWN0ZWQgb3B0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHBvc2l0aW9uIGNvbmZpZyBlbnN1cmVzIHRoYXQgdGhlIHRvcCBcInN0YXJ0XCIgY29ybmVyIG9mIHRoZSBvdmVybGF5XG4gICAgICAgICAqIGlzIGFsaWduZWQgd2l0aCB3aXRoIHRoZSB0b3AgXCJzdGFydFwiIG9mIHRoZSBvcmlnaW4gYnkgZGVmYXVsdCAob3ZlcmxhcHBpbmdcbiAgICAgICAgICogdGhlIHRyaWdnZXIgY29tcGxldGVseSkuIElmIHRoZSBwYW5lbCBjYW5ub3QgZml0IGJlbG93IHRoZSB0cmlnZ2VyLCBpdFxuICAgICAgICAgKiB3aWxsIGZhbGwgYmFjayB0byBhIHBvc2l0aW9uIGFib3ZlIHRoZSB0cmlnZ2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcG9zaXRpb25zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICAgICAgICAgICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgb3ZlcmxheVk6ICd0b3AnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgIG9yaWdpblk6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlZOiAnYm90dG9tJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXIgPSAnYXV0byc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcmlhIGxhYmVsIG9mIHRoZSBzZWxlY3QuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBwbGFjZWhvbGRlciB3aWxsIGJlIHVzZWQgYXMgbGFiZWwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFyaWFMYWJlbCA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5wdXQgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBgYXJpYS1sYWJlbGxlZGJ5YCBhdHRyaWJ1dGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFyaWFMYWJlbGxlZGJ5ID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBoYXMgYmVlbiBvcGVuZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uT3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0IGhhcyBiZWVuIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25DbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZCBieSB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBpZiAodGhpcy5fY29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWJJbmRleCA9IHBhcnNlSW50KHRhYkluZGV4KSB8fCAwO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYWNlaG9sZGVyIHRvIGJlIHNob3duIGlmIG5vIHZhbHVlIGhhcyBiZWVuIHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGFjZWhvbGRlcjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIE11c3Qgd2FpdCB0byByZWNvcmQgdGhlIHRyaWdnZXIgd2lkdGggdG8gZW5zdXJlIHBsYWNlaG9sZGVyIHdpZHRoIGlzIGluY2x1ZGVkLlxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NldFRyaWdnZXJXaWR0aCgpOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb21wb25lbnQgaXMgZGlzYWJsZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb21wb25lbnQgaXMgcmVxdWlyZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlcXVpcmVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fcmVxdWlyZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcIm11bHRpcGxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgc2hvdWxkIGJlIGFsbG93ZWQgdG8gc2VsZWN0IG11bHRpcGxlIG9wdGlvbnMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX211bHRpcGxlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbCkge1xuICAgICAgICAgICAgICAgIHRocm93IGdldE1kU2VsZWN0RHluYW1pY011bHRpcGxlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX211bHRpcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJmbG9hdFBsYWNlaG9sZGVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gZmxvYXQgdGhlIHBsYWNlaG9sZGVyIHRleHQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXI7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZmxvYXRQbGFjZWhvbGRlciA9IHZhbHVlIHx8ICdhdXRvJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWIgaW5kZXggZm9yIHRoZSBzZWxlY3QgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQgPyAtMSA6IHRoaXMuX3RhYkluZGV4OyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFiSW5kZXggPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVtZSBjb2xvciBmb3IgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sb3I7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSB0aGlzLl9jb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgXCJtYXQtXCIgKyB0aGlzLl9jb2xvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcIm9wdGlvblNlbGVjdGlvbkNoYW5nZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tYmluZWQgc3RyZWFtIG9mIGFsbCBvZiB0aGUgY2hpbGQgb3B0aW9ucycgY2hhbmdlIGV2ZW50cy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGUubWVyZ2UuYXBwbHkoT2JzZXJ2YWJsZSwgdGhpcy5vcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBvcHRpb24ub25TZWxlY3Rpb25DaGFuZ2U7IH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsID0gbmV3IFNlbGVjdGlvbk1vZGVsKHRoaXMubXVsdGlwbGUsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IHRoaXMuY29sb3IgfHwgJ3ByaW1hcnknO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9pbml0S2V5TWFuYWdlcigpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VTdWJzY3JpcHRpb24gPSB0aGlzLm9wdGlvbnMuY2hhbmdlcy5zdGFydFdpdGgobnVsbCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXNldE9wdGlvbnMoKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fY29udHJvbCkge1xuICAgICAgICAgICAgICAgIC8vIERlZmVyIHNldHRpbmcgdGhlIHZhbHVlIGluIG9yZGVyIHRvIGF2b2lkIHRoZSBcIkV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAvLyBoYXMgY2hhbmdlZCBhZnRlciBpdCB3YXMgY2hlY2tlZFwiIGVycm9ycyBmcm9tIEFuZ3VsYXIuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NldFNlbGVjdGlvbkJ5VmFsdWUoX3RoaXMuX2NvbnRyb2wudmFsdWUpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZHJvcFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RhYlN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdGFiU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIG92ZXJsYXkgcGFuZWwgb3BlbiBvciBjbG9zZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhbmVsT3BlbiA/IHRoaXMuY2xvc2UoKSA6IHRoaXMub3BlbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIG92ZXJsYXkgcGFuZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3RyaWdnZXJXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VHJpZ2dlcldpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlT3ZlcmxheVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyU3RhdGUgPSB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyU3RhdGUoKTtcbiAgICAgICAgdGhpcy5fcGFuZWxPcGVuID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgb3ZlcmxheSBwYW5lbCBhbmQgZm9jdXNlcyB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcGFuZWxPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lbE9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclN0YXRlID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9mb2N1c0hvc3QoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0J3MgdmFsdWUuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZVxuICAgICAqIHJlcXVpcmVkIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWUgTmV3IHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uQnlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzZWxlY3QncyB2YWx1ZVxuICAgICAqIGNoYW5nZXMgZnJvbSB1c2VyIGlucHV0LiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2VcbiAgICAgKiByZXF1aXJlZCB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzZWxlY3QgaXMgYmx1cnJlZFxuICAgICAqIGJ5IHRoZSB1c2VyLiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UgcmVxdWlyZWRcbiAgICAgKiB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdG91Y2hlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBzZWxlY3QuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSByZXF1aXJlZFxuICAgICAqIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZCBTZXRzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcInBhbmVsT3BlblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3ZlcmxheSBwYW5lbCBpcyBvcGVuLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFuZWxPcGVuO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNlbGVjdC5wcm90b3R5cGUsIFwidHJpZ2dlclZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBkaXNwbGF5ZWQgaW4gdGhlIHRyaWdnZXIuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdGVkT3B0aW9ucyA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBvcHRpb24udmlld1ZhbHVlOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNSdGwoKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE9wdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPKGNyaXNiZXRvKTogZGVsaW1pdGVyIHNob3VsZCBiZSBjb25maWd1cmFibGUgZm9yIHByb3BlciBsb2NhbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkT3B0aW9ucy5qb2luKCcsICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkWzBdLnZpZXdWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpcyBpbiBSVEwgbW9kZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5faXNSdGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgPT09ICdydGwnIDogZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB3aWR0aCBvZiB0aGUgdHJpZ2dlciBlbGVtZW50LiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBtYXRjaFxuICAgICAqIHRoZSBvdmVybGF5IHdpZHRoIHRvIHRoZSB0cmlnZ2VyIHdpZHRoLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9zZXRUcmlnZ2VyV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJXaWR0aCA9IHRoaXMuX2dldFRyaWdnZXJSZWN0KCkud2lkdGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBrZXlib2FyZCBpbnRlcmFjdGlvbnMgb2YgYSBjbG9zZWQgc2VsZWN0LlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5faGFuZGxlQ2xvc2VkS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBTUEFDRSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nIGRvd24gd2hlbiBwcmVzc2luZyBzcGFjZVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gVVBfQVJST1cgfHwgZXZlbnQua2V5Q29kZSA9PT0gRE9XTl9BUlJPVykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUFycm93S2V5KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBrZXlwcmVzc2VzIGluc2lkZSB0aGUgcGFuZWwuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9oYW5kbGVQYW5lbEtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEhPTUUgfHwgZXZlbnQua2V5Q29kZSA9PT0gRU5EKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQua2V5Q29kZSA9PT0gSE9NRSA/IHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCkgOlxuICAgICAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0TGFzdEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcGFuZWwgZWxlbWVudCBpcyBmaW5pc2hlZCB0cmFuc2Zvcm1pbmcgaW4gKHRob3VnaCBub3QgZmFkaW5nIGluKSwgaXRcbiAgICAgKiBlbWl0cyBhbiBldmVudCBhbmQgZm9jdXNlcyBhbiBvcHRpb24gaWYgdGhlIHBhbmVsIGlzIG9wZW4uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX29uUGFuZWxEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbE9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzQ29ycmVjdE9wdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5vbk9wZW4uZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhbmVsRG9uZUFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5RGlyLm9mZnNldFggPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBwYW5lbCBjb250ZW50IGlzIGRvbmUgZmFkaW5nIGluLCB0aGUgX3BhbmVsRG9uZUFuaW1hdGluZyBwcm9wZXJ0eSBpc1xuICAgICAqIHNldCBzbyB0aGUgcHJvcGVyIGNsYXNzIGNhbiBiZSBhZGRlZCB0byB0aGUgcGFuZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX29uRmFkZUluRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGFuZWxEb25lQW5pbWF0aW5nID0gdGhpcy5wYW5lbE9wZW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgdG91Y2hlZCBjYWxsYmFjayBvbmx5IGlmIHRoZSBwYW5lbCBpcyBjbG9zZWQuIE90aGVyd2lzZSwgdGhlIHRyaWdnZXIgd2lsbFxuICAgICAqIFwiYmx1clwiIHRvIHRoZSBwYW5lbCB3aGVuIGl0IG9wZW5zLCBjYXVzaW5nIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhbmVsT3Blbikge1xuICAgICAgICAgICAgdGhpcy5fb25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSBvdmVybGF5IHBhbmVsIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9vbkF0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVPdmVybGF5T2Zmc2V0WCgpO1xuICAgICAgICB0aGlzLl9zZXRTY3JvbGxUb3AoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lci4gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlclxuICAgICAqIHRoZSBvdmVybGF5IHBhbmUgaXMgYXR0YWNoZWQgb3IgdGhlIHNjcm9sbCBjb250YWluZXIgZWxlbWVudCB3aWxsIG5vdCB5ZXQgYmVcbiAgICAgKiBwcmVzZW50IGluIHRoZSBET00uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5vdmVybGF5RGlyLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1hdC1zZWxlY3QtcGFuZWwnKTtcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMuX3Njcm9sbFRvcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdGVkIG9wdGlvbiBiYXNlZCBvbiBhIHZhbHVlLiBJZiBubyBvcHRpb24gY2FuIGJlXG4gICAgICogZm91bmQgd2l0aCB0aGUgZGVzaWduYXRlZCB2YWx1ZSwgdGhlIHNlbGVjdCB0cmlnZ2VyIGlzIGNsZWFyZWQuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9zZXRTZWxlY3Rpb25CeVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUgJiYgdmFsdWUgJiYgIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kU2VsZWN0Tm9uQXJyYXlWYWx1ZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRWYWx1ZSkgeyByZXR1cm4gX3RoaXMuX3NlbGVjdFZhbHVlKGN1cnJlbnRWYWx1ZSk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fc29ydFZhbHVlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0VmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFZhbHVlV2lkdGgoKTtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJTdGF0ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZHMgYW5kIHNlbGVjdHMgYW5kIG9wdGlvbiBiYXNlZCBvbiBpdHMgdmFsdWUuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99IE9wdGlvbiB0aGF0IGhhcyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NlbGVjdFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnNBcnJheSA9IHRoaXMub3B0aW9ucy50b0FycmF5KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvcnJlc3BvbmRpbmdPcHRpb24gPSBvcHRpb25zQXJyYXkuZmluZChmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBvcHRpb24udmFsdWUgJiYgb3B0aW9uLnZhbHVlID09PSB2YWx1ZTsgfSk7XG4gICAgICAgIGlmIChjb3JyZXNwb25kaW5nT3B0aW9uKSB7XG4gICAgICAgICAgICBjb3JyZXNwb25kaW5nT3B0aW9uLnNlbGVjdCgpO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KGNvcnJlc3BvbmRpbmdPcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKG9wdGlvbnNBcnJheS5pbmRleE9mKGNvcnJlc3BvbmRpbmdPcHRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ycmVzcG9uZGluZ09wdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc2VsZWN0IHRyaWdnZXIgYW5kIGRlc2VsZWN0cyBldmVyeSBvcHRpb24gaW4gdGhlIGxpc3QuXG4gICAgICogQHBhcmFtIHs/PX0gc2tpcCBPcHRpb24gdGhhdCBzaG91bGQgbm90IGJlIGRlc2VsZWN0ZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2NsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24gKHNraXApIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbiAhPT0gc2tpcCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5kZXNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9nZXRUcmlnZ2VyUmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBhIGtleSBtYW5hZ2VyIHRvIGxpc3RlbiB0byBrZXlib2FyZCBldmVudHMgb24gdGhlIG92ZXJsYXkgcGFuZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2luaXRLZXlNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEZvY3VzS2V5TWFuYWdlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLl90YWJTdWJzY3JpcHRpb24gPSB0aGlzLl9rZXlNYW5hZ2VyLnRhYk91dC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvc2UoKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEcm9wcyBjdXJyZW50IG9wdGlvbiBzdWJzY3JpcHRpb25zIGFuZCBJRHMgYW5kIHJlc2V0cyBmcm9tIHNjcmF0Y2guXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3Jlc2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZHJvcFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuVG9PcHRpb25zKCk7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbklkcygpO1xuICAgICAgICB0aGlzLl9zZXRPcHRpb25NdWx0aXBsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdGVucyB0byB1c2VyLWdlbmVyYXRlZCBzZWxlY3Rpb24gZXZlbnRzIG9uIGVhY2ggb3B0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9saXN0ZW5Ub09wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX29wdGlvblN1YnNjcmlwdGlvbiA9IHRoaXMub3B0aW9uU2VsZWN0aW9uQ2hhbmdlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LmlzVXNlcklucHV0OyB9KVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLl9vblNlbGVjdChldmVudC5zb3VyY2UpO1xuICAgICAgICAgICAgX3RoaXMuX3NldFZhbHVlV2lkdGgoKTtcbiAgICAgICAgICAgIGlmICghX3RoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiBhbiBvcHRpb24gaXMgY2xpY2tlZC5cbiAgICAgKiBAcGFyYW0gez99IG9wdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9vblNlbGVjdCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2FzU2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKG9wdGlvbik7XG4gICAgICAgIC8vIFRPRE8oY3Jpc2JldG8pOiBoYW5kbGUgYmxhbmsvbnVsbCBvcHRpb25zIGluc2lkZSBtdWx0aS1zZWxlY3QuXG4gICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC50b2dnbGUob3B0aW9uKTtcbiAgICAgICAgICAgIHdhc1NlbGVjdGVkID8gb3B0aW9uLmRlc2VsZWN0KCkgOiBvcHRpb24uc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9zb3J0VmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGVjdGlvbihvcHRpb24udmFsdWUgPT0gbnVsbCA/IG51bGwgOiBvcHRpb24pO1xuICAgICAgICAgICAgaWYgKG9wdGlvbi52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlcyhvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KG9wdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhc1NlbGVjdGVkICE9PSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKG9wdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BhZ2F0ZUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIG1vZGVsIHZhbHVlcywgZW5zdXJpbmcgdGhhdCB0aGV5IGtlZXAgdGhlIHNhbWVcbiAgICAgKiBvcmRlciB0aGF0IHRoZXkgaGF2ZSBpbiB0aGUgcGFuZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NvcnRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9tdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Qob3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gYWxsIG9wdGlvbiBzdWJzY3JpcHRpb25zLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9kcm9wU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25TdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBjaGFuZ2UgZXZlbnQgdG8gc2V0IHRoZSBtb2RlbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gez89fSBmYWxsYmFja1ZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3Byb3BhZ2F0ZUNoYW5nZXMgPSBmdW5jdGlvbiAoZmFsbGJhY2tWYWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZVRvRW1pdCA9IG51bGw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICB2YWx1ZVRvRW1pdCA9IHRoaXMuc2VsZWN0ZWQubWFwKGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIG9wdGlvbi52YWx1ZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZVRvRW1pdCA9IHRoaXMuc2VsZWN0ZWQgPyB0aGlzLnNlbGVjdGVkLnZhbHVlIDogZmFsbGJhY2tWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbkNoYW5nZSh2YWx1ZVRvRW1pdCk7XG4gICAgICAgIHRoaXMuY2hhbmdlLmVtaXQobmV3IE1kU2VsZWN0Q2hhbmdlKHRoaXMsIHZhbHVlVG9FbWl0KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWNvcmRzIG9wdGlvbiBJRHMgdG8gcGFzcyB0byB0aGUgYXJpYS1vd25zIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9zZXRPcHRpb25JZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbklkcyA9IHRoaXMub3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbikgeyByZXR1cm4gb3B0aW9uLmlkOyB9KS5qb2luKCcgJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgbXVsdGlwbGVgIHByb3BlcnR5IG9uIGVhY2ggb3B0aW9uLiBUaGUgcHJvbWlzZSBpcyBuZWNlc3NhcnlcbiAgICAgKiBpbiBvcmRlciB0byBhdm9pZCBBbmd1bGFyIGVycm9ycyB3aGVuIG1vZGlmeWluZyB0aGUgcHJvcGVydHkgYWZ0ZXIgaW5pdC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fc2V0T3B0aW9uTXVsdGlwbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIG9wdGlvbi5tdWx0aXBsZSA9IF90aGlzLm11bHRpcGxlOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNdXN0IHNldCB0aGUgd2lkdGggb2YgdGhlIHNlbGVjdGVkIG9wdGlvbidzIHZhbHVlIHByb2dyYW1tYXRpY2FsbHlcbiAgICAgKiBiZWNhdXNlIGl0IGlzIGFic29sdXRlbHkgcG9zaXRpb25lZCBhbmQgb3RoZXJ3aXNlIHdpbGwgbm90IGNsaXBcbiAgICAgKiBvdmVyZmxvdy4gVGhlIHNlbGVjdGlvbiBhcnJvdyBpcyA5cHggd2lkZSwgYWRkIDRweCBvZiBwYWRkaW5nID0gMTNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fc2V0VmFsdWVXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRWYWx1ZVdpZHRoID0gdGhpcy5fdHJpZ2dlcldpZHRoIC0gMTM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBzZWxlY3RlZCBpdGVtLiBJZiBubyBvcHRpb24gaXMgc2VsZWN0ZWQsIGl0IHdpbGwgZm9jdXNcbiAgICAgKiB0aGUgZmlyc3QgaXRlbSBpbnN0ZWFkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9mb2N1c0NvcnJlY3RPcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0odGhpcy5fZ2V0T3B0aW9uSW5kZXgodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgaG9zdCBlbGVtZW50IHdoZW4gdGhlIHBhbmVsIGNsb3Nlcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZm9jdXNIb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBwcm92aWRlZCBvcHRpb24gaW4gdGhlIG9wdGlvbiBsaXN0LlxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2dldE9wdGlvbkluZGV4ID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBjdXJyZW50LCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gKG9wdGlvbiA9PT0gY3VycmVudCA/IGluZGV4IDogdW5kZWZpbmVkKSA6IHJlc3VsdDtcbiAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNjcm9sbCBwb3NpdGlvbiBhbmQgeC0gYW5kIHktb2Zmc2V0cyBvZiB0aGUgb3ZlcmxheSBwYW5lbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2FsY3VsYXRlT3ZlcmxheVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYW5lbEhlaWdodCA9IE1hdGgubWluKHRoaXMub3B0aW9ucy5sZW5ndGggKiBTRUxFQ1RfT1BUSU9OX0hFSUdIVCwgU0VMRUNUX1BBTkVMX01BWF9IRUlHSFQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY3JvbGxDb250YWluZXJIZWlnaHQgPSB0aGlzLm9wdGlvbnMubGVuZ3RoICogU0VMRUNUX09QVElPTl9IRUlHSFQ7XG4gICAgICAgIC8vIFRoZSBmYXJ0aGVzdCB0aGUgcGFuZWwgY2FuIGJlIHNjcm9sbGVkIGJlZm9yZSBpdCBoaXRzIHRoZSBib3R0b21cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF4U2Nyb2xsID0gc2Nyb2xsQ29udGFpbmVySGVpZ2h0IC0gcGFuZWxIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RlZEluZGV4ID0gdGhpcy5fZ2V0T3B0aW9uSW5kZXgodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF0pO1xuICAgICAgICAgICAgLy8gV2UgbXVzdCBtYWludGFpbiBhIHNjcm9sbCBidWZmZXIgc28gdGhlIHNlbGVjdGVkIG9wdGlvbiB3aWxsIGJlIHNjcm9sbGVkIHRvIHRoZVxuICAgICAgICAgICAgLy8gY2VudGVyIG9mIHRoZSBvdmVybGF5IHBhbmVsIHJhdGhlciB0aGFuIHRoZSB0b3AuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY3JvbGxCdWZmZXIgPSBwYW5lbEhlaWdodCAvIDI7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb3AgPSB0aGlzLl9jYWxjdWxhdGVPdmVybGF5U2Nyb2xsKHNlbGVjdGVkSW5kZXgsIHNjcm9sbEJ1ZmZlciwgbWF4U2Nyb2xsKTtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldFkgPSB0aGlzLl9jYWxjdWxhdGVPdmVybGF5T2Zmc2V0WShzZWxlY3RlZEluZGV4LCBzY3JvbGxCdWZmZXIsIG1heFNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBubyBvcHRpb24gaXMgc2VsZWN0ZWQsIHRoZSBwYW5lbCBjZW50ZXJzIG9uIHRoZSBmaXJzdCBvcHRpb24uIEluIHRoaXMgY2FzZSxcbiAgICAgICAgICAgIC8vIHdlIG11c3Qgb25seSBhZGp1c3QgZm9yIHRoZSBoZWlnaHQgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBvcHRpb24gZWxlbWVudFxuICAgICAgICAgICAgLy8gYW5kIHRoZSB0cmlnZ2VyIGVsZW1lbnQsIHRoZW4gbXVsdGlwbHkgaXQgYnkgLTEgdG8gZW5zdXJlIHRoZSBwYW5lbCBtb3Zlc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uIHVwIHRoZSBwYWdlLlxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IChTRUxFQ1RfT1BUSU9OX0hFSUdIVCAtIFNFTEVDVF9UUklHR0VSX0hFSUdIVCkgLyAyICogLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tPdmVybGF5V2l0aGluVmlld3BvcnQobWF4U2Nyb2xsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0J3Mgb3ZlcmxheSBwYW5lbC5cbiAgICAgKlxuICAgICAqIEF0dGVtcHRzIHRvIGNlbnRlciB0aGUgc2VsZWN0ZWQgb3B0aW9uIGluIHRoZSBwYW5lbC4gSWYgdGhlIG9wdGlvbiBpc1xuICAgICAqIHRvbyBoaWdoIG9yIHRvbyBsb3cgaW4gdGhlIHBhbmVsIHRvIGJlIHNjcm9sbGVkIHRvIHRoZSBjZW50ZXIsIGl0IGNsYW1wcyB0aGVcbiAgICAgKiBzY3JvbGwgcG9zaXRpb24gdG8gdGhlIG1pbiBvciBtYXggc2Nyb2xsIHBvc2l0aW9ucyByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RlZEluZGV4XG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxCdWZmZXJcbiAgICAgKiBAcGFyYW0gez99IG1heFNjcm9sbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9jYWxjdWxhdGVPdmVybGF5U2Nyb2xsID0gZnVuY3Rpb24gKHNlbGVjdGVkSW5kZXgsIHNjcm9sbEJ1ZmZlciwgbWF4U2Nyb2xsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbk9mZnNldEZyb21TY3JvbGxUb3AgPSBTRUxFQ1RfT1BUSU9OX0hFSUdIVCAqIHNlbGVjdGVkSW5kZXg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhbGZPcHRpb25IZWlnaHQgPSBTRUxFQ1RfT1BUSU9OX0hFSUdIVCAvIDI7XG4gICAgICAgIC8vIFN0YXJ0cyBhdCB0aGUgb3B0aW9uT2Zmc2V0RnJvbVNjcm9sbFRvcCwgd2hpY2ggc2Nyb2xscyB0aGUgb3B0aW9uIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgICAgIC8vIHNjcm9sbCBjb250YWluZXIsIHRoZW4gc3VidHJhY3RzIHRoZSBzY3JvbGwgYnVmZmVyIHRvIHNjcm9sbCB0aGUgb3B0aW9uIGRvd24gdG9cbiAgICAgICAgLy8gdGhlIGNlbnRlciBvZiB0aGUgb3ZlcmxheSBwYW5lbC4gSGFsZiB0aGUgb3B0aW9uIGhlaWdodCBtdXN0IGJlIHJlLWFkZGVkIHRvIHRoZVxuICAgICAgICAvLyBzY3JvbGxUb3Agc28gdGhlIG9wdGlvbiBpcyBjZW50ZXJlZCBiYXNlZCBvbiBpdHMgbWlkZGxlLCBub3QgaXRzIHRvcCBlZGdlLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpbWFsU2Nyb2xsUG9zaXRpb24gPSBvcHRpb25PZmZzZXRGcm9tU2Nyb2xsVG9wIC0gc2Nyb2xsQnVmZmVyICsgaGFsZk9wdGlvbkhlaWdodDtcbiAgICAgICAgcmV0dXJuIGNsYW1wVmFsdWUoMCwgb3B0aW1hbFNjcm9sbFBvc2l0aW9uLCBtYXhTY3JvbGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmlndXJlcyBvdXQgdGhlIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiBzdGF0ZSBmb3IgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9nZXRQbGFjZWhvbGRlckFuaW1hdGlvblN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5mbG9hdFBsYWNlaG9sZGVyID09PSAnbmV2ZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmxvYXRQbGFjZWhvbGRlciA9PT0gJ2Fsd2F5cycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXJTdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIENTUyBgb3BhY2l0eWAgb2YgdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2dldFBsYWNlaG9sZGVyT3BhY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsb2F0UGxhY2Vob2xkZXIgIT09ICduZXZlcicgfHwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpKSA/XG4gICAgICAgICAgICAnMScgOiAnMCc7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcIl9hcmlhTGFiZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgYXJpYS1sYWJlbCBvZiB0aGUgc2VsZWN0IGNvbXBvbmVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSWYgYW4gYXJpYUxhYmVsbGVkYnkgdmFsdWUgaGFzIGJlZW4gc2V0LCB0aGUgc2VsZWN0IHNob3VsZCBub3Qgb3ZlcndyaXRlIHRoZVxuICAgICAgICAgICAgLy8gYGFyaWEtbGFiZWxsZWRieWAgdmFsdWUgYnkgc2V0dGluZyB0aGUgYXJpYUxhYmVsIHRvIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyaWFMYWJlbGxlZGJ5ID8gbnVsbCA6IHRoaXMuYXJpYUxhYmVsIHx8IHRoaXMucGxhY2Vob2xkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHgtb2Zmc2V0IG9mIHRoZSBvdmVybGF5IHBhbmVsIGluIHJlbGF0aW9uIHRvIHRoZSB0cmlnZ2VyJ3MgdG9wIHN0YXJ0IGNvcm5lci5cbiAgICAgKiBUaGlzIG11c3QgYmUgYWRqdXN0ZWQgdG8gYWxpZ24gdGhlIHNlbGVjdGVkIG9wdGlvbiB0ZXh0IG92ZXIgdGhlIHRyaWdnZXIgdGV4dCB3aGVuXG4gICAgICogdGhlIHBhbmVsIG9wZW5zLiBXaWxsIGNoYW5nZSBiYXNlZCBvbiBMVFIgb3IgUlRMIHRleHQgZGlyZWN0aW9uLiBOb3RlIHRoYXQgdGhlIG9mZnNldFxuICAgICAqIGNhbid0IGJlIGNhbGN1bGF0ZWQgdW50aWwgdGhlIHBhbmVsIGhhcyBiZWVuIGF0dGFjaGVkLCBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyB0aGVcbiAgICAgKiBjb250ZW50IHdpZHRoIGluIG9yZGVyIHRvIGNvbnN0cmFpbiB0aGUgcGFuZWwgd2l0aGluIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2FsY3VsYXRlT3ZlcmxheU9mZnNldFggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlSZWN0ID0gdGhpcy5vdmVybGF5RGlyLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdwb3J0UmVjdCA9IHRoaXMuX3ZpZXdwb3J0UnVsZXIuZ2V0Vmlld3BvcnRSZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzUnRsID0gdGhpcy5faXNSdGwoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0WCA9IHRoaXMubXVsdGlwbGUgPyBTRUxFQ1RfTVVMVElQTEVfUEFORUxfUEFERElOR19YIDogU0VMRUNUX1BBTkVMX1BBRERJTkdfWDtcbiAgICAgICAgaWYgKCFpc1J0bCkge1xuICAgICAgICAgICAgb2Zmc2V0WCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWZ0T3ZlcmZsb3cgPSAwIC0gKG92ZXJsYXlSZWN0LmxlZnQgKyBvZmZzZXRYXG4gICAgICAgICAgICAtIChpc1J0bCA/IFNFTEVDVF9QQU5FTF9QQURESU5HX1ggKiAyIDogMCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaWdodE92ZXJmbG93ID0gb3ZlcmxheVJlY3QucmlnaHQgKyBvZmZzZXRYIC0gdmlld3BvcnRSZWN0LndpZHRoXG4gICAgICAgICAgICArIChpc1J0bCA/IDAgOiBTRUxFQ1RfUEFORUxfUEFERElOR19YICogMik7XG4gICAgICAgIGlmIChsZWZ0T3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICBvZmZzZXRYICs9IGxlZnRPdmVyZmxvdyArIFNFTEVDVF9QQU5FTF9WSUVXUE9SVF9QQURESU5HO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJpZ2h0T3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICBvZmZzZXRYIC09IHJpZ2h0T3ZlcmZsb3cgKyBTRUxFQ1RfUEFORUxfVklFV1BPUlRfUEFERElORztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIG9mZnNldCBkaXJlY3RseSBpbiBvcmRlciB0byBhdm9pZCBoYXZpbmcgdG8gZ28gdGhyb3VnaCBjaGFuZ2UgZGV0ZWN0aW9uIGFuZFxuICAgICAgICAvLyBwb3RlbnRpYWxseSB0cmlnZ2VyaW5nIFwiY2hhbmdlZCBhZnRlciBpdCB3YXMgY2hlY2tlZFwiIGVycm9ycy5cbiAgICAgICAgdGhpcy5vdmVybGF5RGlyLm9mZnNldFggPSBvZmZzZXRYO1xuICAgICAgICB0aGlzLm92ZXJsYXlEaXIub3ZlcmxheVJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgeS1vZmZzZXQgb2YgdGhlIHNlbGVjdCdzIG92ZXJsYXkgcGFuZWwgaW4gcmVsYXRpb24gdG8gdGhlXG4gICAgICogdG9wIHN0YXJ0IGNvcm5lciBvZiB0aGUgdHJpZ2dlci4gSXQgaGFzIHRvIGJlIGFkanVzdGVkIGluIG9yZGVyIGZvciB0aGVcbiAgICAgKiBzZWxlY3RlZCBvcHRpb24gdG8gYmUgYWxpZ25lZCBvdmVyIHRoZSB0cmlnZ2VyIHdoZW4gdGhlIHBhbmVsIG9wZW5zLlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0ZWRJbmRleFxuICAgICAqIEBwYXJhbSB7P30gc2Nyb2xsQnVmZmVyXG4gICAgICogQHBhcmFtIHs/fSBtYXhTY3JvbGxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2FsY3VsYXRlT3ZlcmxheU9mZnNldFkgPSBmdW5jdGlvbiAoc2VsZWN0ZWRJbmRleCwgc2Nyb2xsQnVmZmVyLCBtYXhTY3JvbGwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9uT2Zmc2V0RnJvbVBhbmVsVG9wO1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsVG9wID09PSAwKSB7XG4gICAgICAgICAgICBvcHRpb25PZmZzZXRGcm9tUGFuZWxUb3AgPSBzZWxlY3RlZEluZGV4ICogU0VMRUNUX09QVElPTl9IRUlHSFQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2Nyb2xsVG9wID09PSBtYXhTY3JvbGwpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpcnN0RGlzcGxheWVkSW5kZXggPSB0aGlzLm9wdGlvbnMubGVuZ3RoIC0gU0VMRUNUX01BWF9PUFRJT05TX0RJU1BMQVlFRDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdGVkRGlzcGxheUluZGV4ID0gc2VsZWN0ZWRJbmRleCAtIGZpcnN0RGlzcGxheWVkSW5kZXg7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBwYW5lbCBoZWlnaHQgaXMgbG9uZ2VyIHRoYW4gdGhlIGhlaWdodCBvZiB0aGUgb3B0aW9ucyBhbG9uZSxcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFsd2F5cyBleHRyYSBwYWRkaW5nIGF0IHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSBwYW5lbC4gV2hlblxuICAgICAgICAgICAgLy8gc2Nyb2xsZWQgdG8gdGhlIHZlcnkgYm90dG9tLCB0aGlzIHBhZGRpbmcgaXMgYXQgdGhlIHRvcCBvZiB0aGUgcGFuZWwgYW5kXG4gICAgICAgICAgICAvLyBtdXN0IGJlIGFkZGVkIHRvIHRoZSBvZmZzZXQuXG4gICAgICAgICAgICBvcHRpb25PZmZzZXRGcm9tUGFuZWxUb3AgPVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGlzcGxheUluZGV4ICogU0VMRUNUX09QVElPTl9IRUlHSFQgKyBTRUxFQ1RfUEFORUxfUEFERElOR19ZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9wdGlvbiB3YXMgc2Nyb2xsZWQgdG8gdGhlIG1pZGRsZSBvZiB0aGUgcGFuZWwgdXNpbmcgYSBzY3JvbGwgYnVmZmVyLFxuICAgICAgICAgICAgLy8gaXRzIG9mZnNldCB3aWxsIGJlIHRoZSBzY3JvbGwgYnVmZmVyIG1pbnVzIHRoZSBoYWxmIGhlaWdodCB0aGF0IHdhcyBhZGRlZCB0b1xuICAgICAgICAgICAgLy8gY2VudGVyIGl0LlxuICAgICAgICAgICAgb3B0aW9uT2Zmc2V0RnJvbVBhbmVsVG9wID0gc2Nyb2xsQnVmZmVyIC0gU0VMRUNUX09QVElPTl9IRUlHSFQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBmaW5hbCBvZmZzZXQgaXMgdGhlIG9wdGlvbidzIG9mZnNldCBmcm9tIHRoZSB0b3AsIGFkanVzdGVkIGZvciB0aGUgaGVpZ2h0XG4gICAgICAgIC8vIGRpZmZlcmVuY2UsIG11bHRpcGxpZWQgYnkgLTEgdG8gZW5zdXJlIHRoYXQgdGhlIG92ZXJsYXkgbW92ZXMgaW4gdGhlIGNvcnJlY3RcbiAgICAgICAgLy8gZGlyZWN0aW9uIHVwIHRoZSBwYWdlLlxuICAgICAgICByZXR1cm4gb3B0aW9uT2Zmc2V0RnJvbVBhbmVsVG9wICogLTEgLSBTRUxFQ1RfT1BUSU9OX0hFSUdIVF9BREpVU1RNRU5UO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoYXQgdGhlIGF0dGVtcHRlZCBvdmVybGF5IHBvc2l0aW9uIHdpbGwgZml0IHdpdGhpbiB0aGUgdmlld3BvcnQuXG4gICAgICogSWYgaXQgd2lsbCBub3QgZml0LCB0cmllcyB0byBhZGp1c3QgdGhlIHNjcm9sbCBwb3NpdGlvbiBhbmQgdGhlIGFzc29jaWF0ZWRcbiAgICAgKiB5LW9mZnNldCBzbyB0aGUgcGFuZWwgY2FuIG9wZW4gZnVsbHkgb24tc2NyZWVuLiBJZiBpdCBzdGlsbCB3b24ndCBmaXQsXG4gICAgICogc2V0cyB0aGUgb2Zmc2V0IGJhY2sgdG8gMCB0byBhbGxvdyB0aGUgZmFsbGJhY2sgcG9zaXRpb24gdG8gdGFrZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7P30gbWF4U2Nyb2xsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2NoZWNrT3ZlcmxheVdpdGhpblZpZXdwb3J0ID0gZnVuY3Rpb24gKG1heFNjcm9sbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3cG9ydFJlY3QgPSB0aGlzLl92aWV3cG9ydFJ1bGVyLmdldFZpZXdwb3J0UmVjdCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyUmVjdCA9IHRoaXMuX2dldFRyaWdnZXJSZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvcFNwYWNlQXZhaWxhYmxlID0gdHJpZ2dlclJlY3QudG9wIC0gU0VMRUNUX1BBTkVMX1ZJRVdQT1JUX1BBRERJTkc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdHRvbVNwYWNlQXZhaWxhYmxlID0gdmlld3BvcnRSZWN0LmhlaWdodCAtIHRyaWdnZXJSZWN0LmJvdHRvbSAtIFNFTEVDVF9QQU5FTF9WSUVXUE9SVF9QQURESU5HO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYW5lbEhlaWdodFRvcCA9IE1hdGguYWJzKHRoaXMuX29mZnNldFkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b3RhbFBhbmVsSGVpZ2h0ID0gTWF0aC5taW4odGhpcy5vcHRpb25zLmxlbmd0aCAqIFNFTEVDVF9PUFRJT05fSEVJR0hULCBTRUxFQ1RfUEFORUxfTUFYX0hFSUdIVCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhbmVsSGVpZ2h0Qm90dG9tID0gdG90YWxQYW5lbEhlaWdodCAtIHBhbmVsSGVpZ2h0VG9wIC0gdHJpZ2dlclJlY3QuaGVpZ2h0O1xuICAgICAgICBpZiAocGFuZWxIZWlnaHRCb3R0b20gPiBib3R0b21TcGFjZUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fYWRqdXN0UGFuZWxVcChwYW5lbEhlaWdodEJvdHRvbSwgYm90dG9tU3BhY2VBdmFpbGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhbmVsSGVpZ2h0VG9wID4gdG9wU3BhY2VBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkanVzdFBhbmVsRG93bihwYW5lbEhlaWdodFRvcCwgdG9wU3BhY2VBdmFpbGFibGUsIG1heFNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW5CYXNlZE9uT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIG92ZXJsYXkgcGFuZWwgdXAgdG8gZml0IGluIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gez99IHBhbmVsSGVpZ2h0Qm90dG9tXG4gICAgICogQHBhcmFtIHs/fSBib3R0b21TcGFjZUF2YWlsYWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9hZGp1c3RQYW5lbFVwID0gZnVuY3Rpb24gKHBhbmVsSGVpZ2h0Qm90dG9tLCBib3R0b21TcGFjZUF2YWlsYWJsZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXN0YW5jZUJlbG93Vmlld3BvcnQgPSBwYW5lbEhlaWdodEJvdHRvbSAtIGJvdHRvbVNwYWNlQXZhaWxhYmxlO1xuICAgICAgICAvLyBTY3JvbGxzIHRoZSBwYW5lbCB1cCBieSB0aGUgZGlzdGFuY2UgaXQgd2FzIGV4dGVuZGluZyBwYXN0IHRoZSBib3VuZGFyeSwgdGhlblxuICAgICAgICAvLyBhZGp1c3RzIHRoZSBvZmZzZXQgYnkgdGhhdCBhbW91bnQgdG8gbW92ZSB0aGUgcGFuZWwgdXAgaW50byB0aGUgdmlld3BvcnQuXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvcCAtPSBkaXN0YW5jZUJlbG93Vmlld3BvcnQ7XG4gICAgICAgIHRoaXMuX29mZnNldFkgLT0gZGlzdGFuY2VCZWxvd1ZpZXdwb3J0O1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW5CYXNlZE9uT3B0aW9uKCk7XG4gICAgICAgIC8vIElmIHRoZSBwYW5lbCBpcyBzY3JvbGxlZCB0byB0aGUgdmVyeSB0b3AsIGl0IHdvbid0IGJlIGFibGUgdG8gZml0IHRoZSBwYW5lbFxuICAgICAgICAvLyBieSBzY3JvbGxpbmcsIHNvIHNldCB0aGUgb2Zmc2V0IHRvIDAgdG8gYWxsb3cgdGhlIGZhbGxiYWNrIHBvc2l0aW9uIHRvIHRha2VcbiAgICAgICAgLy8gZWZmZWN0LlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsVG9wIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IFwiNTAlIGJvdHRvbSAwcHhcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgb3ZlcmxheSBwYW5lbCBkb3duIHRvIGZpdCBpbiB0aGUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIHs/fSBwYW5lbEhlaWdodFRvcFxuICAgICAqIEBwYXJhbSB7P30gdG9wU3BhY2VBdmFpbGFibGVcbiAgICAgKiBAcGFyYW0gez99IG1heFNjcm9sbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9hZGp1c3RQYW5lbERvd24gPSBmdW5jdGlvbiAocGFuZWxIZWlnaHRUb3AsIHRvcFNwYWNlQXZhaWxhYmxlLCBtYXhTY3JvbGwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlzdGFuY2VBYm92ZVZpZXdwb3J0ID0gcGFuZWxIZWlnaHRUb3AgLSB0b3BTcGFjZUF2YWlsYWJsZTtcbiAgICAgICAgLy8gU2Nyb2xscyB0aGUgcGFuZWwgZG93biBieSB0aGUgZGlzdGFuY2UgaXQgd2FzIGV4dGVuZGluZyBwYXN0IHRoZSBib3VuZGFyeSwgdGhlblxuICAgICAgICAvLyBhZGp1c3RzIHRoZSBvZmZzZXQgYnkgdGhhdCBhbW91bnQgdG8gbW92ZSB0aGUgcGFuZWwgZG93biBpbnRvIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9wICs9IGRpc3RhbmNlQWJvdmVWaWV3cG9ydDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WSArPSBkaXN0YW5jZUFib3ZlVmlld3BvcnQ7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbkJhc2VkT25PcHRpb24oKTtcbiAgICAgICAgLy8gSWYgdGhlIHBhbmVsIGlzIHNjcm9sbGVkIHRvIHRoZSB2ZXJ5IGJvdHRvbSwgaXQgd29uJ3QgYmUgYWJsZSB0byBmaXQgdGhlXG4gICAgICAgIC8vIHBhbmVsIGJ5IHNjcm9sbGluZywgc28gc2V0IHRoZSBvZmZzZXQgdG8gMCB0byBhbGxvdyB0aGUgZmFsbGJhY2sgcG9zaXRpb25cbiAgICAgICAgLy8gdG8gdGFrZSBlZmZlY3QuXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb3AgPSBtYXhTY3JvbGw7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IFwiNTAlIHRvcCAwcHhcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdHJhbnNmb3JtIG9yaWdpbiBwb2ludCBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgb3B0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9nZXRPcmlnaW5CYXNlZE9uT3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5ZID0gTWF0aC5hYnModGhpcy5fb2Zmc2V0WSkgLSBTRUxFQ1RfT1BUSU9OX0hFSUdIVF9BREpVU1RNRU5UICsgU0VMRUNUX09QVElPTl9IRUlHSFQgLyAyO1xuICAgICAgICByZXR1cm4gXCI1MCUgXCIgKyBvcmlnaW5ZICsgXCJweCAwcHhcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpZ3VyZXMgb3V0IHRoZSBmbG9hdGluZyBwbGFjZWhvbGRlciBzdGF0ZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZmxvYXRQbGFjZWhvbGRlclN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNSdGwoKSA/ICdmbG9hdGluZy1ydGwnIDogJ2Zsb2F0aW5nLWx0cic7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSB1c2VyIHByZXNzaW5nIHRoZSBhcnJvdyBrZXlzIG9uIGEgY2xvc2VkIHNlbGVjdC5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2hhbmRsZUFycm93S2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9tdWx0aXBsZSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldkFjdGl2ZUl0ZW0gPSB0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW07XG4gICAgICAgICAgICAvLyBDeWNsZSB0aG91Z2ggdGhlIHNlbGVjdCBvcHRpb25zIGV2ZW4gd2hlbiB0aGUgc2VsZWN0IGlzIGNsb3NlZCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgbmF0aXZlIHNlbGVjdCBlbGVtZW50LlxuICAgICAgICAgICAgLy8gVE9ETyhjcmlzYmV0byk6IG5hdGl2ZSBzZWxlY3RzIGFsc28gY3ljbGUgdGhyb3VnaCB0aGUgb3B0aW9ucyB3aXRoIGxlZnQvcmlnaHQgYXJyb3dzLFxuICAgICAgICAgICAgLy8gaG93ZXZlciB0aGUga2V5IG1hbmFnZXIgb25seSBzdXBwb3J0cyB1cC9kb3duIGF0IHRoZSBtb21lbnQuXG4gICAgICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50QWN0aXZlSXRlbSA9ICh0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRBY3RpdmVJdGVtICE9PSBwcmV2QWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uQnlWYWx1ZShjdXJyZW50QWN0aXZlSXRlbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWRTZWxlY3Q7XG59KCkpO1xuTWRTZWxlY3QuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1zZWxlY3QsIG1hdC1zZWxlY3QnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1zZWxlY3QtdHJpZ2dlclxcXCIgY2RrLW92ZXJsYXktb3JpZ2luIChjbGljayk9XFxcInRvZ2dsZSgpXFxcIiAjb3JpZ2luPVxcXCJjZGtPdmVybGF5T3JpZ2luXFxcIiAjdHJpZ2dlcj4gPHNwYW4gY2xhc3M9XFxcIm1hdC1zZWxlY3QtcGxhY2Vob2xkZXJcXFwiIFtjbGFzcy5tYXQtZmxvYXRpbmctcGxhY2Vob2xkZXJdPVxcXCJfc2VsZWN0aW9uTW9kZWwuaGFzVmFsdWUoKVxcXCIgW0B0cmFuc2Zvcm1QbGFjZWhvbGRlcl09XFxcIl9nZXRQbGFjZWhvbGRlckFuaW1hdGlvblN0YXRlKClcXFwiIFtzdHlsZS5vcGFjaXR5XT1cXFwiX2dldFBsYWNlaG9sZGVyT3BhY2l0eSgpXFxcIiBbc3R5bGUud2lkdGgucHhdPVxcXCJfc2VsZWN0ZWRWYWx1ZVdpZHRoXFxcIj4ge3sgcGxhY2Vob2xkZXIgfX0gPC9zcGFuPiA8c3BhbiBjbGFzcz1cXFwibWF0LXNlbGVjdC12YWx1ZVxcXCIgKm5nSWY9XFxcIl9zZWxlY3Rpb25Nb2RlbC5oYXNWYWx1ZSgpXFxcIj4gPHNwYW4gY2xhc3M9XFxcIm1hdC1zZWxlY3QtdmFsdWUtdGV4dFxcXCI+e3sgdHJpZ2dlclZhbHVlIH19PC9zcGFuPiA8L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJtYXQtc2VsZWN0LWFycm93XFxcIj48L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJtYXQtc2VsZWN0LXVuZGVybGluZVxcXCI+PC9zcGFuPiA8L2Rpdj4gPG5nLXRlbXBsYXRlIGNkay1jb25uZWN0ZWQtb3ZlcmxheSBbb3JpZ2luXT1cXFwib3JpZ2luXFxcIiBbb3Blbl09XFxcInBhbmVsT3BlblxcXCIgaGFzQmFja2Ryb3AgKGJhY2tkcm9wQ2xpY2spPVxcXCJjbG9zZSgpXFxcIiBiYWNrZHJvcENsYXNzPVxcXCJjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcFxcXCIgW3Bvc2l0aW9uc109XFxcIl9wb3NpdGlvbnNcXFwiIFttaW5XaWR0aF09XFxcIl90cmlnZ2VyV2lkdGhcXFwiIFtvZmZzZXRZXT1cXFwiX29mZnNldFlcXFwiIChhdHRhY2gpPVxcXCJfb25BdHRhY2hlZCgpXFxcIiAoZGV0YWNoKT1cXFwiY2xvc2UoKVxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1zZWxlY3QtcGFuZWxcXFwiIFtAdHJhbnNmb3JtUGFuZWxdPVxcXCInc2hvd2luZydcXFwiIChAdHJhbnNmb3JtUGFuZWwuZG9uZSk9XFxcIl9vblBhbmVsRG9uZSgpXFxcIiAoa2V5ZG93bik9XFxcIl9oYW5kbGVQYW5lbEtleWRvd24oJGV2ZW50KVxcXCIgW3N0eWxlLnRyYW5zZm9ybU9yaWdpbl09XFxcIl90cmFuc2Zvcm1PcmlnaW5cXFwiIFtjbGFzcy5tYXQtc2VsZWN0LXBhbmVsLWRvbmUtYW5pbWF0aW5nXT1cXFwiX3BhbmVsRG9uZUFuaW1hdGluZ1xcXCIgW25nQ2xhc3NdPVxcXCInbWF0LScgKyBjb2xvclxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1zZWxlY3QtY29udGVudFxcXCIgW0BmYWRlSW5Db250ZW50XT1cXFwiJ3Nob3dpbmcnXFxcIiAoQGZhZGVJbkNvbnRlbnQuZG9uZSk9XFxcIl9vbkZhZGVJbkRvbmUoKVxcXCI+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9kaXY+IDwvZGl2PiA8L25nLXRlbXBsYXRlPiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtc2VsZWN0e2Rpc3BsYXk6aW5saW5lLWJsb2NrO291dGxpbmU6MDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmfS5tYXQtc2VsZWN0LXRyaWdnZXJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtoZWlnaHQ6MzBweDttaW4td2lkdGg6MTEycHg7Y3Vyc29yOnBvaW50ZXI7cG9zaXRpb246cmVsYXRpdmU7Ym94LXNpemluZzpib3JkZXItYm94O2ZvbnQtc2l6ZToxNnB4fVthcmlhLWRpc2FibGVkPXRydWVdIC5tYXQtc2VsZWN0LXRyaWdnZXJ7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2N1cnNvcjpkZWZhdWx0fS5tYXQtc2VsZWN0LXVuZGVybGluZXtwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtsZWZ0OjA7cmlnaHQ6MDtoZWlnaHQ6MXB4fVthcmlhLWRpc2FibGVkPXRydWVdIC5tYXQtc2VsZWN0LXVuZGVybGluZXtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byByaWdodCxyZ2JhKDAsMCwwLC4yNikgMCxyZ2JhKDAsMCwwLC4yNikgMzMlLHRyYW5zcGFyZW50IDApO2JhY2tncm91bmQtc2l6ZTo0cHggMXB4O2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7YmFja2dyb3VuZC1wb3NpdGlvbjowIGJvdHRvbX0ubWF0LXNlbGVjdC1wbGFjZWhvbGRlcntwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjAgMnB4O3RyYW5zZm9ybS1vcmlnaW46bGVmdCB0b3A7ZmxleC1ncm93OjF9Lm1hdC1zZWxlY3QtcGxhY2Vob2xkZXIubWF0LWZsb2F0aW5nLXBsYWNlaG9sZGVye3RvcDotMjJweDtsZWZ0Oi0ycHg7dGV4dC1hbGlnbjpsZWZ0O3RyYW5zZm9ybTpzY2FsZSguNzUpfVtkaXI9cnRsXSAubWF0LXNlbGVjdC1wbGFjZWhvbGRlcnt0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0IHRvcH1bZGlyPXJ0bF0gLm1hdC1zZWxlY3QtcGxhY2Vob2xkZXIubWF0LWZsb2F0aW5nLXBsYWNlaG9sZGVye2xlZnQ6MnB4O3RleHQtYWxpZ246cmlnaHR9W2FyaWEtcmVxdWlyZWQ9dHJ1ZV0gLm1hdC1zZWxlY3QtcGxhY2Vob2xkZXI6OmFmdGVye2NvbnRlbnQ6JyonfS5tYXQtc2VsZWN0LXZhbHVle3Bvc2l0aW9uOmFic29sdXRlO21heC13aWR0aDpjYWxjKDEwMCUgLSAxOHB4KTtmbGV4LWdyb3c6MTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcn1bZGlyPXJ0bF0gLm1hdC1zZWxlY3QtdmFsdWV7bGVmdDphdXRvO3JpZ2h0OjB9Lm1hdC1zZWxlY3QtdmFsdWUtdGV4dHt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7bGluZS1oZWlnaHQ6MzBweH0ubWF0LXNlbGVjdC1hcnJvd3t3aWR0aDowO2hlaWdodDowO2JvcmRlci1sZWZ0OjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci10b3A6NXB4IHNvbGlkO21hcmdpbjowIDRweH0ubWF0LXNlbGVjdC1wYW5lbHtib3gtc2hhZG93OjAgNXB4IDVweCAtM3B4IHJnYmEoMCwwLDAsLjIpLDAgOHB4IDEwcHggMXB4IHJnYmEoMCwwLDAsLjE0KSwwIDNweCAxNHB4IDJweCByZ2JhKDAsMCwwLC4xMik7bWluLXdpZHRoOjExMnB4O21heC13aWR0aDoyODBweDtvdmVyZmxvdzphdXRvOy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MDttYXgtaGVpZ2h0OjI1NnB4O21pbi13aWR0aDoxMDAlfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtc2VsZWN0LXBhbmVse291dGxpbmU6c29saWQgMXB4fX0gLyojIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0LmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdsaXN0Ym94JyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLnRhYmluZGV4XSc6ICd0YWJJbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdfYXJpYUxhYmVsJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtbGFiZWxsZWRieV0nOiAnYXJpYUxhYmVsbGVkYnknLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1yZXF1aXJlZF0nOiAncmVxdWlyZWQudG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdkaXNhYmxlZC50b1N0cmluZygpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtaW52YWxpZF0nOiAnX2NvbnRyb2w/LmludmFsaWQgfHwgXCJmYWxzZVwiJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtb3duc10nOiAnX29wdGlvbklkcycsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNlbGVjdC1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zZWxlY3RdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVDbG9zZWRLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ19vbkJsdXIoKScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1QYW5lbCxcbiAgICAgICAgICAgICAgICAgICAgZmFkZUluQ29udGVudFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtZFNlbGVjdCcsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU2VsZWN0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IFZpZXdwb3J0UnVsZXIsIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICB7IHR5cGU6IERpciwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IFNlbGYgfSwgeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogQXR0cmlidXRlLCBhcmdzOiBbJ3RhYmluZGV4JyxdIH0sXSB9LFxuXTsgfTtcbk1kU2VsZWN0LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICd0cmlnZ2VyJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3RyaWdnZXInLF0gfSxdLFxuICAgICdvdmVybGF5RGlyJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSxdIH0sXSxcbiAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kT3B0aW9uLF0gfSxdLFxuICAgICdwbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3JlcXVpcmVkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtdWx0aXBsZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZmxvYXRQbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndGFiSW5kZXgnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2FyaWFMYWJlbCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2FyaWEtbGFiZWwnLF0gfSxdLFxuICAgICdhcmlhTGFiZWxsZWRieSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2FyaWEtbGFiZWxsZWRieScsXSB9LF0sXG4gICAgJ2NvbG9yJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdvbk9wZW4nOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdvbkNsb3NlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnY2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG4vKipcbiAqIENsYW1wcyBhIHZhbHVlIG4gYmV0d2VlbiBtaW4gYW5kIG1heCB2YWx1ZXMuXG4gKiBAcGFyYW0gez99IG1pblxuICogQHBhcmFtIHs/fSBuXG4gKiBAcGFyYW0gez99IG1heFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2xhbXBWYWx1ZShtaW4sIG4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIG4pLCBtYXgpO1xufVxudmFyIE1kU2VsZWN0TW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTZWxlY3RNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNlbGVjdE1vZHVsZTtcbn0oKSk7XG5NZFNlbGVjdE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kT3B0aW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZFNlbGVjdCwgTWRPcHRpb25Nb2R1bGUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNlbGVjdF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU2VsZWN0TW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTURfU0xJREVfVE9HR0xFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kU2xpZGVUb2dnbGU7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIE1kU2xpZGVUb2dnbGVDaGFuZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNsaWRlVG9nZ2xlQ2hhbmdlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRTbGlkZVRvZ2dsZUNoYW5nZTtcbn0oKSk7XG4vLyBJbmNyZWFzaW5nIGludGVnZXIgZm9yIGdlbmVyYXRpbmcgdW5pcXVlIGlkcyBmb3Igc2xpZGUtdG9nZ2xlIGNvbXBvbmVudHMuXG52YXIgbmV4dElkJDEgPSAwO1xudmFyIE1kU2xpZGVUb2dnbGVCYXNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZVRvZ2dsZUJhc2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNsaWRlVG9nZ2xlQmFzZTtcbn0oKSk7XG52YXIgX01kU2xpZGVUb2dnbGVNaXhpbkJhc2UgPSBtaXhpbkRpc2FibGVkKE1kU2xpZGVUb2dnbGVCYXNlKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHNsaWRhYmxlIFwic3dpdGNoXCIgdG9nZ2xlIHRoYXQgY2FuIGJlIG1vdmVkIGJldHdlZW4gb24gYW5kIG9mZi5cbiAqL1xudmFyIE1kU2xpZGVUb2dnbGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kU2xpZGVUb2dnbGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZm9jdXNPcmlnaW5Nb25pdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRTbGlkZVRvZ2dsZShfZWxlbWVudFJlZiwgX3JlbmRlcmVyLCBfZm9jdXNPcmlnaW5Nb25pdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIF90aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgX3RoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvciA9IF9mb2N1c09yaWdpbk1vbml0b3I7XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgX3RoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBfdGhpcy5fdW5pcXVlSWQgPSBcIm1kLXNsaWRlLXRvZ2dsZS1cIiArICsrbmV4dElkJDE7XG4gICAgICAgIF90aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9zbGlkZVJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3JlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9kaXNhYmxlUmlwcGxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIHZhbHVlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiBwcmVzZW50XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdW5pcXVlIGlkIGZvciB0aGUgc2xpZGUtdG9nZ2xlIGlucHV0LiBJZiBub25lIGlzIHN1cHBsaWVkLCBpdCB3aWxsIGJlIGF1dG8tZ2VuZXJhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaWQgPSBfdGhpcy5fdW5pcXVlSWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIHNwZWNpZnkgdGhlIHRhYkluZGV4IHZhbHVlIGZvciB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudGFiSW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbGFiZWwgc2hvdWxkIGFwcGVhciBhZnRlciBvciBiZWZvcmUgdGhlIHNsaWRlLXRvZ2dsZS4gRGVmYXVsdHMgdG8gJ2FmdGVyJ1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubGFiZWxQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIHNldCB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmFyaWFMYWJlbCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIHNldCB0aGUgYXJpYS1sYWJlbGxlZGJ5IGF0dHJpYnV0ZSBvbiB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYXJpYUxhYmVsbGVkYnkgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgd2lsbCBiZSBkaXNwYXRjaGVkIGVhY2ggdGltZSB0aGUgc2xpZGUtdG9nZ2xlIGNoYW5nZXMgaXRzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzbGlkZS10b2dnbGUgaXMgcmVxdWlyZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlcXVpcmVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fcmVxdWlyZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiZGlzYWJsZVJpcHBsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IGZvciB0aGlzIHNsaWRlLXRvZ2dsZSBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUgaWQgZm9yIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5pZCB8fCB0aGlzLl91bmlxdWVJZCkgKyBcIi1pbnB1dFwiOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc2xpZGVSZW5kZXJlciA9IG5ldyBTbGlkZVRvZ2dsZVJlbmRlcmVyKHRoaXMuX2VsZW1lbnRSZWYpO1xuICAgICAgICB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3JcbiAgICAgICAgICAgIC5tb25pdG9yKHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LCB0aGlzLl9yZW5kZXJlciwgZmFsc2UpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChmb2N1c09yaWdpbikgeyByZXR1cm4gX3RoaXMuX29uSW5wdXRGb2N1c0NoYW5nZShmb2N1c09yaWdpbik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLnN0b3BNb25pdG9yaW5nKHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBvbkNoYW5nZUV2ZW50IG1ldGhvZCB3aWxsIGJlIGFsc28gY2FsbGVkIG9uIGNsaWNrLlxuICAgICAqIFRoaXMgaXMgYmVjYXVzZSBldmVyeXRoaW5nIGZvciB0aGUgc2xpZGUtdG9nZ2xlIGlzIHdyYXBwZWQgaW5zaWRlIG9mIGEgbGFiZWwsXG4gICAgICogd2hpY2ggdHJpZ2dlcnMgYSBvbkNoYW5nZSBldmVudCBvbiBjbGljay5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fb25DaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBXZSBhbHdheXMgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIG9uIHRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgY2hhbmdlIGV2ZW50LCBmcm9tIHRoZSBpbnB1dCBlbGVtZW50LCB3aWxsIGJ1YmJsZSB1cCBhbmRcbiAgICAgICAgLy8gZW1pdCBpdHMgZXZlbnQgb2JqZWN0IHRvIHRoZSBjb21wb25lbnQncyBgY2hhbmdlYCBvdXRwdXQuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBPbmNlIGEgZHJhZyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MsIHdlIGRvIG5vdCB3YW50IHRvIHRvZ2dsZSB0aGUgc2xpZGUtdG9nZ2xlIG9uIGEgY2xpY2suXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhdGhpcy5fc2xpZGVSZW5kZXJlci5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgIC8vIEVtaXQgb3VyIGN1c3RvbSBjaGFuZ2UgZXZlbnQgaWYgdGhlIG5hdGl2ZSBpbnB1dCBlbWl0dGVkIG9uZS5cbiAgICAgICAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBvbmx5IGVtaXQgaXQsIGlmIHRoZSBuYXRpdmUgaW5wdXQgdHJpZ2dlcmVkIG9uZSwgYmVjYXVzZVxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCB3aGVuIHRoZSBgY2hlY2tlZGAgdmFyaWFibGUgY2hhbmdlcyBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fb25JbnB1dENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBmb3IgY2xpY2sgZXZlbnRzIG9uIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0IGVsZW1lbnQuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIGxhYmVsIGVsZW1lbnQsIGEgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZGlzcGF0Y2hlZCBvbiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBlbGVtZW50LiBTaW5jZSB3ZSBhcmUgdXNpbmcgYSBsYWJlbCBlbGVtZW50IGFzIG91clxuICAgICAgICAvLyByb290IGNvbnRhaW5lciwgdGhlIGNsaWNrIGV2ZW50IG9uIHRoZSBgc2xpZGUtdG9nZ2xlYCB3aWxsIGJlIGV4ZWN1dGVkIHR3aWNlLlxuICAgICAgICAvLyBUaGUgcmVhbCBjbGljayBldmVudCB3aWxsIGJ1YmJsZSB1cCwgYW5kIHRoZSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgYWxzbyB0cmllcyB0byBidWJibGUgdXAuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBsZWFkIHRvIG11bHRpcGxlIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgLy8gUHJldmVudGluZyBidWJibGluZyBmb3IgdGhlIHNlY29uZCBldmVudCB3aWxsIHNvbHZlIHRoYXQgaXNzdWUuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIGEgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIHNsaWRlLXRvZ2dsZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3IuZm9jdXNWaWEodGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHRoaXMuX3JlbmRlcmVyLCAna2V5Ym9hcmQnKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHNsaWRlLXRvZ2dsZSBpcyBjaGVja2VkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRoaXMuX2NoZWNrZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tlZCAhPT0gISF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMuX2NoZWNrZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIG9mIHRoZSBzbGlkZS10b2dnbGUuIENhbiBiZSBwcmltYXJ5LCBhY2NlbnQsIG9yIHdhcm4uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgY2hlY2tlZCBzdGF0ZSBvZiB0aGUgc2xpZGUtdG9nZ2xlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBmb2N1cyBjaGFuZ2VzIGZvciB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IGZvY3VzT3JpZ2luXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fb25JbnB1dEZvY3VzQ2hhbmdlID0gZnVuY3Rpb24gKGZvY3VzT3JpZ2luKSB7XG4gICAgICAgIGlmICghdGhpcy5fZm9jdXNSaXBwbGUgJiYgZm9jdXNPcmlnaW4gPT09ICdrZXlib2FyZCcpIHtcbiAgICAgICAgICAgIC8vIEZvciBrZXlib2FyZCBmb2N1cyBzaG93IGEgcGVyc2lzdGVudCByaXBwbGUgYXMgZm9jdXMgaW5kaWNhdG9yLlxuICAgICAgICAgICAgdGhpcy5fZm9jdXNSaXBwbGUgPSB0aGlzLl9yaXBwbGUubGF1bmNoKDAsIDAsIHsgcGVyc2lzdGVudDogdHJ1ZSwgY2VudGVyZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWZvY3VzT3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICAgICAgLy8gRmFkZSBvdXQgYW5kIGNsZWFyIHRoZSBmb2N1cyByaXBwbGUgaWYgb25lIGlzIGN1cnJlbnRseSBwcmVzZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzUmlwcGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNSaXBwbGUuZmFkZU91dCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUmlwcGxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuZXdDb2xvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX3VwZGF0ZUNvbG9yID0gZnVuY3Rpb24gKG5ld0NvbG9yKSB7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcih0aGlzLl9jb2xvciwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IobmV3Q29sb3IsIHRydWUpO1xuICAgICAgICB0aGlzLl9jb2xvciA9IG5ld0NvbG9yO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb2xvclxuICAgICAqIEBwYXJhbSB7P30gaXNBZGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9zZXRFbGVtZW50Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIGlzQWRkKSB7XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIGNvbG9yICE9ICcnKSB7XG4gICAgICAgICAgICBpZiAoaXNBZGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwibWF0LVwiICsgY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIGNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdHMgdGhlIGNoYW5nZSBldmVudCB0byB0aGUgYGNoYW5nZWAgb3V0cHV0IEV2ZW50RW1pdHRlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSBuZXcgTWRTbGlkZVRvZ2dsZUNoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC5jaGVja2VkID0gdGhpcy5jaGVja2VkO1xuICAgICAgICB0aGlzLmNoYW5nZS5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlUmVuZGVyZXIuc3RhcnRUaHVtYkRyYWcodGhpcy5jaGVja2VkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fc2xpZGVSZW5kZXJlci5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5fc2xpZGVSZW5kZXJlci51cGRhdGVUaHVtYlBvc2l0aW9uKGV2ZW50LmRlbHRhWCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3NsaWRlUmVuZGVyZXIuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIF9wcmV2aW91c0NoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XG4gICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSB0aGlzLl9zbGlkZVJlbmRlcmVyLmRyYWdQZXJjZW50YWdlID4gNTA7XG4gICAgICAgICAgICBpZiAoX3ByZXZpb3VzQ2hlY2tlZCAhPT0gdGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgZHJhZyBzaG91bGQgYmUgc3RvcHBlZCBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IGV2ZW50IGhhbmRsZXIsIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZVxuICAgICAgICAgICAgLy8gY2xpY2sgZXZlbnQgd2lsbCBiZSBmaXJlZCBiZWZvcmUgYW5kIHdpbGwgcmV2ZXJ0IHRoZSBkcmFnIGNoYW5nZS5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NsaWRlUmVuZGVyZXIuc3RvcFRodW1iRHJhZygpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kU2xpZGVUb2dnbGU7XG59KF9NZFNsaWRlVG9nZ2xlTWl4aW5CYXNlKSk7XG5NZFNsaWRlVG9nZ2xlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtc2xpZGUtdG9nZ2xlLCBtYXQtc2xpZGUtdG9nZ2xlJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlLXRvZ2dsZV0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoZWNrZWRdJzogJ2NoZWNrZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZS10b2dnbGUtbGFiZWwtYmVmb3JlXSc6ICdsYWJlbFBvc2l0aW9uID09IFwiYmVmb3JlXCInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGxhYmVsIGNsYXNzPVxcXCJtYXQtc2xpZGUtdG9nZ2xlLWxhYmVsXFxcIiAjbGFiZWw+IDxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZS10b2dnbGUtYmFyXFxcIj4gPGlucHV0ICNpbnB1dCBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS1pbnB1dCBjZGstdmlzdWFsbHktaGlkZGVuXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgW2lkXT1cXFwiaW5wdXRJZFxcXCIgW3JlcXVpcmVkXT1cXFwicmVxdWlyZWRcXFwiIFt0YWJJbmRleF09XFxcInRhYkluZGV4XFxcIiBbY2hlY2tlZF09XFxcImNoZWNrZWRcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcImFyaWFMYWJlbFxcXCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cXFwiYXJpYUxhYmVsbGVkYnlcXFwiIChjaGFuZ2UpPVxcXCJfb25DaGFuZ2VFdmVudCgkZXZlbnQpXFxcIiAoY2xpY2spPVxcXCJfb25JbnB1dENsaWNrKCRldmVudClcXFwiPiA8ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGUtdG9nZ2xlLXRodW1iLWNvbnRhaW5lclxcXCIgKHNsaWRlc3RhcnQpPVxcXCJfb25EcmFnU3RhcnQoKVxcXCIgKHNsaWRlKT1cXFwiX29uRHJhZygkZXZlbnQpXFxcIiAoc2xpZGVlbmQpPVxcXCJfb25EcmFnRW5kKClcXFwiPiA8ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGUtdG9nZ2xlLXRodW1iXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS1yaXBwbGVcXFwiIG1kLXJpcHBsZSBbbWRSaXBwbGVUcmlnZ2VyXT1cXFwibGFiZWxcXFwiIFttZFJpcHBsZUNlbnRlcmVkXT1cXFwidHJ1ZVxcXCIgW21kUmlwcGxlRGlzYWJsZWRdPVxcXCJkaXNhYmxlUmlwcGxlIHx8IGRpc2FibGVkXFxcIj4gPC9kaXY+IDwvZGl2PiA8L2Rpdj4gPHNwYW4gY2xhc3M9XFxcIm1hdC1zbGlkZS10b2dnbGUtY29udGVudFxcXCI+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9zcGFuPiA8L2xhYmVsPiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtc2xpZGUtdG9nZ2xle2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDoyNHB4O2xpbmUtaGVpZ2h0OjI0cHg7d2hpdGUtc3BhY2U6bm93cmFwOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtvdXRsaW5lOjB9Lm1hdC1zbGlkZS10b2dnbGUubWF0LWNoZWNrZWQgLm1hdC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVye3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgxNnB4LDAsMCl9Lm1hdC1zbGlkZS10b2dnbGUubWF0LWRpc2FibGVkIC5tYXQtc2xpZGUtdG9nZ2xlLWxhYmVsLC5tYXQtc2xpZGUtdG9nZ2xlLm1hdC1kaXNhYmxlZCAubWF0LXNsaWRlLXRvZ2dsZS10aHVtYi1jb250YWluZXJ7Y3Vyc29yOmRlZmF1bHR9Lm1hdC1zbGlkZS10b2dnbGUtY29udGVudHtmb250LXNpemU6MTRweDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjUwMH0ubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbHtkaXNwbGF5OmZsZXg7ZmxleDoxO2ZsZXgtZGlyZWN0aW9uOnJvdzthbGlnbi1pdGVtczpjZW50ZXI7Y3Vyc29yOnBvaW50ZXJ9Lm1hdC1zbGlkZS10b2dnbGUtbGFiZWwtYmVmb3JlIC5tYXQtc2xpZGUtdG9nZ2xlLWxhYmVse29yZGVyOjF9Lm1hdC1zbGlkZS10b2dnbGUtbGFiZWwtYmVmb3JlIC5tYXQtc2xpZGUtdG9nZ2xlLWJhcntvcmRlcjoyfS5tYXQtc2xpZGUtdG9nZ2xlLWJhcixbZGlyPXJ0bF0gLm1hdC1zbGlkZS10b2dnbGUtbGFiZWwtYmVmb3JlIC5tYXQtc2xpZGUtdG9nZ2xlLWJhcnttYXJnaW4tcmlnaHQ6OHB4O21hcmdpbi1sZWZ0OjB9Lm1hdC1zbGlkZS10b2dnbGUtbGFiZWwtYmVmb3JlIC5tYXQtc2xpZGUtdG9nZ2xlLWJhcixbZGlyPXJ0bF0gLm1hdC1zbGlkZS10b2dnbGUtYmFye21hcmdpbi1sZWZ0OjhweDttYXJnaW4tcmlnaHQ6MH0ubWF0LXNsaWRlLXRvZ2dsZS10aHVtYi1jb250YWluZXJ7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7dG9wOi0zcHg7bGVmdDowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNpdGlvbjphbGwgODBtcyBsaW5lYXI7dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm07Y3Vyc29yOi13ZWJraXQtZ3JhYjtjdXJzb3I6Z3JhYn0ubWF0LXNsaWRlLXRvZ2dsZS10aHVtYi1jb250YWluZXIubWF0LWRyYWdnaW5nLC5tYXQtc2xpZGUtdG9nZ2xlLXRodW1iLWNvbnRhaW5lcjphY3RpdmV7Y3Vyc29yOi13ZWJraXQtZ3JhYmJpbmc7Y3Vyc29yOmdyYWJiaW5nO3RyYW5zaXRpb24tZHVyYXRpb246MHN9Lm1hdC1zbGlkZS10b2dnbGUtdGh1bWJ7aGVpZ2h0OjIwcHg7d2lkdGg6MjBweDtib3JkZXItcmFkaXVzOjUwJTtib3gtc2hhZG93OjAgMnB4IDFweCAtMXB4IHJnYmEoMCwwLDAsLjIpLDAgMXB4IDFweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCAzcHggMCByZ2JhKDAsMCwwLC4xMil9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC1zbGlkZS10b2dnbGUtdGh1bWJ7YmFja2dyb3VuZDojZmZmO2JvcmRlcjpzb2xpZCAxcHggIzAwMH19Lm1hdC1zbGlkZS10b2dnbGUtYmFye3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjM2cHg7aGVpZ2h0OjE0cHg7Ym9yZGVyLXJhZGl1czo4cHh9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC1zbGlkZS10b2dnbGUtYmFye2JhY2tncm91bmQ6I2ZmZn19Lm1hdC1zbGlkZS10b2dnbGUtaW5wdXR7Ym90dG9tOjA7bGVmdDoxMHB4fS5tYXQtc2xpZGUtdG9nZ2xlLWJhciwubWF0LXNsaWRlLXRvZ2dsZS10aHVtYnt0cmFuc2l0aW9uOmFsbCA4MG1zIGxpbmVhcjt0cmFuc2l0aW9uLXByb3BlcnR5OmJhY2tncm91bmQtY29sb3I7dHJhbnNpdGlvbi1kZWxheTo1MG1zfS5tYXQtc2xpZGUtdG9nZ2xlLXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTEzcHg7bGVmdDotMTNweDtoZWlnaHQ6NDZweDt3aWR0aDo0NnB4O2JvcmRlci1yYWRpdXM6NTAlO3otaW5kZXg6MTtwb2ludGVyLWV2ZW50czpub25lfSAvKiMgc291cmNlTWFwcGluZ1VSTD1zbGlkZS10b2dnbGUuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfU0xJREVfVE9HR0xFX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU2xpZGVUb2dnbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRm9jdXNPcmlnaW5Nb25pdG9yLCB9LFxuXTsgfTtcbk1kU2xpZGVUb2dnbGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2lkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd0YWJJbmRleCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbGFiZWxQb3NpdGlvbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnYXJpYUxhYmVsJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnYXJpYS1sYWJlbCcsXSB9LF0sXG4gICAgJ2FyaWFMYWJlbGxlZGJ5JzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnYXJpYS1sYWJlbGxlZGJ5JyxdIH0sXSxcbiAgICAncmVxdWlyZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2Rpc2FibGVSaXBwbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ19pbnB1dEVsZW1lbnQnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnaW5wdXQnLF0gfSxdLFxuICAgICdfcmlwcGxlJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbTWRSaXBwbGUsXSB9LF0sXG4gICAgJ2NoZWNrZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NvbG9yJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbi8qKlxuICogUmVuZGVyZXIgZm9yIHRoZSBTbGlkZSBUb2dnbGUgY29tcG9uZW50LCB3aGljaCBzZXBhcmF0ZXMgRE9NIG1vZGlmaWNhdGlvbiBpbiBpdHMgb3duIGNsYXNzXG4gKi9cbnZhciBTbGlkZVRvZ2dsZVJlbmRlcmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNsaWRlVG9nZ2xlUmVuZGVyZXIoX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdGh1bWIgaXMgY3VycmVudGx5IGJlaW5nIGRyYWdnZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RodW1iRWwgPSBfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYXQtc2xpZGUtdG9nZ2xlLXRodW1iLWNvbnRhaW5lcicpO1xuICAgICAgICB0aGlzLl90aHVtYkJhckVsID0gX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWF0LXNsaWRlLXRvZ2dsZS1iYXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGRyYWcgb2YgdGhlIHNsaWRlLXRvZ2dsZS5cbiAgICAgKiBAcGFyYW0gez99IGNoZWNrZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNsaWRlVG9nZ2xlUmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0VGh1bWJEcmFnID0gZnVuY3Rpb24gKGNoZWNrZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90aHVtYkJhcldpZHRoID0gdGhpcy5fdGh1bWJCYXJFbC5jbGllbnRXaWR0aCAtIHRoaXMuX3RodW1iRWwuY2xpZW50V2lkdGg7XG4gICAgICAgIHRoaXMuX3RodW1iRWwuY2xhc3NMaXN0LmFkZCgnbWF0LWRyYWdnaW5nJyk7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQ2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBjdXJyZW50IGRyYWcgYW5kIHJldHVybnMgdGhlIG5ldyBjaGVja2VkIHZhbHVlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2xpZGVUb2dnbGVSZW5kZXJlci5wcm90b3R5cGUuc3RvcFRodW1iRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90aHVtYkVsLmNsYXNzTGlzdC5yZW1vdmUoJ21hdC1kcmFnZ2luZycpO1xuICAgICAgICAvLyBSZXNldCB0aGUgdHJhbnNmb3JtIGJlY2F1c2UgdGhlIGNvbXBvbmVudCB3aWxsIHRha2UgY2FyZSBvZiB0aGUgdGh1bWIgcG9zaXRpb24gYWZ0ZXIgZHJhZy5cbiAgICAgICAgYXBwbHlDc3NUcmFuc2Zvcm0odGhpcy5fdGh1bWJFbCwgJycpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnUGVyY2VudGFnZSA+IDUwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdGh1bWIgY29udGFpbmVycyBwb3NpdGlvbiBmcm9tIHRoZSBzcGVjaWZpZWQgZGlzdGFuY2UuXG4gICAgICogQHBhcmFtIHs/fSBkaXN0YW5jZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2xpZGVUb2dnbGVSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlVGh1bWJQb3NpdGlvbiA9IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgICAgICB0aGlzLmRyYWdQZXJjZW50YWdlID0gdGhpcy5fZ2V0RHJhZ1BlcmNlbnRhZ2UoZGlzdGFuY2UpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG1vdmVkIGRpc3RhbmNlIGJhc2VkIG9uIHRoZSB0aHVtYiBiYXIgd2lkdGguXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRyYWdYID0gKHRoaXMuZHJhZ1BlcmNlbnRhZ2UgLyAxMDApICogdGhpcy5fdGh1bWJCYXJXaWR0aDtcbiAgICAgICAgYXBwbHlDc3NUcmFuc2Zvcm0odGhpcy5fdGh1bWJFbCwgXCJ0cmFuc2xhdGUzZChcIiArIGRyYWdYICsgXCJweCwgMCwgMClcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHBlcmNlbnRhZ2Ugb2YgdGh1bWIgZnJvbSB0aGUgbW92ZWQgZGlzdGFuY2UuIFBlcmNlbnRhZ2UgYXMgZnJhY3Rpb24gb2YgMTAwLlxuICAgICAqIEBwYXJhbSB7P30gZGlzdGFuY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNsaWRlVG9nZ2xlUmVuZGVyZXIucHJvdG90eXBlLl9nZXREcmFnUGVyY2VudGFnZSA9IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwZXJjZW50YWdlID0gKGRpc3RhbmNlIC8gdGhpcy5fdGh1bWJCYXJXaWR0aCkgKiAxMDA7XG4gICAgICAgIC8vIFdoZW4gdGhlIHRvZ2dsZSB3YXMgaW5pdGlhbGx5IGNoZWNrZWQsIHRoZW4gd2UgaGF2ZSB0byBzdGFydCB0aGUgZHJhZyBhdCB0aGUgZW5kLlxuICAgICAgICBpZiAodGhpcy5fcHJldmlvdXNDaGVja2VkKSB7XG4gICAgICAgICAgICBwZXJjZW50YWdlICs9IDEwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGVyY2VudGFnZSwgMTAwKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2xpZGVUb2dnbGVSZW5kZXJlcjtcbn0oKSk7XG52YXIgTWRTbGlkZVRvZ2dsZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2xpZGVUb2dnbGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNsaWRlVG9nZ2xlTW9kdWxlO1xufSgpKTtcbk1kU2xpZGVUb2dnbGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtGb3Jtc01vZHVsZSwgTWRSaXBwbGVNb2R1bGUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRTbGlkZVRvZ2dsZSwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kU2xpZGVUb2dnbGVdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBGT0NVU19PUklHSU5fTU9OSVRPUl9QUk9WSURFUixcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBIQU1NRVJfR0VTVFVSRV9DT05GSUcsIHVzZUNsYXNzOiBHZXN0dXJlQ29uZmlnIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNsaWRlVG9nZ2xlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFZpc3VhbGx5LCBhIDMwcHggc2VwYXJhdGlvbiBiZXR3ZWVuIHRpY2sgbWFya3MgbG9va3MgYmVzdC4gVGhpcyBpcyB2ZXJ5IHN1YmplY3RpdmUgYnV0IGl0IGlzXG4gKiB0aGUgZGVmYXVsdCBzZXBhcmF0aW9uIHdlIGNob3NlLlxuICovXG52YXIgTUlOX0FVVE9fVElDS19TRVBBUkFUSU9OID0gMzA7XG4vKipcbiAqIFRoZSB0aHVtYiBnYXAgc2l6ZSBmb3IgYSBkaXNhYmxlZCBzbGlkZXIuXG4gKi9cbnZhciBESVNBQkxFRF9USFVNQl9HQVAgPSA3O1xuLyoqXG4gKiBUaGUgdGh1bWIgZ2FwIHNpemUgZm9yIGEgbm9uLWFjdGl2ZSBzbGlkZXIgYXQgaXRzIG1pbmltdW0gdmFsdWUuXG4gKi9cbnZhciBNSU5fVkFMVUVfTk9OQUNUSVZFX1RIVU1CX0dBUCA9IDc7XG4vKipcbiAqIFRoZSB0aHVtYiBnYXAgc2l6ZSBmb3IgYW4gYWN0aXZlIHNsaWRlciBhdCBpdHMgbWluaW11bSB2YWx1ZS5cbiAqL1xudmFyIE1JTl9WQUxVRV9BQ1RJVkVfVEhVTUJfR0FQID0gMTA7XG4vKipcbiAqIFByb3ZpZGVyIEV4cHJlc3Npb24gdGhhdCBhbGxvd3MgbWQtc2xpZGVyIHRvIHJlZ2lzdGVyIGFzIGEgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gKiBUaGlzIGFsbG93cyBpdCB0byBzdXBwb3J0IFsobmdNb2RlbCldIGFuZCBbZm9ybUNvbnRyb2xdLlxuICovXG52YXIgTURfU0xJREVSX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kU2xpZGVyOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogQSBzaW1wbGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgYnkgdGhlIE1kU2xpZGVyIGNvbXBvbmVudC5cbiAqL1xudmFyIE1kU2xpZGVyQ2hhbmdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZXJDaGFuZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNsaWRlckNoYW5nZTtcbn0oKSk7XG52YXIgTWRTbGlkZXJCYXNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZXJCYXNlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRTbGlkZXJCYXNlO1xufSgpKTtcbnZhciBfTWRTbGlkZXJNaXhpbkJhc2UgPSBtaXhpbkRpc2FibGVkKE1kU2xpZGVyQmFzZSk7XG4vKipcbiAqIEFsbG93cyB1c2VycyB0byBzZWxlY3QgZnJvbSBhIHJhbmdlIG9mIHZhbHVlcyBieSBtb3ZpbmcgdGhlIHNsaWRlciB0aHVtYi4gSXQgaXMgc2ltaWxhciBpblxuICogYmVoYXZpb3IgdG8gdGhlIG5hdGl2ZSBgPGlucHV0IHR5cGU9XCJyYW5nZVwiPmAgZWxlbWVudC5cbiAqL1xudmFyIE1kU2xpZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFNsaWRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX2ZvY3VzT3JpZ2luTW9uaXRvclxuICAgICAqIEBwYXJhbSB7P30gX2RpclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kU2xpZGVyKHJlbmRlcmVyLCBfZWxlbWVudFJlZiwgX2ZvY3VzT3JpZ2luTW9uaXRvciwgX2Rpcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICBfdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yID0gX2ZvY3VzT3JpZ2luTW9uaXRvcjtcbiAgICAgICAgX3RoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIF90aGlzLl9pbnZlcnQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX21heCA9IDEwMDtcbiAgICAgICAgX3RoaXMuX21pbiA9IDA7XG4gICAgICAgIF90aGlzLl9zdGVwID0gMTtcbiAgICAgICAgX3RoaXMuX3RodW1iTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3RpY2tJbnRlcnZhbCA9IDA7XG4gICAgICAgIF90aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIF90aGlzLl92ZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5jb2xvciA9ICdhY2NlbnQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzbGlkZXIgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNsaWRlciB0aHVtYiBtb3Zlcy5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmlucHV0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogb25Ub3VjaCBmdW5jdGlvbiByZWdpc3RlcmVkIHZpYSByZWdpc3Rlck9uVG91Y2ggKENvbnRyb2xWYWx1ZUFjY2Vzc29yKS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgX3RoaXMuX3BlcmNlbnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHRodW1iIGlzIHNsaWRpbmcuXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZXJlIHNob3VsZCBiZSBhIHRyYW5zaXRpb24gZm9yIHRoZSB0aHVtYiBhbmQgZmlsbCB0cmFjay5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzbGlkZXIgaXMgYWN0aXZlIChjbGlja2VkIG9yIHNsaWRpbmcpLlxuICAgICAgICAgKiBVc2VkIHRvIHNocmluayBhbmQgZ3JvdyB0aGUgdGh1bWIgYXMgYWNjb3JkaW5nIHRvIHRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYy5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpemUgb2YgYSB0aWNrIGludGVydmFsIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgc2l6ZSBvZiB0aGUgdHJhY2suXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdGlja0ludGVydmFsUGVyY2VudCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlbmRlcmVyIHRvIGhhbmRsZSB1cGRhdGluZyB0aGUgc2xpZGVyJ3MgdGh1bWIgYW5kIGZpbGwgdHJhY2suXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHNsaWRlci5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zbGlkZXJEaW1lbnNpb25zID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFzdCB2YWx1ZSBmb3Igd2hpY2ggYSBjaGFuZ2UgZXZlbnQgd2FzIGVtaXR0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fbGFzdENoYW5nZVZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IHZhbHVlIGZvciB3aGljaCBhbiBpbnB1dCBldmVudCB3YXMgZW1pdHRlZC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9sYXN0SW5wdXRWYWx1ZSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9mb2N1c09yaWdpbk1vbml0b3IubW9uaXRvcihfdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCByZW5kZXJlciwgdHJ1ZSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKG9yaWdpbikgeyByZXR1cm4gX3RoaXMuX2lzQWN0aXZlID0gISFvcmlnaW4gJiYgb3JpZ2luICE9PSAna2V5Ym9hcmQnOyB9KTtcbiAgICAgICAgX3RoaXMuX3JlbmRlcmVyID0gbmV3IFNsaWRlclJlbmRlcmVyKF90aGlzLl9lbGVtZW50UmVmKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcImludmVydFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzbGlkZXIgaXMgaW52ZXJ0ZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2ludmVydDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2ludmVydCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwibWF4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIHNsaWRlciBjYW4gaGF2ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fbWF4ID0gY29lcmNlTnVtYmVyUHJvcGVydHkodiwgdGhpcy5fbWF4KTtcbiAgICAgICAgICAgIHRoaXMuX3BlcmNlbnQgPSB0aGlzLl9jYWxjdWxhdGVQZXJjZW50YWdlKHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJtaW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gdmFsdWUgdGhhdCB0aGUgc2xpZGVyIGNhbiBoYXZlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWluO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9taW4gPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2LCB0aGlzLl9taW4pO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIHdhc24ndCBleHBsaWNpdGx5IHNldCBieSB0aGUgdXNlciwgc2V0IGl0IHRvIHRoZSBtaW4uXG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5fbWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGVyY2VudCA9IHRoaXMuX2NhbGN1bGF0ZVBlcmNlbnRhZ2UodGhpcy5fdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInN0ZXBcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlcyBhdCB3aGljaCB0aGUgdGh1bWIgd2lsbCBzbmFwLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGVwOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGVwID0gY29lcmNlTnVtYmVyUHJvcGVydHkodiwgdGhpcy5fc3RlcCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RlcCAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3VuZExhYmVsVG8gPSB0aGlzLl9zdGVwLnRvU3RyaW5nKCkuc3BsaXQoJy4nKS5wb3AoKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidGh1bWJMYWJlbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBzaG93IHRoZSB0aHVtYiBsYWJlbC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdGh1bWJMYWJlbDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3RodW1iTGFiZWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl90aHVtYkxhYmVsRGVwcmVjYXRlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90aHVtYkxhYmVsOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fdGh1bWJMYWJlbCA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInRpY2tJbnRlcnZhbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb3cgb2Z0ZW4gdG8gc2hvdyB0aWNrcy4gUmVsYXRpdmUgdG8gdGhlIHN0ZXAgc28gdGhhdCBhIHRpY2sgYWx3YXlzIGFwcGVhcnMgb24gYSBzdGVwLlxuICAgICAgICAgKiBFeDogVGljayBpbnRlcnZhbCBvZiA0IHdpdGggYSBzdGVwIG9mIDMgd2lsbCBkcmF3IGEgdGljayBldmVyeSA0IHN0ZXBzIChldmVyeSAxMiB2YWx1ZXMpLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90aWNrSW50ZXJ2YWw7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSAnYXV0byc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSwgLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5fdGlja0ludGVydmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl90aWNrSW50ZXJ2YWxEZXByZWNhdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGlja0ludGVydmFsOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMudGlja0ludGVydmFsID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZSBvZiB0aGUgc2xpZGVyLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgbmVlZHMgdG8gYmUgcmVhZCBhbmQgaXQgaXMgc3RpbGwgdW5pbml0aWFsaXplZCwgaW5pdGlhbGl6ZSBpdCB0byB0aGUgbWluLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX21pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2LCB0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9wZXJjZW50ID0gdGhpcy5fY2FsY3VsYXRlUGVyY2VudGFnZSh0aGlzLl92YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidmVydGljYWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgc2xpZGVyIGlzIHZlcnRpY2FsLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92ZXJ0aWNhbDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3ZlcnRpY2FsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJkaXNwbGF5VmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIHRvIGJlIHVzZWQgZm9yIGRpc3BsYXkgcHVycG9zZXMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGNvdWxkIGJlIGltcHJvdmVkIGZ1cnRoZXIgYnkgcm91bmRpbmcgc29tZXRoaW5nIGxpa2UgMC45OTkgdG8gMSBvclxuICAgICAgICAgICAgLy8gMC44OTkgdG8gMC45LCBob3dldmVyIGl0IGlzIHZlcnkgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLCBiZWNhdXNlIGl0IGdldHMgY2FsbGVkIG9uXG4gICAgICAgICAgICAvLyBldmVyeSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3JvdW5kTGFiZWxUbyAmJiB0aGlzLnZhbHVlICUgMSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvRml4ZWQodGhpcy5fcm91bmRMYWJlbFRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInBlcmNlbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHNsaWRlciB0aGF0IGNvaW5jaWRlcyB3aXRoIHRoZSB2YWx1ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2xhbXAodGhpcy5fcGVyY2VudCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX2ludmVydEF4aXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYXhpcyBvZiB0aGUgc2xpZGVyIGlzIGludmVydGVkLlxuICAgICAgICAgKiAoaS5lLiB3aGV0aGVyIG1vdmluZyB0aGUgdGh1bWIgaW4gdGhlIHBvc2l0aXZlIHggb3IgeSBkaXJlY3Rpb24gZGVjcmVhc2VzIHRoZSBzbGlkZXIncyB2YWx1ZSkuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFN0YW5kYXJkIG5vbi1pbnZlcnRlZCBtb2RlIGZvciBhIHZlcnRpY2FsIHNsaWRlciBzaG91bGQgYmUgZHJhZ2dpbmcgdGhlIHRodW1iIGZyb20gYm90dG9tIHRvXG4gICAgICAgICAgICAvLyB0b3AuIEhvd2V2ZXIgZnJvbSBhIHktYXhpcyBzdGFuZHBvaW50IHRoaXMgaXMgaW52ZXJ0ZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/ICF0aGlzLmludmVydCA6IHRoaXMuaW52ZXJ0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl9pc01pblZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHNsaWRlciBpcyBhdCBpdHMgbWluaW11bSB2YWx1ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyY2VudCA9PT0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJfdGh1bWJHYXBcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiBzcGFjZSB0byBsZWF2ZSBiZXR3ZWVuIHRoZSBzbGlkZXIgdGh1bWIgYW5kIHRoZSB0cmFjayBmaWxsICYgdHJhY2sgYmFja2dyb3VuZFxuICAgICAgICAgKiBlbGVtZW50cy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRElTQUJMRURfVEhVTUJfR0FQO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTWluVmFsdWUgJiYgIXRoaXMudGh1bWJMYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0FjdGl2ZSA/IE1JTl9WQUxVRV9BQ1RJVkVfVEhVTUJfR0FQIDogTUlOX1ZBTFVFX05PTkFDVElWRV9USFVNQl9HQVA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJfdHJhY2tCYWNrZ3JvdW5kU3R5bGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENTUyBzdHlsZXMgZm9yIHRoZSB0cmFjayBiYWNrZ3JvdW5kIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gJ1knIDogJ1gnO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbiA9IHRoaXMuX2ludmVydE1vdXNlQ29vcmRzID8gJy0nIDogJyc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBcInRyYW5zbGF0ZVwiICsgYXhpcyArIFwiKFwiICsgc2lnbiArIHRoaXMuX3RodW1iR2FwICsgXCJweCkgc2NhbGVcIiArIGF4aXMgKyBcIihcIiArICgxIC0gdGhpcy5wZXJjZW50KSArIFwiKVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl90cmFja0ZpbGxTdHlsZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIHN0eWxlcyBmb3IgdGhlIHRyYWNrIGZpbGwgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXhpcyA9IHRoaXMudmVydGljYWwgPyAnWScgOiAnWCc7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWduID0gdGhpcy5faW52ZXJ0TW91c2VDb29yZHMgPyAnJyA6ICctJztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IFwidHJhbnNsYXRlXCIgKyBheGlzICsgXCIoXCIgKyBzaWduICsgdGhpcy5fdGh1bWJHYXAgKyBcInB4KSBzY2FsZVwiICsgYXhpcyArIFwiKFwiICsgdGhpcy5wZXJjZW50ICsgXCIpXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX3RpY2tzQ29udGFpbmVyU3R5bGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENTUyBzdHlsZXMgZm9yIHRoZSB0aWNrcyBjb250YWluZXIgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXhpcyA9IHRoaXMudmVydGljYWwgPyAnWScgOiAnWCc7XG4gICAgICAgICAgICAvLyBGb3IgYSBob3Jpem9udGFsIHNsaWRlciBpbiBSVEwgbGFuZ3VhZ2VzIHdlIHB1c2ggdGhlIHRpY2tzIGNvbnRhaW5lciBvZmYgdGhlIGxlZnQgZWRnZVxuICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgcmlnaHQgZWRnZSB0byBhdm9pZCBjYXVzaW5nIGEgaG9yaXpvbnRhbCBzY3JvbGxiYXIgdG8gYXBwZWFyLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbiA9ICF0aGlzLnZlcnRpY2FsICYmIHRoaXMuX2RpcmVjdGlvbiA9PSAncnRsJyA/ICcnIDogJy0nO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gdGhpcy5fdGlja0ludGVydmFsUGVyY2VudCAvIDIgKiAxMDA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBcInRyYW5zbGF0ZVwiICsgYXhpcyArIFwiKFwiICsgc2lnbiArIG9mZnNldCArIFwiJSlcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJfdGlja3NTdHlsZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIHN0eWxlcyBmb3IgdGhlIHRpY2tzIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpY2tTaXplID0gdGhpcy5fdGlja0ludGVydmFsUGVyY2VudCAqIDEwMDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhY2tncm91bmRTaXplID0gdGhpcy52ZXJ0aWNhbCA/IFwiMnB4IFwiICsgdGlja1NpemUgKyBcIiVcIiA6IHRpY2tTaXplICsgXCIlIDJweFwiO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXhpcyA9IHRoaXMudmVydGljYWwgPyAnWScgOiAnWCc7XG4gICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiB3ZSBwdXNoZWQgdGhlIHRpY2tzIGNvbnRhaW5lciwgcHVzaCB0aGUgdGlja3MgdGhlIG9wcG9zaXRlXG4gICAgICAgICAgICAvLyBkaXJlY3Rpb24gdG8gcmUtY2VudGVyIHRoZW0gYnV0IGNsaXAgb2ZmIHRoZSBlbmQgZWRnZS4gSW4gUlRMIGxhbmd1YWdlcyB3ZSBuZWVkIHRvIGZsaXAgdGhlXG4gICAgICAgICAgICAvLyB0aWNrcyAxODAgZGVncmVlcyBzbyB3ZSdyZSByZWFsbHkgY3V0dGluZyBvZmYgdGhlIGVuZCBlZGdlIGFiZCBub3QgdGhlIHN0YXJ0LlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbiA9ICF0aGlzLnZlcnRpY2FsICYmIHRoaXMuX2RpcmVjdGlvbiA9PSAncnRsJyA/ICctJyA6ICcnO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm90YXRlID0gIXRoaXMudmVydGljYWwgJiYgdGhpcy5fZGlyZWN0aW9uID09ICdydGwnID8gJyByb3RhdGUoMTgwZGVnKScgOiAnJztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IHtcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZFNpemUnOiBiYWNrZ3JvdW5kU2l6ZSxcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IHRyYW5zbGF0ZVogdGlja3Mgc29tZXRpbWVzIGppdHRlciBhcyB0aGUgc2xpZGVyIG1vdmVzIG9uIENocm9tZSAmIEZpcmVmb3guXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IFwidHJhbnNsYXRlWigwKSB0cmFuc2xhdGVcIiArIGF4aXMgKyBcIihcIiArIHNpZ24gKyB0aWNrU2l6ZSAvIDIgKyBcIiUpXCIgKyByb3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5faXNNaW5WYWx1ZSAmJiB0aGlzLl90aHVtYkdhcCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNpZGUgPSB0aGlzLnZlcnRpY2FsID9cbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX2ludmVydEF4aXMgPyAnQm90dG9tJyA6ICdUb3AnKSA6XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9pbnZlcnRBeGlzID8gJ1JpZ2h0JyA6ICdMZWZ0Jyk7XG4gICAgICAgICAgICAgICAgc3R5bGVzW1wicGFkZGluZ1wiICsgc2lkZV0gPSB0aGlzLl90aHVtYkdhcCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX3RodW1iQ29udGFpbmVyU3R5bGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gJ1knIDogJ1gnO1xuICAgICAgICAgICAgLy8gRm9yIGEgaG9yaXpvbnRhbCBzbGlkZXIgaW4gUlRMIGxhbmd1YWdlcyB3ZSBwdXNoIHRoZSB0aHVtYiBjb250YWluZXIgb2ZmIHRoZSBsZWZ0IGVkZ2VcbiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgdGhlIHJpZ2h0IGVkZ2UgdG8gYXZvaWQgY2F1c2luZyBhIGhvcml6b250YWwgc2Nyb2xsYmFyIHRvIGFwcGVhci5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGludmVydE9mZnNldCA9ICh0aGlzLl9kaXJlY3Rpb24gPT0gJ3J0bCcgJiYgIXRoaXMudmVydGljYWwpID8gIXRoaXMuX2ludmVydEF4aXMgOiB0aGlzLl9pbnZlcnRBeGlzO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gKGludmVydE9mZnNldCA/IHRoaXMucGVyY2VudCA6IDEgLSB0aGlzLnBlcmNlbnQpICogMTAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogXCJ0cmFuc2xhdGVcIiArIGF4aXMgKyBcIigtXCIgKyBvZmZzZXQgKyBcIiUpXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX2ludmVydE1vdXNlQ29vcmRzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgbW91c2UgZXZlbnRzIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYSBzbGlkZXIgcG9zaXRpb24gYnkgY2FsY3VsYXRpbmcgdGhlaXIgZGlzdGFuY2VcbiAgICAgICAgICogZnJvbSB0aGUgcmlnaHQgb3IgYm90dG9tIGVkZ2Ugb2YgdGhlIHNsaWRlciBhcyBvcHBvc2VkIHRvIHRoZSB0b3Agb3IgbGVmdC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9kaXJlY3Rpb24gPT0gJ3J0bCcgJiYgIXRoaXMudmVydGljYWwpID8gIXRoaXMuX2ludmVydEF4aXMgOiB0aGlzLl9pbnZlcnRBeGlzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl9kaXJlY3Rpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhbmd1YWdlIGRpcmVjdGlvbiBmb3IgdGhpcyBzbGlkZXIgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09ICdydGwnKSA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3Iuc3RvcE1vbml0b3JpbmcodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vbk1vdXNlZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugc2F2ZSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgc2xpZGVyIGhlcmUgc28gd2UgY2FuIHVzZSB0aGVtIHRvIHVwZGF0ZSB0aGUgc3BhY2luZyBvZiB0aGVcbiAgICAgICAgLy8gdGlja3MgYW5kIGRldGVybWluZSB3aGVyZSBvbiB0aGUgc2xpZGVyIGNsaWNrIGFuZCBzbGlkZSBldmVudHMgaGFwcGVuLlxuICAgICAgICB0aGlzLl9zbGlkZXJEaW1lbnNpb25zID0gdGhpcy5fcmVuZGVyZXIuZ2V0U2xpZGVyRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLl91cGRhdGVUaWNrSW50ZXJ2YWxQZXJjZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkRm9jdXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWVGcm9tUG9zaXRpb24oeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuICAgICAgICAvKiBFbWl0cyBhIGNoYW5nZSBhbmQgaW5wdXQgZXZlbnQgaWYgdGhlIHZhbHVlIGNoYW5nZWQuICovXG4gICAgICAgIHRoaXMuX2VtaXRJbnB1dEV2ZW50KCk7XG4gICAgICAgIHRoaXMuX2VtaXRWYWx1ZUlmQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vblNsaWRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCB0aGUgc2xpZGUgZnJvbSBzZWxlY3RpbmcgYW55dGhpbmcgZWxzZS5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWVGcm9tUG9zaXRpb24oeyB4OiBldmVudC5jZW50ZXIueCwgeTogZXZlbnQuY2VudGVyLnkgfSk7XG4gICAgICAgIC8vIE5hdGl2ZSByYW5nZSBlbGVtZW50cyBhbHdheXMgZW1pdCBgaW5wdXRgIGV2ZW50cyB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VkIHdoaWxlIHNsaWRpbmcuXG4gICAgICAgIHRoaXMuX2VtaXRJbnB1dEV2ZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX29uU2xpZGVTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbXVsYXRlIG1vdXNlZW50ZXIgaW4gY2FzZSB0aGlzIGlzIGEgbW9iaWxlIGRldmljZS5cbiAgICAgICAgdGhpcy5fb25Nb3VzZWVudGVyKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZEZvY3VzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlRnJvbVBvc2l0aW9uKHsgeDogZXZlbnQuY2VudGVyLngsIHk6IGV2ZW50LmNlbnRlci55IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX29uU2xpZGVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbWl0VmFsdWVJZkNoYW5nZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vbkZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBzYXZlIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzbGlkZXIgaGVyZSBzbyB3ZSBjYW4gdXNlIHRoZW0gdG8gdXBkYXRlIHRoZSBzcGFjaW5nIG9mIHRoZVxuICAgICAgICAvLyB0aWNrcyBhbmQgZGV0ZXJtaW5lIHdoZXJlIG9uIHRoZSBzbGlkZXIgY2xpY2sgYW5kIHNsaWRlIGV2ZW50cyBoYXBwZW4uXG4gICAgICAgIHRoaXMuX3NsaWRlckRpbWVuc2lvbnMgPSB0aGlzLl9yZW5kZXJlci5nZXRTbGlkZXJEaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRpY2tJbnRlcnZhbFBlcmNlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX29uS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBQQUdFX1VQOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudCgxMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBBR0VfRE9XTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZW1lbnQoLTEwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRU5EOlxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm1heDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSE9NRTpcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5taW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgLy8gTk9URTogRm9yIGEgc2lnaHRlZCB1c2VyIGl0IHdvdWxkIG1ha2UgbW9yZSBzZW5zZSB0aGF0IHdoZW4gdGhleSBwcmVzcyBhbiBhcnJvdyBrZXkgb24gYW5cbiAgICAgICAgICAgICAgICAvLyBpbnZlcnRlZCBzbGlkZXIgdGhlIHRodW1iIG1vdmVzIGluIHRoYXQgZGlyZWN0aW9uLiBIb3dldmVyIGZvciBhIGJsaW5kIHVzZXIsIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAvLyBhYm91dCB0aGUgc2xpZGVyIGluZGljYXRlcyB0aGF0IGl0IGlzIGludmVydGVkLiBUaGV5IHdpbGwgZXhwZWN0IGxlZnQgdG8gYmUgZGVjcmVtZW50LFxuICAgICAgICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2YgaG93IGl0IGFwcGVhcnMgb24gdGhlIHNjcmVlbi4gRm9yIHNwZWFrZXJzIG9mUlRMIGxhbmd1YWdlcywgdGhleSBwcm9iYWJseVxuICAgICAgICAgICAgICAgIC8vIGV4cGVjdCBsZWZ0IHRvIG1lYW4gaW5jcmVtZW50LiBUaGVyZWZvcmUgd2UgZmxpcCB0aGUgbWVhbmluZyBvZiB0aGUgc2lkZSBhcnJvdyBrZXlzIGZvclxuICAgICAgICAgICAgICAgIC8vIFJUTC4gRm9yIGludmVydGVkIHNsaWRlcnMgd2UgcHJlZmVyIGEgZ29vZCBhMTF5IGV4cGVyaWVuY2UgdG8gaGF2aW5nIGl0IFwibG9vayByaWdodFwiIGZvclxuICAgICAgICAgICAgICAgIC8vIHNpZ2h0ZWQgdXNlcnMsIHRoZXJlZm9yZSB3ZSBkbyBub3Qgc3dhcCB0aGUgbWVhbmluZy5cbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZW1lbnQodGhpcy5fZGlyZWN0aW9uID09ICdydGwnID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgICAgICAgICAvLyBTZWUgY29tbWVudCBvbiBMRUZUX0FSUk9XIGFib3V0IHRoZSBjb25kaXRpb25zIHVuZGVyIHdoaWNoIHdlIGZsaXAgdGhlIG1lYW5pbmcuXG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KHRoaXMuX2RpcmVjdGlvbiA9PSAncnRsJyA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGlmIHRoZSBrZXkgaXMgbm90IG9uZSB0aGF0IHdlIGV4cGxpY2l0bHkgaGFuZGxlIHRvIGF2b2lkIGNhbGxpbmcgcHJldmVudERlZmF1bHQgb25cbiAgICAgICAgICAgICAgICAvLyBpdC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gdHJ1ZTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vbktleXVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluY3JlbWVudHMgdGhlIHNsaWRlciBieSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHN0ZXBzIChuZWdhdGl2ZSBudW1iZXIgZGVjcmVtZW50cykuXG4gICAgICogQHBhcmFtIHs/fSBudW1TdGVwc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9pbmNyZW1lbnQgPSBmdW5jdGlvbiAobnVtU3RlcHMpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2NsYW1wKHRoaXMudmFsdWUgKyB0aGlzLnN0ZXAgKiBudW1TdGVwcywgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICAgICAgdGhpcy5fZW1pdElucHV0RXZlbnQoKTtcbiAgICAgICAgdGhpcy5fZW1pdFZhbHVlSWZDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIG5ldyB2YWx1ZSBmcm9tIHRoZSBuZXcgcGh5c2ljYWwgbG9jYXRpb24uIFRoZSB2YWx1ZSB3aWxsIGFsd2F5cyBiZSBzbmFwcGVkLlxuICAgICAqIEBwYXJhbSB7P30gcG9zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlRnJvbVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICBpZiAoIXRoaXMuX3NsaWRlckRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXQgPSB0aGlzLnZlcnRpY2FsID8gdGhpcy5fc2xpZGVyRGltZW5zaW9ucy50b3AgOiB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLmxlZnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNpemUgPSB0aGlzLnZlcnRpY2FsID8gdGhpcy5fc2xpZGVyRGltZW5zaW9ucy5oZWlnaHQgOiB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLndpZHRoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3NDb21wb25lbnQgPSB0aGlzLnZlcnRpY2FsID8gcG9zLnkgOiBwb3MueDtcbiAgICAgICAgLy8gVGhlIGV4YWN0IHZhbHVlIGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZXZlbnQgYW5kIHVzZWQgdG8gZmluZCB0aGUgY2xvc2VzdCBzbmFwIHZhbHVlLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwZXJjZW50ID0gdGhpcy5fY2xhbXAoKHBvc0NvbXBvbmVudCAtIG9mZnNldCkgLyBzaXplKTtcbiAgICAgICAgaWYgKHRoaXMuX2ludmVydE1vdXNlQ29vcmRzKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMSAtIHBlcmNlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhhY3RWYWx1ZSA9IHRoaXMuX2NhbGN1bGF0ZVZhbHVlKHBlcmNlbnQpO1xuICAgICAgICAvLyBUaGlzIGNhbGN1bGF0aW9uIGZpbmRzIHRoZSBjbG9zZXN0IHN0ZXAgYnkgZmluZGluZyB0aGUgY2xvc2VzdCB3aG9sZSBudW1iZXIgZGl2aXNpYmxlIGJ5IHRoZVxuICAgICAgICAvLyBzdGVwIHJlbGF0aXZlIHRvIHRoZSBtaW4uXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsb3Nlc3RWYWx1ZSA9IE1hdGgucm91bmQoKGV4YWN0VmFsdWUgLSB0aGlzLm1pbikgLyB0aGlzLnN0ZXApICogdGhpcy5zdGVwICsgdGhpcy5taW47XG4gICAgICAgIC8vIFRoZSB2YWx1ZSBuZWVkcyB0byBzbmFwIHRvIHRoZSBtaW4gYW5kIG1heC5cbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2NsYW1wKGNsb3Nlc3RWYWx1ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgY2hhbmdlIGV2ZW50IGlmIHRoZSBjdXJyZW50IHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBsYXN0IGVtaXR0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX2VtaXRWYWx1ZUlmQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT0gdGhpcy5fbGFzdENoYW5nZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudCA9IHRoaXMuX2NyZWF0ZUNoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Q2hhbmdlVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBpbnB1dCBldmVudCB3aGVuIHRoZSBjdXJyZW50IHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBsYXN0IGVtaXR0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX2VtaXRJbnB1dEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPSB0aGlzLl9sYXN0SW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSB0aGlzLl9jcmVhdGVDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdElucHV0VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5lbWl0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYW1vdW50IG9mIHNwYWNlIGJldHdlZW4gdGlja3MgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSB3aWR0aCBvZiB0aGUgc2xpZGVyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl91cGRhdGVUaWNrSW50ZXJ2YWxQZXJjZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudGlja0ludGVydmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGlja0ludGVydmFsID09ICdhdXRvJykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhY2tTaXplID0gdGhpcy52ZXJ0aWNhbCA/IHRoaXMuX3NsaWRlckRpbWVuc2lvbnMuaGVpZ2h0IDogdGhpcy5fc2xpZGVyRGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpeGVsc1BlclN0ZXAgPSB0cmFja1NpemUgKiB0aGlzLnN0ZXAgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGVwc1BlclRpY2sgPSBNYXRoLmNlaWwoTUlOX0FVVE9fVElDS19TRVBBUkFUSU9OIC8gcGl4ZWxzUGVyU3RlcCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXhlbHNQZXJUaWNrID0gc3RlcHNQZXJUaWNrICogdGhpcy5zdGVwO1xuICAgICAgICAgICAgdGhpcy5fdGlja0ludGVydmFsUGVyY2VudCA9IHBpeGVsc1BlclRpY2sgLyB0cmFja1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWxQZXJjZW50ID0gdGhpcy50aWNrSW50ZXJ2YWwgKiB0aGlzLnN0ZXAgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGlkZXIgY2hhbmdlIG9iamVjdCBmcm9tIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHs/PX0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fY3JlYXRlQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB0aGlzLnZhbHVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV2ZW50ID0gbmV3IE1kU2xpZGVyQ2hhbmdlKCk7XG4gICAgICAgIGV2ZW50LnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIGV2ZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHNsaWRlciB0aGF0IGEgdmFsdWUgaXMuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9jYWxjdWxhdGVQZXJjZW50YWdlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB2YWx1ZSBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHNsaWRlciBjb3JyZXNwb25kcyB0by5cbiAgICAgKiBAcGFyYW0gez99IHBlcmNlbnRhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlVmFsdWUgPSBmdW5jdGlvbiAocGVyY2VudGFnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4gKyBwZXJjZW50YWdlICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbnVtYmVyIGJldHdlZW4gdHdvIG51bWJlcnMuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IG1pblxuICAgICAqIEBwYXJhbSB7Pz19IG1heFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9jbGFtcCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdm9pZCAwKSB7IG1pbiA9IDA7IH1cbiAgICAgICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW9kZWwgdmFsdWUuIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gZWIgdHJpZ2dlcmVkIHdoZW4gdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBmbiBDYWxsYmFjayB0byBiZSByZWdpc3RlcmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB0b3VjaGVkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBmbiBDYWxsYmFjayB0byBiZSByZWdpc3RlcmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gTWRTbGlkZXI7XG59KF9NZFNsaWRlck1peGluQmFzZSkpO1xuTWRTbGlkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1zbGlkZXIsIG1hdC1zbGlkZXInLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01EX1NMSURFUl9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnKGZvY3VzKSc6ICdfb25Gb2N1cygpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdfb25CbHVyKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdfb25DbGljaygkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duKSc6ICdfb25LZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgICAgICAnKGtleXVwKSc6ICdfb25LZXl1cCgpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhtb3VzZWVudGVyKSc6ICdfb25Nb3VzZWVudGVyKCknLFxuICAgICAgICAgICAgICAgICAgICAnKHNsaWRlKSc6ICdfb25TbGlkZSgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhzbGlkZWVuZCknOiAnX29uU2xpZGVFbmQoKScsXG4gICAgICAgICAgICAgICAgICAgICcoc2xpZGVzdGFydCknOiAnX29uU2xpZGVTdGFydCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1zbGlkZXInLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdzbGlkZXInLFxuICAgICAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbWF4XSc6ICdtYXgnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS12YWx1ZW1pbl0nOiAnbWluJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVub3ddJzogJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtb3JpZW50YXRpb25dJzogJ3ZlcnRpY2FsID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wcmltYXJ5XSc6ICdjb2xvciA9PSBcInByaW1hcnlcIicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWFjY2VudF0nOiAnY29sb3IgIT0gXCJwcmltYXJ5XCIgJiYgY29sb3IgIT0gXCJ3YXJuXCInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC13YXJuXSc6ICdjb2xvciA9PSBcIndhcm5cIicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItaGFzLXRpY2tzXSc6ICd0aWNrSW50ZXJ2YWwnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItaG9yaXpvbnRhbF0nOiAnIXZlcnRpY2FsJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGVyLWF4aXMtaW52ZXJ0ZWRdJzogJ19pbnZlcnRBeGlzJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGVyLXNsaWRpbmddJzogJ19pc1NsaWRpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZ10nOiAndGh1bWJMYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci12ZXJ0aWNhbF0nOiAndmVydGljYWwnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItbWluLXZhbHVlXSc6ICdfaXNNaW5WYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1oaWRlLWxhc3QtdGlja10nOiAnZGlzYWJsZWQgfHwgX2lzTWluVmFsdWUgJiYgX3RodW1iR2FwICYmIF9pbnZlcnRBeGlzJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItd3JhcHBlclxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItdHJhY2std3JhcHBlclxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZFxcXCIgW25nU3R5bGVdPVxcXCJfdHJhY2tCYWNrZ3JvdW5kU3R5bGVzXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10cmFjay1maWxsXFxcIiBbbmdTdHlsZV09XFxcIl90cmFja0ZpbGxTdHlsZXNcXFwiPjwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10aWNrcy1jb250YWluZXJcXFwiIFtuZ1N0eWxlXT1cXFwiX3RpY2tzQ29udGFpbmVyU3R5bGVzXFxcIj4gPGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10aWNrc1xcXCIgW25nU3R5bGVdPVxcXCJfdGlja3NTdHlsZXNcXFwiPjwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10aHVtYi1jb250YWluZXJcXFwiIFtuZ1N0eWxlXT1cXFwiX3RodW1iQ29udGFpbmVyU3R5bGVzXFxcIj4gPGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci1mb2N1cy1yaW5nXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10aHVtYlxcXCI+PC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItdGh1bWItbGFiZWxcXFwiPiA8c3BhbiBjbGFzcz1cXFwibWF0LXNsaWRlci10aHVtYi1sYWJlbC10ZXh0XFxcIj57e2Rpc3BsYXlWYWx1ZX19PC9zcGFuPiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtc2xpZGVye2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjhweDtvdXRsaW5lOjA7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tYXQtc2xpZGVyLXdyYXBwZXJ7cG9zaXRpb246YWJzb2x1dGV9Lm1hdC1zbGlkZXItdHJhY2std3JhcHBlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7b3ZlcmZsb3c6aGlkZGVufS5tYXQtc2xpZGVyLXRyYWNrLWZpbGx7cG9zaXRpb246YWJzb2x1dGU7dHJhbnNmb3JtLW9yaWdpbjowIDA7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJhY2tncm91bmQtY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmR7cG9zaXRpb246YWJzb2x1dGU7dHJhbnNmb3JtLW9yaWdpbjoxMDAlIDEwMCU7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJhY2tncm91bmQtY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2xpZGVyLXRpY2tzLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7b3ZlcmZsb3c6aGlkZGVufS5tYXQtc2xpZGVyLXRpY2tze2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdDtiYWNrZ3JvdW5kLWNsaXA6Y29udGVudC1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2xpZGVyLXRodW1iLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjE7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2xpZGVyLWZvY3VzLXJpbmd7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MzBweDtoZWlnaHQ6MzBweDtib3JkZXItcmFkaXVzOjUwJTt0cmFuc2Zvcm06c2NhbGUoMCk7b3BhY2l0eTowO3RyYW5zaXRpb246dHJhbnNmb3JtIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKSxiYWNrZ3JvdW5kLWNvbG9yIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKSxvcGFjaXR5IC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0uY2RrLWtleWJvYXJkLWZvY3VzZWQgLm1hdC1zbGlkZXItZm9jdXMtcmluZ3t0cmFuc2Zvcm06c2NhbGUoMSk7b3BhY2l0eToxfS5tYXQtc2xpZGVyOm5vdCgubWF0LXNsaWRlci1kaXNhYmxlZCkgLm1hdC1zbGlkZXItdGh1bWIsLm1hdC1zbGlkZXI6bm90KC5tYXQtc2xpZGVyLWRpc2FibGVkKSAubWF0LXNsaWRlci10aHVtYi1sYWJlbHtjdXJzb3I6LXdlYmtpdC1ncmFiO2N1cnNvcjpncmFifS5tYXQtc2xpZGVyLXNsaWRpbmc6bm90KC5tYXQtc2xpZGVyLWRpc2FibGVkKSAubWF0LXNsaWRlci10aHVtYiwubWF0LXNsaWRlci1zbGlkaW5nOm5vdCgubWF0LXNsaWRlci1kaXNhYmxlZCkgLm1hdC1zbGlkZXItdGh1bWItbGFiZWwsLm1hdC1zbGlkZXI6bm90KC5tYXQtc2xpZGVyLWRpc2FibGVkKSAubWF0LXNsaWRlci10aHVtYi1sYWJlbDphY3RpdmUsLm1hdC1zbGlkZXI6bm90KC5tYXQtc2xpZGVyLWRpc2FibGVkKSAubWF0LXNsaWRlci10aHVtYjphY3RpdmV7Y3Vyc29yOi13ZWJraXQtZ3JhYmJpbmc7Y3Vyc29yOmdyYWJiaW5nfS5tYXQtc2xpZGVyLXRodW1ie3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi0xMHB4O2JvdHRvbTotMTBweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtib3JkZXI6M3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6NTAlO3RyYW5zZm9ybTpzY2FsZSguNyk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJhY2tncm91bmQtY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJvcmRlci1jb2xvciAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItdGh1bWItbGFiZWx7ZGlzcGxheTpub25lO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHg7Ym9yZGVyLXJhZGl1czo1MCU7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJvcmRlci1yYWRpdXMgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJhY2tncm91bmQtY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHR7ei1pbmRleDoxO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjcwMDtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LXNsaWRlci1zbGlkaW5nIC5tYXQtc2xpZGVyLXRodW1iLWNvbnRhaW5lciwubWF0LXNsaWRlci1zbGlkaW5nIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmQsLm1hdC1zbGlkZXItc2xpZGluZyAubWF0LXNsaWRlci10cmFjay1maWxse3RyYW5zaXRpb24tZHVyYXRpb246MHN9Lm1hdC1zbGlkZXItaGFzLXRpY2tzIC5tYXQtc2xpZGVyLXdyYXBwZXI6OmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyLXdpZHRoOjA7Ym9yZGVyLXN0eWxlOnNvbGlkO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2xpZGVyLWhhcy10aWNrcy5jZGstZm9jdXNlZDpub3QoLm1hdC1zbGlkZXItaGlkZS1sYXN0LXRpY2spIC5tYXQtc2xpZGVyLXdyYXBwZXI6OmFmdGVyLC5tYXQtc2xpZGVyLWhhcy10aWNrczpob3Zlcjpub3QoLm1hdC1zbGlkZXItaGlkZS1sYXN0LXRpY2spIC5tYXQtc2xpZGVyLXdyYXBwZXI6OmFmdGVye29wYWNpdHk6MX0ubWF0LXNsaWRlci1oYXMtdGlja3MuY2RrLWZvY3VzZWQ6bm90KC5tYXQtc2xpZGVyLWRpc2FibGVkKSAubWF0LXNsaWRlci10aWNrcywubWF0LXNsaWRlci1oYXMtdGlja3M6aG92ZXI6bm90KC5tYXQtc2xpZGVyLWRpc2FibGVkKSAubWF0LXNsaWRlci10aWNrc3tvcGFjaXR5OjF9Lm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZyAubWF0LXNsaWRlci1mb2N1cy1yaW5ne3RyYW5zZm9ybTpzY2FsZSgwKTtvcGFjaXR5OjB9Lm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZyAubWF0LXNsaWRlci10aHVtYi1sYWJlbHtkaXNwbGF5OmZsZXh9Lm1hdC1zbGlkZXItYXhpcy1pbnZlcnRlZCAubWF0LXNsaWRlci10cmFjay1maWxse3RyYW5zZm9ybS1vcmlnaW46MTAwJSAxMDAlfS5tYXQtc2xpZGVyLWF4aXMtaW52ZXJ0ZWQgLm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZHt0cmFuc2Zvcm0tb3JpZ2luOjAgMH0uY2RrLWZvY3VzZWQubWF0LXNsaWRlci10aHVtYi1sYWJlbC1zaG93aW5nIC5tYXQtc2xpZGVyLXRodW1ie3RyYW5zZm9ybTpzY2FsZSgwKX0uY2RrLWZvY3VzZWQgLm1hdC1zbGlkZXItdGh1bWItbGFiZWx7Ym9yZGVyLXJhZGl1czo1MCUgNTAlIDB9LmNkay1mb2N1c2VkIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHR7b3BhY2l0eToxfS5jZGstbW91c2UtZm9jdXNlZCAubWF0LXNsaWRlci10aHVtYiwuY2RrLXByb2dyYW0tZm9jdXNlZCAubWF0LXNsaWRlci10aHVtYiwuY2RrLXRvdWNoLWZvY3VzZWQgLm1hdC1zbGlkZXItdGh1bWJ7Ym9yZGVyLXdpZHRoOjJweDt0cmFuc2Zvcm06c2NhbGUoMSl9Lm1hdC1zbGlkZXItZGlzYWJsZWQgLm1hdC1zbGlkZXItZm9jdXMtcmluZ3t0cmFuc2Zvcm06c2NhbGUoMCk7b3BhY2l0eTowfS5tYXQtc2xpZGVyLWRpc2FibGVkIC5tYXQtc2xpZGVyLXRodW1ie2JvcmRlci13aWR0aDo0cHg7dHJhbnNmb3JtOnNjYWxlKC41KX0ubWF0LXNsaWRlci1kaXNhYmxlZCAubWF0LXNsaWRlci10aHVtYi1sYWJlbHtkaXNwbGF5Om5vbmV9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbHtoZWlnaHQ6NDhweDttaW4td2lkdGg6MTI4cHh9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci13cmFwcGVye2hlaWdodDoycHg7dG9wOjIzcHg7bGVmdDo4cHg7cmlnaHQ6OHB4fS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItd3JhcHBlcjo6YWZ0ZXJ7aGVpZ2h0OjJweDtib3JkZXItbGVmdC13aWR0aDoycHg7cmlnaHQ6MDt0b3A6MH0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRyYWNrLXdyYXBwZXJ7aGVpZ2h0OjJweDt3aWR0aDoxMDAlfS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdHJhY2stZmlsbHtoZWlnaHQ6MnB4O3dpZHRoOjEwMCU7dHJhbnNmb3JtOnNjYWxlWCgwKX0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmR7aGVpZ2h0OjJweDt3aWR0aDoxMDAlO3RyYW5zZm9ybTpzY2FsZVgoMSl9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10aWNrcy1jb250YWluZXJ7aGVpZ2h0OjJweDt3aWR0aDoxMDAlfS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdGlja3N7aGVpZ2h0OjJweDt3aWR0aDoxMDAlfS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdGh1bWItY29udGFpbmVye3dpZHRoOjEwMCU7aGVpZ2h0OjA7dG9wOjUwJX0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLWZvY3VzLXJpbmd7dG9wOi0xNXB4O3JpZ2h0Oi0xNXB4fS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdGh1bWItbGFiZWx7cmlnaHQ6LTE0cHg7dG9wOi00MHB4O3RyYW5zZm9ybTp0cmFuc2xhdGVZKDI2cHgpIHNjYWxlKC4wMSkgcm90YXRlKDQ1ZGVnKX0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHR7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS5tYXQtc2xpZGVyLWhvcml6b250YWwuY2RrLWZvY3VzZWQgLm1hdC1zbGlkZXItdGh1bWItbGFiZWx7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9Lm1hdC1zbGlkZXItdmVydGljYWx7d2lkdGg6NDhweDttaW4taGVpZ2h0OjEyOHB4fS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXdyYXBwZXJ7d2lkdGg6MnB4O3RvcDo4cHg7Ym90dG9tOjhweDtsZWZ0OjIzcHh9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItd3JhcHBlcjo6YWZ0ZXJ7d2lkdGg6MnB4O2JvcmRlci10b3Atd2lkdGg6MnB4O2JvdHRvbTowO2xlZnQ6MH0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10cmFjay13cmFwcGVye2hlaWdodDoxMDAlO3dpZHRoOjJweH0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10cmFjay1maWxse2hlaWdodDoxMDAlO3dpZHRoOjJweDt0cmFuc2Zvcm06c2NhbGVZKDApfS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmR7aGVpZ2h0OjEwMCU7d2lkdGg6MnB4O3RyYW5zZm9ybTpzY2FsZVkoMSl9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdGlja3MtY29udGFpbmVye3dpZHRoOjJweDtoZWlnaHQ6MTAwJX0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci1mb2N1cy1yaW5ne2JvdHRvbTotMTVweDtsZWZ0Oi0xNXB4fS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXRpY2tze3dpZHRoOjJweDtoZWlnaHQ6MTAwJX0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10aHVtYi1jb250YWluZXJ7aGVpZ2h0OjEwMCU7d2lkdGg6MDtsZWZ0OjUwJX0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10aHVtYi1sYWJlbHtib3R0b206LTE0cHg7bGVmdDotNDBweDt0cmFuc2Zvcm06dHJhbnNsYXRlWCgyNnB4KSBzY2FsZSguMDEpIHJvdGF0ZSgtNDVkZWcpfS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHR7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9Lm1hdC1zbGlkZXItdmVydGljYWwuY2RrLWZvY3VzZWQgLm1hdC1zbGlkZXItdGh1bWItbGFiZWx7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfVtkaXI9cnRsXSAubWF0LXNsaWRlci13cmFwcGVyOjphZnRlcntsZWZ0OjA7cmlnaHQ6YXV0b31bZGlyPXJ0bF0gLm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10cmFjay1maWxse3RyYW5zZm9ybS1vcmlnaW46MTAwJSAxMDAlfVtkaXI9cnRsXSAubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmR7dHJhbnNmb3JtLW9yaWdpbjowIDB9W2Rpcj1ydGxdIC5tYXQtc2xpZGVyLWhvcml6b250YWwubWF0LXNsaWRlci1heGlzLWludmVydGVkIC5tYXQtc2xpZGVyLXRyYWNrLWZpbGx7dHJhbnNmb3JtLW9yaWdpbjowIDB9W2Rpcj1ydGxdIC5tYXQtc2xpZGVyLWhvcml6b250YWwubWF0LXNsaWRlci1heGlzLWludmVydGVkIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmR7dHJhbnNmb3JtLW9yaWdpbjoxMDAlIDEwMCV9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWRlci5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNsaWRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c09yaWdpbk1vbml0b3IsIH0sXG4gICAgeyB0eXBlOiBEaXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbk1kU2xpZGVyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdpbnZlcnQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ21heCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbWluJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzdGVwJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd0aHVtYkxhYmVsJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdfdGh1bWJMYWJlbERlcHJlY2F0ZWQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyd0aHVtYi1sYWJlbCcsXSB9LF0sXG4gICAgJ3RpY2tJbnRlcnZhbCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnX3RpY2tJbnRlcnZhbERlcHJlY2F0ZWQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyd0aWNrLWludGVydmFsJyxdIH0sXSxcbiAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3ZlcnRpY2FsJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnY2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnaW5wdXQnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxufTtcbi8qKlxuICogUmVuZGVyZXIgY2xhc3MgaW4gb3JkZXIgdG8ga2VlcCBhbGwgZG9tIG1hbmlwdWxhdGlvbiBpbiBvbmUgcGxhY2UgYW5kIG91dHNpZGUgb2YgdGhlIG1haW4gY2xhc3MuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFNsaWRlclJlbmRlcmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2xpZGVyUmVuZGVyZXIoZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9zbGlkZXJFbGVtZW50ID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIHRoZSBzbGlkZXIgdHJhY2sgZWxlbWVudC5cbiAgICAgKiBUaGUgdHJhY2sgaXMgdXNlZCByYXRoZXIgdGhhbiB0aGUgbmF0aXZlIGVsZW1lbnQgdG8gaWdub3JlIHRoZSBleHRyYSBzcGFjZSB0aGF0IHRoZSB0aHVtYiBjYW5cbiAgICAgKiB0YWtlIHVwLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2xpZGVyUmVuZGVyZXIucHJvdG90eXBlLmdldFNsaWRlckRpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdyYXBwZXJFbGVtZW50ID0gdGhpcy5fc2xpZGVyRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWF0LXNsaWRlci13cmFwcGVyJyk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIG5hdGl2ZSBlbGVtZW50LlxuICAgICAqIEN1cnJlbnRseSBvbmx5IHVzZWQgdG8gYWxsb3cgYSBibHVyIGV2ZW50IHRvIGZpcmUgYnV0IHdpbGwgYmUgdXNlZCB3aXRoIGtleWJvYXJkIGlucHV0IGxhdGVyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2xpZGVyUmVuZGVyZXIucHJvdG90eXBlLmFkZEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zbGlkZXJFbGVtZW50LmZvY3VzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2xpZGVyUmVuZGVyZXI7XG59KCkpO1xudmFyIE1kU2xpZGVyTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNsaWRlck1vZHVsZTtcbn0oKSk7XG5NZFNsaWRlck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRm9ybXNNb2R1bGUsIE1kQ29tbW9uTW9kdWxlLCBTdHlsZU1vZHVsZSwgUnRsTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRTbGlkZXIsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNsaWRlcl0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBIQU1NRVJfR0VTVFVSRV9DT05GSUcsIHVzZUNsYXNzOiBHZXN0dXJlQ29uZmlnIH1dXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU2xpZGVyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiB0d28gTWRTaWRlbmF2IGFyZSBtYXRjaGluZyB0aGUgc2FtZSBzaWRlLlxuICogQHBhcmFtIHs/fSBhbGlnblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGhyb3dNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IoYWxpZ24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHNpZGVuYXYgd2FzIGFscmVhZHkgZGVjbGFyZWQgZm9yICdhbGlnbj1cXFwiXCIgKyBhbGlnbiArIFwiXFxcIidcIik7XG59XG4vKipcbiAqIFNpZGVuYXYgdG9nZ2xlIHByb21pc2UgcmVzdWx0LlxuICovXG52YXIgTWRTaWRlbmF2VG9nZ2xlUmVzdWx0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25GaW5pc2hlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kU2lkZW5hdlRvZ2dsZVJlc3VsdCh0eXBlLCBhbmltYXRpb25GaW5pc2hlZCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkZpbmlzaGVkID0gYW5pbWF0aW9uRmluaXNoZWQ7XG4gICAgfVxuICAgIHJldHVybiBNZFNpZGVuYXZUb2dnbGVSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiA8bWQtc2lkZW5hdj4gY29tcG9uZW50LlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBkcmF3ZXIgb2YgdGhlIHNpZGVuYXYuXG4gKlxuICogUGxlYXNlIHJlZmVyIHRvIFJFQURNRS5tZCBmb3IgZXhhbXBsZXMgb24gaG93IHRvIHVzZSBpdC5cbiAqL1xudmFyIE1kU2lkZW5hdiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWYgVGhlIERPTSBlbGVtZW50IHJlZmVyZW5jZS4gVXNlZCBmb3IgdHJhbnNpdGlvbiBhbmQgd2lkdGggY2FsY3VsYXRpb24uXG4gICAgICogICAgIElmIG5vdCBhdmFpbGFibGUgd2UgZG8gbm90IGhvb2sgb24gdHJhbnNpdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSBfZm9jdXNUcmFwRmFjdG9yeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kU2lkZW5hdihfZWxlbWVudFJlZiwgX2ZvY3VzVHJhcEZhY3RvcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9mb2N1c1RyYXBGYWN0b3J5ID0gX2ZvY3VzVHJhcEZhY3Rvcnk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlnbm1lbnQgb2YgdGhlIHNpZGVuYXYgKGRpcmVjdGlvbiBuZXV0cmFsKTsgd2hldGhlciAnc3RhcnQnIG9yICdlbmQnLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZSBvZiB0aGUgc2lkZW5hdjsgb25lIG9mICdvdmVyJywgJ3B1c2gnIG9yICdzaWRlJy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW9kZSA9ICdvdmVyJztcbiAgICAgICAgdGhpcy5fZGlzYWJsZUNsb3NlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzaWRlbmF2IGlzIG9wZW5lZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29wZW5lZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzaWRlbmF2IGlzIGJlaW5nIG9wZW5lZC4gVXNlIHRoaXMgdG8gc3luY2hyb25pemUgYW5pbWF0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25PcGVuU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgaXMgZnVsbHkgb3BlbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbk9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgaXMgYmVpbmcgY2xvc2VkLiBVc2UgdGhpcyB0byBzeW5jaHJvbml6ZSBhbmltYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNsb3NlU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgaXMgZnVsbHkgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzaWRlbmF2IGFsaWdubWVudCBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkFsaWduQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHRvZ2dsZSBhbmltYXRpb24gcHJvbWlzZS4gYG51bGxgIGlmIG5vIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgdG9nZ2xlIGFuaW1hdGlvbiBwcm9taXNlIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAgICAgICAqIGBudWxsYCBpZiBubyBhbmltYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlU2lkZW5hdldhc09wZW5lZCA9IG51bGw7XG4gICAgICAgIHRoaXMub25PcGVuLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVTaWRlbmF2V2FzT3BlbmVkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0ZvY3VzVHJhcEVuYWJsZWQgJiYgX3RoaXMuX2ZvY3VzVHJhcCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9mb2N1c1RyYXAuZm9jdXNJbml0aWFsRWxlbWVudFdoZW5SZWFkeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkNsb3NlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlU2lkZW5hdldhc09wZW5lZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlU2lkZW5hdldhc09wZW5lZC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVTaWRlbmF2V2FzT3BlbmVkID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcImFsaWduXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpcmVjdGlvbiB3aGljaCB0aGUgc2lkZW5hdiBpcyBhbGlnbmVkIGluLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hbGlnbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHZhbGlkIHZhbHVlLlxuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgPT0gJ2VuZCcpID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IHRoaXMuX2FsaWduKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxpZ24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQWxpZ25DaGFuZ2VkLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiZGlzYWJsZUNsb3NlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHNpZGVuYXYgY2FuIGJlIGNsb3NlZCB3aXRoIHRoZSBlc2NhcGUga2V5IG9yIG5vdC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZUNsb3NlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZUNsb3NlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiaXNGb2N1c1RyYXBFbmFibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmb2N1cyB0cmFwIGlzIG9ubHkgZW5hYmxlZCB3aGVuIHRoZSBzaWRlbmF2IGlzIG9wZW4gaW4gYW55IG1vZGUgb3RoZXIgdGhhbiBzaWRlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbmVkICYmIHRoaXMubW9kZSAhPT0gJ3NpZGUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mb2N1c1RyYXAgPSB0aGlzLl9mb2N1c1RyYXBGYWN0b3J5LmNyZWF0ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9mb2N1c1RyYXAuZW5hYmxlZCA9IHRoaXMuaXNGb2N1c1RyYXBFbmFibGVkO1xuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgc2lkZW5hdiBpcyBzZXQgdG8gb3BlbmVkIGluXG4gICAgICAgIC8vIHRoZSB0ZW1wbGF0ZSBhbmQgdGhlIHRyYW5zaXRpb24gaGFzbid0IGVuZGVkLlxuICAgICAgICBpZiAodGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVRvZ2dsZUFuaW1hdGlvblByb21pc2UodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlID0gdGhpcy5fcmVzb2x2ZVRvZ2dsZUFuaW1hdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9mb2N1c1RyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIm9wZW5lZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzaWRlbmF2IGlzIG9wZW5lZC4gV2Ugb3ZlcmxvYWQgdGhpcyBiZWNhdXNlIHdlIHRyaWdnZXIgYW4gZXZlbnQgd2hlbiBpdFxuICAgICAgICAgKiBzdGFydHMgb3IgZW5kLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vcGVuZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE9wZW4gdGhpcyBzaWRlbmF2LCBhbmQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGl0J3MgZnVsbHkgb3BlbmVkIChvciBnZXRcbiAgICAgKiByZWplY3RlZCBpZiBpdCBkaWRuJ3QpLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2dnbGUodHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGlzIHNpZGVuYXYsIGFuZCByZXR1cm4gYSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gaXQncyBmdWxseSBjbG9zZWQgKG9yIGdldFxuICAgICAqIHJlamVjdGVkIGlmIGl0IGRpZG4ndCkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXYucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2dnbGUoZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoaXMgc2lkZW5hdi4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgb3BlbigpIHdoZW4gaXQncyBhbHJlYWR5IG9wZW5lZCwgb3JcbiAgICAgKiBjbG9zZSgpIHdoZW4gaXQncyBjbG9zZWQuXG4gICAgICogQHBhcmFtIHs/PX0gaXNPcGVuIFdoZXRoZXIgdGhlIHNpZGVuYXYgc2hvdWxkIGJlIG9wZW4uXG4gICAgICogQHJldHVybiB7P30gUmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHdoZXRoZXIgdGhlIHNpZGVuYXYgd2FzIG9wZW5lZCBvciBjbG9zZWQuXG4gICAgICovXG4gICAgTWRTaWRlbmF2LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoaXNPcGVuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpc09wZW4gPT09IHZvaWQgMCkgeyBpc09wZW4gPSAhdGhpcy5vcGVuZWQ7IH1cbiAgICAgICAgLy8gU2hvcnRjdXQgaXQgaWYgd2UncmUgYWxyZWFkeSBvcGVuZWQuXG4gICAgICAgIGlmIChpc09wZW4gPT09IHRoaXMub3BlbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSB8fFxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShuZXcgTWRTaWRlbmF2VG9nZ2xlUmVzdWx0KGlzT3BlbiA/ICdvcGVuJyA6ICdjbG9zZScsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcGVuZWQgPSBpc09wZW47XG4gICAgICAgIGlmICh0aGlzLl9mb2N1c1RyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcC5lbmFibGVkID0gdGhpcy5pc0ZvY3VzVHJhcEVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vbk9wZW5TdGFydC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VTdGFydC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IGZ1bmN0aW9uIChhbmltYXRpb25GaW5pc2hlZCkgeyByZXR1cm4gcmVzb2x2ZShuZXcgTWRTaWRlbmF2VG9nZ2xlUmVzdWx0KGlzT3BlbiA/ICdvcGVuJyA6ICdjbG9zZScsIGFuaW1hdGlvbkZpbmlzaGVkKSk7IH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGtleWJvYXJkIGV2ZW50cy5cbiAgICAgKiBcXEBkb2NzLXByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXYucHJvdG90eXBlLmhhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSAmJiAhdGhpcy5kaXNhYmxlQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRyYW5zaXRpb24gaGFzIGZpbmlzaGVkLCBzZXQgdGhlIGludGVybmFsIHN0YXRlIGZvciBjbGFzc2VzIGFuZCBlbWl0IHRoZSBwcm9wZXIgZXZlbnQuXG4gICAgICogVGhlIGV2ZW50IHBhc3NlZCBpcyBhY3R1YWxseSBvZiB0eXBlIFRyYW5zaXRpb25FdmVudCwgYnV0IHRoYXQgdHlwZSBpcyBub3QgYXZhaWxhYmxlIGluXG4gICAgICogQW5kcm9pZCBzbyB3ZSB1c2UgYW55LlxuICAgICAqIEBwYXJhbSB7P30gdHJhbnNpdGlvbkV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXYucHJvdG90eXBlLl9vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkV2ZW50KSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uRXZlbnQudGFyZ2V0ID09IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudFxuICAgICAgICAgICAgJiYgdHJhbnNpdGlvbkV2ZW50LnByb3BlcnR5TmFtZS5lbmRzV2l0aCgndHJhbnNmb3JtJykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlID0gdGhpcy5fcmVzb2x2ZVRvZ2dsZUFuaW1hdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNDbG9zaW5nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fb3BlbmVkICYmICEhdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX2lzT3BlbmluZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3BlbmVkICYmICEhdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX2lzQ2xvc2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fb3BlbmVkICYmICF0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNPcGVuZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5lZCAmJiAhdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX2lzRW5kXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWduID09ICdlbmQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfbW9kZVNpZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PSAnc2lkZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9tb2RlT3ZlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdvdmVyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX21vZGVQdXNoXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT0gJ3B1c2gnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfd2lkdGhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE1kU2lkZW5hdjtcbn0oKSk7XG5NZFNpZGVuYXYuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1zaWRlbmF2LCBtYXQtc2lkZW5hdicsXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtbWFsZXJiYSk6IG1vdmUgdGVtcGxhdGUgdG8gc2VwYXJhdGUgZmlsZS5cbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+IFwiLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdl0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICcodHJhbnNpdGlvbmVuZCknOiAnX29uVHJhbnNpdGlvbkVuZCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duKSc6ICdoYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBhbGlnbmluZyB0ZXh0IGJhc2VkIG9uIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hbGlnbl0nOiAnbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtY2xvc2VkXSc6ICdfaXNDbG9zZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LWNsb3NpbmddJzogJ19pc0Nsb3NpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LWVuZF0nOiAnX2lzRW5kJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1vcGVuZWRdJzogJ19pc09wZW5lZCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtb3BlbmluZ10nOiAnX2lzT3BlbmluZycsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtb3Zlcl0nOiAnX21vZGVPdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1wdXNoXSc6ICdfbW9kZVB1c2gnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LXNpZGVdJzogJ19tb2RlU2lkZScsXG4gICAgICAgICAgICAgICAgICAgICd0YWJJbmRleCc6ICctMSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU2lkZW5hdi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c1RyYXBGYWN0b3J5LCB9LFxuXTsgfTtcbk1kU2lkZW5hdi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnYWxpZ24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ21vZGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2Rpc2FibGVDbG9zZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnb25PcGVuU3RhcnQnOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnb3Blbi1zdGFydCcsXSB9LF0sXG4gICAgJ29uT3Blbic6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydvcGVuJyxdIH0sXSxcbiAgICAnb25DbG9zZVN0YXJ0JzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2Nsb3NlLXN0YXJ0JyxdIH0sXSxcbiAgICAnb25DbG9zZSc6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydjbG9zZScsXSB9LF0sXG4gICAgJ29uQWxpZ25DaGFuZ2VkJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2FsaWduLWNoYW5nZWQnLF0gfSxdLFxuICAgICdvcGVuZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xuLyoqXG4gKiA8bWQtc2lkZW5hdi1jb250YWluZXI+IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHRoZSBwYXJlbnQgY29tcG9uZW50IHRvIG9uZSBvciB0d28gPG1kLXNpZGVuYXY+cyB0aGF0IHZhbGlkYXRlcyB0aGUgc3RhdGUgaW50ZXJuYWxseVxuICogYW5kIGNvb3JkaW5hdGVzIHRoZSBiYWNrZHJvcCBhbmQgY29udGVudCBzdHlsaW5nLlxuICovXG52YXIgTWRTaWRlbmF2Q29udGFpbmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRTaWRlbmF2Q29udGFpbmVyKF9kaXIsIF9lbGVtZW50LCBfcmVuZGVyZXIsIF9uZ1pvbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2lkZW5hdiBiYWNrZHJvcCBpcyBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYWNrZHJvcENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBlbmFibGUgb3Blbi9jbG9zZSB0cmFudGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lbmFibGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgICAvLyBJZiBhIGBEaXJgIGRpcmVjdGl2ZSBleGlzdHMgdXAgdGhlIHRyZWUsIGxpc3RlbiBkaXJlY3Rpb24gY2hhbmdlcyBhbmQgdXBkYXRlIHRoZSBsZWZ0L3JpZ2h0XG4gICAgICAgIC8vIHByb3BlcnRpZXMgdG8gcG9pbnQgdG8gdGhlIHByb3BlciBzdGFydC9lbmQuXG4gICAgICAgIGlmIChfZGlyICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9kaXIuZGlyQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdmFsaWRhdGVEcmF3ZXJzKCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLCBcInN0YXJ0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaWRlbmF2IGNoaWxkIHdpdGggdGhlIGBzdGFydGAgYWxpZ25tZW50LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUsIFwiZW5kXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaWRlbmF2IGNoaWxkIHdpdGggdGhlIGBlbmRgIGFsaWdubWVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZW5kOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBPbiBjaGFuZ2VzLCBhc3NlcnQgb24gY29uc2lzdGVuY3kuXG4gICAgICAgIHRoaXMuX3NpZGVuYXZzLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92YWxpZGF0ZURyYXdlcnMoKTsgfSk7XG4gICAgICAgIHRoaXMuX3NpZGVuYXZzLmZvckVhY2goZnVuY3Rpb24gKHNpZGVuYXYpIHtcbiAgICAgICAgICAgIF90aGlzLl93YXRjaFNpZGVuYXZUb2dnbGUoc2lkZW5hdik7XG4gICAgICAgICAgICBfdGhpcy5fd2F0Y2hTaWRlbmF2QWxpZ24oc2lkZW5hdik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZURyYXdlcnMoKTtcbiAgICAgICAgLy8gR2l2ZSB0aGUgdmlldyBhIGNoYW5jZSB0byByZW5kZXIgdGhlIGluaXRpYWwgc3RhdGUsIHRoZW4gZW5hYmxlIHRyYW5zaXRpb25zLlxuICAgICAgICB0aGlzLl9uZ1pvbmUub25NaWNyb3Rhc2tFbXB0eS5maXJzdCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZW5hYmxlVHJhbnNpdGlvbnMgPSB0cnVlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxzIGBvcGVuYCBvZiBib3RoIHN0YXJ0IGFuZCBlbmQgc2lkZW5hdnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLl9zdGFydCwgdGhpcy5fZW5kXS5tYXAoZnVuY3Rpb24gKHNpZGVuYXYpIHsgcmV0dXJuIHNpZGVuYXYgJiYgc2lkZW5hdi5vcGVuKCk7IH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxzIGBjbG9zZWAgb2YgYm90aCBzdGFydCBhbmQgZW5kIHNpZGVuYXZzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMuX3N0YXJ0LCB0aGlzLl9lbmRdLm1hcChmdW5jdGlvbiAoc2lkZW5hdikgeyByZXR1cm4gc2lkZW5hdiAmJiBzaWRlbmF2LmNsb3NlKCk7IH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gc2lkZW5hdiBldmVudHMgaW4gb3JkZXIgdG8gc2V0IGEgY2xhc3Mgb24gdGhlIG1haW4gY29udGFpbmVyIGVsZW1lbnQgd2hlbiB0aGVcbiAgICAgKiBzaWRlbmF2IGlzIG9wZW4gYW5kIHRoZSBiYWNrZHJvcCBpcyB2aXNpYmxlLiBUaGlzIGVuc3VyZXMgYW55IG92ZXJmbG93IG9uIHRoZSBjb250YWluZXIgZWxlbWVudFxuICAgICAqIGlzIHByb3Blcmx5IGhpZGRlbi5cbiAgICAgKiBAcGFyYW0gez99IHNpZGVuYXZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX3dhdGNoU2lkZW5hdlRvZ2dsZSA9IGZ1bmN0aW9uIChzaWRlbmF2KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghc2lkZW5hdiB8fCBzaWRlbmF2Lm1vZGUgPT09ICdzaWRlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNpZGVuYXYub25PcGVuLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc2V0Q29udGFpbmVyQ2xhc3ModHJ1ZSk7IH0pO1xuICAgICAgICBzaWRlbmF2Lm9uQ2xvc2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9zZXRDb250YWluZXJDbGFzcyhmYWxzZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBzaWRlbmF2IG9uQWxpZ25DaGFuZ2VkIGV2ZW50IGluIG9yZGVyIHRvIHJlLXZhbGlkYXRlIGRyYXdlcnMgd2hlbiB0aGUgYWxpZ25cbiAgICAgKiBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7P30gc2lkZW5hdlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fd2F0Y2hTaWRlbmF2QWxpZ24gPSBmdW5jdGlvbiAoc2lkZW5hdikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXNpZGVuYXYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFOiBXZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZW1wdHkgYmVmb3JlIHZhbGlkYXRpbmcsXG4gICAgICAgIC8vIHNpbmNlIGJvdGggZHJhd2VycyBtYXkgYmUgc3dhcHBpbmcgc2lkZXMgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgc2lkZW5hdi5vbkFsaWduQ2hhbmdlZC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92YWxpZGF0ZURyYXdlcnMoKTsgfSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgJ21hdC1zaWRlbmF2LW9wZW5lZCcgY2xhc3Mgb24gdGhlIG1haW4gJ21kLXNpZGVuYXYtY29udGFpbmVyJyBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7P30gaXNBZGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX3NldENvbnRhaW5lckNsYXNzID0gZnVuY3Rpb24gKGlzQWRkKSB7XG4gICAgICAgIGlmIChpc0FkZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnbWF0LXNpZGVuYXYtb3BlbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtYXQtc2lkZW5hdi1vcGVuZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIHN0YXRlIG9mIHRoZSBzaWRlbmF2IGNoaWxkcmVuIGNvbXBvbmVudHMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl92YWxpZGF0ZURyYXdlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5fZW5kID0gbnVsbDtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSBhdCBtb3N0IG9uZSBzdGFydCBhbmQgb25lIGVuZCBzaWRlbmF2LlxuICAgICAgICAvLyBOT1RFOiBXZSBtdXN0IGNhbGwgdG9BcnJheSBvbiBfc2lkZW5hdnMgZXZlbiB0aG91Z2ggaXQncyBpdGVyYWJsZVxuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzE2NCkuXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9zaWRlbmF2cy50b0FycmF5KCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2lkZW5hdiA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChzaWRlbmF2LmFsaWduID09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93TWREdXBsaWNhdGVkU2lkZW5hdkVycm9yKCdlbmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kID0gc2lkZW5hdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93TWREdXBsaWNhdGVkU2lkZW5hdkVycm9yKCdzdGFydCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCA9IHNpZGVuYXY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmlnaHQgPSB0aGlzLl9sZWZ0ID0gbnVsbDtcbiAgICAgICAgLy8gRGV0ZWN0IGlmIHdlJ3JlIExUUiBvciBSVEwuXG4gICAgICAgIGlmICh0aGlzLl9kaXIgPT0gbnVsbCB8fCB0aGlzLl9kaXIudmFsdWUgPT0gJ2x0cicpIHtcbiAgICAgICAgICAgIHRoaXMuX2xlZnQgPSB0aGlzLl9zdGFydDtcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gdGhpcy5fZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGVmdCA9IHRoaXMuX2VuZDtcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fb25CYWNrZHJvcENsaWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYmFja2Ryb3BDbGljay5lbWl0KCk7XG4gICAgICAgIHRoaXMuX2Nsb3NlTW9kYWxTaWRlbmF2KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2Nsb3NlTW9kYWxTaWRlbmF2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDbG9zZSBhbGwgb3BlbiBzaWRlbmF2J3Mgd2hlcmUgY2xvc2luZyBpcyBub3QgZGlzYWJsZWQgYW5kIHRoZSBtb2RlIGlzIG5vdCBgc2lkZWAuXG4gICAgICAgIFt0aGlzLl9zdGFydCwgdGhpcy5fZW5kXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc2lkZW5hdikgeyByZXR1cm4gc2lkZW5hdiAmJiAhc2lkZW5hdi5kaXNhYmxlQ2xvc2UgJiYgc2lkZW5hdi5tb2RlICE9PSAnc2lkZSc7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoc2lkZW5hdikgeyByZXR1cm4gc2lkZW5hdi5jbG9zZSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5faXNTaG93aW5nQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faXNTaWRlbmF2T3Blbih0aGlzLl9zdGFydCkgJiYgdGhpcy5fc3RhcnQubW9kZSAhPSAnc2lkZScpXG4gICAgICAgICAgICB8fCAodGhpcy5faXNTaWRlbmF2T3Blbih0aGlzLl9lbmQpICYmIHRoaXMuX2VuZC5tb2RlICE9ICdzaWRlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNpZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2lzU2lkZW5hdk9wZW4gPSBmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICByZXR1cm4gc2lkZSAhPSBudWxsICYmIHNpZGUub3BlbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgc2lkZW5hdiwgaWYgaXQncyBpbiB0aGUgcHJvcGVyIG1vZGUgYW5kIG9wZW5lZC5cbiAgICAgKiBUaGlzIG1heSByZWxheW91dCB0aGUgdmlldywgc28gZG8gbm90IGNhbGwgdGhpcyBvZnRlbi5cbiAgICAgKiBAcGFyYW0gez99IHNpZGVuYXZcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2dldFNpZGVuYXZFZmZlY3RpdmVXaWR0aCA9IGZ1bmN0aW9uIChzaWRlbmF2LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faXNTaWRlbmF2T3BlbihzaWRlbmF2KSAmJiBzaWRlbmF2Lm1vZGUgPT0gbW9kZSkgPyBzaWRlbmF2Ll93aWR0aCA6IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2dldE1hcmdpbkxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fbGVmdCwgJ3NpZGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0TWFyZ2luUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fcmlnaHQsICdzaWRlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2dldFBvc2l0aW9uTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNpZGVuYXZFZmZlY3RpdmVXaWR0aCh0aGlzLl9sZWZ0LCAncHVzaCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9nZXRQb3NpdGlvblJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZW5hdkVmZmVjdGl2ZVdpZHRoKHRoaXMuX3JpZ2h0LCAncHVzaCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaG9yaXpvbnRhbCBvZmZzZXQgZm9yIHRoZSBjb250ZW50IGFyZWEuICBUaGVyZSBzaG91bGQgbmV2ZXIgYmUgYSB2YWx1ZSBmb3IgYm90aFxuICAgICAqIGxlZnQgYW5kIHJpZ2h0LCBzbyBieSBzdWJ0cmFjdGluZyB0aGUgcmlnaHQgdmFsdWUgZnJvbSB0aGUgbGVmdCB2YWx1ZSwgd2Ugc2hvdWxkIGFsd2F5cyBnZXRcbiAgICAgKiB0aGUgYXBwcm9wcmlhdGUgb2Zmc2V0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0UG9zaXRpb25PZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQb3NpdGlvbkxlZnQoKSAtIHRoaXMuX2dldFBvc2l0aW9uUmlnaHQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNpbmcgW25nU3R5bGVdIHJhdGhlciB0aGFuIHNlcGFyYXRlIFtzdHlsZS4uLl0gcHJvcGVydGllcyBiZWNhdXNlIFtzdHlsZS50cmFuc2Zvcm1dXG4gICAgICogZG9lc24ndCBzZWVtIHRvIHdvcmsgcmlnaHQgbm93LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFyZ2luTGVmdDogdGhpcy5fZ2V0TWFyZ2luTGVmdCgpICsgXCJweFwiLFxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IHRoaXMuX2dldE1hcmdpblJpZ2h0KCkgKyBcInB4XCIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlM2QoXCIgKyB0aGlzLl9nZXRQb3NpdGlvbk9mZnNldCgpICsgXCJweCwgMCwgMClcIlxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE1kU2lkZW5hdkNvbnRhaW5lcjtcbn0oKSk7XG5NZFNpZGVuYXZDb250YWluZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1zaWRlbmF2LWNvbnRhaW5lciwgbWF0LXNpZGVuYXYtY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgdXNlIENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaC4gSXQgZG9lcyBub3Qgd29yayBmb3IgdGhpcyBjb21wb25lbnQgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHRlY2huaWNhbGx5IGl0IGlzIGEgc2libGluZyBvZiBNZFNpZGVuYXYgKG9uIHRoZSBjb250ZW50IHRyZWUpIGFuZCBpc24ndCB1cGRhdGVkIHdoZW4gTWRTaWRlbmF2XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlcyBpdHMgc3RhdGUuXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXNpZGVuYXYtYmFja2Ryb3BcXFwiIChjbGljayk9XFxcIl9vbkJhY2tkcm9wQ2xpY2tlZCgpXFxcIiBbY2xhc3MubWF0LXNpZGVuYXYtc2hvd25dPVxcXCJfaXNTaG93aW5nQmFja2Ryb3AoKVxcXCI+PC9kaXY+IDxuZy1jb250ZW50IHNlbGVjdD1cXFwibWQtc2lkZW5hdiwgbWF0LXNpZGVuYXZcXFwiPjwvbmctY29udGVudD4gPGRpdiBjbGFzcz1cXFwibWF0LXNpZGVuYXYtY29udGVudFxcXCIgW25nU3R5bGVdPVxcXCJfZ2V0U3R5bGVzKClcXFwiIGNkay1zY3JvbGxhYmxlPiA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IDwvZGl2PiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtc2lkZW5hdi1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTtib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7ZGlzcGxheTpibG9jaztvdmVyZmxvdzpoaWRkZW59Lm1hdC1zaWRlbmF2LWNvbnRhaW5lcltmdWxsc2NyZWVuXXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MH0ubWF0LXNpZGVuYXYtY29udGFpbmVyW2Z1bGxzY3JlZW5dLm1hdC1zaWRlbmF2LW9wZW5lZHtvdmVyZmxvdzpoaWRkZW59Lm1hdC1zaWRlbmF2LWJhY2tkcm9we3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO2Rpc3BsYXk6YmxvY2s7ei1pbmRleDoyO3Zpc2liaWxpdHk6aGlkZGVufS5tYXQtc2lkZW5hdi1iYWNrZHJvcC5tYXQtc2lkZW5hdi1zaG93bnt2aXNpYmlsaXR5OnZpc2libGV9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC1zaWRlbmF2LWJhY2tkcm9we29wYWNpdHk6LjV9fS5tYXQtc2lkZW5hdi1jb250ZW50e3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7ZGlzcGxheTpibG9jaztoZWlnaHQ6MTAwJTtvdmVyZmxvdzphdXRvfS5tYXQtc2lkZW5hdntwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7Ym90dG9tOjA7ei1pbmRleDozO21pbi13aWR0aDo1dnc7b3V0bGluZTowO2JveC1zaXppbmc6Ym9yZGVyLWJveDtoZWlnaHQ6MTAwJTtvdmVyZmxvdy15OmF1dG87dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xMDAlLDAsMCl9Lm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LWNsb3NlZHt2aXNpYmlsaXR5OmhpZGRlbn0ubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtb3BlbmVkLC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1vcGVuaW5ne3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCl9Lm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LXNpZGV7ei1pbmRleDoxfS5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmR7cmlnaHQ6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMTAwJSwwLDApfS5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtY2xvc2Vke3Zpc2liaWxpdHk6aGlkZGVufS5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtb3BlbmVkLC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtb3BlbmluZ3t0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApfVtkaXI9cnRsXSAubWF0LXNpZGVuYXZ7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDEwMCUsMCwwKX1bZGlyPXJ0bF0gLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LWNsb3NlZHt2aXNpYmlsaXR5OmhpZGRlbn1bZGlyPXJ0bF0gLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LW9wZW5lZCxbZGlyPXJ0bF0gLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LW9wZW5pbmd7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX1bZGlyPXJ0bF0gLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LWVuZHtsZWZ0OjA7cmlnaHQ6YXV0bzt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTEwMCUsMCwwKX1bZGlyPXJ0bF0gLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LWVuZC5tYXQtc2lkZW5hdi1jbG9zZWR7dmlzaWJpbGl0eTpoaWRkZW59W2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtb3BlbmVkLFtkaXI9cnRsXSAubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5kLm1hdC1zaWRlbmF2LW9wZW5pbmd7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX0ubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtb3BlbmVkOm5vdCgubWF0LXNpZGVuYXYtc2lkZSksLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LW9wZW5pbmc6bm90KC5tYXQtc2lkZW5hdi1zaWRlKXtib3gtc2hhZG93OjAgOHB4IDEwcHggLTVweCByZ2JhKDAsMCwwLC4yKSwwIDE2cHggMjRweCAycHggcmdiYSgwLDAsMCwuMTQpLDAgNnB4IDMwcHggNXB4IHJnYmEoMCwwLDAsLjEyKX0gLyojIHNvdXJjZU1hcHBpbmdVUkw9c2lkZW5hdi5jc3MubWFwICovIFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi5tYXQtc2lkZW5hdi10cmFuc2l0aW9uIC5tYXQtc2lkZW5hdnt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zaWRlbmF2LXRyYW5zaXRpb24gLm1hdC1zaWRlbmF2LWNvbnRlbnR7dHJhbnNpdGlvbi1kdXJhdGlvbjouNHM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSk7dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm0sbWFyZ2luLWxlZnQsbWFyZ2luLXJpZ2h0fS5tYXQtc2lkZW5hdi10cmFuc2l0aW9uIC5tYXQtc2lkZW5hdi1iYWNrZHJvcC5tYXQtc2lkZW5hdi1zaG93bnt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfSAvKiMgc291cmNlTWFwcGluZ1VSTD1zaWRlbmF2LXRyYW5zaXRpb25zLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1jb250YWluZXJdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LXRyYW5zaXRpb25dJzogJ19lbmFibGVUcmFuc2l0aW9ucycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNpZGVuYXZDb250YWluZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBEaXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbl07IH07XG5NZFNpZGVuYXZDb250YWluZXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ19zaWRlbmF2cyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kU2lkZW5hdixdIH0sXSxcbiAgICAnYmFja2Ryb3BDbGljayc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xudmFyIE1kU2lkZW5hdk1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2lkZW5hdk1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kU2lkZW5hdk1vZHVsZTtcbn0oKSk7XG5NZFNpZGVuYXZNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1kQ29tbW9uTW9kdWxlLCBBMTF5TW9kdWxlLCBPdmVybGF5TW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRTaWRlbmF2Q29udGFpbmVyLCBNZFNpZGVuYXYsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNpZGVuYXZDb250YWluZXIsIE1kU2lkZW5hdl0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU2lkZW5hdk1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIE1kTGlzdERpdmlkZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpc3REaXZpZGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRMaXN0RGl2aWRlcjtcbn0oKSk7XG5NZExpc3REaXZpZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1kaXZpZGVyLCBtYXQtZGl2aWRlcidcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRMaXN0RGl2aWRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIE1kTGlzdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdCgpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZVJpcHBsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRMaXN0LnByb3RvdHlwZSwgXCJkaXNhYmxlUmlwcGxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHJpcHBsZSBlZmZlY3Qgc2hvdWxkIGJlIGRpc2FibGVkIG9uIHRoZSBsaXN0LWl0ZW1zIG9yIG5vdC5cbiAgICAgICAgICogVGhpcyBmbGFnIG9ubHkgaGFzIGFuIGVmZmVjdCBmb3IgYG1kLW5hdi1saXN0YCBjb21wb25lbnRzLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlUmlwcGxlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZVJpcHBsZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBNZExpc3Q7XG59KCkpO1xuTWRMaXN0LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtbGlzdCwgbWF0LWxpc3QsIG1kLW5hdi1saXN0LCBtYXQtbmF2LWxpc3QnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnbGlzdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWxpc3QsLm1hdC1uYXYtbGlzdHtwYWRkaW5nLXRvcDo4cHg7ZGlzcGxheTpibG9ja30ubWF0LWxpc3QgLm1hdC1zdWJoZWFkZXIsLm1hdC1uYXYtbGlzdCAubWF0LXN1YmhlYWRlcntkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtoZWlnaHQ6NDhweDtwYWRkaW5nOjE2cHg7bWFyZ2luOjA7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXNpemU6MTRweDtmb250LXdlaWdodDo1MDB9Lm1hdC1saXN0IC5tYXQtc3ViaGVhZGVyOmZpcnN0LWNoaWxkLC5tYXQtbmF2LWxpc3QgLm1hdC1zdWJoZWFkZXI6Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDotOHB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVte2Rpc3BsYXk6YmxvY2t9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaXRlbS1jb250ZW50e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7YWxpZ24taXRlbXM6Y2VudGVyO2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7Ym94LXNpemluZzpib3JkZXItYm94O2ZvbnQtc2l6ZToxNnB4O2hlaWdodDo0OHB4O3BhZGRpbmc6MCAxNnB4O3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaXRlbS1yaXBwbGUsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaXRlbS1yaXBwbGV7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7cG9pbnRlci1ldmVudHM6bm9uZX0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0ubWF0LWxpc3QtaXRlbS1hdmF0YXIgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC1saXN0LWl0ZW0tYXZhdGFyIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0OjU2cHh9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC0yLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC0yLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6NzJweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0ubWF0LTMtbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0ubWF0LTMtbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50e2hlaWdodDo4OHB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbS5tYXQtbXVsdGktbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0ubWF0LW11bHRpLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6MTAwJTtwYWRkaW5nOjhweCAxNnB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6MTAwJTtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCAxNnB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dD4qLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ+KnttYXJnaW46MDtwYWRkaW5nOjA7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc2l6ZTppbmhlcml0fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDplbXB0eSwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0OmVtcHR5e2Rpc3BsYXk6bm9uZX0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ6bnRoLWNoaWxkKDIpLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ6bnRoLWNoaWxkKDIpe3BhZGRpbmc6MH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWF2YXRhciwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1hdmF0YXJ7ZmxleC1zaHJpbms6MDt3aWR0aDo0MHB4O2hlaWdodDo0MHB4O2JvcmRlci1yYWRpdXM6NTAlfS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaWNvbiwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1pY29ue3dpZHRoOjI0cHg7aGVpZ2h0OjI0cHg7Zm9udC1zaXplOjI0cHg7Ym94LXNpemluZzpjb250ZW50LWJveDtib3JkZXItcmFkaXVzOjUwJTtwYWRkaW5nOjRweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saW5lLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saW5le3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpcztkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saW5lOm50aC1jaGlsZChuKzIpLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saW5lOm50aC1jaGlsZChuKzIpe2ZvbnQtc2l6ZToxNHB4fS5tYXQtbGlzdFtkZW5zZV0sLm1hdC1uYXYtbGlzdFtkZW5zZV17cGFkZGluZy10b3A6NHB4O2Rpc3BsYXk6YmxvY2t9Lm1hdC1saXN0W2RlbnNlXSAubWF0LXN1YmhlYWRlciwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LXN1YmhlYWRlcntkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtoZWlnaHQ6NDBweDtwYWRkaW5nOjE2cHg7bWFyZ2luOjA7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXNpemU6MTNweDtmb250LXdlaWdodDo1MDB9Lm1hdC1saXN0W2RlbnNlXSAubWF0LXN1YmhlYWRlcjpmaXJzdC1jaGlsZCwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LXN1YmhlYWRlcjpmaXJzdC1jaGlsZHttYXJnaW4tdG9wOi00cHh9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbXtkaXNwbGF5OmJsb2NrfS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaXRlbS1jb250ZW50e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7YWxpZ24taXRlbXM6Y2VudGVyO2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7Ym94LXNpemluZzpib3JkZXItYm94O2ZvbnQtc2l6ZToxM3B4O2hlaWdodDo0MHB4O3BhZGRpbmc6MCAxNnB4O3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWl0ZW0tcmlwcGxlLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1pdGVtLXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtwb2ludGVyLWV2ZW50czpub25lfS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0ubWF0LWxpc3QtaXRlbS1hdmF0YXIgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbS5tYXQtbGlzdC1pdGVtLWF2YXRhciAubWF0LWxpc3QtaXRlbS1jb250ZW50e2hlaWdodDo0OHB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0ubWF0LTItbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC0yLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6NjBweH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC0zLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbS5tYXQtMy1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0Ojc2cHh9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbS5tYXQtbXVsdGktbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC1tdWx0aS1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0OjEwMCU7cGFkZGluZzo4cHggMTZweH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6MTAwJTtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCAxNnB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ+KiwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dD4qe21hcmdpbjowO3BhZGRpbmc6MDtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOmluaGVyaXR9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDplbXB0eSwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDplbXB0eXtkaXNwbGF5Om5vbmV9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDpudGgtY2hpbGQoMiksLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ6bnRoLWNoaWxkKDIpe3BhZGRpbmc6MH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1hdmF0YXIsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWF2YXRhcntmbGV4LXNocmluazowO3dpZHRoOjQwcHg7aGVpZ2h0OjQwcHg7Ym9yZGVyLXJhZGl1czo1MCV9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaWNvbiwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaWNvbnt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2ZvbnQtc2l6ZToyMHB4O2JveC1zaXppbmc6Y29udGVudC1ib3g7Ym9yZGVyLXJhZGl1czo1MCU7cGFkZGluZzo0cHh9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpbmUsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saW5le3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpcztkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGluZTpudGgtY2hpbGQobisyKSwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpbmU6bnRoLWNoaWxkKG4rMil7Zm9udC1zaXplOjEzcHh9Lm1hdC1kaXZpZGVye2Rpc3BsYXk6YmxvY2s7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZDtib3JkZXItdG9wLXdpZHRoOjFweDttYXJnaW46MH0ubWF0LW5hdi1saXN0IGF7dGV4dC1kZWNvcmF0aW9uOm5vbmU7Y29sb3I6aW5oZXJpdH0ubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7Y3Vyc29yOnBvaW50ZXJ9Lm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbS1jb250ZW50Lm1hdC1saXN0LWl0ZW0tZm9jdXMsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbS1jb250ZW50OmhvdmVye291dGxpbmU6MH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9bGlzdC5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTGlzdC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuTWRMaXN0LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdkaXNhYmxlUmlwcGxlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTGlzdENzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdENzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTGlzdENzc01hdFN0eWxlcjtcbn0oKSk7XG5NZExpc3RDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWxpc3QsIG1hdC1saXN0JyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWxpc3RdJzogJ3RydWUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZExpc3RDc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTmF2TGlzdENzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTmF2TGlzdENzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTmF2TGlzdENzc01hdFN0eWxlcjtcbn0oKSk7XG5NZE5hdkxpc3RDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLW5hdi1saXN0LCBtYXQtbmF2LWxpc3QnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtbmF2LWxpc3RdJzogJ3RydWUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZE5hdkxpc3RDc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kRGl2aWRlckNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGl2aWRlckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kRGl2aWRlckNzc01hdFN0eWxlcjtcbn0oKSk7XG5NZERpdmlkZXJDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWRpdmlkZXIsIG1hdC1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWRpdmlkZXJdJzogJ3RydWUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERpdmlkZXJDc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlcjtcbn0oKSk7XG5NZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1saXN0LWF2YXRhcl0sIFttYXQtbGlzdC1hdmF0YXJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWxpc3QtYXZhdGFyXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRMaXN0QXZhdGFyQ3NzTWF0U3R5bGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZExpc3RJY29uQ3NzTWF0U3R5bGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0SWNvbkNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTGlzdEljb25Dc3NNYXRTdHlsZXI7XG59KCkpO1xuTWRMaXN0SWNvbkNzc01hdFN0eWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWxpc3QtaWNvbl0sIFttYXQtbGlzdC1pY29uXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1saXN0LWljb25dJzogJ3RydWUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZExpc3RJY29uQ3NzTWF0U3R5bGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXI7XG59KCkpO1xuTWRMaXN0U3ViaGVhZGVyQ3NzTWF0U3R5bGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtc3ViaGVhZGVyXSwgW21hdC1zdWJoZWFkZXJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXN1YmhlYWRlcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIE1kTGlzdEl0ZW0gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IF9saXN0XG4gICAgICogQHBhcmFtIHs/fSBuYXZMaXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRMaXN0SXRlbShfcmVuZGVyZXIsIF9lbGVtZW50LCBfbGlzdCwgbmF2TGlzdCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9saXN0ID0gX2xpc3Q7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNOYXZMaXN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzTmF2TGlzdCA9ICEhbmF2TGlzdDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTGlzdEl0ZW0ucHJvdG90eXBlLCBcImRpc2FibGVSaXBwbGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgcmlwcGxlIGVmZmVjdCBvbiBjbGljayBzaG91bGQgYmUgZGlzYWJsZWQuIFRoaXMgYXBwbGllcyBvbmx5IHRvIGxpc3QgaXRlbXMgdGhhdCBhcmVcbiAgICAgICAgICogcGFydCBvZiBhIG5hdiBsaXN0LiBUaGUgdmFsdWUgb2YgYGRpc2FibGVSaXBwbGVgIG9uIHRoZSBgbWQtbmF2LWxpc3RgIG92ZXJyaWRlcyB0aGlzIGZsYWcuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVSaXBwbGU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlUmlwcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTGlzdEl0ZW0ucHJvdG90eXBlLCBcIl9oYXNBdmF0YXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhdmF0YXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGF2YXRhcikge1xuICAgICAgICAgICAgaWYgKGF2YXRhciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnbWF0LWxpc3QtaXRlbS1hdmF0YXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ21hdC1saXN0LWl0ZW0tYXZhdGFyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRMaXN0SXRlbS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9saW5lU2V0dGVyID0gbmV3IE1kTGluZVNldHRlcih0aGlzLl9saW5lcywgdGhpcy5fcmVuZGVyZXIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGxpc3QgaXRlbSBzaG91bGQgc2hvdyBhIHJpcHBsZSBlZmZlY3Qgd2hlbiBjbGlja2VkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRMaXN0SXRlbS5wcm90b3R5cGUuaXNSaXBwbGVFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGlzYWJsZVJpcHBsZSAmJiB0aGlzLl9pc05hdkxpc3QgJiYgIXRoaXMuX2xpc3QuZGlzYWJsZVJpcHBsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRMaXN0SXRlbS5wcm90b3R5cGUuX2hhbmRsZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtYXQtbGlzdC1pdGVtLWZvY3VzJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTGlzdEl0ZW0ucHJvdG90eXBlLl9oYW5kbGVCbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtYXQtbGlzdC1pdGVtLWZvY3VzJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBjb21wb25lbnQgaG9zdC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTGlzdEl0ZW0ucHJvdG90eXBlLl9nZXRIb3N0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9O1xuICAgIHJldHVybiBNZExpc3RJdGVtO1xufSgpKTtcbk1kTGlzdEl0ZW0uZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1saXN0LWl0ZW0sIG1hdC1saXN0LWl0ZW0sIGFbbWQtbGlzdC1pdGVtXSwgYVttYXQtbGlzdC1pdGVtXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdsaXN0aXRlbScsXG4gICAgICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ19oYW5kbGVGb2N1cygpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdfaGFuZGxlQmx1cigpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtbGlzdC1pdGVtXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1saXN0LWl0ZW0tY29udGVudFxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1saXN0LWl0ZW0tcmlwcGxlXFxcIiBtZC1yaXBwbGUgW21kUmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIiBbbWRSaXBwbGVEaXNhYmxlZF09XFxcIiFpc1JpcHBsZUVuYWJsZWQoKVxcXCI+IDwvZGl2PiA8bmctY29udGVudCBzZWxlY3Q9XFxcIlttZC1saXN0LWF2YXRhcl0sW21kLWxpc3QtaWNvbl0sIFttYXQtbGlzdC1hdmF0YXJdLCBbbWF0LWxpc3QtaWNvbl1cXFwiPjwvbmctY29udGVudD4gPGRpdiBjbGFzcz1cXFwibWF0LWxpc3QtdGV4dFxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWQtbGluZV0sIFttYXQtbGluZV1cXFwiPjwvbmctY29udGVudD48L2Rpdj4gPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiA8L2Rpdj4gXCIsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZExpc3RJdGVtLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IE1kTGlzdCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBNZE5hdkxpc3RDc3NNYXRTdHlsZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbk1kTGlzdEl0ZW0ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2Rpc2FibGVSaXBwbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ19saW5lcyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kTGluZSxdIH0sXSxcbiAgICAnX2hhc0F2YXRhcic6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW01kTGlzdEF2YXRhckNzc01hdFN0eWxlcixdIH0sXSxcbn07XG52YXIgTWRMaXN0TW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRMaXN0TW9kdWxlO1xufSgpKTtcbk1kTGlzdE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW01kTGluZU1vZHVsZSwgTWRSaXBwbGVNb2R1bGUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgTWRMaXN0SXRlbSxcbiAgICAgICAgICAgICAgICAgICAgTWRMaXN0RGl2aWRlcixcbiAgICAgICAgICAgICAgICAgICAgTWRMaXN0QXZhdGFyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZExpbmVNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZExpc3RJY29uQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZExpc3RDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kTmF2TGlzdENzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWREaXZpZGVyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRMaXN0LFxuICAgICAgICAgICAgICAgICAgICBNZExpc3RJdGVtLFxuICAgICAgICAgICAgICAgICAgICBNZExpc3REaXZpZGVyLFxuICAgICAgICAgICAgICAgICAgICBNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kTGlzdEljb25Dc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kTGlzdENzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWROYXZMaXN0Q3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZERpdmlkZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZExpc3RNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQ29udmVydHMgdmFsdWVzIGludG8gc3RyaW5ncy4gRmFsc3kgdmFsdWVzIGJlY29tZSBlbXB0eSBzdHJpbmdzLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb2VyY2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBcIlwiICsgKHZhbHVlIHx8ICcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB2YWx1ZSB0aGF0IG1pZ2h0IGJlIGEgc3RyaW5nIGludG8gYSBudW1iZXIuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUludCh2YWx1ZSwgMTApIDogdmFsdWU7XG59XG52YXIgTWRHcmlkVGlsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kR3JpZFRpbGUoX3JlbmRlcmVyLCBfZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9yb3dzcGFuID0gMTtcbiAgICAgICAgdGhpcy5fY29sc3BhbiA9IDE7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRUaWxlLnByb3RvdHlwZSwgXCJyb3dzcGFuXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFtb3VudCBvZiByb3dzIHRoYXQgdGhlIGdyaWQgdGlsZSB0YWtlcyB1cC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm93c3BhbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3Jvd3NwYW4gPSBjb2VyY2VUb051bWJlcih2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRUaWxlLnByb3RvdHlwZSwgXCJjb2xzcGFuXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFtb3VudCBvZiBjb2x1bW5zIHRoYXQgdGhlIGdyaWQgdGlsZSB0YWtlcyB1cC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sc3BhbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2NvbHNwYW4gPSBjb2VyY2VUb051bWJlcih2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0eWxlIG9mIHRoZSBncmlkLXRpbGUgZWxlbWVudC4gIE5lZWRzIHRvIGJlIHNldCBtYW51YWxseSB0byBhdm9pZFxuICAgICAqIFwiQ2hhbmdlZCBhZnRlciBjaGVja2VkXCIgZXJyb3JzIHRoYXQgd291bGQgb2NjdXIgd2l0aCBIb3N0QmluZGluZy5cbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRHcmlkVGlsZS5wcm90b3R5cGUuX3NldFN0eWxlID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRHcmlkVGlsZTtcbn0oKSk7XG5NZEdyaWRUaWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtZ3JpZC10aWxlLCBtYXQtZ3JpZC10aWxlJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ2xpc3RpdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZ3JpZC10aWxlXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjwhLS0gVE9ETyhrYXJhKTogUmV2aXNpdCB3aHkgdGhpcyBpcyBhIGZpZ3VyZS4tLT4gPGZpZ3VyZSBjbGFzcz1cXFwibWF0LWZpZ3VyZVxcXCI+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9maWd1cmU+XCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWdyaWQtbGlzdHtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtZ3JpZC10aWxle2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7b3ZlcmZsb3c6aGlkZGVufS5tYXQtZ3JpZC10aWxlIC5tYXQtZmlndXJle2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjphYnNvbHV0ZTthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtoZWlnaHQ6MTAwJTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDtwYWRkaW5nOjA7bWFyZ2luOjB9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2hlaWdodDo0OHB4O2NvbG9yOiNmZmY7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4zOCk7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCAxNnB4O2ZvbnQtc2l6ZToxNnB4O3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtyaWdodDowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3RlciAubWF0LWxpbmUsLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVyIC5tYXQtbGluZXt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3h9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyIC5tYXQtbGluZTpudGgtY2hpbGQobisyKSwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXIgLm1hdC1saW5lOm50aC1jaGlsZChuKzIpe2ZvbnQtc2l6ZToxMnB4fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3Rlcj4qLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlcj4qe21hcmdpbjowO3BhZGRpbmc6MDtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOmluaGVyaXR9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyLm1hdC0yLWxpbmUsLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVyLm1hdC0yLWxpbmV7aGVpZ2h0OjY4cHh9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWxpc3QtdGV4dHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3dpZHRoOjEwMCU7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OmhpZGRlbn0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtbGlzdC10ZXh0Pip7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6aW5oZXJpdH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtbGlzdC10ZXh0OmVtcHR5e2Rpc3BsYXk6bm9uZX0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXJ7dG9wOjB9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVye2JvdHRvbTowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1hdmF0YXJ7cGFkZGluZy1yaWdodDoxNnB4fVtkaXI9cnRsXSAubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtYXZhdGFye3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLWxlZnQ6MTZweH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtYXZhdGFyOmVtcHR5e2Rpc3BsYXk6bm9uZX0gLyojIHNvdXJjZU1hcHBpbmdVUkw9Z3JpZC1saXN0LmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kR3JpZFRpbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuXTsgfTtcbk1kR3JpZFRpbGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3Jvd3NwYW4nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NvbHNwYW4nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xudmFyIE1kR3JpZFRpbGVUZXh0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRHcmlkVGlsZVRleHQoX3JlbmRlcmVyLCBfZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kR3JpZFRpbGVUZXh0LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpbmVTZXR0ZXIgPSBuZXcgTWRMaW5lU2V0dGVyKHRoaXMuX2xpbmVzLCB0aGlzLl9yZW5kZXJlciwgdGhpcy5fZWxlbWVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRHcmlkVGlsZVRleHQ7XG59KCkpO1xuTWRHcmlkVGlsZVRleHQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1ncmlkLXRpbGUtaGVhZGVyLCBtYXQtZ3JpZC10aWxlLWhlYWRlciwgbWQtZ3JpZC10aWxlLWZvb3RlciwgbWF0LWdyaWQtdGlsZS1mb290ZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLWdyaWQtYXZhdGFyXSwgW21hdC1ncmlkLWF2YXRhcl1cXFwiPjwvbmctY29udGVudD4gPGRpdiBjbGFzcz1cXFwibWF0LWdyaWQtbGlzdC10ZXh0XFxcIj48bmctY29udGVudCBzZWxlY3Q9XFxcIlttZC1saW5lXSwgW21hdC1saW5lXVxcXCI+PC9uZy1jb250ZW50PjwvZGl2PiA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IFwiXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kR3JpZFRpbGVUZXh0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbl07IH07XG5NZEdyaWRUaWxlVGV4dC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX2xpbmVzJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWRMaW5lLF0gfSxdLFxufTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlcjtcbn0oKSk7XG5NZEdyaWRBdmF0YXJDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1ncmlkLWF2YXRhcl0sIFttYXQtZ3JpZC1hdmF0YXJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWdyaWQtYXZhdGFyXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRHcmlkQXZhdGFyQ3NzTWF0U3R5bGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEdyaWRUaWxlSGVhZGVyQ3NzTWF0U3R5bGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kR3JpZFRpbGVIZWFkZXJDc3NNYXRTdHlsZXI7XG59KCkpO1xuTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtZ3JpZC10aWxlLWhlYWRlciwgbWF0LWdyaWQtdGlsZS1oZWFkZXInLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZ3JpZC10aWxlLWhlYWRlcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kR3JpZFRpbGVIZWFkZXJDc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kR3JpZFRpbGVGb290ZXJDc3NNYXRTdHlsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEdyaWRUaWxlRm9vdGVyQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlcjtcbn0oKSk7XG5NZEdyaWRUaWxlRm9vdGVyQ3NzTWF0U3R5bGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1ncmlkLXRpbGUtZm9vdGVyLCBtYXQtZ3JpZC10aWxlLWZvb3RlcicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1ncmlkLXRpbGUtZm9vdGVyXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBDbGFzcyBmb3IgZGV0ZXJtaW5pbmcsIGZyb20gYSBsaXN0IG9mIHRpbGVzLCB0aGUgKHJvdywgY29sKSBwb3NpdGlvbiBvZiBlYWNoIG9mIHRob3NlIHRpbGVzXG4gKiBpbiB0aGUgZ3JpZC4gVGhpcyBpcyBuZWNlc3NhcnkgKHJhdGhlciB0aGFuIGp1c3QgcmVuZGVyaW5nIHRoZSB0aWxlcyBpbiBub3JtYWwgZG9jdW1lbnQgZmxvdylcbiAqIGJlY2F1c2UgdGhlIHRpbGVzIGNhbiBoYXZlIGEgcm93c3Bhbi5cbiAqXG4gKiBUaGUgcG9zaXRpb25pbmcgYWxnb3JpdGhtIGdyZWVkaWx5IHBsYWNlcyBlYWNoIHRpbGUgYXMgc29vbiBhcyBpdCBlbmNvdW50ZXJzIGEgZ2FwIGluIHRoZSBncmlkXG4gKiBsYXJnZSBlbm91Z2ggdG8gYWNjb21tb2RhdGUgaXQgc28gdGhhdCB0aGUgdGlsZXMgc3RpbGwgcmVuZGVyIGluIHRoZSBzYW1lIG9yZGVyIGluIHdoaWNoIHRoZXlcbiAqIGFyZSBnaXZlbi5cbiAqXG4gKiBUaGUgYmFzaXMgb2YgdGhlIGFsZ29yaXRobSBpcyB0aGUgdXNlIG9mIGFuIGFycmF5IHRvIHRyYWNrIHRoZSBhbHJlYWR5IHBsYWNlZCB0aWxlcy4gRWFjaFxuICogZWxlbWVudCBvZiB0aGUgYXJyYXkgY29ycmVzcG9uZHMgdG8gYSBjb2x1bW4sIGFuZCB0aGUgdmFsdWUgaW5kaWNhdGVzIGhvdyBtYW55IGNlbGxzIGluIHRoYXRcbiAqIGNvbHVtbiBhcmUgYWxyZWFkeSBvY2N1cGllZDsgemVybyBpbmRpY2F0ZXMgYW4gZW1wdHkgY2VsbC4gTW92aW5nIFwiZG93blwiIHRvIHRoZSBuZXh0IHJvd1xuICogZGVjcmVtZW50cyBlYWNoIHZhbHVlIGluIHRoZSB0cmFja2luZyBhcnJheSAoaW5kaWNhdGluZyB0aGF0IHRoZSBjb2x1bW4gaXMgb25lIGNlbGwgY2xvc2VyIHRvXG4gKiBiZWluZyBmcmVlKS5cbiAqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFRpbGVDb29yZGluYXRvciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbnVtQ29sdW1uc1xuICAgICAqIEBwYXJhbSB7P30gdGlsZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaWxlQ29vcmRpbmF0b3IobnVtQ29sdW1ucywgdGlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IGF0IHdoaWNoIHRoZSBzZWFyY2ggZm9yIHRoZSBuZXh0IGdhcCB3aWxsIHN0YXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5JbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCByb3cgaW5kZXguXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvd0luZGV4ID0gMDtcbiAgICAgICAgdGhpcy50cmFja2VyID0gbmV3IEFycmF5KG51bUNvbHVtbnMpO1xuICAgICAgICB0aGlzLnRyYWNrZXIuZmlsbCgwLCAwLCB0aGlzLnRyYWNrZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSB0aWxlcy5tYXAoZnVuY3Rpb24gKHRpbGUpIHsgcmV0dXJuIF90aGlzLl90cmFja1RpbGUodGlsZSk7IH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZSwgXCJyb3dDb3VudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2Ygcm93cyBvY2N1cGllZCBieSB0aWxlc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJvd0luZGV4ICsgMTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUsIFwicm93c3BhblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB0b3RhbCBzcGFuIG9mIHJvd3Mgb2NjdXBpZWQgYnkgdGlsZXMuXG4gICAgICAgICAqIEV4OiBBIGxpc3Qgd2l0aCAxIHJvdyB0aGF0IGNvbnRhaW5zIGEgdGlsZSB3aXRoIHJvd3NwYW4gMiB3aWxsIGhhdmUgYSB0b3RhbCByb3dzcGFuIG9mIDIuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RSb3dNYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCB0aGlzLnRyYWNrZXIpO1xuICAgICAgICAgICAgLy8gaWYgYW55IG9mIHRoZSB0aWxlcyBoYXMgYSByb3dzcGFuIHRoYXQgcHVzaGVzIGl0IGJleW9uZCB0aGUgdG90YWwgcm93IGNvdW50LFxuICAgICAgICAgICAgLy8gYWRkIHRoZSBkaWZmZXJlbmNlIHRvIHRoZSByb3djb3VudFxuICAgICAgICAgICAgcmV0dXJuIGxhc3RSb3dNYXggPiAxID8gdGhpcy5yb3dDb3VudCArIGxhc3RSb3dNYXggLSAxIDogdGhpcy5yb3dDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcm93IGFuZCBjb2wgcG9zaXRpb24gb2YgYSB0aWxlLlxuICAgICAqIEBwYXJhbSB7P30gdGlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZS5fdHJhY2tUaWxlID0gZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgICAgLy8gRmluZCBhIGdhcCBsYXJnZSBlbm91Z2ggZm9yIHRoaXMgdGlsZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ2FwU3RhcnRJbmRleCA9IHRoaXMuX2ZpbmRNYXRjaGluZ0dhcCh0aWxlLmNvbHNwYW4pO1xuICAgICAgICAvLyBQbGFjZSB0aWxlIGluIHRoZSByZXN1bHRpbmcgZ2FwLlxuICAgICAgICB0aGlzLl9tYXJrVGlsZVBvc2l0aW9uKGdhcFN0YXJ0SW5kZXgsIHRpbGUpO1xuICAgICAgICAvLyBUaGUgbmV4dCB0aW1lIHdlIGxvb2sgZm9yIGEgZ2FwLCB0aGUgc2VhcmNoIHdpbGwgc3RhcnQgYXQgY29sdW1uSW5kZXgsIHdoaWNoIHNob3VsZCBiZVxuICAgICAgICAvLyBpbW1lZGlhdGVseSBhZnRlciB0aGUgdGlsZSB0aGF0IGhhcyBqdXN0IGJlZW4gcGxhY2VkLlxuICAgICAgICB0aGlzLmNvbHVtbkluZGV4ID0gZ2FwU3RhcnRJbmRleCArIHRpbGUuY29sc3BhbjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaWxlUG9zaXRpb24odGhpcy5yb3dJbmRleCwgZ2FwU3RhcnRJbmRleCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmV4dCBhdmFpbGFibGUgc3BhY2UgbGFyZ2UgZW5vdWdoIHRvIGZpdCB0aGUgdGlsZS5cbiAgICAgKiBAcGFyYW0gez99IHRpbGVDb2xzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLl9maW5kTWF0Y2hpbmdHYXAgPSBmdW5jdGlvbiAodGlsZUNvbHMpIHtcbiAgICAgICAgaWYgKHRpbGVDb2xzID4gdGhpcy50cmFja2VyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWQtZ3JpZC1saXN0OiB0aWxlIHdpdGggY29sc3BhbiBcIiArIHRpbGVDb2xzICsgXCIgaXMgd2lkZXIgdGhhbiBcIiArXG4gICAgICAgICAgICAgICAgKFwiZ3JpZCB3aXRoIGNvbHM9XFxcIlwiICsgdGhpcy50cmFja2VyLmxlbmd0aCArIFwiXFxcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YXJ0IGluZGV4IGlzIGluY2x1c2l2ZSwgZW5kIGluZGV4IGlzIGV4Y2x1c2l2ZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ2FwU3RhcnRJbmRleCA9IC0xO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnYXBFbmRJbmRleCA9IC0xO1xuICAgICAgICAvLyBMb29rIGZvciBhIGdhcCBsYXJnZSBlbm91Z2ggdG8gZml0IHRoZSBnaXZlbiB0aWxlLiBFbXB0eSBzcGFjZXMgYXJlIG1hcmtlZCB3aXRoIGEgemVyby5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSByb3csIGdvIHRvIHRoZSBuZXh0IHJvdy5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbkluZGV4ICsgdGlsZUNvbHMgPiB0aGlzLnRyYWNrZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFJvdygpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2FwU3RhcnRJbmRleCA9IHRoaXMudHJhY2tlci5pbmRleE9mKDAsIHRoaXMuY29sdW1uSW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG1vcmUgZW1wdHkgc3BhY2VzIGluIHRoaXMgcm93IGF0IGFsbCwgbW92ZSBvbiB0byB0aGUgbmV4dCByb3cuXG4gICAgICAgICAgICBpZiAoZ2FwU3RhcnRJbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRSb3coKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdhcEVuZEluZGV4ID0gdGhpcy5fZmluZEdhcEVuZEluZGV4KGdhcFN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgYSBnYXAgbGFyZ2UgZW5vdWdoIGlzbid0IGZvdW5kLCB3ZSB3YW50IHRvIHN0YXJ0IGxvb2tpbmcgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgIC8vIGdhcCBvbiB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICAgICAgICB0aGlzLmNvbHVtbkluZGV4ID0gZ2FwU3RhcnRJbmRleCArIDE7XG4gICAgICAgICAgICAvLyBDb250aW51ZSBpdGVyYXRpbmcgdW50aWwgd2UgZmluZCBhIGdhcCB3aWRlIGVub3VnaCBmb3IgdGhpcyB0aWxlLlxuICAgICAgICB9IHdoaWxlIChnYXBFbmRJbmRleCAtIGdhcFN0YXJ0SW5kZXggPCB0aWxlQ29scyk7XG4gICAgICAgIHJldHVybiBnYXBTdGFydEluZGV4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZSBcImRvd25cIiB0byB0aGUgbmV4dCByb3cuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLl9uZXh0Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbHVtbkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5yb3dJbmRleCsrO1xuICAgICAgICAvLyBEZWNyZW1lbnQgYWxsIHNwYWNlcyBieSBvbmUgdG8gcmVmbGVjdCBtb3ZpbmcgZG93biBvbmUgcm93LlxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdGhpcy50cmFja2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXJbaV0gPSBNYXRoLm1heCgwLCB0aGlzLnRyYWNrZXJbaV0gLSAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVuZCBpbmRleCAoZXhjbHVzaXZlKSBvZiBhIGdhcCBnaXZlbiB0aGUgaW5kZXggZnJvbSB3aGljaCB0byBzdGFydCBsb29raW5nLlxuICAgICAqIFRoZSBnYXAgZW5kcyB3aGVuIGEgbm9uLXplcm8gdmFsdWUgaXMgZm91bmQuXG4gICAgICogQHBhcmFtIHs/fSBnYXBTdGFydEluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLl9maW5kR2FwRW5kSW5kZXggPSBmdW5jdGlvbiAoZ2FwU3RhcnRJbmRleCkge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBnYXBTdGFydEluZGV4ICsgMTsgaSA8IHRoaXMudHJhY2tlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tlcltpXSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGdhcCBlbmRzIHdpdGggdGhlIGVuZCBvZiB0aGUgcm93LlxuICAgICAgICByZXR1cm4gdGhpcy50cmFja2VyLmxlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdGlsZSB0cmFja2VyIHRvIGFjY291bnQgZm9yIHRoZSBnaXZlbiB0aWxlIGluIHRoZSBnaXZlbiBzcGFjZS5cbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/fSB0aWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLl9tYXJrVGlsZVBvc2l0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCB0aWxlKSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aWxlLmNvbHNwYW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy50cmFja2VyW3N0YXJ0ICsgaV0gPSB0aWxlLnJvd3NwYW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaWxlQ29vcmRpbmF0b3I7XG59KCkpO1xuLyoqXG4gKiBTaW1wbGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIHRpbGUgcG9zaXRpb24gKHJvdywgY29sKS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgVGlsZVBvc2l0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByb3dcbiAgICAgKiBAcGFyYW0gez99IGNvbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRpbGVQb3NpdGlvbihyb3csIGNvbCkge1xuICAgICAgICB0aGlzLnJvdyA9IHJvdztcbiAgICAgICAgdGhpcy5jb2wgPSBjb2w7XG4gICAgfVxuICAgIHJldHVybiBUaWxlUG9zaXRpb247XG59KCkpO1xuLyoqXG4gKiBTZXRzIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGZvciBhbiBpbmRpdmlkdWFsIHRpbGUsIGdpdmVuIHRoZSBwb3NpdGlvbiBjYWxjdWxhdGVkIGJ5IHRoZVxuICogVGlsZSBDb29yZGluYXRvci5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgVGlsZVN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbGVTdHlsZXIoKSB7XG4gICAgICAgIHRoaXMuX3Jvd3MgPSAwO1xuICAgICAgICB0aGlzLl9yb3dzcGFuID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBncmlkLWxpc3QgbGF5b3V0IGluZm8gb25jZSBpdCBpcyBhdmFpbGFibGUuIENhbm5vdCBiZSBwcm9jZXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogYmVjYXVzZSB0aGVzZSBwcm9wZXJ0aWVzIGhhdmVuJ3QgYmVlbiBjYWxjdWxhdGVkIGJ5IHRoYXQgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGd1dHRlclNpemUgU2l6ZSBvZiB0aGUgZ3JpZCdzIGd1dHRlci5cbiAgICAgKiBAcGFyYW0gez99IHRyYWNrZXIgSW5zdGFuY2Ugb2YgdGhlIFRpbGVDb29yZGluYXRvci5cbiAgICAgKiBAcGFyYW0gez99IGNvbHMgQW1vdW50IG9mIGNvbHVtbnMgaW4gdGhlIGdyaWQuXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3Rpb24gTGF5b3V0IGRpcmVjdGlvbiBvZiB0aGUgZ3JpZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZ3V0dGVyU2l6ZSwgdHJhY2tlciwgY29scywgZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2d1dHRlclNpemUgPSBub3JtYWxpemVVbml0cyhndXR0ZXJTaXplKTtcbiAgICAgICAgdGhpcy5fcm93cyA9IHRyYWNrZXIucm93Q291bnQ7XG4gICAgICAgIHRoaXMuX3Jvd3NwYW4gPSB0cmFja2VyLnJvd3NwYW47XG4gICAgICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgYW1vdW50IG9mIHNwYWNlIGEgc2luZ2xlIDF4MSB0aWxlIHdvdWxkIHRha2UgdXAgKHdpZHRoIG9yIGhlaWdodCkuXG4gICAgICogVXNlZCBhcyBhIGJhc2lzIGZvciBvdGhlciBjYWxjdWxhdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSBzaXplUGVyY2VudCBQZXJjZW50IG9mIHRoZSB0b3RhbCBncmlkLWxpc3Qgc3BhY2UgdGhhdCBvbmUgMXgxIHRpbGUgd291bGQgdGFrZSB1cC5cbiAgICAgKiBAcGFyYW0gez99IGd1dHRlckZyYWN0aW9uIEZyYWN0aW9uIG9mIHRoZSBndXR0ZXIgc2l6ZSB0YWtlbiB1cCBieSBvbmUgMXgxIHRpbGUuXG4gICAgICogQHJldHVybiB7P30gVGhlIHNpemUgb2YgYSAxeDEgdGlsZSBhcyBhbiBleHByZXNzaW9uIHRoYXQgY2FuIGJlIGV2YWx1YXRlZCB2aWEgQ1NTIGNhbGMoKS5cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRCYXNlVGlsZVNpemUgPSBmdW5jdGlvbiAoc2l6ZVBlcmNlbnQsIGd1dHRlckZyYWN0aW9uKSB7XG4gICAgICAgIC8vIFRha2UgdGhlIGJhc2Ugc2l6ZSBwZXJjZW50IChhcyB3b3VsZCBiZSBpZiBldmVubHkgZGl2aWRpbmcgdGhlIHNpemUgYmV0d2VlbiBjZWxscyksXG4gICAgICAgIC8vIGFuZCB0aGVuIHN1YnRyYWN0aW5nIHRoZSBzaXplIG9mIG9uZSBndXR0ZXIuIEhvd2V2ZXIsIHNpbmNlIHRoZXJlIGFyZSBubyBndXR0ZXJzIG9uIHRoZVxuICAgICAgICAvLyBlZGdlcywgZWFjaCB0aWxlIG9ubHkgdXNlcyBhIGZyYWN0aW9uIChndXR0ZXJTaGFyZSA9IG51bUd1dHRlcnMgLyBudW1DZWxscykgb2YgdGhlIGd1dHRlclxuICAgICAgICAvLyBzaXplLiAoSW1hZ2luZSBoYXZpbmcgb25lIGd1dHRlciBwZXIgdGlsZSwgYW5kIHRoZW4gYnJlYWtpbmcgdXAgdGhlIGV4dHJhIGd1dHRlciBvbiB0aGVcbiAgICAgICAgLy8gZWRnZSBldmVubHkgYW1vbmcgdGhlIGNlbGxzKS5cbiAgICAgICAgcmV0dXJuIFwiKFwiICsgc2l6ZVBlcmNlbnQgKyBcIiUgLSAoIFwiICsgdGhpcy5fZ3V0dGVyU2l6ZSArIFwiICogXCIgKyBndXR0ZXJGcmFjdGlvbiArIFwiICkpXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIFRoZSBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGEgdGlsZSwgZS5nLiwgdGhlICd0b3AnIG9yICdsZWZ0JyBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gez99IGJhc2VTaXplIEJhc2Ugc2l6ZSBvZiBhIDF4MSB0aWxlIChhcyBjb21wdXRlZCBpbiBnZXRCYXNlVGlsZVNpemUpLlxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0IE51bWJlciBvZiB0aWxlcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJlbmRlcmVkIGluIHRoZSByb3cvY29sdW1uLlxuICAgICAqIEByZXR1cm4gez99IFBvc2l0aW9uIG9mIHRoZSB0aWxlIGFzIGEgQ1NTIGNhbGMoKSBleHByZXNzaW9uLlxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLmdldFRpbGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChiYXNlU2l6ZSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIFRoZSBwb3NpdGlvbiBjb21lcyB0aGUgc2l6ZSBvZiBhIDF4MSB0aWxlIHBsdXMgZ3V0dGVyIGZvciBlYWNoIHByZXZpb3VzIHRpbGUgaW4gdGhlXG4gICAgICAgIC8vIHJvdy9jb2x1bW4gKG9mZnNldCkuXG4gICAgICAgIHJldHVybiBjYWxjKFwiKFwiICsgYmFzZVNpemUgKyBcIiArIFwiICsgdGhpcy5fZ3V0dGVyU2l6ZSArIFwiKSAqIFwiICsgb2Zmc2V0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFjdHVhbCBzaXplIG9mIGEgdGlsZSwgZS5nLiwgd2lkdGggb3IgaGVpZ2h0LCB0YWtpbmcgcm93c3BhbiBvciBjb2xzcGFuIGludG8gYWNjb3VudC5cbiAgICAgKiBAcGFyYW0gez99IGJhc2VTaXplIEJhc2Ugc2l6ZSBvZiBhIDF4MSB0aWxlIChhcyBjb21wdXRlZCBpbiBnZXRCYXNlVGlsZVNpemUpLlxuICAgICAqIEBwYXJhbSB7P30gc3BhbiBUaGUgdGlsZSdzIHJvd3NwYW4gb3IgY29sc3Bhbi5cbiAgICAgKiBAcmV0dXJuIHs/fSBTaXplIG9mIHRoZSB0aWxlIGFzIGEgQ1NTIGNhbGMoKSBleHByZXNzaW9uLlxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLmdldFRpbGVTaXplID0gZnVuY3Rpb24gKGJhc2VTaXplLCBzcGFuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIGJhc2VTaXplICsgXCIgKiBcIiArIHNwYW4gKyBcIikgKyAoXCIgKyAoc3BhbiAtIDEpICsgXCIgKiBcIiArIHRoaXMuX2d1dHRlclNpemUgKyBcIilcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0eWxlIHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZCB0byBhIHRpbGUgZm9yIHRoZSBnaXZlbiByb3cgYW5kIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAcGFyYW0gez99IHRpbGUgVGlsZSB0byB3aGljaCB0byBhcHBseSB0aGUgc3R5bGluZy5cbiAgICAgKiBAcGFyYW0gez99IHJvd0luZGV4IEluZGV4IG9mIHRoZSB0aWxlJ3Mgcm93LlxuICAgICAqIEBwYXJhbSB7P30gY29sSW5kZXggSW5kZXggb2YgdGhlIHRpbGUncyBjb2x1bW4uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCwgY29sSW5kZXgpIHtcbiAgICAgICAgLy8gUGVyY2VudCBvZiB0aGUgYXZhaWxhYmxlIGhvcml6b250YWwgc3BhY2UgdGhhdCBvbmUgY29sdW1uIHRha2VzIHVwLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwZXJjZW50V2lkdGhQZXJUaWxlID0gMTAwIC8gdGhpcy5fY29scztcbiAgICAgICAgLy8gRnJhY3Rpb24gb2YgdGhlIHZlcnRpY2FsIGd1dHRlciBzaXplIHRoYXQgZWFjaCBjb2x1bW4gdGFrZXMgdXAuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCBpZiB0aGVyZSBhcmUgNSBjb2x1bW5zLCBlYWNoIGNvbHVtbiB1c2VzIDQvNSA9IDAuOCB0aW1lcyB0aGUgZ3V0dGVyIHdpZHRoLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBndXR0ZXJXaWR0aEZyYWN0aW9uUGVyVGlsZSA9ICh0aGlzLl9jb2xzIC0gMSkgLyB0aGlzLl9jb2xzO1xuICAgICAgICB0aGlzLnNldENvbFN0eWxlcyh0aWxlLCBjb2xJbmRleCwgcGVyY2VudFdpZHRoUGVyVGlsZSwgZ3V0dGVyV2lkdGhGcmFjdGlvblBlclRpbGUpO1xuICAgICAgICB0aGlzLnNldFJvd1N0eWxlcyh0aWxlLCByb3dJbmRleCwgcGVyY2VudFdpZHRoUGVyVGlsZSwgZ3V0dGVyV2lkdGhGcmFjdGlvblBlclRpbGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaG9yaXpvbnRhbCBwbGFjZW1lbnQgb2YgdGhlIHRpbGUgaW4gdGhlIGxpc3QuXG4gICAgICogQHBhcmFtIHs/fSB0aWxlXG4gICAgICogQHBhcmFtIHs/fSBjb2xJbmRleFxuICAgICAqIEBwYXJhbSB7P30gcGVyY2VudFdpZHRoXG4gICAgICogQHBhcmFtIHs/fSBndXR0ZXJXaWR0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuc2V0Q29sU3R5bGVzID0gZnVuY3Rpb24gKHRpbGUsIGNvbEluZGV4LCBwZXJjZW50V2lkdGgsIGd1dHRlcldpZHRoKSB7XG4gICAgICAgIC8vIEJhc2UgaG9yaXpvbnRhbCBzaXplIG9mIGEgY29sdW1uLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlVGlsZVdpZHRoID0gdGhpcy5nZXRCYXNlVGlsZVNpemUocGVyY2VudFdpZHRoLCBndXR0ZXJXaWR0aCk7XG4gICAgICAgIC8vIFRoZSB3aWR0aCBhbmQgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiBlYWNoIHRpbGUgaXMgYWx3YXlzIGNhbGN1bGF0ZWQgdGhlIHNhbWUgd2F5LCBidXQgdGhlXG4gICAgICAgIC8vIGhlaWdodCBhbmQgdmVydGljYWwgcG9zaXRpb24gZGVwZW5kcyBvbiB0aGUgcm93TW9kZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lkZSA9IHRoaXMuX2RpcmVjdGlvbiA9PT0gJ2x0cicgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICB0aWxlLl9zZXRTdHlsZShzaWRlLCB0aGlzLmdldFRpbGVQb3NpdGlvbihiYXNlVGlsZVdpZHRoLCBjb2xJbmRleCkpO1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgnd2lkdGgnLCBjYWxjKHRoaXMuZ2V0VGlsZVNpemUoYmFzZVRpbGVXaWR0aCwgdGlsZS5jb2xzcGFuKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdG90YWwgc2l6ZSB0YWtlbiB1cCBieSBndXR0ZXJzIGFjcm9zcyBvbmUgYXhpcyBvZiBhIGxpc3QuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRHdXR0ZXJTcGFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3V0dGVyU2l6ZSArIFwiICogKFwiICsgdGhpcy5fcm93c3BhbiArIFwiIC0gMSlcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHRvdGFsIHNpemUgdGFrZW4gdXAgYnkgdGlsZXMgYWNyb3NzIG9uZSBheGlzIG9mIGEgbGlzdC5cbiAgICAgKiBAcGFyYW0gez99IHRpbGVIZWlnaHQgSGVpZ2h0IG9mIHRoZSB0aWxlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0VGlsZVNwYW4gPSBmdW5jdGlvbiAodGlsZUhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm93c3BhbiArIFwiICogXCIgKyB0aGlzLmdldFRpbGVTaXplKHRpbGVIZWlnaHQsIDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmVydGljYWwgcGxhY2VtZW50IG9mIHRoZSB0aWxlIGluIHRoZSBsaXN0LlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCB0eXBlIG9mIFRpbGVTdHlsZXIuXG4gICAgICogXFxAZG9jcy1wcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSB0aWxlXG4gICAgICogQHBhcmFtIHs/fSByb3dJbmRleFxuICAgICAqIEBwYXJhbSB7P30gcGVyY2VudFdpZHRoXG4gICAgICogQHBhcmFtIHs/fSBndXR0ZXJXaWR0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuc2V0Um93U3R5bGVzID0gZnVuY3Rpb24gKHRpbGUsIHJvd0luZGV4LCBwZXJjZW50V2lkdGgsIGd1dHRlcldpZHRoKSB7IH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY29tcHV0ZWQgaGVpZ2h0IGFuZCByZXR1cm5zIHRoZSBjb3JyZWN0IHN0eWxlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZSBvZiBUaWxlU3R5bGVyLlxuICAgICAqIFxcQGRvY3MtcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBUaWxlU3R5bGVyO1xufSgpKTtcbi8qKlxuICogVGhpcyB0eXBlIG9mIHN0eWxlciBpcyBpbnN0YW50aWF0ZWQgd2hlbiB0aGUgdXNlciBwYXNzZXMgaW4gYSBmaXhlZCByb3cgaGVpZ2h0LlxuICogRXhhbXBsZSA8bWQtZ3JpZC1saXN0IGNvbHM9XCIzXCIgcm93SGVpZ2h0PVwiMTAwcHhcIj5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgRml4ZWRUaWxlU3R5bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGaXhlZFRpbGVTdHlsZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaXhlZFJvd0hlaWdodFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZpeGVkVGlsZVN0eWxlcihmaXhlZFJvd0hlaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5maXhlZFJvd0hlaWdodCA9IGZpeGVkUm93SGVpZ2h0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZ3V0dGVyU2l6ZVxuICAgICAqIEBwYXJhbSB7P30gdHJhY2tlclxuICAgICAqIEBwYXJhbSB7P30gY29sc1xuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGaXhlZFRpbGVTdHlsZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZ3V0dGVyU2l6ZSwgdHJhY2tlciwgY29scywgZGlyZWN0aW9uKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGd1dHRlclNpemUsIHRyYWNrZXIsIGNvbHMsIGRpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuZml4ZWRSb3dIZWlnaHQgPSBub3JtYWxpemVVbml0cyh0aGlzLmZpeGVkUm93SGVpZ2h0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGlsZVxuICAgICAqIEBwYXJhbSB7P30gcm93SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHBlcmNlbnRXaWR0aFxuICAgICAqIEBwYXJhbSB7P30gZ3V0dGVyV2lkdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZpeGVkVGlsZVN0eWxlci5wcm90b3R5cGUuc2V0Um93U3R5bGVzID0gZnVuY3Rpb24gKHRpbGUsIHJvd0luZGV4LCBwZXJjZW50V2lkdGgsIGd1dHRlcldpZHRoKSB7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCd0b3AnLCB0aGlzLmdldFRpbGVQb3NpdGlvbih0aGlzLmZpeGVkUm93SGVpZ2h0LCByb3dJbmRleCkpO1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgnaGVpZ2h0JywgY2FsYyh0aGlzLmdldFRpbGVTaXplKHRoaXMuZml4ZWRSb3dIZWlnaHQsIHRpbGUucm93c3BhbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRml4ZWRUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRDb21wdXRlZEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdoZWlnaHQnLCBjYWxjKHRoaXMuZ2V0VGlsZVNwYW4odGhpcy5maXhlZFJvd0hlaWdodCkgKyBcIiArIFwiICsgdGhpcy5nZXRHdXR0ZXJTcGFuKCkpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICByZXR1cm4gRml4ZWRUaWxlU3R5bGVyO1xufShUaWxlU3R5bGVyKSk7XG4vKipcbiAqIFRoaXMgdHlwZSBvZiBzdHlsZXIgaXMgaW5zdGFudGlhdGVkIHdoZW4gdGhlIHVzZXIgcGFzc2VzIGluIGEgd2lkdGg6aGVpZ2h0IHJhdGlvXG4gKiBmb3IgdGhlIHJvdyBoZWlnaHQuICBFeGFtcGxlIDxtZC1ncmlkLWxpc3QgY29scz1cIjNcIiByb3dIZWlnaHQ9XCIzOjFcIj5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgUmF0aW9UaWxlU3R5bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSYXRpb1RpbGVTdHlsZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJhdGlvVGlsZVN0eWxlcih2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcGFyc2VSYXRpbyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0aWxlXG4gICAgICogQHBhcmFtIHs/fSByb3dJbmRleFxuICAgICAqIEBwYXJhbSB7P30gcGVyY2VudFdpZHRoXG4gICAgICogQHBhcmFtIHs/fSBndXR0ZXJXaWR0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmF0aW9UaWxlU3R5bGVyLnByb3RvdHlwZS5zZXRSb3dTdHlsZXMgPSBmdW5jdGlvbiAodGlsZSwgcm93SW5kZXgsIHBlcmNlbnRXaWR0aCwgZ3V0dGVyV2lkdGgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGVyY2VudEhlaWdodFBlclRpbGUgPSBwZXJjZW50V2lkdGggLyB0aGlzLnJvd0hlaWdodFJhdGlvO1xuICAgICAgICB0aGlzLmJhc2VUaWxlSGVpZ2h0ID0gdGhpcy5nZXRCYXNlVGlsZVNpemUocGVyY2VudEhlaWdodFBlclRpbGUsIGd1dHRlcldpZHRoKTtcbiAgICAgICAgLy8gVXNlIHBhZGRpbmdUb3AgYW5kIG1hcmdpblRvcCB0byBtYWludGFpbiB0aGUgZ2l2ZW4gYXNwZWN0IHJhdGlvLCBhc1xuICAgICAgICAvLyBhIHBlcmNlbnRhZ2UtYmFzZWQgdmFsdWUgZm9yIHRoZXNlIHByb3BlcnRpZXMgaXMgYXBwbGllZCB2ZXJzdXMgdGhlICp3aWR0aCogb2YgdGhlXG4gICAgICAgIC8vIGNvbnRhaW5pbmcgYmxvY2suIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyL2JveC5odG1sI21hcmdpbi1wcm9wZXJ0aWVzXG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCdtYXJnaW5Ub3AnLCB0aGlzLmdldFRpbGVQb3NpdGlvbih0aGlzLmJhc2VUaWxlSGVpZ2h0LCByb3dJbmRleCkpO1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgncGFkZGluZ1RvcCcsIGNhbGModGhpcy5nZXRUaWxlU2l6ZSh0aGlzLmJhc2VUaWxlSGVpZ2h0LCB0aWxlLnJvd3NwYW4pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJhdGlvVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAncGFkZGluZ0JvdHRvbScsIGNhbGModGhpcy5nZXRUaWxlU3Bhbih0aGlzLmJhc2VUaWxlSGVpZ2h0KSArIFwiICsgXCIgKyB0aGlzLmdldEd1dHRlclNwYW4oKSlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJhdGlvVGlsZVN0eWxlci5wcm90b3R5cGUuX3BhcnNlUmF0aW8gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmF0aW9QYXJ0cyA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIGlmIChyYXRpb1BhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWQtZ3JpZC1saXN0OiBpbnZhbGlkIHJhdGlvIGdpdmVuIGZvciByb3ctaGVpZ2h0OiBcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0hlaWdodFJhdGlvID0gcGFyc2VGbG9hdChyYXRpb1BhcnRzWzBdKSAvIHBhcnNlRmxvYXQocmF0aW9QYXJ0c1sxXSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmF0aW9UaWxlU3R5bGVyO1xufShUaWxlU3R5bGVyKSk7XG4vKipcbiAqIFRoaXMgdHlwZSBvZiBzdHlsZXIgaXMgaW5zdGFudGlhdGVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIFwiZml0XCIgcm93IGhlaWdodCBtb2RlLlxuICogSW4gb3RoZXIgd29yZHMsIHRoZSByb3cgaGVpZ2h0IHdpbGwgcmVmbGVjdCB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIgZGl2aWRlZFxuICogYnkgdGhlIG51bWJlciBvZiByb3dzLiAgRXhhbXBsZSA8bWQtZ3JpZC1saXN0IGNvbHM9XCIzXCIgcm93SGVpZ2h0PVwiZml0XCI+XG4gKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBGaXRUaWxlU3R5bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGaXRUaWxlU3R5bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpdFRpbGVTdHlsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0aWxlXG4gICAgICogQHBhcmFtIHs/fSByb3dJbmRleFxuICAgICAqIEBwYXJhbSB7P30gcGVyY2VudFdpZHRoXG4gICAgICogQHBhcmFtIHs/fSBndXR0ZXJXaWR0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRml0VGlsZVN0eWxlci5wcm90b3R5cGUuc2V0Um93U3R5bGVzID0gZnVuY3Rpb24gKHRpbGUsIHJvd0luZGV4LCBwZXJjZW50V2lkdGgsIGd1dHRlcldpZHRoKSB7XG4gICAgICAgIC8vIFBlcmNlbnQgb2YgdGhlIGF2YWlsYWJsZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IG9uZSByb3cgdGFrZXMgdXAuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBlcmNlbnRIZWlnaHRQZXJUaWxlID0gMTAwIC8gdGhpcy5fcm93c3BhbjtcbiAgICAgICAgLy8gRnJhY3Rpb24gb2YgdGhlIGhvcml6b250YWwgZ3V0dGVyIHNpemUgdGhhdCBlYWNoIGNvbHVtbiB0YWtlcyB1cC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ3V0dGVySGVpZ2h0UGVyVGlsZSA9ICh0aGlzLl9yb3dzIC0gMSkgLyB0aGlzLl9yb3dzO1xuICAgICAgICAvLyBCYXNlIHZlcnRpY2FsIHNpemUgb2YgYSBjb2x1bW4uXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VUaWxlSGVpZ2h0ID0gdGhpcy5nZXRCYXNlVGlsZVNpemUocGVyY2VudEhlaWdodFBlclRpbGUsIGd1dHRlckhlaWdodFBlclRpbGUpO1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgndG9wJywgdGhpcy5nZXRUaWxlUG9zaXRpb24oYmFzZVRpbGVIZWlnaHQsIHJvd0luZGV4KSk7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCdoZWlnaHQnLCBjYWxjKHRoaXMuZ2V0VGlsZVNpemUoYmFzZVRpbGVIZWlnaHQsIHRpbGUucm93c3BhbikpKTtcbiAgICB9O1xuICAgIHJldHVybiBGaXRUaWxlU3R5bGVyO1xufShUaWxlU3R5bGVyKSk7XG4vKipcbiAqIFdyYXBzIGEgQ1NTIHN0cmluZyBpbiBhIGNhbGMgZnVuY3Rpb25cbiAqIEBwYXJhbSB7P30gZXhwXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjYWxjKGV4cCkgeyByZXR1cm4gXCJjYWxjKFwiICsgZXhwICsgXCIpXCI7IH1cbi8qKlxuICogQXBwZW5kcyBwaXhlbHMgdG8gYSBDU1Mgc3RyaW5nIGlmIG5vIHVuaXRzIGFyZSBnaXZlbi5cbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZS5tYXRjaCgvcHh8ZW18cmVtLykpID8gdmFsdWUgOiB2YWx1ZSArICdweCc7XG59XG4vLyBUT0RPKGthcmEpOiBDb25kaXRpb25hbCAocmVzcG9uc2l2ZSkgY29sdW1uIGNvdW50IC8gcm93IHNpemUuXG4vLyBUT0RPKGthcmEpOiBSZS1sYXlvdXQgb24gd2luZG93IHJlc2l6ZSAvIG1lZGlhIGNoYW5nZSAoZGVib3VuY2VkKS5cbi8vIFRPRE8oa2FyYSk6IGdyaWRUaWxlSGVhZGVyIGFuZCBncmlkVGlsZUZvb3Rlci5cbnZhciBNRF9GSVRfTU9ERSA9ICdmaXQnO1xudmFyIE1kR3JpZExpc3QgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IF9kaXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZEdyaWRMaXN0KF9yZW5kZXJlciwgX2VsZW1lbnQsIF9kaXIpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aWxlcy4gVGhpcyB3aWxsIGJlIHNvbWV0aGluZyBsaWtlICc1cHgnIG9yICcyZW0nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ3V0dGVyID0gJzFweCc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJjb2xzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBncmlkIGxpc3QuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHM7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9jb2xzID0gY29lcmNlVG9OdW1iZXIodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRHcmlkTGlzdC5wcm90b3R5cGUsIFwiZ3V0dGVyU2l6ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXplIG9mIHRoZSBncmlkIGxpc3QncyBndXR0ZXIgaW4gcGl4ZWxzLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ndXR0ZXI7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9ndXR0ZXIgPSBjb2VyY2VUb1N0cmluZyh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJyb3dIZWlnaHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHJvdyBoZWlnaHQgZnJvbSB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0hlaWdodCA9IGNvZXJjZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFRpbGVTdHlsZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEdyaWRMaXN0LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb2xzKCk7XG4gICAgICAgIHRoaXMuX2NoZWNrUm93SGVpZ2h0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgbGF5b3V0IGNhbGN1bGF0aW9uIGlzIGZhaXJseSBjaGVhcCBpZiBub3RoaW5nIGNoYW5nZXMsIHNvIHRoZXJlJ3MgbGl0dGxlIGNvc3RcbiAgICAgKiB0byBydW4gaXQgZnJlcXVlbnRseS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0VGlsZXMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRocm93IGEgZnJpZW5kbHkgZXJyb3IgaWYgY29scyBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEdyaWRMaXN0LnByb3RvdHlwZS5fY2hlY2tDb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29scykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWQtZ3JpZC1saXN0OiBtdXN0IHBhc3MgaW4gbnVtYmVyIG9mIGNvbHVtbnMuIFwiICtcbiAgICAgICAgICAgICAgICBcIkV4YW1wbGU6IDxtZC1ncmlkLWxpc3QgY29scz1cXFwiM1xcXCI+XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHRvIGVxdWFsIHdpZHRoOmhlaWdodCBpZiByb3dIZWlnaHQgcHJvcGVydHkgaXMgbWlzc2luZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUuX2NoZWNrUm93SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvd0hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0eWxlciA9IG5ldyBSYXRpb1RpbGVTdHlsZXIoJzE6MScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNvcnJlY3QgVGlsZSBTdHlsZXIgc3VidHlwZSBiYXNlZCBvbiByb3dIZWlnaHQgcGFzc2VkIGluIGJ5IHVzZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLl9zZXRUaWxlU3R5bGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcm93SGVpZ2h0ID09PSBNRF9GSVRfTU9ERSkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0eWxlciA9IG5ldyBGaXRUaWxlU3R5bGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcm93SGVpZ2h0ICYmIHRoaXMuX3Jvd0hlaWdodC5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0eWxlciA9IG5ldyBSYXRpb1RpbGVTdHlsZXIodGhpcy5fcm93SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdHlsZXIgPSBuZXcgRml4ZWRUaWxlU3R5bGVyKHRoaXMuX3Jvd0hlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGFuZCBhcHBsaWVzIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBmb3IgYWxsIGNoaWxkcmVuIGdyaWQgdGlsZXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEdyaWRMaXN0LnByb3RvdHlwZS5fbGF5b3V0VGlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYWNrZXIgPSBuZXcgVGlsZUNvb3JkaW5hdG9yKHRoaXMuY29scywgdGhpcy5fdGlsZXMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3Rpb24gPSB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICAgICAgdGhpcy5fdGlsZVN0eWxlci5pbml0KHRoaXMuZ3V0dGVyU2l6ZSwgdHJhY2tlciwgdGhpcy5jb2xzLCBkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLl90aWxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0aWxlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zID0gdHJhY2tlci5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgX3RoaXMuX3RpbGVTdHlsZXIuc2V0U3R5bGUodGlsZSwgcG9zLnJvdywgcG9zLmNvbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZXRMaXN0U3R5bGUodGhpcy5fdGlsZVN0eWxlci5nZXRDb21wdXRlZEhlaWdodCgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgc3R5bGUgb24gdGhlIG1haW4gZ3JpZC1saXN0IGVsZW1lbnQsIGdpdmVuIHRoZSBzdHlsZSBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEdyaWRMaXN0LnByb3RvdHlwZS5fc2V0TGlzdFN0eWxlID0gZnVuY3Rpb24gKHN0eWxlJCQxKSB7XG4gICAgICAgIGlmIChzdHlsZSQkMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCBzdHlsZSQkMVswXSwgc3R5bGUkJDFbMV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWRHcmlkTGlzdDtcbn0oKSk7XG5NZEdyaWRMaXN0LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtZ3JpZC1saXN0LCBtYXQtZ3JpZC1saXN0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2PiA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IDwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1ncmlkLWxpc3R7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LWdyaWQtdGlsZXtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbn0ubWF0LWdyaWQtdGlsZSAubWF0LWZpZ3VyZXtkaXNwbGF5OmZsZXg7cG9zaXRpb246YWJzb2x1dGU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7aGVpZ2h0OjEwMCU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7cGFkZGluZzowO21hcmdpbjowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3RlciwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtoZWlnaHQ6NDhweDtjb2xvcjojZmZmO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMzgpO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjAgMTZweDtmb250LXNpemU6MTZweDtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7cmlnaHQ6MH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXIgLm1hdC1saW5lLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlciAubWF0LWxpbmV7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3RlciAubWF0LWxpbmU6bnRoLWNoaWxkKG4rMiksLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVyIC5tYXQtbGluZTpudGgtY2hpbGQobisyKXtmb250LXNpemU6MTJweH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXI+KiwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXI+KnttYXJnaW46MDtwYWRkaW5nOjA7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc2l6ZTppbmhlcml0fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3Rlci5tYXQtMi1saW5lLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlci5tYXQtMi1saW5le2hlaWdodDo2OHB4fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1saXN0LXRleHR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt3aWR0aDoxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpoaWRkZW59Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWxpc3QtdGV4dD4qe21hcmdpbjowO3BhZGRpbmc6MDtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOmluaGVyaXR9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWxpc3QtdGV4dDplbXB0eXtkaXNwbGF5Om5vbmV9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVye3RvcDowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3Rlcntib3R0b206MH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtYXZhdGFye3BhZGRpbmctcmlnaHQ6MTZweH1bZGlyPXJ0bF0gLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWF2YXRhcntwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy1sZWZ0OjE2cHh9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWF2YXRhcjplbXB0eXtkaXNwbGF5Om5vbmV9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPWdyaWQtbGlzdC5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ2xpc3QnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1ncmlkLWxpc3RdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRHcmlkTGlzdC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBEaXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbk1kR3JpZExpc3QucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ190aWxlcyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kR3JpZFRpbGUsXSB9LF0sXG4gICAgJ2NvbHMnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2d1dHRlclNpemUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3Jvd0hlaWdodCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG52YXIgTWRHcmlkTGlzdE1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kR3JpZExpc3RNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEdyaWRMaXN0TW9kdWxlO1xufSgpKTtcbk1kR3JpZExpc3RNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNZExpbmVNb2R1bGUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kR3JpZExpc3QsXG4gICAgICAgICAgICAgICAgICAgIE1kR3JpZFRpbGUsXG4gICAgICAgICAgICAgICAgICAgIE1kR3JpZFRpbGVUZXh0LFxuICAgICAgICAgICAgICAgICAgICBNZExpbmVNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZEdyaWRUaWxlSGVhZGVyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZEdyaWRUaWxlRm9vdGVyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZEdyaWRBdmF0YXJDc3NNYXRTdHlsZXJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBNZEdyaWRMaXN0LFxuICAgICAgICAgICAgICAgICAgICBNZEdyaWRUaWxlLFxuICAgICAgICAgICAgICAgICAgICBNZEdyaWRUaWxlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWRHcmlkQXZhdGFyQ3NzTWF0U3R5bGVyXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRHcmlkTGlzdE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBDb250ZW50IG9mIGEgY2FyZCwgbmVlZGVkIGFzIGl0J3MgdXNlZCBhcyBhIHNlbGVjdG9yIGluIHRoZSBBUEkuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2FyZENvbnRlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRDb250ZW50KCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkQ29udGVudDtcbn0oKSk7XG5NZENhcmRDb250ZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLWNvbnRlbnQsIG1hdC1jYXJkLWNvbnRlbnQnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC1jb250ZW50XSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkQ29udGVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBUaXRsZSBvZiBhIGNhcmQsIG5lZWRlZCBhcyBpdCdzIHVzZWQgYXMgYSBzZWxlY3RvciBpbiB0aGUgQVBJLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZENhcmRUaXRsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZFRpdGxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkVGl0bGU7XG59KCkpO1xuTWRDYXJkVGl0bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWNhcmQtdGl0bGUsIG1hdC1jYXJkLXRpdGxlLCBbbWQtY2FyZC10aXRsZV0sIFttYXQtY2FyZC10aXRsZV0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC10aXRsZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FyZFRpdGxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFN1Yi10aXRsZSBvZiBhIGNhcmQsIG5lZWRlZCBhcyBpdCdzIHVzZWQgYXMgYSBzZWxlY3RvciBpbiB0aGUgQVBJLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZENhcmRTdWJ0aXRsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZFN1YnRpdGxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkU3VidGl0bGU7XG59KCkpO1xuTWRDYXJkU3VidGl0bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWNhcmQtc3VidGl0bGUsIG1hdC1jYXJkLXN1YnRpdGxlLCBbbWQtY2FyZC1zdWJ0aXRsZV0sIFttYXQtY2FyZC1zdWJ0aXRsZV0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC1zdWJ0aXRsZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FyZFN1YnRpdGxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEFjdGlvbiBzZWN0aW9uIG9mIGEgY2FyZCwgbmVlZGVkIGFzIGl0J3MgdXNlZCBhcyBhIHNlbGVjdG9yIGluIHRoZSBBUEkuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2FyZEFjdGlvbnMgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRBY3Rpb25zKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkQWN0aW9ucztcbn0oKSk7XG5NZENhcmRBY3Rpb25zLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLWFjdGlvbnMsIG1hdC1jYXJkLWFjdGlvbnMnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC1hY3Rpb25zXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkQWN0aW9ucy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBGb290ZXIgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkRm9vdGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkRm9vdGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkRm9vdGVyO1xufSgpKTtcbk1kQ2FyZEZvb3Rlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC1mb290ZXIsIG1hdC1jYXJkLWZvb3RlcicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLWZvb3Rlcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FyZEZvb3Rlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBJbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkU21JbWFnZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZFNtSW1hZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRTbUltYWdlO1xufSgpKTtcbk1kQ2FyZFNtSW1hZ2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1jYXJkLXNtLWltYWdlXSwgW21hdC1jYXJkLXNtLWltYWdlXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLXNtLWltYWdlXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkU21JbWFnZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBJbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkTWRJbWFnZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZE1kSW1hZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRNZEltYWdlO1xufSgpKTtcbk1kQ2FyZE1kSW1hZ2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1jYXJkLW1kLWltYWdlXSwgW21hdC1jYXJkLW1kLWltYWdlXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLW1kLWltYWdlXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkTWRJbWFnZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBJbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkTGdJbWFnZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZExnSW1hZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRMZ0ltYWdlO1xufSgpKTtcbk1kQ2FyZExnSW1hZ2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1jYXJkLWxnLWltYWdlXSwgW21hdC1jYXJkLWxnLWltYWdlXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MubWF0LWNhcmQtbGctaW1hZ2UnOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FyZExnSW1hZ2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogSW1hZ2UgdXNlZCBpbiBhIGNhcmQsIG5lZWRlZCB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2FyZEltYWdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkSW1hZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRJbWFnZTtcbn0oKSk7XG5NZENhcmRJbWFnZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWNhcmQtaW1hZ2VdLCBbbWF0LWNhcmQtaW1hZ2VdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQtaW1hZ2VdJzogJ3RydWUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENhcmRJbWFnZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBMYXJnZSBpbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkWGxJbWFnZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZFhsSW1hZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRYbEltYWdlO1xufSgpKTtcbk1kQ2FyZFhsSW1hZ2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1jYXJkLXhsLWltYWdlXSwgW21hdC1jYXJkLXhsLWltYWdlXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLXhsLWltYWdlXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkWGxJbWFnZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBBdmF0YXIgaW1hZ2UgdXNlZCBpbiBhIGNhcmQsIG5lZWRlZCB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2FyZEF2YXRhciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZEF2YXRhcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ2FyZEF2YXRhcjtcbn0oKSk7XG5NZENhcmRBdmF0YXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1jYXJkLWF2YXRhcl0sIFttYXQtY2FyZC1hdmF0YXJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQtYXZhdGFyXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkQXZhdGFyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEEgYmFzaWMgY29udGVudCBjb250YWluZXIgY29tcG9uZW50IHRoYXQgYWRkcyB0aGUgc3R5bGVzIG9mIGEgTWF0ZXJpYWwgZGVzaWduIGNhcmQuXG4gKlxuICogV2hpbGUgdGhpcyBjb21wb25lbnQgY2FuIGJlIHVzZWQgYWxvbmUsIGl0IGFsc28gcHJvdmlkZXMgYSBudW1iZXJcbiAqIG9mIHByZXNldCBzdHlsZXMgZm9yIGNvbW1vbiBjYXJkIHNlY3Rpb25zLCBpbmNsdWRpbmc6XG4gKiAtIG1kLWNhcmQtdGl0bGVcbiAqIC0gbWQtY2FyZC1zdWJ0aXRsZVxuICogLSBtZC1jYXJkLWNvbnRlbnRcbiAqIC0gbWQtY2FyZC1hY3Rpb25zXG4gKiAtIG1kLWNhcmQtZm9vdGVyXG4gKi9cbnZhciBNZENhcmQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmQoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmQ7XG59KCkpO1xuTWRDYXJkLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtY2FyZCwgbWF0LWNhcmQnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD4gXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWNhcmR7dHJhbnNpdGlvbjpib3gtc2hhZG93IDI4MG1zIGN1YmljLWJlemllciguNCwwLC4yLDEpO3dpbGwtY2hhbmdlOmJveC1zaGFkb3c7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjI0cHg7Ym9yZGVyLXJhZGl1czoycHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZn0ubWF0LWNhcmQ6bm90KFtjbGFzcyo9bWF0LWVsZXZhdGlvbi16XSl7Ym94LXNoYWRvdzowIDNweCAxcHggLTJweCByZ2JhKDAsMCwwLC4yKSwwIDJweCAycHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMTIpfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtY2FyZHtvdXRsaW5lOnNvbGlkIDFweH19Lm1hdC1jYXJkLWZsYXR7Ym94LXNoYWRvdzpub25lfS5tYXQtY2FyZC1hY3Rpb25zLC5tYXQtY2FyZC1jb250ZW50LC5tYXQtY2FyZC1zdWJ0aXRsZSwubWF0LWNhcmQtdGl0bGV7ZGlzcGxheTpibG9jazttYXJnaW4tYm90dG9tOjE2cHh9Lm1hdC1jYXJkLXRpdGxle2ZvbnQtc2l6ZToyNHB4O2ZvbnQtd2VpZ2h0OjQwMH0ubWF0LWNhcmQtc3VidGl0bGV7Zm9udC1zaXplOjE0cHh9Lm1hdC1jYXJkLWNvbnRlbnR7Zm9udC1zaXplOjE0cHh9Lm1hdC1jYXJkLWFjdGlvbnN7bWFyZ2luLWxlZnQ6LTE2cHg7bWFyZ2luLXJpZ2h0Oi0xNnB4O3BhZGRpbmc6OHB4IDB9Lm1hdC1jYXJkLWFjdGlvbnNbYWxpZ249ZW5kXXtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfS5tYXQtY2FyZC1pbWFnZXt3aWR0aDpjYWxjKDEwMCUgKyA0OHB4KTttYXJnaW46MCAtMjRweCAxNnB4IC0yNHB4fS5tYXQtY2FyZC14bC1pbWFnZXt3aWR0aDoyNDBweDtoZWlnaHQ6MjQwcHg7bWFyZ2luOi04cHh9Lm1hdC1jYXJkLWZvb3Rlcntwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxMDAlO21pbi1oZWlnaHQ6NXB4O2JvdHRvbTowO2xlZnQ6MH0ubWF0LWNhcmQtYWN0aW9ucyAubWF0LWJ1dHRvbiwubWF0LWNhcmQtYWN0aW9ucyAubWF0LXJhaXNlZC1idXR0b257bWFyZ2luOjAgNHB4fS5tYXQtY2FyZC1oZWFkZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvd30ubWF0LWNhcmQtaGVhZGVyLXRleHR7bWFyZ2luOjAgOHB4fS5tYXQtY2FyZC1hdmF0YXJ7aGVpZ2h0OjQwcHg7d2lkdGg6NDBweDtib3JkZXItcmFkaXVzOjUwJTtmbGV4LXNocmluazowfS5tYXQtY2FyZC1oZWFkZXIgLm1hdC1jYXJkLXRpdGxle2ZvbnQtc2l6ZToxNHB4fS5tYXQtY2FyZC1sZy1pbWFnZSwubWF0LWNhcmQtbWQtaW1hZ2UsLm1hdC1jYXJkLXNtLWltYWdle21hcmdpbjotOHB4IDB9Lm1hdC1jYXJkLXRpdGxlLWdyb3Vwe2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjttYXJnaW46MCAtOHB4fS5tYXQtY2FyZC1zbS1pbWFnZXt3aWR0aDo4MHB4O2hlaWdodDo4MHB4fS5tYXQtY2FyZC1tZC1pbWFnZXt3aWR0aDoxMTJweDtoZWlnaHQ6MTEycHh9Lm1hdC1jYXJkLWxnLWltYWdle3dpZHRoOjE1MnB4O2hlaWdodDoxNTJweH1AbWVkaWEgKG1heC13aWR0aDo2MDBweCl7Lm1hdC1jYXJke3BhZGRpbmc6MjRweCAxNnB4fS5tYXQtY2FyZC1hY3Rpb25ze21hcmdpbi1sZWZ0Oi04cHg7bWFyZ2luLXJpZ2h0Oi04cHh9Lm1hdC1jYXJkLWltYWdle3dpZHRoOmNhbGMoMTAwJSArIDMycHgpO21hcmdpbjoxNnB4IC0xNnB4fS5tYXQtY2FyZC10aXRsZS1ncm91cHttYXJnaW46MH0ubWF0LWNhcmQteGwtaW1hZ2V7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0ubWF0LWNhcmQtaGVhZGVye21hcmdpbjotOHB4IDAgMCAwfX0ubWF0LWNhcmQtY29udGVudD46Zmlyc3QtY2hpbGQsLm1hdC1jYXJkPjpmaXJzdC1jaGlsZHttYXJnaW4tdG9wOjB9Lm1hdC1jYXJkLWNvbnRlbnQ+Omxhc3QtY2hpbGQsLm1hdC1jYXJkPjpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH0ubWF0LWNhcmQtaW1hZ2U6Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDotMjRweH0ubWF0LWNhcmQ+Lm1hdC1jYXJkLWFjdGlvbnM6bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOi0xNnB4O3BhZGRpbmctYm90dG9tOjB9Lm1hdC1jYXJkLWFjdGlvbnMgLm1hdC1idXR0b246Zmlyc3QtY2hpbGQsLm1hdC1jYXJkLWFjdGlvbnMgLm1hdC1yYWlzZWQtYnV0dG9uOmZpcnN0LWNoaWxke21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjB9Lm1hdC1jYXJkLXN1YnRpdGxlOm5vdCg6Zmlyc3QtY2hpbGQpLC5tYXQtY2FyZC10aXRsZTpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tdG9wOi00cHh9Lm1hdC1jYXJkLWhlYWRlciAubWF0LWNhcmQtc3VidGl0bGU6bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLXRvcDotOHB4fS5tYXQtY2FyZD4ubWF0LWNhcmQteGwtaW1hZ2U6Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDotOHB4fS5tYXQtY2FyZD4ubWF0LWNhcmQteGwtaW1hZ2U6bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOi04cHh9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPWNhcmQuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmRdJzogJ3RydWUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENhcmQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQ29tcG9uZW50IGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aGluIHRoZSBgPG1kLWNhcmQ+YCBjb21wb25lbnQuIEl0IGFkZHMgc3R5bGVzIGZvciBhXG4gKiBwcmVzZXQgaGVhZGVyIHNlY3Rpb24gKGkuZS4gYSB0aXRsZSwgc3VidGl0bGUsIGFuZCBhdmF0YXIgbGF5b3V0KS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkSGVhZGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkSGVhZGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkSGVhZGVyO1xufSgpKTtcbk1kQ2FyZEhlYWRlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLWNhcmQtaGVhZGVyLCBtYXQtY2FyZC1oZWFkZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLWNhcmQtYXZhdGFyXSwgW21hdC1jYXJkLWF2YXRhcl1cXFwiPjwvbmctY29udGVudD4gPGRpdiBjbGFzcz1cXFwibWF0LWNhcmQtaGVhZGVyLXRleHRcXFwiPiA8bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLWNhcmQtdGl0bGUsIG1hdC1jYXJkLXRpdGxlLCBtZC1jYXJkLXN1YnRpdGxlLCBtYXQtY2FyZC1zdWJ0aXRsZSwgW21kLWNhcmQtdGl0bGVdLCBbbWF0LWNhcmQtdGl0bGVdLCBbbWQtY2FyZC1zdWJ0aXRsZV0sIFttYXQtY2FyZC1zdWJ0aXRsZV1cXFwiPjwvbmctY29udGVudD4gPC9kaXY+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gXCIsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQtaGVhZGVyXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkSGVhZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIENvbXBvbmVudCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGhpbiB0aGUgPG1kLWNhcmQ+IGNvbXBvbmVudC4gSXQgYWRkcyBzdHlsZXMgZm9yIGEgcHJlc2V0XG4gKiBsYXlvdXQgdGhhdCBncm91cHMgYW4gaW1hZ2Ugd2l0aCBhIHRpdGxlIHNlY3Rpb24uXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2FyZFRpdGxlR3JvdXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRUaXRsZUdyb3VwKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkVGl0bGVHcm91cDtcbn0oKSk7XG5NZENhcmRUaXRsZUdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtY2FyZC10aXRsZS1ncm91cCwgbWF0LWNhcmQtdGl0bGUtZ3JvdXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXY+IDxuZy1jb250ZW50IHNlbGVjdD1cXFwibWQtY2FyZC10aXRsZSwgbWF0LWNhcmQtdGl0bGUsIG1kLWNhcmQtc3VidGl0bGUsIG1hdC1jYXJkLXN1YnRpdGxlLCBbbWQtY2FyZC10aXRsZV0sIFttYXQtY2FyZC10aXRsZV0sIFttZC1jYXJkLXN1YnRpdGxlXSwgW21hdC1jYXJkLXN1YnRpdGxlXVxcXCI+PC9uZy1jb250ZW50PiA8L2Rpdj4gPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJpbWdcXFwiPjwvbmctY29udGVudD4gPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiBcIixcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC10aXRsZS1ncm91cF0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FyZFRpdGxlR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbnZhciBNZENhcmRNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRNb2R1bGU7XG59KCkpO1xuTWRDYXJkTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkLFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kQ2FyZFRpdGxlR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIE1kQ2FyZENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIE1kQ2FyZFRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRTdWJ0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkRm9vdGVyLFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRTbUltYWdlLFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRNZEltYWdlLFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRMZ0ltYWdlLFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkWGxJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkQXZhdGFyLFxuICAgICAgICAgICAgICAgICAgICBNZENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBNZENhcmQsIE1kQ2FyZEhlYWRlciwgTWRDYXJkVGl0bGVHcm91cCwgTWRDYXJkQ29udGVudCwgTWRDYXJkVGl0bGUsIE1kQ2FyZFN1YnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRBY3Rpb25zLCBNZENhcmRGb290ZXIsIE1kQ2FyZFNtSW1hZ2UsIE1kQ2FyZE1kSW1hZ2UsIE1kQ2FyZExnSW1hZ2UsIE1kQ2FyZEltYWdlLFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRYbEltYWdlLCBNZENhcmRBdmF0YXIsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIE1hdGVyaWFsIGRlc2lnbiBzdHlsZWQgQ2hpcCBjb21wb25lbnQuIFVzZWQgaW5zaWRlIHRoZSBNZENoaXBMaXN0IGNvbXBvbmVudC5cbiAqL1xudmFyIE1kQ2hpcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kQ2hpcChfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgY2hpcCBpcyBkaXNhYmxlZC4gRGlzYWJsZWQgY2hpcHMgY2Fubm90IGJlIGZvY3VzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgY2hpcCBpcyBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFsZXR0ZSBjb2xvciBvZiBzZWxlY3RlZCBjaGlwcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvbG9yID0gJ3ByaW1hcnknO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHRlZCB3aGVuIHRoZSBjaGlwIGlzIGZvY3VzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIGNoaXAgaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgY2hpcCBpcyBkZXNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgY2hpcCBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGlwLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWRkRGVmYXVsdENTU0NsYXNzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yKHRoaXMuX2NvbG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGlwLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95LmVtaXQoeyBjaGlwOiB0aGlzIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hpcC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGNoaXAgaXMgZGlzYWJsZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBjaGlwLlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpID8gdHJ1ZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoaXAucHJvdG90eXBlLCBcIl9pc0FyaWFEaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBkaXNhYmxlZCBzdGF0ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhjb2VyY2VCb29sZWFuUHJvcGVydHkodGhpcy5kaXNhYmxlZCkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGlwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGNoaXAgaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHsgY2hpcDogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3QuZW1pdCh7IGNoaXA6IHRoaXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgc3RhdGUgb2YgdGhpcyBjaGlwLlxuICAgICAqIEByZXR1cm4gez99IFdoZXRoZXIgdGhlIGNoaXAgaXMgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgTWRDaGlwLnByb3RvdHlwZS50b2dnbGVTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9ICF0aGlzLnNlbGVjdGVkO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoaXAucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xvciBvZiB0aGUgY2hpcC4gQ2FuIGJlIGBwcmltYXJ5YCwgYGFjY2VudGAsIG9yIGB3YXJuYC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWxsb3dzIGZvciBwcm9ncmFtbWF0aWMgZm9jdXNpbmcgb2YgdGhlIGNoaXAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoaXAucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoeyBjaGlwOiB0aGlzIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBldmVudHMgZmlyZSBwcm9wZXJseSB1cG9uIGNsaWNrLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hpcC5wcm90b3R5cGUuX2hhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIENoZWNrIGRpc2FibGVkXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBhcHByb3ByaWF0ZSBDU1MgY2xhc3NlcyBiYXNlZCBvbiB0aGUgY2hpcCB0eXBlIChiYXNpYyBvciBzdGFuZGFyZCkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoaXAucHJvdG90eXBlLl9hZGREZWZhdWx0Q1NTQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAvLyBBbHdheXMgYWRkIHRoZSBgbWF0LWNoaXBgIGNsYXNzXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKGVsLCAnbWF0LWNoaXAnKTtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGEgYmFzaWMgY2hpcCwgYWxzbyBhZGQgdGhlIGBtYXQtYmFzaWMtY2hpcGAgY2xhc3MgZm9yIDpub3QoKSB0YXJnZXRpbmdcbiAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ21hdC1iYXNpYy1jaGlwJyB8fCBlbC5oYXNBdHRyaWJ1dGUoJ21hdC1iYXNpYy1jaGlwJykgfHxcbiAgICAgICAgICAgIGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ21kLWJhc2ljLWNoaXAnIHx8IGVsLmhhc0F0dHJpYnV0ZSgnbWQtYmFzaWMtY2hpcCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhlbCwgJ21hdC1iYXNpYy1jaGlwJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHByaXZhdGUgX2NvbG9yIHZhcmlhYmxlIGFuZCB0aGUgbmF0aXZlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHs/fSBuZXdDb2xvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGlwLnByb3RvdHlwZS5fdXBkYXRlQ29sb3IgPSBmdW5jdGlvbiAobmV3Q29sb3IpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKHRoaXMuX2NvbG9yLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcihuZXdDb2xvciwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gbmV3Q29sb3I7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXQtY29sb3Igb24gdGhlIG5hdGl2ZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7P30gY29sb3JcbiAgICAgKiBAcGFyYW0gez99IGlzQWRkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoaXAucHJvdG90eXBlLl9zZXRFbGVtZW50Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIGlzQWRkKSB7XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIGNvbG9yICE9ICcnKSB7XG4gICAgICAgICAgICBpZiAoaXNBZGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwibWF0LVwiICsgY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIGNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kQ2hpcDtcbn0oKSk7XG5NZENoaXAuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCJtZC1iYXNpYy1jaGlwLCBbbWQtYmFzaWMtY2hpcF0sIG1kLWNoaXAsIFttZC1jaGlwXSxcXG4gICAgICAgICAgICAgbWF0LWJhc2ljLWNoaXAsIFttYXQtYmFzaWMtY2hpcF0sIG1hdC1jaGlwLCBbbWF0LWNoaXBdXCIsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2hpcF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICd0YWJpbmRleCc6ICctMScsXG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ29wdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoaXAtc2VsZWN0ZWRdJzogJ3NlbGVjdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdfaXNBcmlhRGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdfaGFuZGxlQ2xpY2soJGV2ZW50KSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2hpcC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG5dOyB9O1xuTWRDaGlwLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdzZWxlY3QnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdkZXNlbGVjdCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2Rlc3Ryb3knOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc2VsZWN0ZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NvbG9yJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbi8qKlxuICogQSBtYXRlcmlhbCBkZXNpZ24gY2hpcHMgY29tcG9uZW50IChuYW1lZCBDaGlwTGlzdCBmb3IgaXQncyBzaW1pbGFyaXR5IHRvIHRoZSBMaXN0IGNvbXBvbmVudCkuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgPG1kLWNoaXAtbGlzdD5cbiAqICAgICAgIDxtZC1jaGlwPkNoaXAgMTxtZC1jaGlwPlxuICogICAgICAgPG1kLWNoaXA+Q2hpcCAyPG1kLWNoaXA+XG4gKiAgICAgPC9tZC1jaGlwLWxpc3Q+XG4gKi9cbnZhciBNZENoaXBMaXN0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDaGlwTGlzdCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoaWNoIGNoaXBzIHdlJ3JlIGxpc3RlbmluZyB0byBmb3IgZm9jdXMvZGVzdHJ1Y3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVkID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBjaGlwIGlzIHNlbGVjdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRhYiBpbmRleCBmb3IgdGhlIGNoaXAgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RhYkluZGV4ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIgPSBuZXcgRm9jdXNLZXlNYW5hZ2VyKHRoaXMuY2hpcHMpLndpdGhXcmFwKCk7XG4gICAgICAgIC8vIFByZXZlbnRzIHRoZSBjaGlwIGxpc3QgZnJvbSBjYXB0dXJpbmcgZm9jdXMgYW5kIHJlZGlyZWN0aW5nXG4gICAgICAgIC8vIGl0IGJhY2sgdG8gdGhlIGZpcnN0IGNoaXAgd2hlbiB0aGUgdXNlciB0YWJzIG91dC5cbiAgICAgICAgdGhpcy5fdGFiT3V0U3Vic2NyaXB0aW9uID0gdGhpcy5fa2V5TWFuYWdlci50YWJPdXQuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl90YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdGFiSW5kZXggPSAwOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEdvIGFoZWFkIGFuZCBzdWJzY3JpYmUgYWxsIG9mIHRoZSBpbml0aWFsIGNoaXBzXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZUNoaXBzKHRoaXMuY2hpcHMpO1xuICAgICAgICAvLyBXaGVuIHRoZSBsaXN0IGNoYW5nZXMsIHJlLXN1YnNjcmliZVxuICAgICAgICB0aGlzLmNoaXBzLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uIChjaGlwcykge1xuICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmliZUNoaXBzKGNoaXBzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hpcExpc3QucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdGFiT3V0U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJPdXRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hpcExpc3QucHJvdG90eXBlLCBcInNlbGVjdGFibGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyBjaGlwIGlzIHNlbGVjdGFibGUuIFdoZW4gYSBjaGlwIGlzIG5vdCBzZWxlY3RhYmxlLFxuICAgICAgICAgKiBpdCdzIHNlbGVjdGVkIHN0YXRlIGlzIGFsd2F5cyBpZ25vcmVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zZWxlY3RhYmxlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGFibGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9ncmFtbWF0aWNhbGx5IGZvY3VzIHRoZSBjaGlwIGxpc3QuIFRoaXMgaW4gdHVybiBmb2N1c2VzIHRoZSBmaXJzdFxuICAgICAqIG5vbi1kaXNhYmxlZCBjaGlwIGluIHRoaXMgY2hpcCBsaXN0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IEFSSUEgc2F5cyB0aGlzIHNob3VsZCBmb2N1cyB0aGUgZmlyc3QgYHNlbGVjdGVkYCBjaGlwLlxuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEZpcnN0SXRlbUFjdGl2ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFzc2VzIHJlbGV2YW50IGtleSBwcmVzc2VzIHRvIG91ciBrZXkgbWFuYWdlci5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5fa2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YXJnZXQgPSAoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgLy8gSWYgdGhleSBhcmUgb24gYSBjaGlwLCBjaGVjayBmb3Igc3BhY2UvbGVmdC9yaWdodCwgb3RoZXJ3aXNlIHBhc3MgdG8gb3VyIGtleSBtYW5hZ2VyXG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnbWF0LWNoaXAnKSkge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHNlbGVjdGFibGUsIHRvZ2dsZSB0aGUgZm9jdXNlZCBjaGlwXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZVNlbGVjdE9uRm9jdXNlZENoaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgcHJldmVudCBzcGFjZSBmcm9tIHNjcm9sbGluZyB0aGUgcGFnZSBzaW5jZSB0aGUgbGlzdCBoYXMgZm9jdXNcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldFByZXZpb3VzSXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldE5leHRJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGNoaXAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5fdG9nZ2xlU2VsZWN0T25Gb2N1c2VkQ2hpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQWxsb3cgZGlzYWJsaW5nIG9mIGNoaXAgc2VsZWN0aW9uXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9jdXNlZEluZGV4ID0gdGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtSW5kZXg7XG4gICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkSW5kZXgoZm9jdXNlZEluZGV4KSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9jdXNlZENoaXAgPSB0aGlzLmNoaXBzLnRvQXJyYXkoKVtmb2N1c2VkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGZvY3VzZWRDaGlwKSB7XG4gICAgICAgICAgICAgICAgZm9jdXNlZENoaXAudG9nZ2xlU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIGNoaXBzIGFuZCBhZGQgdGhlbSB0byBvdXIgbGlzdCBvZlxuICAgICAqIHN1YnNjcmliZWQgY2hpcHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGNoaXBzIFRoZSBsaXN0IG9mIGNoaXBzIHRvIGJlIHN1YnNjcmliZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5fc3Vic2NyaWJlQ2hpcHMgPSBmdW5jdGlvbiAoY2hpcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY2hpcHMuZm9yRWFjaChmdW5jdGlvbiAoY2hpcCkgeyByZXR1cm4gX3RoaXMuX2FkZENoaXAoY2hpcCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgc3BlY2lmaWMgY2hpcCB0byBvdXIgc3Vic2NyaWJlZCBsaXN0LiBJZiB0aGUgY2hpcCBoYXNcbiAgICAgKiBhbHJlYWR5IGJlZW4gc3Vic2NyaWJlZCwgdGhpcyBlbnN1cmVzIGl0IGlzIG9ubHkgc3Vic2NyaWJlZFxuICAgICAqIG9uY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGNoaXAgVGhlIGNoaXAgdG8gYmUgc3Vic2NyaWJlZCAob3IgY2hlY2tlZCBmb3IgZXhpc3RpbmdcbiAgICAgKiBzdWJzY3JpcHRpb24pLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUuX2FkZENoaXAgPSBmdW5jdGlvbiAoY2hpcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGJlZW4gc3Vic2NyaWJlZCB0byBhIHBhcmVudCwgZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaWJlZC5oYXMoY2hpcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYXRjaCBmb3IgZm9jdXMgZXZlbnRzIG91dHNpZGUgb2YgdGhlIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAgICAgY2hpcC5vbkZvY3VzLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlwSW5kZXggPSBfdGhpcy5jaGlwcy50b0FycmF5KCkuaW5kZXhPZihjaGlwKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNWYWxpZEluZGV4KGNoaXBJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5TWFuYWdlci51cGRhdGVBY3RpdmVJdGVtSW5kZXgoY2hpcEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9uIGRlc3Ryb3ksIHJlbW92ZSB0aGUgaXRlbSBmcm9tIG91ciBsaXN0LCBhbmQgY2hlY2sgZm9jdXNcbiAgICAgICAgY2hpcC5kZXN0cm95LnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlwSW5kZXggPSBfdGhpcy5jaGlwcy50b0FycmF5KCkuaW5kZXhPZihjaGlwKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNWYWxpZEluZGV4KGNoaXBJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBjaGlwIGlzIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAoY2hpcEluZGV4IDwgX3RoaXMuY2hpcHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKGNoaXBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaXBJbmRleCAtIDEgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKGNoaXBJbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpYmVkLmRlbGV0ZShjaGlwKTtcbiAgICAgICAgICAgIGNoaXAuZGVzdHJveS51bnN1YnNjcmliZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlZC5zZXQoY2hpcCwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IHRvIGVuc3VyZSBhbGwgaW5kZXhlcyBhcmUgdmFsaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGluZGV4IFRoZSBpbmRleCB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm4gez99IFRydWUgaWYgdGhlIGluZGV4IGlzIHZhbGlkIGZvciBvdXIgbGlzdCBvZiBjaGlwcy5cbiAgICAgKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5faXNWYWxpZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5jaGlwcy5sZW5ndGg7XG4gICAgfTtcbiAgICByZXR1cm4gTWRDaGlwTGlzdDtcbn0oKSk7XG5NZENoaXBMaXN0LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtY2hpcC1saXN0LCBtYXQtY2hpcC1saXN0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtY2hpcC1saXN0LXdyYXBwZXJcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLnRhYmluZGV4XSc6ICdfdGFiSW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdsaXN0Ym94JyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2hpcC1saXN0XSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gRXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ2ZvY3VzKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19rZXlkb3duKCRldmVudCknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNoaXBzOiBuZXcgQ29udGVudENoaWxkcmVuKE1kQ2hpcClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1jaGlwLWxpc3Qtd3JhcHBlcntkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWl0ZW1zOmZsZXgtc3RhcnR9Lm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApe2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6OHB4IDEycHggOHB4IDEycHg7Ym9yZGVyLXJhZGl1czoyNHB4O2ZvbnQtc2l6ZToxM3B4O2xpbmUtaGVpZ2h0OjE2cHh9Lm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApKy5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKXttYXJnaW46MCAwIDAgM3B4fVtkaXI9cnRsXSAubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCkrLm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApe21hcmdpbjowIDNweCAwIDB9Lm1hdC1jaGlwLWxpc3Qtc3RhY2tlZCAubWF0LWNoaXAtbGlzdC13cmFwcGVye2Rpc3BsYXk6YmxvY2t9Lm1hdC1jaGlwLWxpc3Qtc3RhY2tlZCAubWF0LWNoaXAtbGlzdC13cmFwcGVyIC5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKXtkaXNwbGF5OmJsb2NrO21hcmdpbjowO21hcmdpbi1ib3R0b206OHB4fVtkaXI9cnRsXSAubWF0LWNoaXAtbGlzdC1zdGFja2VkIC5tYXQtY2hpcC1saXN0LXdyYXBwZXIgLm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApe21hcmdpbjowO21hcmdpbi1ib3R0b206OHB4fS5tYXQtY2hpcC1saXN0LXN0YWNrZWQgLm1hdC1jaGlwLWxpc3Qtd3JhcHBlciAubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCk6bGFzdC1jaGlsZCxbZGlyPXJ0bF0gLm1hdC1jaGlwLWxpc3Qtc3RhY2tlZCAubWF0LWNoaXAtbGlzdC13cmFwcGVyIC5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKTpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9Y2hpcHMuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENoaXBMaXN0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG5NZENoaXBMaXN0LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdzZWxlY3RhYmxlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbnZhciBNZENoaXBzTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDaGlwc01vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ2hpcHNNb2R1bGU7XG59KCkpO1xuTWRDaGlwc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kQ2hpcExpc3QsIE1kQ2hpcF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRDaGlwTGlzdCwgTWRDaGlwXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENoaXBzTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFJldHVybnMgYW4gZXhjZXB0aW9uIHRvIGJlIHRocm93biBpbiB0aGUgY2FzZSB3aGVuIGF0dGVtcHRpbmcgdG9cbiAqIGxvYWQgYW4gaWNvbiB3aXRoIGEgbmFtZSB0aGF0IGNhbm5vdCBiZSBmb3VuZC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHBhcmFtIHs/fSBpY29uTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TWRJY29uTmFtZU5vdEZvdW5kRXJyb3IoaWNvbk5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgaWNvbiB3aXRoIHRoZSBuYW1lIFxcXCJcIiArIGljb25OYW1lICsgXCJcXFwiXCIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGV4Y2VwdGlvbiB0byBiZSB0aHJvd24gd2hlbiB0aGUgY29uc3VtZXIgYXR0ZW1wdHMgdG8gdXNlXG4gKiBgPG1kLWljb24+YCB3aXRob3V0IGluY2x1ZGluZyBcXEBhbmd1bGFyL2h0dHAuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE1kSWNvbk5vSHR0cFByb3ZpZGVyRXJyb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgSHR0cCBwcm92aWRlciBmb3IgdXNlIHdpdGggQW5ndWxhciBNYXRlcmlhbCBpY29ucy4gJyArXG4gICAgICAgICdQbGVhc2UgaW5jbHVkZSB0aGUgSHR0cE1vZHVsZSBmcm9tIEBhbmd1bGFyL2h0dHAgaW4geW91ciBhcHAgaW1wb3J0cy4nKTtcbn1cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgYW4gaWNvbiwgaW5jbHVkaW5nIHRoZSBVUkwgYW5kIHBvc3NpYmx5IHRoZSBjYWNoZWQgU1ZHIGVsZW1lbnQuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFN2Z0ljb25Db25maWcgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN2Z0ljb25Db25maWcodXJsKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gU3ZnSWNvbkNvbmZpZztcbn0oKSk7XG4vKipcbiAqIFNlcnZpY2UgdG8gcmVnaXN0ZXIgYW5kIGRpc3BsYXkgaWNvbnMgdXNlZCBieSB0aGUgPG1kLWljb24+IGNvbXBvbmVudC5cbiAqIC0gUmVnaXN0ZXJzIGljb24gVVJMcyBieSBuYW1lc3BhY2UgYW5kIG5hbWUuXG4gKiAtIFJlZ2lzdGVycyBpY29uIHNldCBVUkxzIGJ5IG5hbWVzcGFjZS5cbiAqIC0gUmVnaXN0ZXJzIGFsaWFzZXMgZm9yIENTUyBjbGFzc2VzLCBmb3IgdXNlIHdpdGggaWNvbiBmb250cy5cbiAqIC0gTG9hZHMgaWNvbnMgZnJvbSBVUkxzIGFuZCBleHRyYWN0cyBpbmRpdmlkdWFsIGljb25zIGZyb20gaWNvbiBzZXRzLlxuICovXG52YXIgTWRJY29uUmVnaXN0cnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9odHRwXG4gICAgICogQHBhcmFtIHs/fSBfc2FuaXRpemVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRJY29uUmVnaXN0cnkoX2h0dHAsIF9zYW5pdGl6ZXIpIHtcbiAgICAgICAgdGhpcy5faHR0cCA9IF9odHRwO1xuICAgICAgICB0aGlzLl9zYW5pdGl6ZXIgPSBfc2FuaXRpemVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVVJMcyBhbmQgY2FjaGVkIFNWRyBlbGVtZW50cyBmb3IgaW5kaXZpZHVhbCBpY29ucy4gS2V5cyBhcmUgb2YgdGhlIGZvcm1hdCBcIltuYW1lc3BhY2VdOltpY29uXVwiLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3ZnSWNvbkNvbmZpZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdmdJY29uQ29uZmlnIG9iamVjdHMgYW5kIGNhY2hlZCBTVkcgZWxlbWVudHMgZm9yIGljb24gc2V0cywga2V5ZWQgYnkgbmFtZXNwYWNlLlxuICAgICAgICAgKiBNdWx0aXBsZSBpY29uIHNldHMgY2FuIGJlIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIHNhbWUgbmFtZXNwYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faWNvblNldENvbmZpZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZSBmb3IgaWNvbnMgbG9hZGVkIGJ5IGRpcmVjdCBVUkxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2FjaGVkSWNvbnNCeVVybCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluLXByb2dyZXNzIGljb24gZmV0Y2hlcy4gVXNlZCB0byBjb2FsZXNjZSBtdWx0aXBsZSByZXF1ZXN0cyB0byB0aGUgc2FtZSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pblByb2dyZXNzVXJsRmV0Y2hlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBmcm9tIGZvbnQgaWRlbnRpZmllcnMgdG8gdGhlaXIgQ1NTIGNsYXNzIG5hbWVzLiBVc2VkIGZvciBpY29uIGZvbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZm9udENzc0NsYXNzZXNCeUFsaWFzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIENTUyBjbGFzcyB0byBhcHBseSB3aGVuIGFuIDxtZC1pY29uPiBjb21wb25lbnQgaGFzIG5vIGljb24gbmFtZSwgdXJsLCBvciBmb250IHNwZWNpZmllZC5cbiAgICAgICAgICogVGhlIGRlZmF1bHQgJ21hdGVyaWFsLWljb25zJyB2YWx1ZSBhc3N1bWVzIHRoYXQgdGhlIG1hdGVyaWFsIGljb24gZm9udCBoYXMgYmVlbiBsb2FkZWQgYXNcbiAgICAgICAgICogZGVzY3JpYmVkIGF0IGh0dHA6Ly9nb29nbGUuZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29ucy8jaWNvbi1mb250LWZvci10aGUtd2ViXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kZWZhdWx0Rm9udFNldENsYXNzID0gJ21hdGVyaWFsLWljb25zJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGljb24gYnkgVVJMIGluIHRoZSBkZWZhdWx0IG5hbWVzcGFjZS5cbiAgICAgKiBAcGFyYW0gez99IGljb25OYW1lIE5hbWUgdW5kZXIgd2hpY2ggdGhlIGljb24gc2hvdWxkIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5hZGRTdmdJY29uID0gZnVuY3Rpb24gKGljb25OYW1lLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU3ZnSWNvbkluTmFtZXNwYWNlKCcnLCBpY29uTmFtZSwgdXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpY29uIGJ5IFVSTCBpbiB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZS5cbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZSBOYW1lc3BhY2UgaW4gd2hpY2ggdGhlIGljb24gc2hvdWxkIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHBhcmFtIHs/fSBpY29uTmFtZSBOYW1lIHVuZGVyIHdoaWNoIHRoZSBpY29uIHNob3VsZCBiZSByZWdpc3RlcmVkLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuYWRkU3ZnSWNvbkluTmFtZXNwYWNlID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgaWNvbk5hbWUsIHVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSBpY29uS2V5KG5hbWVzcGFjZSwgaWNvbk5hbWUpO1xuICAgICAgICB0aGlzLl9zdmdJY29uQ29uZmlncy5zZXQoa2V5LCBuZXcgU3ZnSWNvbkNvbmZpZyh1cmwpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaWNvbiBzZXQgYnkgVVJMIGluIHRoZSBkZWZhdWx0IG5hbWVzcGFjZS5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmFkZFN2Z0ljb25TZXQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFN2Z0ljb25TZXRJbk5hbWVzcGFjZSgnJywgdXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpY29uIHNldCBieSBVUkwgaW4gdGhlIHNwZWNpZmllZCBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2UgTmFtZXNwYWNlIGluIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBpY29uIHNldC5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmFkZFN2Z0ljb25TZXRJbk5hbWVzcGFjZSA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIHVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25maWcgPSBuZXcgU3ZnSWNvbkNvbmZpZyh1cmwpO1xuICAgICAgICBpZiAodGhpcy5faWNvblNldENvbmZpZ3MuaGFzKG5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljb25TZXRDb25maWdzLmdldChuYW1lc3BhY2UpLnB1c2goY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ljb25TZXRDb25maWdzLnNldChuYW1lc3BhY2UsIFtjb25maWddKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgYW4gYWxpYXMgZm9yIGEgQ1NTIGNsYXNzIG5hbWUgdG8gYmUgdXNlZCBmb3IgaWNvbiBmb250cy4gQ3JlYXRpbmcgYW4gbWRJY29uXG4gICAgICogY29tcG9uZW50IHdpdGggdGhlIGFsaWFzIGFzIHRoZSBmb250U2V0IGlucHV0IHdpbGwgY2F1c2UgdGhlIGNsYXNzIG5hbWUgdG8gYmUgYXBwbGllZFxuICAgICAqIHRvIHRoZSA8bWQtaWNvbj4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gYWxpYXMgQWxpYXMgZm9yIHRoZSBmb250LlxuICAgICAqIEBwYXJhbSB7Pz19IGNsYXNzTmFtZSBDbGFzcyBuYW1lIG92ZXJyaWRlIHRvIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgYWxpYXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJGb250Q2xhc3NBbGlhcyA9IGZ1bmN0aW9uIChhbGlhcywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChjbGFzc05hbWUgPT09IHZvaWQgMCkgeyBjbGFzc05hbWUgPSBhbGlhczsgfVxuICAgICAgICB0aGlzLl9mb250Q3NzQ2xhc3Nlc0J5QWxpYXMuc2V0KGFsaWFzLCBjbGFzc05hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIENTUyBjbGFzcyBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgYWxpYXMgYnkgYSBwcmV2aW91cyBjYWxsIHRvXG4gICAgICogcmVnaXN0ZXJGb250Q2xhc3NBbGlhcy4gSWYgbm8gQ1NTIGNsYXNzIGhhcyBiZWVuIGFzc29jaWF0ZWQsIHJldHVybnMgdGhlIGFsaWFzIHVubW9kaWZpZWQuXG4gICAgICogQHBhcmFtIHs/fSBhbGlhc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmNsYXNzTmFtZUZvckZvbnRBbGlhcyA9IGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udENzc0NsYXNzZXNCeUFsaWFzLmdldChhbGlhcykgfHwgYWxpYXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBDU1MgY2xhc3MgbmFtZSB0byBiZSB1c2VkIGZvciBpY29uIGZvbnRzIHdoZW4gYW4gPG1kLWljb24+IGNvbXBvbmVudCBkb2VzIG5vdFxuICAgICAqIGhhdmUgYSBmb250U2V0IGlucHV0IHZhbHVlLCBhbmQgaXMgbm90IGxvYWRpbmcgYW4gaWNvbiBieSBuYW1lIG9yIFVSTC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gY2xhc3NOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuc2V0RGVmYXVsdEZvbnRTZXRDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEZvbnRTZXRDbGFzcyA9IGNsYXNzTmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBDU1MgY2xhc3MgbmFtZSB0byBiZSB1c2VkIGZvciBpY29uIGZvbnRzIHdoZW4gYW4gPG1kLWljb24+IGNvbXBvbmVudCBkb2VzIG5vdFxuICAgICAqIGhhdmUgYSBmb250U2V0IGlucHV0IHZhbHVlLCBhbmQgaXMgbm90IGxvYWRpbmcgYW4gaWNvbiBieSBuYW1lIG9yIFVSTC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXREZWZhdWx0Rm9udFNldENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEZvbnRTZXRDbGFzcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHByb2R1Y2VzIHRoZSBpY29uIChhcyBhbiA8c3ZnPiBET00gZWxlbWVudCkgZnJvbSB0aGUgZ2l2ZW4gVVJMLlxuICAgICAqIFRoZSByZXNwb25zZSBmcm9tIHRoZSBVUkwgbWF5IGJlIGNhY2hlZCBzbyB0aGlzIHdpbGwgbm90IGFsd2F5cyBjYXVzZSBhbiBIVFRQIHJlcXVlc3QsIGJ1dFxuICAgICAqIHRoZSBwcm9kdWNlZCBlbGVtZW50IHdpbGwgYWx3YXlzIGJlIGEgbmV3IGNvcHkgb2YgdGhlIG9yaWdpbmFsbHkgZmV0Y2hlZCBpY29uLiAoVGhhdCBpcyxcbiAgICAgKiBpdCB3aWxsIG5vdCBjb250YWluIGFueSBtb2RpZmljYXRpb25zIG1hZGUgdG8gZWxlbWVudHMgcHJldmlvdXNseSByZXR1cm5lZCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHNhZmVVcmwgVVJMIGZyb20gd2hpY2ggdG8gZmV0Y2ggdGhlIFNWRyBpY29uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmdldFN2Z0ljb25Gcm9tVXJsID0gZnVuY3Rpb24gKHNhZmVVcmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsID0gdGhpcy5fc2FuaXRpemVyLnNhbml0aXplKFNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkwsIHNhZmVVcmwpO1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkSWNvbnNCeVVybC5oYXModXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGUub2YoY2xvbmVTdmcodGhpcy5fY2FjaGVkSWNvbnNCeVVybC5nZXQodXJsKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkU3ZnSWNvbkZyb21Db25maWcobmV3IFN2Z0ljb25Db25maWcodXJsKSlcbiAgICAgICAgICAgIC5kbyhmdW5jdGlvbiAoc3ZnKSB7IHJldHVybiBfdGhpcy5fY2FjaGVkSWNvbnNCeVVybC5zZXQodXJsLCBzdmcpOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3ZnKSB7IHJldHVybiBjbG9uZVN2ZyhzdmcpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHByb2R1Y2VzIHRoZSBpY29uIChhcyBhbiA8c3ZnPiBET00gZWxlbWVudCkgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgICAqIGFuZCBuYW1lc3BhY2UuIFRoZSBpY29uIG11c3QgaGF2ZSBiZWVuIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFkZEljb24gb3IgYWRkSWNvblNldDtcbiAgICAgKiBpZiBub3QsIHRoZSBPYnNlcnZhYmxlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IG5hbWUgTmFtZSBvZiB0aGUgaWNvbiB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlIE5hbWVzcGFjZSBpbiB3aGljaCB0byBsb29rIGZvciB0aGUgaWNvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXROYW1lZFN2Z0ljb24gPSBmdW5jdGlvbiAobmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHZvaWQgMCkgeyBuYW1lc3BhY2UgPSAnJzsgfVxuICAgICAgICAvLyBSZXR1cm4gKGNvcHkgb2YpIGNhY2hlZCBpY29uIGlmIHBvc3NpYmxlLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSBpY29uS2V5KG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICAgIGlmICh0aGlzLl9zdmdJY29uQ29uZmlncy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN2Z0Zyb21Db25maWcodGhpcy5fc3ZnSWNvbkNvbmZpZ3MuZ2V0KGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBpZiB3ZSBoYXZlIGFueSBpY29uIHNldHMgcmVnaXN0ZXJlZCBmb3IgdGhlIG5hbWVzcGFjZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWNvblNldENvbmZpZ3MgPSB0aGlzLl9pY29uU2V0Q29uZmlncy5nZXQobmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKGljb25TZXRDb25maWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3ZnRnJvbUljb25TZXRDb25maWdzKG5hbWUsIGljb25TZXRDb25maWdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS50aHJvdyhnZXRNZEljb25OYW1lTm90Rm91bmRFcnJvcihrZXkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhY2hlZCBpY29uIGZvciBhIFN2Z0ljb25Db25maWcgaWYgYXZhaWxhYmxlLCBvciBmZXRjaGVzIGl0IGZyb20gaXRzIFVSTCBpZiBub3QuXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fZ2V0U3ZnRnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgdGhlIFNWRyBlbGVtZW50IGZvciB0aGlzIGljb24sIHJldHVybiBhIGNvcHkuXG4gICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZihjbG9uZVN2Zyhjb25maWcuc3ZnRWxlbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGljb24gZnJvbSB0aGUgY29uZmlnJ3MgVVJMLCBjYWNoZSBpdCwgYW5kIHJldHVybiBhIGNvcHkuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFN2Z0ljb25Gcm9tQ29uZmlnKGNvbmZpZylcbiAgICAgICAgICAgICAgICAuZG8oZnVuY3Rpb24gKHN2ZykgeyByZXR1cm4gY29uZmlnLnN2Z0VsZW1lbnQgPSBzdmc7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3ZnKSB7IHJldHVybiBjbG9uZVN2ZyhzdmcpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gZmluZCBhbiBpY29uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIGluIGFueSBvZiB0aGUgU1ZHIGljb24gc2V0cy5cbiAgICAgKiBGaXJzdCBzZWFyY2hlcyB0aGUgYXZhaWxhYmxlIGNhY2hlZCBpY29ucyBmb3IgYSBuZXN0ZWQgZWxlbWVudCB3aXRoIGEgbWF0Y2hpbmcgbmFtZSwgYW5kXG4gICAgICogaWYgZm91bmQgY29waWVzIHRoZSBlbGVtZW50IHRvIGEgbmV3IDxzdmc+IGVsZW1lbnQuIElmIG5vdCBmb3VuZCwgZmV0Y2hlcyBhbGwgaWNvbiBzZXRzXG4gICAgICogdGhhdCBoYXZlIG5vdCBiZWVuIGNhY2hlZCwgYW5kIHNlYXJjaGVzIGFnYWluIGFmdGVyIGFsbCBmZXRjaGVzIGFyZSBjb21wbGV0ZWQuXG4gICAgICogVGhlIHJldHVybmVkIE9ic2VydmFibGUgcHJvZHVjZXMgdGhlIFNWRyBlbGVtZW50IGlmIHBvc3NpYmxlLCBhbmQgdGhyb3dzXG4gICAgICogYW4gZXJyb3IgaWYgbm8gaWNvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBjYW4gYmUgZm91bmQuXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBpY29uU2V0Q29uZmlnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9nZXRTdmdGcm9tSWNvblNldENvbmZpZ3MgPSBmdW5jdGlvbiAobmFtZSwgaWNvblNldENvbmZpZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRm9yIGFsbCB0aGUgaWNvbiBzZXQgU1ZHIGVsZW1lbnRzIHdlJ3ZlIGZldGNoZWQsIHNlZSBpZiBhbnkgY29udGFpbiBhbiBpY29uIHdpdGggdGhlXG4gICAgICAgIC8vIHJlcXVlc3RlZCBuYW1lLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lZEljb24gPSB0aGlzLl9leHRyYWN0SWNvbldpdGhOYW1lRnJvbUFueVNldChuYW1lLCBpY29uU2V0Q29uZmlncyk7XG4gICAgICAgIGlmIChuYW1lZEljb24pIHtcbiAgICAgICAgICAgIC8vIFdlIGNvdWxkIGNhY2hlIG5hbWVkSWNvbiBpbiBfc3ZnSWNvbkNvbmZpZ3MsIGJ1dCBzaW5jZSB3ZSBoYXZlIHRvIG1ha2UgYSBjb3B5IGV2ZXJ5XG4gICAgICAgICAgICAvLyB0aW1lIGFueXdheSwgdGhlcmUncyBwcm9iYWJseSBub3QgbXVjaCBhZHZhbnRhZ2UgY29tcGFyZWQgdG8ganVzdCBhbHdheXMgZXh0cmFjdGluZ1xuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgaWNvbiBzZXQuXG4gICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZihuYW1lZEljb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBmb3VuZCBpbiBhbnkgY2FjaGVkIGljb24gc2V0cy4gSWYgdGhlcmUgYXJlIGljb24gc2V0cyB3aXRoIFVSTHMgdGhhdCB3ZSBoYXZlbid0XG4gICAgICAgIC8vIGZldGNoZWQsIGZldGNoIHRoZW0gbm93IGFuZCBsb29rIGZvciBpY29uTmFtZSBpbiB0aGUgcmVzdWx0cy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWNvblNldEZldGNoUmVxdWVzdHMgPSBpY29uU2V0Q29uZmlnc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaWNvblNldENvbmZpZykgeyByZXR1cm4gIWljb25TZXRDb25maWcuc3ZnRWxlbWVudDsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGljb25TZXRDb25maWcpIHsgcmV0dXJuIF90aGlzLl9sb2FkU3ZnSWNvblNldEZyb21Db25maWcoaWNvblNldENvbmZpZylcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyLCBjYXVnaHQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybCA9IF90aGlzLl9zYW5pdGl6ZXIuc2FuaXRpemUoU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCwgaWNvblNldENvbmZpZy51cmwpO1xuICAgICAgICAgICAgLy8gU3dhbGxvdyBlcnJvcnMgZmV0Y2hpbmcgaW5kaXZpZHVhbCBVUkxzIHNvIHRoZSBjb21iaW5lZCBPYnNlcnZhYmxlIHdvbid0XG4gICAgICAgICAgICAvLyBuZWNlc3NhcmlseSBmYWlsLlxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkaW5nIGljb24gc2V0IFVSTDogXCIgKyB1cmwgKyBcIiBmYWlsZWQ6IFwiICsgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKG51bGwpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmRvKGZ1bmN0aW9uIChzdmcpIHtcbiAgICAgICAgICAgIC8vIENhY2hlIFNWRyBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKHN2Zykge1xuICAgICAgICAgICAgICAgIGljb25TZXRDb25maWcuc3ZnRWxlbWVudCA9IHN2ZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7IH0pO1xuICAgICAgICAvLyBGZXRjaCBhbGwgdGhlIGljb24gc2V0IFVSTHMuIFdoZW4gdGhlIHJlcXVlc3RzIGNvbXBsZXRlLCBldmVyeSBJY29uU2V0IHNob3VsZCBoYXZlIGFcbiAgICAgICAgLy8gY2FjaGVkIFNWRyBlbGVtZW50ICh1bmxlc3MgdGhlIHJlcXVlc3QgZmFpbGVkKSwgYW5kIHdlIGNhbiBjaGVjayBhZ2FpbiBmb3IgdGhlIGljb24uXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmZvcmtKb2luKGljb25TZXRGZXRjaFJlcXVlc3RzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaWdub3JlZFJlc3VsdHMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvdW5kSWNvbiA9IF90aGlzLl9leHRyYWN0SWNvbldpdGhOYW1lRnJvbUFueVNldChuYW1lLCBpY29uU2V0Q29uZmlncyk7XG4gICAgICAgICAgICBpZiAoIWZvdW5kSWNvbikge1xuICAgICAgICAgICAgICAgIHRocm93IGdldE1kSWNvbk5hbWVOb3RGb3VuZEVycm9yKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kSWNvbjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aGUgY2FjaGVkIFNWRyBlbGVtZW50cyBmb3IgdGhlIGdpdmVuIGljb24gc2V0cyBmb3IgYSBuZXN0ZWQgaWNvbiBlbGVtZW50IHdob3NlIFwiaWRcIlxuICAgICAqIHRhZyBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgbmFtZS4gSWYgZm91bmQsIGNvcGllcyB0aGUgbmVzdGVkIGVsZW1lbnQgdG8gYSBuZXcgU1ZHIGVsZW1lbnQgYW5kXG4gICAgICogcmV0dXJucyBpdC4gUmV0dXJucyBudWxsIGlmIG5vIG1hdGNoaW5nIGVsZW1lbnQgaXMgZm91bmQuXG4gICAgICogQHBhcmFtIHs/fSBpY29uTmFtZVxuICAgICAqIEBwYXJhbSB7P30gaWNvblNldENvbmZpZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fZXh0cmFjdEljb25XaXRoTmFtZUZyb21BbnlTZXQgPSBmdW5jdGlvbiAoaWNvbk5hbWUsIGljb25TZXRDb25maWdzKSB7XG4gICAgICAgIC8vIEl0ZXJhdGUgYmFja3dhcmRzLCBzbyBpY29uIHNldHMgYWRkZWQgbGF0ZXIgaGF2ZSBwcmVjZWRlbmNlLlxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBpY29uU2V0Q29uZmlncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gaWNvblNldENvbmZpZ3NbaV07XG4gICAgICAgICAgICBpZiAoY29uZmlnLnN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3VuZEljb24gPSB0aGlzLl9leHRyYWN0U3ZnSWNvbkZyb21TZXQoY29uZmlnLnN2Z0VsZW1lbnQsIGljb25OYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRJY29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZEljb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIGNvbnRlbnQgb2YgdGhlIGljb24gVVJMIHNwZWNpZmllZCBpbiB0aGUgU3ZnSWNvbkNvbmZpZyBhbmQgY3JlYXRlcyBhbiBTVkcgZWxlbWVudFxuICAgICAqIGZyb20gaXQuXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fbG9hZFN2Z0ljb25Gcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hVcmwoY29uZmlnLnVybClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN2Z1RleHQpIHsgcmV0dXJuIF90aGlzLl9jcmVhdGVTdmdFbGVtZW50Rm9yU2luZ2xlSWNvbihzdmdUZXh0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgY29udGVudCBvZiB0aGUgaWNvbiBzZXQgVVJMIHNwZWNpZmllZCBpbiB0aGUgU3ZnSWNvbkNvbmZpZyBhbmQgY3JlYXRlcyBhbiBTVkcgZWxlbWVudFxuICAgICAqIGZyb20gaXQuXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fbG9hZFN2Z0ljb25TZXRGcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBUT0RPOiBEb2N1bWVudCB0aGF0IGljb25zIHNob3VsZCBvbmx5IGJlIGxvYWRlZCBmcm9tIHRydXN0ZWQgc291cmNlcy5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoVXJsKGNvbmZpZy51cmwpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzdmdUZXh0KSB7IHJldHVybiBfdGhpcy5fc3ZnRWxlbWVudEZyb21TdHJpbmcoc3ZnVGV4dCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERPTSBlbGVtZW50IGZyb20gdGhlIGdpdmVuIFNWRyBzdHJpbmcsIGFuZCBhZGRzIGRlZmF1bHQgYXR0cmlidXRlcy5cbiAgICAgKiBAcGFyYW0gez99IHJlc3BvbnNlVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9jcmVhdGVTdmdFbGVtZW50Rm9yU2luZ2xlSWNvbiA9IGZ1bmN0aW9uIChyZXNwb25zZVRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ZnID0gdGhpcy5fc3ZnRWxlbWVudEZyb21TdHJpbmcocmVzcG9uc2VUZXh0KTtcbiAgICAgICAgdGhpcy5fc2V0U3ZnQXR0cmlidXRlcyhzdmcpO1xuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhlIGNhY2hlZCBlbGVtZW50IG9mIHRoZSBnaXZlbiBTdmdJY29uQ29uZmlnIGZvciBhIG5lc3RlZCBpY29uIGVsZW1lbnQgd2hvc2UgXCJpZFwiXG4gICAgICogdGFnIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBuYW1lLiBJZiBmb3VuZCwgY29waWVzIHRoZSBuZXN0ZWQgZWxlbWVudCB0byBhIG5ldyBTVkcgZWxlbWVudCBhbmRcbiAgICAgKiByZXR1cm5zIGl0LiBSZXR1cm5zIG51bGwgaWYgbm8gbWF0Y2hpbmcgZWxlbWVudCBpcyBmb3VuZC5cbiAgICAgKiBAcGFyYW0gez99IGljb25TZXRcbiAgICAgKiBAcGFyYW0gez99IGljb25OYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2V4dHJhY3RTdmdJY29uRnJvbVNldCA9IGZ1bmN0aW9uIChpY29uU2V0LCBpY29uTmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpY29uTm9kZSA9IGljb25TZXQucXVlcnlTZWxlY3RvcignIycgKyBpY29uTmFtZSk7XG4gICAgICAgIGlmICghaWNvbk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBpY29uIG5vZGUgaXMgaXRzZWxmIGFuIDxzdmc+IG5vZGUsIGNsb25lIGFuZCByZXR1cm4gaXQgZGlyZWN0bHkuIElmIG5vdCwgc2V0IGl0IGFzXG4gICAgICAgIC8vIHRoZSBjb250ZW50IG9mIGEgbmV3IDxzdmc+IG5vZGUuXG4gICAgICAgIGlmIChpY29uTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0U3ZnQXR0cmlidXRlcygvKiogQHR5cGUgez99ICovIChpY29uTm9kZS5jbG9uZU5vZGUodHJ1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgbm9kZSBpcyBhIDxzeW1ib2w+LCBpdCB3b24ndCBiZSByZW5kZXJlZCBzbyB3ZSBoYXZlIHRvIGNvbnZlcnQgaXQgaW50byA8c3ZnPi4gTm90ZVxuICAgICAgICAvLyB0aGF0IHRoZSBzYW1lIGNvdWxkIGJlIGFjaGlldmVkIGJ5IHJlZmVycmluZyB0byBpdCB2aWEgPHVzZSBocmVmPVwiI2lkXCI+LCBob3dldmVyIHRoZSA8dXNlPlxuICAgICAgICAvLyB0YWcgaXMgcHJvYmxlbWF0aWMgb24gRmlyZWZveCwgYmVjYXVzZSBpdCBuZWVkcyB0byBpbmNsdWRlIHRoZSBjdXJyZW50IHBhZ2UgcGF0aC5cbiAgICAgICAgaWYgKGljb25Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0U3ZnQXR0cmlidXRlcyh0aGlzLl90b1N2Z0VsZW1lbnQoaWNvbk5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGVFbGVtZW50KCdTVkcnKSBkb2Vzbid0IHdvcmsgYXMgZXhwZWN0ZWQ7IHRoZSBET00gZW5kcyB1cCB3aXRoXG4gICAgICAgIC8vIHRoZSBjb3JyZWN0IG5vZGVzLCBidXQgdGhlIFNWRyBjb250ZW50IGRvZXNuJ3QgcmVuZGVyLiBJbnN0ZWFkIHdlXG4gICAgICAgIC8vIGhhdmUgdG8gY3JlYXRlIGFuIGVtcHR5IFNWRyBub2RlIHVzaW5nIGlubmVySFRNTCBhbmQgYXBwZW5kIGl0cyBjb250ZW50LlxuICAgICAgICAvLyBFbGVtZW50cyBjcmVhdGVkIHVzaW5nIERPTVBhcnNlci5wYXJzZUZyb21TdHJpbmcgaGF2ZSB0aGUgc2FtZSBwcm9ibGVtLlxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIzMDAzMjc4L3N2Zy1pbm5lcmh0bWwtaW4tZmlyZWZveC1jYW4tbm90LWRpc3BsYXlcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ZnID0gdGhpcy5fc3ZnRWxlbWVudEZyb21TdHJpbmcoJzxzdmc+PC9zdmc+Jyk7XG4gICAgICAgIC8vIENsb25lIHRoZSBub2RlIHNvIHdlIGRvbid0IHJlbW92ZSBpdCBmcm9tIHRoZSBwYXJlbnQgaWNvbiBzZXQgZWxlbWVudC5cbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKGljb25Ob2RlLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXRTdmdBdHRyaWJ1dGVzKHN2Zyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRE9NIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gU1ZHIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gez99IHN0clxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9zdmdFbGVtZW50RnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgLy8gVE9ETzogSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRoYW4gaW5uZXJIVE1MPyBSZW5kZXJlciBkb2Vzbid0IGFwcGVhciB0byBoYXZlIGEgbWV0aG9kIGZvclxuICAgICAgICAvLyBjcmVhdGluZyBhbiBlbGVtZW50IGZyb20gYW4gSFRNTCBzdHJpbmcuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gc3RyO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdmcgPSAoZGl2LnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpKTtcbiAgICAgICAgaWYgKCFzdmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignPHN2Zz4gdGFnIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBlbGVtZW50IGludG8gYW4gU1ZHIG5vZGUgYnkgY2xvbmluZyBhbGwgb2YgaXRzIGNoaWxkcmVuLlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl90b1N2Z0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdmcgPSB0aGlzLl9zdmdFbGVtZW50RnJvbVN0cmluZygnPHN2Zz48L3N2Zz4nKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoZWxlbWVudC5jaGlsZE5vZGVzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgYW4gU1ZHIGVsZW1lbnQgdG8gYmUgdXNlZCBhcyBhbiBpY29uLlxuICAgICAqIEBwYXJhbSB7P30gc3ZnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX3NldFN2Z0F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgICAgIGlmICghc3ZnLmdldEF0dHJpYnV0ZSgneG1sbnMnKSkge1xuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdmaXQnLCAnJyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxMDAlJyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScsICdmYWxzZScpOyAvLyBEaXNhYmxlIElFMTEgZGVmYXVsdCBiZWhhdmlvciB0byBtYWtlIFNWR3MgZm9jdXNhYmxlLlxuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHdoaWNoIHByb2R1Y2VzIHRoZSBzdHJpbmcgY29udGVudHMgb2YgdGhlIGdpdmVuIFVSTC4gUmVzdWx0cyBtYXkgYmVcbiAgICAgKiBjYWNoZWQsIHNvIGZ1dHVyZSBjYWxscyB3aXRoIHRoZSBzYW1lIFVSTCBtYXkgbm90IGNhdXNlIGFub3RoZXIgSFRUUCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7P30gc2FmZVVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9mZXRjaFVybCA9IGZ1bmN0aW9uIChzYWZlVXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5faHR0cCkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TWRJY29uTm9IdHRwUHJvdmlkZXJFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybCA9IHRoaXMuX3Nhbml0aXplci5zYW5pdGl6ZShTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBzYWZlVXJsKTtcbiAgICAgICAgLy8gU3RvcmUgaW4tcHJvZ3Jlc3MgZmV0Y2hlcyB0byBhdm9pZCBzZW5kaW5nIGEgZHVwbGljYXRlIHJlcXVlc3QgZm9yIGEgVVJMIHdoZW4gdGhlcmUgaXNcbiAgICAgICAgLy8gYWxyZWFkeSBhIHJlcXVlc3QgaW4gcHJvZ3Jlc3MgZm9yIHRoYXQgVVJMLiBJdCdzIG5lY2Vzc2FyeSB0byBjYWxsIHNoYXJlKCkgb24gdGhlXG4gICAgICAgIC8vIE9ic2VydmFibGUgcmV0dXJuZWQgYnkgaHR0cC5nZXQoKSBzbyB0aGF0IG11bHRpcGxlIHN1YnNjcmliZXJzIGRvbid0IGNhdXNlIG11bHRpcGxlIFhIUnMuXG4gICAgICAgIGlmICh0aGlzLl9pblByb2dyZXNzVXJsRmV0Y2hlcy5oYXModXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luUHJvZ3Jlc3NVcmxGZXRjaGVzLmdldCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiBmb3Igc29tZSByZWFzb24sIHRoZSBgZmluYWxseWAgb3BlcmF0b3IgXCJsb3Nlc1wiIHRoZSBnZW5lcmljIHR5cGUgb24gdGhlXG4gICAgICAgIC8vIE9ic2VydmFibGUuIEZpZ3VyZSBvdXQgd2h5IGFuZCBmaXggaXQuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcSA9ICh0aGlzLl9odHRwLmdldCh1cmwpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2UudGV4dCgpOyB9KVxuICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2luUHJvZ3Jlc3NVcmxGZXRjaGVzLmRlbGV0ZSh1cmwpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNoYXJlKCkpO1xuICAgICAgICB0aGlzLl9pblByb2dyZXNzVXJsRmV0Y2hlcy5zZXQodXJsLCByZXEpO1xuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH07XG4gICAgcmV0dXJuIE1kSWNvblJlZ2lzdHJ5O1xufSgpKTtcbk1kSWNvblJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEljb25SZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEh0dHAsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogRG9tU2FuaXRpemVyLCB9LFxuXTsgfTtcbi8qKlxuICogQHBhcmFtIHs/fSBwYXJlbnRSZWdpc3RyeVxuICogQHBhcmFtIHs/fSBodHRwXG4gKiBAcGFyYW0gez99IHNhbml0aXplclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gSUNPTl9SRUdJU1RSWV9QUk9WSURFUl9GQUNUT1JZKHBhcmVudFJlZ2lzdHJ5LCBodHRwLCBzYW5pdGl6ZXIpIHtcbiAgICByZXR1cm4gcGFyZW50UmVnaXN0cnkgfHwgbmV3IE1kSWNvblJlZ2lzdHJ5KGh0dHAsIHNhbml0aXplcik7XG59XG52YXIgSUNPTl9SRUdJU1RSWV9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIE1kSWNvblJlZ2lzdHJ5IGF2YWlsYWJsZSwgdXNlIHRoYXQuIE90aGVyd2lzZSwgcHJvdmlkZSBhIG5ldyBvbmUuXG4gICAgcHJvdmlkZTogTWRJY29uUmVnaXN0cnksXG4gICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIE1kSWNvblJlZ2lzdHJ5XSwgW25ldyBPcHRpb25hbCgpLCBIdHRwXSwgRG9tU2FuaXRpemVyXSxcbiAgICB1c2VGYWN0b3J5OiBJQ09OX1JFR0lTVFJZX1BST1ZJREVSX0ZBQ1RPUllcbn07XG4vKipcbiAqIENsb25lcyBhbiBTVkdFbGVtZW50IHdoaWxlIHByZXNlcnZpbmcgdHlwZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7P30gc3ZnXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjbG9uZVN2ZyhzdmcpIHtcbiAgICByZXR1cm4gKHN2Zy5jbG9uZU5vZGUodHJ1ZSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWNoZSBrZXkgdG8gdXNlIGZvciBhbiBpY29uIG5hbWVzcGFjZSBhbmQgbmFtZS5cbiAqIEBwYXJhbSB7P30gbmFtZXNwYWNlXG4gKiBAcGFyYW0gez99IG5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGljb25LZXkobmFtZXNwYWNlLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWVzcGFjZSArICc6JyArIG5hbWU7XG59XG4vKipcbiAqIENvbXBvbmVudCB0byBkaXNwbGF5IGFuIGljb24uIEl0IGNhbiBiZSB1c2VkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gU3BlY2lmeSB0aGUgc3ZnU3JjIGlucHV0IHRvIGxvYWQgYW4gU1ZHIGljb24gZnJvbSBhIFVSTC4gVGhlIFNWRyBjb250ZW50IGlzIGRpcmVjdGx5IGlubGluZWRcbiAqICAgYXMgYSBjaGlsZCBvZiB0aGUgPG1kLWljb24+IGNvbXBvbmVudCwgc28gdGhhdCBDU1Mgc3R5bGVzIGNhbiBlYXNpbHkgYmUgYXBwbGllZCB0byBpdC5cbiAqICAgVGhlIFVSTCBpcyBsb2FkZWQgdmlhIGFuIFhNTEh0dHBSZXF1ZXN0LCBzbyBpdCBtdXN0IGJlIG9uIHRoZSBzYW1lIGRvbWFpbiBhcyB0aGUgcGFnZSBvciBpdHNcbiAqICAgc2VydmVyIG11c3QgYmUgY29uZmlndXJlZCB0byBhbGxvdyBjcm9zcy1kb21haW4gcmVxdWVzdHMuXG4gKiAgIEV4YW1wbGU6XG4gKiAgICAgPG1kLWljb24gc3ZnU3JjPVwiYXNzZXRzL2Fycm93LnN2Z1wiPjwvbWQtaWNvbj5cbiAqXG4gKiAtIFNwZWNpZnkgdGhlIHN2Z0ljb24gaW5wdXQgdG8gbG9hZCBhbiBTVkcgaWNvbiBmcm9tIGEgVVJMIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIHRoZVxuICogICBhZGRTdmdJY29uLCBhZGRTdmdJY29uSW5OYW1lc3BhY2UsIGFkZFN2Z0ljb25TZXQsIG9yIGFkZFN2Z0ljb25TZXRJbk5hbWVzcGFjZSBtZXRob2RzIG9mXG4gKiAgIE1kSWNvblJlZ2lzdHJ5LiBJZiB0aGUgc3ZnSWNvbiB2YWx1ZSBjb250YWlucyBhIGNvbG9uIGl0IGlzIGFzc3VtZWQgdG8gYmUgaW4gdGhlIGZvcm1hdFxuICogICBcIltuYW1lc3BhY2VdOltuYW1lXVwiLCBpZiBub3QgdGhlIHZhbHVlIHdpbGwgYmUgdGhlIG5hbWUgb2YgYW4gaWNvbiBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuXG4gKiAgIEV4YW1wbGVzOlxuICogICAgIDxtZC1pY29uIHN2Z0ljb249XCJsZWZ0LWFycm93XCI+PC9tZC1pY29uPlxuICogICAgIDxtZC1pY29uIHN2Z0ljb249XCJhbmltYWxzOmNhdFwiPjwvbWQtaWNvbj5cbiAqXG4gKiAtIFVzZSBhIGZvbnQgbGlnYXR1cmUgYXMgYW4gaWNvbiBieSBwdXR0aW5nIHRoZSBsaWdhdHVyZSB0ZXh0IGluIHRoZSBjb250ZW50IG9mIHRoZSA8bWQtaWNvbj5cbiAqICAgY29tcG9uZW50LiBCeSBkZWZhdWx0IHRoZSBNYXRlcmlhbCBpY29ucyBmb250IGlzIHVzZWQgYXMgZGVzY3JpYmVkIGF0XG4gKiAgIGh0dHA6Ly9nb29nbGUuZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29ucy8jaWNvbi1mb250LWZvci10aGUtd2ViLiBZb3UgY2FuIHNwZWNpZnkgYW5cbiAqICAgYWx0ZXJuYXRlIGZvbnQgYnkgc2V0dGluZyB0aGUgZm9udFNldCBpbnB1dCB0byBlaXRoZXIgdGhlIENTUyBjbGFzcyB0byBhcHBseSB0byB1c2UgdGhlXG4gKiAgIGRlc2lyZWQgZm9udCwgb3IgdG8gYW4gYWxpYXMgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggTWRJY29uUmVnaXN0cnkucmVnaXN0ZXJGb250Q2xhc3NBbGlhcy5cbiAqICAgRXhhbXBsZXM6XG4gKiAgICAgPG1kLWljb24+aG9tZTwvbWQtaWNvbj5cbiAqICAgICA8bWQtaWNvbiBmb250U2V0PVwibXlmb250XCI+c3VuPC9tZC1pY29uPlxuICpcbiAqIC0gU3BlY2lmeSBhIGZvbnQgZ2x5cGggdG8gYmUgaW5jbHVkZWQgdmlhIENTUyBydWxlcyBieSBzZXR0aW5nIHRoZSBmb250U2V0IGlucHV0IHRvIHNwZWNpZnkgdGhlXG4gKiAgIGZvbnQsIGFuZCB0aGUgZm9udEljb24gaW5wdXQgdG8gc3BlY2lmeSB0aGUgaWNvbi4gVHlwaWNhbGx5IHRoZSBmb250SWNvbiB3aWxsIHNwZWNpZnkgYVxuICogICBDU1MgY2xhc3Mgd2hpY2ggY2F1c2VzIHRoZSBnbHlwaCB0byBiZSBkaXNwbGF5ZWQgdmlhIGEgOmJlZm9yZSBzZWxlY3RvciwgYXMgaW5cbiAqICAgaHR0cHM6Ly9mb3J0YXdlc29tZS5naXRodWIuaW8vRm9udC1Bd2Vzb21lL2V4YW1wbGVzL1xuICogICBFeGFtcGxlOlxuICogICAgIDxtZC1pY29uIGZvbnRTZXQ9XCJmYVwiIGZvbnRJY29uPVwiYWxhcm1cIj48L21kLWljb24+XG4gKi9cbnZhciBNZEljb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9tZEljb25SZWdpc3RyeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kSWNvbihfZWxlbWVudFJlZiwgX3JlbmRlcmVyLCBfbWRJY29uUmVnaXN0cnkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fbWRJY29uUmVnaXN0cnkgPSBfbWRJY29uUmVnaXN0cnk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY3JlZW5yZWFkZXIgbGFiZWwgZm9yIHRoZSBpY29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob3N0QXJpYUxhYmVsID0gJyc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEljb24ucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIG9mIHRoZSBpY29uLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2xvcjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuZXdDb2xvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uLnByb3RvdHlwZS5fdXBkYXRlQ29sb3IgPSBmdW5jdGlvbiAobmV3Q29sb3IpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKHRoaXMuX2NvbG9yLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcihuZXdDb2xvciwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gbmV3Q29sb3I7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbG9yXG4gICAgICogQHBhcmFtIHs/fSBpc0FkZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uLnByb3RvdHlwZS5fc2V0RWxlbWVudENvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCBpc0FkZCkge1xuICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCAmJiBjb2xvciAhPSAnJykge1xuICAgICAgICAgICAgaWYgKGlzQWRkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIGNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJtYXQtXCIgKyBjb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhbiBzdmdJY29uIGJpbmRpbmcgdmFsdWUgaW50byBpdHMgaWNvbiBzZXQgYW5kIGljb24gbmFtZSBjb21wb25lbnRzLlxuICAgICAqIFJldHVybnMgYSAyLWVsZW1lbnQgYXJyYXkgb2YgWyhpY29uIHNldCksIChpY29uIG5hbWUpXS5cbiAgICAgKiBUaGUgc2VwYXJhdG9yIGZvciB0aGUgdHdvIGZpZWxkcyBpcyAnOicuIElmIHRoZXJlIGlzIG5vIHNlcGFyYXRvciwgYW4gZW1wdHlcbiAgICAgKiBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIHRoZSBpY29uIHNldCBhbmQgdGhlIGVudGlyZSB2YWx1ZSBpcyByZXR1cm5lZCBmb3JcbiAgICAgKiB0aGUgaWNvbiBuYW1lLiBJZiB0aGUgYXJndW1lbnQgaXMgZmFsc3ksIHJldHVybnMgYW4gYXJyYXkgb2YgdHdvIGVtcHR5IHN0cmluZ3MuXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBuYW1lIGNvbnRhaW5zIHR3byBvciBtb3JlICc6JyBzZXBhcmF0b3JzLlxuICAgICAqIEV4YW1wbGVzOlxuICAgICAqICAgJ3NvY2lhbDpjYWtlJyAtPiBbJ3NvY2lhbCcsICdjYWtlJ11cbiAgICAgKiAgICdwZW5ndWluJyAtPiBbJycsICdwZW5ndWluJ11cbiAgICAgKiAgIG51bGwgLT4gWycnLCAnJ11cbiAgICAgKiAgICdhOmI6YycgLT4gKHRocm93cyBFcnJvcilcbiAgICAgKiBAcGFyYW0gez99IGljb25OYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb24ucHJvdG90eXBlLl9zcGxpdEljb25OYW1lID0gZnVuY3Rpb24gKGljb25OYW1lKSB7XG4gICAgICAgIGlmICghaWNvbk5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbJycsICcnXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IGljb25OYW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgIHN3aXRjaCAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHQgbmFtZXNwYWNlLlxuICAgICAgICAgICAgICAgIHJldHVybiBbJycsIHBhcnRzWzBdXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnRzKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpY29uIG5hbWU6IFxcXCJcIiArIGljb25OYW1lICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvbi5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFuZ2VkSW5wdXRzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBpbmxpbmUgU1ZHIGljb24gaWYgdGhlIGlucHV0cyBjaGFuZ2VkLCB0byBhdm9pZCB1bm5lY2Vzc2FyeSBET00gb3BlcmF0aW9ucy5cbiAgICAgICAgaWYgKGNoYW5nZWRJbnB1dHMuaW5kZXhPZignc3ZnSWNvbicpICE9IC0xIHx8IGNoYW5nZWRJbnB1dHMuaW5kZXhPZignc3ZnU3JjJykgIT0gLTEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN2Z0ljb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9zcGxpdEljb25OYW1lKHRoaXMuc3ZnSWNvbiksIG5hbWVzcGFjZSA9IF9hWzBdLCBpY29uTmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5LmdldE5hbWVkU3ZnSWNvbihpY29uTmFtZSwgbmFtZXNwYWNlKS5maXJzdCgpLnN1YnNjcmliZShmdW5jdGlvbiAoc3ZnKSB7IHJldHVybiBfdGhpcy5fc2V0U3ZnRWxlbWVudChzdmcpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjb25zb2xlLmxvZyhcIkVycm9yIHJldHJpZXZpbmcgaWNvbjogXCIgKyBlcnIubWVzc2FnZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91c2luZ0ZvbnRJY29uKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZvbnRJY29uQ2xhc3NlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFyaWFMYWJlbCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb24ucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBVcGRhdGUgZm9udCBjbGFzc2VzIGJlY2F1c2UgbmdPbkNoYW5nZXMgd29uJ3QgYmUgY2FsbGVkIGlmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgcHJlc2VudCxcbiAgICAgICAgLy8gZS5nLiA8bWQtaWNvbj5hcnJvdzwvbWQtaWNvbj4uIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGFkZCBhIENTUyBjbGFzcyBmb3IgdGhlIGRlZmF1bHQgZm9udC5cbiAgICAgICAgaWYgKHRoaXMuX3VzaW5nRm9udEljb24oKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9udEljb25DbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uLnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBhcmlhIGxhYmVsIGhlcmUgYmVjYXVzZSBpdCBtYXkgZGVwZW5kIG9uIHRoZSBwcm9qZWN0ZWQgdGV4dCBjb250ZW50LlxuICAgICAgICAvLyAoZS5nLiA8bWQtaWNvbj5ob21lPC9tZC1pY29uPiBzaG91bGQgdXNlICdob21lJykuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFyaWFMYWJlbCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb24ucHJvdG90eXBlLl91cGRhdGVBcmlhTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyaWFMYWJlbCA9IHRoaXMuX2dldEFyaWFMYWJlbCgpO1xuICAgICAgICBpZiAoYXJpYUxhYmVsICYmIGFyaWFMYWJlbCAhPT0gdGhpcy5fcHJldmlvdXNBcmlhTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzQXJpYUxhYmVsID0gYXJpYUxhYmVsO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2FyaWEtbGFiZWwnLCBhcmlhTGFiZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvbi5wcm90b3R5cGUuX2dldEFyaWFMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmVudCBwcm92aWRlZCBhbiBhcmlhLWxhYmVsIGF0dHJpYnV0ZSB2YWx1ZSwgdXNlIGl0IGFzLWlzLiBPdGhlcndpc2UgbG9vayBmb3IgYVxuICAgICAgICAvLyByZWFzb25hYmxlIHZhbHVlIGZyb20gdGhlIGFsdCBhdHRyaWJ1dGUsIGZvbnQgaWNvbiBuYW1lLCBTVkcgaWNvbiBuYW1lLCBvciAoZm9yIGxpZ2F0dXJlcylcbiAgICAgICAgLy8gdGhlIHRleHQgY29udGVudCBvZiB0aGUgZGlyZWN0aXZlLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYWJlbCA9IHRoaXMuaG9zdEFyaWFMYWJlbCB8fFxuICAgICAgICAgICAgdGhpcy5hbHQgfHxcbiAgICAgICAgICAgIHRoaXMuZm9udEljb24gfHxcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0SWNvbk5hbWUodGhpcy5zdmdJY29uKVsxXTtcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIFwiY29udGVudFwiIG9mIGFuIFNWRyBpY29uIGlzIG5vdCBhIHVzZWZ1bCBsYWJlbC5cbiAgICAgICAgaWYgKHRoaXMuX3VzaW5nRm9udEljb24oKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogV2FybiBoZXJlIGluIGRldiBtb2RlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uLnByb3RvdHlwZS5fdXNpbmdGb250SWNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnN2Z0ljb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN2Z1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uLnByb3RvdHlwZS5fc2V0U3ZnRWxlbWVudCA9IGZ1bmN0aW9uIChzdmcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGF5b3V0RWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIGNoaWxkIG5vZGVzIGFuZCBhZGQgdGhlIG5ldyBTVkcgZWxlbWVudC5cbiAgICAgICAgLy8gV2Ugd291bGQgdXNlIHJlbmRlcmVyLmRldGFjaFZpZXcoQXJyYXkuZnJvbShsYXlvdXRFbGVtZW50LmNoaWxkTm9kZXMpKSBoZXJlLFxuICAgICAgICAvLyBidXQgaXQgZmFpbHMgaW4gSUUxMTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNjMyN1xuICAgICAgICBsYXlvdXRFbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hcHBlbmRDaGlsZChsYXlvdXRFbGVtZW50LCBzdmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb24ucHJvdG90eXBlLl91cGRhdGVGb250SWNvbkNsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdXNpbmdGb250SWNvbigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9udFNldENsYXNzID0gdGhpcy5mb250U2V0ID9cbiAgICAgICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5LmNsYXNzTmFtZUZvckZvbnRBbGlhcyh0aGlzLmZvbnRTZXQpIDpcbiAgICAgICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5LmdldERlZmF1bHRGb250U2V0Q2xhc3MoKTtcbiAgICAgICAgaWYgKGZvbnRTZXRDbGFzcyAhPSB0aGlzLl9wcmV2aW91c0ZvbnRTZXRDbGFzcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzRm9udFNldENsYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbSwgdGhpcy5fcHJldmlvdXNGb250U2V0Q2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvbnRTZXRDbGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKGVsZW0sIGZvbnRTZXRDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0ZvbnRTZXRDbGFzcyA9IGZvbnRTZXRDbGFzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb250SWNvbiAhPSB0aGlzLl9wcmV2aW91c0ZvbnRJY29uQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2aW91c0ZvbnRJY29uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtLCB0aGlzLl9wcmV2aW91c0ZvbnRJY29uQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9udEljb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhlbGVtLCB0aGlzLmZvbnRJY29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzRm9udEljb25DbGFzcyA9IHRoaXMuZm9udEljb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZEljb247XG59KCkpO1xuTWRJY29uLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1pY29uLCBtYXQtaWNvbicsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWljb257YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZpbGw6Y3VycmVudENvbG9yO2hlaWdodDoyNHB4O3dpZHRoOjI0cHh9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPWljb24uY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdpbWcnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1pY29uXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kSWNvbi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBNZEljb25SZWdpc3RyeSwgfSxcbl07IH07XG5NZEljb24ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3N2Z0ljb24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2ZvbnRTZXQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2ZvbnRJY29uJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdhbHQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2hvc3RBcmlhTGFiZWwnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydhcmlhLWxhYmVsJyxdIH0sXSxcbiAgICAnY29sb3InOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xudmFyIE1kSWNvbk1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kSWNvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kSWNvbk1vZHVsZTtcbn0oKSk7XG5NZEljb25Nb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNZENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kSWNvbiwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kSWNvbl0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbSUNPTl9SRUdJU1RSWV9QUk9WSURFUl0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kSWNvbk1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBBIHNpbmdsZSBkZWdyZWUgaW4gcmFkaWFucy5cbiAqL1xudmFyIERFR1JFRV9JTl9SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcbi8qKlxuICogRHVyYXRpb24gb2YgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uLlxuICovXG52YXIgRFVSQVRJT05fSU5ERVRFUk1JTkFURSA9IDY2Nztcbi8qKlxuICogRHVyYXRpb24gb2YgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uLlxuICovXG52YXIgRFVSQVRJT05fREVURVJNSU5BVEUgPSAyMjU7XG4vKipcbiAqIFN0YXJ0IGFuaW1hdGlvbiB2YWx1ZSBvZiB0aGUgaW5kZXRlcm1pbmF0ZSBhbmltYXRpb25cbiAqL1xudmFyIHN0YXJ0SW5kZXRlcm1pbmF0ZSA9IDM7XG4vKipcbiAqIEVuZCBhbmltYXRpb24gdmFsdWUgb2YgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uXG4gKi9cbnZhciBlbmRJbmRldGVybWluYXRlID0gODA7XG4vKipcbiAqIE1heGltdW0gYW5nbGUgZm9yIHRoZSBhcmMuIFRoZSBhbmdsZSBjYW4ndCBiZSBleGFjdGx5IDM2MCwgYmVjYXVzZSB0aGUgYXJjIGJlY29tZXMgaGlkZGVuLlxuICovXG52YXIgTUFYX0FOR0xFID0gMzU5Ljk5IC8gMTAwO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBzdXBwb3J0cyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG4gKi9cbnZhciBIQVNfUkFGID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIERlZmF1bHQgc3Ryb2tlIHdpZHRoIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgdmlld0JveC5cbiAqL1xudmFyIFBST0dSRVNTX1NQSU5ORVJfU1RST0tFX1dJRFRIID0gMTA7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUHJvZ3Jlc3NTcGlubmVyQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXI7XG59KCkpO1xuTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLXByb2dyZXNzLXNwaW5uZXIsIG1hdC1wcm9ncmVzcy1zcGlubmVyJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXByb2dyZXNzLXNwaW5uZXJdJzogJ3RydWUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiA8bWQtcHJvZ3Jlc3Mtc3Bpbm5lcj4gY29tcG9uZW50LlxuICovXG52YXIgTWRQcm9ncmVzc1NwaW5uZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzU3Bpbm5lcihfbmdab25lLCBfZWxlbWVudFJlZiwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWQgb2YgdGhlIGxhc3QgcmVxdWVzdGVkIGFuaW1hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RBbmltYXRpb25JZCA9IDA7XG4gICAgICAgIHRoaXMuX21vZGUgPSAnZGV0ZXJtaW5hdGUnO1xuICAgICAgICB0aGlzLl9jb2xvciA9ICdwcmltYXJ5JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cm9rZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3Mgc3Bpbm5lci4gQnkgZGVmYXVsdCB1c2VzIDEwcHggYXMgc3Ryb2tlIHdpZHRoLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IFBST0dSRVNTX1NQSU5ORVJfU1RST0tFX1dJRFRIO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcIl9hcmlhVmFsdWVNaW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVzIGZvciBhcmlhIG1heCBhbmQgbWluIGFyZSBvbmx5IGRlZmluZWQgYXMgbnVtYmVycyB3aGVuIGluIGEgZGV0ZXJtaW5hdGUgbW9kZS4gIFdlIGRvIHRoaXNcbiAgICAgICAgICogYmVjYXVzZSB2b2ljZW92ZXIgZG9lcyBub3QgcmVwb3J0IHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IgYXMgaW5kZXRlcm1pbmF0ZSBpZiB0aGUgYXJpYSBtaW5cbiAgICAgICAgICogYW5kL29yIG1heCB2YWx1ZSBhcmUgbnVtYmVyIHZhbHVlcy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PSAnZGV0ZXJtaW5hdGUnID8gMCA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwiX2FyaWFWYWx1ZU1heFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdkZXRlcm1pbmF0ZScgPyAxMDAgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcImludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBkb2NzLXByaXZhdGVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGRvY3MtcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gez99IGludGVydmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcmRldGVybWluYXRlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJkZXRlcm1pbmF0ZUludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIGFueSBhbmltYXRpb25zIHRoYXQgd2VyZSBydW5uaW5nLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwSW5kZXRlcm1pbmF0ZUFuaW1hdGlvbigpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29sb3Igb2YgdGhlIHByb2dyZXNzLXNwaW5uZXIuIENhbiBiZSBwcmltYXJ5LCBhY2NlbnQsIG9yIHdhcm4uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJtYXQtXCIgKyB0aGlzLl9jb2xvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlIG9mIHRoZSBwcm9ncmVzcyBjaXJjbGUuIEl0IGlzIGJvdW5kIHRvIHRoZSBob3N0IGFzIHRoZSBhdHRyaWJ1dGUgYXJpYS12YWx1ZW5vdy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PSAnZGV0ZXJtaW5hdGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodiAhPSBudWxsICYmIHRoaXMubW9kZSA9PSAnZGV0ZXJtaW5hdGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3VmFsdWUgPSBjbGFtcCh2KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlQ2lyY2xlKHRoaXMudmFsdWUgfHwgMCwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwibW9kZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlIG9mIHRoZSBwcm9ncmVzcyBjaXJjbGVcbiAgICAgICAgICpcbiAgICAgICAgICogSW5wdXQgbXVzdCBiZSBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIFByb2dyZXNzTW9kZSwgZGVmYXVsdHMgdG8gJ2RldGVybWluYXRlJy5cbiAgICAgICAgICogbW9kZSBpcyBib3VuZCB0byB0aGUgaG9zdCBhcyB0aGUgYXR0cmlidXRlIGhvc3QuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICAgICAgICBpZiAobW9kZSAhPT0gdGhpcy5fbW9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAnaW5kZXRlcm1pbmF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRJbmRldGVybWluYXRlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwSW5kZXRlcm1pbmF0ZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlQ2lyY2xlKDAsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFuaW1hdGVzIHRoZSBjaXJjbGUgZnJvbSBvbmUgcGVyY2VudGFnZSB2YWx1ZSB0byBhbm90aGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRlRnJvbSBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2lyY2xlIGZpbGxlZCBzdGFydGluZyB0aGUgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0ZVRvIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaXJjbGUgZmlsbGVkIGVuZGluZyB0aGUgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7Pz19IGVhc2UgVGhlIGVhc2luZyBmdW5jdGlvbiB0byBtYW5hZ2UgdGhlIHBhY2Ugb2YgY2hhbmdlIGluIHRoZSBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHs/PX0gZHVyYXRpb24gVGhlIGxlbmd0aCBvZiB0aW1lIHRvIHNob3cgdGhlIGFuaW1hdGlvbiwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSB7Pz19IHJvdGF0aW9uIFRoZSBzdGFydGluZyBhbmdsZSBvZiB0aGUgY2lyY2xlIGZpbGwsIHdpdGggMMKwIHJlcHJlc2VudGVkIGF0IHRoZSB0b3AgY2VudGVyXG4gICAgICogICAgb2YgdGhlIGNpcmNsZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5fYW5pbWF0ZUNpcmNsZSA9IGZ1bmN0aW9uIChhbmltYXRlRnJvbSwgYW5pbWF0ZVRvLCBlYXNlLCBkdXJhdGlvbiwgcm90YXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGVhc2UgPT09IHZvaWQgMCkgeyBlYXNlID0gbGluZWFyRWFzZTsgfVxuICAgICAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkgeyBkdXJhdGlvbiA9IERVUkFUSU9OX0RFVEVSTUlOQVRFOyB9XG4gICAgICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7IHJvdGF0aW9uID0gMDsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9ICsrdGhpcy5fbGFzdEFuaW1hdGlvbklkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFuZ2VJblZhbHVlID0gYW5pbWF0ZVRvIC0gYW5pbWF0ZUZyb207XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gYW5pbWF0ZSBpdCBpZiB0aGUgdmFsdWVzIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAoYW5pbWF0ZVRvID09PSBhbmltYXRlRnJvbSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQXJjKGFuaW1hdGVUbywgcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9uXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBza2lwIGFoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGFwc2VkVGltZSA9IEhBU19SQUYgP1xuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCBNYXRoLm1pbihEYXRlLm5vdygpIC0gc3RhcnRUaW1lLCBkdXJhdGlvbikpIDpcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb247XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlckFyYyhlYXNlKGVsYXBzZWRUaW1lLCBhbmltYXRlRnJvbSwgY2hhbmdlSW5WYWx1ZSwgZHVyYXRpb24pLCByb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBvdmVybGFwcGluZyBhbmltYXRpb25zIGJ5IGNoZWNraW5nIGlmIGEgbmV3IGFuaW1hdGlvbiBoYXMgYmVlbiBjYWxsZWQgZm9yIGFuZFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaGFzIGxhc3RlZCBsb25nZXIgdGhhbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gX3RoaXMuX2xhc3RBbmltYXRpb25JZCAmJiBlbGFwc2VkVGltZSA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRpb25fMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgYW5pbWF0aW9uIG91dHNpZGUgb2YgQW5ndWxhcidzIHpvbmUsIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBoaXR0aW5nIFpvbmVKUyBhbmQgY2hhbmdlIGRldGVjdGlvbiBvbiBlYWNoIGZyYW1lLlxuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGFuaW1hdGlvbl8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbiBpbnRlcnZhbCwgaWYgaXQgaXMgbm90IGFscmVhZHkgcnVubmluZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5fc3RhcnRJbmRldGVybWluYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb3RhdGlvblN0YXJ0UG9pbnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHN0YXJ0SW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kID0gZW5kSW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb24gPSBEVVJBVElPTl9JTkRFVEVSTUlOQVRFO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRlJCQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGVDaXJjbGUoc3RhcnQsIGVuZCwgbWF0ZXJpYWxFYXNlLCBkdXJhdGlvbiwgcm90YXRpb25TdGFydFBvaW50KTtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgcm90YXRpb24gZnJvbSByZWFjaGluZyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUi5cbiAgICAgICAgICAgIHJvdGF0aW9uU3RhcnRQb2ludCA9IChyb3RhdGlvblN0YXJ0UG9pbnQgKyBlbmQpICUgMTAwO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcCA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgPSAtZW5kO1xuICAgICAgICAgICAgZW5kID0gLXRlbXA7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5pbnRlcmRldGVybWluYXRlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW50ZXJkZXRlcm1pbmF0ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoYW5pbWF0ZSQkMSwgZHVyYXRpb24gKyA1MCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGUkJDEoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGludGVydmFsLCBlbmRpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5fY2xlYW51cEluZGV0ZXJtaW5hdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW50ZXJkZXRlcm1pbmF0ZUludGVydmFsID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGFyYyBvbnRvIHRoZSBTVkcgZWxlbWVudC4gUHJveGllcyBgZ2V0QXJjYCB3aGlsZSBzZXR0aW5nIHRoZSBwcm9wZXJcbiAgICAgKiBET00gYXR0cmlidXRlIG9uIHRoZSBgPHBhdGg+YC5cbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRWYWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHJvdGF0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX3JlbmRlckFyYyA9IGZ1bmN0aW9uIChjdXJyZW50VmFsdWUsIHJvdGF0aW9uKSB7XG4gICAgICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7IHJvdGF0aW9uID0gMDsgfVxuICAgICAgICBpZiAodGhpcy5fcGF0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ZnQXJjID0gZ2V0U3ZnQXJjKGN1cnJlbnRWYWx1ZSwgcm90YXRpb24sIHRoaXMuc3Ryb2tlV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuX3BhdGgubmF0aXZlRWxlbWVudCwgJ2QnLCBzdmdBcmMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWRQcm9ncmVzc1NwaW5uZXI7XG59KCkpO1xuTWRQcm9ncmVzc1NwaW5uZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1wcm9ncmVzcy1zcGlubmVyLCBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lcicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdwcm9ncmVzc2JhcicsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbWluXSc6ICdfYXJpYVZhbHVlTWluJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtYXhdJzogJ19hcmlhVmFsdWVNYXgnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8IS0tIHByZXNlcnZlQXNwZWN0UmF0aW8gb2YgeE1pZFlNaWQgbWVldCBhcyB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCBpcyB0aGUgY2lyY2xlJ3MgY2VudGVyLiBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgd2lsbCByZW1haW4gYXQgdGhlIGNlbnRlciBvZiB0aGUgbWQtcHJvZ3Jlc3Mtc3Bpbm5lciBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIFNWRy4gLS0+IDxzdmcgdmlld0JveD1cXFwiMCAwIDEwMCAxMDBcXFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XFxcInhNaWRZTWlkIG1lZXRcXFwiPiA8cGF0aCAjcGF0aCBbc3R5bGUuc3Ryb2tlV2lkdGhdPVxcXCJzdHJva2VXaWR0aFxcXCI+PC9wYXRoPiA8L3N2Zz4gXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmJsb2NrO2hlaWdodDoxMDBweDt3aWR0aDoxMDBweDtvdmVyZmxvdzpoaWRkZW59Omhvc3Qgc3Zne2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXJ9Omhvc3QgcGF0aHtmaWxsOnRyYW5zcGFyZW50O3RyYW5zaXRpb246c3Ryb2tlIC4zcyBjdWJpYy1iZXppZXIoLjM1LDAsLjI1LDEpfTpob3N0W21vZGU9aW5kZXRlcm1pbmF0ZV0gc3Zne2FuaW1hdGlvbi1kdXJhdGlvbjo1LjI1cywyLjg4N3M7YW5pbWF0aW9uLW5hbWU6bWF0LXByb2dyZXNzLXNwaW5uZXItc3BvcmFkaWMtcm90YXRlLG1hdC1wcm9ncmVzcy1zcGlubmVyLWxpbmVhci1yb3RhdGU7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjM1LDAsLjI1LDEpLGxpbmVhcjthbmltYXRpb24taXRlcmF0aW9uLWNvdW50OmluZmluaXRlO3RyYW5zaXRpb246bm9uZX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLWxpbmVhci1yb3RhdGV7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zcG9yYWRpYy1yb3RhdGV7MTIuNSV7dHJhbnNmb3JtOnJvdGF0ZSgxMzVkZWcpfTI1JXt0cmFuc2Zvcm06cm90YXRlKDI3MGRlZyl9MzcuNSV7dHJhbnNmb3JtOnJvdGF0ZSg0MDVkZWcpfTUwJXt0cmFuc2Zvcm06cm90YXRlKDU0MGRlZyl9NjIuNSV7dHJhbnNmb3JtOnJvdGF0ZSg2NzVkZWcpfTc1JXt0cmFuc2Zvcm06cm90YXRlKDgxMGRlZyl9ODcuNSV7dHJhbnNmb3JtOnJvdGF0ZSg5NDVkZWcpfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgxMDgwZGVnKX19IC8qIyBzb3VyY2VNYXBwaW5nVVJMPXByb2dyZXNzLXNwaW5uZXIuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUHJvZ3Jlc3NTcGlubmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbl07IH07XG5NZFByb2dyZXNzU3Bpbm5lci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX3BhdGgnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsncGF0aCcsXSB9LF0sXG4gICAgJ3N0cm9rZVdpZHRoJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS12YWx1ZW5vdycsXSB9LF0sXG4gICAgJ21vZGUnOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLm1vZGUnLF0gfSwgeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xuLyoqXG4gKiA8bWQtc3Bpbm5lcj4gY29tcG9uZW50LlxuICpcbiAqIFRoaXMgaXMgYSBjb21wb25lbnQgZGVmaW5pdGlvbiB0byBiZSB1c2VkIGFzIGEgY29udmVuaWVuY2UgcmVmZXJlbmNlIHRvIGNyZWF0ZSBhblxuICogaW5kZXRlcm1pbmF0ZSA8bWQtcHJvZ3Jlc3Mtc3Bpbm5lcj4gaW5zdGFuY2UuXG4gKi9cbnZhciBNZFNwaW5uZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kU3Bpbm5lciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IG5nWm9uZVxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFNwaW5uZXIoZWxlbWVudFJlZiwgbmdab25lLCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZ1pvbmUsIGVsZW1lbnRSZWYsIHJlbmRlcmVyKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tb2RlID0gJ2luZGV0ZXJtaW5hdGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTcGlubmVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhlIGBuZ09uRGVzdHJveWAgZnJvbSBgTWRQcm9ncmVzc1NwaW5uZXJgIHNob3VsZCBiZSBjYWxsZWQgZXhwbGljaXRseSwgYmVjYXVzZVxuICAgICAgICAvLyBpbiBjZXJ0YWluIGNhc2VzIEFuZ3VsYXIgd29uJ3QgY2FsbCBpdCAoZS5nLiB3aGVuIHVzaW5nIEFvVCBhbmQgaW4gdW5pdCB0ZXN0cykuXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBNZFNwaW5uZXI7XG59KE1kUHJvZ3Jlc3NTcGlubmVyKSk7XG5NZFNwaW5uZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1zcGlubmVyLCBtYXQtc3Bpbm5lcicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdwcm9ncmVzc2JhcicsXG4gICAgICAgICAgICAgICAgICAgICdtb2RlJzogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zcGlubmVyXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjwhLS0gcHJlc2VydmVBc3BlY3RSYXRpbyBvZiB4TWlkWU1pZCBtZWV0IGFzIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0IGlzIHRoZSBjaXJjbGUncyBjZW50ZXIuIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSB3aWxsIHJlbWFpbiBhdCB0aGUgY2VudGVyIG9mIHRoZSBtZC1wcm9ncmVzcy1zcGlubmVyIGVsZW1lbnQgY29udGFpbmluZyB0aGUgU1ZHLiAtLT4gPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMTAwIDEwMFxcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCI+IDxwYXRoICNwYXRoIFtzdHlsZS5zdHJva2VXaWR0aF09XFxcInN0cm9rZVdpZHRoXFxcIj48L3BhdGg+IDwvc3ZnPiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMHB4O3dpZHRoOjEwMHB4O292ZXJmbG93OmhpZGRlbn06aG9zdCBzdmd7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlcn06aG9zdCBwYXRoe2ZpbGw6dHJhbnNwYXJlbnQ7dHJhbnNpdGlvbjpzdHJva2UgLjNzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSBzdmd7YW5pbWF0aW9uLWR1cmF0aW9uOjUuMjVzLDIuODg3czthbmltYXRpb24tbmFtZTptYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zcG9yYWRpYy1yb3RhdGUsbWF0LXByb2dyZXNzLXNwaW5uZXItbGluZWFyLXJvdGF0ZTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMzUsMCwuMjUsMSksbGluZWFyO2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6aW5maW5pdGU7dHJhbnNpdGlvbjpub25lfUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLXNwaW5uZXItbGluZWFyLXJvdGF0ZXswJXt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLXNwb3JhZGljLXJvdGF0ZXsxMi41JXt0cmFuc2Zvcm06cm90YXRlKDEzNWRlZyl9MjUle3RyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKX0zNy41JXt0cmFuc2Zvcm06cm90YXRlKDQwNWRlZyl9NTAle3RyYW5zZm9ybTpyb3RhdGUoNTQwZGVnKX02Mi41JXt0cmFuc2Zvcm06cm90YXRlKDY3NWRlZyl9NzUle3RyYW5zZm9ybTpyb3RhdGUoODEwZGVnKX04Ny41JXt0cmFuc2Zvcm06cm90YXRlKDk0NWRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDEwODBkZWcpfX0gLyojIHNvdXJjZU1hcHBpbmdVUkw9cHJvZ3Jlc3Mtc3Bpbm5lci5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRTcGlubmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbl07IH07XG4vKipcbiAqIENsYW1wcyBhIHZhbHVlIHRvIGJlIGJldHdlZW4gMCBhbmQgMTAwLlxuICogQHBhcmFtIHs/fSB2XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjbGFtcCh2KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgdikpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBQb2xhciBjb29yZGluYXRlcyB0byBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0gez99IHJhZGl1c1xuICogQHBhcmFtIHs/fSBwYXRoUmFkaXVzXG4gKiBAcGFyYW0gez99IGFuZ2xlSW5EZWdyZWVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwb2xhclRvQ2FydGVzaWFuKHJhZGl1cywgcGF0aFJhZGl1cywgYW5nbGVJbkRlZ3JlZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmdsZUluUmFkaWFucyA9IChhbmdsZUluRGVncmVlcyAtIDkwKSAqIERFR1JFRV9JTl9SQURJQU5TO1xuICAgIHJldHVybiAocmFkaXVzICsgKHBhdGhSYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucykpKSArXG4gICAgICAgICcsJyArIChyYWRpdXMgKyAocGF0aFJhZGl1cyAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKSkpO1xufVxuLyoqXG4gKiBFYXNpbmcgZnVuY3Rpb24gZm9yIGxpbmVhciBhbmltYXRpb24uXG4gKiBAcGFyYW0gez99IGN1cnJlbnRUaW1lXG4gKiBAcGFyYW0gez99IHN0YXJ0VmFsdWVcbiAqIEBwYXJhbSB7P30gY2hhbmdlSW5WYWx1ZVxuICogQHBhcmFtIHs/fSBkdXJhdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbGluZWFyRWFzZShjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgY2hhbmdlSW5WYWx1ZSwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gY2hhbmdlSW5WYWx1ZSAqIGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gKyBzdGFydFZhbHVlO1xufVxuLyoqXG4gKiBFYXNpbmcgZnVuY3Rpb24gdG8gbWF0Y2ggbWF0ZXJpYWwgZGVzaWduIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uLlxuICogQHBhcmFtIHs/fSBjdXJyZW50VGltZVxuICogQHBhcmFtIHs/fSBzdGFydFZhbHVlXG4gKiBAcGFyYW0gez99IGNoYW5nZUluVmFsdWVcbiAqIEBwYXJhbSB7P30gZHVyYXRpb25cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG1hdGVyaWFsRWFzZShjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgY2hhbmdlSW5WYWx1ZSwgZHVyYXRpb24pIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lID0gY3VycmVudFRpbWUgLyBkdXJhdGlvbjtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lQ3ViZWQgPSBNYXRoLnBvdyh0aW1lLCAzKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lUXVhZCA9IE1hdGgucG93KHRpbWUsIDQpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWVRdWludCA9IE1hdGgucG93KHRpbWUsIDUpO1xuICAgIHJldHVybiBzdGFydFZhbHVlICsgY2hhbmdlSW5WYWx1ZSAqICgoNiAqIHRpbWVRdWludCkgKyAoLTE1ICogdGltZVF1YWQpICsgKDEwICogdGltZUN1YmVkKSk7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIHBhdGggdmFsdWUgdG8gZGVmaW5lIHRoZSBhcmMuICBDb252ZXJ0aW5nIHBlcmNlbnRhZ2UgdmFsdWVzIHRvIHRvIHBvbGFyXG4gKiBjb29yZGluYXRlcyBvbiB0aGUgY2lyY2xlLCBhbmQgdGhlbiB0byBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgaW4gdGhlIHZpZXdwb3J0LlxuICpcbiAqIEBwYXJhbSB7P30gY3VycmVudFZhbHVlIFRoZSBjdXJyZW50IHBlcmNlbnRhZ2UgdmFsdWUgb2YgdGhlIHByb2dyZXNzIGNpcmNsZSwgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlXG4gKiAgICBjaXJjbGUgdG8gZmlsbC5cbiAqIEBwYXJhbSB7P30gcm90YXRpb24gVGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBjaXJjbGUgd2l0aCAwIGJlaW5nIHRoZSAwIGRlZ3JlZSBwb2ludC5cbiAqIEBwYXJhbSB7P30gc3Ryb2tlV2lkdGggU3Ryb2tlIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBzcGlubmVyIGFyYy5cbiAqIEByZXR1cm4gez99IEEgc3RyaW5nIGZvciBhbiBTVkcgcGF0aCByZXByZXNlbnRpbmcgYSBjaXJjbGUgZmlsbGVkIGZyb20gdGhlIHN0YXJ0aW5nIHBvaW50IHRvIHRoZVxuICogICAgcGVyY2VudGFnZSB2YWx1ZSBwcm92aWRlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0U3ZnQXJjKGN1cnJlbnRWYWx1ZSwgcm90YXRpb24sIHN0cm9rZVdpZHRoKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRQb2ludCA9IHJvdGF0aW9uIHx8IDA7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmFkaXVzID0gNTA7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGF0aFJhZGl1cyA9IHJhZGl1cyAtIHN0cm9rZVdpZHRoO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0QW5nbGUgPSBzdGFydFBvaW50ICogTUFYX0FOR0xFO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZEFuZ2xlID0gY3VycmVudFZhbHVlICogTUFYX0FOR0xFO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gcG9sYXJUb0NhcnRlc2lhbihyYWRpdXMsIHBhdGhSYWRpdXMsIHN0YXJ0QW5nbGUpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IHBvbGFyVG9DYXJ0ZXNpYW4ocmFkaXVzLCBwYXRoUmFkaXVzLCBlbmRBbmdsZSArIHN0YXJ0QW5nbGUpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyY1N3ZWVwID0gZW5kQW5nbGUgPCAwID8gMCA6IDE7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFyZ2VBcmNGbGFnO1xuICAgIGlmIChlbmRBbmdsZSA8IDApIHtcbiAgICAgICAgbGFyZ2VBcmNGbGFnID0gZW5kQW5nbGUgPj0gLTE4MCA/IDAgOiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGFyZ2VBcmNGbGFnID0gZW5kQW5nbGUgPD0gMTgwID8gMCA6IDE7XG4gICAgfVxuICAgIHJldHVybiBcIk1cIiArIHN0YXJ0ICsgXCJBXCIgKyBwYXRoUmFkaXVzICsgXCIsXCIgKyBwYXRoUmFkaXVzICsgXCIgMCBcIiArIGxhcmdlQXJjRmxhZyArIFwiLFwiICsgYXJjU3dlZXAgKyBcIiBcIiArIGVuZDtcbn1cbnZhciBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGU7XG59KCkpO1xuTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNZENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBNZFByb2dyZXNzU3Bpbm5lcixcbiAgICAgICAgICAgICAgICAgICAgTWRTcGlubmVyLFxuICAgICAgICAgICAgICAgICAgICBNZENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBNZFByb2dyZXNzU3Bpbm5lcixcbiAgICAgICAgICAgICAgICAgICAgTWRTcGlubmVyLFxuICAgICAgICAgICAgICAgICAgICBNZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlclxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIDxtZC1wcm9ncmVzcy1iYXI+IGNvbXBvbmVudC5cbiAqL1xudmFyIE1kUHJvZ3Jlc3NCYXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzQmFyKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3Igb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sb3IgPSAncHJpbWFyeSc7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5fYnVmZmVyVmFsdWUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbnB1dCBtdXN0IGJlIG9uZSBvZiB0aGVzZSB2YWx1ZXM6IGRldGVybWluYXRlLCBpbmRldGVybWluYXRlLCBidWZmZXIsIHF1ZXJ5LCBkZWZhdWx0cyB0b1xuICAgICAgICAgKiAnZGV0ZXJtaW5hdGUnLlxuICAgICAgICAgKiBNaXJyb3JlZCB0byBtb2RlIGF0dHJpYnV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW9kZSA9ICdkZXRlcm1pbmF0ZSc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzQmFyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZSBvZiB0aGUgcHJvZ3Jlc3NiYXIuIERlZmF1bHRzIHRvIHplcm8uIE1pcnJvcmVkIHRvIGFyaWEtdmFsdWVub3cuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuX3ZhbHVlID0gY2xhbXAkMSh2IHx8IDApOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUsIFwiYnVmZmVyVmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIHZhbHVlIG9mIHRoZSBwcm9ncmVzcyBiYXIuIERlZmF1bHRzIHRvIHplcm8uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2J1ZmZlclZhbHVlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuX2J1ZmZlclZhbHVlID0gY2xhbXAkMSh2IHx8IDApOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybSB2YWx1ZSBmb3IgdGhlIHByb2dyZXNzIGJhcidzIHByaW1hcnkgaW5kaWNhdG9yLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUuX3ByaW1hcnlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjYWxlID0gdGhpcy52YWx1ZSAvIDEwMDtcbiAgICAgICAgcmV0dXJuIHsgdHJhbnNmb3JtOiBcInNjYWxlWChcIiArIHNjYWxlICsgXCIpXCIgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtIHZhbHVlIGZvciB0aGUgcHJvZ3Jlc3MgYmFyJ3MgYnVmZmVyIGluZGljYXRvci4gIE9ubHkgdXNlZCBpZiB0aGVcbiAgICAgKiBwcm9ncmVzcyBtb2RlIGlzIHNldCB0byBidWZmZXIsIG90aGVyd2lzZSByZXR1cm5zIGFuIHVuZGVmaW5lZCwgY2F1c2luZyBubyB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLl9idWZmZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT0gJ2J1ZmZlcicpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjYWxlID0gdGhpcy5idWZmZXJWYWx1ZSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiB7IHRyYW5zZm9ybTogXCJzY2FsZVgoXCIgKyBzY2FsZSArIFwiKVwiIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZFByb2dyZXNzQmFyO1xufSgpKTtcbk1kUHJvZ3Jlc3NCYXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1wcm9ncmVzcy1iYXIsIG1hdC1wcm9ncmVzcy1iYXInLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxuICAgICAgICAgICAgICAgICAgICAnYXJpYS12YWx1ZW1pbic6ICcwJyxcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtdmFsdWVtYXgnOiAnMTAwJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcHJpbWFyeV0nOiAnY29sb3IgPT0gXCJwcmltYXJ5XCInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1hY2NlbnRdJzogJ2NvbG9yID09IFwiYWNjZW50XCInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC13YXJuXSc6ICdjb2xvciA9PSBcIndhcm5cIicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXByb2dyZXNzLWJhcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8IS0tIFRoZSBiYWNrZ3JvdW5kIGRpdiBpcyBuYW1lZCBhcyBzdWNoIGJlY2F1c2UgaXQgYXBwZWFycyBiZWxvdyB0aGUgb3RoZXIgZGl2cyBhbmQgaXMgbm90IHNpemVkIGJhc2VkIG9uIHZhbHVlcy4gLS0+IDxkaXYgY2xhc3M9XFxcIm1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZCBtYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnRcXFwiPjwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJtYXQtcHJvZ3Jlc3MtYmFyLWJ1ZmZlciBtYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnRcXFwiIFtuZ1N0eWxlXT1cXFwiX2J1ZmZlclRyYW5zZm9ybSgpXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWF0LXByb2dyZXNzLWJhci1wcmltYXJ5IG1hdC1wcm9ncmVzcy1iYXItZmlsbCBtYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnRcXFwiIFtuZ1N0eWxlXT1cXFwiX3ByaW1hcnlUcmFuc2Zvcm0oKVxcXCI+PC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5IG1hdC1wcm9ncmVzcy1iYXItZmlsbCBtYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnRcXFwiPjwvZGl2PiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjVweDtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNpdGlvbjpvcGFjaXR5IDI1MG1zIGxpbmVhcjt3aWR0aDoxMDAlfTpob3N0IC5tYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnQsOmhvc3QgLm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXJ7aGVpZ2h0OjEwMCU7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJX06aG9zdCAubWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5ke2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2JhY2tncm91bmQtc2l6ZToxMHB4IDRweDtkaXNwbGF5Om5vbmV9Omhvc3QgLm1hdC1wcm9ncmVzcy1iYXItYnVmZmVye3RyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMjUwbXMgZWFzZSxzdHJva2UgLjNzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9Omhvc3QgLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5e2Rpc3BsYXk6bm9uZX06aG9zdCAubWF0LXByb2dyZXNzLWJhci1maWxse2FuaW1hdGlvbjpub25lO3RyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMjUwbXMgZWFzZSxzdHJva2UgLjNzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9Omhvc3QgLm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXJ7YW5pbWF0aW9uOm5vbmU7Y29udGVudDonJztkaXNwbGF5OmlubGluZS1ibG9jaztsZWZ0OjB9Omhvc3RbbW9kZT1xdWVyeV17dHJhbnNmb3JtOnJvdGF0ZVooMTgwZGVnKX06aG9zdFttb2RlPWluZGV0ZXJtaW5hdGVdIC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGwsOmhvc3RbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItZmlsbHt0cmFuc2l0aW9uOm5vbmV9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1wcmltYXJ5LDpob3N0W21vZGU9cXVlcnldIC5tYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnl7YW5pbWF0aW9uOm1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeS1pbmRldGVybWluYXRlLXRyYW5zbGF0ZSAycyBpbmZpbml0ZSBsaW5lYXI7bGVmdDotMTQ1LjE2NjYxMSV9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1wcmltYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXIsOmhvc3RbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeS5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVye2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnktaW5kZXRlcm1pbmF0ZS1zY2FsZSAycyBpbmZpbml0ZSBsaW5lYXJ9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnksOmhvc3RbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5e2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeS1pbmRldGVybWluYXRlLXRyYW5zbGF0ZSAycyBpbmZpbml0ZSBsaW5lYXI7bGVmdDotNTQuODg4ODkxJTtkaXNwbGF5OmJsb2NrfTpob3N0W21vZGU9aW5kZXRlcm1pbmF0ZV0gLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXIsOmhvc3RbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXJ7YW5pbWF0aW9uOm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5LWluZGV0ZXJtaW5hdGUtc2NhbGUgMnMgaW5maW5pdGUgbGluZWFyfTpob3N0W21vZGU9YnVmZmVyXSAubWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5ke2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQtc2Nyb2xsIDI1MG1zIGluZmluaXRlIGxpbmVhcjtkaXNwbGF5OmJsb2NrfTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKXt0cmFuc2Zvcm06cm90YXRlWSgxODBkZWcpfUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLWJhci1wcmltYXJ5LWluZGV0ZXJtaW5hdGUtdHJhbnNsYXRlezAle3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApfTIwJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguNSwwLC43MDE3MywuNDk1ODIpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApfTU5LjE1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMzAyNDQsLjM4MTM1LC41NSwuOTU2MzUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDgzLjY3MTQyJSl9MTAwJXt0cmFuc2Zvcm06dHJhbnNsYXRlWCgyMDAuNjExMDYlKX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnktaW5kZXRlcm1pbmF0ZS1zY2FsZXswJXt0cmFuc2Zvcm06c2NhbGVYKC4wOCl9MzYuNjUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4zMzQ3MywuMTI0ODIsLjc4NTg0LDEpO3RyYW5zZm9ybTpzY2FsZVgoLjA4KX02OS4xNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjA2LC4xMSwuNiwxKTt0cmFuc2Zvcm06c2NhbGVYKC42NjE0OCl9MTAwJXt0cmFuc2Zvcm06c2NhbGVYKC4wOCl9fUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGV7MCV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjE1LDAsLjUxNTA2LC40MDk2OSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9MjUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4zMTAzMywuMjg0MDYsLjgsLjczMzcxKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgzNy42NTE5MSUpfTQ4LjM1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguNCwuNjI3MDQsLjYsLjkwMjAzKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCg4NC4zODYxNyUpfTEwMCV7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTYwLjI3Nzc4JSl9fUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnktaW5kZXRlcm1pbmF0ZS1zY2FsZXswJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMTUsMCwuNTE1MDYsLjQwOTY5KTt0cmFuc2Zvcm06c2NhbGVYKC4wOCl9MTkuMTUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4zMTAzMywuMjg0MDYsLjgsLjczMzcxKTt0cmFuc2Zvcm06c2NhbGVYKC40NTcxKX00NC4xNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjQsLjYyNzA0LC42LC45MDIwMyk7dHJhbnNmb3JtOnNjYWxlWCguNzI3OTYpfTEwMCV7dHJhbnNmb3JtOnNjYWxlWCguMDgpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZC1zY3JvbGx7dG97dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwcHgpfX0gLyojIHNvdXJjZU1hcHBpbmdVUkw9cHJvZ3Jlc3MtYmFyLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFByb2dyZXNzQmFyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG5NZFByb2dyZXNzQmFyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS12YWx1ZW5vdycsXSB9LF0sXG4gICAgJ2J1ZmZlclZhbHVlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtb2RlJzogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLm1vZGUnLF0gfSxdLFxufTtcbi8qKlxuICogQ2xhbXBzIGEgdmFsdWUgdG8gYmUgYmV0d2VlbiB0d28gbnVtYmVycywgYnkgZGVmYXVsdCAwIGFuZCAxMDAuXG4gKiBAcGFyYW0gez99IHZcbiAqIEBwYXJhbSB7Pz19IG1pblxuICogQHBhcmFtIHs/PX0gbWF4XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjbGFtcCQxKHYsIG1pbiwgbWF4KSB7XG4gICAgaWYgKG1pbiA9PT0gdm9pZCAwKSB7IG1pbiA9IDA7IH1cbiAgICBpZiAobWF4ID09PSB2b2lkIDApIHsgbWF4ID0gMTAwOyB9XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2KSk7XG59XG52YXIgTWRQcm9ncmVzc0Jhck1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUHJvZ3Jlc3NCYXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFByb2dyZXNzQmFyTW9kdWxlO1xufSgpKTtcbk1kUHJvZ3Jlc3NCYXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRQcm9ncmVzc0JhciwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kUHJvZ3Jlc3NCYXJdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFByb2dyZXNzQmFyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TWRJbnB1dENvbnRhaW5lclBsYWNlaG9sZGVyQ29uZmxpY3RFcnJvcigpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdQbGFjZWhvbGRlciBhdHRyaWJ1dGUgYW5kIGNoaWxkIGVsZW1lbnQgd2VyZSBib3RoIHNwZWNpZmllZC4nKTtcbn1cbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcGFyYW0gez99IHR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE1kSW5wdXRDb250YWluZXJVbnN1cHBvcnRlZFR5cGVFcnJvcih0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIklucHV0IHR5cGUgXFxcIlwiICsgdHlwZSArIFwiXFxcIiBpc24ndCBzdXBwb3J0ZWQgYnkgbWQtaW5wdXQtY29udGFpbmVyLlwiKTtcbn1cbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcGFyYW0gez99IGFsaWduXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRNZElucHV0Q29udGFpbmVyRHVwbGljYXRlZEhpbnRFcnJvcihhbGlnbikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJBIGhpbnQgd2FzIGFscmVhZHkgZGVjbGFyZWQgZm9yICdhbGlnbj1cXFwiXCIgKyBhbGlnbiArIFwiXFxcIicuXCIpO1xufVxuLyoqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE1kSW5wdXRDb250YWluZXJNaXNzaW5nTWRJbnB1dEVycm9yKCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ21kLWlucHV0LWNvbnRhaW5lciBtdXN0IGNvbnRhaW4gYW4gbWRJbnB1dCBkaXJlY3RpdmUuICcgK1xuICAgICAgICAnRGlkIHlvdSBmb3JnZXQgdG8gYWRkIG1kSW5wdXQgdG8gdGhlIG5hdGl2ZSBpbnB1dCBvciB0ZXh0YXJlYSBlbGVtZW50PycpO1xufVxuLy8gSW52YWxpZCBpbnB1dCB0eXBlLiBVc2luZyBvbmUgb2YgdGhlc2Ugd2lsbCB0aHJvdyBhbiBNZElucHV0Q29udGFpbmVyVW5zdXBwb3J0ZWRUeXBlRXJyb3IuXG52YXIgTURfSU5QVVRfSU5WQUxJRF9UWVBFUyA9IFtcbiAgICAnYnV0dG9uJyxcbiAgICAnY2hlY2tib3gnLFxuICAgICdjb2xvcicsXG4gICAgJ2ZpbGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdpbWFnZScsXG4gICAgJ3JhZGlvJyxcbiAgICAncmFuZ2UnLFxuICAgICdyZXNldCcsXG4gICAgJ3N1Ym1pdCdcbl07XG52YXIgbmV4dFVuaXF1ZUlkJDEgPSAwO1xuLyoqXG4gKiBUaGUgcGxhY2Vob2xkZXIgZGlyZWN0aXZlLiBUaGUgY29udGVudCBjYW4gZGVjbGFyZSB0aGlzIHRvIGltcGxlbWVudCBtb3JlXG4gKiBjb21wbGV4IHBsYWNlaG9sZGVycy5cbiAqL1xudmFyIE1kUGxhY2Vob2xkZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFBsYWNlaG9sZGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRQbGFjZWhvbGRlcjtcbn0oKSk7XG5NZFBsYWNlaG9sZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1wbGFjZWhvbGRlciwgbWF0LXBsYWNlaG9sZGVyJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFBsYWNlaG9sZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEhpbnQgdGV4dCB0byBiZSBzaG93biB1bmRlcm5lYXRoIHRoZSBpbnB1dC5cbiAqL1xudmFyIE1kSGludCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kSGludCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYWxpZ24gdGhlIGhpbnQgbGFiZWwgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgbGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5pcXVlIElEIGZvciB0aGUgaGludC4gVXNlZCBmb3IgdGhlIGFyaWEtZGVzY3JpYmVkYnkgb24gdGhlIGlucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IFwibWQtaW5wdXQtaGludC1cIiArIG5leHRVbmlxdWVJZCQxKys7XG4gICAgfVxuICAgIHJldHVybiBNZEhpbnQ7XG59KCkpO1xuTWRIaW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1oaW50LCBtYXQtaGludCcsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1oaW50XSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcmlnaHRdJzogJ2FsaWduID09IFwiZW5kXCInLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuaWRdJzogJ2lkJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kSGludC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuTWRIaW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdhbGlnbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xuLyoqXG4gKiBTaW5nbGUgZXJyb3IgbWVzc2FnZSB0byBiZSBzaG93biB1bmRlcm5lYXRoIHRoZSBpbnB1dC5cbiAqL1xudmFyIE1kRXJyb3JEaXJlY3RpdmUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEVycm9yRGlyZWN0aXZlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRFcnJvckRpcmVjdGl2ZTtcbn0oKSk7XG5NZEVycm9yRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1lcnJvciwgbWF0LWVycm9yJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWlucHV0LWVycm9yXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRFcnJvckRpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBQcmVmaXggdG8gYmUgcGxhY2VkIHRoZSB0aGUgZnJvbnQgb2YgdGhlIGlucHV0LlxuICovXG52YXIgTWRQcmVmaXggPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByZWZpeCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kUHJlZml4O1xufSgpKTtcbk1kUHJlZml4LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWRQcmVmaXhdLCBbbWF0UHJlZml4XSwgW21kLXByZWZpeF0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUHJlZml4LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFN1ZmZpeCB0byBiZSBwbGFjZWQgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuXG4gKi9cbnZhciBNZFN1ZmZpeCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU3VmZml4KCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRTdWZmaXg7XG59KCkpO1xuTWRTdWZmaXguZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZFN1ZmZpeF0sIFttYXRTdWZmaXhdLCBbbWQtc3VmZml4XSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRTdWZmaXguY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogTWFya2VyIGZvciB0aGUgaW5wdXQgZWxlbWVudCB0aGF0IGBNZElucHV0Q29udGFpbmVyYCBpcyB3cmFwcGluZy5cbiAqL1xudmFyIE1kSW5wdXREaXJlY3RpdmUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9uZ0NvbnRyb2xcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZElucHV0RGlyZWN0aXZlKF9lbGVtZW50UmVmLCBfcmVuZGVyZXIsIF9uZ0NvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fbmdDb250cm9sID0gX25nQ29udHJvbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhcmlhYmxlcyB1c2VkIGFzIGNhY2hlIGZvciBnZXR0ZXJzIGFuZCBzZXR0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZm9jdXNlZCBvciBub3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIHBsYWNlaG9sZGVyIGNoYW5nZXMgc28gdGhhdCB0aGUgYG1kLWlucHV0LWNvbnRhaW5lcmAgY2FuIHJlLXZhbGlkYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX25ldmVyRW1wdHlJbnB1dFR5cGVzID0gW1xuICAgICAgICAgICAgJ2RhdGUnLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJyxcbiAgICAgICAgICAgICdkYXRldGltZS1sb2NhbCcsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ3RpbWUnLFxuICAgICAgICAgICAgJ3dlZWsnXG4gICAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiBnZXRTdXBwb3J0ZWRJbnB1dFR5cGVzKCkuaGFzKHQpOyB9KTtcbiAgICAgICAgLy8gRm9yY2Ugc2V0dGVyIHRvIGJlIGNhbGxlZCBpbiBjYXNlIGlkIHdhcyBub3Qgc3BlY2lmaWVkLlxuICAgICAgICB0aGlzLmlkID0gdGhpcy5pZDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZ0NvbnRyb2wgPyB0aGlzLl9uZ0NvbnRyb2wuZGlzYWJsZWQgOiB0aGlzLl9kaXNhYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmlxdWUgaWQgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5faWQgPSB2YWx1ZSB8fCB0aGlzLl91aWQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbGFjZWhvbGRlciBhdHRyaWJ1dGUgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BsYWNlaG9sZGVyOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlciAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyQ2hhbmdlLmVtaXQodGhpcy5fcGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpcyByZXF1aXJlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9yZXF1aXJlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElucHV0IHR5cGUgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3R5cGU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHZhbHVlIHx8ICd0ZXh0JztcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlVHlwZSgpO1xuICAgICAgICAgICAgLy8gV2hlbiB1c2luZyBBbmd1bGFyIGlucHV0cywgZGV2ZWxvcGVycyBhcmUgbm8gbG9uZ2VyIGFibGUgdG8gc2V0IHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSBuYXRpdmVcbiAgICAgICAgICAgIC8vIGlucHV0IGVsZW1lbnQuIFRvIGVuc3VyZSB0aGF0IGJpbmRpbmdzIGZvciBgdHlwZWAgd29yaywgd2UgbmVlZCB0byBzeW5jIHRoZSBzZXR0ZXJcbiAgICAgICAgICAgIC8vIHdpdGggdGhlIG5hdGl2ZSBwcm9wZXJ0eS4gVGV4dGFyZWEgZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCB0aGUgdHlwZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVGV4dGFyZWEoKSAmJiBnZXRTdXBwb3J0ZWRJbnB1dFR5cGVzKCkuaGFzKHRoaXMuX3R5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndHlwZScsIHRoaXMuX3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlucHV0IGVsZW1lbnQncyB2YWx1ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlbXB0eVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBpbnB1dCBpcyBlbXB0eS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9pc05ldmVyRW1wdHkoKSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnZhbHVlID09IG51bGwgfHwgdGhpcy52YWx1ZSA9PT0gJycpICYmXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGlucHV0IGNvbnRhaW5zIGJhZCBpbnB1dC4gSWYgc28sIHdlIGtub3cgdGhhdCBpdCBvbmx5IGFwcGVhcnMgZW1wdHkgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZSBmYWlsZWQgdG8gcGFyc2UuIEZyb20gdGhlIHVzZXIncyBwZXJzcGVjdGl2ZSBpdCBpcyBub3QgZW1wdHkuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtbWFsZXJiYSk6IEFkZCBlMmUgdGVzdCBmb3IgYmFkIGlucHV0IGNhc2UuXG4gICAgICAgICAgICAgICAgIXRoaXMuX2lzQmFkSW5wdXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcIl91aWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2FjaGVkVWlkID0gdGhpcy5fY2FjaGVkVWlkIHx8IFwibWQtaW5wdXQtXCIgKyBuZXh0VW5pcXVlSWQkMSsrOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZm9jdXNlZCA9IHRydWU7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5fb25CbHVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLmZvY3VzZWQgPSBmYWxzZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLl9vbklucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbm9vcCBmdW5jdGlvbiBhbmQgaXMgdXNlZCB0byBsZXQgQW5ndWxhciBrbm93IHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAgICAvLyBBbmd1bGFyIHdpbGwgcnVuIGEgbmV3IGNoYW5nZSBkZXRlY3Rpb24gZWFjaCB0aW1lIHRoZSBgaW5wdXRgIGV2ZW50IGhhcyBiZWVuIGRpc3BhdGNoZWQuXG4gICAgICAgIC8vIEl0J3MgbmVjZXNzYXJ5IHRoYXQgQW5ndWxhciByZWNvZ25pemVzIHRoZSB2YWx1ZSBjaGFuZ2UsIGJlY2F1c2Ugd2hlbiBmbG9hdGluZ0xhYmVsXG4gICAgICAgIC8vIGlzIHNldCB0byBmYWxzZSBhbmQgQW5ndWxhciBmb3JtcyBhcmVuJ3QgdXNlZCwgdGhlIHBsYWNlaG9sZGVyIHdvbid0IHJlY29nbml6ZSB0aGVcbiAgICAgICAgLy8gdmFsdWUgY2hhbmdlcyBhbmQgd2lsbCBub3QgZGlzYXBwZWFyLlxuICAgICAgICAvLyBMaXN0ZW5pbmcgdG8gdGhlIGlucHV0IGV2ZW50IHdvdWxkbid0IGJlIG5lY2Vzc2FyeSB3aGVuIHRoZSBpbnB1dCBpcyB1c2luZyB0aGVcbiAgICAgICAgLy8gRm9ybXNNb2R1bGUgb3IgUmVhY3RpdmVGb3Jtc01vZHVsZSwgYmVjYXVzZSBBbmd1bGFyIGZvcm1zIGFsc28gbGlzdGVucyB0byBpbnB1dCBldmVudHMuXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgdGhlIGlucHV0IGlzIGEgc3VwcG9ydGVkIHR5cGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5fdmFsaWRhdGVUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoTURfSU5QVVRfSU5WQUxJRF9UWVBFUy5pbmRleE9mKHRoaXMuX3R5cGUpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TWRJbnB1dENvbnRhaW5lclVuc3VwcG9ydGVkVHlwZUVycm9yKHRoaXMuX3R5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLl9pc05ldmVyRW1wdHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uZXZlckVtcHR5SW5wdXRUeXBlcy5pbmRleE9mKHRoaXMuX3R5cGUpICE9PSAtMTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLl9pc0JhZElucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKS52YWxpZGl0eS5iYWRJbnB1dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGNvbXBvbmVudCBob3N0IGlzIGEgdGV4dGFyZWEuIElmIG5vdCByZWNvZ25pemFibGUgaXQgcmV0dXJucyBmYWxzZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLl9pc1RleHRhcmVhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYXRpdmVFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gbmF0aXZlRWxlbWVudCA/IG5hdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJyA6IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIE1kSW5wdXREaXJlY3RpdmU7XG59KCkpO1xuTWRJbnB1dERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBcImlucHV0W21kSW5wdXRdLCB0ZXh0YXJlYVttZElucHV0XSwgaW5wdXRbbWF0SW5wdXRdLCB0ZXh0YXJlYVttYXRJbnB1dF1cIixcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWlucHV0LWVsZW1lbnRdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICAvLyBOYXRpdmUgaW5wdXQgcHJvcGVydGllcyB0aGF0IGFyZSBvdmVyd3JpdHRlbiBieSBBbmd1bGFyIGlucHV0cyBuZWVkIHRvIGJlIHN5bmNlZCB3aXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudC4gT3RoZXJ3aXNlIHByb3BlcnR5IGJpbmRpbmdzIGZvciB0aG9zZSBkb24ndCB3b3JrLlxuICAgICAgICAgICAgICAgICAgICAnW2lkXSc6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgICdbcGxhY2Vob2xkZXJdJzogJ3BsYWNlaG9sZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tkaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW3JlcXVpcmVkXSc6ICdyZXF1aXJlZCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XSc6ICdhcmlhRGVzY3JpYmVkYnkgfHwgbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX29uQmx1cigpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhmb2N1cyknOiAnX29uRm9jdXMoKScsXG4gICAgICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ19vbklucHV0KCknLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRJbnB1dERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogU2VsZiB9LF0gfSxcbl07IH07XG5NZElucHV0RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdyZXF1aXJlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndHlwZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnX3BsYWNlaG9sZGVyQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG4vKipcbiAqIENvbnRhaW5lciBmb3IgdGV4dCBpbnB1dHMgdGhhdCBhcHBsaWVzIE1hdGVyaWFsIERlc2lnbiBzdHlsaW5nIGFuZCBiZWhhdmlvci5cbiAqL1xudmFyIE1kSW5wdXRDb250YWluZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfY2hhbmdlRGV0ZWN0b3JSZWZcbiAgICAgKiBAcGFyYW0gez99IF9wYXJlbnRGb3JtXG4gICAgICogQHBhcmFtIHs/fSBfcGFyZW50Rm9ybUdyb3VwXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRJbnB1dENvbnRhaW5lcihfZWxlbWVudFJlZiwgX2NoYW5nZURldGVjdG9yUmVmLCBfcGFyZW50Rm9ybSwgX3BhcmVudEZvcm1Hcm91cCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLl9wYXJlbnRGb3JtID0gX3BhcmVudEZvcm07XG4gICAgICAgIHRoaXMuX3BhcmVudEZvcm1Hcm91cCA9IF9wYXJlbnRGb3JtR3JvdXA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlnbm1lbnQgb2YgdGhlIGlucHV0IGNvbnRhaW5lcidzIGNvbnRlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsaWduID0gJ3N0YXJ0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIG9mIHRoZSBpbnB1dCBkaXZpZGVyLCBiYXNlZCBvbiB0aGUgdGhlbWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gJ3ByaW1hcnknO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhdGUgb2YgdGhlIG1kLWhpbnQgYW5kIG1kLWVycm9yIGFuaW1hdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRBbmltYXRpb25TdGF0ZSA9ICcnO1xuICAgICAgICB0aGlzLl9oaW50TGFiZWwgPSAnJztcbiAgICAgICAgLy8gVW5pcXVlIGlkIGZvciB0aGUgaGludCBsYWJlbC5cbiAgICAgICAgdGhpcy5faGludExhYmVsSWQgPSBcIm1kLWlucHV0LWhpbnQtXCIgKyBuZXh0VW5pcXVlSWQkMSsrO1xuICAgICAgICB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyID0gJ2F1dG8nO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiZGl2aWRlckNvbG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBjb2xvciBpbnN0ZWFkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbG9yOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5jb2xvciA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiaGlkZVJlcXVpcmVkTWFya2VyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHJlcXVpcmVkIG1hcmtlciBzaG91bGQgYmUgaGlkZGVuLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oaWRlUmVxdWlyZWRNYXJrZXI7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGlkZVJlcXVpcmVkTWFya2VyID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLCBcIl9zaG91bGRBbHdheXNGbG9hdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBmbG9hdGluZyBsYWJlbCBzaG91bGQgYWx3YXlzIGZsb2F0IG9yIG5vdC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZmxvYXRQbGFjZWhvbGRlciA9PT0gJ2Fsd2F5cyc7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJfY2FuUGxhY2Vob2xkZXJGbG9hdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBwbGFjZWhvbGRlciBjYW4gZmxvYXQgb3Igbm90LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyICE9PSAnbmV2ZXInOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiaGludExhYmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgZm9yIHRoZSBpbnB1dCBoaW50LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oaW50TGFiZWw7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGludExhYmVsID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzSGludHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLCBcImZsb2F0UGxhY2Vob2xkZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGFsd2F5cyBmbG9hdCwgbmV2ZXIgZmxvYXQgb3IgZmxvYXQgYXMgdGhlIHVzZXIgdHlwZXMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXI7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZmxvYXRQbGFjZWhvbGRlciA9IHZhbHVlIHx8ICdhdXRvJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlSW5wdXRDaGlsZCgpO1xuICAgICAgICB0aGlzLl9wcm9jZXNzSGludHMoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVQbGFjZWhvbGRlcnMoKTtcbiAgICAgICAgLy8gUmUtdmFsaWRhdGUgd2hlbiB0aGluZ3MgY2hhbmdlLlxuICAgICAgICB0aGlzLl9oaW50Q2hpbGRyZW4uY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3Byb2Nlc3NIaW50cygpOyB9KTtcbiAgICAgICAgdGhpcy5fbWRJbnB1dENoaWxkLl9wbGFjZWhvbGRlckNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3ZhbGlkYXRlUGxhY2Vob2xkZXJzKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlSW5wdXRDaGlsZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEF2b2lkIGFuaW1hdGlvbnMgb24gbG9hZC5cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0QW5pbWF0aW9uU3RhdGUgPSAnZW50ZXInO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBjbGFzcyBmcm9tIHRoZSBOZ0NvbnRyb2wgc2hvdWxkIGJlIGZvcndhcmRlZCB0byB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX3Nob3VsZEZvcndhcmQgPSBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250cm9sID0gdGhpcy5fbWRJbnB1dENoaWxkID8gdGhpcy5fbWRJbnB1dENoaWxkLl9uZ0NvbnRyb2wgOiBudWxsO1xuICAgICAgICByZXR1cm4gY29udHJvbCAmJiAoKGNvbnRyb2wpKVtwcm9wXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGlucHV0IGhhcyBhIHBsYWNlaG9sZGVyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX2hhc1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gISEodGhpcy5fbWRJbnB1dENoaWxkLnBsYWNlaG9sZGVyIHx8IHRoaXMuX3BsYWNlaG9sZGVyQ2hpbGQpOyB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIHVuZGVybHlpbmcgaW5wdXQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5fZm9jdXNJbnB1dCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbWRJbnB1dENoaWxkLmZvY3VzKCk7IH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgaW5wdXQgY29udGFpbmVyIGlzIGluIGFuIGVycm9yIHN0YXRlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX2lzRXJyb3JTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udHJvbCA9IHRoaXMuX21kSW5wdXRDaGlsZC5fbmdDb250cm9sO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0ludmFsaWQgPSBjb250cm9sICYmIGNvbnRyb2wuaW52YWxpZDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNUb3VjaGVkID0gY29udHJvbCAmJiBjb250cm9sLnRvdWNoZWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzU3VibWl0dGVkID0gKHRoaXMuX3BhcmVudEZvcm1Hcm91cCAmJiB0aGlzLl9wYXJlbnRGb3JtR3JvdXAuc3VibWl0dGVkKSB8fFxuICAgICAgICAgICAgKHRoaXMuX3BhcmVudEZvcm0gJiYgdGhpcy5fcGFyZW50Rm9ybS5zdWJtaXR0ZWQpO1xuICAgICAgICByZXR1cm4gISEoaXNJbnZhbGlkICYmIChpc1RvdWNoZWQgfHwgaXNTdWJtaXR0ZWQpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBkaXNwbGF5IGhpbnRzIG9yIGVycm9ycy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLl9nZXREaXNwbGF5ZWRNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9lcnJvckNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgdGhpcy5faXNFcnJvclN0YXRlKCkpID8gJ2Vycm9yJyA6ICdoaW50JztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIHBsYWNlaG9sZGVyIChlaXRoZXIgYGlucHV0YCBhdHRyaWJ1dGUgb3IgY2hpbGQgZWxlbWVudCB3aXRoIHRoZVxuICAgICAqIGBtZC1wbGFjZWhvbGRlcmAgYXR0cmlidXRlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX3ZhbGlkYXRlUGxhY2Vob2xkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbWRJbnB1dENoaWxkLnBsYWNlaG9sZGVyICYmIHRoaXMuX3BsYWNlaG9sZGVyQ2hpbGQpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kSW5wdXRDb250YWluZXJQbGFjZWhvbGRlckNvbmZsaWN0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRG9lcyBhbnkgZXh0cmEgcHJvY2Vzc2luZyB0aGF0IGlzIHJlcXVpcmVkIHdoZW4gaGFuZGxpbmcgdGhlIGhpbnRzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX3Byb2Nlc3NIaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVIaW50cygpO1xuICAgICAgICB0aGlzLl9zeW5jQXJpYURlc2NyaWJlZGJ5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGVyZSBpcyBhIG1heGltdW0gb2Ygb25lIG9mIGVhY2ggYDxtZC1oaW50PmAgYWxpZ25tZW50IHNwZWNpZmllZCwgd2l0aCB0aGVcbiAgICAgKiBhdHRyaWJ1dGUgYmVpbmcgY29uc2lkZXJlZCBhcyBgYWxpZ249XCJzdGFydFwiYC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLl92YWxpZGF0ZUhpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5faGludENoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydEhpbnRfMSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmRIaW50XzEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGludENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGludC5hbGlnbiA9PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEhpbnRfMSB8fCBfdGhpcy5oaW50TGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGdldE1kSW5wdXRDb250YWluZXJEdXBsaWNhdGVkSGludEVycm9yKCdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SGludF8xID0gaGludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGludC5hbGlnbiA9PSAnZW5kJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSGludF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBnZXRNZElucHV0Q29udGFpbmVyRHVwbGljYXRlZEhpbnRFcnJvcignZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5kSGludF8xID0gaGludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2hpbGQgaW5wdXQncyBgYXJpYS1kZXNjcmliZWRieWAgdG8gYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGUgaWRzXG4gICAgICogb2YgdGhlIGN1cnJlbnRseS1zcGVjaWZpZWQgaGludHMsIGFzIHdlbGwgYXMgYSBnZW5lcmF0ZWQgaWQgZm9yIHRoZSBoaW50IGxhYmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX3N5bmNBcmlhRGVzY3JpYmVkYnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tZElucHV0Q2hpbGQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkcyA9IFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRIaW50ID0gdGhpcy5faGludENoaWxkcmVuID9cbiAgICAgICAgICAgICAgICB0aGlzLl9oaW50Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAoaGludCkgeyByZXR1cm4gaGludC5hbGlnbiA9PT0gJ3N0YXJ0JzsgfSkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kSGludCA9IHRoaXMuX2hpbnRDaGlsZHJlbiA/XG4gICAgICAgICAgICAgICAgdGhpcy5faGludENoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKGhpbnQpIHsgcmV0dXJuIGhpbnQuYWxpZ24gPT09ICdlbmQnOyB9KSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoc3RhcnRIaW50KSB7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goc3RhcnRIaW50LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2hpbnRMYWJlbCkge1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKHRoaXMuX2hpbnRMYWJlbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRIaW50KSB7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goZW5kSGludC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tZElucHV0Q2hpbGQuYXJpYURlc2NyaWJlZGJ5ID0gaWRzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjb250YWluZXIncyBpbnB1dCBjaGlsZCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLl92YWxpZGF0ZUlucHV0Q2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWRJbnB1dENoaWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRNZElucHV0Q29udGFpbmVyTWlzc2luZ01kSW5wdXRFcnJvcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWRJbnB1dENvbnRhaW5lcjtcbn0oKSk7XG5NZElucHV0Q29udGFpbmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtaW5wdXQtY29udGFpbmVyLCBtYXQtaW5wdXQtY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtd3JhcHBlclxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1pbnB1dC10YWJsZVxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1pbnB1dC1wcmVmaXhcXFwiICpuZ0lmPVxcXCJfcHJlZml4Q2hpbGRyZW4ubGVuZ3RoXFxcIj4gPCEtLSBUT0RPKGFuZHJld3NlZ3Vpbik6IHJlbW92ZSBbbWQtcHJlZml4XSAtLT4gPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWRQcmVmaXhdLCBbbWF0UHJlZml4XSwgW21kLXByZWZpeF1cXFwiPjwvbmctY29udGVudD4gPC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1hdC1pbnB1dC1pbmZpeFxcXCIgW2NsYXNzLm1hdC1lbmRdPVxcXCJhbGlnbiA9PSAnZW5kJ1xcXCI+IDxuZy1jb250ZW50IHNlbGVjdG9yPVxcXCJpbnB1dCwgdGV4dGFyZWFcXFwiPjwvbmctY29udGVudD4gPHNwYW4gY2xhc3M9XFxcIm1hdC1pbnB1dC1wbGFjZWhvbGRlci13cmFwcGVyXFxcIj4gPGxhYmVsIGNsYXNzPVxcXCJtYXQtaW5wdXQtcGxhY2Vob2xkZXJcXFwiIFthdHRyLmZvcl09XFxcIl9tZElucHV0Q2hpbGQuaWRcXFwiIFtjbGFzcy5tYXQtZW1wdHldPVxcXCJfbWRJbnB1dENoaWxkLmVtcHR5ICYmICFfc2hvdWxkQWx3YXlzRmxvYXRcXFwiIFtjbGFzcy5tYXQtZmxvYXRdPVxcXCJfY2FuUGxhY2Vob2xkZXJGbG9hdFxcXCIgW2NsYXNzLm1hdC1hY2NlbnRdPVxcXCJjb2xvciA9PSAnYWNjZW50J1xcXCIgW2NsYXNzLm1hdC13YXJuXT1cXFwiY29sb3IgPT0gJ3dhcm4nXFxcIiAqbmdJZj1cXFwiX2hhc1BsYWNlaG9sZGVyKClcXFwiPiA8bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLXBsYWNlaG9sZGVyLCBtYXQtcGxhY2Vob2xkZXJcXFwiPjwvbmctY29udGVudD4ge3tfbWRJbnB1dENoaWxkLnBsYWNlaG9sZGVyfX0gPHNwYW4gY2xhc3M9XFxcIm1hdC1wbGFjZWhvbGRlci1yZXF1aXJlZFxcXCIgKm5nSWY9XFxcIiFoaWRlUmVxdWlyZWRNYXJrZXIgJiYgX21kSW5wdXRDaGlsZC5yZXF1aXJlZFxcXCI+Kjwvc3Bhbj4gPC9sYWJlbD4gPC9zcGFuPiA8L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWF0LWlucHV0LXN1ZmZpeFxcXCIgKm5nSWY9XFxcIl9zdWZmaXhDaGlsZHJlbi5sZW5ndGhcXFwiPiA8IS0tIFRPRE8oYW5kcmV3c2VndWluKTogcmVtb3ZlIFttZC1zdWZmaXhdIC0tPiA8bmctY29udGVudCBzZWxlY3Q9XFxcIlttZFN1ZmZpeF0sIFttYXRTdWZmaXhdLCBbbWQtc3VmZml4XVxcXCI+PC9uZy1jb250ZW50PiA8L2Rpdj4gPC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1hdC1pbnB1dC11bmRlcmxpbmVcXFwiICN1bmRlcmxpbmUgW2NsYXNzLm1hdC1kaXNhYmxlZF09XFxcIl9tZElucHV0Q2hpbGQuZGlzYWJsZWRcXFwiPiA8c3BhbiBjbGFzcz1cXFwibWF0LWlucHV0LXJpcHBsZVxcXCIgW2NsYXNzLm1hdC1hY2NlbnRdPVxcXCJjb2xvciA9PSAnYWNjZW50J1xcXCIgW2NsYXNzLm1hdC13YXJuXT1cXFwiY29sb3IgPT0gJ3dhcm4nXFxcIj48L3NwYW4+IDwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtc3Vic2NyaXB0LXdyYXBwZXJcXFwiIFtuZ1N3aXRjaF09XFxcIl9nZXREaXNwbGF5ZWRNZXNzYWdlcygpXFxcIj4gPGRpdiAqbmdTd2l0Y2hDYXNlPVxcXCInZXJyb3InXFxcIiBbQHRyYW5zaXRpb25NZXNzYWdlc109XFxcIl9zdWJzY3JpcHRBbmltYXRpb25TdGF0ZVxcXCI+IDxuZy1jb250ZW50IHNlbGVjdD1cXFwibWQtZXJyb3IsIG1hdC1lcnJvclxcXCI+PC9uZy1jb250ZW50PiA8L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWF0LWlucHV0LWhpbnQtd3JhcHBlclxcXCIgKm5nU3dpdGNoQ2FzZT1cXFwiJ2hpbnQnXFxcIiBbQHRyYW5zaXRpb25NZXNzYWdlc109XFxcIl9zdWJzY3JpcHRBbmltYXRpb25TdGF0ZVxcXCI+IDxkaXYgKm5nSWY9XFxcImhpbnRMYWJlbFxcXCIgW2lkXT1cXFwiX2hpbnRMYWJlbElkXFxcIiBjbGFzcz1cXFwibWF0LWhpbnRcXFwiPnt7aGludExhYmVsfX08L2Rpdj4gPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1oaW50Om5vdChbYWxpZ249J2VuZCddKSwgbWF0LWhpbnQ6bm90KFthbGlnbj0nZW5kJ10pXFxcIj48L25nLWNvbnRlbnQ+IDxkaXYgY2xhc3M9XFxcIm1hdC1pbnB1dC1oaW50LXNwYWNlclxcXCI+PC9kaXY+IDxuZy1jb250ZW50IHNlbGVjdD1cXFwibWQtaGludFthbGlnbj0nZW5kJ10sIG1hdC1oaW50W2FsaWduPSdlbmQnXVxcXCI+PC9uZy1jb250ZW50PiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtaW5wdXQtY29udGFpbmVye2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7bGluZS1oZWlnaHQ6bm9ybWFsO3RleHQtYWxpZ246bGVmdH1bZGlyPXJ0bF0gLm1hdC1pbnB1dC1jb250YWluZXJ7dGV4dC1hbGlnbjpyaWdodH0ubWF0LWlucHV0LWNvbnRhaW5lciAubWF0LWRhdGVwaWNrZXItdG9nZ2xlLC5tYXQtaW5wdXQtY29udGFpbmVyIC5tYXQtaWNvbnt3aWR0aDoxZW07aGVpZ2h0OjFlbTtmb250LXNpemU6MTAwJTt2ZXJ0aWNhbC1hbGlnbjp0b3B9Lm1hdC1pbnB1dC13cmFwcGVye21hcmdpbjoxZW0gMDtwYWRkaW5nLWJvdHRvbTo2cHh9Lm1hdC1pbnB1dC10YWJsZXtkaXNwbGF5OmlubGluZS10YWJsZTtmbGV4LWZsb3c6Y29sdW1uO3ZlcnRpY2FsLWFsaWduOmJvdHRvbTt3aWR0aDoxMDAlfS5tYXQtaW5wdXQtdGFibGU+KntkaXNwbGF5OnRhYmxlLWNlbGx9Lm1hdC1pbnB1dC1pbmZpeHtwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LWlucHV0LWVsZW1lbnR7Zm9udDppbmhlcml0O2JhY2tncm91bmQ6MCAwO2NvbG9yOmN1cnJlbnRDb2xvcjtib3JkZXI6bm9uZTtvdXRsaW5lOjA7cGFkZGluZzowO3dpZHRoOjEwMCU7dmVydGljYWwtYWxpZ246Ym90dG9tfS5tYXQtZW5kIC5tYXQtaW5wdXQtZWxlbWVudHt0ZXh0LWFsaWduOnJpZ2h0fVtkaXI9cnRsXSAubWF0LWVuZCAubWF0LWlucHV0LWVsZW1lbnR7dGV4dC1hbGlnbjpsZWZ0fS5tYXQtaW5wdXQtZWxlbWVudDotbW96LXVpLWludmFsaWR7Ym94LXNoYWRvdzpub25lfS5tYXQtaW5wdXQtZWxlbWVudDotd2Via2l0LWF1dG9maWxsKy5tYXQtaW5wdXQtcGxhY2Vob2xkZXItd3JhcHBlciAubWF0LWZsb2F0e2Rpc3BsYXk6YmxvY2s7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTEuMzVlbSwwKSBzY2FsZSguNzUpO3dpZHRoOjEzMy4zMzMzMyU7dHJhbnNpdGlvbjpub25lfS5tYXQtaW5wdXQtZWxlbWVudDo6cGxhY2Vob2xkZXJ7Y29sb3I6dHJhbnNwYXJlbnQhaW1wb3J0YW50fS5tYXQtaW5wdXQtZWxlbWVudDo6LW1vei1wbGFjZWhvbGRlcntjb2xvcjp0cmFuc3BhcmVudCFpbXBvcnRhbnR9Lm1hdC1pbnB1dC1lbGVtZW50Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOnRyYW5zcGFyZW50IWltcG9ydGFudH0ubWF0LWlucHV0LWVsZW1lbnQ6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOnRyYW5zcGFyZW50IWltcG9ydGFudH0ubWF0LWlucHV0LXBsYWNlaG9sZGVye3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDtmb250LXNpemU6MTAwJTtwb2ludGVyLWV2ZW50czpub25lO3otaW5kZXg6MTtwYWRkaW5nLXRvcDoxZW07d2lkdGg6MTAwJTtkaXNwbGF5Om5vbmU7d2hpdGUtc3BhY2U6bm93cmFwO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7b3ZlcmZsb3c6aGlkZGVuO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNmb3JtLW9yaWdpbjpib3R0b20gbGVmdDt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLHdpZHRoIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LWlucHV0LXBsYWNlaG9sZGVyLm1hdC1lbXB0eXtkaXNwbGF5OmJsb2NrO2N1cnNvcjp0ZXh0fS5tYXQtZm9jdXNlZCAubWF0LWlucHV0LXBsYWNlaG9sZGVyLm1hdC1mbG9hdCwubWF0LWlucHV0LXBsYWNlaG9sZGVyLm1hdC1mbG9hdDpub3QoLm1hdC1lbXB0eSl7ZGlzcGxheTpibG9jazt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwtMS4zNWVtLDApIHNjYWxlKC43NSk7d2lkdGg6MTMzLjMzMzMzJX1bZGlyPXJ0bF0gLm1hdC1pbnB1dC1wbGFjZWhvbGRlcnt0cmFuc2Zvcm0tb3JpZ2luOmJvdHRvbSByaWdodDtsZWZ0OmF1dG87cmlnaHQ6MH0ubWF0LWlucHV0LXBsYWNlaG9sZGVyOm5vdCgubWF0LWVtcHR5KXt0cmFuc2l0aW9uOm5vbmV9Lm1hdC1pbnB1dC1wbGFjZWhvbGRlci13cmFwcGVye3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6LTFlbTt3aWR0aDoxMDAlO3BhZGRpbmctdG9wOjFlbTtvdmVyZmxvdzpoaWRkZW47cG9pbnRlci1ldmVudHM6bm9uZTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApfS5tYXQtaW5wdXQtcGxhY2Vob2xkZXItd3JhcHBlcjo6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmlubGluZS10YWJsZX0ubWF0LWlucHV0LXVuZGVybGluZXtwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MXB4O3dpZHRoOjEwMCU7bWFyZ2luLXRvcDo0cHg7Ym9yZGVyLXRvcC13aWR0aDoxcHg7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZH0ubWF0LWlucHV0LXVuZGVybGluZS5tYXQtZGlzYWJsZWR7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgwLDAsMCwuMjYpIDAscmdiYSgwLDAsMCwuMjYpIDMzJSx0cmFuc3BhcmVudCAwKTtiYWNrZ3JvdW5kLXNpemU6NHB4IDFweDtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtib3JkZXItdG9wOjA7YmFja2dyb3VuZC1wb3NpdGlvbjowfS5tYXQtaW5wdXQtdW5kZXJsaW5lIC5tYXQtaW5wdXQtcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoycHg7ei1pbmRleDoxO3RvcDotMXB4O3dpZHRoOjEwMCU7dHJhbnNmb3JtLW9yaWdpbjo1MCU7dHJhbnNmb3JtOnNjYWxlWCguNSk7dmlzaWJpbGl0eTpoaWRkZW47dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4zcyBjdWJpYy1iZXppZXIoLjU1LDAsLjU1LC4yKX0ubWF0LWZvY3VzZWQgLm1hdC1pbnB1dC11bmRlcmxpbmUgLm1hdC1pbnB1dC1yaXBwbGUsLm1hdC1pbnB1dC1pbnZhbGlkIC5tYXQtaW5wdXQtdW5kZXJsaW5lIC5tYXQtaW5wdXQtcmlwcGxle3Zpc2liaWxpdHk6dmlzaWJsZTt0cmFuc2Zvcm06c2NhbGVYKDEpO3RyYW5zaXRpb246dHJhbnNmb3JtIDE1MG1zIGxpbmVhcixiYWNrZ3JvdW5kLWNvbG9yIC4zcyBjdWJpYy1iZXppZXIoLjU1LDAsLjU1LC4yKX0ubWF0LWlucHV0LXN1YnNjcmlwdC13cmFwcGVye3Bvc2l0aW9uOmFic29sdXRlO2ZvbnQtc2l6ZTo3NSU7dG9wOjEwMCU7d2lkdGg6MTAwJTttYXJnaW4tdG9wOi0xLjJlbTtsaW5lLWhlaWdodDoxLjJlbTtvdmVyZmxvdzpoaWRkZW59Lm1hdC1pbnB1dC1oaW50LXdyYXBwZXJ7ZGlzcGxheTpmbGV4fS5tYXQtaW5wdXQtaGludC1zcGFjZXJ7ZmxleDoxIDAgMTBweH0ubWF0LWlucHV0LWVycm9ye2Rpc3BsYXk6YmxvY2t9Lm1hdC1pbnB1dC1wcmVmaXgsLm1hdC1pbnB1dC1zdWZmaXh7d2lkdGg6LjFweDt3aGl0ZS1zcGFjZTpub3dyYXB9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPWlucHV0LWNvbnRhaW5lci5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ3RyYW5zaXRpb25NZXNzYWdlcycsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdlbnRlcicsIHN0eWxlKHsgb3BhY2l0eTogMSwgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwJSknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gZW50ZXInLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC0xMDAlKScgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnMzAwbXMgY3ViaWMtYmV6aWVyKDAuNTUsIDAsIDAuNTUsIDAuMiknKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsaWduIGF0dHJpYnV0ZSB0byBwcmV2ZW50IGl0IGZyb20gaW50ZXJmZXJpbmcgd2l0aCBsYXlvdXQuXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hbGlnbl0nOiAnbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWlucHV0LWNvbnRhaW5lcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWlucHV0LWludmFsaWRdJzogJ19pc0Vycm9yU3RhdGUoKScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWZvY3VzZWRdJzogJ19tZElucHV0Q2hpbGQuZm9jdXNlZCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubmctdW50b3VjaGVkXSc6ICdfc2hvdWxkRm9yd2FyZChcInVudG91Y2hlZFwiKScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubmctdG91Y2hlZF0nOiAnX3Nob3VsZEZvcndhcmQoXCJ0b3VjaGVkXCIpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1wcmlzdGluZV0nOiAnX3Nob3VsZEZvcndhcmQoXCJwcmlzdGluZVwiKScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubmctZGlydHldJzogJ19zaG91bGRGb3J3YXJkKFwiZGlydHlcIiknLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXZhbGlkXSc6ICdfc2hvdWxkRm9yd2FyZChcInZhbGlkXCIpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1pbnZhbGlkXSc6ICdfc2hvdWxkRm9yd2FyZChcImludmFsaWRcIiknLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXBlbmRpbmddJzogJ19zaG91bGRGb3J3YXJkKFwicGVuZGluZ1wiKScsXG4gICAgICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19mb2N1c0lucHV0KCknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRJbnB1dENvbnRhaW5lci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICB7IHR5cGU6IE5nRm9ybSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBGb3JtR3JvdXBEaXJlY3RpdmUsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbk1kSW5wdXRDb250YWluZXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2FsaWduJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGl2aWRlckNvbG9yJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdoaWRlUmVxdWlyZWRNYXJrZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2hpbnRMYWJlbCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZmxvYXRQbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndW5kZXJsaW5lUmVmJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3VuZGVybGluZScsXSB9LF0sXG4gICAgJ19tZElucHV0Q2hpbGQnOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtNZElucHV0RGlyZWN0aXZlLF0gfSxdLFxuICAgICdfcGxhY2Vob2xkZXJDaGlsZCc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW01kUGxhY2Vob2xkZXIsXSB9LF0sXG4gICAgJ19lcnJvckNoaWxkcmVuJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWRFcnJvckRpcmVjdGl2ZSxdIH0sXSxcbiAgICAnX2hpbnRDaGlsZHJlbic6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kSGludCxdIH0sXSxcbiAgICAnX3ByZWZpeENoaWxkcmVuJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWRQcmVmaXgsXSB9LF0sXG4gICAgJ19zdWZmaXhDaGlsZHJlbic6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kU3VmZml4LF0gfSxdLFxufTtcbi8qKlxuICogRGlyZWN0aXZlIHRvIGF1dG9tYXRpY2FsbHkgcmVzaXplIGEgdGV4dGFyZWEgdG8gZml0IGl0cyBjb250ZW50LlxuICovXG52YXIgTWRUZXh0YXJlYUF1dG9zaXplID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kVGV4dGFyZWFBdXRvc2l6ZShfZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLCBcIm1pblJvd3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIG1kQXV0b3NpemVNaW5Sb3dzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21pblJvd3M7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWluUm93cyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2V0TWluSGVpZ2h0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLCBcIm1heFJvd3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIG1kQXV0b3NpemVNYXhSb3dzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21heFJvd3M7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWF4Um93cyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2V0TWF4SGVpZ2h0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLCBcIm1kQXV0b3NpemVNaW5Sb3dzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1pbmltdW0gbnVtYmVyIG9mIHJvd3MgZm9yIHRoaXMgdGV4dGFyZWEuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWluUm93czsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMubWluUm93cyA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZSwgXCJtZEF1dG9zaXplTWF4Um93c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIGZvciB0aGlzIHRleHRhcmVhLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1heFJvd3M7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLm1heFJvd3MgPSB2YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHRleHRhcmVhIGFzIGRldGVybWluZWQgYnkgbWluUm93cy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUuX3NldE1pbkhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWluSGVpZ2h0ID0gdGhpcy5taW5Sb3dzICYmIHRoaXMuX2NhY2hlZExpbmVIZWlnaHQgP1xuICAgICAgICAgICAgdGhpcy5taW5Sb3dzICogdGhpcy5fY2FjaGVkTGluZUhlaWdodCArIFwicHhcIiA6IG51bGw7XG4gICAgICAgIGlmIChtaW5IZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFRleHRhcmVhU3R5bGUoJ21pbkhlaWdodCcsIG1pbkhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1heGltdW0gaGVpZ2h0IG9mIHRoZSB0ZXh0YXJlYSBhcyBkZXRlcm1pbmVkIGJ5IG1heFJvd3MuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLl9zZXRNYXhIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1heEhlaWdodCA9IHRoaXMubWF4Um93cyAmJiB0aGlzLl9jYWNoZWRMaW5lSGVpZ2h0ID9cbiAgICAgICAgICAgIHRoaXMubWF4Um93cyAqIHRoaXMuX2NhY2hlZExpbmVIZWlnaHQgKyBcInB4XCIgOiBudWxsO1xuICAgICAgICBpZiAobWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRUZXh0YXJlYVN0eWxlKCdtYXhIZWlnaHQnLCBtYXhIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYWNoZVRleHRhcmVhTGluZUhlaWdodCgpO1xuICAgICAgICB0aGlzLnJlc2l6ZVRvRml0Q29udGVudCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9uIHRoZSB0ZXh0YXJlYSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLl9zZXRUZXh0YXJlYVN0eWxlID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0YXJlYSA9ICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB0ZXh0YXJlYS5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhY2hlIHRoZSBoZWlnaHQgb2YgYSBzaW5nbGUtcm93IHRleHRhcmVhLlxuICAgICAqXG4gICAgICogV2UgbmVlZCB0byBrbm93IGhvdyBsYXJnZSBhIHNpbmdsZSBcInJvd1wiIG9mIGEgdGV4dGFyZWEgaXMgaW4gb3JkZXIgdG8gYXBwbHkgbWluUm93cyBhbmRcbiAgICAgKiBtYXhSb3dzLiBGb3IgdGhlIGluaXRpYWwgdmVyc2lvbiwgd2Ugd2lsbCBhc3N1bWUgdGhhdCB0aGUgaGVpZ2h0IG9mIGEgc2luZ2xlIGxpbmUgaW4gdGhlXG4gICAgICogdGV4dGFyZWEgZG9lcyBub3QgZXZlciBjaGFuZ2UuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLl9jYWNoZVRleHRhcmVhTGluZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dGFyZWEgPSAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgLy8gVXNlIGEgY2xvbmUgZWxlbWVudCBiZWNhdXNlIHdlIGhhdmUgdG8gb3ZlcnJpZGUgc29tZSBzdHlsZXMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRhcmVhQ2xvbmUgPSAodGV4dGFyZWEuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgICAgIHRleHRhcmVhQ2xvbmUucm93cyA9IDE7XG4gICAgICAgIC8vIFVzZSBgcG9zaXRpb246IGFic29sdXRlYCBzbyB0aGF0IHRoaXMgZG9lc24ndCBjYXVzZSBhIGJyb3dzZXIgbGF5b3V0IGFuZCB1c2VcbiAgICAgICAgLy8gYHZpc2liaWxpdHk6IGhpZGRlbmAgc28gdGhhdCBub3RoaW5nIGlzIHJlbmRlcmVkLiBDbGVhciBhbnkgb3RoZXIgc3R5bGVzIHRoYXRcbiAgICAgICAgLy8gd291bGQgYWZmZWN0IHRoZSBoZWlnaHQuXG4gICAgICAgIHRleHRhcmVhQ2xvbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgICAgIHRleHRhcmVhQ2xvbmUuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS5taW5IZWlnaHQgPSAnJztcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS5tYXhIZWlnaHQgPSAnJztcbiAgICAgICAgdGV4dGFyZWEucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0ZXh0YXJlYUNsb25lKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkTGluZUhlaWdodCA9IHRleHRhcmVhQ2xvbmUuY2xpZW50SGVpZ2h0O1xuICAgICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRleHRhcmVhQ2xvbmUpO1xuICAgICAgICAvLyBNaW4gYW5kIG1heCBoZWlnaHRzIGhhdmUgdG8gYmUgcmUtY2FsY3VsYXRlZCBpZiB0aGUgY2FjaGVkIGxpbmUgaGVpZ2h0IGNoYW5nZXNcbiAgICAgICAgdGhpcy5fc2V0TWluSGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuX3NldE1heEhlaWdodCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzaXplIHRoZSB0ZXh0YXJlYSB0byBmaXQgaXRzIGNvbnRlbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLnJlc2l6ZVRvRml0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dGFyZWEgPSAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRleHRhcmVhIGhlaWdodCB0byBhdXRvIGluIG9yZGVyIHRvIHNocmluayBiYWNrIHRvIGl0cyBkZWZhdWx0IHNpemUuXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgLy8gVXNlIHRoZSBzY3JvbGxIZWlnaHQgdG8ga25vdyBob3cgbGFyZ2UgdGhlIHRleHRhcmVhICp3b3VsZCogYmUgaWYgZml0IGl0cyBlbnRpcmUgdmFsdWUuXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IHRleHRhcmVhLnNjcm9sbEhlaWdodCArIFwicHhcIjtcbiAgICB9O1xuICAgIHJldHVybiBNZFRleHRhcmVhQXV0b3NpemU7XG59KCkpO1xuTWRUZXh0YXJlYUF1dG9zaXplLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICd0ZXh0YXJlYVttZC1hdXRvc2l6ZV0sIHRleHRhcmVhW21kVGV4dGFyZWFBdXRvc2l6ZV0sJyArXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0YXJlYVttYXQtYXV0b3NpemVdLCB0ZXh0YXJlYVttYXRUZXh0YXJlYUF1dG9zaXplXScsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtZFRleHRhcmVhQXV0b3NpemUnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJyhpbnB1dCknOiAncmVzaXplVG9GaXRDb250ZW50KCknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVGV4dGFyZWFBdXRvc2l6ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG5dOyB9O1xuTWRUZXh0YXJlYUF1dG9zaXplLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdtaW5Sb3dzJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtYXhSb3dzJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtZEF1dG9zaXplTWluUm93cyc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbWRBdXRvc2l6ZU1heFJvd3MnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xudmFyIE1kSW5wdXRNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZElucHV0TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRJbnB1dE1vZHVsZTtcbn0oKSk7XG5NZElucHV0TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRFcnJvckRpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgTWRIaW50LFxuICAgICAgICAgICAgICAgICAgICBNZElucHV0Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBNZElucHV0RGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICBNZFBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICBNZFByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgTWRTdWZmaXgsXG4gICAgICAgICAgICAgICAgICAgIE1kVGV4dGFyZWFBdXRvc2l6ZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgUGxhdGZvcm1Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kRXJyb3JEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIE1kSGludCxcbiAgICAgICAgICAgICAgICAgICAgTWRJbnB1dENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgTWRJbnB1dERpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgTWRQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgTWRQcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIE1kU3VmZml4LFxuICAgICAgICAgICAgICAgICAgICBNZFRleHRhcmVhQXV0b3NpemUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRJbnB1dE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIHVzZWQgd2hlbiBvcGVuaW5nIGEgc25hY2stYmFyLlxuICovXG52YXIgTWRTbmFja0JhckNvbmZpZyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXJDb25maWcoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcG9saXRlbmVzcyBsZXZlbCBmb3IgdGhlIE1kQXJpYUxpdmVBbm5vdW5jZXIgYW5ub3VuY2VtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2xpdGVuZXNzID0gJ2Fzc2VydGl2ZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXNzYWdlIHRvIGJlIGFubm91bmNlZCBieSB0aGUgTWRBcmlhTGl2ZUFubm91bmNlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbm5vdW5jZW1lbnRNZXNzYWdlID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlldyBjb250YWluZXIgdG8gcGxhY2UgdGhlIG92ZXJsYXkgZm9yIHRoZSBzbmFjayBiYXIgaW50by5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGVuZ3RoIG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGF1dG9tYXRpY2FsbHkgZGlzbWlzc2luZyB0aGUgc25hY2sgYmFyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0IGxheW91dCBkaXJlY3Rpb24gZm9yIHRoZSBzbmFjayBiYXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICdsdHInO1xuICAgIH1cbiAgICByZXR1cm4gTWRTbmFja0JhckNvbmZpZztcbn0oKSk7XG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIHNuYWNrIGJhciBkaXNwYXRjaGVkIGZyb20gdGhlIHNuYWNrIGJhciBzZXJ2aWNlLlxuICovXG52YXIgTWRTbmFja0JhclJlZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lckluc3RhbmNlXG4gICAgICogQHBhcmFtIHs/fSBfb3ZlcmxheVJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXJSZWYoaW5zdGFuY2UsIGNvbnRhaW5lckluc3RhbmNlLCBfb3ZlcmxheVJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gX292ZXJsYXlSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhlIHVzZXIgdGhhdCB0aGUgc25hY2sgYmFyIGhhcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hZnRlckNsb3NlZCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhlIHVzZXIgdGhhdCB0aGUgc25hY2sgYmFyIGFjdGlvbiB3YXMgY2FsbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25BY3Rpb24gPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvLyBTZXRzIHRoZSByZWFkb25seSBpbnN0YW5jZSBvZiB0aGUgc25hY2sgYmFyIGNvbnRlbnQgY29tcG9uZW50LlxuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckluc3RhbmNlID0gY29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgIC8vIERpc21pc3Mgc25hY2tiYXIgb24gYWN0aW9uLlxuICAgICAgICB0aGlzLm9uQWN0aW9uKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRpc21pc3MoKTsgfSk7XG4gICAgICAgIGNvbnRhaW5lckluc3RhbmNlLl9vbkV4aXQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2ZpbmlzaERpc21pc3MoKTsgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNuYWNrQmFyUmVmLnByb3RvdHlwZSwgXCJpbnN0YW5jZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBtYWtpbmcgdXAgdGhlIGNvbnRlbnQgb2YgdGhlIHNuYWNrIGJhci5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEaXNtaXNzZXMgdGhlIHNuYWNrIGJhci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLmRpc21pc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWZ0ZXJDbG9zZWQuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckluc3RhbmNlLmV4aXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIHNuYWNrYmFyIGFjdGlvbiBjbGlja2VkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0JhclJlZi5wcm90b3R5cGUuX2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vbkFjdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQWN0aW9uLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQWN0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBzbmFja2JhciBhcyBvcGVuZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2FmdGVyT3BlbmVkLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5fYWZ0ZXJPcGVuZWQubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5fYWZ0ZXJPcGVuZWQuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHRoZSBET00gYWZ0ZXIgY2xvc2luZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLl9maW5pc2hEaXNtaXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQubmV4dCgpO1xuICAgICAgICB0aGlzLl9hZnRlckNsb3NlZC5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBvYnNlcnZhYmxlIHRoYXQgaXMgbm90aWZpZWQgd2hlbiB0aGUgc25hY2sgYmFyIGlzIGZpbmlzaGVkIGNsb3NpbmcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyUmVmLnByb3RvdHlwZS5hZnRlckRpc21pc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FmdGVyQ2xvc2VkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBvYnNlcnZhYmxlIHRoYXQgaXMgbm90aWZpZWQgd2hlbiB0aGUgc25hY2sgYmFyIGhhcyBvcGVuZWQgYW5kIGFwcGVhcmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0JhclJlZi5wcm90b3R5cGUuYWZ0ZXJPcGVuZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckluc3RhbmNlLl9vbkVudGVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGFuIG9ic2VydmFibGUgdGhhdCBpcyBub3RpZmllZCB3aGVuIHRoZSBzbmFjayBiYXIgYWN0aW9uIGlzIGNhbGxlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25BY3Rpb24uYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRTbmFja0JhclJlZjtcbn0oKSk7XG4vLyBUT0RPKGplbGJvdXJuKTogd2UgY2FuJ3QgdXNlIGNvbnN0YW50cyBmcm9tIGFuaW1hdGlvbi50cyBoZXJlIGJlY2F1c2UgeW91IGNhbid0IHVzZVxuLy8gYSB0ZXh0IGludGVycG9sYXRpb24gaW4gYW55dGhpbmcgdGhhdCBpcyBhbmFseXplZCBzdGF0aWNhbGx5IHdpdGggbmdjIChmb3IgQW9UIGNvbXBpbGUpLlxudmFyIFNIT1dfQU5JTUFUSU9OID0gJzIyNW1zIGN1YmljLWJlemllcigwLjQsMC4wLDEsMSknO1xudmFyIEhJREVfQU5JTUFUSU9OID0gJzE5NW1zIGN1YmljLWJlemllcigwLjAsMC4wLDAuMiwxKSc7XG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCB0aGF0IHdyYXBzIHVzZXItcHJvdmlkZWQgc25hY2sgYmFyIGNvbnRlbnQuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kU25hY2tCYXJDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kU25hY2tCYXJDb250YWluZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRTbmFja0JhckNvbnRhaW5lcihfbmdab25lLCBfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICBfdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIF90aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhhdCB0aGUgc25hY2sgYmFyIGhhcyBleGl0ZWQgZnJvbSB2aWV3LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub25FeGl0ID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGF0IHRoZSBzbmFjayBiYXIgaGFzIGZpbmlzaGVkIGVudGVyaW5nIHRoZSB2aWV3LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub25FbnRlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3RhdGUgb2YgdGhlIHNuYWNrIGJhciBhbmltYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYW5pbWF0aW9uU3RhdGUgPSAnaW5pdGlhbCc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgY29tcG9uZW50IHBvcnRhbCBhcyBjb250ZW50IHRvIHRoaXMgc25hY2sgYmFyIGNvbnRhaW5lci5cbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gcG9ydGFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5hdHRhY2hDb21wb25lbnRQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3J0YWxIb3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBhdHRhY2ggc25hY2sgYmFyIGNvbnRlbnQgYWZ0ZXIgY29udGVudCBpcyBhbHJlYWR5IGF0dGFjaGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc25hY2tCYXJDb25maWcuZXh0cmFDbGFzc2VzKSB7XG4gICAgICAgICAgICAvLyBOb3QgdGhlIG1vc3QgZWZmaWNpZW50IHdheSBvZiBhZGRpbmcgY2xhc3NlcywgYnV0IHRoZSByZW5kZXJlciBkb2Vzbid0IGFsbG93IHVzXG4gICAgICAgICAgICAvLyB0byBwYXNzIGluIGFuIGFycmF5IG9yIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3QuXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zbmFja0JhckNvbmZpZy5leHRyYUNsYXNzZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzc0NsYXNzID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgY3NzQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3J0YWxIb3N0LmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgdGVtcGxhdGUgcG9ydGFsIGFzIGNvbnRlbnQgdG8gdGhpcyBzbmFjayBiYXIgY29udGFpbmVyLlxuICAgICAqIEBwYXJhbSB7P30gcG9ydGFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5hdHRhY2hUZW1wbGF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZW5kIG9mIGFuaW1hdGlvbnMsIHVwZGF0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgc25hY2tiYXIuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0JhckNvbnRhaW5lci5wcm90b3R5cGUub25BbmltYXRpb25FbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICd2b2lkJyB8fCBldmVudC50b1N0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZUV4aXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB3ZSBzaG91bGRuJ3QgdXNlIGB0aGlzYCBpbnNpZGUgdGhlIHpvbmUgY2FsbGJhY2ssXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGNhbiBjYXVzZSBhIG1lbW9yeSBsZWFrLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb25FbnRlcl8xID0gdGhpcy5vbkVudGVyO1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb25FbnRlcl8xLm5leHQoKTtcbiAgICAgICAgICAgICAgICBvbkVudGVyXzEuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCZWdpbiBhbmltYXRpb24gb2Ygc25hY2sgYmFyIGVudHJhbmNlIGludG8gdmlldy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gJ3Zpc2libGUnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHJlc29sdmluZyB3aGVuIHRoZSBlbnRlciBhbmltYXRpb24gY29tcGxldGVzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0JhckNvbnRhaW5lci5wcm90b3R5cGUuX29uRW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAndmlzaWJsZSc7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRW50ZXIuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCZWdpbiBhbmltYXRpb24gb2YgdGhlIHNuYWNrIGJhciBleGl0aW5nIGZyb20gdmlldy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLmV4aXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnY29tcGxldGUnO1xuICAgICAgICByZXR1cm4gdGhpcy5fb25FeGl0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBjb21wbGV0ZXMgYWZ0ZXIgdGhlIGNsb3NpbmcgYW5pbWF0aW9uIGlzIGRvbmUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5fb25FeGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkV4aXQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoZSBleGl0IGNhbGxiYWNrcyBoYXZlIGJlZW4gaW52b2tlZCB3aGVuIHRoZSBlbGVtZW50IGlzIGRlc3Ryb3llZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZUV4aXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciB0aGUgem9uZSB0byBzZXR0bGUgYmVmb3JlIHJlbW92aW5nIHRoZSBlbGVtZW50LiBIZWxwcyBwcmV2ZW50XG4gICAgICogZXJyb3JzIHdoZXJlIHdlIGVuZCB1cCByZW1vdmluZyBhbiBlbGVtZW50IHdoaWNoIGlzIGluIHRoZSBtaWRkbGUgb2YgYW4gYW5pbWF0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0JhckNvbnRhaW5lci5wcm90b3R5cGUuX2NvbXBsZXRlRXhpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTm90ZTogd2Ugc2hvdWxkbid0IHVzZSBgdGhpc2AgaW5zaWRlIHRoZSB6b25lIGNhbGxiYWNrLFxuICAgICAgICAvLyBiZWNhdXNlIGl0IGNhbiBjYXVzZSBhIG1lbW9yeSBsZWFrLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbkV4aXQgPSB0aGlzLm9uRXhpdDtcbiAgICAgICAgdGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkuZmlyc3QoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb25FeGl0Lm5leHQoKTtcbiAgICAgICAgICAgIG9uRXhpdC5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNZFNuYWNrQmFyQ29udGFpbmVyO1xufShCYXNlUG9ydGFsSG9zdCkpO1xuTWRTbmFja0JhckNvbnRhaW5lci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ3NuYWNrLWJhci1jb250YWluZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy10ZW1wbGF0ZSBjZGtQb3J0YWxIb3N0PjwvbmctdGVtcGxhdGU+IFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7Ym94LXNoYWRvdzowIDNweCA1cHggLTFweCByZ2JhKDAsMCwwLC4yKSwwIDZweCAxMHB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDE4cHggMCByZ2JhKDAsMCwwLC4xMik7YmFja2dyb3VuZDojMzIzMjMyO2JvcmRlci1yYWRpdXM6MnB4O2JveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXgtd2lkdGg6NTY4cHg7bWluLXdpZHRoOjI4OHB4O3BhZGRpbmc6MTRweCAyNHB4O3RyYW5zZm9ybTp0cmFuc2xhdGVZKDEwMCUpfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpezpob3N0e2JvcmRlcjpzb2xpZCAxcHh9fSAvKiMgc291cmNlTWFwcGluZ1VSTD1zbmFjay1iYXItY29udGFpbmVyLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnYWxlcnQnLFxuICAgICAgICAgICAgICAgICAgICAnW0BzdGF0ZV0nOiAnYW5pbWF0aW9uU3RhdGUnLFxuICAgICAgICAgICAgICAgICAgICAnKEBzdGF0ZS5kb25lKSc6ICdvbkFuaW1hdGlvbkVuZCgkZXZlbnQpJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdzdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdpbml0aWFsJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDEwMCUpJyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgndmlzaWJsZScsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwJSknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdjb21wbGV0ZScsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgxMDAlKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbigndmlzaWJsZSA9PiBjb21wbGV0ZScsIGFuaW1hdGUoSElERV9BTklNQVRJT04pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2luaXRpYWwgPT4gdmlzaWJsZSwgdm9pZCA9PiB2aXNpYmxlJywgYW5pbWF0ZShTSE9XX0FOSU1BVElPTikpLFxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU25hY2tCYXJDb250YWluZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuXTsgfTtcbk1kU25hY2tCYXJDb250YWluZXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ19wb3J0YWxIb3N0JzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbUG9ydGFsSG9zdERpcmVjdGl2ZSxdIH0sXSxcbn07XG4vKipcbiAqIEEgY29tcG9uZW50IHVzZWQgdG8gb3BlbiBhcyB0aGUgZGVmYXVsdCBzbmFjayBiYXIsIG1hdGNoaW5nIG1hdGVyaWFsIHNwZWMuXG4gKiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc25hY2sgYmFyIHNlcnZpY2UuXG4gKi9cbnZhciBTaW1wbGVTbmFja0JhciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZVNuYWNrQmFyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNtaXNzZXMgdGhlIHNuYWNrIGJhci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVNuYWNrQmFyLnByb3RvdHlwZS5kaXNtaXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNuYWNrQmFyUmVmLl9hY3Rpb24oKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVTbmFja0Jhci5wcm90b3R5cGUsIFwiaGFzQWN0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBhY3Rpb24gYnV0dG9uIHNob3VsZCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5hY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBTaW1wbGVTbmFja0Jhcjtcbn0oKSk7XG5TaW1wbGVTbmFja0Jhci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ3NpbXBsZS1zbmFjay1iYXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcInt7bWVzc2FnZX19IDxidXR0b24gY2xhc3M9XFxcIm1hdC1zaW1wbGUtc25hY2tiYXItYWN0aW9uXFxcIiAqbmdJZj1cXFwiaGFzQWN0aW9uXFxcIiAoY2xpY2spPVxcXCJkaXNtaXNzKClcXFwiPnt7YWN0aW9ufX08L2J1dHRvbj4gXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXNpbXBsZS1zbmFja2JhcntkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47Y29sb3I6I2ZmZjtsaW5lLWhlaWdodDoyMHB4O2ZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWZ9Lm1hdC1zaW1wbGUtc25hY2tiYXItYWN0aW9uey13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtjdXJzb3I6cG9pbnRlcjtvdXRsaW5lOjA7Ym9yZGVyOm5vbmU7YmFja2dyb3VuZDowIDA7Y29sb3I6aW5oZXJpdDtsaW5lLWhlaWdodDoxO2ZsZXgtc2hyaW5rOjA7bWFyZ2luLWxlZnQ6NDhweDtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtd2VpZ2h0OjYwMH1bZGlyPXJ0bF0gLm1hdC1zaW1wbGUtc25hY2tiYXItYWN0aW9ue21hcmdpbi1yaWdodDo0OHB4O21hcmdpbi1sZWZ0OjB9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZS1zbmFjay1iYXIuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpbXBsZS1zbmFja2Jhcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5TaW1wbGVTbmFja0Jhci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBFeHRlbmRzIGFuIG9iamVjdCB3aXRoIHRoZSAqZW51bWVyYWJsZSogYW5kICpvd24qIHByb3BlcnRpZXMgb2Ygb25lIG9yIG1vcmUgc291cmNlIG9iamVjdHMsXG4gKiBzaW1pbGFyIHRvIE9iamVjdC5hc3NpZ24uXG4gKlxuICogQHBhcmFtIHs/fSBkZXN0IFRoZSBvYmplY3Qgd2hpY2ggd2lsbCBoYXZlIHByb3BlcnRpZXMgY29waWVkIHRvIGl0LlxuICogQHBhcmFtIHsuLi4/fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cyBmcm9tIHdoaWNoIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHRlbmRPYmplY3QoZGVzdCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKGRlc3QgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfYSA9IDAsIHNvdXJjZXNfMSA9IHNvdXJjZXM7IF9hIDwgc291cmNlc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc18xW19hXTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuLyoqXG4gKiBTZXJ2aWNlIHRvIGRpc3BhdGNoIE1hdGVyaWFsIERlc2lnbiBzbmFjayBiYXIgbWVzc2FnZXMuXG4gKi9cbnZhciBNZFNuYWNrQmFyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfb3ZlcmxheVxuICAgICAqIEBwYXJhbSB7P30gX2xpdmVcbiAgICAgKiBAcGFyYW0gez99IF9wYXJlbnRTbmFja0JhclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXIoX292ZXJsYXksIF9saXZlLCBfcGFyZW50U25hY2tCYXIpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheSA9IF9vdmVybGF5O1xuICAgICAgICB0aGlzLl9saXZlID0gX2xpdmU7XG4gICAgICAgIHRoaXMuX3BhcmVudFNuYWNrQmFyID0gX3BhcmVudFNuYWNrQmFyO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbmFja0Jhci5wcm90b3R5cGUsIFwiX29wZW5lZFNuYWNrQmFyUmVmXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IG9wZW5lZCBzbmFja2JhciBhdCAqYW55KiBsZXZlbC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFNuYWNrQmFyID9cbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnRTbmFja0Jhci5fb3BlbmVkU25hY2tCYXJSZWYgOiB0aGlzLl9zbmFja0JhclJlZkF0VGhpc0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnRTbmFja0Jhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudFNuYWNrQmFyLl9vcGVuZWRTbmFja0JhclJlZiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc25hY2tCYXJSZWZBdFRoaXNMZXZlbCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBkaXNwYXRjaGVzIGEgc25hY2sgYmFyIHdpdGggYSBjdXN0b20gY29tcG9uZW50IGZvciB0aGUgY29udGVudCwgcmVtb3ZpbmcgYW55XG4gICAgICogY3VycmVudGx5IG9wZW5lZCBzbmFjayBiYXJzLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudCBDb21wb25lbnQgdG8gYmUgaW5zdGFudGlhdGVkLlxuICAgICAqIEBwYXJhbSB7Pz19IGNvbmZpZyBFeHRyYSBjb25maWd1cmF0aW9uIGZvciB0aGUgc25hY2sgYmFyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0Jhci5wcm90b3R5cGUub3BlbkZyb21Db21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uZmlnID0gX2FwcGx5Q29uZmlnRGVmYXVsdHMoY29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3ZlcmxheVJlZiA9IHRoaXMuX2NyZWF0ZU92ZXJsYXkoY29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc25hY2tCYXJDb250YWluZXIgPSB0aGlzLl9hdHRhY2hTbmFja0JhckNvbnRhaW5lcihvdmVybGF5UmVmLCBjb25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzbmFja0JhclJlZiA9IHRoaXMuX2F0dGFjaFNuYWNrYmFyQ29udGVudChjb21wb25lbnQsIHNuYWNrQmFyQ29udGFpbmVyLCBvdmVybGF5UmVmKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgc25hY2tiYXIgaXMgZGlzbWlzc2VkLCBjbGVhciB0aGUgcmVmZXJlbmNlIHRvIGl0LlxuICAgICAgICBzbmFja0JhclJlZi5hZnRlckRpc21pc3NlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgc25hY2tiYXIgcmVmIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcmVwbGFjZWQgYnkgYSBuZXdlciBzbmFja2Jhci5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYgPT0gc25hY2tCYXJSZWYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgYSBzbmFjayBiYXIgaXMgYWxyZWFkeSBpbiB2aWV3LCBkaXNtaXNzIGl0IGFuZCBlbnRlciB0aGUgbmV3IHNuYWNrIGJhciBhZnRlciBleGl0XG4gICAgICAgIC8vIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgICAgaWYgKHRoaXMuX29wZW5lZFNuYWNrQmFyUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuZWRTbmFja0JhclJlZi5hZnRlckRpc21pc3NlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc25hY2tCYXJSZWYuY29udGFpbmVySW5zdGFuY2UuZW50ZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYuZGlzbWlzcygpO1xuICAgICAgICAgICAgLy8gSWYgbm8gc25hY2sgYmFyIGlzIGluIHZpZXcsIGVudGVyIHRoZSBuZXcgc25hY2sgYmFyLlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc25hY2tCYXJSZWYuY29udGFpbmVySW5zdGFuY2UuZW50ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIGRpc21pc3MgdGltZW91dCBpcyBwcm92aWRlZCwgc2V0IHVwIGRpc21pc3MgYmFzZWQgb24gYWZ0ZXIgdGhlIHNuYWNrYmFyIGlzIG9wZW5lZC5cbiAgICAgICAgaWYgKGNvbmZpZy5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHNuYWNrQmFyUmVmLmFmdGVyT3BlbmVkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNuYWNrQmFyUmVmLmRpc21pc3MoKTsgfSwgY29uZmlnLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpdmUuYW5ub3VuY2UoY29uZmlnLmFubm91bmNlbWVudE1lc3NhZ2UsIGNvbmZpZy5wb2xpdGVuZXNzKTtcbiAgICAgICAgdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYgPSBzbmFja0JhclJlZjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5lZFNuYWNrQmFyUmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBzbmFja2JhciB3aXRoIGEgbWVzc2FnZSBhbmQgYW4gb3B0aW9uYWwgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBzaG93IGluIHRoZSBzbmFja2Jhci5cbiAgICAgKiBAcGFyYW0gez89fSBhY3Rpb24gVGhlIGxhYmVsIGZvciB0aGUgc25hY2tiYXIgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Pz19IGNvbmZpZyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHNuYWNrYmFyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0Jhci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBhY3Rpb24sIGNvbmZpZykge1xuICAgICAgICBpZiAoYWN0aW9uID09PSB2b2lkIDApIHsgYWN0aW9uID0gJyc7IH1cbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIGNvbmZpZy5hbm5vdW5jZW1lbnRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2ltcGxlU25hY2tCYXJSZWYgPSB0aGlzLm9wZW5Gcm9tQ29tcG9uZW50KFNpbXBsZVNuYWNrQmFyLCBjb25maWcpO1xuICAgICAgICBzaW1wbGVTbmFja0JhclJlZi5pbnN0YW5jZS5zbmFja0JhclJlZiA9IHNpbXBsZVNuYWNrQmFyUmVmO1xuICAgICAgICBzaW1wbGVTbmFja0JhclJlZi5pbnN0YW5jZS5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgc2ltcGxlU25hY2tCYXJSZWYuaW5zdGFuY2UuYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICByZXR1cm4gc2ltcGxlU25hY2tCYXJSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNtaXNzZXMgdGhlIGN1cnJlbnRseS12aXNpYmxlIHNuYWNrIGJhci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLmRpc21pc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcGVuZWRTbmFja0JhclJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYuZGlzbWlzcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgc25hY2sgYmFyIGNvbnRhaW5lciBjb21wb25lbnQgdG8gdGhlIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5UmVmXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLl9hdHRhY2hTbmFja0JhckNvbnRhaW5lciA9IGZ1bmN0aW9uIChvdmVybGF5UmVmLCBjb25maWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbmVyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChNZFNuYWNrQmFyQ29udGFpbmVyLCBjb25maWcudmlld0NvbnRhaW5lclJlZik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lclJlZiA9IG92ZXJsYXlSZWYuYXR0YWNoKGNvbnRhaW5lclBvcnRhbCk7XG4gICAgICAgIGNvbnRhaW5lclJlZi5pbnN0YW5jZS5zbmFja0JhckNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lclJlZi5pbnN0YW5jZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBsYWNlcyBhIG5ldyBjb21wb25lbnQgYXMgdGhlIGNvbnRlbnQgb2YgdGhlIHNuYWNrIGJhciBjb250YWluZXIuXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5UmVmXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyLnByb3RvdHlwZS5fYXR0YWNoU25hY2tiYXJDb250ZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgY29udGFpbmVyLCBvdmVybGF5UmVmKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoY29tcG9uZW50KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudFJlZiA9IGNvbnRhaW5lci5hdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNZFNuYWNrQmFyUmVmKGNvbnRlbnRSZWYuaW5zdGFuY2UsIGNvbnRhaW5lciwgb3ZlcmxheVJlZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG92ZXJsYXkgYW5kIHBsYWNlcyBpdCBpbiB0aGUgY29ycmVjdCBsb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gez99IGNvbmZpZyBUaGUgdXNlci1zcGVjaWZpZWQgc25hY2sgYmFyIGNvbmZpZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0ZSQkMSA9IG5ldyBPdmVybGF5U3RhdGUoKTtcbiAgICAgICAgc3RhdGUkJDEuZGlyZWN0aW9uID0gY29uZmlnLmRpcmVjdGlvbjtcbiAgICAgICAgc3RhdGUkJDEucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX292ZXJsYXkucG9zaXRpb24oKS5nbG9iYWwoKS5jZW50ZXJIb3Jpem9udGFsbHkoKS5ib3R0b20oJzAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuY3JlYXRlKHN0YXRlJCQxKTtcbiAgICB9O1xuICAgIHJldHVybiBNZFNuYWNrQmFyO1xufSgpKTtcbk1kU25hY2tCYXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU25hY2tCYXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBPdmVybGF5LCB9LFxuICAgIHsgdHlwZTogTGl2ZUFubm91bmNlciwgfSxcbiAgICB7IHR5cGU6IE1kU25hY2tCYXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogU2tpcFNlbGYgfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBBcHBsaWVzIGRlZmF1bHQgb3B0aW9ucyB0byB0aGUgc25hY2tiYXIgY29uZmlnLlxuICogQHBhcmFtIHs/fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gd2hpY2ggdGhlIGRlZmF1bHRzIHdpbGwgYmUgYXBwbGllZC5cbiAqIEByZXR1cm4gez99IFRoZSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBkZWZhdWx0cyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBfYXBwbHlDb25maWdEZWZhdWx0cyhjb25maWcpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JqZWN0KG5ldyBNZFNuYWNrQmFyQ29uZmlnKCksIGNvbmZpZyk7XG59XG52YXIgTWRTbmFja0Jhck1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNuYWNrQmFyTW9kdWxlO1xufSgpKTtcbk1kU25hY2tCYXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgUG9ydGFsTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kU25hY2tCYXJDb250YWluZXIsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNuYWNrQmFyQ29udGFpbmVyLCBTaW1wbGVTbmFja0Jhcl0sXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTWRTbmFja0JhckNvbnRhaW5lciwgU2ltcGxlU25hY2tCYXJdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01kU25hY2tCYXIsIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNuYWNrQmFyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFVzZWQgdG8gZmxhZyB0YWIgbGFiZWxzIGZvciB1c2Ugd2l0aCB0aGUgcG9ydGFsIGRpcmVjdGl2ZVxuICovXG52YXIgTWRUYWJMYWJlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRUYWJMYWJlbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlUmVmXG4gICAgICogQHBhcmFtIHs/fSB2aWV3Q29udGFpbmVyUmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRUYWJMYWJlbCh0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZFRhYkxhYmVsO1xufShUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSkpO1xuTWRUYWJMYWJlbC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLXRhYi1sYWJlbF0sIFttYXQtdGFiLWxhYmVsXScsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVGFiTGFiZWwuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgfSxcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG5dOyB9O1xudmFyIE1kVGFiID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfdmlld0NvbnRhaW5lclJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kVGFiKF92aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwbGFpbiB0ZXh0IGxhYmVsIGZvciB0aGUgdGFiLCB1c2VkIHdoZW4gdGhlcmUgaXMgbm8gdGVtcGxhdGUgbGFiZWwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHRMYWJlbCA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBvcnRhbCB0aGF0IHdpbGwgYmUgdGhlIGhvc3RlZCBjb250ZW50IG9mIHRoZSB0YWJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvbnRlbnRQb3J0YWwgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlbGF0aXZlbHkgaW5kZXhlZCBwb3NpdGlvbiB3aGVyZSAwIHJlcHJlc2VudHMgdGhlIGNlbnRlciwgbmVnYXRpdmUgaXMgbGVmdCwgYW5kIHBvc2l0aXZlXG4gICAgICAgICAqIHJlcHJlc2VudHMgdGhlIHJpZ2h0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5pdGlhbCByZWxhdGl2ZWx5IGluZGV4IG9yaWdpbiBvZiB0aGUgdGFiIGlmIGl0IHdhcyBjcmVhdGVkIGFuZCBzZWxlY3RlZCBhZnRlciB0aGVyZVxuICAgICAgICAgKiB3YXMgYWxyZWFkeSBhIHNlbGVjdGVkIHRhYi4gUHJvdmlkZXMgY29udGV4dCBvZiB3aGF0IHBvc2l0aW9uIHRoZSB0YWIgc2hvdWxkIG9yaWdpbmF0ZSBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmlnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWIucHJvdG90eXBlLCBcImNvbnRlbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udGVudFBvcnRhbDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRhYiBpcyBkaXNhYmxlZFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb250ZW50UG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX2NvbnRlbnQsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kVGFiO1xufSgpKTtcbk1kVGFiLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtdGFiLCBtYXQtdGFiJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8IS0tIENyZWF0ZSBhIHRlbXBsYXRlIGZvciB0aGUgY29udGVudCBvZiB0aGUgPG1kLXRhYj4gc28gdGhhdCB3ZSBjYW4gZ3JhYiBhIHJlZmVyZW5jZSB0byB0aGlzIFRlbXBsYXRlUmVmIGFuZCB1c2UgaXQgaW4gYSBQb3J0YWwgdG8gcmVuZGVyIHRoZSB0YWIgY29udGVudCBpbiB0aGUgYXBwcm9wcmlhdGUgcGxhY2UgaW4gdGhlIHRhYi1ncm91cC4gLS0+IDxuZy10ZW1wbGF0ZT48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9uZy10ZW1wbGF0ZT4gXCIsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVGFiLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbl07IH07XG5NZFRhYi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAndGVtcGxhdGVMYWJlbCc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW01kVGFiTGFiZWwsXSB9LF0sXG4gICAgJ19jb250ZW50JzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbVGVtcGxhdGVSZWYsXSB9LF0sXG4gICAgJ3RleHRMYWJlbCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2xhYmVsJyxdIH0sXSxcbiAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xuLyoqXG4gKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRCdzIGZvciBlYWNoIHRhYiBjb21wb25lbnRcbiAqL1xudmFyIG5leHRJZCQyID0gMDtcbi8qKlxuICogQSBzaW1wbGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgb24gZm9jdXMgb3Igc2VsZWN0aW9uIGNoYW5nZXMuXG4gKi9cbnZhciBNZFRhYkNoYW5nZUV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWJDaGFuZ2VFdmVudCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kVGFiQ2hhbmdlRXZlbnQ7XG59KCkpO1xuLyoqXG4gKiBNYXRlcmlhbCBkZXNpZ24gdGFiLWdyb3VwIGNvbXBvbmVudC4gIFN1cHBvcnRzIGJhc2ljIHRhYiBwYWlycyAobGFiZWwgKyBjb250ZW50KSBhbmQgaW5jbHVkZXNcbiAqIGFuaW1hdGVkIGluay1iYXIsIGtleWJvYXJkIG5hdmlnYXRpb24sIGFuZCBzY3JlZW4gcmVhZGVyLlxuICogU2VlOiBodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL2NvbXBvbmVudHMvdGFicy5odG1sXG4gKi9cbnZhciBNZFRhYkdyb3VwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFRhYkdyb3VwKF9yZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFiIGluZGV4IHRoYXQgc2hvdWxkIGJlIHNlbGVjdGVkIGFmdGVyIHRoZSBjb250ZW50IGhhcyBiZWVuIGNoZWNrZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmRleFRvU2VsZWN0ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNuYXBzaG90IG9mIHRoZSBoZWlnaHQgb2YgdGhlIHRhYiBib2R5IHdyYXBwZXIgYmVmb3JlIGFub3RoZXIgdGFiIGlzIGFjdGl2YXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RhYkJvZHlXcmFwcGVySGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRhYiBncm91cCBzaG91bGQgZ3JvdyB0byB0aGUgc2l6ZSBvZiB0aGUgYWN0aXZlIHRhYlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZHluYW1pY0hlaWdodCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNhYmxlUmlwcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUG9zaXRpb24gb2YgdGhlIHRhYiBoZWFkZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlYWRlclBvc2l0aW9uID0gJ2Fib3ZlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBmb2N1cyBoYXMgY2hhbmdlZCB3aXRoaW4gYSB0YWIgZ3JvdXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB0YWIgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKHRydWUpO1xuICAgICAgICB0aGlzLl9ncm91cElkID0gbmV4dElkJDIrKztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiR3JvdXAucHJvdG90eXBlLCBcImR5bmFtaWNIZWlnaHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZHluYW1pY0hlaWdodDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2R5bmFtaWNIZWlnaHQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiX2R5bmFtaWNIZWlnaHREZXByZWNhdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2R5bmFtaWNIZWlnaHQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9keW5hbWljSGVpZ2h0ID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJkaXNhYmxlUmlwcGxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgcmlwcGxlcyBmb3IgdGhlIHRhYi1ncm91cCBzaG91bGQgYmUgZGlzYWJsZWQgb3Igbm90LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlUmlwcGxlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZVJpcHBsZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSW5kZXg7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGFjdGl2ZSB0YWIuXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2luZGV4VG9TZWxlY3QgPSB2YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiR3JvdXAucHJvdG90eXBlLCBcInNlbGVjdGVkSW5kZXhDaGFuZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogT3V0cHV0IHRvIGVuYWJsZSBzdXBwb3J0IGZvciB0d28td2F5IGJpbmRpbmcgb24gYFsoc2VsZWN0ZWRJbmRleCldYFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RDaGFuZ2UubWFwKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuaW5kZXg7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBZnRlciB0aGUgY29udGVudCBpcyBjaGVja2VkLCB0aGlzIGNvbXBvbmVudCBrbm93cyB3aGF0IHRhYnMgaGF2ZSBiZWVuIGRlZmluZWRcbiAgICAgKiBhbmQgd2hhdCB0aGUgc2VsZWN0ZWQgaW5kZXggc2hvdWxkIGJlLiBUaGlzIGlzIHdoZXJlIHdlIGNhbiBrbm93IGV4YWN0bHkgd2hhdCBwb3NpdGlvblxuICAgICAqIGVhY2ggdGFiIHNob3VsZCBiZSBpbiBhY2NvcmRpbmcgdG8gdGhlIG5ldyBzZWxlY3RlZCBpbmRleCwgYW5kIGFkZGl0aW9uYWxseSB3ZSBrbm93IGhvd1xuICAgICAqIGEgbmV3IHNlbGVjdGVkIHRhYiBzaG91bGQgdHJhbnNpdGlvbiBpbiAoZnJvbSB0aGUgbGVmdCBvciByaWdodCkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIENsYW1wIHRoZSBuZXh0IHNlbGVjdGVkIGluZGV4IHRvIHRoZSBib3VuZHMgb2YgMCBhbmQgdGhlIHRhYnMgbGVuZ3RoLiBOb3RlIHRoZSBgfHwgMGAsIHdoaWNoXG4gICAgICAgIC8vIGVuc3VyZXMgdGhhdCB2YWx1ZXMgbGlrZSBOYU4gY2FuJ3QgZ2V0IHRocm91Z2ggYW5kIHdoaWNoIHdvdWxkIG90aGVyd2lzZSB0aHJvdyB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50IGludG8gYW4gaW5maW5pdGUgbG9vcCAoc2luY2UgTWF0aC5tYXgoTmFOLCAwKSA9PT0gTmFOKS5cbiAgICAgICAgdGhpcy5faW5kZXhUb1NlbGVjdCA9XG4gICAgICAgICAgICBNYXRoLm1pbih0aGlzLl90YWJzLmxlbmd0aCAtIDEsIE1hdGgubWF4KHRoaXMuX2luZGV4VG9TZWxlY3QgfHwgMCwgMCkpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGNoYW5nZSBpbiBzZWxlY3RlZCBpbmRleCwgZW1pdCBhIGNoYW5nZSBldmVudC4gU2hvdWxkIG5vdCB0cmlnZ2VyIGlmXG4gICAgICAgIC8vIHRoZSBzZWxlY3RlZCBpbmRleCBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLlxuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRJbmRleCAhPSB0aGlzLl9pbmRleFRvU2VsZWN0ICYmIHRoaXMuX3NlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RDaGFuZ2UuZW1pdCh0aGlzLl9jcmVhdGVDaGFuZ2VFdmVudCh0aGlzLl9pbmRleFRvU2VsZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dXAgdGhlIHBvc2l0aW9uIGZvciBlYWNoIHRhYiBhbmQgb3B0aW9uYWxseSBzZXR1cCBhbiBvcmlnaW4gb24gdGhlIG5leHQgc2VsZWN0ZWQgdGFiLlxuICAgICAgICB0aGlzLl90YWJzLmZvckVhY2goZnVuY3Rpb24gKHRhYiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRhYi5wb3NpdGlvbiA9IGluZGV4IC0gX3RoaXMuX2luZGV4VG9TZWxlY3Q7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgc2VsZWN0ZWQgdGFiLCB0aGVuIHNldCB1cCBhbiBvcmlnaW4gZm9yIHRoZSBuZXh0IHNlbGVjdGVkIHRhYlxuICAgICAgICAgICAgLy8gaWYgaXQgZG9lc24ndCBoYXZlIG9uZSBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKF90aGlzLl9zZWxlY3RlZEluZGV4ICE9IG51bGwgJiYgdGFiLnBvc2l0aW9uID09IDAgJiYgIXRhYi5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICB0YWIub3JpZ2luID0gX3RoaXMuX2luZGV4VG9TZWxlY3QgLSBfdGhpcy5fc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSB0aGlzLl9pbmRleFRvU2VsZWN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2FpdHMgb25lIGZyYW1lIGZvciB0aGUgdmlldyB0byB1cGRhdGUsIHRoZW4gdXBkYXRlcyB0aGUgaW5rIGJhclxuICAgICAqIE5vdGU6IFRoaXMgbXVzdCBiZSBydW4gb3V0c2lkZSBvZiB0aGUgem9uZSBvciBpdCB3aWxsIGNyZWF0ZSBhbiBpbmZpbml0ZSBjaGFuZ2UgZGV0ZWN0aW9uIGxvb3AuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX2ZvY3VzQ2hhbmdlZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlLmVtaXQodGhpcy5fY3JlYXRlQ2hhbmdlRXZlbnQoaW5kZXgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9jcmVhdGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudCA9IG5ldyBNZFRhYkNoYW5nZUV2ZW50O1xuICAgICAgICBldmVudC5pbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAodGhpcy5fdGFicyAmJiB0aGlzLl90YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgZXZlbnQudGFiID0gdGhpcy5fdGFicy50b0FycmF5KClbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGxhYmVsIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9nZXRUYWJMYWJlbElkID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIFwibWQtdGFiLWxhYmVsLVwiICsgdGhpcy5fZ3JvdXBJZCArIFwiLVwiICsgaTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGNvbnRlbnQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gaVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX2dldFRhYkNvbnRlbnRJZCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBcIm1kLXRhYi1jb250ZW50LVwiICsgdGhpcy5fZ3JvdXBJZCArIFwiLVwiICsgaTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgYm9keSB3cmFwcGVyIHRvIHRoZSBoZWlnaHQgb2YgdGhlIGFjdGl2YXRpbmcgdGFiIGlmIGR5bmFtaWNcbiAgICAgKiBoZWlnaHQgcHJvcGVydHkgaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0gez99IHRhYkhlaWdodFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX3NldFRhYkJvZHlXcmFwcGVySGVpZ2h0ID0gZnVuY3Rpb24gKHRhYkhlaWdodCkge1xuICAgICAgICBpZiAoIXRoaXMuX2R5bmFtaWNIZWlnaHQgfHwgIXRoaXMuX3RhYkJvZHlXcmFwcGVySGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fdGFiQm9keVdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIHRoaXMuX3RhYkJvZHlXcmFwcGVySGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgIC8vIFRoaXMgY29uZGl0aW9uYWwgZm9yY2VzIHRoZSBicm93c2VyIHRvIHBhaW50IHRoZSBoZWlnaHQgc28gdGhhdFxuICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIHRvIHRoZSBuZXcgaGVpZ2h0IGNhbiBoYXZlIGFuIG9yaWdpbi5cbiAgICAgICAgaWYgKHRoaXMuX3RhYkJvZHlXcmFwcGVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl90YWJCb2R5V3JhcHBlci5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgdGFiSGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGhlaWdodCBvZiB0aGUgdGFiIGJvZHkgd3JhcHBlci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9yZW1vdmVUYWJCb2R5V3JhcHBlckhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFiQm9keVdyYXBwZXJIZWlnaHQgPSB0aGlzLl90YWJCb2R5V3JhcHBlci5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fdGFiQm9keVdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsICcnKTtcbiAgICB9O1xuICAgIHJldHVybiBNZFRhYkdyb3VwO1xufSgpKTtcbk1kVGFiR3JvdXAuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC10YWItZ3JvdXAsIG1hdC10YWItZ3JvdXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxtZC10YWItaGVhZGVyICN0YWJIZWFkZXIgW3NlbGVjdGVkSW5kZXhdPVxcXCJzZWxlY3RlZEluZGV4XFxcIiBbZGlzYWJsZVJpcHBsZV09XFxcImRpc2FibGVSaXBwbGVcXFwiIChpbmRleEZvY3VzZWQpPVxcXCJfZm9jdXNDaGFuZ2VkKCRldmVudClcXFwiIChzZWxlY3RGb2N1c2VkSW5kZXgpPVxcXCJzZWxlY3RlZEluZGV4ID0gJGV2ZW50XFxcIj4gPGRpdiBjbGFzcz1cXFwibWF0LXRhYi1sYWJlbFxcXCIgcm9sZT1cXFwidGFiXFxcIiBtZC10YWItbGFiZWwtd3JhcHBlciBtZC1yaXBwbGUgKm5nRm9yPVxcXCJsZXQgdGFiIG9mIF90YWJzOyBsZXQgaSA9IGluZGV4XFxcIiBbaWRdPVxcXCJfZ2V0VGFiTGFiZWxJZChpKVxcXCIgW3RhYkluZGV4XT1cXFwic2VsZWN0ZWRJbmRleCA9PSBpID8gMCA6IC0xXFxcIiBbYXR0ci5hcmlhLWNvbnRyb2xzXT1cXFwiX2dldFRhYkNvbnRlbnRJZChpKVxcXCIgW2F0dHIuYXJpYS1zZWxlY3RlZF09XFxcInNlbGVjdGVkSW5kZXggPT0gaVxcXCIgW2NsYXNzLm1hdC10YWItbGFiZWwtYWN0aXZlXT1cXFwic2VsZWN0ZWRJbmRleCA9PSBpXFxcIiBbZGlzYWJsZWRdPVxcXCJ0YWIuZGlzYWJsZWRcXFwiIFttZFJpcHBsZURpc2FibGVkXT1cXFwiZGlzYWJsZVJpcHBsZVxcXCIgKGNsaWNrKT1cXFwidGFiSGVhZGVyLmZvY3VzSW5kZXggPSBzZWxlY3RlZEluZGV4ID0gaVxcXCI+IDwhLS0gSWYgdGhlcmUgaXMgYSBsYWJlbCB0ZW1wbGF0ZSwgdXNlIGl0LiAtLT4gPG5nLXRlbXBsYXRlIFtuZ0lmXT1cXFwidGFiLnRlbXBsYXRlTGFiZWxcXFwiPiA8bmctdGVtcGxhdGUgW2Nka1BvcnRhbEhvc3RdPVxcXCJ0YWIudGVtcGxhdGVMYWJlbFxcXCI+PC9uZy10ZW1wbGF0ZT4gPC9uZy10ZW1wbGF0ZT4gPCEtLSBJZiB0aGVyZSBpcyBub3QgYSBsYWJlbCB0ZW1wbGF0ZSwgZmFsbCBiYWNrIHRvIHRoZSB0ZXh0IGxhYmVsLiAtLT4gPG5nLXRlbXBsYXRlIFtuZ0lmXT1cXFwiIXRhYi50ZW1wbGF0ZUxhYmVsXFxcIj57e3RhYi50ZXh0TGFiZWx9fTwvbmctdGVtcGxhdGU+IDwvZGl2PiA8L21kLXRhYi1oZWFkZXI+IDxkaXYgY2xhc3M9XFxcIm1hdC10YWItYm9keS13cmFwcGVyXFxcIiAjdGFiQm9keVdyYXBwZXI+IDxtZC10YWItYm9keSByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgKm5nRm9yPVxcXCJsZXQgdGFiIG9mIF90YWJzOyBsZXQgaSA9IGluZGV4XFxcIiBbaWRdPVxcXCJfZ2V0VGFiQ29udGVudElkKGkpXFxcIiBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVxcXCJfZ2V0VGFiTGFiZWxJZChpKVxcXCIgW2NsYXNzLm1hdC10YWItYm9keS1hY3RpdmVdPVxcXCJzZWxlY3RlZEluZGV4ID09IGlcXFwiIFtjb250ZW50XT1cXFwidGFiLmNvbnRlbnRcXFwiIFtwb3NpdGlvbl09XFxcInRhYi5wb3NpdGlvblxcXCIgW29yaWdpbl09XFxcInRhYi5vcmlnaW5cXFwiIChvbkNlbnRlcmVkKT1cXFwiX3JlbW92ZVRhYkJvZHlXcmFwcGVySGVpZ2h0KClcXFwiIChvbkNlbnRlcmluZyk9XFxcIl9zZXRUYWJCb2R5V3JhcHBlckhlaWdodCgkZXZlbnQpXFxcIj4gPC9tZC10YWItYm9keT4gPC9kaXY+IFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmfTpob3N0Lm1hdC10YWItZ3JvdXAtaW52ZXJ0ZWQtaGVhZGVye2ZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlfS5tYXQtdGFiLWxhYmVse2xpbmUtaGVpZ2h0OjQ4cHg7aGVpZ2h0OjQ4cHg7cGFkZGluZzowIDEycHg7Zm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXdlaWdodDo1MDA7Y3Vyc29yOnBvaW50ZXI7Ym94LXNpemluZzpib3JkZXItYm94O29wYWNpdHk6LjY7bWluLXdpZHRoOjE2MHB4O3RleHQtYWxpZ246Y2VudGVyO3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtdGFiLWxhYmVsOmZvY3Vze291dGxpbmU6MDtvcGFjaXR5OjF9QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpey5tYXQtdGFiLWxhYmVse21pbi13aWR0aDo3MnB4fX06aG9zdFttYXQtc3RyZXRjaC10YWJzXSAubWF0LXRhYi1sYWJlbCw6aG9zdFttZC1zdHJldGNoLXRhYnNdIC5tYXQtdGFiLWxhYmVse2ZsZXgtYmFzaXM6MDtmbGV4LWdyb3c6MX0ubWF0LXRhYi1ib2R5LXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVuO2Rpc3BsYXk6ZmxleDt0cmFuc2l0aW9uOmhlaWdodCAuNXMgY3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKX0ubWF0LXRhYi1ib2R5e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO2Rpc3BsYXk6YmxvY2s7b3ZlcmZsb3c6aGlkZGVufS5tYXQtdGFiLWJvZHkubWF0LXRhYi1ib2R5LWFjdGl2ZXtwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdy14OmhpZGRlbjtvdmVyZmxvdy15OmF1dG87ei1pbmRleDoxO2ZsZXgtZ3JvdzoxfTpob3N0Lm1hdC10YWItZ3JvdXAtZHluYW1pYy1oZWlnaHQgLm1hdC10YWItYm9keS5tYXQtdGFiLWJvZHktYWN0aXZle292ZXJmbG93LXk6aGlkZGVufS5tYXQtdGFiLWRpc2FibGVke2N1cnNvcjpkZWZhdWx0O3BvaW50ZXItZXZlbnRzOm5vbmV9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPXRhYi1ncm91cC5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1ncm91cF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1ncm91cC1keW5hbWljLWhlaWdodF0nOiAnZHluYW1pY0hlaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1ncm91cC1pbnZlcnRlZC1oZWFkZXJdJzogJ2hlYWRlclBvc2l0aW9uID09PSBcImJlbG93XCInLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUYWJHcm91cC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbl07IH07XG5NZFRhYkdyb3VwLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdfdGFicyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kVGFiLF0gfSxdLFxuICAgICdfdGFiQm9keVdyYXBwZXInOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsndGFiQm9keVdyYXBwZXInLF0gfSxdLFxuICAgICdkeW5hbWljSGVpZ2h0JzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdfZHluYW1pY0hlaWdodERlcHJlY2F0ZWQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZC1keW5hbWljLWhlaWdodCcsXSB9LF0sXG4gICAgJ2Rpc2FibGVSaXBwbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkSW5kZXgnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2hlYWRlclBvc2l0aW9uJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzZWxlY3RlZEluZGV4Q2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnZm9jdXNDaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdzZWxlY3RDaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxufTtcbi8qKlxuICogVXNlZCBpbiB0aGUgYG1kLXRhYi1ncm91cGAgdmlldyB0byBkaXNwbGF5IHRhYiBsYWJlbHMuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kVGFiTGFiZWxXcmFwcGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRUYWJMYWJlbFdyYXBwZXIoZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdGFiIGxhYmVsIGlzIGRpc2FibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiTGFiZWxXcmFwcGVyLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0cyBmb2N1cyBvbiB0aGUgd3JhcHBlciBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkxhYmVsV3JhcHBlci5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiTGFiZWxXcmFwcGVyLnByb3RvdHlwZS5nZXRPZmZzZXRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJMYWJlbFdyYXBwZXIucHJvdG90eXBlLmdldE9mZnNldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgfTtcbiAgICByZXR1cm4gTWRUYWJMYWJlbFdyYXBwZXI7XG59KCkpO1xuTWRUYWJMYWJlbFdyYXBwZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC10YWItbGFiZWwtd3JhcHBlcl0sIFttYXQtdGFiLWxhYmVsLXdyYXBwZXJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFRhYkxhYmVsV3JhcHBlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG5dOyB9O1xuTWRUYWJMYWJlbFdyYXBwZXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2Rpc2FibGVkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbi8qKlxuICogVGhlIGluay1iYXIgaXMgdXNlZCB0byBkaXNwbGF5IGFuZCBhbmltYXRlIHRoZSBsaW5lIHVuZGVybmVhdGggdGhlIGN1cnJlbnQgYWN0aXZlIHRhYiBsYWJlbC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRJbmtCYXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZElua0JhcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmLCBfbmdab25lKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHN0eWxlcyBmcm9tIHRoZSBwcm92aWRlZCBlbGVtZW50IGluIG9yZGVyIHRvIGFsaWduIHRoZSBpbmstYmFyIHRvIHRoYXQgZWxlbWVudC5cbiAgICAgKiBTaG93cyB0aGUgaW5rIGJhciBpZiBwcmV2aW91c2x5IHNldCBhcyBoaWRkZW4uXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuYWxpZ25Ub0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlcmVyLnNldFN0eWxlKF90aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdsZWZ0JywgX3RoaXMuX2dldExlZnRQb3NpdGlvbihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlcmVyLnNldFN0eWxlKF90aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIF90aGlzLl9nZXRFbGVtZW50V2lkdGgoZWxlbWVudCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIGluayBiYXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgaW5rIGJhci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5rQmFyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBwaXhlbCBkaXN0YW5jZSBmcm9tIHRoZSBsZWZ0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBlbGVtZW50IGluIHN0cmluZyBmb3JtYXQuXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuX2dldExlZnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vZmZzZXRMZWZ0ICsgJ3B4JyA6ICcwJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgcGl4ZWwgd2lkdGggZnJvbSB0aGUgcHJvdmlkZWQgZWxlbWVudCBpbiBzdHJpbmcgZm9ybWF0LlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbmtCYXIucHJvdG90eXBlLl9nZXRFbGVtZW50V2lkdGggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggKyAncHgnIDogJzAnO1xuICAgIH07XG4gICAgcmV0dXJuIE1kSW5rQmFyO1xufSgpKTtcbk1kSW5rQmFyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1pbmstYmFyLCBtYXQtaW5rLWJhcicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1pbmstYmFyXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZElua0Jhci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG5dOyB9O1xuLyoqXG4gKiBOYXZpZ2F0aW9uIGNvbXBvbmVudCBtYXRjaGluZyB0aGUgc3R5bGVzIG9mIHRoZSB0YWIgZ3JvdXAgaGVhZGVyLlxuICogUHJvdmlkZXMgYW5jaG9yZWQgbmF2aWdhdGlvbiB3aXRoIGFuaW1hdGVkIGluayBiYXIuXG4gKi9cbnZhciBNZFRhYk5hdkJhciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2RpclxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kVGFiTmF2QmFyKF9kaXIsIF9uZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbWJpbmVzIGxpc3RlbmVycyB0aGF0IHdpbGwgcmUtYWxpZ24gdGhlIGluayBiYXIgd2hlbmV2ZXIgdGhleSdyZSBpbnZva2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVhbGlnbklua0JhciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBjb21wb25lbnQgdGhhdCB0aGUgYWN0aXZlIGxpbmsgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiTmF2QmFyLnByb3RvdHlwZS51cGRhdGVBY3RpdmVMaW5rID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlTGlua0NoYW5nZWQgPSB0aGlzLl9hY3RpdmVMaW5rRWxlbWVudCAhPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9hY3RpdmVMaW5rRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiTmF2QmFyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JlYWxpZ25JbmtCYXIgPSB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyQ2hhbmdlID0gX3RoaXMuX2RpciA/IF90aGlzLl9kaXIuZGlyQ2hhbmdlIDogT2JzZXJ2YWJsZS5vZihudWxsKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc2l6ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgICAgICBPYnNlcnZhYmxlLmZyb21FdmVudCh3aW5kb3csICdyZXNpemUnKS5hdWRpdFRpbWUoMTApIDpcbiAgICAgICAgICAgICAgICBPYnNlcnZhYmxlLm9mKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGUubWVyZ2UoZGlyQ2hhbmdlLCByZXNpemUpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYWxpZ25JbmtCYXIoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBhY3RpdmUgbGluayBoYXMgYmVlbiBjaGFuZ2VkIGFuZCwgaWYgc28sIHdpbGwgdXBkYXRlIHRoZSBpbmsgYmFyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJOYXZCYXIucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUxpbmtDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGlnbklua0JhcigpO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlTGlua0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYk5hdkJhci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWFsaWduSW5rQmFyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWFsaWduSW5rQmFyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLl9yZWFsaWduSW5rQmFyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxpZ25zIHRoZSBpbmsgYmFyIHRvIHRoZSBhY3RpdmUgbGluay5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiTmF2QmFyLnByb3RvdHlwZS5fYWxpZ25JbmtCYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVMaW5rRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5faW5rQmFyLmFsaWduVG9FbGVtZW50KHRoaXMuX2FjdGl2ZUxpbmtFbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWRUYWJOYXZCYXI7XG59KCkpO1xuTWRUYWJOYXZCYXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdbbWQtdGFiLW5hdi1iYXJdLCBbbWF0LXRhYi1uYXYtYmFyXScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXRhYi1saW5rc1xcXCI+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPG1kLWluay1iYXI+PC9tZC1pbmstYmFyPiA8L2Rpdj4gXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXRhYi1uYXYtYmFye292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTtmbGV4LXNocmluazowfS5tYXQtdGFiLWxpbmtze3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtdGFiLWxpbmt7bGluZS1oZWlnaHQ6NDhweDtoZWlnaHQ6NDhweDtwYWRkaW5nOjAgMTJweDtmb250LXNpemU6MTRweDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjUwMDtjdXJzb3I6cG9pbnRlcjtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3BhY2l0eTouNjttaW4td2lkdGg6MTYwcHg7dGV4dC1hbGlnbjpjZW50ZXI7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO3RleHQtZGVjb3JhdGlvbjpub25lO3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbn0ubWF0LXRhYi1saW5rOmZvY3Vze291dGxpbmU6MDtvcGFjaXR5OjF9QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpey5tYXQtdGFiLWxpbmt7bWluLXdpZHRoOjcycHh9fS5tYXQtaW5rLWJhcntwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtoZWlnaHQ6MnB4O3RyYW5zaXRpb246LjVzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9Lm1hdC10YWItZ3JvdXAtaW52ZXJ0ZWQtaGVhZGVyIC5tYXQtaW5rLWJhcntib3R0b206YXV0bzt0b3A6MH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9dGFiLW5hdi1iYXIuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LXRhYi1uYXYtYmFyJyB9LFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVGFiTmF2QmFyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRGlyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbl07IH07XG5NZFRhYk5hdkJhci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX2lua0Jhcic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW01kSW5rQmFyLF0gfSxdLFxufTtcbi8qKlxuICogTGluayBpbnNpZGUgb2YgYSBgbWQtdGFiLW5hdi1iYXJgLlxuICovXG52YXIgTWRUYWJMaW5rID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfbWRUYWJOYXZCYXJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRUYWJMaW5rKF9tZFRhYk5hdkJhciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fbWRUYWJOYXZCYXIgPSBfbWRUYWJOYXZCYXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiTGluay5wcm90b3R5cGUsIFwiYWN0aXZlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGxpbmsgaXMgYWN0aXZlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pc0FjdGl2ZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWRUYWJOYXZCYXIudXBkYXRlQWN0aXZlTGluayh0aGlzLl9lbGVtZW50UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE1kVGFiTGluaztcbn0oKSk7XG5NZFRhYkxpbmsuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC10YWItbGlua10sIFttYXQtdGFiLWxpbmtdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtdGFiLWxpbmsnIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUYWJMaW5rLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTWRUYWJOYXZCYXIsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuXTsgfTtcbk1kVGFiTGluay5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnYWN0aXZlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbi8qKlxuICogU2ltcGxlIGRpcmVjdGl2ZSB0aGF0IGV4dGVuZHMgdGhlIHJpcHBsZSBhbmQgbWF0Y2hlcyB0aGUgc2VsZWN0b3Igb2YgdGhlIE1kVGFiTGluay4gVGhpc1xuICogYWRkcyB0aGUgcmlwcGxlIGJlaGF2aW9yIHRvIG5hdiBiYXIgbGFiZWxzLlxuICovXG52YXIgTWRUYWJMaW5rUmlwcGxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFRhYkxpbmtSaXBwbGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBuZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IHJ1bGVyXG4gICAgICogQHBhcmFtIHs/fSBwbGF0Zm9ybVxuICAgICAqIEBwYXJhbSB7P30gZ2xvYmFsT3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kVGFiTGlua1JpcHBsZShlbGVtZW50UmVmLCBuZ1pvbmUsIHJ1bGVyLCBwbGF0Zm9ybSwgZ2xvYmFsT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudFJlZiwgbmdab25lLCBydWxlciwgcGxhdGZvcm0sIGdsb2JhbE9wdGlvbnMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZFRhYkxpbmtSaXBwbGU7XG59KE1kUmlwcGxlKSk7XG5NZFRhYkxpbmtSaXBwbGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC10YWItbGlua10sIFttYXQtdGFiLWxpbmtdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtdGFiLWxpbmsnIH0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVGFiTGlua1JpcHBsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgeyB0eXBlOiBWaWV3cG9ydFJ1bGVyLCB9LFxuICAgIHsgdHlwZTogUGxhdGZvcm0sIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTURfUklQUExFX0dMT0JBTF9PUFRJT05TLF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBXcmFwcGVyIGZvciB0aGUgY29udGVudHMgb2YgYSB0YWIuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kVGFiQm9keSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2RpclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFRhYkJvZHkoX2RpciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB0YWIgYmVnaW5zIHRvIGFuaW1hdGUgdG93YXJkcyB0aGUgY2VudGVyIGFzIHRoZSBhY3RpdmUgdGFiLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNlbnRlcmluZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdGFiIGNvbXBsZXRlcyBpdHMgYW5pbWF0aW9uIHRvd2FyZHMgdGhlIGNlbnRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25DZW50ZXJlZCA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkJvZHkucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcG9zaXRpb25cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9nZXRMYXlvdXREaXJlY3Rpb24oKSA9PSAnbHRyJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gJ2NlbnRlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkJvZHkucHJvdG90eXBlLCBcIm9yaWdpblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3JpZ2luIHBvc2l0aW9uIGZyb20gd2hpY2ggdGhpcyB0YWIgc2hvdWxkIGFwcGVhciB3aGVuIGl0IGlzIGNlbnRlcmVkIGludG8gdmlldy5cbiAgICAgICAgICogQHBhcmFtIHs/fSBvcmlnaW5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICAgICAgaWYgKG9yaWdpbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyID0gdGhpcy5fZ2V0TGF5b3V0RGlyZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoKGRpciA9PSAnbHRyJyAmJiBvcmlnaW4gPD0gMCkgfHwgKGRpciA9PSAncnRsJyAmJiBvcmlnaW4gPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbiA9ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbiA9ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFmdGVyIGluaXRpYWxpemVkLCBjaGVjayBpZiB0aGUgY29udGVudCBpcyBjZW50ZXJlZCBhbmQgaGFzIGFuIG9yaWdpbi4gSWYgc28sIHNldCB0aGVcbiAgICAgKiBzcGVjaWFsIHBvc2l0aW9uIHN0YXRlcyB0aGF0IHRyYW5zaXRpb24gdGhlIHRhYiBmcm9tIHRoZSBsZWZ0IG9yIHJpZ2h0IGJlZm9yZSBjZW50ZXJpbmcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkJvZHkucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcG9zaXRpb24gPT0gJ2NlbnRlcicgJiYgdGhpcy5fb3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX29yaWdpbiA9PSAnbGVmdCcgPyAnbGVmdC1vcmlnaW4tY2VudGVyJyA6ICdyaWdodC1vcmlnaW4tY2VudGVyJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgdGhlIHZpZXcgaGFzIGJlZW4gc2V0LCBjaGVjayBpZiB0aGUgdGFiIGNvbnRlbnQgaXMgc2V0IHRvIHRoZSBjZW50ZXIgYW5kIGF0dGFjaCB0aGVcbiAgICAgKiBjb250ZW50IGlmIGl0IGlzIG5vdCBhbHJlYWR5IGF0dGFjaGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJCb2R5LnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NlbnRlclBvc2l0aW9uKHRoaXMuX3Bvc2l0aW9uKSAmJiAhdGhpcy5fcG9ydGFsSG9zdC5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWxIb3N0LmF0dGFjaCh0aGlzLl9jb250ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkJvZHkucHJvdG90eXBlLl9vblRyYW5zbGF0ZVRhYlN0YXJ0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5faXNDZW50ZXJQb3NpdGlvbihlLnRvU3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2VudGVyaW5nLmVtaXQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJCb2R5LnByb3RvdHlwZS5fb25UcmFuc2xhdGVUYWJDb21wbGV0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIElmIHRoZSBlbmQgc3RhdGUgaXMgdGhhdCB0aGUgdGFiIGlzIG5vdCBjZW50ZXJlZCwgdGhlbiBkZXRhY2ggdGhlIGNvbnRlbnQuXG4gICAgICAgIGlmICghdGhpcy5faXNDZW50ZXJQb3NpdGlvbihlLnRvU3RhdGUpICYmICF0aGlzLl9pc0NlbnRlclBvc2l0aW9uKHRoaXMuX3Bvc2l0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5fcG9ydGFsSG9zdC5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdHJhbnNpdGlvbiB0byB0aGUgY2VudGVyIGlzIGNvbXBsZXRlLCBlbWl0IGFuIGV2ZW50LlxuICAgICAgICBpZiAodGhpcy5faXNDZW50ZXJQb3NpdGlvbihlLnRvU3RhdGUpICYmIHRoaXMuX2lzQ2VudGVyUG9zaXRpb24odGhpcy5fcG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2VudGVyZWQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGNvbnRhaW5pbmcgYXBwLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJCb2R5LnByb3RvdHlwZS5fZ2V0TGF5b3V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcHJvdmlkZWQgcG9zaXRpb24gc3RhdGUgaXMgY29uc2lkZXJlZCBjZW50ZXIsIHJlZ2FyZGxlc3Mgb2Ygb3JpZ2luLlxuICAgICAqIEBwYXJhbSB7P30gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiQm9keS5wcm90b3R5cGUuX2lzQ2VudGVyUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uID09ICdjZW50ZXInIHx8XG4gICAgICAgICAgICBwb3NpdGlvbiA9PSAnbGVmdC1vcmlnaW4tY2VudGVyJyB8fFxuICAgICAgICAgICAgcG9zaXRpb24gPT0gJ3JpZ2h0LW9yaWdpbi1jZW50ZXInO1xuICAgIH07XG4gICAgcmV0dXJuIE1kVGFiQm9keTtcbn0oKSk7XG5NZFRhYkJvZHkuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC10YWItYm9keSwgbWF0LXRhYi1ib2R5JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWJvZHktY29udGVudFxcXCIgI2NvbnRlbnQgW0B0cmFuc2xhdGVUYWJdPVxcXCJfcG9zaXRpb25cXFwiIChAdHJhbnNsYXRlVGFiLnN0YXJ0KT1cXFwiX29uVHJhbnNsYXRlVGFiU3RhcnRlZCgkZXZlbnQpXFxcIiAoQHRyYW5zbGF0ZVRhYi5kb25lKT1cXFwiX29uVHJhbnNsYXRlVGFiQ29tcGxldGUoJGV2ZW50KVxcXCI+IDxuZy10ZW1wbGF0ZSBjZGtQb3J0YWxIb3N0PjwvbmctdGVtcGxhdGU+IDwvZGl2PiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtdGFiLWJvZHktY29udGVudHtoZWlnaHQ6MTAwJTtvdmVyZmxvdzphdXRvfS5tYXQtdGFiLWdyb3VwLWR5bmFtaWMtaGVpZ2h0IC5tYXQtdGFiLWJvZHktY29udGVudHtvdmVyZmxvdzpoaWRkZW59IC8qIyBzb3VyY2VNYXBwaW5nVVJMPXRhYi1ib2R5LmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItYm9keV0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ3RyYW5zbGF0ZVRhYicsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCd2b2lkJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2xlZnQnLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2xlZnQtb3JpZ2luLWNlbnRlcicsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdyaWdodC1vcmlnaW4tY2VudGVyJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2NlbnRlcicsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdyaWdodCcsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJyogPT4gbGVmdCwgKiA9PiByaWdodCwgbGVmdCA9PiBjZW50ZXIsIHJpZ2h0ID0+IGNlbnRlcicsIGFuaW1hdGUoJzUwMG1zIGN1YmljLWJlemllcigwLjM1LCAwLCAwLjI1LCAxKScpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gbGVmdC1vcmlnaW4tY2VudGVyJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKCc1MDBtcyBjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSknKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IHJpZ2h0LW9yaWdpbi1jZW50ZXInLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnNTAwbXMgY3ViaWMtYmV6aWVyKDAuMzUsIDAsIDAuMjUsIDEpJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFRhYkJvZHkuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBEaXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbl07IH07XG5NZFRhYkJvZHkucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ19wb3J0YWxIb3N0JzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbUG9ydGFsSG9zdERpcmVjdGl2ZSxdIH0sXSxcbiAgICAnb25DZW50ZXJpbmcnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdvbkNlbnRlcmVkJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnX2NvbnRlbnQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydjb250ZW50JyxdIH0sXSxcbiAgICAncG9zaXRpb24nOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydwb3NpdGlvbicsXSB9LF0sXG4gICAgJ29yaWdpbic6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ29yaWdpbicsXSB9LF0sXG59O1xuLyoqXG4gKiBUaGUgZGlzdGFuY2UgaW4gcGl4ZWxzIHRoYXQgd2lsbCBiZSBvdmVyc2hvdCB3aGVuIHNjcm9sbGluZyBhIHRhYiBsYWJlbCBpbnRvIHZpZXcuIFRoaXMgaGVscHNcbiAqIHByb3ZpZGUgYSBzbWFsbCBhZmZvcmRhbmNlIHRvIHRoZSBsYWJlbCBuZXh0IHRvIGl0LlxuICovXG52YXIgRVhBR0dFUkFURURfT1ZFUlNDUk9MTCA9IDYwO1xuLyoqXG4gKiBUaGUgaGVhZGVyIG9mIHRoZSB0YWIgZ3JvdXAgd2hpY2ggZGlzcGxheXMgYSBsaXN0IG9mIGFsbCB0aGUgdGFicyBpbiB0aGUgdGFiIGdyb3VwLiBJbmNsdWRlc1xuICogYW4gaW5rIGJhciB0aGF0IGZvbGxvd3MgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YWIuIFdoZW4gdGhlIHRhYnMgbGlzdCdzIHdpZHRoIGV4Y2VlZHMgdGhlXG4gKiB3aWR0aCBvZiB0aGUgaGVhZGVyIGNvbnRhaW5lciwgdGhlbiBhcnJvd3Mgd2lsbCBiZSBkaXNwbGF5ZWQgdG8gYWxsb3cgdGhlIHVzZXIgdG8gc2Nyb2xsXG4gKiBsZWZ0IGFuZCByaWdodCBhY3Jvc3MgdGhlIGhlYWRlci5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRUYWJIZWFkZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRUYWJIZWFkZXIoX2VsZW1lbnRSZWYsIF9uZ1pvbmUsIF9kaXIpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRhYiBpbmRleCB0aGF0IGlzIGZvY3VzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9mb2N1c0luZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgdGhhdCB0aGUgdGFiIGxhYmVscyBzaG91bGQgYmUgdHJhbnNsYXRlZCB0byB0aGUgbGVmdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Njcm9sbERpc3RhbmNlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGhlYWRlciBzaG91bGQgc2Nyb2xsIHRvIHRoZSBzZWxlY3RlZCBpbmRleCBhZnRlciB0aGUgdmlldyBoYXMgYmVlbiBjaGVja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbWJpbmVzIGxpc3RlbmVycyB0aGF0IHdpbGwgcmUtYWxpZ24gdGhlIGluayBiYXIgd2hlbmV2ZXIgdGhleSdyZSBpbnZva2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVhbGlnbklua0JhciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb250cm9scyBmb3IgcGFnaW5hdGlvbiBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zaG93UGFnaW5hdGlvbkNvbnRyb2xzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB0YWIgbGlzdCBjYW4gYmUgc2Nyb2xsZWQgbW9yZSB0b3dhcmRzIHRoZSBlbmQgb2YgdGhlIHRhYiBsYWJlbCBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZVNjcm9sbEFmdGVyID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRhYiBsaXN0IGNhbiBiZSBzY3JvbGxlZCBtb3JlIHRvd2FyZHMgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGFiIGxhYmVsIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsQmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RGb2N1c2VkSW5kZXggPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gYSBsYWJlbCBpcyBmb2N1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleEZvY3VzZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkhlYWRlci5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGFjdGl2ZSB0YWIuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSW5kZXg7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleENoYW5nZWQgPSB0aGlzLl9zZWxlY3RlZEluZGV4ICE9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNJbmRleCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcImRpc2FibGVSaXBwbGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciByaXBwbGVzIGZvciB0aGUgdGFiLWhlYWRlciBsYWJlbHMgc2hvdWxkIGJlIGRpc2FibGVkIG9yIG5vdC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIHRoZSBudW1iZXIgb2YgdGFiIGxhYmVscyBoYXZlIGNoYW5nZWQsIGNoZWNrIGlmIHNjcm9sbGluZyBzaG91bGQgYmUgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5fdGFiTGFiZWxDb3VudCAhPSB0aGlzLl9sYWJlbFdyYXBwZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fdGFiTGFiZWxDb3VudCA9IHRoaXMuX2xhYmVsV3JhcHBlcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3RlZCBpbmRleCBoYXMgY2hhbmdlZCwgc2Nyb2xsIHRvIHRoZSBsYWJlbCBhbmQgY2hlY2sgaWYgdGhlIHNjcm9sbGluZyBjb250cm9sc1xuICAgICAgICAvLyBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZEluZGV4Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9MYWJlbCh0aGlzLl9zZWxlY3RlZEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrU2Nyb2xsaW5nQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2FsaWduSW5rQmFyVG9TZWxlY3RlZFRhYigpO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc2Nyb2xsIGRpc3RhbmNlIGhhcyBiZWVuIGNoYW5nZWQgKHRhYiBzZWxlY3RlZCwgZm9jdXNlZCwgc2Nyb2xsIGNvbnRyb2xzIGFjdGl2YXRlZCksXG4gICAgICAgIC8vIHRoZW4gdHJhbnNsYXRlIHRoZSBoZWFkZXIgdG8gcmVmbGVjdCB0aGlzLlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsRGlzdGFuY2VDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUYWJTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRGlzdGFuY2VDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5faGFuZGxlS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNOZXh0VGFiKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNQcmV2aW91c1RhYigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFTlRFUjpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZvY3VzZWRJbmRleC5lbWl0KHRoaXMuZm9jdXNJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFsaWducyB0aGUgaW5rIGJhciB0byB0aGUgc2VsZWN0ZWQgdGFiIG9uIGxvYWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9yZWFsaWduSW5rQmFyID0gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpckNoYW5nZSA9IF90aGlzLl9kaXIgPyBfdGhpcy5fZGlyLmRpckNoYW5nZSA6IE9ic2VydmFibGUub2YobnVsbCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNpemUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICAgICAgT2JzZXJ2YWJsZS5mcm9tRXZlbnQod2luZG93LCAncmVzaXplJykuYXVkaXRUaW1lKDEwKSA6XG4gICAgICAgICAgICAgICAgT2JzZXJ2YWJsZS5vZihudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlLm1lcmdlKGRpckNoYW5nZSwgcmVzaXplKS5zdGFydFdpdGgobnVsbCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9hbGlnbklua0JhclRvU2VsZWN0ZWRUYWIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVhbGlnbklua0Jhcikge1xuICAgICAgICAgICAgdGhpcy5fcmVhbGlnbklua0Jhci51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVhbGlnbklua0JhciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZvciB3aGVuIHRoZSBNdXRhdGlvbk9ic2VydmVyIGRldGVjdHMgdGhhdCB0aGUgY29udGVudCBoYXMgY2hhbmdlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fb25Db250ZW50Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpO1xuICAgICAgICB0aGlzLl9hbGlnbklua0JhclRvU2VsZWN0ZWRUYWIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0aW5nIHRoZSB2aWV3IHdoZXRoZXIgcGFnaW5hdGlvbiBzaG91bGQgYmUgZW5hYmxlZCBvciBub3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fdXBkYXRlUGFnaW5hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQYWdpbmF0aW9uRW5hYmxlZCgpO1xuICAgICAgICB0aGlzLl9jaGVja1Njcm9sbGluZ0NvbnRyb2xzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRhYlNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcImZvY3VzSW5kZXhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIHdoaWNoIGVsZW1lbnQgaGFzIGZvY3VzOyB1c2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2ZvY3VzSW5kZXg7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSBmb2N1cyBpbmRleCBpcyBzZXQsIHdlIG11c3QgbWFudWFsbHkgc2VuZCBmb2N1cyB0byB0aGUgY29ycmVjdCBsYWJlbFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkSW5kZXgodmFsdWUpIHx8IHRoaXMuX2ZvY3VzSW5kZXggPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9mb2N1c0luZGV4ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmluZGV4Rm9jdXNlZC5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFRhYkZvY3VzKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhbiBpbmRleCBpcyB2YWxpZC4gIElmIHRoZSB0YWJzIGFyZSBub3QgcmVhZHkgeWV0LCB3ZSBhc3N1bWUgdGhhdCB0aGUgdXNlciBpc1xuICAgICAqIHByb3ZpZGluZyBhIHZhbGlkIGluZGV4IGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2lzVmFsaWRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xhYmVsV3JhcHBlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhYiA9IHRoaXMuX2xhYmVsV3JhcHBlcnMgPyB0aGlzLl9sYWJlbFdyYXBwZXJzLnRvQXJyYXkoKVtpbmRleF0gOiBudWxsO1xuICAgICAgICByZXR1cm4gdGFiICYmICF0YWIuZGlzYWJsZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGZvY3VzIG9uIHRoZSBIVE1MIGVsZW1lbnQgZm9yIHRoZSBsYWJlbCB3cmFwcGVyIGFuZCBzY3JvbGxzIGl0IGludG8gdGhlIHZpZXcgaWZcbiAgICAgKiBzY3JvbGxpbmcgaXMgZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0gez99IHRhYkluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX3NldFRhYkZvY3VzID0gZnVuY3Rpb24gKHRhYkluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl9zaG93UGFnaW5hdGlvbkNvbnRyb2xzKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb0xhYmVsKHRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGFiZWxXcmFwcGVycyAmJiB0aGlzLl9sYWJlbFdyYXBwZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KClbdGFiSW5kZXhdLmZvY3VzKCk7XG4gICAgICAgICAgICAvLyBEbyBub3QgbGV0IHRoZSBicm93c2VyIG1hbmFnZSBzY3JvbGxpbmcgdG8gZm9jdXMgdGhlIGVsZW1lbnQsIHRoaXMgd2lsbCBiZSBoYW5kbGVkXG4gICAgICAgICAgICAvLyBieSB1c2luZyB0cmFuc2xhdGlvbi4gSW4gTFRSLCB0aGUgc2Nyb2xsIGxlZnQgc2hvdWxkIGJlIDAuIEluIFJUTCwgdGhlIHNjcm9sbCB3aWR0aFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHRoZSBmdWxsIHdpZHRoIG1pbnVzIHRoZSBvZmZzZXQgd2lkdGguXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluZXJFbCA9IHRoaXMuX3RhYkxpc3RDb250YWluZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpciA9IHRoaXMuX2dldExheW91dERpcmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGRpciA9PSAnbHRyJykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsLnNjcm9sbExlZnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWwuc2Nyb2xsTGVmdCA9IGNvbnRhaW5lckVsLnNjcm9sbFdpZHRoIC0gY29udGFpbmVyRWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBmb2N1cyB0b3dhcmRzIHRoZSBiZWdpbm5pbmcgb3IgdGhlIGVuZCBvZiB0aGUgbGlzdCBkZXBlbmRpbmcgb24gdGhlIG9mZnNldCBwcm92aWRlZC5cbiAgICAgKiBWYWxpZCBvZmZzZXRzIGFyZSAxIGFuZCAtMS5cbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9tb3ZlRm9jdXMgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWJzID0gdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KCk7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSB0aGlzLmZvY3VzSW5kZXggKyBvZmZzZXQ7IGkgPCB0YWJzLmxlbmd0aCAmJiBpID49IDA7IGkgKz0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnQgdGhlIGZvY3VzIGluZGV4IGJ5IDEgdW50aWwgYSB2YWxpZCB0YWIgaXMgZm91bmQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2ZvY3VzTmV4dFRhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW92ZUZvY3VzKHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInID8gMSA6IC0xKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlY3JlbWVudCB0aGUgZm9jdXMgaW5kZXggYnkgMSB1bnRpbCBhIHZhbGlkIHRhYiBpcyBmb3VuZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fZm9jdXNQcmV2aW91c1RhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW92ZUZvY3VzKHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInID8gLTEgOiAxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBsYXlvdXQgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluaW5nIGFwcC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fZ2V0TGF5b3V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIENTUyB0cmFuc2Zvcm1hdGlvbiBvbiB0aGUgdGFiIGxpc3QgdGhhdCB3aWxsIGNhdXNlIHRoZSBsaXN0IHRvIHNjcm9sbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fdXBkYXRlVGFiU2Nyb2xsUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zbGF0ZVggPSB0aGlzLnNjcm9sbERpc3RhbmNlICsgJ3B4JztcbiAgICAgICAgaWYgKHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVYID0gJy0nICsgdHJhbnNsYXRlWDtcbiAgICAgICAgfVxuICAgICAgICBhcHBseUNzc1RyYW5zZm9ybSh0aGlzLl90YWJMaXN0Lm5hdGl2ZUVsZW1lbnQsIFwidHJhbnNsYXRlM2QoXCIgKyB0cmFuc2xhdGVYICsgXCIsIDAsIDApXCIpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJzY3JvbGxEaXN0YW5jZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zY3JvbGxEaXN0YW5jZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc3RhbmNlIGluIHBpeGVscyB0aGF0IHRoZSB0YWIgaGVhZGVyIHNob3VsZCBiZSB0cmFuc2Zvcm1lZCBpbiB0aGUgWC1heGlzLlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbERpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5fZ2V0TWF4U2Nyb2xsRGlzdGFuY2UoKSwgdikpO1xuICAgICAgICAgICAgLy8gTWFyayB0aGF0IHRoZSBzY3JvbGwgZGlzdGFuY2UgaGFzIGNoYW5nZWQgc28gdGhhdCBhZnRlciB0aGUgdmlldyBpcyBjaGVja2VkLCB0aGUgQ1NTXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm1hdGlvbiBjYW4gbW92ZSB0aGUgaGVhZGVyLlxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRGlzdGFuY2VDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrU2Nyb2xsaW5nQ29udHJvbHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHRhYiBsaXN0IGluIHRoZSAnYmVmb3JlJyBvciAnYWZ0ZXInIGRpcmVjdGlvbiAodG93YXJkcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0IG9yXG4gICAgICogdGhlIGVuZCBvZiB0aGUgbGlzdCwgcmVzcGVjdGl2ZWx5KS4gVGhlIGRpc3RhbmNlIHRvIHNjcm9sbCBpcyBjb21wdXRlZCB0byBiZSBhIHRoaXJkIG9mIHRoZVxuICAgICAqIGxlbmd0aCBvZiB0aGUgdGFiIGxpc3QgdmlldyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBjYWxsIHRoYXQgZm9yY2VzIGEgbGF5b3V0IHJlZmxvdyB0byBjb21wdXRlIGJveCBhbmQgc2Nyb2xsIG1ldHJpY3MgYW5kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBzcGFyaW5nbHkuXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxEaXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fc2Nyb2xsSGVhZGVyID0gZnVuY3Rpb24gKHNjcm9sbERpcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3TGVuZ3RoID0gdGhpcy5fdGFiTGlzdENvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAvLyBNb3ZlIHRoZSBzY3JvbGwgZGlzdGFuY2Ugb25lLXRoaXJkIHRoZSBsZW5ndGggb2YgdGhlIHRhYiBsaXN0J3Mgdmlld3BvcnQuXG4gICAgICAgIHRoaXMuc2Nyb2xsRGlzdGFuY2UgKz0gKHNjcm9sbERpciA9PSAnYmVmb3JlJyA/IC0xIDogMSkgKiB2aWV3TGVuZ3RoIC8gMztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSB0YWIgbGlzdCBzdWNoIHRoYXQgdGhlIGRlc2lyZWQgdGFiIGxhYmVsIChtYXJrZWQgYnkgaW5kZXgpIGlzIG1vdmVkIGludG8gdmlldy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gZXhwZW5zaXZlIGNhbGwgdGhhdCBmb3JjZXMgYSBsYXlvdXQgcmVmbG93IHRvIGNvbXB1dGUgYm94IGFuZCBzY3JvbGwgbWV0cmljcyBhbmRcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIHNwYXJpbmdseS5cbiAgICAgKiBAcGFyYW0gez99IGxhYmVsSW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fc2Nyb2xsVG9MYWJlbCA9IGZ1bmN0aW9uIChsYWJlbEluZGV4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdGVkTGFiZWwgPSB0aGlzLl9sYWJlbFdyYXBwZXJzXG4gICAgICAgICAgICA/IHRoaXMuX2xhYmVsV3JhcHBlcnMudG9BcnJheSgpW2xhYmVsSW5kZXhdXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICghc2VsZWN0ZWRMYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSB2aWV3IGxlbmd0aCBpcyB0aGUgdmlzaWJsZSB3aWR0aCBvZiB0aGUgdGFiIGxhYmVscy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0xlbmd0aCA9IHRoaXMuX3RhYkxpc3RDb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFiZWxCZWZvcmVQb3MsIC8qKiBAdHlwZSB7P30gKi8gbGFiZWxBZnRlclBvcztcbiAgICAgICAgaWYgKHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInKSB7XG4gICAgICAgICAgICBsYWJlbEJlZm9yZVBvcyA9IHNlbGVjdGVkTGFiZWwuZ2V0T2Zmc2V0TGVmdCgpO1xuICAgICAgICAgICAgbGFiZWxBZnRlclBvcyA9IGxhYmVsQmVmb3JlUG9zICsgc2VsZWN0ZWRMYWJlbC5nZXRPZmZzZXRXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWxBZnRlclBvcyA9IHRoaXMuX3RhYkxpc3QubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAtIHNlbGVjdGVkTGFiZWwuZ2V0T2Zmc2V0TGVmdCgpO1xuICAgICAgICAgICAgbGFiZWxCZWZvcmVQb3MgPSBsYWJlbEFmdGVyUG9zIC0gc2VsZWN0ZWRMYWJlbC5nZXRPZmZzZXRXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJlZm9yZVZpc2libGVQb3MgPSB0aGlzLnNjcm9sbERpc3RhbmNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhZnRlclZpc2libGVQb3MgPSB0aGlzLnNjcm9sbERpc3RhbmNlICsgdmlld0xlbmd0aDtcbiAgICAgICAgaWYgKGxhYmVsQmVmb3JlUG9zIDwgYmVmb3JlVmlzaWJsZVBvcykge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIGhlYWRlciB0byBtb3ZlIGxhYmVsIHRvIHRoZSBiZWZvcmUgZGlyZWN0aW9uXG4gICAgICAgICAgICB0aGlzLnNjcm9sbERpc3RhbmNlIC09IGJlZm9yZVZpc2libGVQb3MgLSBsYWJlbEJlZm9yZVBvcyArIEVYQUdHRVJBVEVEX09WRVJTQ1JPTEw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFiZWxBZnRlclBvcyA+IGFmdGVyVmlzaWJsZVBvcykge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIGhlYWRlciB0byBtb3ZlIGxhYmVsIHRvIHRoZSBhZnRlciBkaXJlY3Rpb25cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlzdGFuY2UgKz0gbGFiZWxBZnRlclBvcyAtIGFmdGVyVmlzaWJsZVBvcyArIEVYQUdHRVJBVEVEX09WRVJTQ1JPTEw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHdoZXRoZXIgdGhlIHBhZ2luYXRpb24gY29udHJvbHMgc2hvdWxkIGJlIGRpc3BsYXllZC4gSWYgdGhlIHNjcm9sbCB3aWR0aCBvZiB0aGVcbiAgICAgKiB0YWIgbGlzdCBpcyB3aWRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBoZWFkZXIgY29udGFpbmVyLCB0aGVuIHRoZSBwYWdpbmF0aW9uIGNvbnRyb2xzIHNob3VsZFxuICAgICAqIGJlIHNob3duLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBleHBlbnNpdmUgY2FsbCB0aGF0IGZvcmNlcyBhIGxheW91dCByZWZsb3cgdG8gY29tcHV0ZSBib3ggYW5kIHNjcm9sbCBtZXRyaWNzIGFuZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgc3BhcmluZ2x5LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9jaGVja1BhZ2luYXRpb25FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zaG93UGFnaW5hdGlvbkNvbnRyb2xzID1cbiAgICAgICAgICAgIHRoaXMuX3RhYkxpc3QubmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aCA+IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93UGFnaW5hdGlvbkNvbnRyb2xzKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERpc3RhbmNlID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgd2hldGhlciB0aGUgYmVmb3JlIGFuZCBhZnRlciBjb250cm9scyBzaG91bGQgYmUgZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAgICAgKiBJZiB0aGUgaGVhZGVyIGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QgKHNjcm9sbCBkaXN0YW5jZSBpcyBlcXVhbCB0byAwKSB0aGVuIGRpc2FibGUgdGhlXG4gICAgICogYmVmb3JlIGJ1dHRvbi4gSWYgdGhlIGhlYWRlciBpcyBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IChzY3JvbGwgZGlzdGFuY2UgaXMgZXF1YWwgdG8gdGhlXG4gICAgICogbWF4aW11bSBkaXN0YW5jZSB3ZSBjYW4gc2Nyb2xsKSwgdGhlbiBkaXNhYmxlIHRoZSBhZnRlciBidXR0b24uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBjYWxsIHRoYXQgZm9yY2VzIGEgbGF5b3V0IHJlZmxvdyB0byBjb21wdXRlIGJveCBhbmQgc2Nyb2xsIG1ldHJpY3MgYW5kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBzcGFyaW5nbHkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2NoZWNrU2Nyb2xsaW5nQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwYWdpbmF0aW9uIGFycm93cyBzaG91bGQgYmUgYWN0aXZhdGVkLlxuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsQmVmb3JlID0gdGhpcy5zY3JvbGxEaXN0YW5jZSA9PSAwO1xuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsQWZ0ZXIgPSB0aGlzLnNjcm9sbERpc3RhbmNlID09IHRoaXMuX2dldE1heFNjcm9sbERpc3RhbmNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoYXQgaXMgdGhlIG1heGltdW0gbGVuZ3RoIGluIHBpeGVscyB0aGF0IGNhbiBiZSBzZXQgZm9yIHRoZSBzY3JvbGwgZGlzdGFuY2UuIFRoaXNcbiAgICAgKiBpcyBlcXVhbCB0byB0aGUgZGlmZmVyZW5jZSBpbiB3aWR0aCBiZXR3ZWVuIHRoZSB0YWIgbGlzdCBjb250YWluZXIgYW5kIHRhYiBoZWFkZXIgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBleHBlbnNpdmUgY2FsbCB0aGF0IGZvcmNlcyBhIGxheW91dCByZWZsb3cgdG8gY29tcHV0ZSBib3ggYW5kIHNjcm9sbCBtZXRyaWNzIGFuZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgc3BhcmluZ2x5LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9nZXRNYXhTY3JvbGxEaXN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuZ3RoT2ZUYWJMaXN0ID0gdGhpcy5fdGFiTGlzdC5uYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3TGVuZ3RoID0gdGhpcy5fdGFiTGlzdENvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoT2ZUYWJMaXN0IC0gdmlld0xlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSBpbmstYmFyIHRvIGFsaWduIGl0c2VsZiB0byB0aGUgY3VycmVudCBsYWJlbCB3cmFwcGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2FsaWduSW5rQmFyVG9TZWxlY3RlZFRhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0ZWRMYWJlbFdyYXBwZXIgPSB0aGlzLl9sYWJlbFdyYXBwZXJzICYmIHRoaXMuX2xhYmVsV3JhcHBlcnMubGVuZ3RoXG4gICAgICAgICAgICA/IHRoaXMuX2xhYmVsV3JhcHBlcnMudG9BcnJheSgpW3RoaXMuc2VsZWN0ZWRJbmRleF0uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50XG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHRoaXMuX2lua0Jhci5hbGlnblRvRWxlbWVudChzZWxlY3RlZExhYmVsV3JhcHBlcik7XG4gICAgfTtcbiAgICByZXR1cm4gTWRUYWJIZWFkZXI7XG59KCkpO1xuTWRUYWJIZWFkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC10YWItaGVhZGVyLCBtYXQtdGFiLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbiBtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWJlZm9yZSBtYXQtZWxldmF0aW9uLXo0XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgbWQtcmlwcGxlIFttZFJpcHBsZURpc2FibGVkXT1cXFwiX2Rpc2FibGVTY3JvbGxCZWZvcmUgfHwgZGlzYWJsZVJpcHBsZVxcXCIgW2NsYXNzLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tZGlzYWJsZWRdPVxcXCJfZGlzYWJsZVNjcm9sbEJlZm9yZVxcXCIgKGNsaWNrKT1cXFwiX3Njcm9sbEhlYWRlcignYmVmb3JlJylcXFwiPiA8ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb25cXFwiPjwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWF0LXRhYi1sYWJlbC1jb250YWluZXJcXFwiICN0YWJMaXN0Q29udGFpbmVyIChrZXlkb3duKT1cXFwiX2hhbmRsZUtleWRvd24oJGV2ZW50KVxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGlzdFxcXCIgI3RhYkxpc3Qgcm9sZT1cXFwidGFibGlzdFxcXCIgKGNka09ic2VydmVDb250ZW50KT1cXFwiX29uQ29udGVudENoYW5nZXMoKVxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGFiZWxzXFxcIj4gPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiA8L2Rpdj4gPG1kLWluay1iYXI+PC9tZC1pbmstYmFyPiA8L2Rpdj4gPC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24gbWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1hZnRlciBtYXQtZWxldmF0aW9uLXo0XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgbWQtcmlwcGxlIFttZFJpcHBsZURpc2FibGVkXT1cXFwiX2Rpc2FibGVTY3JvbGxBZnRlciB8fCBkaXNhYmxlUmlwcGxlXFxcIiBbY2xhc3MubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1kaXNhYmxlZF09XFxcIl9kaXNhYmxlU2Nyb2xsQWZ0ZXJcXFwiIChjbGljayk9XFxcIl9zY3JvbGxIZWFkZXIoJ2FmdGVyJylcXFwiPiA8ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb25cXFwiPjwvZGl2PiA8L2Rpdj4gXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXRhYi1oZWFkZXJ7ZGlzcGxheTpmbGV4O292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTtmbGV4LXNocmluazowfS5tYXQtdGFiLWxhYmVse2xpbmUtaGVpZ2h0OjQ4cHg7aGVpZ2h0OjQ4cHg7cGFkZGluZzowIDEycHg7Zm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXdlaWdodDo1MDA7Y3Vyc29yOnBvaW50ZXI7Ym94LXNpemluZzpib3JkZXItYm94O29wYWNpdHk6LjY7bWluLXdpZHRoOjE2MHB4O3RleHQtYWxpZ246Y2VudGVyO3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtdGFiLWxhYmVsOmZvY3Vze291dGxpbmU6MDtvcGFjaXR5OjF9QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpey5tYXQtdGFiLWxhYmVse21pbi13aWR0aDo3MnB4fX0ubWF0LWluay1iYXJ7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjA7aGVpZ2h0OjJweDt0cmFuc2l0aW9uOi41cyBjdWJpYy1iZXppZXIoLjM1LDAsLjI1LDEpfS5tYXQtdGFiLWdyb3VwLWludmVydGVkLWhlYWRlciAubWF0LWluay1iYXJ7Ym90dG9tOmF1dG87dG9wOjB9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb257cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpub25lO2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO21pbi13aWR0aDozMnB4O2N1cnNvcjpwb2ludGVyO3otaW5kZXg6Mn0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jb250cm9scy1lbmFibGVkIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9ue2Rpc3BsYXk6ZmxleH0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1iZWZvcmUsLm1hdC10YWItaGVhZGVyLXJ0bCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1hZnRlcntwYWRkaW5nLWxlZnQ6NHB4fS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWJlZm9yZSAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9uLC5tYXQtdGFiLWhlYWRlci1ydGwgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYWZ0ZXIgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbnt0cmFuc2Zvcm06cm90YXRlKC0xMzVkZWcpfS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWFmdGVyLC5tYXQtdGFiLWhlYWRlci1ydGwgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYmVmb3Jle3BhZGRpbmctcmlnaHQ6NHB4fS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWFmdGVyIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb24sLm1hdC10YWItaGVhZGVyLXJ0bCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1iZWZvcmUgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbnt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9ue2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItd2lkdGg6MnB4IDJweCAwIDA7Y29udGVudDonJztoZWlnaHQ6OHB4O3dpZHRoOjhweH0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1kaXNhYmxlZHtib3gtc2hhZG93Om5vbmU7Y3Vyc29yOmRlZmF1bHR9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tZGlzYWJsZWQgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbntib3JkZXItY29sb3I6I2NjY30ubWF0LXRhYi1sYWJlbC1jb250YWluZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtZ3JvdzoxO292ZXJmbG93OmhpZGRlbjt6LWluZGV4OjF9Lm1hdC10YWItbGlzdHtmbGV4LWdyb3c6MTtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNXMgY3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKX0ubWF0LXRhYi1sYWJlbHN7ZGlzcGxheTpmbGV4fSAvKiMgc291cmNlTWFwcGluZ1VSTD10YWItaGVhZGVyLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LXRhYi1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY29udHJvbHMtZW5hYmxlZF0nOiAnX3Nob3dQYWdpbmF0aW9uQ29udHJvbHMnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItaGVhZGVyLXJ0bF0nOiBcIl9nZXRMYXlvdXREaXJlY3Rpb24oKSA9PSAncnRsJ1wiLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUYWJIZWFkZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogRGlyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbl07IH07XG5NZFRhYkhlYWRlci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX2xhYmVsV3JhcHBlcnMnOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtNZFRhYkxhYmVsV3JhcHBlcixdIH0sXSxcbiAgICAnX2lua0Jhcic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW01kSW5rQmFyLF0gfSxdLFxuICAgICdfdGFiTGlzdENvbnRhaW5lcic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWyd0YWJMaXN0Q29udGFpbmVyJyxdIH0sXSxcbiAgICAnX3RhYkxpc3QnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsndGFiTGlzdCcsXSB9LF0sXG4gICAgJ3NlbGVjdGVkSW5kZXgnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2Rpc2FibGVSaXBwbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdEZvY3VzZWRJbmRleCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2luZGV4Rm9jdXNlZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xudmFyIE1kVGFic01vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFic01vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kVGFic01vZHVsZTtcbn0oKSk7XG5NZFRhYnNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBQb3J0YWxNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kUmlwcGxlTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBPYnNlcnZlQ29udGVudE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgU2Nyb2xsRGlzcGF0Y2hNb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBleHBvcnQgYWxsIGNvbXBvbmVudHMgYmVjYXVzZSBzb21lIGFyZSBvbmx5IHRvIGJlIHVzZWQgaW50ZXJuYWxseS5cbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiTGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiLFxuICAgICAgICAgICAgICAgICAgICBNZFRhYk5hdkJhcixcbiAgICAgICAgICAgICAgICAgICAgTWRUYWJMaW5rLFxuICAgICAgICAgICAgICAgICAgICBNZFRhYkxpbmtSaXBwbGVcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBNZFRhYkdyb3VwLFxuICAgICAgICAgICAgICAgICAgICBNZFRhYkxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBNZFRhYixcbiAgICAgICAgICAgICAgICAgICAgTWRJbmtCYXIsXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiTGFiZWxXcmFwcGVyLFxuICAgICAgICAgICAgICAgICAgICBNZFRhYk5hdkJhcixcbiAgICAgICAgICAgICAgICAgICAgTWRUYWJMaW5rLFxuICAgICAgICAgICAgICAgICAgICBNZFRhYkJvZHksXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiTGlua1JpcHBsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRUYWJIZWFkZXJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1ZJRVdQT1JUX1JVTEVSX1BST1ZJREVSXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUYWJzTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWRUb29sYmFyUm93ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sYmFyUm93KCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRUb29sYmFyUm93O1xufSgpKTtcbk1kVG9vbGJhclJvdy5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtdG9vbGJhci1yb3csIG1hdC10b29sYmFyLXJvdycsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10b29sYmFyLXJvd10nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUb29sYmFyUm93LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWRUb29sYmFyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRUb29sYmFyKF9lbGVtZW50UmVmLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbGJhci5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIG9mIHRoZSB0b29sYmFyLiBDYW4gYmUgcHJpbWFyeSwgYWNjZW50LCBvciB3YXJuLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5ld0NvbG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRvb2xiYXIucHJvdG90eXBlLl91cGRhdGVDb2xvciA9IGZ1bmN0aW9uIChuZXdDb2xvcikge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IodGhpcy5fY29sb3IsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKG5ld0NvbG9yLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29sb3JcbiAgICAgKiBAcGFyYW0gez99IGlzQWRkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRvb2xiYXIucHJvdG90eXBlLl9zZXRFbGVtZW50Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIGlzQWRkKSB7XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIGNvbG9yICE9ICcnKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGlzQWRkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgXCJtYXQtXCIgKyBjb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtZW50LCBcIm1hdC1cIiArIGNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kVG9vbGJhcjtcbn0oKSk7XG5NZFRvb2xiYXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC10b29sYmFyLCBtYXQtdG9vbGJhcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXRvb2xiYXItbGF5b3V0XFxcIj4gPG1kLXRvb2xiYXItcm93PiA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IDwvbWQtdG9vbGJhci1yb3c+IDxuZy1jb250ZW50IHNlbGVjdD1cXFwibWQtdG9vbGJhci1yb3csIG1hdC10b29sYmFyLXJvd1xcXCI+PC9uZy1jb250ZW50PiA8L2Rpdj4gXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXRvb2xiYXJ7ZGlzcGxheTpmbGV4O2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDoxMDAlO2ZvbnQtc2l6ZToyMHB4O2ZvbnQtd2VpZ2h0OjUwMDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmO3BhZGRpbmc6MCAxNnB4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0ubWF0LXRvb2xiYXIgLm1hdC10b29sYmFyLXJvd3tkaXNwbGF5OmZsZXg7Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOjEwMCU7ZmxleC1kaXJlY3Rpb246cm93O2FsaWduLWl0ZW1zOmNlbnRlcjt3aGl0ZS1zcGFjZTpub3dyYXB9Lm1hdC10b29sYmFye21pbi1oZWlnaHQ6NjRweH0ubWF0LXRvb2xiYXItcm93e2hlaWdodDo2NHB4fUBtZWRpYSAobWF4LXdpZHRoOjYwMHB4KXsubWF0LXRvb2xiYXJ7bWluLWhlaWdodDo1NnB4fS5tYXQtdG9vbGJhci1yb3d7aGVpZ2h0OjU2cHh9fSAvKiMgc291cmNlTWFwcGluZ1VSTD10b29sYmFyLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdG9vbGJhcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3Rvb2xiYXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVG9vbGJhci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG5dOyB9O1xuTWRUb29sYmFyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG52YXIgTWRUb29sYmFyTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sYmFyTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRUb29sYmFyTW9kdWxlO1xufSgpKTtcbk1kVG9vbGJhck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW01kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRUb29sYmFyLCBNZFRvb2xiYXJSb3csIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFRvb2xiYXIsIE1kVG9vbGJhclJvd10sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVG9vbGJhck1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBUaW1lIGluIG1zIHRvIGRlbGF5IGJlZm9yZSBjaGFuZ2luZyB0aGUgdG9vbHRpcCB2aXNpYmlsaXR5IHRvIGhpZGRlblxuICovXG52YXIgVE9VQ0hFTkRfSElERV9ERUxBWSA9IDE1MDA7XG4vKipcbiAqIFRpbWUgaW4gbXMgdG8gdGhyb3R0bGUgcmVwb3NpdGlvbmluZyBhZnRlciBzY3JvbGwgZXZlbnRzLlxuICovXG52YXIgU0NST0xMX1RIUk9UVExFX01TID0gMjA7XG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdXNlciBzdXBwbGllZCBhbiBpbnZhbGlkIHRvb2x0aXAgcG9zaXRpb24uXG4gKiBAcGFyYW0gez99IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0aHJvd01kVG9vbHRpcEludmFsaWRQb3NpdGlvbkVycm9yKHBvc2l0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbHRpcCBwb3NpdGlvbiBcXFwiXCIgKyBwb3NpdGlvbiArIFwiXFxcIiBpcyBpbnZhbGlkLlwiKTtcbn1cbi8qKlxuICogRGlyZWN0aXZlIHRoYXQgYXR0YWNoZXMgYSBtYXRlcmlhbCBkZXNpZ24gdG9vbHRpcCB0byB0aGUgaG9zdCBlbGVtZW50LiBBbmltYXRlcyB0aGUgc2hvd2luZyBhbmRcbiAqIGhpZGluZyBvZiBhIHRvb2x0aXAgcHJvdmlkZWQgcG9zaXRpb24gKGRlZmF1bHRzIHRvIGJlbG93IHRoZSBlbGVtZW50KS5cbiAqXG4gKiBodHRwczovL21hdGVyaWFsLmdvb2dsZS5jb20vY29tcG9uZW50cy90b29sdGlwcy5odG1sXG4gKi9cbnZhciBNZFRvb2x0aXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9vdmVybGF5XG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX3Njcm9sbERpc3BhdGNoZXJcbiAgICAgKiBAcGFyYW0gez99IF92aWV3Q29udGFpbmVyUmVmXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9wbGF0Zm9ybVxuICAgICAqIEBwYXJhbSB7P30gX2RpclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kVG9vbHRpcChfb3ZlcmxheSwgX2VsZW1lbnRSZWYsIF9zY3JvbGxEaXNwYXRjaGVyLCBfdmlld0NvbnRhaW5lclJlZiwgX25nWm9uZSwgX3JlbmRlcmVyLCBfcGxhdGZvcm0sIF9kaXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fb3ZlcmxheSA9IF9vdmVybGF5O1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3Njcm9sbERpc3BhdGNoZXIgPSBfc2Nyb2xsRGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gJ2JlbG93JztcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGRlbGF5IGluIG1zIGJlZm9yZSBzaG93aW5nIHRoZSB0b29sdGlwIGFmdGVyIHNob3cgaXMgY2FsbGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dEZWxheSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBkZWxheSBpbiBtcyBiZWZvcmUgaGlkaW5nIHRoZSB0b29sdGlwIGFmdGVyIGhpZGUgaXMgY2FsbGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpZGVEZWxheSA9IDA7XG4gICAgICAgIC8vIFRoZSBtb3VzZSBldmVudHMgc2hvdWxkbid0IGJlIGJvdW5kIG9uIGlPUyBkZXZpY2VzLCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZXkgY2FuIHByZXZlbnQgdGhlIGZpcnN0IHRhcCBmcm9tIGZpcmluZyBpdHMgY2xpY2sgZXZlbnQuXG4gICAgICAgIGlmICghX3BsYXRmb3JtLklPUykge1xuICAgICAgICAgICAgX3JlbmRlcmVyLmxpc3RlbihfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNob3coKTsgfSk7XG4gICAgICAgICAgICBfcmVuZGVyZXIubGlzdGVuKF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaGlkZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcG9zaXRpb247IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmRyZXdqcyk6IFdoZW4gdGhlIG92ZXJsYXkncyBwb3NpdGlvbiBjYW4gYmUgZHluYW1pY2FsbHkgY2hhbmdlZCwgZG8gbm90IGRlc3Ryb3lcbiAgICAgICAgICAgICAgICAvLyB0aGUgdG9vbHRpcC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGlzcGxheSBvZiB0aGUgdG9vbHRpcC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICAgICAgLy8gSWYgdG9vbHRpcCBpcyBkaXNhYmxlZCwgaGlkZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX3Bvc2l0aW9uRGVwcmVjYXRlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wb3NpdGlvbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2U7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFRvb2x0aXBNZXNzYWdlKHRoaXMuX21lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfZGVwcmVjYXRlZE1lc3NhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZXNzYWdlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMubWVzc2FnZSA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9tYXRNZXNzYWdlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1lc3NhZ2UgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0UG9zaXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wb3NpdGlvbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLnBvc2l0aW9uID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX21hdERpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5kaXNhYmxlZCA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9tYXRIaWRlRGVsYXlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5oaWRlRGVsYXk7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5oaWRlRGVsYXkgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0U2hvd0RlbGF5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc2hvd0RlbGF5OyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuc2hvd0RlbGF5ID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB0aGUgdG9vbHRpcCB3aGVuIGRlc3Ryb3llZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSB0b29sdGlwIGFmdGVyIHRoZSBkZWxheSBpbiBtcywgZGVmYXVsdHMgdG8gdG9vbHRpcC1kZWxheS1zaG93IG9yIDBtcyBpZiBubyBpbnB1dFxuICAgICAqIEBwYXJhbSB7Pz19IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSB0aGlzLnNob3dEZWxheTsgfVxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAhdGhpcy5fbWVzc2FnZSB8fCAhdGhpcy5fbWVzc2FnZS50cmltKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlVG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFRvb2x0aXBNZXNzYWdlKHRoaXMuX21lc3NhZ2UpO1xuICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2Uuc2hvdyh0aGlzLl9wb3NpdGlvbiwgZGVsYXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIHRvb2x0aXAgYWZ0ZXIgdGhlIGRlbGF5IGluIG1zLCBkZWZhdWx0cyB0byB0b29sdGlwLWRlbGF5LWhpZGUgb3IgMG1zIGlmIG5vIGlucHV0XG4gICAgICogQHBhcmFtIHs/PX0gZGVsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IHRoaXMuaGlkZURlbGF5OyB9XG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5oaWRlKGRlbGF5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hvd3MvaGlkZXMgdGhlIHRvb2x0aXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc1Rvb2x0aXBWaXNpYmxlKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0b29sdGlwIGlzIGN1cnJlbnRseSB2aXNpYmxlIHRvIHRoZSB1c2VyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLl9pc1Rvb2x0aXBWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl90b29sdGlwSW5zdGFuY2UgJiYgdGhpcy5fdG9vbHRpcEluc3RhbmNlLmlzVmlzaWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSB0b29sdGlwIHRvIGRpc3BsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX2NyZWF0ZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChUb29sdGlwQ29tcG9uZW50LCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlID0gdGhpcy5fb3ZlcmxheVJlZi5hdHRhY2gocG9ydGFsKS5pbnN0YW5jZTtcbiAgICAgICAgLy8gRGlzcG9zZSB0aGUgb3ZlcmxheSB3aGVuIGZpbmlzaGVkIHRoZSBzaG93biB0b29sdGlwLlxuICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UuYWZ0ZXJIaWRkZW4oKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZmlyc3QgaWYgdGhlIHRvb2x0aXAgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIHRocm91Z2ggdGhpcyBjb21wb25lbnRzIGRlc3Ryb3kuXG4gICAgICAgICAgICBpZiAoX3RoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwb3NlVG9vbHRpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgb3ZlcmxheSBjb25maWcgYW5kIHBvc2l0aW9uIHN0cmF0ZWd5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW4oKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zaXRpb24gPSB0aGlzLl9nZXRPdmVybGF5UG9zaXRpb24oKTtcbiAgICAgICAgLy8gQ3JlYXRlIGNvbm5lY3RlZCBwb3NpdGlvbiBzdHJhdGVneSB0aGF0IGxpc3RlbnMgZm9yIHNjcm9sbCBldmVudHMgdG8gcmVwb3NpdGlvbi5cbiAgICAgICAgLy8gQWZ0ZXIgcG9zaXRpb24gY2hhbmdlcyBvY2N1ciBhbmQgdGhlIG92ZXJsYXkgaXMgY2xpcHBlZCBieSBhIHBhcmVudCBzY3JvbGxhYmxlIHRoZW5cbiAgICAgICAgLy8gY2xvc2UgdGhlIHRvb2x0aXAuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpLmNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnRSZWYsIG9yaWdpbiwgcG9zaXRpb24pO1xuICAgICAgICBzdHJhdGVneS53aXRoU2Nyb2xsYWJsZUNvbnRhaW5lcnModGhpcy5fc2Nyb2xsRGlzcGF0Y2hlci5nZXRTY3JvbGxDb250YWluZXJzKHRoaXMuX2VsZW1lbnRSZWYpKTtcbiAgICAgICAgc3RyYXRlZ3kub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5zY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMuaXNPdmVybGF5Q2xpcHBlZCAmJlxuICAgICAgICAgICAgICAgIF90aGlzLl90b29sdGlwSW5zdGFuY2UgJiYgX3RoaXMuX3Rvb2x0aXBJbnN0YW5jZS5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25maWcgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIGNvbmZpZy5kaXJlY3Rpb24gPSB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICAgICAgY29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgY29uZmlnLnNjcm9sbFN0cmF0ZWd5ID1cbiAgICAgICAgICAgIG5ldyBSZXBvc2l0aW9uU2Nyb2xsU3RyYXRlZ3kodGhpcy5fc2Nyb2xsRGlzcGF0Y2hlciwgU0NST0xMX1RIUk9UVExFX01TKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKGNvbmZpZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgY3VycmVudCB0b29sdGlwIGFuZCB0aGUgb3ZlcmxheSBpdCBpcyBhdHRhY2hlZCB0b1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fZGlzcG9zZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9yaWdpbiBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdXNlcidzIHBvc2l0aW9uIHByZWZlcmVuY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX2dldE9yaWdpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ2Fib3ZlJyB8fCB0aGlzLnBvc2l0aW9uID09ICdiZWxvdycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdjZW50ZXInLCBvcmlnaW5ZOiB0aGlzLnBvc2l0aW9uID09ICdhYm92ZScgPyAndG9wJyA6ICdib3R0b20nIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNEaXJlY3Rpb25MdHIgPSAhdGhpcy5fZGlyIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJztcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ2xlZnQnIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdiZWZvcmUnICYmIGlzRGlyZWN0aW9uTHRyIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdhZnRlcicgJiYgIWlzRGlyZWN0aW9uTHRyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09ICdyaWdodCcgfHxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2FmdGVyJyAmJiBpc0RpcmVjdGlvbkx0ciB8fFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYmVmb3JlJyAmJiAhaXNEaXJlY3Rpb25MdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93TWRUb29sdGlwSW52YWxpZFBvc2l0aW9uRXJyb3IodGhpcy5wb3NpdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVybGF5IHBvc2l0aW9uIGJhc2VkIG9uIHRoZSB1c2VyJ3MgcHJlZmVyZW5jZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fZ2V0T3ZlcmxheVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAnYWJvdmUnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ2NlbnRlcicsIG92ZXJsYXlZOiAnYm90dG9tJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09ICdiZWxvdycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnY2VudGVyJywgb3ZlcmxheVk6ICd0b3AnIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNMdHIgPSAhdGhpcy5fZGlyIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJztcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ2xlZnQnIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdiZWZvcmUnICYmIGlzTHRyIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdhZnRlcicgJiYgIWlzTHRyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09ICdyaWdodCcgfHxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2FmdGVyJyAmJiBpc0x0ciB8fFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYmVmb3JlJyAmJiAhaXNMdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2NlbnRlcicgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvd01kVG9vbHRpcEludmFsaWRQb3NpdGlvbkVycm9yKHRoaXMucG9zaXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdG9vbHRpcCBtZXNzYWdlIGFuZCByZXBvc2l0aW9ucyB0aGUgb3ZlcmxheSBhY2NvcmRpbmcgdG8gdGhlIG5ldyBtZXNzYWdlIGxlbmd0aFxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fc2V0VG9vbHRpcE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBNdXN0IHdhaXQgZm9yIHRoZSBtZXNzYWdlIHRvIGJlIHBhaW50ZWQgdG8gdGhlIHRvb2x0aXAgc28gdGhhdCB0aGUgb3ZlcmxheSBjYW4gcHJvcGVybHlcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHBvc2l0aW9uaW5nIGJhc2VkIG9uIHRoZSBzaXplIG9mIHRoZSB0ZXh0LlxuICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5fbWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX292ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRUb29sdGlwO1xufSgpKTtcbk1kVG9vbHRpcC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLXRvb2x0aXBdLCBbbWRUb29sdGlwXSwgW21hdC10b29sdGlwXSwgW21hdFRvb2x0aXBdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICcobG9uZ3ByZXNzKSc6ICdzaG93KCknLFxuICAgICAgICAgICAgICAgICAgICAnKHRvdWNoZW5kKSc6ICdoaWRlKCcgKyBUT1VDSEVORF9ISURFX0RFTEFZICsgJyknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtZFRvb2x0aXAnLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFRvb2x0aXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBPdmVybGF5LCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFNjcm9sbERpc3BhdGNoZXIsIH0sXG4gICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogUGxhdGZvcm0sIH0sXG4gICAgeyB0eXBlOiBEaXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbk1kVG9vbHRpcC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAncG9zaXRpb24nOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFRvb2x0aXBQb3NpdGlvbicsXSB9LF0sXG4gICAgJ2Rpc2FibGVkJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWRUb29sdGlwRGlzYWJsZWQnLF0gfSxdLFxuICAgICdfcG9zaXRpb25EZXByZWNhdGVkJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsndG9vbHRpcC1wb3NpdGlvbicsXSB9LF0sXG4gICAgJ3Nob3dEZWxheSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kVG9vbHRpcFNob3dEZWxheScsXSB9LF0sXG4gICAgJ2hpZGVEZWxheSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kVG9vbHRpcEhpZGVEZWxheScsXSB9LF0sXG4gICAgJ21lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFRvb2x0aXAnLF0gfSxdLFxuICAgICdfZGVwcmVjYXRlZE1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZC10b29sdGlwJyxdIH0sXSxcbiAgICAnX21hdE1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXRUb29sdGlwJyxdIH0sXSxcbiAgICAnX21hdFBvc2l0aW9uJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0VG9vbHRpcFBvc2l0aW9uJyxdIH0sXSxcbiAgICAnX21hdERpc2FibGVkJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0VG9vbHRpcERpc2FibGVkJyxdIH0sXSxcbiAgICAnX21hdEhpZGVEZWxheSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21hdFRvb2x0aXBIaWRlRGVsYXknLF0gfSxdLFxuICAgICdfbWF0U2hvd0RlbGF5JzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0VG9vbHRpcFNob3dEZWxheScsXSB9LF0sXG59O1xuLyoqXG4gKiBJbnRlcm5hbCBjb21wb25lbnQgdGhhdCB3cmFwcyB0aGUgdG9vbHRpcCdzIGNvbnRlbnQuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFRvb2x0aXBDb21wb25lbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kaXJcbiAgICAgKiBAcGFyYW0gez99IF9jaGFuZ2VEZXRlY3RvclJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRvb2x0aXBDb21wb25lbnQoX2RpciwgX2NoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydHkgd2F0Y2hlZCBieSB0aGUgYW5pbWF0aW9uIGZyYW1ld29yayB0byBzaG93IG9yIGhpZGUgdGhlIHRvb2x0aXBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHkgPSAnaW5pdGlhbCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGludGVyYWN0aW9ucyBvbiB0aGUgcGFnZSBzaG91bGQgY2xvc2UgdGhlIHRvb2x0aXBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRyYW5zZm9ybSBvcmlnaW4gdXNlZCBpbiB0aGUgYW5pbWF0aW9uIGZvciBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIHRvb2x0aXBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICdib3R0b20nO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoYXQgdGhlIHRvb2x0aXAgaGFzIGJlZW4gaGlkZGVuIGZyb20gdGhlIHZpZXdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uSGlkZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSB0b29sdGlwIHdpdGggYW4gYW5pbWF0aW9uIG9yaWdpbmF0aW5nIGZyb20gdGhlIHByb3ZpZGVkIG9yaWdpblxuICAgICAqIEBwYXJhbSB7P30gcG9zaXRpb24gUG9zaXRpb24gb2YgdGhlIHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHs/fSBkZWxheSBBbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBkZWxheSBzaG93aW5nIHRoZSB0b29sdGlwLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgZGVsYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBkZWxheWVkIGhpZGUgaWYgaXQgaXMgc2NoZWR1bGVkXG4gICAgICAgIGlmICh0aGlzLl9oaWRlVGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQm9keSBpbnRlcmFjdGlvbnMgc2hvdWxkIGNhbmNlbCB0aGUgdG9vbHRpcCBpZiB0aGVyZSBpcyBhIGRlbGF5IGluIHNob3dpbmcuXG4gICAgICAgIHRoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NldFRyYW5zZm9ybU9yaWdpbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3Nob3dUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl92aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgc2V0IHRvIHRydWUgaW1tZWRpYXRlbHksIHRoZW4gYSBib2R5IGNsaWNrIHRoYXQgdHJpZ2dlcnMgc2hvdygpIHdvdWxkXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGludGVyYWN0aW9uIGFuZCBjbG9zZSB0aGUgdG9vbHRpcCByaWdodCBhZnRlciBpdCB3YXMgZGlzcGxheWVkLlxuICAgICAgICAgICAgX3RoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gTWFyayBmb3IgY2hlY2sgc28gaWYgYW55IHBhcmVudCBjb21wb25lbnQgaGFzIHNldCB0aGVcbiAgICAgICAgICAgIC8vIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IHRvIE9uUHVzaCBpdCB3aWxsIGJlIGNoZWNrZWQgYW55d2F5c1xuICAgICAgICAgICAgX3RoaXMuX21hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fY2xvc2VPbkludGVyYWN0aW9uID0gdHJ1ZTsgfSwgMCk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJlZ2lucyB0aGUgYW5pbWF0aW9uIHRvIGhpZGUgdGhlIHRvb2x0aXAgYWZ0ZXIgdGhlIHByb3ZpZGVkIGRlbGF5IGluIG1zLlxuICAgICAqIEBwYXJhbSB7P30gZGVsYXkgQW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBzaG93aW5nIHRoZSB0b29sdGlwLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGRlbGF5ZWQgc2hvdyBpZiBpdCBpcyBzY2hlZHVsZWRcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaG93VGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oaWRlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fdmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgX3RoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gTWFyayBmb3IgY2hlY2sgc28gaWYgYW55IHBhcmVudCBjb21wb25lbnQgaGFzIHNldCB0aGVcbiAgICAgICAgICAgIC8vIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IHRvIE9uUHVzaCBpdCB3aWxsIGJlIGNoZWNrZWQgYW55d2F5c1xuICAgICAgICAgICAgX3RoaXMuX21hcmtGb3JDaGVjaygpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBub3RpZmllcyB3aGVuIHRoZSB0b29sdGlwIGhhcyBiZWVuIGhpZGRlbiBmcm9tIHZpZXdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLmFmdGVySGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25IaWRlLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgdG9vbHRpcCBpcyBiZWluZyBkaXNwbGF5ZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2liaWxpdHkgPT09ICd2aXNpYmxlJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRvb2x0aXAgdHJhbnNmb3JtIG9yaWdpbiBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXAgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZS5fc2V0VHJhbnNmb3JtT3JpZ2luID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzTHRyID0gIXRoaXMuX2RpciB8fCB0aGlzLl9kaXIudmFsdWUgPT0gJ2x0cic7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gaXNMdHIgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IGlzTHRyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWJvdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmVsb3cnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICd0b3AnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3dNZFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuX2FmdGVyVmlzaWJpbGl0eUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RhdGUgPT09ICdoaWRkZW4nICYmICF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkhpZGUubmV4dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcmFjdGlvbnMgb24gdGhlIEhUTUwgYm9keSBzaG91bGQgY2xvc2UgdGhlIHRvb2x0aXAgaW1tZWRpYXRlbHkgYXMgZGVmaW5lZCBpbiB0aGVcbiAgICAgKiBtYXRlcmlhbCBkZXNpZ24gc3BlYy5cbiAgICAgKiBodHRwczovL21hdGVyaWFsLmdvb2dsZS5jb20vY29tcG9uZW50cy90b29sdGlwcy5odG1sI3Rvb2x0aXBzLWludGVyYWN0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZS5faGFuZGxlQm9keUludGVyYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VPbkludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoYXQgdGhlIHRvb2x0aXAgbmVlZHMgdG8gYmUgY2hlY2tlZCBpbiB0aGUgbmV4dCBjaGFuZ2UgZGV0ZWN0aW9uIHJ1bi5cbiAgICAgKiBNYWlubHkgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBpbml0aWFsIHRleHQgYmVmb3JlIHBvc2l0aW9uaW5nIGEgdG9vbHRpcCwgd2hpY2hcbiAgICAgKiBjYW4gYmUgcHJvYmxlbWF0aWMgaW4gY29tcG9uZW50cyB3aXRoIE9uUHVzaCBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuX21hcmtGb3JDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbHRpcENvbXBvbmVudDtcbn0oKSk7XG5Ub29sdGlwQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtdG9vbHRpcC1jb21wb25lbnQsIG1hdC10b29sdGlwLWNvbXBvbmVudCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXRvb2x0aXBcXFwiIFtzdHlsZS50cmFuc2Zvcm0tb3JpZ2luXT1cXFwiX3RyYW5zZm9ybU9yaWdpblxcXCIgW0BzdGF0ZV09XFxcIl92aXNpYmlsaXR5XFxcIiAoQHN0YXRlLmRvbmUpPVxcXCJfYWZ0ZXJWaXNpYmlsaXR5QW5pbWF0aW9uKCRldmVudClcXFwiPiB7e21lc3NhZ2V9fSA8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e3BvaW50ZXItZXZlbnRzOm5vbmV9Lm1hdC10b29sdGlwe2NvbG9yOiNmZmY7cGFkZGluZzo2cHggOHB4O2JvcmRlci1yYWRpdXM6MnB4O2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7Zm9udC1zaXplOjEwcHg7bWFyZ2luOjE0cHg7bWF4LXdpZHRoOjI1MHB4fUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtdG9vbHRpcHtvdXRsaW5lOnNvbGlkIDFweH19IC8qIyBzb3VyY2VNYXBwaW5nVVJMPXRvb2x0aXAuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdzdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCd2b2lkJywgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2luaXRpYWwnLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgndmlzaWJsZScsIHN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoMSknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdoaWRkZW4nLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IHZpc2libGUnLCBhbmltYXRlKCcxNTBtcyBjdWJpYy1iZXppZXIoMC4wLCAwLjAsIDAuMiwgMSknKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IGhpZGRlbicsIGFuaW1hdGUoJzE1MG1zIGN1YmljLWJlemllcigwLjQsIDAuMCwgMSwgMSknKSksXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICcoYm9keTpjbGljayknOiAndGhpcy5faGFuZGxlQm9keUludGVyYWN0aW9uKCknXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Ub29sdGlwQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRGlyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmLCB9LFxuXTsgfTtcbnZhciBNZFRvb2x0aXBNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRvb2x0aXBNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFRvb2x0aXBNb2R1bGU7XG59KCkpO1xuTWRUb29sdGlwTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbT3ZlcmxheU1vZHVsZSwgTWRDb21tb25Nb2R1bGUsIFBsYXRmb3JtTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRUb29sdGlwLCBUb29sdGlwQ29tcG9uZW50LCBNZENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRUb29sdGlwLCBUb29sdGlwQ29tcG9uZW50XSxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtUb29sdGlwQ29tcG9uZW50XSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUb29sdGlwTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gZm9yIHRoZSBjYXNlIHdoZW4gbWVudSB0cmlnZ2VyIGRvZXNuJ3QgaGF2ZSBhIHZhbGlkIG1kLW1lbnUgaW5zdGFuY2VcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGhyb3dNZE1lbnVNaXNzaW5nRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWQtbWVudS10cmlnZ2VyOiBtdXN0IHBhc3MgaW4gYW4gbWQtbWVudSBpbnN0YW5jZS5cXG5cXG4gICAgRXhhbXBsZTpcXG4gICAgICA8bWQtbWVudSAjbWVudT1cXFwibWRNZW51XFxcIj48L21kLW1lbnU+XFxuICAgICAgPGJ1dHRvbiBbbWRNZW51VHJpZ2dlckZvcl09XFxcIm1lbnVcXFwiPjwvYnV0dG9uPlwiKTtcbn1cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIGNhc2Ugd2hlbiBtZW51J3MgeC1wb3NpdGlvbiB2YWx1ZSBpc24ndCB2YWxpZC5cbiAqIEluIG90aGVyIHdvcmRzLCBpdCBkb2Vzbid0IG1hdGNoICdiZWZvcmUnIG9yICdhZnRlcicuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRocm93TWRNZW51SW52YWxpZFBvc2l0aW9uWCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4LXBvc2l0aW9uIHZhbHVlIG11c3QgYmUgZWl0aGVyICdiZWZvcmUnIG9yIGFmdGVyJy5cXG4gICAgICBFeGFtcGxlOiA8bWQtbWVudSB4LXBvc2l0aW9uPVxcXCJiZWZvcmVcXFwiICNtZW51PVxcXCJtZE1lbnVcXFwiPjwvbWQtbWVudT5cIik7XG59XG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gZm9yIHRoZSBjYXNlIHdoZW4gbWVudSdzIHktcG9zaXRpb24gdmFsdWUgaXNuJ3QgdmFsaWQuXG4gKiBJbiBvdGhlciB3b3JkcywgaXQgZG9lc24ndCBtYXRjaCAnYWJvdmUnIG9yICdiZWxvdycuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRocm93TWRNZW51SW52YWxpZFBvc2l0aW9uWSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5LXBvc2l0aW9uIHZhbHVlIG11c3QgYmUgZWl0aGVyICdhYm92ZScgb3IgYmVsb3cnLlxcbiAgICAgIEV4YW1wbGU6IDxtZC1tZW51IHktcG9zaXRpb249XFxcImFib3ZlXFxcIiAjbWVudT1cXFwibWRNZW51XFxcIj48L21kLW1lbnU+XCIpO1xufVxuLyoqXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluc2lkZSBhbiBtZC1tZW51IHRhZy5cbiAqIEl0IGV4aXN0cyBtb3N0bHkgdG8gc2V0IHRoZSByb2xlIGF0dHJpYnV0ZS5cbiAqL1xudmFyIE1kTWVudUl0ZW0gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRNZW51SXRlbShfZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBtZW51IGl0ZW0gaXMgZGlzYWJsZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIG1lbnUgaXRlbS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudUl0ZW0ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9nZXRIb3N0RWxlbWVudCgpLmZvY3VzKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51SXRlbS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbWVudSBpdGVtIGlzIGRpc2FibGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc2V0IHRoZSBgdGFiaW5kZXhgLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51SXRlbS5wcm90b3R5cGUuX2dldFRhYkluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQgPyAnLTEnIDogJzAnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzZXQgdGhlIEhUTUwgYGRpc2FibGVkYCBhdHRyaWJ1dGUuIE5lY2Vzc2FyeSBmb3IgbGlua3MgdG8gYmUgZGlzYWJsZWQgcHJvcGVybHkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVJdGVtLnByb3RvdHlwZS5fZ2V0RGlzYWJsZWRBdHRyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQgPyB0cnVlIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhvc3QgRE9NIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVJdGVtLnByb3RvdHlwZS5fZ2V0SG9zdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBlbGVtZW50IGFjdGlvbnMgaWYgaXQgaXMgZGlzYWJsZWQuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51SXRlbS5wcm90b3R5cGUuX2NoZWNrRGlzYWJsZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kTWVudUl0ZW07XG59KCkpO1xuTWRNZW51SXRlbS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ1ttZC1tZW51LWl0ZW1dLCBbbWF0LW1lbnUtaXRlbV0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnbWVudWl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1tZW51LWl0ZW1dJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIudGFiaW5kZXhdJzogJ19nZXRUYWJJbmRleCgpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkLnRvU3RyaW5nKCknLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuZGlzYWJsZWRdJzogJ19nZXREaXNhYmxlZEF0dHIoKScsXG4gICAgICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19jaGVja0Rpc2FibGVkKCRldmVudCknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiA8ZGl2IGNsYXNzPVxcXCJtYXQtbWVudS1yaXBwbGVcXFwiICpuZ0lmPVxcXCIhZGlzYWJsZWRcXFwiIG1kLXJpcHBsZSBbbWRSaXBwbGVUcmlnZ2VyXT1cXFwiX2dldEhvc3RFbGVtZW50KClcXFwiPiA8L2Rpdj4gXCIsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtZE1lbnVJdGVtJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZE1lbnVJdGVtLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbl07IH07XG5NZE1lbnVJdGVtLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG4vKipcbiAqIEJlbG93IGFyZSBhbGwgdGhlIGFuaW1hdGlvbnMgZm9yIHRoZSBtZC1tZW51IGNvbXBvbmVudC5cbiAqIEFuaW1hdGlvbiBkdXJhdGlvbiBhbmQgdGltaW5nIHZhbHVlcyBhcmUgYmFzZWQgb24gQW5ndWxhckpTIE1hdGVyaWFsLlxuICovXG4vKipcbiAqIFRoaXMgYW5pbWF0aW9uIGNvbnRyb2xzIHRoZSBtZW51IHBhbmVsJ3MgZW50cnkgYW5kIGV4aXQgZnJvbSB0aGUgcGFnZS5cbiAqXG4gKiBXaGVuIHRoZSBtZW51IHBhbmVsIGlzIGFkZGVkIHRvIHRoZSBET00sIGl0IHNjYWxlcyBpbiBhbmQgZmFkZXMgaW4gaXRzIGJvcmRlci5cbiAqXG4gKiBXaGVuIHRoZSBtZW51IHBhbmVsIGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLCBpdCBzaW1wbHkgZmFkZXMgb3V0IGFmdGVyIGEgYnJpZWZcbiAqIGRlbGF5IHRvIGRpc3BsYXkgdGhlIHJpcHBsZS5cbiAqL1xuLy8gVE9ETyhrYXJhKTogc3dpdGNoIHRvIDplbnRlciBhbmQgOmxlYXZlIG9uY2UgTW9iaWxlIFNhZmFyaSBpcyBzb3J0ZWQgb3V0LlxudmFyIHRyYW5zZm9ybU1lbnUgPSB0cmlnZ2VyKCd0cmFuc2Zvcm1NZW51JywgW1xuICAgIHN0YXRlKCdzaG93aW5nJywgc3R5bGUoe1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIlxuICAgIH0pKSxcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbXG4gICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMClcIlxuICAgICAgICB9KSxcbiAgICAgICAgYW5pbWF0ZShcIjIwMG1zIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpXCIpXG4gICAgXSksXG4gICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xuICAgICAgICBhbmltYXRlKCc1MG1zIDEwMG1zIGxpbmVhcicsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSlcbiAgICBdKVxuXSk7XG4vKipcbiAqIFRoaXMgYW5pbWF0aW9uIGZhZGVzIGluIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFuZCBjb250ZW50IG9mIHRoZSBtZW51IHBhbmVsXG4gKiBhZnRlciBpdHMgY29udGFpbmluZyBlbGVtZW50IGlzIHNjYWxlZCBpbi5cbiAqL1xudmFyIGZhZGVJbkl0ZW1zID0gdHJpZ2dlcignZmFkZUluSXRlbXMnLCBbXG4gICAgc3RhdGUoJ3Nob3dpbmcnLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpLFxuICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtcbiAgICAgICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICAgICAgICBhbmltYXRlKFwiMjAwbXMgMTAwbXMgY3ViaWMtYmV6aWVyKDAuNTUsIDAsIDAuNTUsIDAuMilcIilcbiAgICBdKVxuXSk7XG4vLyBUT0RPKGthcmEpOiBwcmV2ZW50LWNsb3NlIGZ1bmN0aW9uYWxpdHlcbnZhciBNZE1lbnUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE1lbnUoKSB7XG4gICAgICAgIHRoaXMuX3hQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgICAgIHRoaXMuX3lQb3NpdGlvbiA9ICdiZWxvdyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBtZW51J3MgbmdDbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0ID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBtZW51IHNob3VsZCBvdmVybGFwIGl0cyB0cmlnZ2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vdmVybGFwVHJpZ2dlciA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIG1lbnUgaXMgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudS5wcm90b3R5cGUsIFwieFBvc2l0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvc2l0aW9uIG9mIHRoZSBtZW51IGluIHRoZSBYIGF4aXMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3hQb3NpdGlvbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICdiZWZvcmUnICYmIHZhbHVlICE9PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dNZE1lbnVJbnZhbGlkUG9zaXRpb25YKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94UG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb25DbGFzc2VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1lbnUucHJvdG90eXBlLCBcInlQb3NpdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3NpdGlvbiBvZiB0aGUgbWVudSBpbiB0aGUgWSBheGlzLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl95UG9zaXRpb247IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnYWJvdmUnICYmIHZhbHVlICE9PSAnYmVsb3cnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dNZE1lbnVJbnZhbGlkUG9zaXRpb25ZKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl95UG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb25DbGFzc2VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1lbnUucHJvdG90eXBlLCBcImNsYXNzTGlzdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBjbGFzc2VzIHNldCBvbiB0aGUgaG9zdCBtZC1tZW51IGVsZW1lbnQgYW5kIGFwcGxpZXMgdGhlbSBvbiB0aGVcbiAgICAgICAgICogbWVudSB0ZW1wbGF0ZSB0aGF0IGRpc3BsYXlzIGluIHRoZSBvdmVybGF5IGNvbnRhaW5lci4gIE90aGVyd2lzZSwgaXQncyBkaWZmaWN1bHRcbiAgICAgICAgICogdG8gc3R5bGUgdGhlIGNvbnRhaW5pbmcgbWVudSBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogQHBhcmFtIHs/fSBjbGFzc2VzIGxpc3Qgb2YgY2xhc3MgbmFtZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsYXNzTGlzdCA9IGNsYXNzZXMuc3BsaXQoJyAnKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgb2JqW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEZvY3VzS2V5TWFuYWdlcih0aGlzLml0ZW1zKS53aXRoV3JhcCgpO1xuICAgICAgICB0aGlzLl90YWJTdWJzY3JpcHRpb24gPSB0aGlzLl9rZXlNYW5hZ2VyLnRhYk91dC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2VtaXRDbG9zZUV2ZW50KCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdGFiU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEga2V5Ym9hcmQgZXZlbnQgZnJvbSB0aGUgbWVudSwgZGVsZWdhdGluZyB0byB0aGUgYXBwcm9wcmlhdGUgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudS5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEVTQ0FQRTpcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0Q2xvc2VFdmVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5vbktleWRvd24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1cyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbWVudS4gVGhpcyBtZXRob2QgaXMgdXNlZCBieSB0aGUgbWVudSB0cmlnZ2VyXG4gICAgICogdG8gZm9jdXMgdGhlIGZpcnN0IGl0ZW0gd2hlbiB0aGUgbWVudSBpcyBvcGVuZWQgYnkgdGhlIEVOVEVSIGtleS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudS5wcm90b3R5cGUuZm9jdXNGaXJzdEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGVtaXRzIGEgY2xvc2UgZXZlbnQgdG8gd2hpY2ggdGhlIHRyaWdnZXIgaXMgc3Vic2NyaWJlZC4gV2hlbiBlbWl0dGVkLCB0aGVcbiAgICAgKiB0cmlnZ2VyIHdpbGwgY2xvc2UgdGhlIG1lbnUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnUucHJvdG90eXBlLl9lbWl0Q2xvc2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbG9zZS5lbWl0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJdCdzIG5lY2Vzc2FyeSB0byBzZXQgcG9zaXRpb24tYmFzZWQgY2xhc3NlcyB0byBlbnN1cmUgdGhlIG1lbnUgcGFuZWwgYW5pbWF0aW9uXG4gICAgICogZm9sZHMgb3V0IGZyb20gdGhlIGNvcnJlY3QgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Pz19IHBvc1hcbiAgICAgKiBAcGFyYW0gez89fSBwb3NZXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnUucHJvdG90eXBlLnNldFBvc2l0aW9uQ2xhc3NlcyA9IGZ1bmN0aW9uIChwb3NYLCBwb3NZKSB7XG4gICAgICAgIGlmIChwb3NYID09PSB2b2lkIDApIHsgcG9zWCA9IHRoaXMueFBvc2l0aW9uOyB9XG4gICAgICAgIGlmIChwb3NZID09PSB2b2lkIDApIHsgcG9zWSA9IHRoaXMueVBvc2l0aW9uOyB9XG4gICAgICAgIHRoaXMuX2NsYXNzTGlzdFsnbWF0LW1lbnUtYmVmb3JlJ10gPSBwb3NYID09PSAnYmVmb3JlJztcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydtYXQtbWVudS1hZnRlciddID0gcG9zWCA9PT0gJ2FmdGVyJztcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydtYXQtbWVudS1hYm92ZSddID0gcG9zWSA9PT0gJ2Fib3ZlJztcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydtYXQtbWVudS1iZWxvdyddID0gcG9zWSA9PT0gJ2JlbG93JztcbiAgICB9O1xuICAgIHJldHVybiBNZE1lbnU7XG59KCkpO1xuTWRNZW51LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtbWVudSwgbWF0LW1lbnUnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ3JvbGUnOiAnbWVudScgfSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctdGVtcGxhdGU+IDxkaXYgY2xhc3M9XFxcIm1hdC1tZW51LXBhbmVsXFxcIiBbbmdDbGFzc109XFxcIl9jbGFzc0xpc3RcXFwiIChrZXlkb3duKT1cXFwiX2hhbmRsZUtleWRvd24oJGV2ZW50KVxcXCIgKGNsaWNrKT1cXFwiX2VtaXRDbG9zZUV2ZW50KClcXFwiIFtAdHJhbnNmb3JtTWVudV09XFxcIidzaG93aW5nJ1xcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1tZW51LWNvbnRlbnRcXFwiIFtAZmFkZUluSXRlbXNdPVxcXCInc2hvd2luZydcXFwiPiA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IDwvZGl2PiA8L2Rpdj4gPC9uZy10ZW1wbGF0ZT4gXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LW1lbnUtcGFuZWx7Ym94LXNoYWRvdzowIDVweCA1cHggLTNweCByZ2JhKDAsMCwwLC4yKSwwIDhweCAxMHB4IDFweCByZ2JhKDAsMCwwLC4xNCksMCAzcHggMTRweCAycHggcmdiYSgwLDAsMCwuMTIpO21pbi13aWR0aDoxMTJweDttYXgtd2lkdGg6MjgwcHg7b3ZlcmZsb3c6YXV0bzstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDttYXgtaGVpZ2h0OmNhbGMoMTAwdmggLSA0OHB4KX0ubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYWZ0ZXIubWF0LW1lbnUtYmVsb3d7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IHRvcH0ubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYWZ0ZXIubWF0LW1lbnUtYWJvdmV7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IGJvdHRvbX0ubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYmVmb3JlLm1hdC1tZW51LWJlbG93e3RyYW5zZm9ybS1vcmlnaW46cmlnaHQgdG9wfS5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1iZWZvcmUubWF0LW1lbnUtYWJvdmV7dHJhbnNmb3JtLW9yaWdpbjpyaWdodCBib3R0b219W2Rpcj1ydGxdIC5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1hZnRlci5tYXQtbWVudS1iZWxvd3t0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0IHRvcH1bZGlyPXJ0bF0gLm1hdC1tZW51LXBhbmVsLm1hdC1tZW51LWFmdGVyLm1hdC1tZW51LWFib3Zle3RyYW5zZm9ybS1vcmlnaW46cmlnaHQgYm90dG9tfVtkaXI9cnRsXSAubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYmVmb3JlLm1hdC1tZW51LWJlbG93e3RyYW5zZm9ybS1vcmlnaW46bGVmdCB0b3B9W2Rpcj1ydGxdIC5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1iZWZvcmUubWF0LW1lbnUtYWJvdmV7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IGJvdHRvbX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LW1lbnUtcGFuZWx7b3V0bGluZTpzb2xpZCAxcHh9fS5tYXQtbWVudS1jb250ZW50e3BhZGRpbmctdG9wOjhweDtwYWRkaW5nLWJvdHRvbTo4cHh9Lm1hdC1tZW51LWl0ZW17LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2N1cnNvcjpwb2ludGVyO291dGxpbmU6MDtib3JkZXI6bm9uZTt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7ZGlzcGxheTpibG9jaztsaW5lLWhlaWdodDo0OHB4O2hlaWdodDo0OHB4O3BhZGRpbmc6MCAxNnB4O2ZvbnQtc2l6ZToxNnB4O2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7dGV4dC1hbGlnbjpsZWZ0O3RleHQtZGVjb3JhdGlvbjpub25lO3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtbWVudS1pdGVtW2Rpc2FibGVkXXtjdXJzb3I6ZGVmYXVsdH1bZGlyPXJ0bF0gLm1hdC1tZW51LWl0ZW17dGV4dC1hbGlnbjpyaWdodH0ubWF0LW1lbnUtaXRlbSAubWF0LWljb257bWFyZ2luLXJpZ2h0OjE2cHh9W2Rpcj1ydGxdIC5tYXQtbWVudS1pdGVtIC5tYXQtaWNvbnttYXJnaW4tbGVmdDoxNnB4O21hcmdpbi1yaWdodDowfWJ1dHRvbi5tYXQtbWVudS1pdGVte3dpZHRoOjEwMCV9Lm1hdC1tZW51LXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9bWVudS5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtTWVudSxcbiAgICAgICAgICAgICAgICAgICAgZmFkZUluSXRlbXNcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRNZW51J1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZE1lbnUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbk1kTWVudS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAneFBvc2l0aW9uJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd5UG9zaXRpb24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3RlbXBsYXRlUmVmJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbVGVtcGxhdGVSZWYsXSB9LF0sXG4gICAgJ2l0ZW1zJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWRNZW51SXRlbSxdIH0sXSxcbiAgICAnb3ZlcmxhcFRyaWdnZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NsYXNzTGlzdCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2NsYXNzJyxdIH0sXSxcbiAgICAnY2xvc2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxufTtcbi8qKlxuICogVGhpcyBkaXJlY3RpdmUgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGFuIG1kLW1lbnUgdGFnLiAgSXQgaXNcbiAqIHJlc3BvbnNpYmxlIGZvciB0b2dnbGluZyB0aGUgZGlzcGxheSBvZiB0aGUgcHJvdmlkZWQgbWVudSBpbnN0YW5jZS5cbiAqL1xudmFyIE1kTWVudVRyaWdnZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9vdmVybGF5XG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdDb250YWluZXJSZWZcbiAgICAgKiBAcGFyYW0gez99IF9kaXJcbiAgICAgKiBAcGFyYW0gez99IF9zY3JvbGxEaXNwYXRjaGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRNZW51VHJpZ2dlcihfb3ZlcmxheSwgX2VsZW1lbnQsIF92aWV3Q29udGFpbmVyUmVmLCBfZGlyLCBfc2Nyb2xsRGlzcGF0Y2hlcikge1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gX292ZXJsYXk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9zY3JvbGxEaXNwYXRjaGVyID0gX3Njcm9sbERpc3BhdGNoZXI7XG4gICAgICAgIHRoaXMuX21lbnVPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29wZW5lZEJ5TW91c2UgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBtZW51IGlzIG9wZW5lZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25NZW51T3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBtZW51IGlzIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25NZW51Q2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZSwgXCJfZGVwcmVjYXRlZE1kTWVudVRyaWdnZXJGb3JcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZW51OyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMubWVudSA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZSwgXCJfZGVwcmVjYXRlZE1hdE1lbnVUcmlnZ2VyRm9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVudTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1lbnUgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwiX21hdE1lbnVUcmlnZ2VyRm9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVudTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1lbnUgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2hlY2tNZW51KCk7XG4gICAgICAgIHRoaXMubWVudS5jbG9zZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvc2VNZW51KCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5kZXN0cm95TWVudSgpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZSwgXCJtZW51T3BlblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBtZW51IGlzIG9wZW4uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21lbnVPcGVuOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBtZW51IGJldHdlZW4gdGhlIG9wZW4gYW5kIGNsb3NlZCBzdGF0ZXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS50b2dnbGVNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVudU9wZW4gPyB0aGlzLmNsb3NlTWVudSgpIDogdGhpcy5vcGVuTWVudSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIG1lbnUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5vcGVuTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tZW51T3Blbikge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5hdHRhY2godGhpcy5fcG9ydGFsKTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvQmFja2Ryb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRNZW51KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgbWVudS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLmNsb3NlTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRNZW51KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG1lbnUgZnJvbSB0aGUgRE9NLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuZGVzdHJveU1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW5VcFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbWVudSB0cmlnZ2VyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcImRpclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGNvbnRhaW5pbmcgYXBwLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBlbnN1cmVzIHRoYXQgdGhlIG1lbnUgY2xvc2VzIHdoZW4gdGhlIG92ZXJsYXkgYmFja2Ryb3AgaXMgY2xpY2tlZC5cbiAgICAgKiBXZSBkbyBub3QgdXNlIGZpcnN0KCkgaGVyZSBiZWNhdXNlIGRvaW5nIHNvIHdvdWxkIG5vdCBjYXRjaCBjbGlja3MgZnJvbSB3aXRoaW5cbiAgICAgKiB0aGUgbWVudSwgYW5kIGl0IHdvdWxkIGZhaWwgdG8gdW5zdWJzY3JpYmUgcHJvcGVybHkuIEluc3RlYWQsIHdlIHVuc3Vic2NyaWJlXG4gICAgICogZXhwbGljaXRseSB3aGVuIHRoZSBtZW51IGlzIGNsb3NlZCBvciBkZXN0cm95ZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5fc3Vic2NyaWJlVG9CYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24gPSB0aGlzLl9vdmVybGF5UmVmLmJhY2tkcm9wQ2xpY2soKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMubWVudS5fZW1pdENsb3NlRXZlbnQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBtZW51IHN0YXRlIHRvIG9wZW4gYW5kIGZvY3VzZXMgdGhlIGZpcnN0IGl0ZW0gaWZcbiAgICAgKiB0aGUgbWVudSB3YXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5faW5pdE1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldElzTWVudU9wZW4odHJ1ZSk7XG4gICAgICAgIC8vIFNob3VsZCBvbmx5IHNldCBmb2N1cyBpZiBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZCwgc28ga2V5Ym9hcmQgdXNlcnMgY2FuXG4gICAgICAgIC8vIGNhbiBlYXNpbHkgbmF2aWdhdGUgbWVudSBpdGVtcy4gQWNjb3JkaW5nIHRvIHNwZWMsIG1vdXNlIHVzZXJzIHNob3VsZCBub3RcbiAgICAgICAgLy8gc2VlIHRoZSBmb2N1cyBzdHlsZS5cbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWRCeU1vdXNlKSB7XG4gICAgICAgICAgICB0aGlzLm1lbnUuZm9jdXNGaXJzdEl0ZW0oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSBtZW51IHdoZW4gaXQncyBjbG9zZWQsIG1vc3QgaW1wb3J0YW50bHkgcmVzdG9yaW5nXG4gICAgICogZm9jdXMgdG8gdGhlIG1lbnUgdHJpZ2dlciBpZiB0aGUgbWVudSB3YXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5fcmVzZXRNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZXRJc01lbnVPcGVuKGZhbHNlKTtcbiAgICAgICAgLy8gRm9jdXMgb25seSBuZWVkcyB0byBiZSByZXNldCB0byB0aGUgaG9zdCBlbGVtZW50IGlmIHRoZSBtZW51IHdhcyBvcGVuZWRcbiAgICAgICAgLy8gYnkgdGhlIGtleWJvYXJkIGFuZCBtYW51YWxseSBzaGlmdGVkIHRvIHRoZSBmaXJzdCBtZW51IGl0ZW0uXG4gICAgICAgIGlmICghdGhpcy5fb3BlbmVkQnlNb3VzZSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5lZEJ5TW91c2UgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXNPcGVuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5fc2V0SXNNZW51T3BlbiA9IGZ1bmN0aW9uIChpc09wZW4pIHtcbiAgICAgICAgdGhpcy5fbWVudU9wZW4gPSBpc09wZW47XG4gICAgICAgIHRoaXMuX21lbnVPcGVuID8gdGhpcy5vbk1lbnVPcGVuLmVtaXQoKSA6IHRoaXMub25NZW51Q2xvc2UuZW1pdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogIFRoaXMgbWV0aG9kIGNoZWNrcyB0aGF0IGEgdmFsaWQgaW5zdGFuY2Ugb2YgTWRNZW51IGhhcyBiZWVuIHBhc3NlZCBpbnRvXG4gICAgICogIG1kTWVudVRyaWdnZXJGb3IuIElmIG5vdCwgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9jaGVja01lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5tZW51KSB7XG4gICAgICAgICAgICB0aHJvd01kTWVudU1pc3NpbmdFcnJvcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAgVGhpcyBtZXRob2QgY3JlYXRlcyB0aGUgb3ZlcmxheSBmcm9tIHRoZSBwcm92aWRlZCBtZW51J3MgdGVtcGxhdGUgYW5kIHNhdmVzIGl0c1xuICAgICAqICBPdmVybGF5UmVmIHNvIHRoYXQgaXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBET00gd2hlbiBvcGVuTWVudSBpcyBjYWxsZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGhpcy5tZW51LnRlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmZpZyA9IHRoaXMuX2dldE92ZXJsYXlDb25maWcoKTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25zKC8qKiBAdHlwZSB7P30gKi8gKGNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5KSk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYnVpbGRzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBuZWVkZWQgdG8gY3JlYXRlIHRoZSBvdmVybGF5LCB0aGUgT3ZlcmxheVN0YXRlLlxuICAgICAqIEByZXR1cm4gez99IE92ZXJsYXlTdGF0ZVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9nZXRPdmVybGF5Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5U3RhdGUgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fZ2V0UG9zaXRpb24oKVxuICAgICAgICAgICAgLndpdGhEaXJlY3Rpb24odGhpcy5kaXIpO1xuICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgICBvdmVybGF5U3RhdGUuYmFja2Ryb3BDbGFzcyA9ICdjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCc7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5kaXJlY3Rpb24gPSB0aGlzLmRpcjtcbiAgICAgICAgb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5ID0gbmV3IFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneSh0aGlzLl9zY3JvbGxEaXNwYXRjaGVyKTtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlTdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbnMgdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldHMgdGhlIGNvcnJlY3QgY2xhc3Nlc1xuICAgICAqIG9uIHRoZSBtZW51IGJhc2VkIG9uIHRoZSBuZXcgcG9zaXRpb24uIFRoaXMgZW5zdXJlcyB0aGUgYW5pbWF0aW9uIG9yaWdpbiBpcyBhbHdheXNcbiAgICAgKiBjb3JyZWN0LCBldmVuIGlmIGEgZmFsbGJhY2sgcG9zaXRpb24gaXMgdXNlZCBmb3IgdGhlIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHs/fSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX3N1YnNjcmliZVRvUG9zaXRpb25zID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uID0gcG9zaXRpb24ub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zWCA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vcmlnaW5YID09PSAnc3RhcnQnID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zWSA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vcmlnaW5ZID09PSAndG9wJyA/ICdiZWxvdycgOiAnYWJvdmUnO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5tZW51Lm92ZXJsYXBUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgcG9zWSA9IHBvc1kgPT09ICdiZWxvdycgPyAnYWJvdmUnIDogJ2JlbG93JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm1lbnUuc2V0UG9zaXRpb25DbGFzc2VzKHBvc1gsIHBvc1kpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgZm9yIHRoZSBvdmVybGF5LCBzbyB0aGUgbWVudSBpcyBwcm9wZXJseSBjb25uZWN0ZWRcbiAgICAgKiB0byB0aGUgdHJpZ2dlci5cbiAgICAgKiBAcmV0dXJuIHs/fSBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2dldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm1lbnUueFBvc2l0aW9uID09PSAnYmVmb3JlJyA/IFsnZW5kJywgJ3N0YXJ0J10gOiBbJ3N0YXJ0JywgJ2VuZCddLCBwb3NYID0gX2FbMF0sIGZhbGxiYWNrWCA9IF9hWzFdO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLm1lbnUueVBvc2l0aW9uID09PSAnYWJvdmUnID8gWydib3R0b20nLCAndG9wJ10gOiBbJ3RvcCcsICdib3R0b20nXSwgb3ZlcmxheVkgPSBfYlswXSwgZmFsbGJhY2tPdmVybGF5WSA9IF9iWzFdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5ZID0gb3ZlcmxheVk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZhbGxiYWNrT3JpZ2luWSA9IGZhbGxiYWNrT3ZlcmxheVk7XG4gICAgICAgIGlmICghdGhpcy5tZW51Lm92ZXJsYXBUcmlnZ2VyKSB7XG4gICAgICAgICAgICBvcmlnaW5ZID0gb3ZlcmxheVkgPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICAgIGZhbGxiYWNrT3JpZ2luWSA9IGZhbGxiYWNrT3ZlcmxheVkgPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAgICAgICAuY29ubmVjdGVkVG8odGhpcy5fZWxlbWVudCwgeyBvcmlnaW5YOiBwb3NYLCBvcmlnaW5ZOiBvcmlnaW5ZIH0sIHsgb3ZlcmxheVg6IHBvc1gsIG92ZXJsYXlZOiBvdmVybGF5WSB9KVxuICAgICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKHsgb3JpZ2luWDogZmFsbGJhY2tYLCBvcmlnaW5ZOiBvcmlnaW5ZIH0sIHsgb3ZlcmxheVg6IGZhbGxiYWNrWCwgb3ZlcmxheVk6IG92ZXJsYXlZIH0pXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oeyBvcmlnaW5YOiBwb3NYLCBvcmlnaW5ZOiBmYWxsYmFja09yaWdpblkgfSwgeyBvdmVybGF5WDogcG9zWCwgb3ZlcmxheVk6IGZhbGxiYWNrT3ZlcmxheVkgfSlcbiAgICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbih7IG9yaWdpblg6IGZhbGxiYWNrWCwgb3JpZ2luWTogZmFsbGJhY2tPcmlnaW5ZIH0sIHsgb3ZlcmxheVg6IGZhbGxiYWNrWCwgb3ZlcmxheVk6IGZhbGxiYWNrT3ZlcmxheVkgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9jbGVhblVwU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2hhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuZWRCeU1vdXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kTWVudVRyaWdnZXI7XG59KCkpO1xuTWRNZW51VHJpZ2dlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBcIlttZC1tZW51LXRyaWdnZXItZm9yXSwgW21hdC1tZW51LXRyaWdnZXItZm9yXSxcXG4gICAgICAgICAgICAgW21kTWVudVRyaWdnZXJGb3JdLCBbbWF0TWVudVRyaWdnZXJGb3JdXCIsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgJyhtb3VzZWRvd24pJzogJ19oYW5kbGVNb3VzZWRvd24oJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ3RvZ2dsZU1lbnUoKScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21kTWVudVRyaWdnZXInXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTWVudVRyaWdnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBPdmVybGF5LCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgeyB0eXBlOiBEaXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogU2Nyb2xsRGlzcGF0Y2hlciwgfSxcbl07IH07XG5NZE1lbnVUcmlnZ2VyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdfZGVwcmVjYXRlZE1kTWVudVRyaWdnZXJGb3InOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZC1tZW51LXRyaWdnZXItZm9yJyxdIH0sXSxcbiAgICAnX2RlcHJlY2F0ZWRNYXRNZW51VHJpZ2dlckZvcic6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21hdC1tZW51LXRyaWdnZXItZm9yJyxdIH0sXSxcbiAgICAnX21hdE1lbnVUcmlnZ2VyRm9yJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0TWVudVRyaWdnZXJGb3InLF0gfSxdLFxuICAgICdtZW51JzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWRNZW51VHJpZ2dlckZvcicsXSB9LF0sXG4gICAgJ29uTWVudU9wZW4nOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdvbk1lbnVDbG9zZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xudmFyIE1kTWVudU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTWVudU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTWVudU1vZHVsZTtcbn0oKSk7XG5NZE1lbnVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZFJpcHBsZU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRNZW51LCBNZE1lbnVJdGVtLCBNZE1lbnVUcmlnZ2VyLCBNZENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRNZW51LCBNZE1lbnVJdGVtLCBNZE1lbnVUcmlnZ2VyXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRNZW51TW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGRpYWxvZyBvcGVuZWQgdmlhIHRoZSBNZERpYWxvZyBzZXJ2aWNlLlxuICovXG52YXIgTWREaWFsb2dSZWYgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9vdmVybGF5UmVmXG4gICAgICogQHBhcmFtIHs/fSBfY29udGFpbmVySW5zdGFuY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZERpYWxvZ1JlZihfb3ZlcmxheVJlZiwgX2NvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBfb3ZlcmxheVJlZjtcbiAgICAgICAgdGhpcy5fY29udGFpbmVySW5zdGFuY2UgPSBfY29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhlIHVzZXIgdGhhdCB0aGUgZGlhbG9nIGhhcyBmaW5pc2hlZCBjbG9zaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICBfY29udGFpbmVySW5zdGFuY2UuX29uQW5pbWF0aW9uU3RhdGVDaGFuZ2VcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC50b1N0YXRlID09PSAnZXhpdCc7IH0pXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfSwgbnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2FmdGVyQ2xvc2VkLm5leHQoX3RoaXMuX3Jlc3VsdCk7XG4gICAgICAgICAgICBfdGhpcy5fYWZ0ZXJDbG9zZWQuY29tcGxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIHs/PX0gZGlhbG9nUmVzdWx0IE9wdGlvbmFsIHJlc3VsdCB0byByZXR1cm4gdG8gdGhlIGRpYWxvZyBvcGVuZXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERpYWxvZ1JlZi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZGlhbG9nUmVzdWx0KSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdCA9IGRpYWxvZ1Jlc3VsdDtcbiAgICAgICAgdGhpcy5fY29udGFpbmVySW5zdGFuY2UuX3N0YXRlID0gJ2V4aXQnO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaEJhY2tkcm9wKCk7IC8vIFRyYW5zaXRpb24gdGhlIGJhY2tkcm9wIGluIHBhcmFsbGVsIHdpdGggdGhlIGRpYWxvZy5cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gb2JzZXJ2YWJsZSB0aGF0IGlzIG5vdGlmaWVkIHdoZW4gdGhlIGRpYWxvZyBpcyBmaW5pc2hlZCBjbG9zaW5nLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2dSZWYucHJvdG90eXBlLmFmdGVyQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWZ0ZXJDbG9zZWQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBkaWFsb2cncyBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gez89fSBwb3NpdGlvbiBOZXcgZGlhbG9nIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2dSZWYucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0cmF0ZWd5ID0gdGhpcy5fZ2V0UG9zaXRpb25TdHJhdGVneSgpO1xuICAgICAgICBpZiAocG9zaXRpb24gJiYgKHBvc2l0aW9uLmxlZnQgfHwgcG9zaXRpb24ucmlnaHQpKSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5sZWZ0ID8gc3RyYXRlZ3kubGVmdChwb3NpdGlvbi5sZWZ0KSA6IHN0cmF0ZWd5LnJpZ2h0KHBvc2l0aW9uLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmF0ZWd5LmNlbnRlckhvcml6b250YWxseSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiAmJiAocG9zaXRpb24udG9wIHx8IHBvc2l0aW9uLmJvdHRvbSkpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnRvcCA/IHN0cmF0ZWd5LnRvcChwb3NpdGlvbi50b3ApIDogc3RyYXRlZ3kuYm90dG9tKHBvc2l0aW9uLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJhdGVneS5jZW50ZXJWZXJ0aWNhbGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGRpYWxvZydzIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICogQHBhcmFtIHs/PX0gd2lkdGggTmV3IHdpZHRoIG9mIHRoZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIHs/PX0gaGVpZ2h0IE5ldyBoZWlnaHQgb2YgdGhlIGRpYWxvZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGlhbG9nUmVmLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHsgd2lkdGggPSAnYXV0byc7IH1cbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdm9pZCAwKSB7IGhlaWdodCA9ICdhdXRvJzsgfVxuICAgICAgICB0aGlzLl9nZXRQb3NpdGlvblN0cmF0ZWd5KCkud2lkdGgod2lkdGgpLmhlaWdodChoZWlnaHQpO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgb2JqZWN0IGZyb20gdGhlIG92ZXJsYXkgcmVmLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2dSZWYucHJvdG90eXBlLl9nZXRQb3NpdGlvblN0cmF0ZWd5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX292ZXJsYXlSZWYuZ2V0U3RhdGUoKS5wb3NpdGlvblN0cmF0ZWd5KTtcbiAgICB9O1xuICAgIHJldHVybiBNZERpYWxvZ1JlZjtcbn0oKSk7XG52YXIgTURfRElBTE9HX0RBVEEgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ01kRGlhbG9nRGF0YScpO1xuLyoqXG4gKiBDdXN0b20gaW5qZWN0b3IgdHlwZSBzcGVjaWZpY2FsbHkgZm9yIGluc3RhbnRpYXRpbmcgY29tcG9uZW50cyB3aXRoIGEgZGlhbG9nLlxuICovXG52YXIgRGlhbG9nSW5qZWN0b3IgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9wYXJlbnRJbmplY3RvclxuICAgICAqIEBwYXJhbSB7P30gX2RpYWxvZ1JlZlxuICAgICAqIEBwYXJhbSB7P30gX2RhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaWFsb2dJbmplY3RvcihfcGFyZW50SW5qZWN0b3IsIF9kaWFsb2dSZWYsIF9kYXRhKSB7XG4gICAgICAgIHRoaXMuX3BhcmVudEluamVjdG9yID0gX3BhcmVudEluamVjdG9yO1xuICAgICAgICB0aGlzLl9kaWFsb2dSZWYgPSBfZGlhbG9nUmVmO1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez89fSBub3RGb3VuZFZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaWFsb2dJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gTWREaWFsb2dSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWFsb2dSZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuID09PSBNRF9ESUFMT0dfREFUQSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudEluamVjdG9yLmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlhbG9nSW5qZWN0b3I7XG59KCkpO1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBvcGVuaW5nIGEgbW9kYWwgZGlhbG9nIHdpdGggdGhlIE1kRGlhbG9nIHNlcnZpY2UuXG4gKi9cbnZhciBNZERpYWxvZ0NvbmZpZyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nQ29uZmlnKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEFSSUEgcm9sZSBvZiB0aGUgZGlhbG9nIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvbGUgPSAnZGlhbG9nJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGRpYWxvZyBoYXMgYSBiYWNrZHJvcC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VzdG9tIGNsYXNzIGZvciB0aGUgYmFja2Ryb3AsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhY2tkcm9wQ2xhc3MgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgY2FuIHVzZSBlc2NhcGUgb3IgY2xpY2tpbmcgb3V0c2lkZSB0byBjbG9zZSBhIG1vZGFsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpZHRoIG9mIHRoZSBkaWFsb2cuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpZHRoID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWlnaHQgb2YgdGhlIGRpYWxvZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIGJlaW5nIGluamVjdGVkIGludG8gdGhlIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiBhZGQgY29uZmlndXJhdGlvbiBmb3IgbGlmZWN5Y2xlIGhvb2tzLCBBUklBIGxhYmVsbGluZy5cbiAgICB9XG4gICAgcmV0dXJuIE1kRGlhbG9nQ29uZmlnO1xufSgpKTtcbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIGNhc2Ugd2hlbiBhIENvbXBvbmVudFBvcnRhbCBpc1xuICogYXR0YWNoZWQgdG8gYSBEb21Qb3J0YWxIb3N0IHdpdGhvdXQgYW4gb3JpZ2luLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0aHJvd01kRGlhbG9nQ29udGVudEFscmVhZHlBdHRhY2hlZEVycm9yKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBhdHRhY2ggZGlhbG9nIGNvbnRlbnQgYWZ0ZXIgY29udGVudCBpcyBhbHJlYWR5IGF0dGFjaGVkJyk7XG59XG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCB0aGF0IHdyYXBzIHVzZXItcHJvdmlkZWQgZGlhbG9nIGNvbnRlbnQuXG4gKiBBbmltYXRpb24gaXMgYmFzZWQgb24gaHR0cHM6Ly9tYXRlcmlhbC5pby9ndWlkZWxpbmVzL21vdGlvbi9jaG9yZW9ncmFwaHkuaHRtbC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWREaWFsb2dDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kRGlhbG9nQ29udGFpbmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c1RyYXBGYWN0b3J5XG4gICAgICogQHBhcmFtIHs/fSBfZG9jdW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZERpYWxvZ0NvbnRhaW5lcihfbmdab25lLCBfZWxlbWVudFJlZiwgX2ZvY3VzVHJhcEZhY3RvcnksIF9kb2N1bWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgX3RoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgX3RoaXMuX2ZvY3VzVHJhcEZhY3RvcnkgPSBfZm9jdXNUcmFwRmFjdG9yeTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBiZWZvcmUgdGhlIGRpYWxvZyB3YXMgb3BlbmVkLiBTYXZlIHRoaXMgdG8gcmVzdG9yZSB1cG9uIGNsb3NlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlRGlhbG9nV2FzT3BlbmVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXRlIG9mIHRoZSBkaWFsb2cgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3N0YXRlID0gJ2VudGVyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uQW5pbWF0aW9uU3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSBDb21wb25lbnRQb3J0YWwgYXMgY29udGVudCB0byB0aGlzIGRpYWxvZyBjb250YWluZXIuXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWQgYXMgdGhlIGRpYWxvZyBjb250ZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2dDb250YWluZXIucHJvdG90eXBlLmF0dGFjaENvbXBvbmVudFBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BvcnRhbEhvc3QuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhyb3dNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NhdmVQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbEhvc3QuYXR0YWNoQ29tcG9uZW50UG9ydGFsKHBvcnRhbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSBUZW1wbGF0ZVBvcnRhbCBhcyBjb250ZW50IHRvIHRoaXMgZGlhbG9nIGNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0gez99IHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWQgYXMgdGhlIGRpYWxvZyBjb250ZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2dDb250YWluZXIucHJvdG90eXBlLmF0dGFjaFRlbXBsYXRlUG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICBpZiAodGhpcy5fcG9ydGFsSG9zdC5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aHJvd01kRGlhbG9nQ29udGVudEFscmVhZHlBdHRhY2hlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2F2ZVByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsSG9zdC5hdHRhY2hUZW1wbGF0ZVBvcnRhbChwb3J0YWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGZvY3VzIGluc2lkZSB0aGUgZm9jdXMgdHJhcC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZS5fdHJhcEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZvY3VzVHJhcCkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNUcmFwID0gdGhpcy5fZm9jdXNUcmFwRmFjdG9yeS5jcmVhdGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZXJlIHRvIGF0dGVtcHQgdG8gZm9jdXMgaW1tZWRpYXRlbHksIHRoZW4gdGhlIGNvbnRlbnQgb2YgdGhlIGRpYWxvZyB3b3VsZCBub3QgeWV0IGJlXG4gICAgICAgIC8vIHJlYWR5IGluIGluc3RhbmNlcyB3aGVyZSBjaGFuZ2UgZGV0ZWN0aW9uIGhhcyB0byBydW4gZmlyc3QuIFRvIGRlYWwgd2l0aCB0aGlzLCB3ZSBzaW1wbHlcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBlbXB0eS5cbiAgICAgICAgdGhpcy5fZm9jdXNUcmFwLmZvY3VzSW5pdGlhbEVsZW1lbnRXaGVuUmVhZHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIGZvY3VzIHRvIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSBkaWFsb2cgb3BlbmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2dDb250YWluZXIucHJvdG90eXBlLl9yZXN0b3JlRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvRm9jdXMgPSB0aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZURpYWxvZ1dhc09wZW5lZDtcbiAgICAgICAgLy8gV2UgbmVlZCB0aGUgZXh0cmEgY2hlY2ssIGJlY2F1c2UgSUUgY2FuIHNldCB0aGUgYGFjdGl2ZUVsZW1lbnRgIHRvIG51bGwgaW4gc29tZSBjYXNlcy5cbiAgICAgICAgaWYgKHRvRm9jdXMgJiYgJ2ZvY3VzJyBpbiB0b0ZvY3VzKSB7XG4gICAgICAgICAgICB0b0ZvY3VzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzVHJhcCkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNUcmFwLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2F2ZXMgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBiZWZvcmUgdGhlIGRpYWxvZyB3YXMgb3BlbmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2dDb250YWluZXIucHJvdG90eXBlLl9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlRGlhbG9nV2FzT3BlbmVkID0gKHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjaywgaW52b2tlZCB3aGVuZXZlciBhbiBhbmltYXRpb24gb24gdGhlIGhvc3QgY29tcGxldGVzLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZS5fb25BbmltYXRpb25Eb25lID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX29uQW5pbWF0aW9uU3RhdGVDaGFuZ2UuZW1pdChldmVudCk7XG4gICAgICAgIGlmIChldmVudC50b1N0YXRlID09PSAnZW50ZXInKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFwRm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC50b1N0YXRlID09PSAnZXhpdCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVGb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5fb25BbmltYXRpb25TdGF0ZUNoYW5nZS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWREaWFsb2dDb250YWluZXI7XG59KEJhc2VQb3J0YWxIb3N0KSk7XG5NZERpYWxvZ0NvbnRhaW5lci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLWRpYWxvZy1jb250YWluZXIsIG1hdC1kaWFsb2ctY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctdGVtcGxhdGUgY2RrUG9ydGFsSG9zdD48L25nLXRlbXBsYXRlPiBcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtZGlhbG9nLWNvbnRhaW5lcntib3gtc2hhZG93OjAgMTFweCAxNXB4IC03cHggcmdiYSgwLDAsMCwuMiksMCAyNHB4IDM4cHggM3B4IHJnYmEoMCwwLDAsLjE0KSwwIDlweCA0NnB4IDhweCByZ2JhKDAsMCwwLC4xMik7ZGlzcGxheTpibG9jaztwYWRkaW5nOjI0cHg7Ym9yZGVyLXJhZGl1czoycHg7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OmF1dG87bWF4LXdpZHRoOjgwdnc7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LWRpYWxvZy1jb250YWluZXJ7b3V0bGluZTpzb2xpZCAxcHh9fS5tYXQtZGlhbG9nLWNvbnRlbnR7ZGlzcGxheTpibG9jazttYXJnaW46MCAtMjRweDtwYWRkaW5nOjAgMjRweDttYXgtaGVpZ2h0OjY1dmg7b3ZlcmZsb3c6YXV0bzstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaH0ubWF0LWRpYWxvZy10aXRsZXtmb250LXNpemU6MjBweDtmb250LXdlaWdodDo3MDA7bWFyZ2luOjAgMCAyMHB4O2Rpc3BsYXk6YmxvY2t9Lm1hdC1kaWFsb2ctYWN0aW9uc3twYWRkaW5nOjEycHggMDtkaXNwbGF5OmZsZXh9Lm1hdC1kaWFsb2ctYWN0aW9uczpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206LTI0cHh9Lm1hdC1kaWFsb2ctYWN0aW9uc1thbGlnbj1lbmRde2p1c3RpZnktY29udGVudDpmbGV4LWVuZH0ubWF0LWRpYWxvZy1hY3Rpb25zW2FsaWduPWNlbnRlcl17anVzdGlmeS1jb250ZW50OmNlbnRlcn0gLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGlhbG9nLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdzbGlkZURpYWxvZycsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCd2b2lkJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAyNSUsIDApIHNjYWxlKDAuOSknLCBvcGFjaXR5OiAwIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdlbnRlcicsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCkgc2NhbGUoMSknLCBvcGFjaXR5OiAxIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdleGl0Jywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAyNSUsIDApJywgb3BhY2l0eTogMCB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IConLCBhbmltYXRlKCc0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKScpKSxcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZGlhbG9nLWNvbnRhaW5lcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5yb2xlXSc6ICdkaWFsb2dDb25maWc/LnJvbGUnLFxuICAgICAgICAgICAgICAgICAgICAnW0BzbGlkZURpYWxvZ10nOiAnX3N0YXRlJyxcbiAgICAgICAgICAgICAgICAgICAgJyhAc2xpZGVEaWFsb2cuZG9uZSknOiAnX29uQW5pbWF0aW9uRG9uZSgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERpYWxvZ0NvbnRhaW5lci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c1RyYXBGYWN0b3J5LCB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0RPQ1VNRU5ULF0gfSxdIH0sXG5dOyB9O1xuTWREaWFsb2dDb250YWluZXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ19wb3J0YWxIb3N0JzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbUG9ydGFsSG9zdERpcmVjdGl2ZSxdIH0sXSxcbn07XG4vKipcbiAqIFNlcnZpY2UgdG8gb3BlbiBNYXRlcmlhbCBEZXNpZ24gbW9kYWwgZGlhbG9ncy5cbiAqL1xudmFyIE1kRGlhbG9nID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfb3ZlcmxheVxuICAgICAqIEBwYXJhbSB7P30gX2luamVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBfdmlld3BvcnRSdWxlclxuICAgICAqIEBwYXJhbSB7P30gX2xvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/fSBfcGFyZW50RGlhbG9nXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWREaWFsb2coX292ZXJsYXksIF9pbmplY3RvciwgX3ZpZXdwb3J0UnVsZXIsIF9sb2NhdGlvbiwgX3BhcmVudERpYWxvZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gX292ZXJsYXk7XG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICB0aGlzLl92aWV3cG9ydFJ1bGVyID0gX3ZpZXdwb3J0UnVsZXI7XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gX2xvY2F0aW9uO1xuICAgICAgICB0aGlzLl9wYXJlbnREaWFsb2cgPSBfcGFyZW50RGlhbG9nO1xuICAgICAgICB0aGlzLl9vcGVuRGlhbG9nc0F0VGhpc0xldmVsID0gW107XG4gICAgICAgIHRoaXMuX2FmdGVyQWxsQ2xvc2VkQXRUaGlzTGV2ZWwgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl9hZnRlck9wZW5BdFRoaXNMZXZlbCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX2JvdW5kS2V5ZG93biA9IHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYW4gb2JzZXJ2YWJsZSB0aGF0IGlzIG5vdGlmaWVkIHdoZW4gYSBkaWFsb2cgaGFzIGJlZW4gb3BlbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZnRlck9wZW4gPSB0aGlzLl9hZnRlck9wZW4uYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGFuIG9ic2VydmFibGUgdGhhdCBpcyBub3RpZmllZCB3aGVuIGFsbCBvcGVuIGRpYWxvZyBoYXZlIGZpbmlzaGVkIGNsb3NpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFmdGVyQWxsQ2xvc2VkID0gdGhpcy5fYWZ0ZXJBbGxDbG9zZWQuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIC8vIENsb3NlIGFsbCBvZiB0aGUgZGlhbG9ncyB3aGVuIHRoZSB1c2VyIGdvZXMgZm9yd2FyZHMvYmFja3dhcmRzIGluIGhpc3Rvcnkgb3Igd2hlbiB0aGVcbiAgICAgICAgLy8gbG9jYXRpb24gaGFzaCBjaGFuZ2VzLiBOb3RlIHRoYXQgdGhpcyB1c3VhbGx5IGRvZXNuJ3QgaW5jbHVkZSBjbGlja2luZyBvbiBsaW5rcyAodW5sZXNzXG4gICAgICAgIC8vIHRoZSB1c2VyIGlzIHVzaW5nIHRoZSBgSGFzaExvY2F0aW9uU3RyYXRlZ3lgKS5cbiAgICAgICAgaWYgKCFfcGFyZW50RGlhbG9nICYmIF9sb2NhdGlvbikge1xuICAgICAgICAgICAgX2xvY2F0aW9uLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jbG9zZUFsbCgpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREaWFsb2cucHJvdG90eXBlLCBcIl9vcGVuRGlhbG9nc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudGx5LW9wZW4gZGlhbG9ncy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudERpYWxvZyA/IHRoaXMuX3BhcmVudERpYWxvZy5fb3BlbkRpYWxvZ3MgOiB0aGlzLl9vcGVuRGlhbG9nc0F0VGhpc0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREaWFsb2cucHJvdG90eXBlLCBcIl9hZnRlck9wZW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoZSB1c2VyIHRoYXQgYSBkaWFsb2cgaGFzIG9wZW5lZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudERpYWxvZyA/IHRoaXMuX3BhcmVudERpYWxvZy5fYWZ0ZXJPcGVuIDogdGhpcy5fYWZ0ZXJPcGVuQXRUaGlzTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERpYWxvZy5wcm90b3R5cGUsIFwiX2FmdGVyQWxsQ2xvc2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGUgdXNlciB0aGF0IGFsbCBvcGVuIGRpYWxvZ3MgaGF2ZSBmaW5pc2hlZCBjbG9zaW5nLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50RGlhbG9nID9cbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnREaWFsb2cuX2FmdGVyQWxsQ2xvc2VkIDogdGhpcy5fYWZ0ZXJBbGxDbG9zZWRBdFRoaXNMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBtb2RhbCBkaWFsb2cgY29udGFpbmluZyB0aGUgZ2l2ZW4gY29tcG9uZW50LlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRPclRlbXBsYXRlUmVmIFR5cGUgb2YgdGhlIGNvbXBvbmVudCB0byBsb2FkIGludG8gdGhlIGRpYWxvZyxcbiAgICAgKiAgICAgb3IgYSBUZW1wbGF0ZVJlZiB0byBpbnN0YW50aWF0ZSBhcyB0aGUgZGlhbG9nIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHs/PX0gY29uZmlnIEV4dHJhIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHs/fSBSZWZlcmVuY2UgdG8gdGhlIG5ld2x5LW9wZW5lZCBkaWFsb2cuXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoY29tcG9uZW50T3JUZW1wbGF0ZVJlZiwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbmZpZyA9IF9hcHBseUNvbmZpZ0RlZmF1bHRzJDEoY29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3ZlcmxheVJlZiA9IHRoaXMuX2NyZWF0ZU92ZXJsYXkoY29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlhbG9nQ29udGFpbmVyID0gdGhpcy5fYXR0YWNoRGlhbG9nQ29udGFpbmVyKG92ZXJsYXlSZWYsIGNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpYWxvZ1JlZiA9IHRoaXMuX2F0dGFjaERpYWxvZ0NvbnRlbnQoY29tcG9uZW50T3JUZW1wbGF0ZVJlZiwgZGlhbG9nQ29udGFpbmVyLCBvdmVybGF5UmVmLCBjb25maWcpO1xuICAgICAgICBpZiAoIXRoaXMuX29wZW5EaWFsb2dzLmxlbmd0aCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kS2V5ZG93bik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3BlbkRpYWxvZ3MucHVzaChkaWFsb2dSZWYpO1xuICAgICAgICBkaWFsb2dSZWYuYWZ0ZXJDbG9zZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3JlbW92ZU9wZW5EaWFsb2coZGlhbG9nUmVmKTsgfSk7XG4gICAgICAgIHRoaXMuX2FmdGVyT3Blbi5uZXh0KGRpYWxvZ1JlZik7XG4gICAgICAgIHJldHVybiBkaWFsb2dSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIG9mIHRoZSBjdXJyZW50bHktb3BlbiBkaWFsb2dzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLmNsb3NlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGhpcy5fb3BlbkRpYWxvZ3MubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAvLyBUaGUgYF9vcGVuRGlhbG9nc2AgcHJvcGVydHkgaXNuJ3QgdXBkYXRlZCBhZnRlciBjbG9zZSB1bnRpbCB0aGUgcnhqcyBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHJ1bnMgb24gdGhlIG5leHQgbWljcm90YXNrLCBpbiBhZGRpdGlvbiB0byBtb2RpZnlpbmcgdGhlIGFycmF5IGFzIHdlJ3JlIGdvaW5nXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGl0LiBXZSBsb29wIHRocm91Z2ggYWxsIG9mIHRoZW0gYW5kIGNhbGwgY2xvc2Ugd2l0aG91dCBhc3N1bWluZyB0aGF0XG4gICAgICAgICAgICAvLyB0aGV5J2xsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdCBpbnN0YW50YW5lb3VzbHkuXG4gICAgICAgICAgICB0aGlzLl9vcGVuRGlhbG9nc1tpXS5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBvdmVybGF5IGludG8gd2hpY2ggdGhlIGRpYWxvZyB3aWxsIGJlIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gez99IGNvbmZpZyBUaGUgZGlhbG9nIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybiB7P30gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgT3ZlcmxheVJlZiBmb3IgdGhlIGNyZWF0ZWQgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXkgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlTdGF0ZSA9IHRoaXMuX2dldE92ZXJsYXlTdGF0ZShjb25maWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheVN0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb3ZlcmxheSBzdGF0ZSBmcm9tIGEgZGlhbG9nIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0gez99IGRpYWxvZ0NvbmZpZyBUaGUgZGlhbG9nIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybiB7P30gVGhlIG92ZXJsYXkgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2dldE92ZXJsYXlTdGF0ZSA9IGZ1bmN0aW9uIChkaWFsb2dDb25maWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3ZlcmxheVN0YXRlID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSBkaWFsb2dDb25maWcuaGFzQmFja2Ryb3A7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5zY3JvbGxTdHJhdGVneSA9IG5ldyBCbG9ja1Njcm9sbFN0cmF0ZWd5KHRoaXMuX3ZpZXdwb3J0UnVsZXIpO1xuICAgICAgICBpZiAoZGlhbG9nQ29uZmlnLmJhY2tkcm9wQ2xhc3MpIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGF0ZS5iYWNrZHJvcENsYXNzID0gZGlhbG9nQ29uZmlnLmJhY2tkcm9wQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgb3ZlcmxheVN0YXRlLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuZ2xvYmFsKCk7XG4gICAgICAgIHJldHVybiBvdmVybGF5U3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBhbiBNZERpYWxvZ0NvbnRhaW5lciB0byBhIGRpYWxvZydzIGFscmVhZHktY3JlYXRlZCBvdmVybGF5LlxuICAgICAqIEBwYXJhbSB7P30gb3ZlcmxheSBSZWZlcmVuY2UgdG8gdGhlIGRpYWxvZydzIHVuZGVybHlpbmcgb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gez99IGNvbmZpZyBUaGUgZGlhbG9nIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybiB7P30gQSBwcm9taXNlIHJlc29sdmluZyB0byBhIENvbXBvbmVudFJlZiBmb3IgdGhlIGF0dGFjaGVkIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2F0dGFjaERpYWxvZ0NvbnRhaW5lciA9IGZ1bmN0aW9uIChvdmVybGF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0NvbnRhaW5lciA9IGNvbmZpZyA/IGNvbmZpZy52aWV3Q29udGFpbmVyUmVmIDogbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbmVyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChNZERpYWxvZ0NvbnRhaW5lciwgdmlld0NvbnRhaW5lcik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lclJlZiA9IG92ZXJsYXkuYXR0YWNoKGNvbnRhaW5lclBvcnRhbCk7XG4gICAgICAgIGNvbnRhaW5lclJlZi5pbnN0YW5jZS5kaWFsb2dDb25maWcgPSBjb25maWc7XG4gICAgICAgIHJldHVybiBjb250YWluZXJSZWYuaW5zdGFuY2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgdXNlci1wcm92aWRlZCBjb21wb25lbnQgdG8gdGhlIGFscmVhZHktY3JlYXRlZCBNZERpYWxvZ0NvbnRhaW5lci5cbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50T3JUZW1wbGF0ZVJlZiBUaGUgdHlwZSBvZiBjb21wb25lbnQgYmVpbmcgbG9hZGVkIGludG8gdGhlIGRpYWxvZyxcbiAgICAgKiAgICAgb3IgYSBUZW1wbGF0ZVJlZiB0byBpbnN0YW50aWF0ZSBhcyB0aGUgY29udGVudC5cbiAgICAgKiBAcGFyYW0gez99IGRpYWxvZ0NvbnRhaW5lciBSZWZlcmVuY2UgdG8gdGhlIHdyYXBwaW5nIE1kRGlhbG9nQ29udGFpbmVyLlxuICAgICAqIEBwYXJhbSB7P30gb3ZlcmxheVJlZiBSZWZlcmVuY2UgdG8gdGhlIG92ZXJsYXkgaW4gd2hpY2ggdGhlIGRpYWxvZyByZXNpZGVzLlxuICAgICAqIEBwYXJhbSB7P30gY29uZmlnIFRoZSBkaWFsb2cgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBNZERpYWxvZ1JlZiB0aGF0IHNob3VsZCBiZSByZXR1cm5lZCB0byB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2F0dGFjaERpYWxvZ0NvbnRlbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50T3JUZW1wbGF0ZVJlZiwgZGlhbG9nQ29udGFpbmVyLCBvdmVybGF5UmVmLCBjb25maWcpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcmVmZXJlbmNlIHRvIHRoZSBkaWFsb2cgd2UncmUgY3JlYXRpbmcgaW4gb3JkZXIgdG8gZ2l2ZSB0aGUgdXNlciBhIGhhbmRsZVxuICAgICAgICAvLyB0byBtb2RpZnkgYW5kIGNsb3NlIGl0LlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaWFsb2dSZWYgPSBuZXcgTWREaWFsb2dSZWYob3ZlcmxheVJlZiwgZGlhbG9nQ29udGFpbmVyKTtcbiAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUNsb3NlKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBkaWFsb2cgYmFja2Ryb3AgaXMgY2xpY2tlZCwgd2Ugd2FudCB0byBjbG9zZSBpdC5cbiAgICAgICAgICAgIG92ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpYWxvZ1JlZi5jbG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBjcmVhdGUgYW4gaW5qZWN0b3Igc3BlY2lmaWNhbGx5IGZvciB0aGUgY29tcG9uZW50IHdlJ3JlIGluc3RhbnRpYXRpbmcgc28gdGhhdCBpdCBjYW5cbiAgICAgICAgLy8gaW5qZWN0IHRoZSBNZERpYWxvZ1JlZi4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgbG9hZGVkIGluc2lkZSBvZiBhIGRpYWxvZyB0byBjbG9zZSBpdHNlbGZcbiAgICAgICAgLy8gYW5kLCBvcHRpb25hbGx5LCB0byByZXR1cm4gYSB2YWx1ZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXNlckluamVjdG9yID0gY29uZmlnICYmIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmICYmIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmLmluamVjdG9yO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaWFsb2dJbmplY3RvciA9IG5ldyBEaWFsb2dJbmplY3Rvcih1c2VySW5qZWN0b3IgfHwgdGhpcy5faW5qZWN0b3IsIGRpYWxvZ1JlZiwgY29uZmlnLmRhdGEpO1xuICAgICAgICBpZiAoY29tcG9uZW50T3JUZW1wbGF0ZVJlZiBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICBkaWFsb2dDb250YWluZXIuYXR0YWNoVGVtcGxhdGVQb3J0YWwobmV3IFRlbXBsYXRlUG9ydGFsKGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnRSZWYgPSBkaWFsb2dDb250YWluZXIuYXR0YWNoQ29tcG9uZW50UG9ydGFsKG5ldyBDb21wb25lbnRQb3J0YWwoY29tcG9uZW50T3JUZW1wbGF0ZVJlZiwgbnVsbCwgZGlhbG9nSW5qZWN0b3IpKTtcbiAgICAgICAgICAgIGRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZSA9IGNvbnRlbnRSZWYuaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZGlhbG9nUmVmXG4gICAgICAgICAgICAudXBkYXRlU2l6ZShjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQpXG4gICAgICAgICAgICAudXBkYXRlUG9zaXRpb24oY29uZmlnLnBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIGRpYWxvZ1JlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkaWFsb2cgZnJvbSB0aGUgYXJyYXkgb2Ygb3BlbiBkaWFsb2dzLlxuICAgICAqIEBwYXJhbSB7P30gZGlhbG9nUmVmIERpYWxvZyB0byBiZSByZW1vdmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9yZW1vdmVPcGVuRGlhbG9nID0gZnVuY3Rpb24gKGRpYWxvZ1JlZikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHRoaXMuX29wZW5EaWFsb2dzLmluZGV4T2YoZGlhbG9nUmVmKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX29wZW5EaWFsb2dzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAvLyBubyBvcGVuIGRpYWxvZ3MgYXJlIGxlZnQsIGNhbGwgbmV4dCBvbiBhZnRlckFsbENsb3NlZCBTdWJqZWN0XG4gICAgICAgICAgICBpZiAoIXRoaXMuX29wZW5EaWFsb2dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FmdGVyQWxsQ2xvc2VkLm5leHQoKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRLZXlkb3duKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBnbG9iYWwga2V5IHByZXNzZXMgd2hpbGUgdGhlcmUgYXJlIG9wZW4gZGlhbG9ncy4gQ2xvc2VzIHRoZVxuICAgICAqIHRvcCBkaWFsb2cgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGVzY2FwZS5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9wRGlhbG9nID0gdGhpcy5fb3BlbkRpYWxvZ3NbdGhpcy5fb3BlbkRpYWxvZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhbkNsb3NlID0gdG9wRGlhbG9nID8gIXRvcERpYWxvZy5fY29udGFpbmVySW5zdGFuY2UuZGlhbG9nQ29uZmlnLmRpc2FibGVDbG9zZSA6IGZhbHNlO1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFICYmIGNhbkNsb3NlKSB7XG4gICAgICAgICAgICB0b3BEaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kRGlhbG9nO1xufSgpKTtcbk1kRGlhbG9nLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERpYWxvZy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE92ZXJsYXksIH0sXG4gICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICB7IHR5cGU6IFZpZXdwb3J0UnVsZXIsIH0sXG4gICAgeyB0eXBlOiBMb2NhdGlvbiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBNZERpYWxvZywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBTa2lwU2VsZiB9LF0gfSxcbl07IH07XG4vKipcbiAqIEFwcGxpZXMgZGVmYXVsdCBvcHRpb25zIHRvIHRoZSBkaWFsb2cgY29uZmlnLlxuICogQHBhcmFtIHs/fSBjb25maWcgQ29uZmlnIHRvIGJlIG1vZGlmaWVkLlxuICogQHJldHVybiB7P30gVGhlIG5ldyBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2FwcGx5Q29uZmlnRGVmYXVsdHMkMShjb25maWcpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JqZWN0KG5ldyBNZERpYWxvZ0NvbmZpZygpLCBjb25maWcpO1xufVxuLyoqXG4gKiBCdXR0b24gdGhhdCB3aWxsIGNsb3NlIHRoZSBjdXJyZW50IGRpYWxvZy5cbiAqL1xudmFyIE1kRGlhbG9nQ2xvc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpYWxvZ1JlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nQ2xvc2UoZGlhbG9nUmVmKSB7XG4gICAgICAgIHRoaXMuZGlhbG9nUmVmID0gZGlhbG9nUmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NyZWVucmVhZGVyIGxhYmVsIGZvciB0aGUgYnV0dG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcmlhTGFiZWwgPSAnQ2xvc2UgZGlhbG9nJztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGlhbG9nQ2xvc2UucHJvdG90eXBlLCBcIl9tYXREaWFsb2dDbG9zZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaWFsb2cgY2xvc2UgaW5wdXQgZm9yIGNvbXBhdGliaWxpdHkgbW9kZS5cbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5kaWFsb2dSZXN1bHQgPSB2YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE1kRGlhbG9nQ2xvc2U7XG59KCkpO1xuTWREaWFsb2dDbG9zZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYnV0dG9uW21kLWRpYWxvZy1jbG9zZV0sIGJ1dHRvblttYXQtZGlhbG9nLWNsb3NlXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdkaWFsb2dSZWYuY2xvc2UoZGlhbG9nUmVzdWx0KScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdhcmlhTGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWREaWFsb2dDbG9zZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE1kRGlhbG9nUmVmLCB9LFxuXTsgfTtcbk1kRGlhbG9nQ2xvc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2FyaWFMYWJlbCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2FyaWEtbGFiZWwnLF0gfSxdLFxuICAgICdkaWFsb2dSZXN1bHQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZC1kaWFsb2ctY2xvc2UnLF0gfSxdLFxuICAgICdfbWF0RGlhbG9nQ2xvc2UnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXQtZGlhbG9nLWNsb3NlJyxdIH0sXSxcbn07XG4vKipcbiAqIFRpdGxlIG9mIGEgZGlhbG9nIGVsZW1lbnQuIFN0YXlzIGZpeGVkIHRvIHRoZSB0b3Agb2YgdGhlIGRpYWxvZyB3aGVuIHNjcm9sbGluZy5cbiAqL1xudmFyIE1kRGlhbG9nVGl0bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ1RpdGxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWREaWFsb2dUaXRsZTtcbn0oKSk7XG5NZERpYWxvZ1RpdGxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtZGlhbG9nLXRpdGxlXSwgW21hdC1kaWFsb2ctdGl0bGVdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWRpYWxvZy10aXRsZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kRGlhbG9nVGl0bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogU2Nyb2xsYWJsZSBjb250ZW50IGNvbnRhaW5lciBvZiBhIGRpYWxvZy5cbiAqL1xudmFyIE1kRGlhbG9nQ29udGVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nQ29udGVudCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kRGlhbG9nQ29udGVudDtcbn0oKSk7XG5NZERpYWxvZ0NvbnRlbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1kaWFsb2ctY29udGVudF0sIG1kLWRpYWxvZy1jb250ZW50LCBbbWF0LWRpYWxvZy1jb250ZW50XSwgbWF0LWRpYWxvZy1jb250ZW50JyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWRpYWxvZy1jb250ZW50XSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWREaWFsb2dDb250ZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIENvbnRhaW5lciBmb3IgdGhlIGJvdHRvbSBhY3Rpb24gYnV0dG9ucyBpbiBhIGRpYWxvZy5cbiAqIFN0YXlzIGZpeGVkIHRvIHRoZSBib3R0b20gd2hlbiBzY3JvbGxpbmcuXG4gKi9cbnZhciBNZERpYWxvZ0FjdGlvbnMgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ0FjdGlvbnMoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZERpYWxvZ0FjdGlvbnM7XG59KCkpO1xuTWREaWFsb2dBY3Rpb25zLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtZGlhbG9nLWFjdGlvbnNdLCBtZC1kaWFsb2ctYWN0aW9ucywgW21hdC1kaWFsb2ctYWN0aW9uc10sIG1hdC1kaWFsb2ctYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1kaWFsb2ctYWN0aW9uc10nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kRGlhbG9nQWN0aW9ucy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIE1kRGlhbG9nTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWREaWFsb2dNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZERpYWxvZ01vZHVsZTtcbn0oKSk7XG5NZERpYWxvZ01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFBvcnRhbE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgQTExeU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBNZERpYWxvZ0Nsb3NlLFxuICAgICAgICAgICAgICAgICAgICBNZERpYWxvZ1RpdGxlLFxuICAgICAgICAgICAgICAgICAgICBNZERpYWxvZ0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWREaWFsb2dDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nQ2xvc2UsXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nVGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgTWREaWFsb2dDb250ZW50LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTWREaWFsb2dDb250YWluZXJdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERpYWxvZ01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEl0IGFsc28gYWRkcyBhY3RpdmUgc3R5bGVzIHRvIHRoZSBuZXdseSBhY3RpdmUgaXRlbSBhbmQgcmVtb3ZlcyBhY3RpdmVcbiAgICAgKiBzdHlsZXMgZnJvbSB0aGUgcHJldmlvdXNseSBhY3RpdmUgaXRlbS5cbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlSXRlbS5zZXRJbmFjdGl2ZVN0eWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXRBY3RpdmVJdGVtLmNhbGwoX3RoaXMsIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlSXRlbS5zZXRBY3RpdmVTdHlsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXI7XG59KExpc3RLZXlNYW5hZ2VyKSk7XG4vKipcbiAqIEF1dG9jb21wbGV0ZSBJRHMgbmVlZCB0byBiZSB1bmlxdWUgYWNyb3NzIGNvbXBvbmVudHMsIHNvIHRoaXMgY291bnRlciBleGlzdHMgb3V0c2lkZSBvZlxuICogdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG52YXIgX3VuaXF1ZUF1dG9jb21wbGV0ZUlkQ291bnRlciA9IDA7XG52YXIgTWRBdXRvY29tcGxldGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jaGFuZ2VEZXRlY3RvclJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kQXV0b2NvbXBsZXRlKF9jaGFuZ2VEZXRlY3RvclJlZikge1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGF1dG9jb21wbGV0ZSBwYW5lbCBkaXNwbGF5cyBhYm92ZSBvciBiZWxvdyBpdHMgdHJpZ2dlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb25ZID0gJ2JlbG93JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGF1dG9jb21wbGV0ZSBwYW5lbCBzaG91bGQgYmUgdmlzaWJsZSwgZGVwZW5kaW5nIG9uIG9wdGlvbiBsZW5ndGguXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dQYW5lbCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5pcXVlIElEIHRvIGJlIHVzZWQgYnkgYXV0b2NvbXBsZXRlIHRyaWdnZXIncyBcImFyaWEtb3duc1wiIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IFwibWQtYXV0b2NvbXBsZXRlLVwiICsgX3VuaXF1ZUF1dG9jb21wbGV0ZUlkQ291bnRlcisrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIgPSBuZXcgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIodGhpcy5vcHRpb25zKS53aXRoV3JhcCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcGFuZWwgc2Nyb2xsVG9wLiBUaGlzIGFsbG93cyB1cyB0byBtYW51YWxseSBzY3JvbGwgdG8gZGlzcGxheVxuICAgICAqIG9wdGlvbnMgYmVsb3cgdGhlIGZvbGQsIGFzIHRoZXkgYXJlIG5vdCBhY3R1YWxseSBiZWluZyBmb2N1c2VkIHdoZW4gYWN0aXZlLlxuICAgICAqIEBwYXJhbSB7P30gc2Nyb2xsVG9wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuX3NldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWwpIHtcbiAgICAgICAgICAgIHRoaXMucGFuZWwubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhbmVsIHNob3VsZCBoaWRlIGl0c2VsZiB3aGVuIHRoZSBvcHRpb24gbGlzdCBpcyBlbXB0eS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5fc2V0VmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zaG93UGFuZWwgPSAhIV90aGlzLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgX3RoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYSBjbGFzcyBvbiB0aGUgcGFuZWwgYmFzZWQgb24gaXRzIHBvc2l0aW9uICh1c2VkIHRvIHNldCB5LW9mZnNldCkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuX2dldENsYXNzTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdtYXQtYXV0b2NvbXBsZXRlLXBhbmVsLWJlbG93JzogdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycsXG4gICAgICAgICAgICAnbWF0LWF1dG9jb21wbGV0ZS1wYW5lbC1hYm92ZSc6IHRoaXMucG9zaXRpb25ZID09PSAnYWJvdmUnLFxuICAgICAgICAgICAgJ21hdC1hdXRvY29tcGxldGUtdmlzaWJsZSc6IHRoaXMuc2hvd1BhbmVsLFxuICAgICAgICAgICAgJ21hdC1hdXRvY29tcGxldGUtaGlkZGVuJzogIXRoaXMuc2hvd1BhbmVsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTWRBdXRvY29tcGxldGU7XG59KCkpO1xuTWRBdXRvY29tcGxldGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1hdXRvY29tcGxldGUsIG1hdC1hdXRvY29tcGxldGUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy10ZW1wbGF0ZT4gPGRpdiBjbGFzcz1cXFwibWF0LWF1dG9jb21wbGV0ZS1wYW5lbFxcXCIgcm9sZT1cXFwibGlzdGJveFxcXCIgW2lkXT1cXFwiaWRcXFwiIFtuZ0NsYXNzXT1cXFwiX2dldENsYXNzTGlzdCgpXFxcIiAjcGFuZWw+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9kaXY+IDwvbmctdGVtcGxhdGU+IFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1hdXRvY29tcGxldGUtcGFuZWx7Ym94LXNoYWRvdzowIDVweCA1cHggLTNweCByZ2JhKDAsMCwwLC4yKSwwIDhweCAxMHB4IDFweCByZ2JhKDAsMCwwLC4xNCksMCAzcHggMTRweCAycHggcmdiYSgwLDAsMCwuMTIpO21pbi13aWR0aDoxMTJweDttYXgtd2lkdGg6MjgwcHg7b3ZlcmZsb3c6YXV0bzstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDt2aXNpYmlsaXR5OmhpZGRlbjttYXgtd2lkdGg6bm9uZTttYXgtaGVpZ2h0OjI1NnB4O3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtYXV0b2NvbXBsZXRlLXBhbmVsLm1hdC1hdXRvY29tcGxldGUtcGFuZWwtYmVsb3d7dG9wOjZweH0ubWF0LWF1dG9jb21wbGV0ZS1wYW5lbC5tYXQtYXV0b2NvbXBsZXRlLXBhbmVsLWFib3Zle3RvcDotMjRweH0ubWF0LWF1dG9jb21wbGV0ZS1wYW5lbC5tYXQtYXV0b2NvbXBsZXRlLXZpc2libGV7dmlzaWJpbGl0eTp2aXNpYmxlfS5tYXQtYXV0b2NvbXBsZXRlLXBhbmVsLm1hdC1hdXRvY29tcGxldGUtaGlkZGVue3Zpc2liaWxpdHk6aGlkZGVufSAvKiMgc291cmNlTWFwcGluZ1VSTD1hdXRvY29tcGxldGUuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21kQXV0b2NvbXBsZXRlJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWF1dG9jb21wbGV0ZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQXV0b2NvbXBsZXRlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYsIH0sXG5dOyB9O1xuTWRBdXRvY29tcGxldGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3RlbXBsYXRlJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbVGVtcGxhdGVSZWYsXSB9LF0sXG4gICAgJ3BhbmVsJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3BhbmVsJyxdIH0sXSxcbiAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kT3B0aW9uLF0gfSxdLFxuICAgICdkaXNwbGF5V2l0aCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG4vKipcbiAqIFRoZSBoZWlnaHQgb2YgZWFjaCBhdXRvY29tcGxldGUgb3B0aW9uLlxuICovXG52YXIgQVVUT0NPTVBMRVRFX09QVElPTl9IRUlHSFQgPSA0ODtcbi8qKlxuICogVGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsLlxuICovXG52YXIgQVVUT0NPTVBMRVRFX1BBTkVMX0hFSUdIVCA9IDI1Njtcbi8qKlxuICogUHJvdmlkZXIgdGhhdCBhbGxvd3MgdGhlIGF1dG9jb21wbGV0ZSB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNRF9BVVRPQ09NUExFVEVfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRBdXRvY29tcGxldGVUcmlnZ2VyOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBNZEF1dG9jb21wbGV0ZVRyaWdnZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBfb3ZlcmxheVxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdDb250YWluZXJSZWZcbiAgICAgKiBAcGFyYW0gez99IF9jaGFuZ2VEZXRlY3RvclJlZlxuICAgICAqIEBwYXJhbSB7P30gX3Njcm9sbERpc3BhdGNoZXJcbiAgICAgKiBAcGFyYW0gez99IF9kaXJcbiAgICAgKiBAcGFyYW0gez99IF96b25lXG4gICAgICogQHBhcmFtIHs/fSBfaW5wdXRDb250YWluZXJcbiAgICAgKiBAcGFyYW0gez99IF9kb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kQXV0b2NvbXBsZXRlVHJpZ2dlcihfZWxlbWVudCwgX292ZXJsYXksIF92aWV3Q29udGFpbmVyUmVmLCBfY2hhbmdlRGV0ZWN0b3JSZWYsIF9zY3JvbGxEaXNwYXRjaGVyLCBfZGlyLCBfem9uZSwgX2lucHV0Q29udGFpbmVyLCBfZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gX292ZXJsYXk7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYgPSBfY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIHRoaXMuX3Njcm9sbERpc3BhdGNoZXIgPSBfc2Nyb2xsRGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9pbnB1dENvbnRhaW5lciA9IF9pbnB1dENvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHBsYWNlaG9sZGVyIHN0YXRlIGlzIGJlaW5nIG92ZXJyaWRkZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW51YWxseUZsb2F0aW5nUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gdmFsdWUgY2hhbmdlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gYXV0b2NvbXBsZXRlIGhhcyBiZWVuIHRvdWNoZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUsIFwiX21hdEF1dG9jb21wbGV0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0eSB3aXRoIG1hdC0gcHJlZml4IGZvciBuby1jb25mbGljdCBtb2RlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvY29tcGxldGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGF1dG9jb21wbGV0ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYXV0b2NvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZSA9IGF1dG9jb21wbGV0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcGFuZWxQb3NpdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcGFuZWxQb3NpdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lQYW5lbCgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUsIFwicGFuZWxPcGVuXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYW5lbE9wZW4gJiYgdGhpcy5hdXRvY29tcGxldGUuc2hvd1BhbmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb24gcGFuZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLm9wZW5QYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiogVXBkYXRlIHRoZSBwYW5lbCB3aWR0aCwgaW4gY2FzZSB0aGUgaG9zdCB3aWR0aCBoYXMgY2hhbmdlZCAqL1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5nZXRTdGF0ZSgpLndpZHRoID0gdGhpcy5fZ2V0SG9zdFdpZHRoKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5hdHRhY2godGhpcy5fcG9ydGFsKTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvQ2xvc2luZ0FjdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5fc2V0VmlzaWJpbGl0eSgpO1xuICAgICAgICB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyKCk7XG4gICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uIHBhbmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5jbG9zZVBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZiAmJiB0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFuZWxPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jlc2V0UGxhY2Vob2xkZXIoKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gbWFudWFsbHksIGJlY2F1c2VcbiAgICAgICAgLy8gYGZyb21FdmVudGAgZG9lc24ndCBzZWVtIHRvIGRvIGl0IGF0IHRoZSBwcm9wZXIgdGltZS5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHBsYWNlaG9sZGVyIGlzIHJlc2V0IHdoZW4gdGhlXG4gICAgICAgIC8vIHVzZXIgY2xpY2tzIG91dHNpZGUuXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLCBcInBhbmVsQ2xvc2luZ0FjdGlvbnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJlYW0gb2YgYWN0aW9ucyB0aGF0IHNob3VsZCBjbG9zZSB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsLCBpbmNsdWRpbmdcbiAgICAgICAgICogd2hlbiBhbiBvcHRpb24gaXMgc2VsZWN0ZWQsIG9uIGJsdXIsIGFuZCB3aGVuIFRBQiBpcyBwcmVzc2VkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5tZXJnZSh0aGlzLm9wdGlvblNlbGVjdGlvbnMsIHRoaXMuYXV0b2NvbXBsZXRlLl9rZXlNYW5hZ2VyLnRhYk91dCwgdGhpcy5fb3V0c2lkZUNsaWNrU3RyZWFtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUsIFwib3B0aW9uU2VsZWN0aW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJlYW0gb2YgYXV0b2NvbXBsZXRlIG9wdGlvbiBzZWxlY3Rpb25zLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5tZXJnZS5hcHBseShPYnNlcnZhYmxlLCB0aGlzLmF1dG9jb21wbGV0ZS5vcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBvcHRpb24ub25TZWxlY3Rpb25DaGFuZ2U7IH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUsIFwiYWN0aXZlT3B0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIG9wdGlvbiwgY29lcmNlZCB0byBNZE9wdGlvbiB0eXBlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvY29tcGxldGUuX2tleU1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuYXV0b2NvbXBsZXRlLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZSwgXCJfb3V0c2lkZUNsaWNrU3RyZWFtXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmVhbSBvZiBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuZnJvbUV2ZW50KHRoaXMuX2RvY3VtZW50LCAnY2xpY2snKS5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsaWNrVGFyZ2V0ID0gKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0Q29udGFpbmVyID0gX3RoaXMuX2lucHV0Q29udGFpbmVyID9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnB1dENvbnRhaW5lci5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50IDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wYW5lbE9wZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrVGFyZ2V0ICE9PSBfdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWlucHV0Q29udGFpbmVyIHx8ICFpbnB1dENvbnRhaW5lci5jb250YWlucyhjbGlja1RhcmdldCkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhX3RoaXMuX292ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQuY29udGFpbnMoY2xpY2tUYXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhdXRvY29tcGxldGUncyB2YWx1ZS4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlXG4gICAgICogcmVxdWlyZWQgdG8gaW50ZWdyYXRlIHdpdGggQW5ndWxhcidzIGNvcmUgZm9ybXMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZSBOZXcgdmFsdWUgdG8gYmUgd3JpdHRlbiB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NldFRyaWdnZXJWYWx1ZSh2YWx1ZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2F2ZXMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gdGhlIGF1dG9jb21wbGV0ZSdzIHZhbHVlXG4gICAgICogY2hhbmdlcyBmcm9tIHVzZXIgaW5wdXQuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZVxuICAgICAqIHJlcXVpcmVkIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZm4gQ2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBhdXRvY29tcGxldGUgaXMgYmx1cnJlZFxuICAgICAqIGJ5IHRoZSB1c2VyLiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UgcmVxdWlyZWRcbiAgICAgKiB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdG91Y2hlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9oYW5kbGVLZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZU9wdGlvbiAmJiBldmVudC5rZXlDb2RlID09PSBFTlRFUikge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVPcHRpb24uX3NlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldkFjdGl2ZUl0ZW1fMSA9IHRoaXMuYXV0b2NvbXBsZXRlLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0Fycm93S2V5XzEgPSBldmVudC5rZXlDb2RlID09PSBVUF9BUlJPVyB8fCBldmVudC5rZXlDb2RlID09PSBET1dOX0FSUk9XO1xuICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuX2tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChpc0Fycm93S2V5XzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5QYW5lbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyb3dLZXlfMSB8fCBfdGhpcy5hdXRvY29tcGxldGUuX2tleU1hbmFnZXIuYWN0aXZlSXRlbSAhPT0gcHJldkFjdGl2ZUl0ZW1fMSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2Nyb2xsVG9PcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5faGFuZGxlSW5wdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgaW5wdXQgaXMgZm9jdXNlZCwgYmVjYXVzZSBJRSB3aWxsIGZpcmUgdGhlIGBpbnB1dGBcbiAgICAgICAgLy8gZXZlbnQgb24gZm9jdXMvYmx1ci9sb2FkIGlmIHRoZSBpbnB1dCBoYXMgYSBwbGFjZWhvbGRlci4gU2VlOlxuICAgICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzg4NTc0Ny9cbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKChldmVudC50YXJnZXQpKS52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9wZW5QYW5lbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbiBcImF1dG9cIiBtb2RlLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBhbmltYXRlIGRvd24gYXMgc29vbiBhcyBmb2N1cyBpcyBsb3N0LlxuICAgICAqIFRoaXMgY2F1c2VzIHRoZSB2YWx1ZSB0byBqdW1wIHdoZW4gc2VsZWN0aW5nIGFuIG9wdGlvbiB3aXRoIHRoZSBtb3VzZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBtYW51YWxseSBmbG9hdHMgdGhlIHBsYWNlaG9sZGVyIHVudGlsIHRoZSBwYW5lbCBjYW4gYmUgY2xvc2VkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fZmxvYXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0Q29udGFpbmVyICYmIHRoaXMuX2lucHV0Q29udGFpbmVyLmZsb2F0UGxhY2Vob2xkZXIgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5faW5wdXRDb250YWluZXIuZmxvYXRQbGFjZWhvbGRlciA9ICdhbHdheXMnO1xuICAgICAgICAgICAgdGhpcy5fbWFudWFsbHlGbG9hdGluZ1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHBsYWNlaG9sZGVyIGhhcyBiZWVuIG1hbnVhbGx5IGVsZXZhdGVkLCByZXR1cm4gaXQgdG8gaXRzIG5vcm1hbCBzdGF0ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3Jlc2V0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYW51YWxseUZsb2F0aW5nUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0Q29udGFpbmVyLmZsb2F0UGxhY2Vob2xkZXIgPSAnYXV0byc7XG4gICAgICAgICAgICB0aGlzLl9tYW51YWxseUZsb2F0aW5nUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhhdCB3ZSBhcmUgbm90IGFjdHVhbGx5IGZvY3VzaW5nIGFjdGl2ZSBvcHRpb25zLCB3ZSBtdXN0IG1hbnVhbGx5IGFkanVzdCBzY3JvbGxcbiAgICAgKiB0byByZXZlYWwgb3B0aW9ucyBiZWxvdyB0aGUgZm9sZC4gRmlyc3QsIHdlIGZpbmQgdGhlIG9mZnNldCBvZiB0aGUgb3B0aW9uIGZyb20gdGhlIHRvcFxuICAgICAqIG9mIHRoZSBwYW5lbC4gVGhlIG5ldyBzY3JvbGxUb3Agd2lsbCBiZSB0aGF0IG9mZnNldCAtIHRoZSBwYW5lbCBoZWlnaHQgKyB0aGUgb3B0aW9uXG4gICAgICogaGVpZ2h0LCBzbyB0aGUgYWN0aXZlIG9wdGlvbiB3aWxsIGJlIGp1c3QgdmlzaWJsZSBhdCB0aGUgYm90dG9tIG9mIHRoZSBwYW5lbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3Njcm9sbFRvT3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25PZmZzZXQgPSB0aGlzLmF1dG9jb21wbGV0ZS5fa2V5TWFuYWdlci5hY3RpdmVJdGVtSW5kZXggKiBBVVRPQ09NUExFVEVfT1BUSU9OX0hFSUdIVDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3U2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgb3B0aW9uT2Zmc2V0IC0gQVVUT0NPTVBMRVRFX1BBTkVMX0hFSUdIVCArIEFVVE9DT01QTEVURV9PUFRJT05fSEVJR0hUKTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuX3NldFNjcm9sbFRvcChuZXdTY3JvbGxUb3ApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbGlzdGVucyB0byBhIHN0cmVhbSBvZiBwYW5lbCBjbG9zaW5nIGFjdGlvbnMgYW5kIHJlc2V0cyB0aGVcbiAgICAgKiBzdHJlYW0gZXZlcnkgdGltZSB0aGUgb3B0aW9uIGxpc3QgY2hhbmdlcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3N1YnNjcmliZVRvQ2xvc2luZ0FjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdoZW4gdGhlIHpvbmUgaXMgc3RhYmxlIGluaXRpYWxseSwgYW5kIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGNoYW5nZXMuLi5cbiAgICAgICAgT2JzZXJ2YWJsZS5tZXJnZSh0aGlzLl96b25lLm9uU3RhYmxlLmZpcnN0KCksIHRoaXMuYXV0b2NvbXBsZXRlLm9wdGlvbnMuY2hhbmdlcylcbiAgICAgICAgICAgIC5zd2l0Y2hNYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc2V0UGFuZWwoKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wYW5lbENsb3NpbmdBY3Rpb25zO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpcnN0KClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5fc2V0VmFsdWVBbmRDbG9zZShldmVudCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uIHBhbmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fZGVzdHJveVBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9zZXRUcmlnZ2VyVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9EaXNwbGF5ID0gdGhpcy5hdXRvY29tcGxldGUuZGlzcGxheVdpdGggPyB0aGlzLmF1dG9jb21wbGV0ZS5kaXNwbGF5V2l0aCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LnZhbHVlID0gdG9EaXNwbGF5IHx8ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2xvc2VzIHRoZSBwYW5lbCwgYW5kIGlmIGEgdmFsdWUgaXMgc3BlY2lmaWVkLCBhbHNvIHNldHMgdGhlIGFzc29jaWF0ZWRcbiAgICAgKiBjb250cm9sIHRvIHRoYXQgdmFsdWUuIEl0IHdpbGwgYWxzbyBtYXJrIHRoZSBjb250cm9sIGFzIGRpcnR5IGlmIHRoaXMgaW50ZXJhY3Rpb25cbiAgICAgKiBzdGVtbWVkIGZyb20gdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fc2V0VmFsdWVBbmRDbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclByZXZpb3VzU2VsZWN0ZWRPcHRpb24oZXZlbnQuc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFRyaWdnZXJWYWx1ZShldmVudC5zb3VyY2UudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoZXZlbnQuc291cmNlLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYW55IHByZXZpb3VzIHNlbGVjdGVkIG9wdGlvbiBhbmQgZW1pdCBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgZm9yIHRoaXMgb3B0aW9uXG4gICAgICogQHBhcmFtIHs/fSBza2lwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9jbGVhclByZXZpb3VzU2VsZWN0ZWRPcHRpb24gPSBmdW5jdGlvbiAoc2tpcCkge1xuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbiAhPSBza2lwICYmIG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5kZXNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuYXV0b2NvbXBsZXRlLnRlbXBsYXRlLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKHRoaXMuX2dldE92ZXJsYXlDb25maWcoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2dldE92ZXJsYXlDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlTdGF0ZSA9IG5ldyBPdmVybGF5U3RhdGUoKTtcbiAgICAgICAgb3ZlcmxheVN0YXRlLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9nZXRPdmVybGF5UG9zaXRpb24oKTtcbiAgICAgICAgb3ZlcmxheVN0YXRlLndpZHRoID0gdGhpcy5fZ2V0SG9zdFdpZHRoKCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5kaXJlY3Rpb24gPSB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICAgICAgb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5ID0gbmV3IFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneSh0aGlzLl9zY3JvbGxEaXNwYXRjaGVyKTtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlTdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fZ2V0T3ZlcmxheVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpLmNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnQsIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ2JvdHRvbScgfSwgeyBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnIH0pXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oeyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAndG9wJyB9LCB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2JvdHRvbScgfSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25TdHJhdGVneTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHN1YnNjcmliZXMgdG8gcG9zaXRpb24gY2hhbmdlcyBpbiB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsLCBzbyB0aGUgcGFuZWwnc1xuICAgICAqIHktb2Zmc2V0IGNhbiBiZSBhZGp1c3RlZCB0byBtYXRjaCB0aGUgbmV3IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gc3RyYXRlZ3lcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzID0gZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3BhbmVsUG9zaXRpb25TdWJzY3JpcHRpb24gPSBzdHJhdGVneS5vblBvc2l0aW9uQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICBfdGhpcy5hdXRvY29tcGxldGUucG9zaXRpb25ZID0gY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm9yaWdpblkgPT09ICd0b3AnID8gJ2Fib3ZlJyA6ICdiZWxvdyc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGlucHV0IGVsZW1lbnQsIHNvIHRoZSBwYW5lbCB3aWR0aCBjYW4gbWF0Y2ggaXQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9nZXRIb3N0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCBhY3RpdmUgaXRlbSB0byBudWxsIHNvIGFycm93IGV2ZW50cyB3aWxsIGFjdGl2YXRlIHRoZSBjb3JyZWN0IG9wdGlvbnMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9yZXNldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0obnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGFjdGl2ZSBpdGVtIGFuZCByZS1jYWxjdWxhdGVzIGFsaWdubWVudCBvZiB0aGUgcGFuZWwgaW4gY2FzZSBpdHMgc2l6ZVxuICAgICAqIGhhcyBjaGFuZ2VkIGR1ZSB0byBmZXdlciBvciBncmVhdGVyIG51bWJlciBvZiBvcHRpb25zLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fcmVzZXRQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRBY3RpdmVJdGVtKCk7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kucmVjYWxjdWxhdGVMYXN0UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuX3NldFZpc2liaWxpdHkoKTtcbiAgICB9O1xuICAgIHJldHVybiBNZEF1dG9jb21wbGV0ZVRyaWdnZXI7XG59KCkpO1xuTWRBdXRvY29tcGxldGVUcmlnZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFttZEF1dG9jb21wbGV0ZV0sIGlucHV0W21hdEF1dG9jb21wbGV0ZV0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnY29tYm9ib3gnLFxuICAgICAgICAgICAgICAgICAgICAnYXV0b2NvbXBsZXRlJzogJ29mZicsXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6ICdsaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtbXVsdGlsaW5lJzogJ2ZhbHNlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtYWN0aXZlZGVzY2VuZGFudF0nOiAnYWN0aXZlT3B0aW9uPy5pZCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdwYW5lbE9wZW4udG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLW93bnNdJzogJ2F1dG9jb21wbGV0ZT8uaWQnLFxuICAgICAgICAgICAgICAgICAgICAnKGZvY3VzKSc6ICdvcGVuUGFuZWwoKScsXG4gICAgICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ19oYW5kbGVJbnB1dCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdfb25Ub3VjaGVkKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfQVVUT0NPTVBMRVRFX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEF1dG9jb21wbGV0ZVRyaWdnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogT3ZlcmxheSwgfSxcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICB7IHR5cGU6IFNjcm9sbERpc3BhdGNoZXIsIH0sXG4gICAgeyB0eXBlOiBEaXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogTWRJbnB1dENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBIb3N0IH0sXSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0RPQ1VNRU5ULF0gfSxdIH0sXG5dOyB9O1xuTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdhdXRvY29tcGxldGUnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZEF1dG9jb21wbGV0ZScsXSB9LF0sXG4gICAgJ19tYXRBdXRvY29tcGxldGUnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXRBdXRvY29tcGxldGUnLF0gfSxdLFxufTtcbnZhciBNZEF1dG9jb21wbGV0ZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQXV0b2NvbXBsZXRlTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRBdXRvY29tcGxldGVNb2R1bGU7XG59KCkpO1xuTWRBdXRvY29tcGxldGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNZE9wdGlvbk1vZHVsZSwgT3ZlcmxheU1vZHVsZSwgTWRDb21tb25Nb2R1bGUsIENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kQXV0b2NvbXBsZXRlLCBNZE9wdGlvbk1vZHVsZSwgTWRBdXRvY29tcGxldGVUcmlnZ2VyLCBNZENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRBdXRvY29tcGxldGUsIE1kQXV0b2NvbXBsZXRlVHJpZ2dlcl0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQXV0b2NvbXBsZXRlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEFuIGludGVybmFsIGNsYXNzIHRoYXQgcmVwcmVzZW50cyB0aGUgZGF0YSBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIGNhbGVuZGFyIGNlbGwuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2FsZW5kYXJDZWxsID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gZGlzcGxheVZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBhcmlhTGFiZWxcbiAgICAgKiBAcGFyYW0gez99IGVuYWJsZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZENhbGVuZGFyQ2VsbCh2YWx1ZSwgZGlzcGxheVZhbHVlLCBhcmlhTGFiZWwsIGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgdGhpcy5hcmlhTGFiZWwgPSBhcmlhTGFiZWw7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiBNZENhbGVuZGFyQ2VsbDtcbn0oKSk7XG4vKipcbiAqIEFuIGludGVybmFsIGNvbXBvbmVudCB1c2VkIHRvIGRpc3BsYXkgY2FsZW5kYXIgZGF0YSBpbiBhIHRhYmxlLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZENhbGVuZGFyQm9keSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FsZW5kYXJCb2R5KCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSB0YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubnVtQ29scyA9IDc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGFsbG93IHNlbGVjdGlvbiBvZiBkaXNhYmxlZCBjZWxscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsb3dEaXNhYmxlZFNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNlbGwgbnVtYmVyIG9mIHRoZSBhY3RpdmUgY2VsbCBpbiB0aGUgdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZUNlbGwgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgd2hlbiBhIG5ldyB2YWx1ZSBpcyBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjZWxsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENhbGVuZGFyQm9keS5wcm90b3R5cGUuX2NlbGxDbGlja2VkID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGlzYWJsZWRTZWxlY3Rpb24gJiYgIWNlbGwuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZUNoYW5nZS5lbWl0KGNlbGwudmFsdWUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2FsZW5kYXJCb2R5LnByb3RvdHlwZSwgXCJfZmlyc3RSb3dPZmZzZXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBibGFuayBjZWxscyB0byBwdXQgYXQgdGhlIGJlZ2lubmluZyBmb3IgdGhlIGZpcnN0IHJvdy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93cyAmJiB0aGlzLnJvd3MubGVuZ3RoICYmIHRoaXMucm93c1swXS5sZW5ndGggP1xuICAgICAgICAgICAgICAgIHRoaXMubnVtQ29scyAtIHRoaXMucm93c1swXS5sZW5ndGggOiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvd0luZGV4XG4gICAgICogQHBhcmFtIHs/fSBjb2xJbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhckJvZHkucHJvdG90eXBlLl9pc0FjdGl2ZUNlbGwgPSBmdW5jdGlvbiAocm93SW5kZXgsIGNvbEluZGV4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNlbGxOdW1iZXIgPSByb3dJbmRleCAqIHRoaXMubnVtQ29scyArIGNvbEluZGV4O1xuICAgICAgICAvLyBBY2NvdW50IGZvciB0aGUgZmFjdCB0aGF0IHRoZSBmaXJzdCByb3cgbWF5IG5vdCBoYXZlIGFzIG1hbnkgY2VsbHMuXG4gICAgICAgIGlmIChyb3dJbmRleCkge1xuICAgICAgICAgICAgY2VsbE51bWJlciAtPSB0aGlzLl9maXJzdFJvd09mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2VsbE51bWJlciA9PSB0aGlzLmFjdGl2ZUNlbGw7XG4gICAgfTtcbiAgICByZXR1cm4gTWRDYWxlbmRhckJvZHk7XG59KCkpO1xuTWRDYWxlbmRhckJvZHkuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdbbWQtY2FsZW5kYXItYm9keV0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjwhLS0gSWYgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIGluIHRoZSBmaXJzdCByb3csIGNyZWF0ZSBhIHNlcGFyYXRlIGxhYmVsIHJvdy4gV2UgbWFyayB0aGlzIHJvdyBhcyBhcmlhLWhpZGRlbiBiZWNhdXNlIHdlIGRvbid0IHdhbnQgaXQgdG8gYmUgcmVhZCBvdXQgYXMgb25lIG9mIHRoZSB3ZWVrcyBpbiB0aGUgbW9udGguIC0tPiA8dHIgKm5nSWY9XFxcIl9maXJzdFJvd09mZnNldCA8IGxhYmVsTWluUmVxdWlyZWRDZWxsc1xcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiA8dGQgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1ib2R5LWxhYmVsXFxcIiBbYXR0ci5jb2xzcGFuXT1cXFwibnVtQ29sc1xcXCIgPnt7bGFiZWx9fTwvdGQ+IDwvdHI+IDwhLS0gQ3JlYXRlIHRoZSBmaXJzdCByb3cgc2VwYXJhdGVseSBzbyB3ZSBjYW4gaW5jbHVkZSBhIHNwZWNpYWwgc3BhY2VyIGNlbGwuIC0tPiA8dHIgKm5nRm9yPVxcXCJsZXQgcm93IG9mIHJvd3M7IGxldCByb3dJbmRleCA9IGluZGV4XFxcIiByb2xlPVxcXCJyb3dcXFwiPiA8IS0tIFdlIG1hcmsgdGhpcyBjZWxsIGFzIGFyaWEtaGlkZGVuIHNvIGl0IGRvZXNuJ3QgZ2V0IHJlYWQgb3V0IGFzIG9uZSBvZiB0aGUgZGF5cyBpbiB0aGUgd2Vlay4gLS0+IDx0ZCAqbmdJZj1cXFwicm93SW5kZXggPT09IDAgJiYgX2ZpcnN0Um93T2Zmc2V0XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1ib2R5LWxhYmVsXFxcIiBbYXR0ci5jb2xzcGFuXT1cXFwiX2ZpcnN0Um93T2Zmc2V0XFxcIj4ge3tfZmlyc3RSb3dPZmZzZXQgPj0gbGFiZWxNaW5SZXF1aXJlZENlbGxzID8gbGFiZWwgOiAnJ319IDwvdGQ+IDx0ZCAqbmdGb3I9XFxcImxldCBpdGVtIG9mIHJvdzsgbGV0IGNvbEluZGV4ID0gaW5kZXhcXFwiIHJvbGU9XFxcImdyaWRjZWxsXFxcIiBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLWJvZHktY2VsbFxcXCIgW3RhYmluZGV4XT1cXFwiX2lzQWN0aXZlQ2VsbChyb3dJbmRleCwgY29sSW5kZXgpID8gMCA6IC0xXFxcIiBbY2xhc3MubWF0LWNhbGVuZGFyLWJvZHktZGlzYWJsZWRdPVxcXCIhaXRlbS5lbmFibGVkXFxcIiBbY2xhc3MubWF0LWNhbGVuZGFyLWJvZHktYWN0aXZlXT1cXFwiX2lzQWN0aXZlQ2VsbChyb3dJbmRleCwgY29sSW5kZXgpXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiaXRlbS5hcmlhTGFiZWxcXFwiIFthdHRyLmFyaWEtZGlzYWJsZWRdPVxcXCIhaXRlbS5lbmFibGVkIHx8IG51bGxcXFwiIChjbGljayk9XFxcIl9jZWxsQ2xpY2tlZChpdGVtKVxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1ib2R5LWNlbGwtY29udGVudFxcXCIgW2NsYXNzLm1hdC1jYWxlbmRhci1ib2R5LXNlbGVjdGVkXT1cXFwic2VsZWN0ZWRWYWx1ZSA9PT0gaXRlbS52YWx1ZVxcXCIgW2NsYXNzLm1hdC1jYWxlbmRhci1ib2R5LXRvZGF5XT1cXFwidG9kYXlWYWx1ZSA9PT0gaXRlbS52YWx1ZVxcXCI+IHt7aXRlbS5kaXNwbGF5VmFsdWV9fSA8L2Rpdj4gPC90ZD4gPC90cj4gXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWNhbGVuZGFyLWJvZHl7Zm9udC1zaXplOjEzcHg7bWluLXdpZHRoOjIyNHB4fS5tYXQtY2FsZW5kYXItYm9keS1sYWJlbHtwYWRkaW5nOjcuMTQyODYlIDAgNy4xNDI4NiUgNy4xNDI4NiU7aGVpZ2h0OjA7bGluZS1oZWlnaHQ6MDt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNnB4KTt0ZXh0LWFsaWduOmxlZnQ7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6NzAwfS5tYXQtY2FsZW5kYXItYm9keS1jZWxse3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjE0LjI4NTcxJTtoZWlnaHQ6MDtsaW5lLWhlaWdodDowO3BhZGRpbmc6Ny4xNDI4NiUgMDt0ZXh0LWFsaWduOmNlbnRlcjtvdXRsaW5lOjA7Y3Vyc29yOnBvaW50ZXJ9Lm1hdC1jYWxlbmRhci1ib2R5LWRpc2FibGVke2N1cnNvcjpkZWZhdWx0fS5tYXQtY2FsZW5kYXItYm9keS1jZWxsLWNvbnRlbnR7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUlO2xlZnQ6NSU7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDo5MCU7aGVpZ2h0OjkwJTtib3JkZXItd2lkdGg6MXB4O2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItcmFkaXVzOjUwJX1bZGlyPXJ0bF0gLm1hdC1jYWxlbmRhci1ib2R5LWxhYmVse3BhZGRpbmc6MCA3LjE0Mjg2JSAwIDA7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoNnB4KTt0ZXh0LWFsaWduOnJpZ2h0fSAvKiMgc291cmNlTWFwcGluZ1VSTD1jYWxlbmRhci1ib2R5LmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1jYWxlbmRhci1ib2R5JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FsZW5kYXJCb2R5LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG5NZENhbGVuZGFyQm9keS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnbGFiZWwnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3Jvd3MnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3RvZGF5VmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkVmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2xhYmVsTWluUmVxdWlyZWRDZWxscyc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbnVtQ29scyc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnYWxsb3dEaXNhYmxlZFNlbGVjdGlvbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnYWN0aXZlQ2VsbCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc2VsZWN0ZWRWYWx1ZUNoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIk1kRGF0ZXBpY2tlcjogTm8gcHJvdmlkZXIgZm91bmQgZm9yIFwiICsgcHJvdmlkZXIgKyBcIi4gWW91IG11c3QgaW1wb3J0IG9uZSBvZiB0aGUgZm9sbG93aW5nXCIgK1xuICAgICAgICBcIm1vZHVsZXMgYXQgeW91ciBhcHBsaWNhdGlvbiByb290OiBNZE5hdGl2ZURhdGVNb2R1bGUsIG9yIHByb3ZpZGUgYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXCIpO1xufVxudmFyIERBWVNfUEVSX1dFRUsgPSA3O1xuLyoqXG4gKiBBbiBpbnRlcm5hbCBjb21wb25lbnQgdXNlZCB0byBkaXNwbGF5IGEgc2luZ2xlIG1vbnRoIGluIHRoZSBkYXRlcGlja2VyLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZE1vbnRoVmlldyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2RhdGVBZGFwdGVyXG4gICAgICogQHBhcmFtIHs/fSBfZGF0ZUZvcm1hdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZE1vbnRoVmlldyhfZGF0ZUFkYXB0ZXIsIF9kYXRlRm9ybWF0cykge1xuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlciA9IF9kYXRlQWRhcHRlcjtcbiAgICAgICAgdGhpcy5fZGF0ZUZvcm1hdHMgPSBfZGF0ZUZvcm1hdHM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIGEgbmV3IGRhdGUgaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGVBZGFwdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignRGF0ZUFkYXB0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2RhdGVGb3JtYXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignTURfREFURV9GT1JNQVRTJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0Rmlyc3REYXlPZldlZWsoKTtcbiAgICAgICAgdmFyIG5hcnJvd1dlZWtkYXlzID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF5T2ZXZWVrTmFtZXMoJ25hcnJvdycpO1xuICAgICAgICB2YXIgbG9uZ1dlZWtkYXlzID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF5T2ZXZWVrTmFtZXMoJ2xvbmcnKTtcbiAgICAgICAgLy8gUm90YXRlIHRoZSBsYWJlbHMgZm9yIGRheXMgb2YgdGhlIHdlZWsgYmFzZWQgb24gdGhlIGNvbmZpZ3VyZWQgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICB2YXIgd2Vla2RheXMgPSBsb25nV2Vla2RheXMubWFwKGZ1bmN0aW9uIChsb25nLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBsb25nOiBsb25nLCBuYXJyb3c6IG5hcnJvd1dlZWtkYXlzW2ldIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl93ZWVrZGF5cyA9IHdlZWtkYXlzLnNsaWNlKGZpcnN0RGF5T2ZXZWVrKS5jb25jYXQod2Vla2RheXMuc2xpY2UoMCwgZmlyc3REYXlPZldlZWspKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLnRvZGF5KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1vbnRoVmlldy5wcm90b3R5cGUsIFwiYWN0aXZlRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSB0byBkaXNwbGF5IGluIHRoaXMgbW9udGggdmlldyAoZXZlcnl0aGluZyBvdGhlciB0aGFuIHRoZSBtb250aCBhbmQgeWVhciBpcyBpZ25vcmVkKS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWN0aXZlRGF0ZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRBY3RpdmVEYXRlID0gdGhpcy5fYWN0aXZlRGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB2YWx1ZSB8fCB0aGlzLl9kYXRlQWRhcHRlci50b2RheSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNTYW1lTW9udGhBbmRZZWFyKG9sZEFjdGl2ZURhdGUsIHRoaXMuX2FjdGl2ZURhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNb250aFZpZXcucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IHRoaXMuX2dldERhdGVJbkN1cnJlbnRNb250aCh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1vbnRoVmlldy5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYSBuZXcgZGF0ZSBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTW9udGhWaWV3LnByb3RvdHlwZS5fZGF0ZVNlbGVjdGVkID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkRGF0ZSA9PSBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLmFjdGl2ZURhdGUpLCB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aCh0aGlzLmFjdGl2ZURhdGUpLCBkYXRlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGlzIG1vbnRoIHZpZXcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1vbnRoVmlldy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IHRoaXMuX2dldERhdGVJbkN1cnJlbnRNb250aCh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5fdG9kYXlEYXRlID0gdGhpcy5fZ2V0RGF0ZUluQ3VycmVudE1vbnRoKHRoaXMuX2RhdGVBZGFwdGVyLnRvZGF5KCkpO1xuICAgICAgICB0aGlzLl9tb250aExhYmVsID1cbiAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoTmFtZXMoJ3Nob3J0JylbdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5hY3RpdmVEYXRlKV1cbiAgICAgICAgICAgICAgICAudG9Mb2NhbGVVcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlyc3RPZk1vbnRoID0gdGhpcy5fZGF0ZUFkYXB0ZXIuY3JlYXRlRGF0ZSh0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuYWN0aXZlRGF0ZSksIHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKHRoaXMuYWN0aXZlRGF0ZSksIDEpO1xuICAgICAgICB0aGlzLl9maXJzdFdlZWtPZmZzZXQgPVxuICAgICAgICAgICAgKERBWVNfUEVSX1dFRUsgKyB0aGlzLl9kYXRlQWRhcHRlci5nZXREYXlPZldlZWsoZmlyc3RPZk1vbnRoKSAtXG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0Rmlyc3REYXlPZldlZWsoKSkgJSBEQVlTX1BFUl9XRUVLO1xuICAgICAgICB0aGlzLl9jcmVhdGVXZWVrQ2VsbHMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgTWRDYWxlbmRhckNlbGxzIGZvciB0aGUgZGF0ZXMgaW4gdGhpcyBtb250aC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTW9udGhWaWV3LnByb3RvdHlwZS5fY3JlYXRlV2Vla0NlbGxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkYXlzSW5Nb250aCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldE51bURheXNJbk1vbnRoKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGVOYW1lcyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldERhdGVOYW1lcygpO1xuICAgICAgICB0aGlzLl93ZWVrcyA9IFtbXV07XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDAsIC8qKiBAdHlwZSB7P30gKi8gY2VsbCA9IHRoaXMuX2ZpcnN0V2Vla09mZnNldDsgaSA8IGRheXNJbk1vbnRoOyBpKyssIGNlbGwrKykge1xuICAgICAgICAgICAgaWYgKGNlbGwgPT0gREFZU19QRVJfV0VFSykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgIGNlbGwgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLmFjdGl2ZURhdGUpLCB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aCh0aGlzLmFjdGl2ZURhdGUpLCBpICsgMSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmFibGVkID0gIXRoaXMuZGF0ZUZpbHRlciB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZUZpbHRlcihkYXRlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyaWFMYWJlbCA9IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChkYXRlLCB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5LmRhdGVBMTF5TGFiZWwpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla3NbdGhpcy5fd2Vla3MubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICAucHVzaChuZXcgTWRDYWxlbmRhckNlbGwoaSArIDEsIGRhdGVOYW1lc1tpXSwgYXJpYUxhYmVsLCBlbmFibGVkKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGUgaW4gdGhpcyBtb250aCB0aGF0IHRoZSBnaXZlbiBEYXRlIGZhbGxzIG9uLlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZ2l2ZW4gRGF0ZSBpcyBpbiBhbm90aGVyIG1vbnRoLlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNb250aFZpZXcucHJvdG90eXBlLl9nZXREYXRlSW5DdXJyZW50TW9udGggPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzU2FtZU1vbnRoQW5kWWVhcihkYXRlLCB0aGlzLmFjdGl2ZURhdGUpID9cbiAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldERhdGUoZGF0ZSkgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIDIgZGF0ZXMgYXJlIG5vbi1udWxsIGFuZCBmYWxsIHdpdGhpbiB0aGUgc2FtZSBtb250aCBvZiB0aGUgc2FtZSB5ZWFyLlxuICAgICAqIEBwYXJhbSB7P30gZDFcbiAgICAgKiBAcGFyYW0gez99IGQyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1vbnRoVmlldy5wcm90b3R5cGUuX2hhc1NhbWVNb250aEFuZFllYXIgPSBmdW5jdGlvbiAoZDEsIGQyKSB7XG4gICAgICAgIHJldHVybiAhIShkMSAmJiBkMiAmJiB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aChkMSkgPT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgoZDIpICYmXG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKGQxKSA9PSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKGQyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRNb250aFZpZXc7XG59KCkpO1xuTWRNb250aFZpZXcuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1tb250aC12aWV3JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dGFibGUgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci10YWJsZVxcXCI+IDx0aGVhZCBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLXRhYmxlLWhlYWRlclxcXCI+IDx0cj48dGggKm5nRm9yPVxcXCJsZXQgZGF5IG9mIF93ZWVrZGF5c1xcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcImRheS5sb25nXFxcIj57e2RheS5uYXJyb3d9fTwvdGg+PC90cj4gPHRyPjx0aCBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLXRhYmxlLWhlYWRlci1kaXZpZGVyXFxcIiBjb2xzcGFuPVxcXCI3XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC90aD48L3RyPiA8L3RoZWFkPiA8dGJvZHkgbWQtY2FsZW5kYXItYm9keSByb2xlPVxcXCJncmlkXFxcIiBbbGFiZWxdPVxcXCJfbW9udGhMYWJlbFxcXCIgW3Jvd3NdPVxcXCJfd2Vla3NcXFwiIFt0b2RheVZhbHVlXT1cXFwiX3RvZGF5RGF0ZVxcXCIgW3NlbGVjdGVkVmFsdWVdPVxcXCJfc2VsZWN0ZWREYXRlXFxcIiBbbGFiZWxNaW5SZXF1aXJlZENlbGxzXT1cXFwiM1xcXCIgW2FjdGl2ZUNlbGxdPVxcXCJfZGF0ZUFkYXB0ZXIuZ2V0RGF0ZShhY3RpdmVEYXRlKSAtIDFcXFwiIChzZWxlY3RlZFZhbHVlQ2hhbmdlKT1cXFwiX2RhdGVTZWxlY3RlZCgkZXZlbnQpXFxcIj4gPC90Ym9keT4gPC90YWJsZT4gXCIsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRNb250aFZpZXcuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBEYXRlQWRhcHRlciwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTURfREFURV9GT1JNQVRTLF0gfSxdIH0sXG5dOyB9O1xuTWRNb250aFZpZXcucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2FjdGl2ZURhdGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdkYXRlRmlsdGVyJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzZWxlY3RlZENoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBBbiBpbnRlcm5hbCBjb21wb25lbnQgdXNlZCB0byBkaXNwbGF5IGEgc2luZ2xlIHllYXIgaW4gdGhlIGRhdGVwaWNrZXIuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kWWVhclZpZXcgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kYXRlQWRhcHRlclxuICAgICAqIEBwYXJhbSB7P30gX2RhdGVGb3JtYXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRZZWFyVmlldyhfZGF0ZUFkYXB0ZXIsIF9kYXRlRm9ybWF0cykge1xuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlciA9IF9kYXRlQWRhcHRlcjtcbiAgICAgICAgdGhpcy5fZGF0ZUZvcm1hdHMgPSBfZGF0ZUZvcm1hdHM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIGEgbmV3IG1vbnRoIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlcikge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ0RhdGVBZGFwdGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlRm9ybWF0cykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ01EX0RBVEVfRk9STUFUUycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci50b2RheSgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRZZWFyVmlldy5wcm90b3R5cGUsIFwiYWN0aXZlRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZSB0byBkaXNwbGF5IGluIHRoaXMgeWVhciB2aWV3IChldmVyeXRoaW5nIG90aGVyIHRoYW4gdGhlIHllYXIgaXMgaWdub3JlZCkuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FjdGl2ZURhdGU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkQWN0aXZlRGF0ZSA9IHRoaXMuX2FjdGl2ZURhdGU7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdmFsdWUgfHwgdGhpcy5fZGF0ZUFkYXB0ZXIudG9kYXkoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKG9sZEFjdGl2ZURhdGUpICE9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5fYWN0aXZlRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFllYXJWaWV3LnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoID0gdGhpcy5fZ2V0TW9udGhJbkN1cnJlbnRZZWFyKHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kWWVhclZpZXcucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIGEgbmV3IG1vbnRoIGlzIHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSB7P30gbW9udGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kWWVhclZpZXcucHJvdG90eXBlLl9tb250aFNlbGVjdGVkID0gZnVuY3Rpb24gKG1vbnRoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSwgbW9udGgsIHRoaXMuX2RhdGVBZGFwdGVyLmdldERhdGUodGhpcy5hY3RpdmVEYXRlKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhpcyBtb250aCB2aWV3LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRZZWFyVmlldy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGggPSB0aGlzLl9nZXRNb250aEluQ3VycmVudFllYXIodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuX3RvZGF5TW9udGggPSB0aGlzLl9nZXRNb250aEluQ3VycmVudFllYXIodGhpcy5fZGF0ZUFkYXB0ZXIudG9kYXkoKSk7XG4gICAgICAgIHRoaXMuX3llYXJMYWJlbCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXJOYW1lKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vbnRoTmFtZXMgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aE5hbWVzKCdzaG9ydCcpO1xuICAgICAgICAvLyBGaXJzdCByb3cgb2YgbW9udGhzIG9ubHkgY29udGFpbnMgNSBlbGVtZW50cyBzbyB3ZSBjYW4gZml0IHRoZSB5ZWFyIGxhYmVsIG9uIHRoZSBzYW1lIHJvdy5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gW1swLCAxLCAyLCAzLCA0XSwgWzUsIDYsIDcsIDgsIDksIDEwLCAxMV1dLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3cubWFwKGZ1bmN0aW9uIChtb250aCkgeyByZXR1cm4gX3RoaXMuX2NyZWF0ZUNlbGxGb3JNb250aChtb250aCwgbW9udGhOYW1lc1ttb250aF0pOyB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtb250aCBpbiB0aGlzIHllYXIgdGhhdCB0aGUgZ2l2ZW4gRGF0ZSBmYWxscyBvbi5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGdpdmVuIERhdGUgaXMgaW4gYW5vdGhlciB5ZWFyLlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRZZWFyVmlldy5wcm90b3R5cGUuX2dldE1vbnRoSW5DdXJyZW50WWVhciA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlICYmIHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZSkgPT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLmFjdGl2ZURhdGUpID9cbiAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUpIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gTWRDYWxlbmRhckNlbGwgZm9yIHRoZSBnaXZlbiBtb250aC5cbiAgICAgKiBAcGFyYW0gez99IG1vbnRoXG4gICAgICogQHBhcmFtIHs/fSBtb250aE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kWWVhclZpZXcucHJvdG90eXBlLl9jcmVhdGVDZWxsRm9yTW9udGggPSBmdW5jdGlvbiAobW9udGgsIG1vbnRoTmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmlhTGFiZWwgPSB0aGlzLl9kYXRlQWRhcHRlci5mb3JtYXQodGhpcy5fZGF0ZUFkYXB0ZXIuY3JlYXRlRGF0ZSh0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuYWN0aXZlRGF0ZSksIG1vbnRoLCAxKSwgdGhpcy5fZGF0ZUZvcm1hdHMuZGlzcGxheS5tb250aFllYXJBMTF5TGFiZWwpO1xuICAgICAgICByZXR1cm4gbmV3IE1kQ2FsZW5kYXJDZWxsKG1vbnRoLCBtb250aE5hbWUudG9Mb2NhbGVVcHBlckNhc2UoKSwgYXJpYUxhYmVsLCB0aGlzLl9pc01vbnRoRW5hYmxlZChtb250aCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZ2l2ZW4gbW9udGggaXMgZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0gez99IG1vbnRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFllYXJWaWV3LnByb3RvdHlwZS5faXNNb250aEVuYWJsZWQgPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpcnN0T2ZNb250aCA9IHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLmFjdGl2ZURhdGUpLCBtb250aCwgMSk7XG4gICAgICAgIC8vIElmIGFueSBkYXRlIGluIHRoZSBtb250aCBpcyBlbmFibGVkIGNvdW50IHRoZSBtb250aCBhcyBlbmFibGVkLlxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGRhdGUgPSBmaXJzdE9mTW9udGg7IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUpID09IG1vbnRoOyBkYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJEYXlzKGRhdGUsIDEpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRlRmlsdGVyKGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIE1kWWVhclZpZXc7XG59KCkpO1xuTWRZZWFyVmlldy5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLXllYXItdmlldycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHRhYmxlIGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItdGFibGVcXFwiPiA8dGhlYWQgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci10YWJsZS1oZWFkZXJcXFwiPiA8dHI+PHRoIGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItdGFibGUtaGVhZGVyLWRpdmlkZXJcXFwiIGNvbHNwYW49XFxcIjdcXFwiPjwvdGg+PC90cj4gPC90aGVhZD4gPHRib2R5IG1kLWNhbGVuZGFyLWJvZHkgcm9sZT1cXFwiZ3JpZFxcXCIgYWxsb3dEaXNhYmxlZFNlbGVjdGlvbj1cXFwidHJ1ZVxcXCIgW2xhYmVsXT1cXFwiX3llYXJMYWJlbFxcXCIgW3Jvd3NdPVxcXCJfbW9udGhzXFxcIiBbdG9kYXlWYWx1ZV09XFxcIl90b2RheU1vbnRoXFxcIiBbc2VsZWN0ZWRWYWx1ZV09XFxcIl9zZWxlY3RlZE1vbnRoXFxcIiBbbGFiZWxNaW5SZXF1aXJlZENlbGxzXT1cXFwiMlxcXCIgW2FjdGl2ZUNlbGxdPVxcXCJfZGF0ZUFkYXB0ZXIuZ2V0TW9udGgoYWN0aXZlRGF0ZSlcXFwiIChzZWxlY3RlZFZhbHVlQ2hhbmdlKT1cXFwiX21vbnRoU2VsZWN0ZWQoJGV2ZW50KVxcXCI+IDwvdGJvZHk+IDwvdGFibGU+IFwiLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kWWVhclZpZXcuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBEYXRlQWRhcHRlciwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTURfREFURV9GT1JNQVRTLF0gfSxdIH0sXG5dOyB9O1xuTWRZZWFyVmlldy5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnYWN0aXZlRGF0ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc2VsZWN0ZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2RhdGVGaWx0ZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG4vKipcbiAqIERhdGVwaWNrZXIgZGF0YSB0aGF0IHJlcXVpcmVzIGludGVybmF0aW9uYWxpemF0aW9uLlxuICovXG52YXIgTWREYXRlcGlja2VySW50bCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGF0ZXBpY2tlckludGwoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxhYmVsIGZvciB0aGUgY2FsZW5kYXIgcG9wdXAgKHVzZWQgYnkgc2NyZWVuIHJlYWRlcnMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxlbmRhckxhYmVsID0gJ0NhbGVuZGFyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSBidXR0b24gdXNlZCB0byBvcGVuIHRoZSBjYWxlbmRhciBwb3B1cCAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW5DYWxlbmRhckxhYmVsID0gJ09wZW4gY2FsZW5kYXInO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsYWJlbCBmb3IgdGhlIHByZXZpb3VzIG1vbnRoIGJ1dHRvbiAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZNb250aExhYmVsID0gJ1ByZXZpb3VzIG1vbnRoJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSBuZXh0IG1vbnRoIGJ1dHRvbiAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHRNb250aExhYmVsID0gJ05leHQgbW9udGgnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsYWJlbCBmb3IgdGhlIHByZXZpb3VzIHllYXIgYnV0dG9uICh1c2VkIGJ5IHNjcmVlbiByZWFkZXJzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldlllYXJMYWJlbCA9ICdQcmV2aW91cyB5ZWFyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSBuZXh0IHllYXIgYnV0dG9uICh1c2VkIGJ5IHNjcmVlbiByZWFkZXJzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dFllYXJMYWJlbCA9ICdOZXh0IHllYXInO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsYWJlbCBmb3IgdGhlICdzd2l0Y2ggdG8gbW9udGggdmlldycgYnV0dG9uICh1c2VkIGJ5IHNjcmVlbiByZWFkZXJzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3dpdGNoVG9Nb250aFZpZXdMYWJlbCA9ICdDaGFuZ2UgdG8gbW9udGggdmlldyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxhYmVsIGZvciB0aGUgJ3N3aXRjaCB0byB5ZWFyIHZpZXcnIGJ1dHRvbiAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN3aXRjaFRvWWVhclZpZXdMYWJlbCA9ICdDaGFuZ2UgdG8geWVhciB2aWV3JztcbiAgICB9XG4gICAgcmV0dXJuIE1kRGF0ZXBpY2tlckludGw7XG59KCkpO1xuTWREYXRlcGlja2VySW50bC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWREYXRlcGlja2VySW50bC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBBIGNhbGVuZGFyIHRoYXQgaXMgdXNlZCBhcyBwYXJ0IG9mIHRoZSBkYXRlcGlja2VyLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZENhbGVuZGFyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX2ludGxcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IF9pc0NvbXBhdGliaWxpdHlNb2RlXG4gICAgICogQHBhcmFtIHs/fSBfZGF0ZUFkYXB0ZXJcbiAgICAgKiBAcGFyYW0gez99IF9kYXRlRm9ybWF0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kQ2FsZW5kYXIoX2VsZW1lbnRSZWYsIF9pbnRsLCBfbmdab25lLCBfaXNDb21wYXRpYmlsaXR5TW9kZSwgX2RhdGVBZGFwdGVyLCBfZGF0ZUZvcm1hdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9pbnRsID0gX2ludGw7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX2lzQ29tcGF0aWJpbGl0eU1vZGUgPSBfaXNDb21wYXRpYmlsaXR5TW9kZTtcbiAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIgPSBfZGF0ZUFkYXB0ZXI7XG4gICAgICAgIHRoaXMuX2RhdGVGb3JtYXRzID0gX2RhdGVGb3JtYXRzO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIHN0YXJ0ZWQgaW4gbW9udGggb3IgeWVhciB2aWV3LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydFZpZXcgPSAnbW9udGgnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgd2hlbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRlIGZpbHRlciBmb3IgdGhlIG1vbnRoIGFuZCB5ZWFyIHZpZXdzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGF0ZUZpbHRlckZvclZpZXdzID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWRhdGUgJiZcbiAgICAgICAgICAgICAgICAoIV90aGlzLmRhdGVGaWx0ZXIgfHwgX3RoaXMuZGF0ZUZpbHRlcihkYXRlKSkgJiZcbiAgICAgICAgICAgICAgICAoIV90aGlzLm1pbkRhdGUgfHwgX3RoaXMuX2RhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKGRhdGUsIF90aGlzLm1pbkRhdGUpID49IDApICYmXG4gICAgICAgICAgICAgICAgKCFfdGhpcy5tYXhEYXRlIHx8IF90aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShkYXRlLCBfdGhpcy5tYXhEYXRlKSA8PSAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlcikge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ0RhdGVBZGFwdGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlRm9ybWF0cykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ01EX0RBVEVfRk9STUFUUycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENhbGVuZGFyLnByb3RvdHlwZSwgXCJfYWN0aXZlRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBhY3RpdmUgZGF0ZS4gVGhpcyBkZXRlcm1pbmVzIHdoaWNoIHRpbWUgcGVyaW9kIGlzIHNob3duIGFuZCB3aGljaCBkYXRlIGlzXG4gICAgICAgICAqIGhpZ2hsaWdodGVkIHdoZW4gdXNpbmcga2V5Ym9hcmQgbmF2aWdhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5jbGFtcERhdGUodmFsdWUsIHRoaXMubWluRGF0ZSwgdGhpcy5tYXhEYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2FsZW5kYXIucHJvdG90eXBlLCBcIl9wZXJpb2RCdXR0b25UZXh0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYWJlbCBmb3IgdGhlIGN1cnJlbnQgY2FsZW5kYXIgdmlldy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoVmlldyA/XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZm9ybWF0KHRoaXMuX2FjdGl2ZURhdGUsIHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkubW9udGhZZWFyTGFiZWwpXG4gICAgICAgICAgICAgICAgICAgIC50b0xvY2FsZVVwcGVyQ2FzZSgpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyTmFtZSh0aGlzLl9hY3RpdmVEYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2FsZW5kYXIucHJvdG90eXBlLCBcIl9wZXJpb2RCdXR0b25MYWJlbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhWaWV3ID8gdGhpcy5faW50bC5zd2l0Y2hUb1llYXJWaWV3TGFiZWwgOiB0aGlzLl9pbnRsLnN3aXRjaFRvTW9udGhWaWV3TGFiZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENhbGVuZGFyLnByb3RvdHlwZSwgXCJfcHJldkJ1dHRvbkxhYmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYWJlbCBmb3IgdGhlIHRoZSBwcmV2aW91cyBidXR0b24uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aFZpZXcgPyB0aGlzLl9pbnRsLnByZXZNb250aExhYmVsIDogdGhpcy5faW50bC5wcmV2WWVhckxhYmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDYWxlbmRhci5wcm90b3R5cGUsIFwiX25leHRCdXR0b25MYWJlbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFiZWwgZm9yIHRoZSB0aGUgbmV4dCBidXR0b24uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aFZpZXcgPyB0aGlzLl9pbnRsLm5leHRNb250aExhYmVsIDogdGhpcy5faW50bC5uZXh0WWVhckxhYmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuc3RhcnRBdCB8fCB0aGlzLl9kYXRlQWRhcHRlci50b2RheSgpO1xuICAgICAgICB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwoKTtcbiAgICAgICAgdGhpcy5fbW9udGhWaWV3ID0gdGhpcy5zdGFydFZpZXcgIT0gJ3llYXInO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBkYXRlIHNlbGVjdGlvbiBpbiB0aGUgbW9udGggdmlldy5cbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9kYXRlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGVBZGFwdGVyLnNhbWVEYXRlKGRhdGUsIHRoaXMuc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbW9udGggc2VsZWN0aW9uIGluIHRoZSB5ZWFyIHZpZXcuXG4gICAgICogQHBhcmFtIHs/fSBtb250aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhci5wcm90b3R5cGUuX21vbnRoU2VsZWN0ZWQgPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG1vbnRoO1xuICAgICAgICB0aGlzLl9tb250aFZpZXcgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB1c2VyIGNsaWNrcyBvbiB0aGUgcGVyaW9kIGxhYmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhci5wcm90b3R5cGUuX2N1cnJlbnRQZXJpb2RDbGlja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tb250aFZpZXcgPSAhdGhpcy5fbW9udGhWaWV3O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB1c2VyIGNsaWNrcyBvbiB0aGUgcHJldmlvdXMgYnV0dG9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhci5wcm90b3R5cGUuX3ByZXZpb3VzQ2xpY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX21vbnRoVmlldyA/XG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLl9hY3RpdmVEYXRlLCAtMSkgOlxuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHVzZXIgY2xpY2tzIG9uIHRoZSBuZXh0IGJ1dHRvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9uZXh0Q2xpY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX21vbnRoVmlldyA/XG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLl9hY3RpdmVEYXRlLCAxKSA6XG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhclllYXJzKHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcHJldmlvdXMgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhci5wcm90b3R5cGUuX3ByZXZpb3VzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1pbkRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy5taW5EYXRlIHx8ICF0aGlzLl9pc1NhbWVWaWV3KHRoaXMuX2FjdGl2ZURhdGUsIHRoaXMubWluRGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBuZXh0IHBlcmlvZCBidXR0b24gaXMgZW5hYmxlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9uZXh0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLm1heERhdGUgfHwgIXRoaXMuX2lzU2FtZVZpZXcodGhpcy5fYWN0aXZlRGF0ZSwgdGhpcy5tYXhEYXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMga2V5ZG93biBldmVudHMgb24gdGhlIGNhbGVuZGFyIGJvZHkuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhci5wcm90b3R5cGUuX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gVE9ETyhtbWFsZXJiYSk6IFdlIGN1cnJlbnRseSBhbGxvdyBrZXlib2FyZCBuYXZpZ2F0aW9uIHRvIGRpc2FibGVkIGRhdGVzLCBidXQganVzdCBwcmV2ZW50XG4gICAgICAgIC8vIGRpc2FibGVkIG9uZXMgZnJvbSBiZWluZyBzZWxlY3RlZC4gVGhpcyBtYXkgbm90IGJlIGlkZWFsLCB3ZSBzaG91bGQgbG9vayBpbnRvIHdoZXRoZXJcbiAgICAgICAgLy8gbmF2aWdhdGlvbiBzaG91bGQgc2tpcCBvdmVyIGRpc2FibGVkIGRhdGVzLCBhbmQgaWYgc28sIGhvdyB0byBpbXBsZW1lbnQgdGhhdCBlZmZpY2llbnRseS5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoVmlldykge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlQ2FsZW5kYXJCb2R5S2V5ZG93bkluTW9udGhWaWV3KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd25JblllYXJWaWV3KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgYWN0aXZlIGNlbGwgYWZ0ZXIgdGhlIG1pY3JvdGFzayBxdWV1ZSBpcyBlbXB0eS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9mb2N1c0FjdGl2ZUNlbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbmdab25lLm9uU3RhYmxlLmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFjdGl2ZUVsID0gX3RoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWF0LWNhbGVuZGFyLWJvZHktYWN0aXZlJyk7XG4gICAgICAgICAgICBhY3RpdmVFbC5mb2N1cygpO1xuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB0d28gZGF0ZXMgcmVwcmVzZW50IHRoZSBzYW1lIHZpZXcgaW4gdGhlIGN1cnJlbnQgdmlldyBtb2RlIChtb250aCBvciB5ZWFyKS5cbiAgICAgKiBAcGFyYW0gez99IGRhdGUxXG4gICAgICogQHBhcmFtIHs/fSBkYXRlMlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhci5wcm90b3R5cGUuX2lzU2FtZVZpZXcgPSBmdW5jdGlvbiAoZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aFZpZXcgP1xuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlMSkgPT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlMikgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aChkYXRlMSkgPT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgoZGF0ZTIpIDpcbiAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZTEpID09IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZTIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBrZXlkb3duIGV2ZW50cyBvbiB0aGUgY2FsZW5kYXIgYm9keSB3aGVuIGNhbGVuZGFyIGlzIGluIG1vbnRoIHZpZXcuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhci5wcm90b3R5cGUuX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd25Jbk1vbnRoVmlldyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJEYXlzKHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyRGF5cyh0aGlzLl9hY3RpdmVEYXRlLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyRGF5cyh0aGlzLl9hY3RpdmVEYXRlLCAtNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyRGF5cyh0aGlzLl9hY3RpdmVEYXRlLCA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSE9NRTpcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJEYXlzKHRoaXMuX2FjdGl2ZURhdGUsIDEgLSB0aGlzLl9kYXRlQWRhcHRlci5nZXREYXRlKHRoaXMuX2FjdGl2ZURhdGUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRU5EOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhckRheXModGhpcy5fYWN0aXZlRGF0ZSwgKHRoaXMuX2RhdGVBZGFwdGVyLmdldE51bURheXNJbk1vbnRoKHRoaXMuX2FjdGl2ZURhdGUpIC1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF0ZSh0aGlzLl9hY3RpdmVEYXRlKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQQUdFX1VQOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBldmVudC5hbHRLZXkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhclllYXJzKHRoaXMuX2FjdGl2ZURhdGUsIC0xKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUEFHRV9ET1dOOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBldmVudC5hbHRLZXkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhclllYXJzKHRoaXMuX2FjdGl2ZURhdGUsIDEpIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVOVEVSOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kYXRlRmlsdGVyRm9yVmlld3ModGhpcy5fYWN0aXZlRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0ZVNlbGVjdGVkKHRoaXMuX2FjdGl2ZURhdGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHVuZXhwZWN0ZWQgZGVmYXVsdCBhY3Rpb25zIHN1Y2ggYXMgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIERvbid0IHByZXZlbnQgZGVmYXVsdCBvciBmb2N1cyBhY3RpdmUgY2VsbCBvbiBrZXlzIHRoYXQgd2UgZG9uJ3QgZXhwbGljaXRseSBoYW5kbGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCgpO1xuICAgICAgICAvLyBQcmV2ZW50IHVuZXhwZWN0ZWQgZGVmYXVsdCBhY3Rpb25zIHN1Y2ggYXMgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBrZXlkb3duIGV2ZW50cyBvbiB0aGUgY2FsZW5kYXIgYm9keSB3aGVuIGNhbGVuZGFyIGlzIGluIHllYXIgdmlldy5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENhbGVuZGFyLnByb3RvdHlwZS5faGFuZGxlQ2FsZW5kYXJCb2R5S2V5ZG93bkluWWVhclZpZXcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBVUF9BUlJPVzpcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fcHJldk1vbnRoSW5TYW1lQ29sKHRoaXMuX2FjdGl2ZURhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9uZXh0TW9udGhJblNhbWVDb2wodGhpcy5fYWN0aXZlRGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhPTUU6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsIC10aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aCh0aGlzLl9hY3RpdmVEYXRlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVORDpcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSwgMTEgLSB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aCh0aGlzLl9hY3RpdmVEYXRlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBBR0VfVVA6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnModGhpcy5fYWN0aXZlRGF0ZSwgZXZlbnQuYWx0S2V5ID8gLTEwIDogLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQQUdFX0RPV046XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnModGhpcy5fYWN0aXZlRGF0ZSwgZXZlbnQuYWx0S2V5ID8gMTAgOiAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRU5URVI6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhTZWxlY3RlZCh0aGlzLl9hY3RpdmVEYXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgcHJldmVudCBkZWZhdWx0IG9yIGZvY3VzIGFjdGl2ZSBjZWxsIG9uIGtleXMgdGhhdCB3ZSBkb24ndCBleHBsaWNpdGx5IGhhbmRsZS5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKCk7XG4gICAgICAgIC8vIFByZXZlbnQgdW5leHBlY3RlZCBkZWZhdWx0IGFjdGlvbnMgc3VjaCBhcyBmb3JtIHN1Ym1pc3Npb24uXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRhdGUgZm9yIHRoZSBtb250aCB0aGF0IGNvbWVzIGJlZm9yZSB0aGUgZ2l2ZW4gbW9udGggaW4gdGhlIHNhbWUgY29sdW1uIGluIHRoZVxuICAgICAqIGNhbGVuZGFyIHRhYmxlLlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhci5wcm90b3R5cGUuX3ByZXZNb250aEluU2FtZUNvbCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIC8vIERldGVybWluZSBob3cgbWFueSBtb250aHMgdG8ganVtcCBmb3J3YXJkIGdpdmVuIHRoYXQgdGhlcmUgYXJlIDIgZW1wdHkgc2xvdHMgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAvLyBvZiBlYWNoIHllYXIuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluY3JlbWVudCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUpIDw9IDQgPyAtNSA6XG4gICAgICAgICAgICAodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgoZGF0ZSkgPj0gNyA/IC03IDogLTEyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyTW9udGhzKGRhdGUsIGluY3JlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRhdGUgZm9yIHRoZSBtb250aCB0aGF0IGNvbWVzIGFmdGVyIHRoZSBnaXZlbiBtb250aCBpbiB0aGUgc2FtZSBjb2x1bW4gaW4gdGhlXG4gICAgICogY2FsZW5kYXIgdGFibGUuXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENhbGVuZGFyLnByb3RvdHlwZS5fbmV4dE1vbnRoSW5TYW1lQ29sID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IG1vbnRocyB0byBqdW1wIGZvcndhcmQgZ2l2ZW4gdGhhdCB0aGVyZSBhcmUgMiBlbXB0eSBzbG90cyBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgIC8vIG9mIGVhY2ggeWVhci5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5jcmVtZW50ID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgoZGF0ZSkgPD0gNCA/IDcgOlxuICAgICAgICAgICAgKHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUpID49IDcgPyA1IDogMTIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHMoZGF0ZSwgaW5jcmVtZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBNZENhbGVuZGFyO1xufSgpKTtcbk1kQ2FsZW5kYXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1jYWxlbmRhcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLWhlYWRlclxcXCI+IDxkaXYgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1jb250cm9sc1xcXCI+IDwhLS0gVE9ETyhtbWFsZXJiYSk6IENsZWFuIHVwIGR1cGxpY2F0ZWQgY29tcGF0aWJpbGl0eSBtb2RlIGNvZGUgd2hlbiB3ZSBoYXZlIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzLiAtLT4gPCEtLSBDaGVjayBmb3IgY29tcGF0aWJpbGl0eSBtb2RlIGFuZCB1c2UgY29ycmVjdCBwcmVmaXggZm9yIG1kLWJ1dHRvbi4gLS0+IDxidXR0b24gKm5nSWY9XFxcIiFfaXNDb21wYXRpYmlsaXR5TW9kZVxcXCIgbWQtYnV0dG9uIGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItcGVyaW9kLWJ1dHRvblxcXCIgKGNsaWNrKT1cXFwiX2N1cnJlbnRQZXJpb2RDbGlja2VkKClcXFwiICBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiX3BlcmlvZEJ1dHRvbkxhYmVsXFxcIj4ge3tfcGVyaW9kQnV0dG9uVGV4dH19IDxkaXYgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1hcnJvd1xcXCIgW2NsYXNzLm1hdC1jYWxlbmRhci1pbnZlcnRdPVxcXCIhX21vbnRoVmlld1xcXCI+PC9kaXY+IDwvYnV0dG9uPiA8YnV0dG9uICpuZ0lmPVxcXCJfaXNDb21wYXRpYmlsaXR5TW9kZVxcXCIgbWF0LWJ1dHRvbiBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLXBlcmlvZC1idXR0b25cXFwiIChjbGljayk9XFxcIl9jdXJyZW50UGVyaW9kQ2xpY2tlZCgpXFxcIiAgW2F0dHIuYXJpYS1sYWJlbF09XFxcIl9wZXJpb2RCdXR0b25MYWJlbFxcXCI+IHt7X3BlcmlvZEJ1dHRvblRleHR9fSA8ZGl2IGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItYXJyb3dcXFwiIFtjbGFzcy5tYXQtY2FsZW5kYXItaW52ZXJ0XT1cXFwiIV9tb250aFZpZXdcXFwiPjwvZGl2PiA8L2J1dHRvbj4gPGRpdiBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLXNwYWNlclxcXCI+PC9kaXY+IDwhLS0gQ2hlY2sgZm9yIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgdXNlIGNvcnJlY3QgcHJlZml4IGZvciBtZC1pY29uLWJ1dHRvbi4gLS0+IDxidXR0b24gKm5nSWY9XFxcIiFfaXNDb21wYXRpYmlsaXR5TW9kZVxcXCIgbWQtaWNvbi1idXR0b24gY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1wcmV2aW91cy1idXR0b25cXFwiIFtkaXNhYmxlZF09XFxcIiFfcHJldmlvdXNFbmFibGVkKClcXFwiIChjbGljayk9XFxcIl9wcmV2aW91c0NsaWNrZWQoKVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcIl9wcmV2QnV0dG9uTGFiZWxcXFwiPiA8L2J1dHRvbj4gPGJ1dHRvbiAqbmdJZj1cXFwiX2lzQ29tcGF0aWJpbGl0eU1vZGVcXFwiIG1hdC1pY29uLWJ1dHRvbiBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLXByZXZpb3VzLWJ1dHRvblxcXCIgW2Rpc2FibGVkXT1cXFwiIV9wcmV2aW91c0VuYWJsZWQoKVxcXCIgKGNsaWNrKT1cXFwiX3ByZXZpb3VzQ2xpY2tlZCgpXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiX3ByZXZCdXR0b25MYWJlbFxcXCI+IDwvYnV0dG9uPiA8IS0tIENoZWNrIGZvciBjb21wYXRpYmlsaXR5IG1vZGUgYW5kIHVzZSBjb3JyZWN0IHByZWZpeCBmb3IgbWQtaWNvbi1idXR0b24uIC0tPiA8YnV0dG9uICpuZ0lmPVxcXCIhX2lzQ29tcGF0aWJpbGl0eU1vZGVcXFwiIG1kLWljb24tYnV0dG9uIGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItbmV4dC1idXR0b25cXFwiIFtkaXNhYmxlZF09XFxcIiFfbmV4dEVuYWJsZWQoKVxcXCIgKGNsaWNrKT1cXFwiX25leHRDbGlja2VkKClcXFwiIFthdHRyLmFyaWEtbGFiZWxdPVxcXCJfbmV4dEJ1dHRvbkxhYmVsXFxcIj4gPC9idXR0b24+IDxidXR0b24gKm5nSWY9XFxcIl9pc0NvbXBhdGliaWxpdHlNb2RlXFxcIiBtYXQtaWNvbi1idXR0b24gY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1uZXh0LWJ1dHRvblxcXCIgW2Rpc2FibGVkXT1cXFwiIV9uZXh0RW5hYmxlZCgpXFxcIiAoY2xpY2spPVxcXCJfbmV4dENsaWNrZWQoKVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcIl9uZXh0QnV0dG9uTGFiZWxcXFwiPiA8L2J1dHRvbj4gPC9kaXY+IDwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItY29udGVudFxcXCIgKGtleWRvd24pPVxcXCJfaGFuZGxlQ2FsZW5kYXJCb2R5S2V5ZG93bigkZXZlbnQpXFxcIiBjZGtNb25pdG9yU3VidHJlZUZvY3VzPiA8bWQtbW9udGgtdmlldyAqbmdJZj1cXFwiX21vbnRoVmlld1xcXCIgW2FjdGl2ZURhdGVdPVxcXCJfYWN0aXZlRGF0ZVxcXCIgW3NlbGVjdGVkXT1cXFwic2VsZWN0ZWRcXFwiIFtkYXRlRmlsdGVyXT1cXFwiX2RhdGVGaWx0ZXJGb3JWaWV3c1xcXCIgKHNlbGVjdGVkQ2hhbmdlKT1cXFwiX2RhdGVTZWxlY3RlZCgkZXZlbnQpXFxcIj4gPC9tZC1tb250aC12aWV3PiA8bWQteWVhci12aWV3ICpuZ0lmPVxcXCIhX21vbnRoVmlld1xcXCIgW2FjdGl2ZURhdGVdPVxcXCJfYWN0aXZlRGF0ZVxcXCIgW3NlbGVjdGVkXT1cXFwic2VsZWN0ZWRcXFwiIFtkYXRlRmlsdGVyXT1cXFwiX2RhdGVGaWx0ZXJGb3JWaWV3c1xcXCIgKHNlbGVjdGVkQ2hhbmdlKT1cXFwiX21vbnRoU2VsZWN0ZWQoJGV2ZW50KVxcXCI+IDwvbWQteWVhci12aWV3PiA8L2Rpdj4gXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWNhbGVuZGFye2Rpc3BsYXk6YmxvY2t9Lm1hdC1jYWxlbmRhci1oZWFkZXJ7cGFkZGluZzo4cHggOHB4IDAgOHB4fS5tYXQtY2FsZW5kYXItY29udGVudHtwYWRkaW5nOjAgOHB4IDhweCA4cHg7b3V0bGluZTowfS5tYXQtY2FsZW5kYXItY29udHJvbHN7ZGlzcGxheTpmbGV4O3BhZGRpbmc6NSUgY2FsYygxMDAlIC8gMTQgLSAyMnB4KSA1JSBjYWxjKDEwMCUgLyAxNCAtIDIycHgpfS5tYXQtY2FsZW5kYXItc3BhY2Vye2ZsZXg6MSAxIGF1dG99Lm1hdC1jYWxlbmRhci1wZXJpb2QtYnV0dG9ue2ZvbnQ6aW5oZXJpdDtmb250LXNpemU6MTRweDtmb250LXdlaWdodDo3MDA7bWluLXdpZHRoOjB9Lm1hdC1jYWxlbmRhci1hcnJvd3tkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlci1sZWZ0OjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci10b3Atd2lkdGg6NXB4O2JvcmRlci10b3Atc3R5bGU6c29saWQ7bWFyZ2luOjAgMCAwIDVweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm1hdC1jYWxlbmRhci1hcnJvdy5tYXQtY2FsZW5kYXItaW52ZXJ0e3RyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKX0ubWF0LWNhbGVuZGFyLW5leHQtYnV0dG9uLC5tYXQtY2FsZW5kYXItcHJldmlvdXMtYnV0dG9ue3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtY2FsZW5kYXItbmV4dC1idXR0b246OmFmdGVyLC5tYXQtY2FsZW5kYXItcHJldmlvdXMtYnV0dG9uOjphZnRlcntjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtib3R0b206MDtyaWdodDowO21hcmdpbjoxNS41cHg7Ym9yZGVyOjAgc29saWQgY3VycmVudENvbG9yO2JvcmRlci10b3Atd2lkdGg6MnB4fS5tYXQtY2FsZW5kYXItcHJldmlvdXMtYnV0dG9uOjphZnRlcntib3JkZXItbGVmdC13aWR0aDoycHg7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMnB4KSByb3RhdGUoLTQ1ZGVnKX0ubWF0LWNhbGVuZGFyLW5leHQtYnV0dG9uOjphZnRlcntib3JkZXItcmlnaHQtd2lkdGg6MnB4O3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0ycHgpIHJvdGF0ZSg0NWRlZyl9Lm1hdC1jYWxlbmRhci10YWJsZXtib3JkZXItc3BhY2luZzowO2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTt3aWR0aDoxMDAlfS5tYXQtY2FsZW5kYXItdGFibGUtaGVhZGVyIHRoe3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZToxMXB4O2ZvbnQtd2VpZ2h0OjQwMDtwYWRkaW5nOjAgMCA4cHggMH0ubWF0LWNhbGVuZGFyLXRhYmxlLWhlYWRlci1kaXZpZGVye3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxcHh9Lm1hdC1jYWxlbmRhci10YWJsZS1oZWFkZXItZGl2aWRlcjo6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0Oi04cHg7cmlnaHQ6LThweDtoZWlnaHQ6MXB4fSAvKiMgc291cmNlTWFwcGluZ1VSTD1jYWxlbmRhci5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhbGVuZGFyXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FsZW5kYXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogTWREYXRlcGlja2VySW50bCwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUsXSB9LF0gfSxcbiAgICB7IHR5cGU6IERhdGVBZGFwdGVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNRF9EQVRFX0ZPUk1BVFMsXSB9LF0gfSxcbl07IH07XG5NZENhbGVuZGFyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdzdGFydEF0JzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzdGFydFZpZXcnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtaW5EYXRlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtYXhEYXRlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdkYXRlRmlsdGVyJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzZWxlY3RlZENoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBVc2VkIHRvIGdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciBlYWNoIGRhdGVwaWNrZXIgaW5zdGFuY2UuXG4gKi9cbnZhciBkYXRlcGlja2VyVWlkID0gMDtcbi8qKlxuICogQ29tcG9uZW50IHVzZWQgYXMgdGhlIGNvbnRlbnQgZm9yIHRoZSBkYXRlcGlja2VyIGRpYWxvZyBhbmQgcG9wdXAuIFdlIHVzZSB0aGlzIGluc3RlYWQgb2YgdXNpbmdcbiAqIE1kQ2FsZW5kYXIgZGlyZWN0bHkgYXMgdGhlIGNvbnRlbnQgc28gd2UgY2FuIGNvbnRyb2wgdGhlIGluaXRpYWwgZm9jdXMuIFRoaXMgYWxzbyBnaXZlcyB1cyBhXG4gKiBwbGFjZSB0byBwdXQgYWRkaXRpb25hbCBmZWF0dXJlcyBvZiB0aGUgcG9wdXAgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIGNhbGVuZGFyIGl0c2VsZiBpbiB0aGVcbiAqIGZ1dHVyZS4gKGUuZy4gY29uZmlybWF0aW9uIGJ1dHRvbnMpLlxuICogXFxAZG9jcy1pbnRlcm5hbFxuICovXG52YXIgTWREYXRlcGlja2VyQ29udGVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGF0ZXBpY2tlckNvbnRlbnQoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VyQ29udGVudC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYWxlbmRhci5fZm9jdXNBY3RpdmVDZWxsKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnQgb24gZGF0ZXBpY2tlciBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnQgVGhlIGV2ZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VyQ29udGVudC5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEVTQ0FQRTpcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGVwaWNrZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHNvIHRoYXQgd2UgZG9uJ3QgcHJldmVudERlZmF1bHQgb24ga2V5cyB0aGF0IGFyZSBub3QgZXhwbGljaXRseSBoYW5kbGVkLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kRGF0ZXBpY2tlckNvbnRlbnQ7XG59KCkpO1xuTWREYXRlcGlja2VyQ29udGVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLWRhdGVwaWNrZXItY29udGVudCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG1kLWNhbGVuZGFyIGNka1RyYXBGb2N1cyBbaWRdPVxcXCJkYXRlcGlja2VyLmlkXFxcIiBbc3RhcnRBdF09XFxcImRhdGVwaWNrZXIuc3RhcnRBdFxcXCIgW3N0YXJ0Vmlld109XFxcImRhdGVwaWNrZXIuc3RhcnRWaWV3XFxcIiBbbWluRGF0ZV09XFxcImRhdGVwaWNrZXIuX21pbkRhdGVcXFwiIFttYXhEYXRlXT1cXFwiZGF0ZXBpY2tlci5fbWF4RGF0ZVxcXCIgW2RhdGVGaWx0ZXJdPVxcXCJkYXRlcGlja2VyLl9kYXRlRmlsdGVyXFxcIiBbc2VsZWN0ZWRdPVxcXCJkYXRlcGlja2VyLl9zZWxlY3RlZFxcXCIgKHNlbGVjdGVkQ2hhbmdlKT1cXFwiZGF0ZXBpY2tlci5fc2VsZWN0QW5kQ2xvc2UoJGV2ZW50KVxcXCI+IDwvbWQtY2FsZW5kYXI+IFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1kYXRlcGlja2VyLWNvbnRlbnR7Ym94LXNoYWRvdzowIDVweCA1cHggLTNweCByZ2JhKDAsMCwwLC4yKSwwIDhweCAxMHB4IDFweCByZ2JhKDAsMCwwLC4xNCksMCAzcHggMTRweCAycHggcmdiYSgwLDAsMCwuMTIpO2Rpc3BsYXk6YmxvY2t9Lm1hdC1jYWxlbmRhcnt3aWR0aDoyOTZweH0ubWF0LWRhdGVwaWNrZXItY29udGVudC10b3VjaHtib3gtc2hhZG93OjAgMCAwIDAgcmdiYSgwLDAsMCwuMiksMCAwIDAgMCByZ2JhKDAsMCwwLC4xNCksMCAwIDAgMCByZ2JhKDAsMCwwLC4xMik7ZGlzcGxheTpibG9jazttYXgtaGVpZ2h0Ojgwdmg7b3ZlcmZsb3c6YXV0bzttYXJnaW46LTI0cHh9Lm1hdC1kYXRlcGlja2VyLWNvbnRlbnQtdG91Y2ggLm1hdC1jYWxlbmRhcnt3aWR0aDo2NHZtaW47aGVpZ2h0Ojgwdm1pbjttaW4td2lkdGg6MjUwcHg7bWluLWhlaWdodDozMTJweDttYXgtd2lkdGg6NzUwcHg7bWF4LWhlaWdodDo3ODhweH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZXBpY2tlci1jb250ZW50LmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1kYXRlcGlja2VyLWNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1kYXRlcGlja2VyLWNvbnRlbnQtdG91Y2hdJzogJ2RhdGVwaWNrZXIudG91Y2hVaScsXG4gICAgICAgICAgICAgICAgICAgICcoa2V5ZG93biknOiAnX2hhbmRsZUtleWRvd24oJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERhdGVwaWNrZXJDb250ZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG5NZERhdGVwaWNrZXJDb250ZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdfY2FsZW5kYXInOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtNZENhbGVuZGFyLF0gfSxdLFxufTtcbi8qKlxuICogQ29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB0aGUgZGF0ZXBpY2tlciBwb3B1cC9kaWFsb2cuXG4gKi9cbnZhciBNZERhdGVwaWNrZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kaWFsb2dcbiAgICAgKiBAcGFyYW0gez99IF9vdmVybGF5XG4gICAgICogQHBhcmFtIHs/fSBfdmlld0NvbnRhaW5lclJlZlxuICAgICAqIEBwYXJhbSB7P30gX2RhdGVBZGFwdGVyXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWREYXRlcGlja2VyKF9kaWFsb2csIF9vdmVybGF5LCBfdmlld0NvbnRhaW5lclJlZiwgX2RhdGVBZGFwdGVyLCBfZGlyKSB7XG4gICAgICAgIHRoaXMuX2RpYWxvZyA9IF9kaWFsb2c7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlciA9IF9kYXRlQWRhcHRlcjtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2aWV3IHRoYXQgdGhlIGNhbGVuZGFyIHNob3VsZCBzdGFydCBpbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRWaWV3ID0gJ21vbnRoJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIFVJIGlzIGluIHRvdWNoIG1vZGUuIEluIHRvdWNoIG1vZGUgdGhlIGNhbGVuZGFyIG9wZW5zIGluIGEgZGlhbG9nIHJhdGhlclxuICAgICAgICAgKiB0aGFuIGEgcG9wdXAgYW5kIGVsZW1lbnRzIGhhdmUgbW9yZSBwYWRkaW5nIHRvIGFsbG93IGZvciBiaWdnZXIgdG91Y2ggdGFyZ2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG91Y2hVaSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgbmV3IHNlbGVjdGVkIGRhdGUgd2hlbiBzZWxlY3RlZCBkYXRlIGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIGlzIG9wZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkIGZvciB0aGUgZGF0ZXBpY2tlciBjYWxlbmRhci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBcIm1kLWRhdGVwaWNrZXItXCIgKyBkYXRlcGlja2VyVWlkKys7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fZGF0ZUFkYXB0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdEYXRlQWRhcHRlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERhdGVwaWNrZXIucHJvdG90eXBlLCBcInN0YXJ0QXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgdG8gb3BlbiB0aGUgY2FsZW5kYXIgdG8gaW5pdGlhbGx5LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBleHBsaWNpdCBzdGFydEF0IGlzIHNldCB3ZSBzdGFydCB0aGVyZSwgb3RoZXJ3aXNlIHdlIHN0YXJ0IGF0IHdoYXRldmVyIHRoZSBjdXJyZW50bHlcbiAgICAgICAgICAgIC8vIHNlbGVjdGVkIHZhbHVlIGlzLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0QXQgfHwgKHRoaXMuX2RhdGVwaWNrZXJJbnB1dCA/IHRoaXMuX2RhdGVwaWNrZXJJbnB1dC52YWx1ZSA6IG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlKSB7IHRoaXMuX3N0YXJ0QXQgPSBkYXRlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREYXRlcGlja2VyLnByb3RvdHlwZSwgXCJfbWluRGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VySW5wdXQgJiYgdGhpcy5fZGF0ZXBpY2tlcklucHV0Lm1pbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGF0ZXBpY2tlci5wcm90b3R5cGUsIFwiX21heERhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZXBpY2tlcklucHV0ICYmIHRoaXMuX2RhdGVwaWNrZXJJbnB1dC5tYXg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERhdGVwaWNrZXIucHJvdG90eXBlLCBcIl9kYXRlRmlsdGVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VySW5wdXQgJiYgdGhpcy5fZGF0ZXBpY2tlcklucHV0Ll9kYXRlRmlsdGVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX3BvcHVwUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFJlZi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiBkYXRlIGFuZCBjbG9zZXMgdGhlIGN1cnJlbnRseSBvcGVuIHBvcHVwIG9yIGRpYWxvZy5cbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlci5wcm90b3R5cGUuX3NlbGVjdEFuZENsb3NlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkVmFsdWUgPSB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBkYXRlO1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGVBZGFwdGVyLnNhbWVEYXRlKG9sZFZhbHVlLCB0aGlzLl9zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2VkLmVtaXQoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gaW5wdXQgd2l0aCB0aGlzIGRhdGVwaWNrZXIuXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dCBUaGUgZGF0ZXBpY2tlciBpbnB1dCB0byByZWdpc3RlciB3aXRoIHRoaXMgZGF0ZXBpY2tlci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlci5wcm90b3R5cGUuX3JlZ2lzdGVySW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2RhdGVwaWNrZXJJbnB1dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBNZERhdGVwaWNrZXIgY2FuIG9ubHkgYmUgYXNzb2NpYXRlZCB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXJJbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9pbnB1dFN1YnNjcmlwdGlvbiA9XG4gICAgICAgICAgICB0aGlzLl9kYXRlcGlja2VySW5wdXQuX3ZhbHVlQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLl9zZWxlY3RlZCA9IHZhbHVlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGNhbGVuZGFyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2RhdGVwaWNrZXJJbnB1dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gb3BlbiBhbiBNZERhdGVwaWNrZXIgd2l0aCBubyBhc3NvY2lhdGVkIGlucHV0LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hVaSA/IHRoaXMuX29wZW5Bc0RpYWxvZygpIDogdGhpcy5fb3BlbkFzUG9wdXAoKTtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGNhbGVuZGFyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wZW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wb3B1cFJlZiAmJiB0aGlzLl9wb3B1cFJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGlhbG9nUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWFsb2dSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2RpYWxvZ1JlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NhbGVuZGFyUG9ydGFsICYmIHRoaXMuX2NhbGVuZGFyUG9ydGFsLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFyUG9ydGFsLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBjYWxlbmRhciBhcyBhIGRpYWxvZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlci5wcm90b3R5cGUuX29wZW5Bc0RpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gbmV3IE1kRGlhbG9nQ29uZmlnKCk7XG4gICAgICAgIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgdGhpcy5fZGlhbG9nUmVmID0gdGhpcy5fZGlhbG9nLm9wZW4oTWREYXRlcGlja2VyQ29udGVudCwgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZGlhbG9nUmVmLmFmdGVyQ2xvc2VkKCkuZmlyc3QoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvc2UoKTsgfSk7XG4gICAgICAgIHRoaXMuX2RpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5kYXRlcGlja2VyID0gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGNhbGVuZGFyIGFzIGEgcG9wdXAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXIucHJvdG90eXBlLl9vcGVuQXNQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxlbmRhclBvcnRhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsZW5kYXJQb3J0YWwgPSBuZXcgQ29tcG9uZW50UG9ydGFsKE1kRGF0ZXBpY2tlckNvbnRlbnQsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wb3B1cFJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRSZWYgPSB0aGlzLl9wb3B1cFJlZi5hdHRhY2godGhpcy5fY2FsZW5kYXJQb3J0YWwpO1xuICAgICAgICAgICAgY29tcG9uZW50UmVmLmluc3RhbmNlLmRhdGVwaWNrZXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BvcHVwUmVmLmJhY2tkcm9wQ2xpY2soKS5maXJzdCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jbG9zZSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgcG9wdXAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXIucHJvdG90eXBlLl9jcmVhdGVQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3ZlcmxheVN0YXRlID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX2NyZWF0ZVBvcHVwUG9zaXRpb25TdHJhdGVneSgpO1xuICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgICBvdmVybGF5U3RhdGUuYmFja2Ryb3BDbGFzcyA9ICdtZC1vdmVybGF5LXRyYW5zcGFyZW50LWJhY2tkcm9wJztcbiAgICAgICAgb3ZlcmxheVN0YXRlLmRpcmVjdGlvbiA9IHRoaXMuX2RpciA/IHRoaXMuX2Rpci52YWx1ZSA6ICdsdHInO1xuICAgICAgICB0aGlzLl9wb3B1cFJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKG92ZXJsYXlTdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHBvcHVwIFBvc2l0aW9uU3RyYXRlZ3kuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXIucHJvdG90eXBlLl9jcmVhdGVQb3B1cFBvc2l0aW9uU3RyYXRlZ3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpbiA9ICh7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5ID0gKHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAndG9wJyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkucG9zaXRpb24oKS5jb25uZWN0ZWRUbyh0aGlzLl9kYXRlcGlja2VySW5wdXQuZ2V0UG9wdXBDb25uZWN0aW9uRWxlbWVudFJlZigpLCBvcmlnaW4sIG92ZXJsYXkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kRGF0ZXBpY2tlcjtcbn0oKSk7XG5NZERhdGVwaWNrZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1kYXRlcGlja2VyLCBtYXQtZGF0ZXBpY2tlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICcnLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERhdGVwaWNrZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBNZERpYWxvZywgfSxcbiAgICB7IHR5cGU6IE92ZXJsYXksIH0sXG4gICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIHsgdHlwZTogRGF0ZUFkYXB0ZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogRGlyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbl07IH07XG5NZERhdGVwaWNrZXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3N0YXJ0QXQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3N0YXJ0Vmlldyc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndG91Y2hVaSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc2VsZWN0ZWRDaGFuZ2VkJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG52YXIgTURfREFURVBJQ0tFUl9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZERhdGVwaWNrZXJJbnB1dDsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgTURfREFURVBJQ0tFUl9WQUxJREFUT1JTID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWREYXRlcGlja2VySW5wdXQ7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgdXNlZCB0byBjb25uZWN0IGFuIGlucHV0IHRvIGEgTWREYXRlcGlja2VyLlxuICovXG52YXIgTWREYXRlcGlja2VySW5wdXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9kYXRlQWRhcHRlclxuICAgICAqIEBwYXJhbSB7P30gX2RhdGVGb3JtYXRzXG4gICAgICogQHBhcmFtIHs/fSBfbWRJbnB1dENvbnRhaW5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kRGF0ZXBpY2tlcklucHV0KF9lbGVtZW50UmVmLCBfcmVuZGVyZXIsIF9kYXRlQWRhcHRlciwgX2RhdGVGb3JtYXRzLCBfbWRJbnB1dENvbnRhaW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlciA9IF9kYXRlQWRhcHRlcjtcbiAgICAgICAgdGhpcy5fZGF0ZUZvcm1hdHMgPSBfZGF0ZUZvcm1hdHM7XG4gICAgICAgIHRoaXMuX21kSW5wdXRDb250YWluZXIgPSBfbWRJbnB1dENvbnRhaW5lcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKGVpdGhlciBkdWUgdG8gdXNlciBpbnB1dCBvciBwcm9ncmFtbWF0aWMgY2hhbmdlKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMuX2N2YU9uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7IH07XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBtaW4gZGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21pblZhbGlkYXRvciA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFfdGhpcy5taW4gfHwgIWNvbnRyb2wudmFsdWUgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGF0ZUFkYXB0ZXIuY29tcGFyZURhdGUoX3RoaXMubWluLCBjb250cm9sLnZhbHVlKSA8IDApID9cbiAgICAgICAgICAgICAgICBudWxsIDogeyAnbWREYXRlcGlja2VyTWluJzogeyAnbWluJzogX3RoaXMubWluLCAnYWN0dWFsJzogY29udHJvbC52YWx1ZSB9IH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3IgdGhlIG1heCBkYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWF4VmFsaWRhdG9yID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiAoIV90aGlzLm1heCB8fCAhY29udHJvbC52YWx1ZSB8fFxuICAgICAgICAgICAgICAgIF90aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShfdGhpcy5tYXgsIGNvbnRyb2wudmFsdWUpID4gMCkgP1xuICAgICAgICAgICAgICAgIG51bGwgOiB7ICdtZERhdGVwaWNrZXJNYXgnOiB7ICdtYXgnOiBfdGhpcy5tYXgsICdhY3R1YWwnOiBjb250cm9sLnZhbHVlIH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGUgZGF0ZSBmaWx0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9maWx0ZXJWYWxpZGF0b3IgPSBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuICFfdGhpcy5fZGF0ZUZpbHRlciB8fCAhY29udHJvbC52YWx1ZSB8fCBfdGhpcy5fZGF0ZUZpbHRlcihjb250cm9sLnZhbHVlKSA/XG4gICAgICAgICAgICAgICAgbnVsbCA6IHsgJ21kRGF0ZXBpY2tlckZpbHRlcic6IHRydWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb21iaW5lZCBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGlzIGlucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFt0aGlzLl9taW5WYWxpZGF0b3IsIHRoaXMuX21heFZhbGlkYXRvciwgdGhpcy5fZmlsdGVyVmFsaWRhdG9yXSk7XG4gICAgICAgIGlmICghdGhpcy5fZGF0ZUFkYXB0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdEYXRlQWRhcHRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGF0ZUZvcm1hdHMpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdNRF9EQVRFX0ZPUk1BVFMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLCBcIm1kRGF0ZXBpY2tlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZXBpY2tlciB0aGF0IHRoaXMgaW5wdXQgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0ZXBpY2tlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuX3JlZ2lzdGVySW5wdXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUsIFwibWF0RGF0ZXBpY2tlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLm1kRGF0ZXBpY2tlciA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLCBcIm1kRGF0ZXBpY2tlckZpbHRlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZpbHRlclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRlRmlsdGVyID0gZmlsdGVyO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGF0ZXBpY2tlcklucHV0LnByb3RvdHlwZSwgXCJtYXREYXRlcGlja2VyRmlsdGVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZmlsdGVyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWREYXRlcGlja2VyRmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlQWRhcHRlci5wYXJzZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUsIHRoaXMuX2RhdGVGb3JtYXRzLnBhcnNlLmRhdGVJbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLnBhcnNlKHZhbHVlLCB0aGlzLl9kYXRlRm9ybWF0cy5wYXJzZS5kYXRlSW5wdXQpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkRGF0ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIGRhdGUgPyB0aGlzLl9kYXRlQWRhcHRlci5mb3JtYXQoZGF0ZSwgdGhpcy5fZGF0ZUZvcm1hdHMuZGlzcGxheS5kYXRlSW5wdXQpIDogJycpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlci5zYW1lRGF0ZShvbGREYXRlLCBkYXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlLmVtaXQoZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUsIFwibWluXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHZhbGlkIGRhdGUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21pbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9taW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUsIFwibWF4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHZhbGlkIGRhdGUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21heDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2RhdGVwaWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXJTdWJzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2VsZWN0ZWRDaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2N2YU9uQ2hhbmdlKHNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRlcGlja2VyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRlcGlja2VyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlcklucHV0LnByb3RvdHlwZS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlcklucHV0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IgPyB0aGlzLl92YWxpZGF0b3IoYykgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCB0aGF0IHRoZSBkYXRlcGlja2VyIHBvcHVwIHNob3VsZCBiZSBjb25uZWN0ZWQgdG8uXG4gICAgICogQHJldHVybiB7P30gVGhlIGVsZW1lbnQgdG8gY29ubmVjdCB0aGUgcG9wdXAgdG8uXG4gICAgICovXG4gICAgTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLmdldFBvcHVwQ29ubmVjdGlvbkVsZW1lbnRSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZElucHV0Q29udGFpbmVyID8gdGhpcy5fbWRJbnB1dENvbnRhaW5lci51bmRlcmxpbmVSZWYgOiB0aGlzLl9lbGVtZW50UmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fY3ZhT25DaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlcklucHV0LnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlzYWJsZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlcklucHV0LnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgZGlzYWJsZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLl9vbktleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmFsdEtleSAmJiBldmVudC5rZXlDb2RlID09PSBET1dOX0FSUk9XKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRlcGlja2VyLm9wZW4oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlcklucHV0LnByb3RvdHlwZS5fb25JbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIucGFyc2UodmFsdWUsIHRoaXMuX2RhdGVGb3JtYXRzLnBhcnNlLmRhdGVJbnB1dCk7XG4gICAgICAgIHRoaXMuX2N2YU9uQ2hhbmdlKGRhdGUpO1xuICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZS5lbWl0KGRhdGUpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kRGF0ZXBpY2tlcklucHV0O1xufSgpKTtcbk1kRGF0ZXBpY2tlcklucHV0LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFttZERhdGVwaWNrZXJdLCBpbnB1dFttYXREYXRlcGlja2VyXScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfREFURVBJQ0tFUl9WQUxVRV9BQ0NFU1NPUiwgTURfREFURVBJQ0tFUl9WQUxJREFUT1JTXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdfZGF0ZXBpY2tlcj8ub3BlbmVkIHx8IFwiZmFsc2VcIicsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWhhc3BvcHVwXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtb3duc10nOiAnX2RhdGVwaWNrZXI/LmlkJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLm1pbl0nOiAnbWluID8gX2RhdGVBZGFwdGVyLmdldElTT0RhdGVTdHJpbmcobWluKSA6IG51bGwnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIubWF4XSc6ICdtYXggPyBfZGF0ZUFkYXB0ZXIuZ2V0SVNPRGF0ZVN0cmluZyhtYXgpIDogbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ19vbklucHV0KCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdfb25Ub3VjaGVkKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19vbktleWRvd24oJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERhdGVwaWNrZXJJbnB1dC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBEYXRlQWRhcHRlciwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTURfREFURV9GT1JNQVRTLF0gfSxdIH0sXG4gICAgeyB0eXBlOiBNZElucHV0Q29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbl07IH07XG5NZERhdGVwaWNrZXJJbnB1dC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnbWREYXRlcGlja2VyJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtYXREYXRlcGlja2VyJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtZERhdGVwaWNrZXJGaWx0ZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ21hdERhdGVwaWNrZXJGaWx0ZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtaW4nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ21heCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG52YXIgTWREYXRlcGlja2VyVG9nZ2xlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfaW50bFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kRGF0ZXBpY2tlclRvZ2dsZShfaW50bCkge1xuICAgICAgICB0aGlzLl9pbnRsID0gX2ludGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlIG9mIHRoZSBidXR0b24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnYnV0dG9uJztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGF0ZXBpY2tlclRvZ2dsZS5wcm90b3R5cGUsIFwiX2RhdGVwaWNrZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRlcGlja2VyOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuZGF0ZXBpY2tlciA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlclRvZ2dsZS5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZXBpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5kYXRlcGlja2VyLm9wZW4oKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWREYXRlcGlja2VyVG9nZ2xlO1xufSgpKTtcbk1kRGF0ZXBpY2tlclRvZ2dsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2J1dHRvblttZERhdGVwaWNrZXJUb2dnbGVdLCBidXR0b25bbWF0RGF0ZXBpY2tlclRvZ2dsZV0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnJyxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtZGF0ZXBpY2tlci10b2dnbGV7ZGlzcGxheTppbmxpbmUtYmxvY2s7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkhCNElpQm9aV2xuYUhROUlqSTBjSGdpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ1ptbHNiRDBpWTNWeWNtVnVkRU52Ykc5eUlqNDhjR0YwYUNCa1BTSk5NQ0F3YURJMGRqSTBTREI2SWlCbWFXeHNQU0p1YjI1bElpOCtQSEJoZEdnZ1pEMGlUVEU1SUROb0xURldNV2d0TW5ZeVNEaFdNVWcyZGpKSU5XTXRNUzR4TVNBd0xURXVPVGt1T1MweExqazVJREpNTXlBeE9XTXdJREV1TVM0NE9TQXlJRElnTW1neE5HTXhMakVnTUNBeUxTNDVJREl0TWxZMVl6QXRNUzR4TFM0NUxUSXRNaTB5ZW0wd0lERTJTRFZXT0dneE5IWXhNWHBOTnlBeE1HZzFkalZJTjNvaUx6NDhMM04yWno0PSkgbm8tcmVwZWF0O2JhY2tncm91bmQtc2l6ZTpjb250YWluO2hlaWdodDoyNHB4O3dpZHRoOjI0cHg7Ym9yZGVyOm5vbmU7b3V0bGluZTowO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWF0LWRhdGVwaWNrZXItdG9nZ2xlOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn0gLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZXBpY2tlci10b2dnbGUuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2F0dHIudHlwZV0nOiAndHlwZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWRhdGVwaWNrZXItdG9nZ2xlXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtbGFiZWxdJzogJ19pbnRsLm9wZW5DYWxlbmRhckxhYmVsJyxcbiAgICAgICAgICAgICAgICAgICAgJyhjbGljayknOiAnX29wZW4oJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERhdGVwaWNrZXJUb2dnbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBNZERhdGVwaWNrZXJJbnRsLCB9LFxuXTsgfTtcbk1kRGF0ZXBpY2tlclRvZ2dsZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnZGF0ZXBpY2tlcic6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kRGF0ZXBpY2tlclRvZ2dsZScsXSB9LF0sXG4gICAgJ3R5cGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ19kYXRlcGlja2VyJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0RGF0ZXBpY2tlclRvZ2dsZScsXSB9LF0sXG59O1xudmFyIE1kRGF0ZXBpY2tlck1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGF0ZXBpY2tlck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kRGF0ZXBpY2tlck1vZHVsZTtcbn0oKSk7XG5NZERhdGVwaWNrZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZEJ1dHRvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWREaWFsb2dNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFN0eWxlTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBNZERhdGVwaWNrZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kRGF0ZXBpY2tlckNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIE1kRGF0ZXBpY2tlcklucHV0LFxuICAgICAgICAgICAgICAgICAgICBNZERhdGVwaWNrZXJUb2dnbGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRDYWxlbmRhcixcbiAgICAgICAgICAgICAgICAgICAgTWRDYWxlbmRhckJvZHksXG4gICAgICAgICAgICAgICAgICAgIE1kRGF0ZXBpY2tlcixcbiAgICAgICAgICAgICAgICAgICAgTWREYXRlcGlja2VyQ29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgTWREYXRlcGlja2VySW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIE1kRGF0ZXBpY2tlclRvZ2dsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRNb250aFZpZXcsXG4gICAgICAgICAgICAgICAgICAgIE1kWWVhclZpZXcsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWREYXRlcGlja2VySW50bCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICBNZERhdGVwaWNrZXJDb250ZW50LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWREYXRlcGlja2VyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTUFURVJJQUxfTU9EVUxFUyA9IFtcbiAgICBNZEF1dG9jb21wbGV0ZU1vZHVsZSxcbiAgICBNZEJ1dHRvbk1vZHVsZSxcbiAgICBNZEJ1dHRvblRvZ2dsZU1vZHVsZSxcbiAgICBNZENhcmRNb2R1bGUsXG4gICAgTWRDaGlwc01vZHVsZSxcbiAgICBNZENoZWNrYm94TW9kdWxlLFxuICAgIE1kRGF0ZXBpY2tlck1vZHVsZSxcbiAgICBNZERpYWxvZ01vZHVsZSxcbiAgICBNZEdyaWRMaXN0TW9kdWxlLFxuICAgIE1kSWNvbk1vZHVsZSxcbiAgICBNZElucHV0TW9kdWxlLFxuICAgIE1kTGlzdE1vZHVsZSxcbiAgICBNZE1lbnVNb2R1bGUsXG4gICAgTWRQcm9ncmVzc0Jhck1vZHVsZSxcbiAgICBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZSxcbiAgICBNZFJhZGlvTW9kdWxlLFxuICAgIE1kUmlwcGxlTW9kdWxlLFxuICAgIE1kU2VsZWN0TW9kdWxlLFxuICAgIE1kU2lkZW5hdk1vZHVsZSxcbiAgICBNZFNsaWRlck1vZHVsZSxcbiAgICBNZFNsaWRlVG9nZ2xlTW9kdWxlLFxuICAgIE1kU25hY2tCYXJNb2R1bGUsXG4gICAgTWRUYWJzTW9kdWxlLFxuICAgIE1kVG9vbGJhck1vZHVsZSxcbiAgICBNZFRvb2x0aXBNb2R1bGUsXG4gICAgT3ZlcmxheU1vZHVsZSxcbiAgICBQb3J0YWxNb2R1bGUsXG4gICAgUnRsTW9kdWxlLFxuICAgIFN0eWxlTW9kdWxlLFxuICAgIEExMXlNb2R1bGUsXG4gICAgUGxhdGZvcm1Nb2R1bGUsXG4gICAgTWRDb21tb25Nb2R1bGUsXG4gICAgT2JzZXJ2ZUNvbnRlbnRNb2R1bGUsXG5dO1xuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgTWF0ZXJpYWxNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRlcmlhbE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGVyaWFsTW9kdWxlO1xufSgpKTtcbk1hdGVyaWFsTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBNQVRFUklBTF9NT0RVTEVTLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IE1BVEVSSUFMX01PRFVMRVMsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1hdGVyaWFsTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBwdWJsaWMgQVBJcyBvZiBBbmd1bGFyIE1hdGVyaWFsLlxuICovXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5leHBvcnQgeyBEaXIsIFJ0bE1vZHVsZSwgT2JzZXJ2ZUNvbnRlbnRNb2R1bGUsIE9ic2VydmVDb250ZW50LCBNZE9wdGlvbk1vZHVsZSwgTWRPcHRpb24sIE1kT3B0aW9uU2VsZWN0aW9uQ2hhbmdlLCBQb3J0YWwsIEJhc2VQb3J0YWxIb3N0LCBDb21wb25lbnRQb3J0YWwsIFRlbXBsYXRlUG9ydGFsLCBQb3J0YWxIb3N0RGlyZWN0aXZlLCBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSwgUG9ydGFsTW9kdWxlLCBEb21Qb3J0YWxIb3N0LCBHZXN0dXJlQ29uZmlnLCBMaXZlQW5ub3VuY2VyLCBMSVZFX0FOTk9VTkNFUl9FTEVNRU5UX1RPS0VOLCBMSVZFX0FOTk9VTkNFUl9QUk9WSURFUiwgSW50ZXJhY3Rpdml0eUNoZWNrZXIsIGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIsIEExMXlNb2R1bGUsIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIsIFVOSVFVRV9TRUxFQ1RJT05fRElTUEFUQ0hFUl9QUk9WSURFUiwgTWRMaW5lTW9kdWxlLCBNZExpbmUsIE1kTGluZVNldHRlciwgY29lcmNlQm9vbGVhblByb3BlcnR5LCBjb2VyY2VOdW1iZXJQcm9wZXJ0eSwgQ29tcGF0aWJpbGl0eU1vZHVsZSwgTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGUsIE1kQ29tbW9uTW9kdWxlLCBNZENvcmVNb2R1bGUsIFBsYXRmb3JtTW9kdWxlLCBQbGF0Zm9ybSwgZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcywgT3ZlcmxheSwgT1ZFUkxBWV9QUk9WSURFUlMsIE92ZXJsYXlDb250YWluZXIsIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyLCBPdmVybGF5UmVmLCBPdmVybGF5U3RhdGUsIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUsIE92ZXJsYXlPcmlnaW4sIE92ZXJsYXlNb2R1bGUsIFZpZXdwb3J0UnVsZXIsIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3ksIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIsIFNjcm9sbGFibGVWaWV3UHJvcGVydGllcywgQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlLCBTY3JvbGxhYmxlLCBTY3JvbGxEaXNwYXRjaGVyLCBSZXBvc2l0aW9uU2Nyb2xsU3RyYXRlZ3ksIENsb3NlU2Nyb2xsU3RyYXRlZ3ksIE5vb3BTY3JvbGxTdHJhdGVneSwgQmxvY2tTY3JvbGxTdHJhdGVneSwgU2Nyb2xsRGlzcGF0Y2hNb2R1bGUsIE1kUmlwcGxlLCBNRF9SSVBQTEVfR0xPQkFMX09QVElPTlMsIFJpcHBsZVJlZiwgUmlwcGxlU3RhdGUsIFJJUFBMRV9GQURFX0lOX0RVUkFUSU9OLCBSSVBQTEVfRkFERV9PVVRfRFVSQVRJT04sIE1kUmlwcGxlTW9kdWxlLCBTZWxlY3Rpb25Nb2RlbCwgU2VsZWN0aW9uQ2hhbmdlLCBGb2N1c1RyYXAsIEZvY3VzVHJhcEZhY3RvcnksIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUsIEZvY3VzVHJhcERpcmVjdGl2ZSwgU3R5bGVNb2R1bGUsIFRPVUNIX0JVRkZFUl9NUywgRm9jdXNPcmlnaW5Nb25pdG9yLCBDZGtNb25pdG9yRm9jdXMsIEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSX0ZBQ1RPUlksIEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSLCBhcHBseUNzc1RyYW5zZm9ybSwgVVBfQVJST1csIERPV05fQVJST1csIFJJR0hUX0FSUk9XLCBMRUZUX0FSUk9XLCBQQUdFX1VQLCBQQUdFX0RPV04sIEhPTUUsIEVORCwgRU5URVIsIFNQQUNFLCBUQUIsIEVTQ0FQRSwgQkFDS1NQQUNFLCBERUxFVEUsIE1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSwgTUFURVJJQUxfU0FOSVRZX0NIRUNLUywgZ2V0TWRDb21wYXRpYmlsaXR5SW52YWxpZFByZWZpeEVycm9yLCBNQVRfRUxFTUVOVFNfU0VMRUNUT1IsIE1EX0VMRU1FTlRTX1NFTEVDVE9SLCBNYXRQcmVmaXhSZWplY3RvciwgTWRQcmVmaXhSZWplY3RvciwgQW5pbWF0aW9uQ3VydmVzLCBBbmltYXRpb25EdXJhdGlvbnMsIE1kU2VsZWN0aW9uTW9kdWxlLCBNZFBzZXVkb0NoZWNrYm94LCBOYXRpdmVEYXRlTW9kdWxlLCBNZE5hdGl2ZURhdGVNb2R1bGUsIERhdGVBZGFwdGVyLCBNRF9EQVRFX0ZPUk1BVFMsIE5hdGl2ZURhdGVBZGFwdGVyLCBNRF9OQVRJVkVfREFURV9GT1JNQVRTLCBNYXRlcmlhbE1vZHVsZSwgTWRBdXRvY29tcGxldGVNb2R1bGUsIE1kQXV0b2NvbXBsZXRlLCBBVVRPQ09NUExFVEVfT1BUSU9OX0hFSUdIVCwgQVVUT0NPTVBMRVRFX1BBTkVMX0hFSUdIVCwgTURfQVVUT0NPTVBMRVRFX1ZBTFVFX0FDQ0VTU09SLCBNZEF1dG9jb21wbGV0ZVRyaWdnZXIsIE1kQnV0dG9uTW9kdWxlLCBNZEJ1dHRvbkNzc01hdFN0eWxlciwgTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIsIE1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlciwgTWRGYWJDc3NNYXRTdHlsZXIsIE1kTWluaUZhYkNzc01hdFN0eWxlciwgTWRCdXR0b25CYXNlLCBfTWRCdXR0b25NaXhpbkJhc2UsIE1kQnV0dG9uLCBNZEFuY2hvciwgTWRCdXR0b25Ub2dnbGVNb2R1bGUsIE1EX0JVVFRPTl9UT0dHTEVfR1JPVVBfVkFMVUVfQUNDRVNTT1IsIE1kQnV0dG9uVG9nZ2xlQ2hhbmdlLCBNZEJ1dHRvblRvZ2dsZUdyb3VwLCBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUsIE1kQnV0dG9uVG9nZ2xlLCBNZENhcmRNb2R1bGUsIE1kQ2FyZENvbnRlbnQsIE1kQ2FyZFRpdGxlLCBNZENhcmRTdWJ0aXRsZSwgTWRDYXJkQWN0aW9ucywgTWRDYXJkRm9vdGVyLCBNZENhcmRTbUltYWdlLCBNZENhcmRNZEltYWdlLCBNZENhcmRMZ0ltYWdlLCBNZENhcmRJbWFnZSwgTWRDYXJkWGxJbWFnZSwgTWRDYXJkQXZhdGFyLCBNZENhcmQsIE1kQ2FyZEhlYWRlciwgTWRDYXJkVGl0bGVHcm91cCwgTWRDaGlwc01vZHVsZSwgTWRDaGlwTGlzdCwgTWRDaGlwLCBNZENoZWNrYm94TW9kdWxlLCBNRF9DSEVDS0JPWF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLCBUcmFuc2l0aW9uQ2hlY2tTdGF0ZSwgTWRDaGVja2JveENoYW5nZSwgTWRDaGVja2JveEJhc2UsIF9NZENoZWNrYm94TWl4aW5CYXNlLCBNZENoZWNrYm94LCBNZERhdGVwaWNrZXJNb2R1bGUsIE1kQ2FsZW5kYXIsIE1kQ2FsZW5kYXJDZWxsLCBNZENhbGVuZGFyQm9keSwgTWREYXRlcGlja2VyQ29udGVudCwgTWREYXRlcGlja2VyLCBNRF9EQVRFUElDS0VSX1ZBTFVFX0FDQ0VTU09SLCBNRF9EQVRFUElDS0VSX1ZBTElEQVRPUlMsIE1kRGF0ZXBpY2tlcklucHV0LCBNZERhdGVwaWNrZXJJbnRsLCBNZERhdGVwaWNrZXJUb2dnbGUsIE1kTW9udGhWaWV3LCBNZFllYXJWaWV3LCBNZERpYWxvZ01vZHVsZSwgTURfRElBTE9HX0RBVEEsIE1kRGlhbG9nLCB0aHJvd01kRGlhbG9nQ29udGVudEFscmVhZHlBdHRhY2hlZEVycm9yLCBNZERpYWxvZ0NvbnRhaW5lciwgTWREaWFsb2dDbG9zZSwgTWREaWFsb2dUaXRsZSwgTWREaWFsb2dDb250ZW50LCBNZERpYWxvZ0FjdGlvbnMsIE1kRGlhbG9nQ29uZmlnLCBNZERpYWxvZ1JlZiwgTWRHcmlkTGlzdE1vZHVsZSwgTWRHcmlkVGlsZSwgTWRHcmlkTGlzdCwgTWRJY29uTW9kdWxlLCBNZEljb24sIGdldE1kSWNvbk5hbWVOb3RGb3VuZEVycm9yLCBnZXRNZEljb25Ob0h0dHBQcm92aWRlckVycm9yLCBNZEljb25SZWdpc3RyeSwgSUNPTl9SRUdJU1RSWV9QUk9WSURFUl9GQUNUT1JZLCBJQ09OX1JFR0lTVFJZX1BST1ZJREVSLCBNZElucHV0TW9kdWxlLCBNZFRleHRhcmVhQXV0b3NpemUsIE1kUGxhY2Vob2xkZXIsIE1kSGludCwgTWRFcnJvckRpcmVjdGl2ZSwgTWRQcmVmaXgsIE1kU3VmZml4LCBNZElucHV0RGlyZWN0aXZlLCBNZElucHV0Q29udGFpbmVyLCBnZXRNZElucHV0Q29udGFpbmVyUGxhY2Vob2xkZXJDb25mbGljdEVycm9yLCBnZXRNZElucHV0Q29udGFpbmVyVW5zdXBwb3J0ZWRUeXBlRXJyb3IsIGdldE1kSW5wdXRDb250YWluZXJEdXBsaWNhdGVkSGludEVycm9yLCBnZXRNZElucHV0Q29udGFpbmVyTWlzc2luZ01kSW5wdXRFcnJvciwgTWRMaXN0TW9kdWxlLCBNZExpc3REaXZpZGVyLCBNZExpc3QsIE1kTGlzdENzc01hdFN0eWxlciwgTWROYXZMaXN0Q3NzTWF0U3R5bGVyLCBNZERpdmlkZXJDc3NNYXRTdHlsZXIsIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlciwgTWRMaXN0SWNvbkNzc01hdFN0eWxlciwgTWRMaXN0U3ViaGVhZGVyQ3NzTWF0U3R5bGVyLCBNZExpc3RJdGVtLCBNZE1lbnVNb2R1bGUsIGZhZGVJbkl0ZW1zLCB0cmFuc2Zvcm1NZW51LCBNZE1lbnUsIE1kTWVudUl0ZW0sIE1kTWVudVRyaWdnZXIsIE1kUHJvZ3Jlc3NCYXJNb2R1bGUsIE1kUHJvZ3Jlc3NCYXIsIE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlLCBQUk9HUkVTU19TUElOTkVSX1NUUk9LRV9XSURUSCwgTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXIsIE1kUHJvZ3Jlc3NTcGlubmVyLCBNZFNwaW5uZXIsIE1kUmFkaW9Nb2R1bGUsIE1EX1JBRElPX0dST1VQX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsIE1kUmFkaW9DaGFuZ2UsIE1kUmFkaW9Hcm91cEJhc2UsIF9NZFJhZGlvR3JvdXBNaXhpbkJhc2UsIE1kUmFkaW9Hcm91cCwgTWRSYWRpb0J1dHRvbiwgTWRTZWxlY3RNb2R1bGUsIGZhZGVJbkNvbnRlbnQsIHRyYW5zZm9ybVBhbmVsLCB0cmFuc2Zvcm1QbGFjZWhvbGRlciwgU0VMRUNUX09QVElPTl9IRUlHSFQsIFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hULCBTRUxFQ1RfTUFYX09QVElPTlNfRElTUExBWUVELCBTRUxFQ1RfVFJJR0dFUl9IRUlHSFQsIFNFTEVDVF9PUFRJT05fSEVJR0hUX0FESlVTVE1FTlQsIFNFTEVDVF9QQU5FTF9QQURESU5HX1gsIFNFTEVDVF9NVUxUSVBMRV9QQU5FTF9QQURESU5HX1gsIFNFTEVDVF9QQU5FTF9QQURESU5HX1ksIFNFTEVDVF9QQU5FTF9WSUVXUE9SVF9QQURESU5HLCBNZFNlbGVjdENoYW5nZSwgTWRTZWxlY3QsIE1kU2lkZW5hdk1vZHVsZSwgdGhyb3dNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IsIE1kU2lkZW5hdlRvZ2dsZVJlc3VsdCwgTWRTaWRlbmF2LCBNZFNpZGVuYXZDb250YWluZXIsIE1kU2xpZGVyTW9kdWxlLCBNRF9TTElERVJfVkFMVUVfQUNDRVNTT1IsIE1kU2xpZGVyQ2hhbmdlLCBNZFNsaWRlckJhc2UsIF9NZFNsaWRlck1peGluQmFzZSwgTWRTbGlkZXIsIFNsaWRlclJlbmRlcmVyLCBNZFNsaWRlVG9nZ2xlTW9kdWxlLCBNRF9TTElERV9UT0dHTEVfVkFMVUVfQUNDRVNTT1IsIE1kU2xpZGVUb2dnbGVDaGFuZ2UsIE1kU2xpZGVUb2dnbGVCYXNlLCBfTWRTbGlkZVRvZ2dsZU1peGluQmFzZSwgTWRTbGlkZVRvZ2dsZSwgTWRTbmFja0Jhck1vZHVsZSwgTWRTbmFja0JhciwgU0hPV19BTklNQVRJT04sIEhJREVfQU5JTUFUSU9OLCBNZFNuYWNrQmFyQ29udGFpbmVyLCBNZFNuYWNrQmFyQ29uZmlnLCBNZFNuYWNrQmFyUmVmLCBTaW1wbGVTbmFja0JhciwgTWRUYWJzTW9kdWxlLCBNZElua0JhciwgTWRUYWJCb2R5LCBNZFRhYkhlYWRlciwgTWRUYWJMYWJlbFdyYXBwZXIsIE1kVGFiLCBNZFRhYkxhYmVsLCBNZFRhYkNoYW5nZUV2ZW50LCBNZFRhYkdyb3VwLCBNZFRhYk5hdkJhciwgTWRUYWJMaW5rLCBNZFRhYkxpbmtSaXBwbGUsIE1kVG9vbGJhck1vZHVsZSwgTWRUb29sYmFyUm93LCBNZFRvb2xiYXIsIE1kVG9vbHRpcE1vZHVsZSwgVE9VQ0hFTkRfSElERV9ERUxBWSwgU0NST0xMX1RIUk9UVExFX01TLCB0aHJvd01kVG9vbHRpcEludmFsaWRQb3NpdGlvbkVycm9yLCBNZFRvb2x0aXAsIFRvb2x0aXBDb21wb25lbnQsIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSX0ZBQ1RPUlkgYXMgybVpLCBtaXhpbkRpc2FibGVkIGFzIMm1cCwgVU5JUVVFX1NFTEVDVElPTl9ESVNQQVRDSEVSX1BST1ZJREVSX0ZBQ1RPUlkgYXMgybVqLCBNZE11dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5IGFzIMm1YSwgT1ZFUkxBWV9DT05UQUlORVJfUFJPVklERVIgYXMgybVjLCBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUl9GQUNUT1JZIGFzIMm1YiwgT3ZlcmxheVBvc2l0aW9uQnVpbGRlciBhcyDJtW8sIFZJRVdQT1JUX1JVTEVSX1BST1ZJREVSIGFzIMm1ZSwgVklFV1BPUlRfUlVMRVJfUFJPVklERVJfRkFDVE9SWSBhcyDJtWQsIFNDUk9MTF9ESVNQQVRDSEVSX1BST1ZJREVSIGFzIMm1ZywgU0NST0xMX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWSBhcyDJtWYsIFJpcHBsZVJlbmRlcmVyIGFzIMm1aCwgTWRHcmlkQXZhdGFyQ3NzTWF0U3R5bGVyIGFzIMm1bCwgTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlciBhcyDJtW4sIE1kR3JpZFRpbGVIZWFkZXJDc3NNYXRTdHlsZXIgYXMgybVtLCBNZEdyaWRUaWxlVGV4dCBhcyDJtWsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGVyaWFsLmVzNS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AYW5ndWxhci9tYXRlcmlhbC9AYW5ndWxhci9tYXRlcmlhbC5lczUuanNcbi8vIG1vZHVsZSBpZCA9IDUwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9')\n},505:function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n// \\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar router_1 = __webpack_require__(143);\\r\\nvar login_1 = __webpack_require__(220);\\r\\nvar home_1 = __webpack_require__(219);\\r\\nvar datav_1 = __webpack_require__(218);\\r\\nvar blog_list_1 = __webpack_require__(217);\\r\\nvar blog_edit_1 = __webpack_require__(216);\\r\\nvar routes = [\\r\\n    { path: 'login', component: login_1.LoginComponent },\\r\\n    { path: 'datav', component: datav_1.DatavComponent },\\r\\n    { path: 'bloglist', component: blog_list_1.BlogListComponent },\\r\\n    { path: 'blogedit', component: blog_edit_1.BlogEditComponent },\\r\\n    { path: '', component: home_1.HomeComponent },\\r\\n    { path: '', redirectTo: '', pathMatch: 'full' },\\r\\n];\\r\\nvar AppRoutingModule = (function () {\\r\\n    function AppRoutingModule() {\\r\\n    }\\r\\n    return AppRoutingModule;\\r\\n}());\\r\\nAppRoutingModule = __decorate([\\r\\n    core_1.NgModule({\\r\\n        imports: [\\r\\n            router_1.RouterModule.forRoot(routes)\\r\\n        ],\\r\\n        exports: [router_1.RouterModule]\\r\\n    })\\r\\n], AppRoutingModule);\\r\\nexports.AppRoutingModule = AppRoutingModule;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9hcHAtcm91dGluZy5tb2R1bGUudHM/YmRlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIOW8leWFpeaguOW/g+aooeWdl1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlck1vZHVsZSwgUm91dGVzIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuaW1wb3J0IHsgTG9naW5Db21wb25lbnQgfSBmcm9tICcuL2xvZ2luJztcbmltcG9ydCB7IEhvbWVDb21wb25lbnQgfSBmcm9tICcuL2hvbWUnO1xuaW1wb3J0IHsgRGF0YXZDb21wb25lbnQgfSBmcm9tICcuL2RhdGF2JztcbmltcG9ydCB7IEJsb2dMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi9ibG9nLWxpc3QnO1xuaW1wb3J0IHsgQmxvZ0VkaXRDb21wb25lbnQgfSBmcm9tICcuL2Jsb2ctZWRpdCc7XG5cbmNvbnN0IHJvdXRlczogUm91dGVzID0gW1xuICB7cGF0aDogJ2xvZ2luJywgY29tcG9uZW50OiBMb2dpbkNvbXBvbmVudH0sXG4gIHtwYXRoOiAnZGF0YXYnLCBjb21wb25lbnQ6IERhdGF2Q29tcG9uZW50fSxcbiAge3BhdGg6ICdibG9nbGlzdCcsIGNvbXBvbmVudDogQmxvZ0xpc3RDb21wb25lbnR9LFxuICB7cGF0aDogJ2Jsb2dlZGl0JywgY29tcG9uZW50OiBCbG9nRWRpdENvbXBvbmVudH0sXG4gIHtwYXRoOiAnJywgY29tcG9uZW50OiBIb21lQ29tcG9uZW50fSxcbiAgeyBwYXRoOiAnJywgcmVkaXJlY3RUbzogJycsIHBhdGhNYXRjaDogJ2Z1bGwnfSxcbiAgLy8geyBwYXRoOiAnKionLCBjb21wb25lbnQ6IFBhZ2VOb3RGb3VuZENvbXBvbmVudCB9XG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgUm91dGVyTW9kdWxlLmZvclJvb3Qocm91dGVzKVxuICBdLFxuICBleHBvcnRzOiBbUm91dGVyTW9kdWxlXVxufSlcblxuZXhwb3J0IGNsYXNzIEFwcFJvdXRpbmdNb2R1bGUgeyB9XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi90c2xpbnQtbG9hZGVyPz9yZWYtLTAtMCEuL3NyYy9hcHAvYXBwLXJvdXRpbmcubW9kdWxlLnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBU0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\")},506:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\n// \\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nvar __metadata = (this && this.__metadata) || function (k, v) {\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar router_1 = __webpack_require__(143);\\r\\nvar moment = __webpack_require__(1);\\r\\n__webpack_require__(181);\\r\\n__webpack_require__(669);\\r\\nvar AppComponent = (function () {\\r\\n    function AppComponent(route, router) {\\r\\n        this.route = route;\\r\\n        this.router = router;\\r\\n    }\\r\\n    AppComponent.prototype.ngOnInit = function () {\\r\\n        // this.goToLogin();\\r\\n        this.currentTime = moment().format(\\'ddd MMM Do YYYY\\');\\r\\n    };\\r\\n    AppComponent.prototype.goToLogin = function () {\\r\\n        var a = this.route.params;\\r\\n        this.router.navigate([\\'/login\\']);\\r\\n    };\\r\\n    return AppComponent;\\r\\n}());\\r\\nAppComponent = __decorate([\\r\\n    core_1.Component({\\r\\n        selector: \\'cv-app\\',\\r\\n        template: __webpack_require__(856),\\r\\n        styles: [__webpack_require__(965)]\\r\\n    }),\\r\\n    __metadata(\"design:paramtypes\", [router_1.ActivatedRoute,\\r\\n        router_1.Router])\\r\\n], AppComponent);\\r\\nexports.AppComponent = AppComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9hcHAuY29tcG9uZW50LnRzP2JhMDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8g5byV5YWl5Z+65pys5qC35byP5paH5Lu2XG5cbmltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIsIEFjdGl2YXRlZFJvdXRlLCBQYXJhbXMgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcCc7XG5pbXBvcnQgJy4uL2Fzc2V0cy9zY3NzL2NvbW1vbi5zY3NzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY3YtYXBwJyxcbiAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYXBwLmNvbXBvbmVudC5odG1sJyksXG4gIHN0eWxlczogW3JlcXVpcmUoJy4vYXBwLmNvbXBvbmVudC5zY3NzJyldXG59KVxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIHB1YmxpYyBjdXJyZW50VGltZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcm91dGU6IEFjdGl2YXRlZFJvdXRlLFxuICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXJcbiAgKSB7IH1cblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgLy8gdGhpcy5nb1RvTG9naW4oKTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gbW9tZW50KCkuZm9ybWF0KCdkZGQgTU1NIERvIFlZWVknKTtcbiAgfVxuXG4gIHByaXZhdGUgZ29Ub0xvZ2luKCkge1xuICAgIGNvbnN0IGEgPSB0aGlzLnJvdXRlLnBhcmFtcztcbiAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbJy9sb2dpbiddKTtcbiAgfVxuXG4gfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9hcHAuY29tcG9uZW50LnRzIl0sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQWxCQTtBQUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBTEE7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=')},507:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar platform_browser_1 = __webpack_require__(46);\\r\\nvar animations_1 = __webpack_require__(215);\\r\\nvar material_1 = __webpack_require__(502);\\r\\n// flex layout\\r\\nvar flex_layout_1 = __webpack_require__(201);\\r\\nvar app_routing_module_1 = __webpack_require__(505);\\r\\nvar app_component_1 = __webpack_require__(506);\\r\\nvar login_1 = __webpack_require__(220);\\r\\nvar home_1 = __webpack_require__(219);\\r\\nvar datav_1 = __webpack_require__(218);\\r\\nvar blog_list_1 = __webpack_require__(217);\\r\\nvar blog_edit_1 = __webpack_require__(216);\\r\\nvar AppModule = (function () {\\r\\n    function AppModule() {\\r\\n    }\\r\\n    return AppModule;\\r\\n}());\\r\\nAppModule = __decorate([\\r\\n    core_1.NgModule({\\r\\n        imports: [\\r\\n            platform_browser_1.BrowserModule,\\r\\n            animations_1.BrowserAnimationsModule,\\r\\n            material_1.MdButtonModule,\\r\\n            material_1.MdCheckboxModule,\\r\\n            material_1.MdToolbarModule,\\r\\n            material_1.MdIconModule,\\r\\n            material_1.MdMenuModule,\\r\\n            material_1.MdProgressSpinnerModule,\\r\\n            material_1.MdCardModule,\\r\\n            material_1.MdInputModule,\\r\\n            material_1.MdGridListModule,\\r\\n            flex_layout_1.FlexLayoutModule,\\r\\n            app_routing_module_1.AppRoutingModule\\r\\n        ],\\r\\n        declarations: [\\r\\n            app_component_1.AppComponent,\\r\\n            login_1.LoginComponent,\\r\\n            home_1.HomeComponent,\\r\\n            datav_1.DatavComponent,\\r\\n            blog_list_1.BlogListComponent,\\r\\n            blog_edit_1.BlogEditComponent\\r\\n        ],\\r\\n        bootstrap: [app_component_1.AppComponent]\\r\\n    })\\r\\n], AppModule);\\r\\nexports.AppModule = AppModule;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9hcHAubW9kdWxlLnRzPzViZWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgSHR0cE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuXG5cbmltcG9ydCB7IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9hbmltYXRpb25zJztcbmltcG9ydCB7XG4gIE1kQnV0dG9uTW9kdWxlLFxuICBNZENoZWNrYm94TW9kdWxlLFxuICBNZFRvb2xiYXJNb2R1bGUsXG4gIE1kSWNvbk1vZHVsZSxcbiAgTWRNZW51TW9kdWxlLFxuICBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZSxcbiAgTWRDYXJkTW9kdWxlLFxuICBNZElucHV0TW9kdWxlLFxuICBNZEdyaWRMaXN0TW9kdWxlXG59IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcblxuLy8gZmxleCBsYXlvdXRcbmltcG9ydCB7IEZsZXhMYXlvdXRNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mbGV4LWxheW91dCc7XG5cbmltcG9ydCB7IEFwcFJvdXRpbmdNb2R1bGUgfSBmcm9tICcuL2FwcC1yb3V0aW5nLm1vZHVsZSc7XG5cbmltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IExvZ2luQ29tcG9uZW50IH0gZnJvbSAnLi9sb2dpbic7XG5pbXBvcnQgeyBIb21lQ29tcG9uZW50IH0gZnJvbSAnLi9ob21lJztcbmltcG9ydCB7IERhdGF2Q29tcG9uZW50IH0gZnJvbSAnLi9kYXRhdic7XG5pbXBvcnQgeyBCbG9nTGlzdENvbXBvbmVudCB9IGZyb20gJy4vYmxvZy1saXN0JztcbmltcG9ydCB7IEJsb2dFZGl0Q29tcG9uZW50IH0gZnJvbSAnLi9ibG9nLWVkaXQnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQnJvd3Nlck1vZHVsZSxcbiAgICBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSxcbiAgICBNZEJ1dHRvbk1vZHVsZSxcbiAgICBNZENoZWNrYm94TW9kdWxlLFxuICAgIE1kVG9vbGJhck1vZHVsZSxcbiAgICBNZEljb25Nb2R1bGUsXG4gICAgTWRNZW51TW9kdWxlLFxuICAgIE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlLFxuICAgIE1kQ2FyZE1vZHVsZSxcbiAgICBNZElucHV0TW9kdWxlLFxuICAgIE1kR3JpZExpc3RNb2R1bGUsXG4gICAgRmxleExheW91dE1vZHVsZSxcbiAgICBBcHBSb3V0aW5nTW9kdWxlXG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW1xuICAgIEFwcENvbXBvbmVudCxcbiAgICBMb2dpbkNvbXBvbmVudCxcbiAgICBIb21lQ29tcG9uZW50LFxuICAgIERhdGF2Q29tcG9uZW50LFxuICAgIEJsb2dMaXN0Q29tcG9uZW50LFxuICAgIEJsb2dFZGl0Q29tcG9uZW50XG4gIF0sXG4gIGJvb3RzdHJhcDogWyBBcHBDb21wb25lbnQgXVxufSlcbmV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vdHNsaW50LWxvYWRlcj8/cmVmLS0wLTAhLi9zcmMvYXBwL2FwcC5tb2R1bGUudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFZQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE0QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==')},508:function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar Quill = __webpack_require__(414);\\r\\n__webpack_require__(674);\\r\\nvar BlogEditComponent = (function () {\\r\\n    function BlogEditComponent() {\\r\\n    }\\r\\n    BlogEditComponent.prototype.ngOnInit = function () {\\r\\n        console.warn('edit');\\r\\n        this.initEditor();\\r\\n    };\\r\\n    BlogEditComponent.prototype.initEditor = function () {\\r\\n        var toolbarOptions = [\\r\\n            ['bold', 'italic', 'underline', 'strike'],\\r\\n            ['blockquote', 'code-block'],\\r\\n            [{\\r\\n                    header: 1\\r\\n                }, {\\r\\n                    header: 2\\r\\n                }],\\r\\n            [{\\r\\n                    list: 'ordered'\\r\\n                }, {\\r\\n                    list: 'bullet'\\r\\n                }],\\r\\n            [{\\r\\n                    script: 'sub'\\r\\n                }, {\\r\\n                    script: 'super'\\r\\n                }],\\r\\n            [{\\r\\n                    indent: '-1'\\r\\n                }, {\\r\\n                    indent: '+1'\\r\\n                }],\\r\\n            [{\\r\\n                    direction: 'rtl'\\r\\n                }],\\r\\n            [{\\r\\n                    size: ['small', false, 'large', 'huge']\\r\\n                }],\\r\\n            [{\\r\\n                    header: [1, 2, 3, 4, 5, 6, false]\\r\\n                }],\\r\\n            // [{\\r\\n            //   color: []\\r\\n            // }, {\\r\\n            //   background: []\\r\\n            // }], // dropdown with defaults from theme\\r\\n            // [{\\r\\n            //   font: []\\r\\n            // }],\\r\\n            // [{\\r\\n            //   align: []\\r\\n            // }],\\r\\n            ['clean'] // remove formatting button\\r\\n        ];\\r\\n        var options = {\\r\\n            formula: true,\\r\\n            syntax: true,\\r\\n            modules: {\\r\\n                toolbar: toolbarOptions\\r\\n            },\\r\\n            placeholder: '...',\\r\\n            theme: 'snow'\\r\\n        };\\r\\n        var quill = new Quill('#editor', options);\\r\\n    };\\r\\n    return BlogEditComponent;\\r\\n}());\\r\\nBlogEditComponent = __decorate([\\r\\n    core_1.Component({\\r\\n        selector: 'blog-edit',\\r\\n        template: __webpack_require__(857),\\r\\n        styles: [__webpack_require__(966)]\\r\\n    })\\r\\n], BlogEditComponent);\\r\\nexports.BlogEditComponent = BlogEditComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ibG9nLWVkaXQvYmxvZy1lZGl0LmNvbXBvbmVudC50cz8xZmVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgUXVpbGwgZnJvbSAncXVpbGwnO1xuXG5pbXBvcnQgJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9xdWlsbC9kaXN0L3F1aWxsLnNub3cuY3NzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYmxvZy1lZGl0JyxcbiAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYmxvZy1lZGl0LmNvbXBvbmVudC5odG1sJyksXG4gIHN0eWxlczogW3JlcXVpcmUoJy4vYmxvZy1lZGl0LmNvbXBvbmVudC5zY3NzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgQmxvZ0VkaXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICBjb25zb2xlLndhcm4oJ2VkaXQnKTtcblxuICAgIHRoaXMuaW5pdEVkaXRvcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0RWRpdG9yKCkge1xuICAgIGNvbnN0IHRvb2xiYXJPcHRpb25zID0gW1xuICAgICAgWydib2xkJywgJ2l0YWxpYycsICd1bmRlcmxpbmUnLCAnc3RyaWtlJ10sIC8vIHRvZ2dsZWQgYnV0dG9uc1xuICAgICAgWydibG9ja3F1b3RlJywgJ2NvZGUtYmxvY2snXSxcblxuICAgICAgW3tcbiAgICAgICAgaGVhZGVyOiAxXG4gICAgICB9LCB7XG4gICAgICAgIGhlYWRlcjogMlxuICAgICAgfV0sIC8vIGN1c3RvbSBidXR0b24gdmFsdWVzXG4gICAgICBbe1xuICAgICAgICBsaXN0OiAnb3JkZXJlZCdcbiAgICAgIH0sIHtcbiAgICAgICAgbGlzdDogJ2J1bGxldCdcbiAgICAgIH1dLFxuICAgICAgW3tcbiAgICAgICAgc2NyaXB0OiAnc3ViJ1xuICAgICAgfSwge1xuICAgICAgICBzY3JpcHQ6ICdzdXBlcidcbiAgICAgIH1dLCAvLyBzdXBlcnNjcmlwdC9zdWJzY3JpcHRcbiAgICAgIFt7XG4gICAgICAgIGluZGVudDogJy0xJ1xuICAgICAgfSwge1xuICAgICAgICBpbmRlbnQ6ICcrMSdcbiAgICAgIH1dLCAvLyBvdXRkZW50L2luZGVudFxuICAgICAgW3tcbiAgICAgICAgZGlyZWN0aW9uOiAncnRsJ1xuICAgICAgfV0sIC8vIHRleHQgZGlyZWN0aW9uXG5cbiAgICAgIFt7XG4gICAgICAgIHNpemU6IFsnc21hbGwnLCBmYWxzZSwgJ2xhcmdlJywgJ2h1Z2UnXVxuICAgICAgfV0sIC8vIGN1c3RvbSBkcm9wZG93blxuICAgICAgW3tcbiAgICAgICAgaGVhZGVyOiBbMSwgMiwgMywgNCwgNSwgNiwgZmFsc2VdXG4gICAgICB9XSxcblxuICAgICAgLy8gW3tcbiAgICAgIC8vICAgY29sb3I6IFtdXG4gICAgICAvLyB9LCB7XG4gICAgICAvLyAgIGJhY2tncm91bmQ6IFtdXG4gICAgICAvLyB9XSwgLy8gZHJvcGRvd24gd2l0aCBkZWZhdWx0cyBmcm9tIHRoZW1lXG4gICAgICAvLyBbe1xuICAgICAgLy8gICBmb250OiBbXVxuICAgICAgLy8gfV0sXG4gICAgICAvLyBbe1xuICAgICAgLy8gICBhbGlnbjogW11cbiAgICAgIC8vIH1dLFxuXG4gICAgICBbJ2NsZWFuJ10gLy8gcmVtb3ZlIGZvcm1hdHRpbmcgYnV0dG9uXG4gICAgXTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBmb3JtdWxhOiB0cnVlLFxuICAgICAgc3ludGF4OiB0cnVlLFxuICAgICAgbW9kdWxlczoge1xuICAgICAgICB0b29sYmFyOiB0b29sYmFyT3B0aW9uc1xuICAgICAgfSxcbiAgICAgIHBsYWNlaG9sZGVyOiAn6K+36L6T5YWlLi4uJyxcbiAgICAgIHRoZW1lOiAnc25vdydcbiAgICB9O1xuXG4gICAgY29uc3QgcXVpbGwgPSBuZXcgUXVpbGwoJyNlZGl0b3InLCBvcHRpb25zKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9ibG9nLWVkaXQvYmxvZy1lZGl0LmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUlBO0FBRUE7QUFRQTtBQUFBO0FBdUVBO0FBckVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQXZFQTtBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\")},509:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\n__webpack_require__(672);\\r\\nvar jQuery = __webpack_require__(864);\\r\\nvar hljs = __webpack_require__(252);\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar BlogListComponent = (function () {\\r\\n    function BlogListComponent() {\\r\\n        this.cardhtml = \"\\\\n<div class=\\\\\"containerX\\\\\">\\\\n  <div class=\\\\\"container\\\\\">\\\\n    <div fxFlex fxLayout=\\\\\"space-around stretch\\\\\">\\\\n        <md-card class=\\\\\"box-shadow-dark-3\\\\\" fxFlex=\\\\\"32%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxLayout=\\\\\"column\\\\\">\\\\n          <md-card-header>\\\\n            <md-card-title>Card\\\\u5E03\\\\u5C40</md-card-title>\\\\n          </md-card-header>\\\\n\\\\n          <md-card-content>\\\\n            content\\\\n          </md-card-content>\\\\n        </md-card>\\\\n    </div>\\\\n  </div>\\\\n</div>\";\\r\\n        this.cssGradienst = \"\\\\n $color1: rgba(142, 246, 228, .9);\\\\n $color2: rgba(51, 204, 204, .9);\\\\n\\\\n .css-gradient {\\\\n   background: linear-gradient(to bottom left, $color1, $color2);\\\\n }\";\\r\\n    }\\r\\n    BlogListComponent.prototype.ngOnInit = function () {\\r\\n        // hljs.initHighlightingOnLoad();\\r\\n        jQuery(document).ready(function () {\\r\\n            jQuery(\\'pre code\\').each(function (i, block) {\\r\\n                hljs.highlightBlock(block);\\r\\n            });\\r\\n        });\\r\\n        // this.initBlogList();\\r\\n    };\\r\\n    BlogListComponent.prototype.initBlogList = function () {\\r\\n        console.warn(\\'blog list\\');\\r\\n    };\\r\\n    return BlogListComponent;\\r\\n}());\\r\\nBlogListComponent = __decorate([\\r\\n    core_1.Component({\\r\\n        selector: \\'blog-list\\',\\r\\n        template: __webpack_require__(858),\\r\\n        styles: [__webpack_require__(967)]\\r\\n    })\\r\\n], BlogListComponent);\\r\\nexports.BlogListComponent = BlogListComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ibG9nLWxpc3QvYmxvZy1saXN0LmNvbXBvbmVudC50cz80NTBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnaGlnaGxpZ2h0LmpzL3N0eWxlcy9hdG9tLW9uZS1kYXJrLmNzcyc7XG5pbXBvcnQgKiBhcyBqUXVlcnkgZnJvbSAnanF1ZXJ5JztcblxuaW1wb3J0ICogYXMgaGxqcyBmcm9tICdoaWdobGlnaHQuanMnO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Jsb2ctbGlzdCcsXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Jsb2ctbGlzdC5jb21wb25lbnQuaHRtbCcpLFxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL2Jsb2ctbGlzdC5jb21wb25lbnQuc2NzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIEJsb2dMaXN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgcHVibGljIGNhcmRodG1sOiBzdHJpbmcgPSBgXG48ZGl2IGNsYXNzPVwiY29udGFpbmVyWFwiPlxuICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgPGRpdiBmeEZsZXggZnhMYXlvdXQ9XCJzcGFjZS1hcm91bmQgc3RyZXRjaFwiPlxuICAgICAgICA8bWQtY2FyZCBjbGFzcz1cImJveC1zaGFkb3ctZGFyay0zXCIgZnhGbGV4PVwiMzIlXCIgZnhGbGV4Lmx0LXNtPVwiMTAwJVwiIGZ4TGF5b3V0PVwiY29sdW1uXCI+XG4gICAgICAgICAgPG1kLWNhcmQtaGVhZGVyPlxuICAgICAgICAgICAgPG1kLWNhcmQtdGl0bGU+Q2FyZOW4g+WxgDwvbWQtY2FyZC10aXRsZT5cbiAgICAgICAgICA8L21kLWNhcmQtaGVhZGVyPlxuXG4gICAgICAgICAgPG1kLWNhcmQtY29udGVudD5cbiAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICA8L21kLWNhcmQtY29udGVudD5cbiAgICAgICAgPC9tZC1jYXJkPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PmA7XG5cblxuICBwdWJsaWMgY3NzR3JhZGllbnN0OiBzdHJpbmcgPSBgXG4gJGNvbG9yMTogcmdiYSgxNDIsIDI0NiwgMjI4LCAuOSk7XG4gJGNvbG9yMjogcmdiYSg1MSwgMjA0LCAyMDQsIC45KTtcblxuIC5jc3MtZ3JhZGllbnQge1xuICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSBsZWZ0LCAkY29sb3IxLCAkY29sb3IyKTtcbiB9YDtcblxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcblxuICAgIC8vIGhsanMuaW5pdEhpZ2hsaWdodGluZ09uTG9hZCgpO1xuXG4gICAgalF1ZXJ5KGRvY3VtZW50KS5yZWFkeSgoKSA9PiB7XG4gICAgICBqUXVlcnkoJ3ByZSBjb2RlJykuZWFjaCgoaSwgYmxvY2spID0+IHtcbiAgICAgICAgaGxqcy5oaWdobGlnaHRCbG9jayhibG9jayk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHRoaXMuaW5pdEJsb2dMaXN0KCk7XG4gIH1cblxuICBwcml2YXRlIGluaXRCbG9nTGlzdCgpIHtcblxuICAgIGNvbnNvbGUud2FybignYmxvZyBsaXN0Jyk7XG4gIH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9ibG9nLWxpc3QvYmxvZy1saXN0LmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQVdBO0FBTkE7QUFPQTtBQWtCQTtBQTJCQTtBQWxCQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBOUNBO0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9')},510:function(module,exports,__webpack_require__){\"use strict\"\n;eval(\"\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar PIXI = __webpack_require__(406);\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar DatavComponent = (function () {\\r\\n    function DatavComponent() {\\r\\n        this.width = document.body.clientWidth - 120;\\r\\n        this.height = document.body.offsetHeight;\\r\\n        this.bgc = {\\r\\n            backgroundColor: 0x1099bb\\r\\n        };\\r\\n        // public initKnowledge(): void {\\r\\n        //   // SVG \\r\\n        //   const width = document.body.clientWidth;\\r\\n        //   const height = document.body.clientHeight;\\r\\n        //   const svg = d3.select('#knowledge').append('svg')\\r\\n        //     .attr('width', width - 120)\\r\\n        //     .attr('height', height);\\r\\n        //   const g = svg.append('g')\\r\\n        //     .attr('transform', `translate(${width / 2}, ${height / 2})`);\\r\\n        //   const tree = d3.tree()\\r\\n        //     .size([360, 500])\\r\\n        //     .separation((a, b) => {\\r\\n        //       return (a.parent === b.parent ? 1 : 2) / a.depth;\\r\\n        //     });\\r\\n        //   const JsonData = {\\r\\n        //     name: '',\\r\\n        //     children: [{\\r\\n        //       name: 'JavaScript',\\r\\n        //       children: [{\\r\\n        //         name: 'jQuery'\\r\\n        //       }, {\\r\\n        //         name: 'Angularjs'\\r\\n        //       }, {\\r\\n        //         name: 'Angular'\\r\\n        //       }]\\r\\n        //     }, {\\r\\n        //       name: 'HTML5',\\r\\n        //       children: [{\\r\\n        //           name: 'SVG'\\r\\n        //         },\\r\\n        //         {\\r\\n        //           name: 'Canvas'\\r\\n        //         }\\r\\n        //       ]\\r\\n        //     }, {\\r\\n        //       name: 'CSS3',\\r\\n        //       children: [{\\r\\n        //         name: 'Sass'\\r\\n        //       }, {\\r\\n        //         name: 'postCss'\\r\\n        //       }]\\r\\n        //     }]\\r\\n        //   };\\r\\n        //   // const stratify = d3.stratify()\\r\\n        //   //     .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(\\\".\\\")); });\\r\\n        //   const root = d3.hierarchy(JsonData);\\r\\n        //   // root.sum((d) => (d.value)).sort((a, b) => b.value - a.value);\\r\\n        //   tree(root);\\r\\n        //   function project(x: number, y: number) {\\r\\n        //     const angle = (x - 90) / 180 * Math.PI;\\r\\n        //     const radius = y;\\r\\n        //     return [radius * Math.cos(angle), radius * Math.sin(angle)];\\r\\n        //   }\\r\\n        //   // const link = g.selectAll('.link')\\r\\n        //   //   .data(root.descendants().slice(1))\\r\\n        //   //   .enter().append('path')\\r\\n        //   //   .attr('class', 'link')\\r\\n        //   //   .attr('d', (d) => {\\r\\n        //   //     return 'M' + project(d.x, d.y) +\\r\\n        //   //       'C' + project(d.x, (d.y + d.parent.y) / 2) +\\r\\n        //   //       ' ' + project(d.parent.x, (d.y + d.parent.y) / 2) +\\r\\n        //   //       ' ' + project(d.parent.x, d.parent.y);\\r\\n        //   //   });\\r\\n        //   const node = g.selectAll('.node')\\r\\n        //     .data(root.descendants())\\r\\n        //     .enter().append('g')\\r\\n        //     .attr('class', (d) => {\\r\\n        //       return 'node' + (d.children ? ' node--internal' : ' node--leaf');\\r\\n        //     })\\r\\n        //     .attr('transform', (d) => {\\r\\n        //       return 'translate(' + project(d.x, d.y) + ')';\\r\\n        //     });\\r\\n        //   node.append('circle')\\r\\n        //     .attr('r', 2.5);\\r\\n        //   node.append('text')\\r\\n        //     .attr('dy', '.31em')\\r\\n        //     .attr('x', (d) => {\\r\\n        //       return d.x < 180 === !d.children ? 6 : -6;\\r\\n        //     })\\r\\n        //     .style('text-anchor', (d) => {\\r\\n        //       return d.x < 180 === !d.children ? 'start' : 'end';\\r\\n        //     })\\r\\n        //     .attr('transform', (d) => {\\r\\n        //       return 'rotate(' + (d.x < 180 ? d.x - 90 : d.x + 90) + ')';\\r\\n        //     })\\r\\n        //     .text((d) => {\\r\\n        //       return d.data.name;\\r\\n        //     });\\r\\n        // }\\r\\n    }\\r\\n    DatavComponent.prototype.ngOnInit = function () {\\r\\n        // this.initKnowledge();\\r\\n        this.initPIXI();\\r\\n        this.initPIXITexture();\\r\\n    };\\r\\n    DatavComponent.prototype.initPIXI = function () {\\r\\n        var app = new PIXI.Application(this.width, this.height, this.bgc);\\r\\n        document.getElementById('knowledge').appendChild(app.view);\\r\\n        var style = new PIXI.TextStyle({\\r\\n            fontFamily: 'Arial',\\r\\n            fontSize: 36,\\r\\n            fontStyle: 'italic',\\r\\n            fontWeight: 'bold',\\r\\n            fill: ['#ffffff', '#00ff99'],\\r\\n            stroke: '#4a1850',\\r\\n            strokeThickness: 5,\\r\\n            dropShadow: true,\\r\\n            dropShadowColor: '#000000',\\r\\n            dropShadowBlur: 4,\\r\\n            dropShadowAngle: Math.PI / 6,\\r\\n            dropShadowDistance: 6,\\r\\n            wordWrap: true,\\r\\n            wordWrapWidth: 440\\r\\n        });\\r\\n        var richText = new PIXI.Text('H5', style);\\r\\n        richText.x = 30;\\r\\n        richText.y = 50;\\r\\n        // Scale mode for all textures, will retain pixelation\\r\\n        PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;\\r\\n        var bg = PIXI.Sprite.fromImage('src/assets/images/usercenter/login_bg_1.jpg');\\r\\n        app.stage.addChild(bg);\\r\\n        var cells = PIXI.Sprite.fromImage('src/assets/images/magic/flowerup.jpg');\\r\\n        cells.scale.set(1);\\r\\n        var mask = PIXI.Sprite.fromImage('src/assets/images/magic/fly_person2.png');\\r\\n        mask.anchor.set(0.2);\\r\\n        mask.width = 100;\\r\\n        mask.height = 100;\\r\\n        mask.x = this.width / 2;\\r\\n        mask.y = this.height / 2;\\r\\n        cells.mask = mask;\\r\\n        app.stage.addChild(mask, cells);\\r\\n        var target = new PIXI.Point();\\r\\n        reset();\\r\\n        function reset() {\\r\\n            target.x = Math.floor(Math.random() * 600);\\r\\n            target.y = Math.floor(Math.random() * 600);\\r\\n        }\\r\\n        app.ticker.add(function () {\\r\\n            mask.x += (target.x - mask.x) * 0.1;\\r\\n            mask.y += (target.y - mask.y) * 0.1;\\r\\n            if (Math.abs(mask.x - target.x) < 1) {\\r\\n                reset();\\r\\n            }\\r\\n        });\\r\\n        app.stage.addChild(richText);\\r\\n    };\\r\\n    /**\\r\\n     * \\r\\n     * ...\\r\\n     * @memberof DatavComponent\\r\\n     */\\r\\n    DatavComponent.prototype.initPIXITexture = function () {\\r\\n        var app = new PIXI.Application(this.width, this.height, this.bgc);\\r\\n        document.getElementById('texture').appendChild(app.view);\\r\\n        var texture = PIXI.Texture.fromImage('src/assets/images/magic/fly_person2.png');\\r\\n        // Scale mode for pixelation\\r\\n        texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\\r\\n        for (var i = 0; i < 10; i++) {\\r\\n            createBunny(Math.floor(Math.random() * app.renderer.width), Math.floor(Math.random() * app.renderer.height));\\r\\n        }\\r\\n        function createBunny(x, y) {\\r\\n            // create our little bunny friend..\\r\\n            var bunny = new PIXI.Sprite(texture);\\r\\n            // enable the bunny to be interactive... this will allow it to respond to mouse and touch events\\r\\n            bunny.interactive = true;\\r\\n            // this button mode will mean the hand cursor appears when you roll over the bunny with your mouse\\r\\n            bunny.buttonMode = true;\\r\\n            // center the bunny's anchor point\\r\\n            bunny.anchor.set(0.5);\\r\\n            // make it a bit bigger, so it's easier to grab\\r\\n            bunny.scale.set(0.2);\\r\\n            // setup events for mouse + touch using\\r\\n            // the pointer events\\r\\n            bunny\\r\\n                .on('pointerdown', onDragStart)\\r\\n                .on('pointerup', onDragEnd)\\r\\n                .on('pointerupoutside', onDragEnd)\\r\\n                .on('pointermove', onDragMove);\\r\\n            // For mouse-only events\\r\\n            // .on('mousedown', onDragStart)\\r\\n            // .on('mouseup', onDragEnd)\\r\\n            // .on('mouseupoutside', onDragEnd)\\r\\n            // .on('mousemove', onDragMove);\\r\\n            // For touch-only events\\r\\n            // .on('touchstart', onDragStart)\\r\\n            // .on('touchend', onDragEnd)\\r\\n            // .on('touchendoutside', onDragEnd)\\r\\n            // .on('touchmove', onDragMove);\\r\\n            // move the sprite to its designated position\\r\\n            bunny.x = x;\\r\\n            bunny.y = y;\\r\\n            // add it to the stage\\r\\n            app.stage.addChild(bunny);\\r\\n        }\\r\\n        function onDragStart(event) {\\r\\n            // store a reference to the data\\r\\n            // the reason for this is because of multitouch\\r\\n            // we want to track the movement of this particular touch\\r\\n            this.data = event.data;\\r\\n            this.alpha = 0.5;\\r\\n            this.dragging = true;\\r\\n        }\\r\\n        function onDragEnd() {\\r\\n            this.alpha = 1;\\r\\n            this.dragging = false;\\r\\n            // set the interaction data to null\\r\\n            this.data = null;\\r\\n        }\\r\\n        function onDragMove() {\\r\\n            if (this.dragging) {\\r\\n                var newPosition = this.data.getLocalPosition(this.parent);\\r\\n                this.x = newPosition.x;\\r\\n                this.y = newPosition.y;\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n    return DatavComponent;\\r\\n}());\\r\\nDatavComponent = __decorate([\\r\\n    core_1.Component({\\r\\n        selector: 'datav',\\r\\n        template: __webpack_require__(859),\\r\\n        styles: [__webpack_require__(968)]\\r\\n    })\\r\\n], DatavComponent);\\r\\nexports.DatavComponent = DatavComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9kYXRhdi9kYXRhdi5jb21wb25lbnQudHM/ZmVlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgKiBhcyBQSVhJIGZyb20gJ3BpeGkuanMnO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2RhdGF2JyxcbiAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZGF0YXYuY29tcG9uZW50Lmh0bWwnKSxcbiAgc3R5bGVzOiBbcmVxdWlyZSgnLi9kYXRhdi5jb21wb25lbnQuc2NzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIERhdGF2Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgcHJpdmF0ZSB3aWR0aCA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggLSAxMjA7XG4gIHByaXZhdGUgaGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG4gIHByaXZhdGUgYmdjID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogMHgxMDk5YmJcbiAgfTtcblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG5cbiAgICAvLyB0aGlzLmluaXRLbm93bGVkZ2UoKTtcblxuICAgIHRoaXMuaW5pdFBJWEkoKTtcbiAgICB0aGlzLmluaXRQSVhJVGV4dHVyZSgpO1xuICB9XG5cbiAgcHVibGljIGluaXRQSVhJKCk6IHZvaWQge1xuXG4gICAgY29uc3QgYXBwID0gbmV3IFBJWEkuQXBwbGljYXRpb24odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuYmdjKTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdrbm93bGVkZ2UnKS5hcHBlbmRDaGlsZChhcHAudmlldyk7XG5cbiAgICBjb25zdCBzdHlsZSA9IG5ldyBQSVhJLlRleHRTdHlsZSh7XG4gICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgICAgZm9udFNpemU6IDM2LFxuICAgICAgZm9udFN0eWxlOiAnaXRhbGljJyxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIGZpbGw6IFsnI2ZmZmZmZicsICcjMDBmZjk5J10sIC8vIGdyYWRpZW50XG4gICAgICBzdHJva2U6ICcjNGExODUwJyxcbiAgICAgIHN0cm9rZVRoaWNrbmVzczogNSxcbiAgICAgIGRyb3BTaGFkb3c6IHRydWUsXG4gICAgICBkcm9wU2hhZG93Q29sb3I6ICcjMDAwMDAwJyxcbiAgICAgIGRyb3BTaGFkb3dCbHVyOiA0LFxuICAgICAgZHJvcFNoYWRvd0FuZ2xlOiBNYXRoLlBJIC8gNixcbiAgICAgIGRyb3BTaGFkb3dEaXN0YW5jZTogNixcbiAgICAgIHdvcmRXcmFwOiB0cnVlLFxuICAgICAgd29yZFdyYXBXaWR0aDogNDQwXG4gICAgfSk7XG5cbiAgICBjb25zdCByaWNoVGV4dCA9IG5ldyBQSVhJLlRleHQoJ+W8gOWQr0g16Iux6ZuE5LmL6LevJywgc3R5bGUpO1xuICAgIHJpY2hUZXh0LnggPSAzMDtcbiAgICByaWNoVGV4dC55ID0gNTA7XG5cbiAgICAvLyBTY2FsZSBtb2RlIGZvciBhbGwgdGV4dHVyZXMsIHdpbGwgcmV0YWluIHBpeGVsYXRpb25cbiAgICBQSVhJLnNldHRpbmdzLlNDQUxFX01PREUgPSBQSVhJLlNDQUxFX01PREVTLk5FQVJFU1Q7XG5cbiAgICBjb25zdCBiZyA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZSgnc3JjL2Fzc2V0cy9pbWFnZXMvdXNlcmNlbnRlci9sb2dpbl9iZ18xLmpwZycpO1xuICAgIGFwcC5zdGFnZS5hZGRDaGlsZChiZyk7XG5cbiAgICBjb25zdCBjZWxscyA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZSgnc3JjL2Fzc2V0cy9pbWFnZXMvbWFnaWMvZmxvd2VydXAuanBnJyk7XG4gICAgY2VsbHMuc2NhbGUuc2V0KDEpO1xuXG4gICAgY29uc3QgbWFzayA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZSgnc3JjL2Fzc2V0cy9pbWFnZXMvbWFnaWMvZmx5X3BlcnNvbjIucG5nJyk7XG4gICAgbWFzay5hbmNob3Iuc2V0KDAuMik7XG4gICAgbWFzay53aWR0aCA9IDEwMDtcbiAgICBtYXNrLmhlaWdodCA9IDEwMDtcbiAgICBtYXNrLnggPSB0aGlzLndpZHRoIC8gMjtcbiAgICBtYXNrLnkgPSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICBjZWxscy5tYXNrID0gbWFzaztcbiAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQobWFzaywgY2VsbHMpO1xuXG4gICAgY29uc3QgdGFyZ2V0ID0gbmV3IFBJWEkuUG9pbnQoKTtcblxuICAgIHJlc2V0KCk7XG5cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRhcmdldC54ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNjAwKTtcbiAgICAgIHRhcmdldC55ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNjAwKTtcbiAgICB9XG5cbiAgICBhcHAudGlja2VyLmFkZCgoKSA9PiB7XG5cbiAgICAgIG1hc2sueCArPSAodGFyZ2V0LnggLSBtYXNrLngpICogMC4xO1xuICAgICAgbWFzay55ICs9ICh0YXJnZXQueSAtIG1hc2sueSkgKiAwLjE7XG5cbiAgICAgIGlmIChNYXRoLmFicyhtYXNrLnggLSB0YXJnZXQueCkgPCAxKSB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQocmljaFRleHQpO1xuXG5cbiAgfVxuXG4gIC8qKlxuICAgKiDliJ3lp4vljJbnp7vliqjluIPlsYBcbiAgICogLi4uXG4gICAqIEBtZW1iZXJvZiBEYXRhdkNvbXBvbmVudFxuICAgKi9cbiAgcHVibGljIGluaXRQSVhJVGV4dHVyZSgpOiB2b2lkIHtcbiAgICBjb25zdCBhcHAgPSBuZXcgUElYSS5BcHBsaWNhdGlvbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5iZ2MpO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RleHR1cmUnKS5hcHBlbmRDaGlsZChhcHAudmlldyk7XG5cbiAgICBjb25zdCB0ZXh0dXJlID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZSgnc3JjL2Fzc2V0cy9pbWFnZXMvbWFnaWMvZmx5X3BlcnNvbjIucG5nJyk7XG5cbiAgICAvLyBTY2FsZSBtb2RlIGZvciBwaXhlbGF0aW9uXG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zY2FsZU1vZGUgPSBQSVhJLlNDQUxFX01PREVTLk5FQVJFU1Q7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgIGNyZWF0ZUJ1bm55KFxuICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcHAucmVuZGVyZXIud2lkdGgpLFxuICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcHAucmVuZGVyZXIuaGVpZ2h0KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVCdW5ueSh4OiBudW1iZXIsIHk6IG51bWJlcikge1xuXG4gICAgICAvLyBjcmVhdGUgb3VyIGxpdHRsZSBidW5ueSBmcmllbmQuLlxuICAgICAgY29uc3QgYnVubnkgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG5cbiAgICAgIC8vIGVuYWJsZSB0aGUgYnVubnkgdG8gYmUgaW50ZXJhY3RpdmUuLi4gdGhpcyB3aWxsIGFsbG93IGl0IHRvIHJlc3BvbmQgdG8gbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAgYnVubnkuaW50ZXJhY3RpdmUgPSB0cnVlO1xuXG4gICAgICAvLyB0aGlzIGJ1dHRvbiBtb2RlIHdpbGwgbWVhbiB0aGUgaGFuZCBjdXJzb3IgYXBwZWFycyB3aGVuIHlvdSByb2xsIG92ZXIgdGhlIGJ1bm55IHdpdGggeW91ciBtb3VzZVxuICAgICAgYnVubnkuYnV0dG9uTW9kZSA9IHRydWU7XG5cbiAgICAgIC8vIGNlbnRlciB0aGUgYnVubnkncyBhbmNob3IgcG9pbnRcbiAgICAgIGJ1bm55LmFuY2hvci5zZXQoMC41KTtcblxuICAgICAgLy8gbWFrZSBpdCBhIGJpdCBiaWdnZXIsIHNvIGl0J3MgZWFzaWVyIHRvIGdyYWJcbiAgICAgIGJ1bm55LnNjYWxlLnNldCgwLjIpO1xuXG4gICAgICAvLyBzZXR1cCBldmVudHMgZm9yIG1vdXNlICsgdG91Y2ggdXNpbmdcbiAgICAgIC8vIHRoZSBwb2ludGVyIGV2ZW50c1xuICAgICAgYnVubnlcbiAgICAgICAgLm9uKCdwb2ludGVyZG93bicsIG9uRHJhZ1N0YXJ0KVxuICAgICAgICAub24oJ3BvaW50ZXJ1cCcsIG9uRHJhZ0VuZClcbiAgICAgICAgLm9uKCdwb2ludGVydXBvdXRzaWRlJywgb25EcmFnRW5kKVxuICAgICAgICAub24oJ3BvaW50ZXJtb3ZlJywgb25EcmFnTW92ZSk7XG5cbiAgICAgIC8vIEZvciBtb3VzZS1vbmx5IGV2ZW50c1xuICAgICAgLy8gLm9uKCdtb3VzZWRvd24nLCBvbkRyYWdTdGFydClcbiAgICAgIC8vIC5vbignbW91c2V1cCcsIG9uRHJhZ0VuZClcbiAgICAgIC8vIC5vbignbW91c2V1cG91dHNpZGUnLCBvbkRyYWdFbmQpXG4gICAgICAvLyAub24oJ21vdXNlbW92ZScsIG9uRHJhZ01vdmUpO1xuXG4gICAgICAvLyBGb3IgdG91Y2gtb25seSBldmVudHNcbiAgICAgIC8vIC5vbigndG91Y2hzdGFydCcsIG9uRHJhZ1N0YXJ0KVxuICAgICAgLy8gLm9uKCd0b3VjaGVuZCcsIG9uRHJhZ0VuZClcbiAgICAgIC8vIC5vbigndG91Y2hlbmRvdXRzaWRlJywgb25EcmFnRW5kKVxuICAgICAgLy8gLm9uKCd0b3VjaG1vdmUnLCBvbkRyYWdNb3ZlKTtcblxuICAgICAgLy8gbW92ZSB0aGUgc3ByaXRlIHRvIGl0cyBkZXNpZ25hdGVkIHBvc2l0aW9uXG4gICAgICBidW5ueS54ID0geDtcbiAgICAgIGJ1bm55LnkgPSB5O1xuXG4gICAgICAvLyBhZGQgaXQgdG8gdGhlIHN0YWdlXG4gICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQoYnVubnkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGV2ZW50OiBhbnkpIHtcbiAgICAgIC8vIHN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBkYXRhXG4gICAgICAvLyB0aGUgcmVhc29uIGZvciB0aGlzIGlzIGJlY2F1c2Ugb2YgbXVsdGl0b3VjaFxuICAgICAgLy8gd2Ugd2FudCB0byB0cmFjayB0aGUgbW92ZW1lbnQgb2YgdGhpcyBwYXJ0aWN1bGFyIHRvdWNoXG4gICAgICB0aGlzLmRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgdGhpcy5hbHBoYSA9IDAuNTtcbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHtcbiAgICAgIHRoaXMuYWxwaGEgPSAxO1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgLy8gc2V0IHRoZSBpbnRlcmFjdGlvbiBkYXRhIHRvIG51bGxcbiAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnTW92ZSgpIHtcbiAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5kYXRhLmdldExvY2FsUG9zaXRpb24odGhpcy5wYXJlbnQpO1xuICAgICAgICB0aGlzLnggPSBuZXdQb3NpdGlvbi54O1xuICAgICAgICB0aGlzLnkgPSBuZXdQb3NpdGlvbi55O1xuICAgICAgfVxuICAgIH1cblxuXG4gIH1cblxuICAvLyBwdWJsaWMgaW5pdEtub3dsZWRnZSgpOiB2b2lkIHtcblxuICAvLyAgIC8vIFNWRyDlm77lvaLlpKflsI9cbiAgLy8gICBjb25zdCB3aWR0aCA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XG4gIC8vICAgY29uc3QgaGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG5cbiAgLy8gICBjb25zdCBzdmcgPSBkMy5zZWxlY3QoJyNrbm93bGVkZ2UnKS5hcHBlbmQoJ3N2ZycpXG4gIC8vICAgICAuYXR0cignd2lkdGgnLCB3aWR0aCAtIDEyMClcbiAgLy8gICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG4gIC8vICAgY29uc3QgZyA9IHN2Zy5hcHBlbmQoJ2cnKVxuICAvLyAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt3aWR0aCAvIDJ9LCAke2hlaWdodCAvIDJ9KWApO1xuXG4gIC8vICAgY29uc3QgdHJlZSA9IGQzLnRyZWUoKVxuICAvLyAgICAgLnNpemUoWzM2MCwgNTAwXSlcbiAgLy8gICAgIC5zZXBhcmF0aW9uKChhLCBiKSA9PiB7XG4gIC8vICAgICAgIHJldHVybiAoYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDIpIC8gYS5kZXB0aDtcbiAgLy8gICAgIH0pO1xuXG4gIC8vICAgY29uc3QgSnNvbkRhdGEgPSB7XG4gIC8vICAgICBuYW1lOiAn5oiR55qE5aSn5YmN56uvJyxcbiAgLy8gICAgIGNoaWxkcmVuOiBbe1xuICAvLyAgICAgICBuYW1lOiAnSmF2YVNjcmlwdCcsXG4gIC8vICAgICAgIGNoaWxkcmVuOiBbe1xuICAvLyAgICAgICAgIG5hbWU6ICdqUXVlcnknXG4gIC8vICAgICAgIH0sIHtcbiAgLy8gICAgICAgICBuYW1lOiAnQW5ndWxhcmpzJ1xuICAvLyAgICAgICB9LCB7XG4gIC8vICAgICAgICAgbmFtZTogJ0FuZ3VsYXInXG4gIC8vICAgICAgIH1dXG4gIC8vICAgICB9LCB7XG4gIC8vICAgICAgIG5hbWU6ICdIVE1MNScsXG4gIC8vICAgICAgIGNoaWxkcmVuOiBbe1xuICAvLyAgICAgICAgICAgbmFtZTogJ1NWRydcbiAgLy8gICAgICAgICB9LFxuICAvLyAgICAgICAgIHtcbiAgLy8gICAgICAgICAgIG5hbWU6ICdDYW52YXMnXG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgICBdXG4gIC8vICAgICB9LCB7XG4gIC8vICAgICAgIG5hbWU6ICdDU1MzJyxcbiAgLy8gICAgICAgY2hpbGRyZW46IFt7XG4gIC8vICAgICAgICAgbmFtZTogJ1Nhc3MnXG4gIC8vICAgICAgIH0sIHtcbiAgLy8gICAgICAgICBuYW1lOiAncG9zdENzcydcbiAgLy8gICAgICAgfV1cbiAgLy8gICAgIH1dXG4gIC8vICAgfTtcblxuICAvLyAgIC8vIGNvbnN0IHN0cmF0aWZ5ID0gZDMuc3RyYXRpZnkoKVxuICAvLyAgIC8vICAgICAucGFyZW50SWQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5pZC5zdWJzdHJpbmcoMCwgZC5pZC5sYXN0SW5kZXhPZihcIi5cIikpOyB9KTtcblxuICAvLyAgIGNvbnN0IHJvb3QgPSBkMy5oaWVyYXJjaHkoSnNvbkRhdGEpO1xuICAvLyAgIC8vIHJvb3Quc3VtKChkKSA9PiAoZC52YWx1ZSkpLnNvcnQoKGEsIGIpID0+IGIudmFsdWUgLSBhLnZhbHVlKTtcbiAgLy8gICB0cmVlKHJvb3QpO1xuXG4gIC8vICAgZnVuY3Rpb24gcHJvamVjdCh4OiBudW1iZXIsIHk6IG51bWJlcikge1xuICAvLyAgICAgY29uc3QgYW5nbGUgPSAoeCAtIDkwKSAvIDE4MCAqIE1hdGguUEk7XG4gIC8vICAgICBjb25zdCByYWRpdXMgPSB5O1xuICAvLyAgICAgcmV0dXJuIFtyYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSksIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKV07XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gY29uc3QgbGluayA9IGcuc2VsZWN0QWxsKCcubGluaycpXG4gIC8vICAgLy8gICAuZGF0YShyb290LmRlc2NlbmRhbnRzKCkuc2xpY2UoMSkpXG4gIC8vICAgLy8gICAuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAvLyAgIC8vICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsnKVxuICAvLyAgIC8vICAgLmF0dHIoJ2QnLCAoZCkgPT4ge1xuICAvLyAgIC8vICAgICByZXR1cm4gJ00nICsgcHJvamVjdChkLngsIGQueSkgK1xuICAvLyAgIC8vICAgICAgICdDJyArIHByb2plY3QoZC54LCAoZC55ICsgZC5wYXJlbnQueSkgLyAyKSArXG4gIC8vICAgLy8gICAgICAgJyAnICsgcHJvamVjdChkLnBhcmVudC54LCAoZC55ICsgZC5wYXJlbnQueSkgLyAyKSArXG4gIC8vICAgLy8gICAgICAgJyAnICsgcHJvamVjdChkLnBhcmVudC54LCBkLnBhcmVudC55KTtcbiAgLy8gICAvLyAgIH0pO1xuXG5cbiAgLy8gICBjb25zdCBub2RlID0gZy5zZWxlY3RBbGwoJy5ub2RlJylcbiAgLy8gICAgIC5kYXRhKHJvb3QuZGVzY2VuZGFudHMoKSlcbiAgLy8gICAgIC5lbnRlcigpLmFwcGVuZCgnZycpXG4gIC8vICAgICAuYXR0cignY2xhc3MnLCAoZCkgPT4ge1xuICAvLyAgICAgICByZXR1cm4gJ25vZGUnICsgKGQuY2hpbGRyZW4gPyAnIG5vZGUtLWludGVybmFsJyA6ICcgbm9kZS0tbGVhZicpO1xuICAvLyAgICAgfSlcbiAgLy8gICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4ge1xuICAvLyAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcHJvamVjdChkLngsIGQueSkgKyAnKSc7XG4gIC8vICAgICB9KTtcblxuICAvLyAgIG5vZGUuYXBwZW5kKCdjaXJjbGUnKVxuICAvLyAgICAgLmF0dHIoJ3InLCAyLjUpO1xuXG4gIC8vICAgbm9kZS5hcHBlbmQoJ3RleHQnKVxuICAvLyAgICAgLmF0dHIoJ2R5JywgJy4zMWVtJylcbiAgLy8gICAgIC5hdHRyKCd4JywgKGQpID0+IHtcbiAgLy8gICAgICAgcmV0dXJuIGQueCA8IDE4MCA9PT0gIWQuY2hpbGRyZW4gPyA2IDogLTY7XG4gIC8vICAgICB9KVxuICAvLyAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIChkKSA9PiB7XG4gIC8vICAgICAgIHJldHVybiBkLnggPCAxODAgPT09ICFkLmNoaWxkcmVuID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAvLyAgICAgfSlcbiAgLy8gICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4ge1xuICAvLyAgICAgICByZXR1cm4gJ3JvdGF0ZSgnICsgKGQueCA8IDE4MCA/IGQueCAtIDkwIDogZC54ICsgOTApICsgJyknO1xuICAvLyAgICAgfSlcbiAgLy8gICAgIC50ZXh0KChkKSA9PiB7XG4gIC8vICAgICAgIHJldHVybiBkLmRhdGEubmFtZTtcbiAgLy8gICAgIH0pO1xuICAvLyB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi90c2xpbnQtbG9hZGVyPz9yZWYtLTAtMCEuL3NyYy9hcHAvZGF0YXYvZGF0YXYuY29tcG9uZW50LnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBO0FBQ0E7QUFXQTtBQU5BO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQThLQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFuUkE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBeUdBO0FBQUE7QUExUkE7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\")},511:function(module,exports,__webpack_require__){\"use strict\"\n;eval(\"\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar THREE = __webpack_require__(194);\\r\\nvar OrbitControls = __webpack_require__(1254);\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar HomeComponent = (function () {\\r\\n    function HomeComponent() {\\r\\n    }\\r\\n    HomeComponent.prototype.ngOnInit = function () {\\r\\n        this.initHoneyThree();\\r\\n    };\\r\\n    HomeComponent.prototype.initHoneyThree = function () {\\r\\n        console.warn('');\\r\\n        var scene;\\r\\n        var camera;\\r\\n        var renderer;\\r\\n        // let material: THREE.MeshLambertMaterial;\\r\\n        // let rocks: Rock;\\r\\n        var angle = 0;\\r\\n        var width = document.body.clientWidth;\\r\\n        var height = window.innerHeight;\\r\\n        function initScene() {\\r\\n            scene = new THREE.Scene();\\r\\n            camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);\\r\\n            camera.position.set(0, 30, 50);\\r\\n            camera.lookAt(new THREE.Vector3(0, 15, 0));\\r\\n            renderer = new THREE.WebGLRenderer({\\r\\n                antialias: true\\r\\n            });\\r\\n            renderer.setSize(width, height);\\r\\n            renderer.setClearColor(0x393e46);\\r\\n            renderer.shadowMap.enabled = true;\\r\\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\\r\\n            document.getElementById('honeythree').appendChild(renderer.domElement);\\r\\n        }\\r\\n        function initLights() {\\r\\n            var ambientLight = new THREE.AmbientLight(0xffffff, 0.2);\\r\\n            // light.position.set(300, 300, 0);\\r\\n            scene.add(ambientLight);\\r\\n            var pointLight = new THREE.PointLight(0xffffff, 1);\\r\\n            pointLight.position.set(25, 50, 25);\\r\\n            pointLight.castShadow = true;\\r\\n            pointLight.shadow.mapSize.width = 1024;\\r\\n            pointLight.shadow.mapSize.height = 1024;\\r\\n            scene.add(pointLight);\\r\\n        }\\r\\n        function initMesh() {\\r\\n            var shadowMaterisl = new THREE.ShadowMaterial(0xeeeeee);\\r\\n            shadowMaterisl.opacity = 0.5;\\r\\n            var groundMesh = new THREE.Mesh(new THREE.BoxGeometry(100, .1, 100), shadowMaterisl);\\r\\n            groundMesh.receiveShadow = true;\\r\\n            scene.add(groundMesh);\\r\\n        }\\r\\n        function generateShapes() {\\r\\n            // A simple geometric shape with a flat material\\r\\n            var shapeOne = new THREE.Mesh(new THREE.OctahedronGeometry(10, 1), new THREE.MeshStandardMaterial({\\r\\n                color: 0xff0051,\\r\\n                shading: THREE.FlatShading,\\r\\n                metalness: 0,\\r\\n                roughness: 0.8\\r\\n            }));\\r\\n            shapeOne.position.y += 10;\\r\\n            shapeOne.rotateZ(Math.PI / 3);\\r\\n            shapeOne.castShadow = true;\\r\\n            scene.add(shapeOne);\\r\\n            // Add a second shape\\r\\n            var shapeTwo = new THREE.Mesh(new THREE.OctahedronGeometry(5, 1), new THREE.MeshStandardMaterial({\\r\\n                color: 0x47689b,\\r\\n                shading: THREE.FlatShading,\\r\\n                metalness: 0,\\r\\n                roughness: 0.8\\r\\n            }));\\r\\n            shapeTwo.position.y += 5;\\r\\n            shapeTwo.position.x += 15;\\r\\n            shapeTwo.rotateZ(Math.PI / 5);\\r\\n            shapeTwo.castShadow = true;\\r\\n            scene.add(shapeTwo);\\r\\n        }\\r\\n        function render() {\\r\\n            // requestAnimationFrame(render);\\r\\n            renderer.render(scene, camera);\\r\\n            // updateCamPosition();\\r\\n        }\\r\\n        function updateCamPosition() {\\r\\n            angle += 0.005;\\r\\n            var z = 50 * Math.cos(angle);\\r\\n            var y = 50 * Math.sin(angle);\\r\\n            // camera.position.z = z;\\r\\n            camera.position.y = y;\\r\\n            // camera.rotation.x = z * 0.02;\\r\\n        }\\r\\n        // function resize() {\\r\\n        //   // camera.aspect = width / height;\\r\\n        //   camera.updateMatrix();\\r\\n        //   renderer.setSize(width, height);\\r\\n        // }\\r\\n        // window.addEventListener('resize', resize);\\r\\n        function initControls() {\\r\\n            var controls = new OrbitControls(camera, renderer.domElement);\\r\\n            controls.target = new THREE.Vector3(0, 15, 0);\\r\\n            controls.maxPolarAngle = Math.PI / 2;\\r\\n            controls.addEventListener('change', function () {\\r\\n                renderer.render(scene, camera);\\r\\n            });\\r\\n        }\\r\\n        initScene();\\r\\n        initLights();\\r\\n        initMesh();\\r\\n        generateShapes();\\r\\n        initControls();\\r\\n        render();\\r\\n    };\\r\\n    return HomeComponent;\\r\\n}());\\r\\nHomeComponent = __decorate([\\r\\n    core_1.Component({\\r\\n        selector: 'cv-home',\\r\\n        template: __webpack_require__(860),\\r\\n        styles: [__webpack_require__(969)]\\r\\n    })\\r\\n], HomeComponent);\\r\\nexports.HomeComponent = HomeComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50LnRzPzdlZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuY29uc3QgT3JiaXRDb250cm9scyA9IHJlcXVpcmUoJ3RocmVlLW9yYml0Y29udHJvbHMnKTtcblxuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2N2LWhvbWUnLFxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9ob21lLmNvbXBvbmVudC5odG1sJyksXG4gIHN0eWxlczogW3JlcXVpcmUoJy4vaG9tZS5jb21wb25lbnQuc2NzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIEhvbWVDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcblxuICAgIHRoaXMuaW5pdEhvbmV5VGhyZWUoKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0SG9uZXlUaHJlZSgpOiB2b2lkIHtcbiAgICBjb25zb2xlLndhcm4oJ+aKleW9sScpO1xuXG4gICAgbGV0IHNjZW5lOiBUSFJFRS5TY2VuZTtcbiAgICBsZXQgY2FtZXJhOiBUSFJFRS5DYW1lcmE7XG4gICAgbGV0IHJlbmRlcmVyOiBUSFJFRS5XZWJHTFJlbmRlcmVyO1xuICAgIC8vIGxldCBtYXRlcmlhbDogVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbDtcbiAgICAvLyBsZXQgcm9ja3M6IFJvY2s7XG4gICAgbGV0IGFuZ2xlOiBudW1iZXIgPSAwO1xuXG4gICAgY29uc3Qgd2lkdGggPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgIGZ1bmN0aW9uIGluaXRTY2VuZSgpIHtcbiAgICAgIHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNjAsIHdpZHRoIC8gaGVpZ2h0LCAwLjEsIDEwMDApO1xuICAgICAgY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAzMCwgNTApO1xuICAgICAgY2FtZXJhLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygwLCAxNSwgMCkpO1xuICAgICAgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICAgIGFudGlhbGlhczogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweDM5M2U0Nik7XG4gICAgICByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IHRydWU7XG4gICAgICByZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG5cbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob25leXRocmVlJykuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdExpZ2h0cygpIHtcbiAgICAgIGNvbnN0IGFtYmllbnRMaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoMHhmZmZmZmYsIDAuMik7XG4gICAgICAvLyBsaWdodC5wb3NpdGlvbi5zZXQoMzAwLCAzMDAsIDApO1xuICAgICAgc2NlbmUuYWRkKGFtYmllbnRMaWdodCk7XG5cbiAgICAgIGNvbnN0IHBvaW50TGlnaHQgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCgweGZmZmZmZiwgMSk7XG4gICAgICBwb2ludExpZ2h0LnBvc2l0aW9uLnNldCgyNSwgNTAsIDI1KTtcbiAgICAgIHBvaW50TGlnaHQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICBwb2ludExpZ2h0LnNoYWRvdy5tYXBTaXplLndpZHRoID0gMTAyNDtcbiAgICAgIHBvaW50TGlnaHQuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gMTAyNDtcbiAgICAgIHNjZW5lLmFkZChwb2ludExpZ2h0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0TWVzaCgpIHtcbiAgICAgIGNvbnN0IHNoYWRvd01hdGVyaXNsID0gbmV3IFRIUkVFLlNoYWRvd01hdGVyaWFsKDB4ZWVlZWVlKTtcbiAgICAgIHNoYWRvd01hdGVyaXNsLm9wYWNpdHkgPSAwLjU7XG4gICAgICBjb25zdCBncm91bmRNZXNoID0gbmV3IFRIUkVFLk1lc2goXG4gICAgICAgIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgxMDAsIC4xLCAxMDApLFxuICAgICAgICBzaGFkb3dNYXRlcmlzbFxuICAgICAgKTtcbiAgICAgIGdyb3VuZE1lc2gucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICBzY2VuZS5hZGQoZ3JvdW5kTWVzaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVTaGFwZXMoKSB7XG4gICAgICAvLyBBIHNpbXBsZSBnZW9tZXRyaWMgc2hhcGUgd2l0aCBhIGZsYXQgbWF0ZXJpYWxcbiAgICAgIGNvbnN0IHNoYXBlT25lID0gbmV3IFRIUkVFLk1lc2goXG4gICAgICAgIG5ldyBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkoMTAsIDEpLFxuICAgICAgICBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgICAgIGNvbG9yOiAweGZmMDA1MSxcbiAgICAgICAgICBzaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZyxcbiAgICAgICAgICBtZXRhbG5lc3M6IDAsXG4gICAgICAgICAgcm91Z2huZXNzOiAwLjhcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBzaGFwZU9uZS5wb3NpdGlvbi55ICs9IDEwO1xuICAgICAgc2hhcGVPbmUucm90YXRlWihNYXRoLlBJIC8gMyk7XG4gICAgICBzaGFwZU9uZS5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICAgIHNjZW5lLmFkZChzaGFwZU9uZSk7XG5cbiAgICAgIC8vIEFkZCBhIHNlY29uZCBzaGFwZVxuICAgICAgY29uc3Qgc2hhcGVUd28gPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgICAgbmV3IFRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeSg1LCAxKSxcbiAgICAgICAgbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgICAgICBjb2xvcjogMHg0NzY4OWIsXG4gICAgICAgICAgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsXG4gICAgICAgICAgbWV0YWxuZXNzOiAwLFxuICAgICAgICAgIHJvdWdobmVzczogMC44XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgc2hhcGVUd28ucG9zaXRpb24ueSArPSA1O1xuICAgICAgc2hhcGVUd28ucG9zaXRpb24ueCArPSAxNTtcbiAgICAgIHNoYXBlVHdvLnJvdGF0ZVooTWF0aC5QSSAvIDUpO1xuICAgICAgc2hhcGVUd28uY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICBzY2VuZS5hZGQoc2hhcGVUd28pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuXG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG5cbiAgICAgIC8vIHVwZGF0ZUNhbVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ2FtUG9zaXRpb24oKSB7XG4gICAgICBhbmdsZSArPSAwLjAwNTtcbiAgICAgIGNvbnN0IHogPSA1MCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIGNvbnN0IHkgPSA1MCAqIE1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgLy8gY2FtZXJhLnBvc2l0aW9uLnogPSB6O1xuICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgPSB5O1xuICAgICAgLy8gY2FtZXJhLnJvdGF0aW9uLnggPSB6ICogMC4wMjtcbiAgICB9XG5cbiAgICAvLyBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgLy8gICAvLyBjYW1lcmEuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgLy8gICBjYW1lcmEudXBkYXRlTWF0cml4KCk7XG4gICAgLy8gICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIC8vIH1cblxuICAgIC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemUpO1xuXG4gICAgZnVuY3Rpb24gaW5pdENvbnRyb2xzKCkge1xuICAgICAgY29uc3QgY29udHJvbHMgPSAgbmV3IE9yYml0Q29udHJvbHMoXG4gICAgICAgIGNhbWVyYSwgcmVuZGVyZXIuZG9tRWxlbWVudFxuICAgICAgKTtcbiAgICAgIGNvbnRyb2xzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDE1LCAwKTtcbiAgICAgIGNvbnRyb2xzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJIC8gMjtcbiAgICAgIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW5pdFNjZW5lKCk7XG4gICAgaW5pdExpZ2h0cygpO1xuICAgIGluaXRNZXNoKCk7XG4gICAgZ2VuZXJhdGVTaGFwZXMoKTtcbiAgICBpbml0Q29udHJvbHMoKTtcbiAgICByZW5kZXIoKTtcblxuICB9XG5cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50LnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQVdBO0FBQUE7QUE0SUE7QUExSUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUE1SUE7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\")},512:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar core_1 = __webpack_require__(4);\\r\\n// import {\\r\\n//   LoginService\\r\\n// } from \\'./login.service\\';\\r\\nvar LoginComponent = (function () {\\r\\n    function LoginComponent() {\\r\\n    }\\r\\n    // constructor(private loginService: LoginService) {}\\r\\n    LoginComponent.prototype.ngOnInit = function () {\\r\\n        // this.getData();\\r\\n    };\\r\\n    return LoginComponent;\\r\\n}());\\r\\nLoginComponent = __decorate([\\r\\n    core_1.Component({\\r\\n        selector: \\'cv-login\\',\\r\\n        template: __webpack_require__(861),\\r\\n        styles: [__webpack_require__(970)],\\r\\n    })\\r\\n], LoginComponent);\\r\\nexports.LoginComponent = LoginComponent;\\r\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9sb2dpbi9sb2dpbi5jb21wb25lbnQudHM/ZjNkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIE9uSW5pdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLy8gaW1wb3J0IHtcbi8vICAgTG9naW5TZXJ2aWNlXG4vLyB9IGZyb20gJy4vbG9naW4uc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2N2LWxvZ2luJyxcbiAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vbG9naW4uY29tcG9uZW50Lmh0bWwnKSxcbiAgc3R5bGVzOiBbcmVxdWlyZSgnLi9sb2dpbi5jb21wb25lbnQuc2NzcycpXSxcbiAgLy8gcHJvdmlkZXJzOiBbTG9naW5TZXJ2aWNlXVxufSlcblxuZXhwb3J0IGNsYXNzIExvZ2luQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAvLyBjb25zdHJ1Y3Rvcihwcml2YXRlIGxvZ2luU2VydmljZTogTG9naW5TZXJ2aWNlKSB7fVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAvLyB0aGlzLmdldERhdGEoKTtcbiAgfVxuXG4gIC8vIHByaXZhdGUgZ2V0RGF0YSgpIHtcbiAgLy8gICB0aGlzLmxvZ2luU2VydmljZS5nZXRKU09OKCkuc3Vic2NyaWJlKFxuICAvLyAgICAgKHJlc3VsdHM6IGFueSkgPT4ge1xuICAvLyAgICAgICBjb25zb2xlLndhcm4ocmVzdWx0cyk7XG4gIC8vICAgICB9LFxuICAvLyAgICAgKGVycm9yOiBhbnkpID0+IHtcbiAgLy8gICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgLy8gICAgIH1cbiAgLy8gICApO1xuICAvLyB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vdHNsaW50LWxvYWRlcj8/cmVmLS0wLTAhLi9zcmMvYXBwL2xvZ2luL2xvZ2luLmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQVNBO0FBQUE7QUFrQkE7QUFoQkE7QUFFQTtBQUNBO0FBQ0E7QUFZQTtBQUFBO0FBbEJBO0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9')},669:function(module,exports){eval(\"// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9zY3NzL2NvbW1vbi5zY3NzPzFiZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hc3NldHMvc2Nzcy9jb21tb24uc2Nzc1xuLy8gbW9kdWxlIGlkID0gNjY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\")},672:function(module,exports){eval(\"// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9oaWdobGlnaHQuanMvc3R5bGVzL2F0b20tb25lLWRhcmsuY3NzPzUyYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGlnaGxpZ2h0LmpzL3N0eWxlcy9hdG9tLW9uZS1kYXJrLmNzc1xuLy8gbW9kdWxlIGlkID0gNjcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\")},674:function(module,exports){eval(\"// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9xdWlsbC9kaXN0L3F1aWxsLnNub3cuY3NzP2Q0ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcXVpbGwvZGlzdC9xdWlsbC5zbm93LmNzc1xuLy8gbW9kdWxlIGlkID0gNjc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\")},856:function(module,exports){eval('module.exports = \"\\x3c!----\\x3e\\\\n<header class=\\\\\"cv-header\\\\\">\\\\n  <nav>\\\\n    <a routerLink=\\\\\"/\\\\\" routerLinkActive=\\\\\"active\\\\\" class=\\\\\"text-shadow-dark-2\\\\\" md-button>Home</a>\\\\n    <a routerLink=\\\\\"/bloglist\\\\\" routerLinkActive=\\\\\"active\\\\\" class=\\\\\"text-shadow-dark-2\\\\\" md-button>Blog</a>\\\\n    <a routerLink=\\\\\"/datav\\\\\" routerLinkActive=\\\\\"active\\\\\" class=\\\\\"text-shadow-dark-2\\\\\" md-button>DataV</a>\\\\n    <a href=\\\\\"\\\\\" class=\\\\\"text-shadow-dark-2\\\\\" md-button>About</a>\\\\n\\\\n    <a class=\\\\\"pull-right text-shadow-dark-2\\\\\" md-button [mdMenuTriggerFor]=\\\\\"theme\\\\\">Theme</a>\\\\n    <md-menu #theme=\\\\\"mdMenu\\\\\">\\\\n      <button md-menu-item>\\\\n        <md-icon class=\\\\\"text-dark\\\\\">dashboard</md-icon>\\\\n        <span>Material Dark</span>\\\\n       </button>\\\\n      <button md-menu-item>\\\\n         <md-icon class=\\\\\"text-orange\\\\\">dashboard</md-icon>\\\\n         <span>Brief Coffee</span>\\\\n       </button>\\\\n      <button md-menu-item>\\\\n        <md-icon class=\\\\\"text-blue\\\\\">dashboard</md-icon>\\\\n        <span>Blue Ocean</span>\\\\n      </button>\\\\n    </md-menu>\\\\n\\\\n    <a routerLink=\\\\\"/login\\\\\" routerLinkActive=\\\\\"active\\\\\" class=\\\\\"pull-right text-shadow-dark-2\\\\\" md-button>Login</a>\\\\n\\\\n    \\x3c!--<button class=\\\\\"pull-right text-shadow-dark-2\\\\\"  md-button [mdMenuTriggerFor]=\\\\\"account\\\\\">TaylorPzreal</button>\\\\n    <md-menu #account=\\\\\"mdMenu\\\\\">\\\\n      <button md-menu-item>\\\\n        <md-icon>account_box</md-icon>\\\\n        <span>My Profile</span>\\\\n       </button>\\\\n      <button md-menu-item>\\\\n         <md-icon>message</md-icon>\\\\n         <span>My Message</span>\\\\n       </button>\\\\n      <button md-menu-item>\\\\n        <md-icon>power_settings_new</md-icon>\\\\n        <span>Log Out</span>\\\\n      </button>\\\\n    </md-menu>--\\x3e\\\\n\\\\n    <span class=\\\\\"pull-right text-orange cv-label\\\\\">{{currentTime}}</span>\\\\n  </nav>\\\\n</header>\\\\n\\\\n\\x3c!----\\x3e\\\\n<section class=\\\\\"cv-content\\\\\">\\\\n  \\x3c!--<main>\\\\n    <h1>Curriculum Vitae Show</h1>\\\\n  </main>--\\x3e\\\\n\\\\n  \\x3c!----\\x3e\\\\n  <router-outlet></router-outlet> \\\\n</section>\\\\n\\\\n\\x3c!----\\x3e\\\\n<footer class=\\\\\"cv-footer\\\\\">\\\\n  <p>@2017 www.honeymorning.com On My Way.</p>\\\\n</footer>\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9hcHAuY29tcG9uZW50Lmh0bWw/OTUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPCEtLeWFrOWFsemhtumDqC0tPlxcbjxoZWFkZXIgY2xhc3M9XFxcImN2LWhlYWRlclxcXCI+XFxuICA8bmF2PlxcbiAgICA8YSByb3V0ZXJMaW5rPVxcXCIvXFxcIiByb3V0ZXJMaW5rQWN0aXZlPVxcXCJhY3RpdmVcXFwiIGNsYXNzPVxcXCJ0ZXh0LXNoYWRvdy1kYXJrLTJcXFwiIG1kLWJ1dHRvbj5Ib21lPC9hPlxcbiAgICA8YSByb3V0ZXJMaW5rPVxcXCIvYmxvZ2xpc3RcXFwiIHJvdXRlckxpbmtBY3RpdmU9XFxcImFjdGl2ZVxcXCIgY2xhc3M9XFxcInRleHQtc2hhZG93LWRhcmstMlxcXCIgbWQtYnV0dG9uPkJsb2c8L2E+XFxuICAgIDxhIHJvdXRlckxpbms9XFxcIi9kYXRhdlxcXCIgcm91dGVyTGlua0FjdGl2ZT1cXFwiYWN0aXZlXFxcIiBjbGFzcz1cXFwidGV4dC1zaGFkb3ctZGFyay0yXFxcIiBtZC1idXR0b24+RGF0YVY8L2E+XFxuICAgIDxhIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcInRleHQtc2hhZG93LWRhcmstMlxcXCIgbWQtYnV0dG9uPkFib3V0PC9hPlxcblxcbiAgICA8YSBjbGFzcz1cXFwicHVsbC1yaWdodCB0ZXh0LXNoYWRvdy1kYXJrLTJcXFwiIG1kLWJ1dHRvbiBbbWRNZW51VHJpZ2dlckZvcl09XFxcInRoZW1lXFxcIj5UaGVtZTwvYT5cXG4gICAgPG1kLW1lbnUgI3RoZW1lPVxcXCJtZE1lbnVcXFwiPlxcbiAgICAgIDxidXR0b24gbWQtbWVudS1pdGVtPlxcbiAgICAgICAgPG1kLWljb24gY2xhc3M9XFxcInRleHQtZGFya1xcXCI+ZGFzaGJvYXJkPC9tZC1pY29uPlxcbiAgICAgICAgPHNwYW4+TWF0ZXJpYWwgRGFyazwvc3Bhbj5cXG4gICAgICAgPC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBtZC1tZW51LWl0ZW0+XFxuICAgICAgICAgPG1kLWljb24gY2xhc3M9XFxcInRleHQtb3JhbmdlXFxcIj5kYXNoYm9hcmQ8L21kLWljb24+XFxuICAgICAgICAgPHNwYW4+QnJpZWYgQ29mZmVlPC9zcGFuPlxcbiAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIG1kLW1lbnUtaXRlbT5cXG4gICAgICAgIDxtZC1pY29uIGNsYXNzPVxcXCJ0ZXh0LWJsdWVcXFwiPmRhc2hib2FyZDwvbWQtaWNvbj5cXG4gICAgICAgIDxzcGFuPkJsdWUgT2NlYW48L3NwYW4+XFxuICAgICAgPC9idXR0b24+XFxuICAgIDwvbWQtbWVudT5cXG5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL2xvZ2luXFxcIiByb3V0ZXJMaW5rQWN0aXZlPVxcXCJhY3RpdmVcXFwiIGNsYXNzPVxcXCJwdWxsLXJpZ2h0IHRleHQtc2hhZG93LWRhcmstMlxcXCIgbWQtYnV0dG9uPkxvZ2luPC9hPlxcblxcbiAgICA8IS0tPGJ1dHRvbiBjbGFzcz1cXFwicHVsbC1yaWdodCB0ZXh0LXNoYWRvdy1kYXJrLTJcXFwiICBtZC1idXR0b24gW21kTWVudVRyaWdnZXJGb3JdPVxcXCJhY2NvdW50XFxcIj5UYXlsb3JQenJlYWw8L2J1dHRvbj5cXG4gICAgPG1kLW1lbnUgI2FjY291bnQ9XFxcIm1kTWVudVxcXCI+XFxuICAgICAgPGJ1dHRvbiBtZC1tZW51LWl0ZW0+XFxuICAgICAgICA8bWQtaWNvbj5hY2NvdW50X2JveDwvbWQtaWNvbj5cXG4gICAgICAgIDxzcGFuPk15IFByb2ZpbGU8L3NwYW4+XFxuICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gbWQtbWVudS1pdGVtPlxcbiAgICAgICAgIDxtZC1pY29uPm1lc3NhZ2U8L21kLWljb24+XFxuICAgICAgICAgPHNwYW4+TXkgTWVzc2FnZTwvc3Bhbj5cXG4gICAgICAgPC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBtZC1tZW51LWl0ZW0+XFxuICAgICAgICA8bWQtaWNvbj5wb3dlcl9zZXR0aW5nc19uZXc8L21kLWljb24+XFxuICAgICAgICA8c3Bhbj5Mb2cgT3V0PC9zcGFuPlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICA8L21kLW1lbnU+LS0+XFxuXFxuICAgIDxzcGFuIGNsYXNzPVxcXCJwdWxsLXJpZ2h0IHRleHQtb3JhbmdlIGN2LWxhYmVsXFxcIj57e2N1cnJlbnRUaW1lfX08L3NwYW4+XFxuICA8L25hdj5cXG48L2hlYWRlcj5cXG5cXG48IS0t6Lev55SxLS0+XFxuPHNlY3Rpb24gY2xhc3M9XFxcImN2LWNvbnRlbnRcXFwiPlxcbiAgPCEtLTxtYWluPlxcbiAgICA8aDE+Q3VycmljdWx1bSBWaXRhZSBTaG93PC9oMT5cXG4gIDwvbWFpbj4tLT5cXG5cXG4gIDwhLS3moLnot6/nlLEtLT5cXG4gIDxyb3V0ZXItb3V0bGV0Pjwvcm91dGVyLW91dGxldD4gXFxuPC9zZWN0aW9uPlxcblxcbjwhLS3lhazlhbHlupXpg6gtLT5cXG48Zm9vdGVyIGNsYXNzPVxcXCJjdi1mb290ZXJcXFwiPlxcbiAgPHA+QDIwMTcgd3d3LmhvbmV5bW9ybmluZy5jb20gT24gTXkgV2F5LjwvcD5cXG48L2Zvb3Rlcj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvYXBwLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSA4NTZcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==')},857:function(module,exports){eval('module.exports = \"<section class=\\\\\"container\\\\\" fxFlex fxLayoutAlign=\\\\\"center center\\\\\">\\\\n  <div class=\\\\\"margin-top-20 margin-bottom-20\\\\\" fxFlex=\\\\\"80%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxLayout=\\\\\"column\\\\\">\\\\n    <header>\\\\n      <h3>Blog</h3>\\\\n    </header>\\\\n    <div class=\\\\\"cv-editor\\\\\">\\\\n      <div id=\\\\\"toolbar\\\\\">\\\\n        \\\\n      </div>\\\\n      <div id=\\\\\"editor\\\\\"></div>\\\\n    </div>\\\\n  </div>\\\\n</section>\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ibG9nLWVkaXQvYmxvZy1lZGl0LmNvbXBvbmVudC5odG1sP2M2ODAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjxzZWN0aW9uIGNsYXNzPVxcXCJjb250YWluZXJcXFwiIGZ4RmxleCBmeExheW91dEFsaWduPVxcXCJjZW50ZXIgY2VudGVyXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1hcmdpbi10b3AtMjAgbWFyZ2luLWJvdHRvbS0yMFxcXCIgZnhGbGV4PVxcXCI4MCVcXFwiIGZ4RmxleC5sdC1zbT1cXFwiMTAwJVxcXCIgZnhMYXlvdXQ9XFxcImNvbHVtblxcXCI+XFxuICAgIDxoZWFkZXI+XFxuICAgICAgPGgzPue8lui+kUJsb2c8L2gzPlxcbiAgICA8L2hlYWRlcj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY3YtZWRpdG9yXFxcIj5cXG4gICAgICA8ZGl2IGlkPVxcXCJ0b29sYmFyXFxcIj5cXG4gICAgICAgIFxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgaWQ9XFxcImVkaXRvclxcXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9zZWN0aW9uPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9ibG9nLWVkaXQvYmxvZy1lZGl0LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSA4NTdcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==')},858:function(module,exports){eval('module.exports = \"<section fxFlex=\\\\\"100%\\\\\" fxLayout=\\\\\"column\\\\\" fxLayoutAlign=\\\\\"start center\\\\\">\\\\n  <header class=\\\\\"container margin-top-20\\\\\">\\\\n    <a routerLink=\\\\\"/blogedit\\\\\" routerLinkActive=\\\\\"active\\\\\" class=\\\\\"text-shadow-dark-2\\\\\" md-button>\\\\n      <md-icon class=\\\\\"text-dark\\\\\">add</md-icon> Add Blog\\\\n    </a>\\\\n  </header>\\\\n\\\\n  <div class=\\\\\"containerX\\\\\" fxFlex=\\\\\"100%\\\\\" fxLayoutAlign=\\\\\"center center\\\\\">\\\\n    <div class=\\\\\"container\\\\\">\\\\n      <div class=\\\\\"margin-top-20 margin-bottom-20\\\\\" fxFlex=\\\\\"100%\\\\\" fxLayoutAlign=\\\\\"space-around stretch\\\\\">\\\\n\\\\n        <md-card class=\\\\\"box-shadow-dark-3 overflow-auto\\\\\" fxFlex=\\\\\"32%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxLayout=\\\\\"column\\\\\">\\\\n          <md-card-header>\\\\n            <md-card-title>CSS</md-card-title>2017-05-19 07:35:11\\\\n          </md-card-header>\\\\n\\\\n          <md-card-content>\\\\n            <div>\\\\n              Transform, Transtion, Animation\\\\n              <div class=\\\\\"css-animation\\\\\"></div>\\\\n              <pre>\\\\n              <code class=\\\\\"javascript\\\\\">\\\\nlet a = 2;\\\\n              </code>\\\\n            </pre>\\\\n            </div>\\\\n          </md-card-content>\\\\n        </md-card>\\\\n\\\\n        <md-card class=\\\\\"box-shadow-dark-3 css-gradient overflow-auto\\\\\" fxFlex=\\\\\"32%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxlayout=\\\\\"column\\\\\">\\\\n          <md-card-header>\\\\n            <md-card-title>CSS</md-card-title>2017-05-19 07:35:21\\\\n          </md-card-header>\\\\n\\\\n          <md-card-content class=\\\\\"css-gradienst\\\\\">\\\\n            <pre>\\\\n              <code class=\\\\\"css\\\\\">\\\\n                {{cssGradienst}}\\\\n              </code>\\\\n            </pre>\\\\n          </md-card-content>\\\\n        </md-card>\\\\n\\\\n        <md-card class=\\\\\"box-shadow-dark-3 overflow-auto\\\\\" fxFlex=\\\\\"32%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxLayout=\\\\\"column\\\\\">\\\\n          <md-card-header>\\\\n            <md-card-title>Card</md-card-title>2017-05-19 07:35:24\\\\n          </md-card-header>\\\\n\\\\n          <md-card-content>\\\\n            <pre>\\\\n              <code class=\\\\\"html\\\\\">\\\\n                {{cardhtml}}\\\\n              </code>\\\\n            </pre>\\\\n          </md-card-content>\\\\n        </md-card>\\\\n      </div>\\\\n    </div>\\\\n  </div>\\\\n\\\\n</section>\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ibG9nLWxpc3QvYmxvZy1saXN0LmNvbXBvbmVudC5odG1sPzliNTAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjxzZWN0aW9uIGZ4RmxleD1cXFwiMTAwJVxcXCIgZnhMYXlvdXQ9XFxcImNvbHVtblxcXCIgZnhMYXlvdXRBbGlnbj1cXFwic3RhcnQgY2VudGVyXFxcIj5cXG4gIDxoZWFkZXIgY2xhc3M9XFxcImNvbnRhaW5lciBtYXJnaW4tdG9wLTIwXFxcIj5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL2Jsb2dlZGl0XFxcIiByb3V0ZXJMaW5rQWN0aXZlPVxcXCJhY3RpdmVcXFwiIGNsYXNzPVxcXCJ0ZXh0LXNoYWRvdy1kYXJrLTJcXFwiIG1kLWJ1dHRvbj5cXG4gICAgICA8bWQtaWNvbiBjbGFzcz1cXFwidGV4dC1kYXJrXFxcIj5hZGQ8L21kLWljb24+IEFkZCBCbG9nXFxuICAgIDwvYT5cXG4gIDwvaGVhZGVyPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyWFxcXCIgZnhGbGV4PVxcXCIxMDAlXFxcIiBmeExheW91dEFsaWduPVxcXCJjZW50ZXIgY2VudGVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtYXJnaW4tdG9wLTIwIG1hcmdpbi1ib3R0b20tMjBcXFwiIGZ4RmxleD1cXFwiMTAwJVxcXCIgZnhMYXlvdXRBbGlnbj1cXFwic3BhY2UtYXJvdW5kIHN0cmV0Y2hcXFwiPlxcblxcbiAgICAgICAgPG1kLWNhcmQgY2xhc3M9XFxcImJveC1zaGFkb3ctZGFyay0zIG92ZXJmbG93LWF1dG9cXFwiIGZ4RmxleD1cXFwiMzIlXFxcIiBmeEZsZXgubHQtc209XFxcIjEwMCVcXFwiIGZ4TGF5b3V0PVxcXCJjb2x1bW5cXFwiPlxcbiAgICAgICAgICA8bWQtY2FyZC1oZWFkZXI+XFxuICAgICAgICAgICAgPG1kLWNhcmQtdGl0bGU+Q1NT5Yqo55S7PC9tZC1jYXJkLXRpdGxlPjIwMTctMDUtMTkgMDc6MzU6MTFcXG4gICAgICAgICAgPC9tZC1jYXJkLWhlYWRlcj5cXG5cXG4gICAgICAgICAgPG1kLWNhcmQtY29udGVudD5cXG4gICAgICAgICAgICA8ZGl2PlxcbiAgICAgICAgICAgICAgVHJhbnNmb3JtLCBUcmFuc3Rpb24sIEFuaW1hdGlvblxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY3NzLWFuaW1hdGlvblxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICA8cHJlPlxcbiAgICAgICAgICAgICAgPGNvZGUgY2xhc3M9XFxcImphdmFzY3JpcHRcXFwiPlxcbmxldCBhID0gMjtcXG4gICAgICAgICAgICAgIDwvY29kZT5cXG4gICAgICAgICAgICA8L3ByZT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC9tZC1jYXJkLWNvbnRlbnQ+XFxuICAgICAgICA8L21kLWNhcmQ+XFxuXFxuICAgICAgICA8bWQtY2FyZCBjbGFzcz1cXFwiYm94LXNoYWRvdy1kYXJrLTMgY3NzLWdyYWRpZW50IG92ZXJmbG93LWF1dG9cXFwiIGZ4RmxleD1cXFwiMzIlXFxcIiBmeEZsZXgubHQtc209XFxcIjEwMCVcXFwiIGZ4bGF5b3V0PVxcXCJjb2x1bW5cXFwiPlxcbiAgICAgICAgICA8bWQtY2FyZC1oZWFkZXI+XFxuICAgICAgICAgICAgPG1kLWNhcmQtdGl0bGU+Q1NT5riQ5Y+YPC9tZC1jYXJkLXRpdGxlPjIwMTctMDUtMTkgMDc6MzU6MjFcXG4gICAgICAgICAgPC9tZC1jYXJkLWhlYWRlcj5cXG5cXG4gICAgICAgICAgPG1kLWNhcmQtY29udGVudCBjbGFzcz1cXFwiY3NzLWdyYWRpZW5zdFxcXCI+XFxuICAgICAgICAgICAgPHByZT5cXG4gICAgICAgICAgICAgIDxjb2RlIGNsYXNzPVxcXCJjc3NcXFwiPlxcbiAgICAgICAgICAgICAgICB7e2Nzc0dyYWRpZW5zdH19XFxuICAgICAgICAgICAgICA8L2NvZGU+XFxuICAgICAgICAgICAgPC9wcmU+XFxuICAgICAgICAgIDwvbWQtY2FyZC1jb250ZW50PlxcbiAgICAgICAgPC9tZC1jYXJkPlxcblxcbiAgICAgICAgPG1kLWNhcmQgY2xhc3M9XFxcImJveC1zaGFkb3ctZGFyay0zIG92ZXJmbG93LWF1dG9cXFwiIGZ4RmxleD1cXFwiMzIlXFxcIiBmeEZsZXgubHQtc209XFxcIjEwMCVcXFwiIGZ4TGF5b3V0PVxcXCJjb2x1bW5cXFwiPlxcbiAgICAgICAgICA8bWQtY2FyZC1oZWFkZXI+XFxuICAgICAgICAgICAgPG1kLWNhcmQtdGl0bGU+Q2FyZOW4g+WxgDwvbWQtY2FyZC10aXRsZT4yMDE3LTA1LTE5IDA3OjM1OjI0XFxuICAgICAgICAgIDwvbWQtY2FyZC1oZWFkZXI+XFxuXFxuICAgICAgICAgIDxtZC1jYXJkLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPHByZT5cXG4gICAgICAgICAgICAgIDxjb2RlIGNsYXNzPVxcXCJodG1sXFxcIj5cXG4gICAgICAgICAgICAgICAge3tjYXJkaHRtbH19XFxuICAgICAgICAgICAgICA8L2NvZGU+XFxuICAgICAgICAgICAgPC9wcmU+XFxuICAgICAgICAgIDwvbWQtY2FyZC1jb250ZW50PlxcbiAgICAgICAgPC9tZC1jYXJkPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2Plxcblxcbjwvc2VjdGlvbj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvYmxvZy1saXN0L2Jsb2ctbGlzdC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gODU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=')},859:function(module,exports){eval('module.exports = \"\\x3c!----\\x3e\\\\n<section class=\\\\\"container\\\\\">\\\\n  <div class=\\\\\"padding-16\\\\\" fxLayout=\\\\\"column\\\\\">\\\\n    <md-card fxFlex=\\\\\"100%\\\\\"  fxLayoutAlign=\\\\\"center center\\\\\">\\\\n      <div id=\\\\\"knowledge\\\\\" class=\\\\\"\\\\\"></div>\\\\n    </md-card>\\\\n    \\\\n    <md-card class=\\\\\"margin-top-24\\\\\" fxFlex=\\\\\"100%\\\\\" fxLayoutAlign=\\\\\"center center\\\\\">\\\\n      <div id=\\\\\"texture\\\\\"></div>\\\\n    </md-card>\\\\n  </div>\\\\n</section>\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9kYXRhdi9kYXRhdi5jb21wb25lbnQuaHRtbD8xYTBhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8IS0t5pWw5o2u5Y+v6KeG5YyW5bGV56S6LS0+XFxuPHNlY3Rpb24gY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nLTE2XFxcIiBmeExheW91dD1cXFwiY29sdW1uXFxcIj5cXG4gICAgPG1kLWNhcmQgZnhGbGV4PVxcXCIxMDAlXFxcIiAgZnhMYXlvdXRBbGlnbj1cXFwiY2VudGVyIGNlbnRlclxcXCI+XFxuICAgICAgPGRpdiBpZD1cXFwia25vd2xlZGdlXFxcIiBjbGFzcz1cXFwiXFxcIj48L2Rpdj5cXG4gICAgPC9tZC1jYXJkPlxcbiAgICBcXG4gICAgPG1kLWNhcmQgY2xhc3M9XFxcIm1hcmdpbi10b3AtMjRcXFwiIGZ4RmxleD1cXFwiMTAwJVxcXCIgZnhMYXlvdXRBbGlnbj1cXFwiY2VudGVyIGNlbnRlclxcXCI+XFxuICAgICAgPGRpdiBpZD1cXFwidGV4dHVyZVxcXCI+PC9kaXY+XFxuICAgIDwvbWQtY2FyZD5cXG4gIDwvZGl2Plxcbjwvc2VjdGlvbj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvZGF0YXYvZGF0YXYuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDg1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9')},860:function(module,exports){\neval('module.exports = \"<section class=\\\\\"padding-top-20\\\\\">\\\\n  <div id=\\\\\"honeythree\\\\\"></div>\\\\n  <div id=\\\\\"container\\\\\"><br><br><br><br><br>Generating World</div>\\\\n</section>\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmh0bWw/NmNkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPHNlY3Rpb24gY2xhc3M9XFxcInBhZGRpbmctdG9wLTIwXFxcIj5cXG4gIDxkaXYgaWQ9XFxcImhvbmV5dGhyZWVcXFwiPjwvZGl2PlxcbiAgPGRpdiBpZD1cXFwiY29udGFpbmVyXFxcIj48YnI+PGJyPjxicj48YnI+PGJyPkdlbmVyYXRpbmcgV29ybGQ8L2Rpdj5cXG48L3NlY3Rpb24+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gODYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=')},861:function(module,exports){eval('module.exports = \"<section class=\\\\\"containerX\\\\\">\\\\n  <div class=\\\\\"container\\\\\">\\\\n    <div class=\\\\\"margin-top-40 margin-bottom-40\\\\\" fxFlex fxLayoutAlign=\\\\\"center center\\\\\">\\\\n      <md-card class=\\\\\"box-shadow-dark-3\\\\\" fxFlex=\\\\\"60%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxLayout=\\\\\"row\\\\\" fxLayout.sm=\\\\\"column\\\\\" fxLayout.xs=\\\\\"column\\\\\">\\\\n\\\\n        <div class=\\\\\"login-bg\\\\\" fxFlex=\\\\\"50%\\\\\">\\\\n          \\x3c!--<img src=\\\\\"/src/assets/images/usercenter/login_bg_2.jpg\\\\\" alt=\\\\\"\\\\\">--\\x3e\\\\n          <div class=\\\\\"starme\\\\\">\\\\n            <a href=\\\\\"https://github.com/TaylorPzreal/curriculum-vitae\\\\\" target=\\\\\"_blank\\\\\" rel=\\\\\"noopener noreferrer\\\\\" md-button>Star CV</a>\\\\n          </div>\\\\n        </div>\\\\n\\\\n        <div class=\\\\\"relative padding-bottom-24 padding-16\\\\\" fxFlex=\\\\\"50%\\\\\">\\\\n          <md-card-header>\\\\n            <md-card-title>Welcome To CV</md-card-title>\\\\n          </md-card-header>\\\\n\\\\n          <md-card-content>\\\\n            <form>\\\\n              <div fxLayout=\\\\\"column\\\\\">\\\\n                <md-input-container fxFlex=\\\\\"100%\\\\\">\\\\n                  <input type=\\\\\"text\\\\\" name=\\\\\"\\\\\" value=\\\\\"\\\\\" mdInput placeholder=\\\\\"Name\\\\\">\\\\n                </md-input-container>\\\\n                <md-input-container fxFlex=\\\\\"100%\\\\\">\\\\n                  <input type=\\\\\"text\\\\\" mdInput placeholder=\\\\\"Password\\\\\">\\\\n                </md-input-container>\\\\n              </div>\\\\n            </form>\\\\n          </md-card-content>\\\\n\\\\n          <md-card-actions fxLayoutAlign=\\\\\"center center\\\\\">\\\\n            <button md-raised-button class=\\\\\"mat-default\\\\\"><i class=\\\\\"fa fa-github mat-primary\\\\\"></i> Log in with Github</button>\\\\n            <button type=\\\\\"\\\\\" class=\\\\\"mat-primary\\\\\" md-raised-button><md-icon>arrow_forward</md-icon>Log In</button>\\\\n          </md-card-actions>\\\\n\\\\n          <md-card-footer>\\\\n            <button md-button fxFlex fxFlexAlign=\\\\\"start\\\\\">Sign Up</button>\\\\n            <button md-button fxFlex fxFlexAlign=\\\\\"end\\\\\">Forget Password?</button>\\\\n          </md-card-footer>\\\\n\\\\n        </div>\\\\n      </md-card>\\\\n    </div>\\\\n  </div>\\\\n\\\\n</section>\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9sb2dpbi9sb2dpbi5jb21wb25lbnQuaHRtbD81ZjUwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8c2VjdGlvbiBjbGFzcz1cXFwiY29udGFpbmVyWFxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtYXJnaW4tdG9wLTQwIG1hcmdpbi1ib3R0b20tNDBcXFwiIGZ4RmxleCBmeExheW91dEFsaWduPVxcXCJjZW50ZXIgY2VudGVyXFxcIj5cXG4gICAgICA8bWQtY2FyZCBjbGFzcz1cXFwiYm94LXNoYWRvdy1kYXJrLTNcXFwiIGZ4RmxleD1cXFwiNjAlXFxcIiBmeEZsZXgubHQtc209XFxcIjEwMCVcXFwiIGZ4TGF5b3V0PVxcXCJyb3dcXFwiIGZ4TGF5b3V0LnNtPVxcXCJjb2x1bW5cXFwiIGZ4TGF5b3V0LnhzPVxcXCJjb2x1bW5cXFwiPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibG9naW4tYmdcXFwiIGZ4RmxleD1cXFwiNTAlXFxcIj5cXG4gICAgICAgICAgPCEtLTxpbWcgc3JjPVxcXCIvc3JjL2Fzc2V0cy9pbWFnZXMvdXNlcmNlbnRlci9sb2dpbl9iZ18yLmpwZ1xcXCIgYWx0PVxcXCJcXFwiPi0tPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzdGFybWVcXFwiPlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9UYXlsb3JQenJlYWwvY3VycmljdWx1bS12aXRhZVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIHJlbD1cXFwibm9vcGVuZXIgbm9yZWZlcnJlclxcXCIgbWQtYnV0dG9uPlN0YXIgQ1Y8L2E+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZSBwYWRkaW5nLWJvdHRvbS0yNCBwYWRkaW5nLTE2XFxcIiBmeEZsZXg9XFxcIjUwJVxcXCI+XFxuICAgICAgICAgIDxtZC1jYXJkLWhlYWRlcj5cXG4gICAgICAgICAgICA8bWQtY2FyZC10aXRsZT5XZWxjb21lIFRvIENWPC9tZC1jYXJkLXRpdGxlPlxcbiAgICAgICAgICA8L21kLWNhcmQtaGVhZGVyPlxcblxcbiAgICAgICAgICA8bWQtY2FyZC1jb250ZW50PlxcbiAgICAgICAgICAgIDxmb3JtPlxcbiAgICAgICAgICAgICAgPGRpdiBmeExheW91dD1cXFwiY29sdW1uXFxcIj5cXG4gICAgICAgICAgICAgICAgPG1kLWlucHV0LWNvbnRhaW5lciBmeEZsZXg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJcXFwiIHZhbHVlPVxcXCJcXFwiIG1kSW5wdXQgcGxhY2Vob2xkZXI9XFxcIk5hbWVcXFwiPlxcbiAgICAgICAgICAgICAgICA8L21kLWlucHV0LWNvbnRhaW5lcj5cXG4gICAgICAgICAgICAgICAgPG1kLWlucHV0LWNvbnRhaW5lciBmeEZsZXg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBtZElucHV0IHBsYWNlaG9sZGVyPVxcXCJQYXNzd29yZFxcXCI+XFxuICAgICAgICAgICAgICAgIDwvbWQtaW5wdXQtY29udGFpbmVyPlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9mb3JtPlxcbiAgICAgICAgICA8L21kLWNhcmQtY29udGVudD5cXG5cXG4gICAgICAgICAgPG1kLWNhcmQtYWN0aW9ucyBmeExheW91dEFsaWduPVxcXCJjZW50ZXIgY2VudGVyXFxcIj5cXG4gICAgICAgICAgICA8YnV0dG9uIG1kLXJhaXNlZC1idXR0b24gY2xhc3M9XFxcIm1hdC1kZWZhdWx0XFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtZ2l0aHViIG1hdC1wcmltYXJ5XFxcIj48L2k+IExvZyBpbiB3aXRoIEdpdGh1YjwvYnV0dG9uPlxcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiXFxcIiBjbGFzcz1cXFwibWF0LXByaW1hcnlcXFwiIG1kLXJhaXNlZC1idXR0b24+PG1kLWljb24+YXJyb3dfZm9yd2FyZDwvbWQtaWNvbj5Mb2cgSW48L2J1dHRvbj5cXG4gICAgICAgICAgPC9tZC1jYXJkLWFjdGlvbnM+XFxuXFxuICAgICAgICAgIDxtZC1jYXJkLWZvb3Rlcj5cXG4gICAgICAgICAgICA8YnV0dG9uIG1kLWJ1dHRvbiBmeEZsZXggZnhGbGV4QWxpZ249XFxcInN0YXJ0XFxcIj5TaWduIFVwPC9idXR0b24+XFxuICAgICAgICAgICAgPGJ1dHRvbiBtZC1idXR0b24gZnhGbGV4IGZ4RmxleEFsaWduPVxcXCJlbmRcXFwiPkZvcmdldCBQYXNzd29yZD88L2J1dHRvbj5cXG4gICAgICAgICAgPC9tZC1jYXJkLWZvb3Rlcj5cXG5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvbWQtY2FyZD5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG5cXG48L3NlY3Rpb24+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2xvZ2luL2xvZ2luLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSA4NjFcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==')},864:function(module,exports,__webpack_require__){\neval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n * jQuery JavaScript Library v3.2.1\\n * https://jquery.com/\\n *\\n * Includes Sizzle.js\\n * https://sizzlejs.com/\\n *\\n * Copyright JS Foundation and other contributors\\n * Released under the MIT license\\n * https://jquery.org/license\\n *\\n * Date: 2017-03-20T18:59Z\\n */\\n( function( global, factory ) {\\n\\n\\t\"use strict\";\\n\\n\\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\\n\\n\\t\\t// For CommonJS and CommonJS-like environments where a proper `window`\\n\\t\\t// is present, execute the factory and get jQuery.\\n\\t\\t// For environments that do not have a `window` with a `document`\\n\\t\\t// (such as Node.js), expose a factory as module.exports.\\n\\t\\t// This accentuates the need for the creation of a real `window`.\\n\\t\\t// e.g. var jQuery = require(\"jquery\")(window);\\n\\t\\t// See ticket #14549 for more info.\\n\\t\\tmodule.exports = global.document ?\\n\\t\\t\\tfactory( global, true ) :\\n\\t\\t\\tfunction( w ) {\\n\\t\\t\\t\\tif ( !w.document ) {\\n\\t\\t\\t\\t\\tthrow new Error( \"jQuery requires a window with a document\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn factory( w );\\n\\t\\t\\t};\\n\\t} else {\\n\\t\\tfactory( global );\\n\\t}\\n\\n// Pass this if window is not defined yet\\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\\n\\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\\n// enough that all such attempts are guarded in a try block.\\n\"use strict\";\\n\\nvar arr = [];\\n\\nvar document = window.document;\\n\\nvar getProto = Object.getPrototypeOf;\\n\\nvar slice = arr.slice;\\n\\nvar concat = arr.concat;\\n\\nvar push = arr.push;\\n\\nvar indexOf = arr.indexOf;\\n\\nvar class2type = {};\\n\\nvar toString = class2type.toString;\\n\\nvar hasOwn = class2type.hasOwnProperty;\\n\\nvar fnToString = hasOwn.toString;\\n\\nvar ObjectFunctionString = fnToString.call( Object );\\n\\nvar support = {};\\n\\n\\n\\n\\tfunction DOMEval( code, doc ) {\\n\\t\\tdoc = doc || document;\\n\\n\\t\\tvar script = doc.createElement( \"script\" );\\n\\n\\t\\tscript.text = code;\\n\\t\\tdoc.head.appendChild( script ).parentNode.removeChild( script );\\n\\t}\\n/* global Symbol */\\n// Defining this global in .eslintrc.json would create a danger of using the global\\n// unguarded in another place, it seems safer to define global only for this module\\n\\n\\n\\nvar\\n\\tversion = \"3.2.1\",\\n\\n\\t// Define a local copy of jQuery\\n\\tjQuery = function( selector, context ) {\\n\\n\\t\\t// The jQuery object is actually just the init constructor \\'enhanced\\'\\n\\t\\t// Need init if jQuery is called (just allow error to be thrown if not included)\\n\\t\\treturn new jQuery.fn.init( selector, context );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\t// Make sure we trim BOM and NBSP\\n\\trtrim = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g,\\n\\n\\t// Matches dashed string for camelizing\\n\\trmsPrefix = /^-ms-/,\\n\\trdashAlpha = /-([a-z])/g,\\n\\n\\t// Used by jQuery.camelCase as callback to replace()\\n\\tfcamelCase = function( all, letter ) {\\n\\t\\treturn letter.toUpperCase();\\n\\t};\\n\\njQuery.fn = jQuery.prototype = {\\n\\n\\t// The current version of jQuery being used\\n\\tjquery: version,\\n\\n\\tconstructor: jQuery,\\n\\n\\t// The default length of a jQuery object is 0\\n\\tlength: 0,\\n\\n\\ttoArray: function() {\\n\\t\\treturn slice.call( this );\\n\\t},\\n\\n\\t// Get the Nth element in the matched element set OR\\n\\t// Get the whole matched element set as a clean array\\n\\tget: function( num ) {\\n\\n\\t\\t// Return all the elements in a clean array\\n\\t\\tif ( num == null ) {\\n\\t\\t\\treturn slice.call( this );\\n\\t\\t}\\n\\n\\t\\t// Return just the one element from the set\\n\\t\\treturn num < 0 ? this[ num + this.length ] : this[ num ];\\n\\t},\\n\\n\\t// Take an array of elements and push it onto the stack\\n\\t// (returning the new matched element set)\\n\\tpushStack: function( elems ) {\\n\\n\\t\\t// Build a new jQuery matched element set\\n\\t\\tvar ret = jQuery.merge( this.constructor(), elems );\\n\\n\\t\\t// Add the old object onto the stack (as a reference)\\n\\t\\tret.prevObject = this;\\n\\n\\t\\t// Return the newly-formed element set\\n\\t\\treturn ret;\\n\\t},\\n\\n\\t// Execute a callback for every element in the matched set.\\n\\teach: function( callback ) {\\n\\t\\treturn jQuery.each( this, callback );\\n\\t},\\n\\n\\tmap: function( callback ) {\\n\\t\\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\\n\\t\\t\\treturn callback.call( elem, i, elem );\\n\\t\\t} ) );\\n\\t},\\n\\n\\tslice: function() {\\n\\t\\treturn this.pushStack( slice.apply( this, arguments ) );\\n\\t},\\n\\n\\tfirst: function() {\\n\\t\\treturn this.eq( 0 );\\n\\t},\\n\\n\\tlast: function() {\\n\\t\\treturn this.eq( -1 );\\n\\t},\\n\\n\\teq: function( i ) {\\n\\t\\tvar len = this.length,\\n\\t\\t\\tj = +i + ( i < 0 ? len : 0 );\\n\\t\\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\\n\\t},\\n\\n\\tend: function() {\\n\\t\\treturn this.prevObject || this.constructor();\\n\\t},\\n\\n\\t// For internal use only.\\n\\t// Behaves like an Array\\'s method, not like a jQuery method.\\n\\tpush: push,\\n\\tsort: arr.sort,\\n\\tsplice: arr.splice\\n};\\n\\njQuery.extend = jQuery.fn.extend = function() {\\n\\tvar options, name, src, copy, copyIsArray, clone,\\n\\t\\ttarget = arguments[ 0 ] || {},\\n\\t\\ti = 1,\\n\\t\\tlength = arguments.length,\\n\\t\\tdeep = false;\\n\\n\\t// Handle a deep copy situation\\n\\tif ( typeof target === \"boolean\" ) {\\n\\t\\tdeep = target;\\n\\n\\t\\t// Skip the boolean and the target\\n\\t\\ttarget = arguments[ i ] || {};\\n\\t\\ti++;\\n\\t}\\n\\n\\t// Handle case when target is a string or something (possible in deep copy)\\n\\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\\n\\t\\ttarget = {};\\n\\t}\\n\\n\\t// Extend jQuery itself if only one argument is passed\\n\\tif ( i === length ) {\\n\\t\\ttarget = this;\\n\\t\\ti--;\\n\\t}\\n\\n\\tfor ( ; i < length; i++ ) {\\n\\n\\t\\t// Only deal with non-null/undefined values\\n\\t\\tif ( ( options = arguments[ i ] ) != null ) {\\n\\n\\t\\t\\t// Extend the base object\\n\\t\\t\\tfor ( name in options ) {\\n\\t\\t\\t\\tsrc = target[ name ];\\n\\t\\t\\t\\tcopy = options[ name ];\\n\\n\\t\\t\\t\\t// Prevent never-ending loop\\n\\t\\t\\t\\tif ( target === copy ) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Recurse if we\\'re merging plain objects or arrays\\n\\t\\t\\t\\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\\n\\t\\t\\t\\t\\t( copyIsArray = Array.isArray( copy ) ) ) ) {\\n\\n\\t\\t\\t\\t\\tif ( copyIsArray ) {\\n\\t\\t\\t\\t\\t\\tcopyIsArray = false;\\n\\t\\t\\t\\t\\t\\tclone = src && Array.isArray( src ) ? src : [];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tclone = src && jQuery.isPlainObject( src ) ? src : {};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Never move original objects, clone them\\n\\t\\t\\t\\t\\ttarget[ name ] = jQuery.extend( deep, clone, copy );\\n\\n\\t\\t\\t\\t// Don\\'t bring in undefined values\\n\\t\\t\\t\\t} else if ( copy !== undefined ) {\\n\\t\\t\\t\\t\\ttarget[ name ] = copy;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the modified object\\n\\treturn target;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Unique for each copy of jQuery on the page\\n\\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\\\D/g, \"\" ),\\n\\n\\t// Assume jQuery is ready without the ready module\\n\\tisReady: true,\\n\\n\\terror: function( msg ) {\\n\\t\\tthrow new Error( msg );\\n\\t},\\n\\n\\tnoop: function() {},\\n\\n\\tisFunction: function( obj ) {\\n\\t\\treturn jQuery.type( obj ) === \"function\";\\n\\t},\\n\\n\\tisWindow: function( obj ) {\\n\\t\\treturn obj != null && obj === obj.window;\\n\\t},\\n\\n\\tisNumeric: function( obj ) {\\n\\n\\t\\t// As of jQuery 3.0, isNumeric is limited to\\n\\t\\t// strings and numbers (primitives or objects)\\n\\t\\t// that can be coerced to finite numbers (gh-2662)\\n\\t\\tvar type = jQuery.type( obj );\\n\\t\\treturn ( type === \"number\" || type === \"string\" ) &&\\n\\n\\t\\t\\t// parseFloat NaNs numeric-cast false positives (\"\")\\n\\t\\t\\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\\n\\t\\t\\t// subtraction forces infinities to NaN\\n\\t\\t\\t!isNaN( obj - parseFloat( obj ) );\\n\\t},\\n\\n\\tisPlainObject: function( obj ) {\\n\\t\\tvar proto, Ctor;\\n\\n\\t\\t// Detect obvious negatives\\n\\t\\t// Use toString instead of jQuery.type to catch host objects\\n\\t\\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tproto = getProto( obj );\\n\\n\\t\\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\\n\\t\\tif ( !proto ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Objects with prototype are plain iff they were constructed by a global Object function\\n\\t\\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\\n\\t\\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\\n\\t},\\n\\n\\tisEmptyObject: function( obj ) {\\n\\n\\t\\t/* eslint-disable no-unused-vars */\\n\\t\\t// See https://github.com/eslint/eslint/issues/6125\\n\\t\\tvar name;\\n\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t},\\n\\n\\ttype: function( obj ) {\\n\\t\\tif ( obj == null ) {\\n\\t\\t\\treturn obj + \"\";\\n\\t\\t}\\n\\n\\t\\t// Support: Android <=2.3 only (functionish RegExp)\\n\\t\\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\\n\\t\\t\\tclass2type[ toString.call( obj ) ] || \"object\" :\\n\\t\\t\\ttypeof obj;\\n\\t},\\n\\n\\t// Evaluates a script in a global context\\n\\tglobalEval: function( code ) {\\n\\t\\tDOMEval( code );\\n\\t},\\n\\n\\t// Convert dashed to camelCase; used by the css and data modules\\n\\t// Support: IE <=9 - 11, Edge 12 - 13\\n\\t// Microsoft forgot to hump their vendor prefix (#9572)\\n\\tcamelCase: function( string ) {\\n\\t\\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\\n\\t},\\n\\n\\teach: function( obj, callback ) {\\n\\t\\tvar length, i = 0;\\n\\n\\t\\tif ( isArrayLike( obj ) ) {\\n\\t\\t\\tlength = obj.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in obj ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn obj;\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\ttrim: function( text ) {\\n\\t\\treturn text == null ?\\n\\t\\t\\t\"\" :\\n\\t\\t\\t( text + \"\" ).replace( rtrim, \"\" );\\n\\t},\\n\\n\\t// results is for internal usage only\\n\\tmakeArray: function( arr, results ) {\\n\\t\\tvar ret = results || [];\\n\\n\\t\\tif ( arr != null ) {\\n\\t\\t\\tif ( isArrayLike( Object( arr ) ) ) {\\n\\t\\t\\t\\tjQuery.merge( ret,\\n\\t\\t\\t\\t\\ttypeof arr === \"string\" ?\\n\\t\\t\\t\\t\\t[ arr ] : arr\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.call( ret, arr );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n\\t},\\n\\n\\tinArray: function( elem, arr, i ) {\\n\\t\\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\tmerge: function( first, second ) {\\n\\t\\tvar len = +second.length,\\n\\t\\t\\tj = 0,\\n\\t\\t\\ti = first.length;\\n\\n\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\tfirst[ i++ ] = second[ j ];\\n\\t\\t}\\n\\n\\t\\tfirst.length = i;\\n\\n\\t\\treturn first;\\n\\t},\\n\\n\\tgrep: function( elems, callback, invert ) {\\n\\t\\tvar callbackInverse,\\n\\t\\t\\tmatches = [],\\n\\t\\t\\ti = 0,\\n\\t\\t\\tlength = elems.length,\\n\\t\\t\\tcallbackExpect = !invert;\\n\\n\\t\\t// Go through the array, only saving the items\\n\\t\\t// that pass the validator function\\n\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\tcallbackInverse = !callback( elems[ i ], i );\\n\\t\\t\\tif ( callbackInverse !== callbackExpect ) {\\n\\t\\t\\t\\tmatches.push( elems[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn matches;\\n\\t},\\n\\n\\t// arg is for internal usage only\\n\\tmap: function( elems, callback, arg ) {\\n\\t\\tvar length, value,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tret = [];\\n\\n\\t\\t// Go through the array, translating each of the items to their new values\\n\\t\\tif ( isArrayLike( elems ) ) {\\n\\t\\t\\tlength = elems.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Go through every key on the object,\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in elems ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Flatten any nested arrays\\n\\t\\treturn concat.apply( [], ret );\\n\\t},\\n\\n\\t// A global GUID counter for objects\\n\\tguid: 1,\\n\\n\\t// Bind a function to a context, optionally partially applying any\\n\\t// arguments.\\n\\tproxy: function( fn, context ) {\\n\\t\\tvar tmp, args, proxy;\\n\\n\\t\\tif ( typeof context === \"string\" ) {\\n\\t\\t\\ttmp = fn[ context ];\\n\\t\\t\\tcontext = fn;\\n\\t\\t\\tfn = tmp;\\n\\t\\t}\\n\\n\\t\\t// Quick check to determine if target is callable, in the spec\\n\\t\\t// this throws a TypeError, but we will just return undefined.\\n\\t\\tif ( !jQuery.isFunction( fn ) ) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\n\\t\\t// Simulated bind\\n\\t\\targs = slice.call( arguments, 2 );\\n\\t\\tproxy = function() {\\n\\t\\t\\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\\n\\t\\t};\\n\\n\\t\\t// Set the guid of unique handler to the same of original handler, so it can be removed\\n\\t\\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\\n\\n\\t\\treturn proxy;\\n\\t},\\n\\n\\tnow: Date.now,\\n\\n\\t// jQuery.support is not used in Core but other projects attach their\\n\\t// properties to it so it needs to exist.\\n\\tsupport: support\\n} );\\n\\nif ( typeof Symbol === \"function\" ) {\\n\\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\\n}\\n\\n// Populate the class2type map\\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\\nfunction( i, name ) {\\n\\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\\n} );\\n\\nfunction isArrayLike( obj ) {\\n\\n\\t// Support: real iOS 8.2 only (not reproducible in simulator)\\n\\t// `in` check used to prevent JIT error (gh-2145)\\n\\t// hasOwn isn\\'t used here due to false negatives\\n\\t// regarding Nodelist length in IE\\n\\tvar length = !!obj && \"length\" in obj && obj.length,\\n\\t\\ttype = jQuery.type( obj );\\n\\n\\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn type === \"array\" || length === 0 ||\\n\\t\\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\\n}\\nvar Sizzle =\\n/*!\\n * Sizzle CSS Selector Engine v2.3.3\\n * https://sizzlejs.com/\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2016-08-08\\n */\\n(function( window ) {\\n\\nvar i,\\n\\tsupport,\\n\\tExpr,\\n\\tgetText,\\n\\tisXML,\\n\\ttokenize,\\n\\tcompile,\\n\\tselect,\\n\\toutermostContext,\\n\\tsortInput,\\n\\thasDuplicate,\\n\\n\\t// Local document vars\\n\\tsetDocument,\\n\\tdocument,\\n\\tdocElem,\\n\\tdocumentIsHTML,\\n\\trbuggyQSA,\\n\\trbuggyMatches,\\n\\tmatches,\\n\\tcontains,\\n\\n\\t// Instance-specific data\\n\\texpando = \"sizzle\" + 1 * new Date(),\\n\\tpreferredDoc = window.document,\\n\\tdirruns = 0,\\n\\tdone = 0,\\n\\tclassCache = createCache(),\\n\\ttokenCache = createCache(),\\n\\tcompilerCache = createCache(),\\n\\tsortOrder = function( a, b ) {\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t},\\n\\n\\t// Instance methods\\n\\thasOwn = ({}).hasOwnProperty,\\n\\tarr = [],\\n\\tpop = arr.pop,\\n\\tpush_native = arr.push,\\n\\tpush = arr.push,\\n\\tslice = arr.slice,\\n\\t// Use a stripped-down indexOf as it\\'s faster than native\\n\\t// https://jsperf.com/thor-indexof-vs-for/5\\n\\tindexOf = function( list, elem ) {\\n\\t\\tvar i = 0,\\n\\t\\t\\tlen = list.length;\\n\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\tif ( list[i] === elem ) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t},\\n\\n\\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\\n\\n\\t// Regular expressions\\n\\n\\t// http://www.w3.org/TR/css3-selectors/#whitespace\\n\\twhitespace = \"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\",\\n\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\\n\\tidentifier = \"(?:\\\\\\\\\\\\\\\\.|[\\\\\\\\w-]|[^\\\\0-\\\\\\\\xa0])+\",\\n\\n\\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\\n\\tattributes = \"\\\\\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\\n\\t\\t// Operator (capture 2)\\n\\t\\t\"*([*^$|!~]?=)\" + whitespace +\\n\\t\\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\\n\\t\\t\"*(?:\\'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\'])*)\\'|\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\"|(\" + identifier + \"))|)\" + whitespace +\\n\\t\\t\"*\\\\\\\\]\",\\n\\n\\tpseudos = \":(\" + identifier + \")(?:\\\\\\\\((\" +\\n\\t\\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\\n\\t\\t// 1. quoted (capture 3; capture 4 or capture 5)\\n\\t\\t\"(\\'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\'])*)\\'|\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\")|\" +\\n\\t\\t// 2. simple (capture 6)\\n\\t\\t\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\" + attributes + \")*)|\" +\\n\\t\\t// 3. anything else (capture 2)\\n\\t\\t\".*\" +\\n\\t\\t\")\\\\\\\\)|)\",\\n\\n\\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\\n\\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\\n\\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\\n\\n\\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\\n\\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\\n\\n\\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\\\\\]\\'\\\\\"]*?)\" + whitespace + \"*\\\\\\\\]\", \"g\" ),\\n\\n\\trpseudo = new RegExp( pseudos ),\\n\\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\\n\\n\\tmatchExpr = {\\n\\t\\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\\n\\t\\t\"CLASS\": new RegExp( \"^\\\\\\\\.(\" + identifier + \")\" ),\\n\\t\\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\\n\\t\\t\"ATTR\": new RegExp( \"^\" + attributes ),\\n\\t\\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\\n\\t\\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\" + whitespace +\\n\\t\\t\\t\"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\\n\\t\\t\\t\"*(\\\\\\\\d+)|))\" + whitespace + \"*\\\\\\\\)|)\", \"i\" ),\\n\\t\\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\\n\\t\\t// For use in libraries implementing .is()\\n\\t\\t// We use this for POS matching in `select`\\n\\t\\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\" +\\n\\t\\t\\twhitespace + \"*((?:-\\\\\\\\d)?\\\\\\\\d*)\" + whitespace + \"*\\\\\\\\)|)(?=[^-]|$)\", \"i\" )\\n\\t},\\n\\n\\trinputs = /^(?:input|select|textarea|button)$/i,\\n\\trheader = /^h\\\\d$/i,\\n\\n\\trnative = /^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,\\n\\n\\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\\n\\trquickExpr = /^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,\\n\\n\\trsibling = /[+~]/,\\n\\n\\t// CSS escapes\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\\n\\trunescape = new RegExp( \"\\\\\\\\\\\\\\\\([\\\\\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\\n\\tfunescape = function( _, escaped, escapedWhitespace ) {\\n\\t\\tvar high = \"0x\" + escaped - 0x10000;\\n\\t\\t// NaN means non-codepoint\\n\\t\\t// Support: Firefox<24\\n\\t\\t// Workaround erroneous numeric interpretation of +\"0x\"\\n\\t\\treturn high !== high || escapedWhitespace ?\\n\\t\\t\\tescaped :\\n\\t\\t\\thigh < 0 ?\\n\\t\\t\\t\\t// BMP codepoint\\n\\t\\t\\t\\tString.fromCharCode( high + 0x10000 ) :\\n\\t\\t\\t\\t// Supplemental Plane codepoint (surrogate pair)\\n\\t\\t\\t\\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\\n\\t},\\n\\n\\t// CSS string/identifier serialization\\n\\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\\n\\trcssescape = /([\\\\0-\\\\x1f\\\\x7f]|^-?\\\\d)|^-$|[^\\\\0-\\\\x1f\\\\x7f-\\\\uFFFF\\\\w-]/g,\\n\\tfcssescape = function( ch, asCodePoint ) {\\n\\t\\tif ( asCodePoint ) {\\n\\n\\t\\t\\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\\n\\t\\t\\tif ( ch === \"\\\\0\" ) {\\n\\t\\t\\t\\treturn \"\\\\uFFFD\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Control characters and (dependent upon position) numbers get escaped as code points\\n\\t\\t\\treturn ch.slice( 0, -1 ) + \"\\\\\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\\n\\t\\t}\\n\\n\\t\\t// Other potentially-special ASCII characters get backslash-escaped\\n\\t\\treturn \"\\\\\\\\\" + ch;\\n\\t},\\n\\n\\t// Used for iframes\\n\\t// See setDocument()\\n\\t// Removing the function wrapper causes a \"Permission Denied\"\\n\\t// error in IE\\n\\tunloadHandler = function() {\\n\\t\\tsetDocument();\\n\\t},\\n\\n\\tdisabledAncestor = addCombinator(\\n\\t\\tfunction( elem ) {\\n\\t\\t\\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\\n\\t\\t},\\n\\t\\t{ dir: \"parentNode\", next: \"legend\" }\\n\\t);\\n\\n// Optimize for push.apply( _, NodeList )\\ntry {\\n\\tpush.apply(\\n\\t\\t(arr = slice.call( preferredDoc.childNodes )),\\n\\t\\tpreferredDoc.childNodes\\n\\t);\\n\\t// Support: Android<4.0\\n\\t// Detect silently failing push.apply\\n\\tarr[ preferredDoc.childNodes.length ].nodeType;\\n} catch ( e ) {\\n\\tpush = { apply: arr.length ?\\n\\n\\t\\t// Leverage slice if possible\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tpush_native.apply( target, slice.call(els) );\\n\\t\\t} :\\n\\n\\t\\t// Support: IE<9\\n\\t\\t// Otherwise append directly\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tvar j = target.length,\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t// Can\\'t trust NodeList.length\\n\\t\\t\\twhile ( (target[j++] = els[i++]) ) {}\\n\\t\\t\\ttarget.length = j - 1;\\n\\t\\t}\\n\\t};\\n}\\n\\nfunction Sizzle( selector, context, results, seed ) {\\n\\tvar m, i, elem, nid, match, groups, newSelector,\\n\\t\\tnewContext = context && context.ownerDocument,\\n\\n\\t\\t// nodeType defaults to 9, since context defaults to document\\n\\t\\tnodeType = context ? context.nodeType : 9;\\n\\n\\tresults = results || [];\\n\\n\\t// Return early from calls with invalid selector or context\\n\\tif ( typeof selector !== \"string\" || !selector ||\\n\\t\\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\\n\\n\\t\\treturn results;\\n\\t}\\n\\n\\t// Try to shortcut find operations (as opposed to filters) in HTML documents\\n\\tif ( !seed ) {\\n\\n\\t\\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\\n\\t\\t\\tsetDocument( context );\\n\\t\\t}\\n\\t\\tcontext = context || document;\\n\\n\\t\\tif ( documentIsHTML ) {\\n\\n\\t\\t\\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\\n\\t\\t\\t// (excepting DocumentFragment context, where the methods don\\'t exist)\\n\\t\\t\\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\\n\\n\\t\\t\\t\\t// ID selector\\n\\t\\t\\t\\tif ( (m = match[1]) ) {\\n\\n\\t\\t\\t\\t\\t// Document context\\n\\t\\t\\t\\t\\tif ( nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = context.getElementById( m )) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\t\\tif ( elem.id === m ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Element context\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\tif ( newContext && (elem = newContext.getElementById( m )) &&\\n\\t\\t\\t\\t\\t\\t\\tcontains( context, elem ) &&\\n\\t\\t\\t\\t\\t\\t\\telem.id === m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Type selector\\n\\t\\t\\t\\t} else if ( match[2] ) {\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByTagName( selector ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t\\t// Class selector\\n\\t\\t\\t\\t} else if ( (m = match[3]) && support.getElementsByClassName &&\\n\\t\\t\\t\\t\\tcontext.getElementsByClassName ) {\\n\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByClassName( m ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Take advantage of querySelectorAll\\n\\t\\t\\tif ( support.qsa &&\\n\\t\\t\\t\\t!compilerCache[ selector + \" \" ] &&\\n\\t\\t\\t\\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\\n\\n\\t\\t\\t\\tif ( nodeType !== 1 ) {\\n\\t\\t\\t\\t\\tnewContext = context;\\n\\t\\t\\t\\t\\tnewSelector = selector;\\n\\n\\t\\t\\t\\t// qSA looks outside Element context, which is not what we want\\n\\t\\t\\t\\t// Thanks to Andrew Dupont for this workaround technique\\n\\t\\t\\t\\t// Support: IE <=8\\n\\t\\t\\t\\t// Exclude object elements\\n\\t\\t\\t\\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\\n\\n\\t\\t\\t\\t\\t// Capture the context ID, setting it first if necessary\\n\\t\\t\\t\\t\\tif ( (nid = context.getAttribute( \"id\" )) ) {\\n\\t\\t\\t\\t\\t\\tnid = nid.replace( rcssescape, fcssescape );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcontext.setAttribute( \"id\", (nid = expando) );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prefix every selector in the list\\n\\t\\t\\t\\t\\tgroups = tokenize( selector );\\n\\t\\t\\t\\t\\ti = groups.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnewSelector = groups.join( \",\" );\\n\\n\\t\\t\\t\\t\\t// Expand context for sibling selectors\\n\\t\\t\\t\\t\\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\\n\\t\\t\\t\\t\\t\\tcontext;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( newSelector ) {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tpush.apply( results,\\n\\t\\t\\t\\t\\t\\t\\tnewContext.querySelectorAll( newSelector )\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t} catch ( qsaError ) {\\n\\t\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\t\\tif ( nid === expando ) {\\n\\t\\t\\t\\t\\t\\t\\tcontext.removeAttribute( \"id\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// All others\\n\\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\\n}\\n\\n/**\\n * Create key-value caches of limited size\\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\\n *\\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\\n *\\tdeleting the oldest entry\\n */\\nfunction createCache() {\\n\\tvar keys = [];\\n\\n\\tfunction cache( key, value ) {\\n\\t\\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\\n\\t\\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\\n\\t\\t\\t// Only keep the most recent entries\\n\\t\\t\\tdelete cache[ keys.shift() ];\\n\\t\\t}\\n\\t\\treturn (cache[ key + \" \" ] = value);\\n\\t}\\n\\treturn cache;\\n}\\n\\n/**\\n * Mark a function for special use by Sizzle\\n * @param {Function} fn The function to mark\\n */\\nfunction markFunction( fn ) {\\n\\tfn[ expando ] = true;\\n\\treturn fn;\\n}\\n\\n/**\\n * Support testing using an element\\n * @param {Function} fn Passed the created element and returns a boolean result\\n */\\nfunction assert( fn ) {\\n\\tvar el = document.createElement(\"fieldset\");\\n\\n\\ttry {\\n\\t\\treturn !!fn( el );\\n\\t} catch (e) {\\n\\t\\treturn false;\\n\\t} finally {\\n\\t\\t// Remove from its parent by default\\n\\t\\tif ( el.parentNode ) {\\n\\t\\t\\tel.parentNode.removeChild( el );\\n\\t\\t}\\n\\t\\t// release memory in IE\\n\\t\\tel = null;\\n\\t}\\n}\\n\\n/**\\n * Adds the same handler for all of the specified attrs\\n * @param {String} attrs Pipe-separated list of attributes\\n * @param {Function} handler The method that will be applied\\n */\\nfunction addHandle( attrs, handler ) {\\n\\tvar arr = attrs.split(\"|\"),\\n\\t\\ti = arr.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tExpr.attrHandle[ arr[i] ] = handler;\\n\\t}\\n}\\n\\n/**\\n * Checks document order of two siblings\\n * @param {Element} a\\n * @param {Element} b\\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\\n */\\nfunction siblingCheck( a, b ) {\\n\\tvar cur = b && a,\\n\\t\\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\\n\\t\\t\\ta.sourceIndex - b.sourceIndex;\\n\\n\\t// Use IE sourceIndex if available on both nodes\\n\\tif ( diff ) {\\n\\t\\treturn diff;\\n\\t}\\n\\n\\t// Check if b follows a\\n\\tif ( cur ) {\\n\\t\\twhile ( (cur = cur.nextSibling) ) {\\n\\t\\t\\tif ( cur === b ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn a ? 1 : -1;\\n}\\n\\n/**\\n * Returns a function to use in pseudos for input types\\n * @param {String} type\\n */\\nfunction createInputPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn name === \"input\" && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for buttons\\n * @param {String} type\\n */\\nfunction createButtonPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn (name === \"input\" || name === \"button\") && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for :enabled/:disabled\\n * @param {Boolean} disabled true for :disabled; false for :enabled\\n */\\nfunction createDisabledPseudo( disabled ) {\\n\\n\\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\\n\\treturn function( elem ) {\\n\\n\\t\\t// Only certain elements can match :enabled or :disabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\\n\\t\\tif ( \"form\" in elem ) {\\n\\n\\t\\t\\t// Check for inherited disabledness on relevant non-disabled elements:\\n\\t\\t\\t// * listed form-associated elements in a disabled fieldset\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\\n\\t\\t\\t// * option elements in a disabled optgroup\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\\n\\t\\t\\t// All such elements have a \"form\" property.\\n\\t\\t\\tif ( elem.parentNode && elem.disabled === false ) {\\n\\n\\t\\t\\t\\t// Option elements defer to a parent optgroup if present\\n\\t\\t\\t\\tif ( \"label\" in elem ) {\\n\\t\\t\\t\\t\\tif ( \"label\" in elem.parentNode ) {\\n\\t\\t\\t\\t\\t\\treturn elem.parentNode.disabled === disabled;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: IE 6 - 11\\n\\t\\t\\t\\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\\n\\t\\t\\t\\treturn elem.isDisabled === disabled ||\\n\\n\\t\\t\\t\\t\\t// Where there is no isDisabled, check manually\\n\\t\\t\\t\\t\\t/* jshint -W018 */\\n\\t\\t\\t\\t\\telem.isDisabled !== !disabled &&\\n\\t\\t\\t\\t\\t\\tdisabledAncestor( elem ) === disabled;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\n\\t\\t// Try to winnow out elements that can\\'t be disabled before trusting the disabled property.\\n\\t\\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn\\'t\\n\\t\\t// even exist on them, let alone have a boolean value.\\n\\t\\t} else if ( \"label\" in elem ) {\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t}\\n\\n\\t\\t// Remaining elements are neither :enabled nor :disabled\\n\\t\\treturn false;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for positionals\\n * @param {Function} fn\\n */\\nfunction createPositionalPseudo( fn ) {\\n\\treturn markFunction(function( argument ) {\\n\\t\\targument = +argument;\\n\\t\\treturn markFunction(function( seed, matches ) {\\n\\t\\t\\tvar j,\\n\\t\\t\\t\\tmatchIndexes = fn( [], seed.length, argument ),\\n\\t\\t\\t\\ti = matchIndexes.length;\\n\\n\\t\\t\\t// Match elements found at the specified indexes\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( seed[ (j = matchIndexes[i]) ] ) {\\n\\t\\t\\t\\t\\tseed[j] = !(matches[j] = seed[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\n/**\\n * Checks a node for validity as a Sizzle context\\n * @param {Element|Object=} context\\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\\n */\\nfunction testContext( context ) {\\n\\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\\n}\\n\\n// Expose support vars for convenience\\nsupport = Sizzle.support = {};\\n\\n/**\\n * Detects XML nodes\\n * @param {Element|Object} elem An element or a document\\n * @returns {Boolean} True iff elem is a non-HTML XML node\\n */\\nisXML = Sizzle.isXML = function( elem ) {\\n\\t// documentElement is verified for cases where it doesn\\'t yet exist\\n\\t// (such as loading iframes in IE - #4833)\\n\\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\\n\\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\\n};\\n\\n/**\\n * Sets document-related variables once based on the current document\\n * @param {Element|Object} [doc] An element or document object to use to set the document\\n * @returns {Object} Returns the current document\\n */\\nsetDocument = Sizzle.setDocument = function( node ) {\\n\\tvar hasCompare, subWindow,\\n\\t\\tdoc = node ? node.ownerDocument || node : preferredDoc;\\n\\n\\t// Return early if doc is invalid or already selected\\n\\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\\n\\t\\treturn document;\\n\\t}\\n\\n\\t// Update global variables\\n\\tdocument = doc;\\n\\tdocElem = document.documentElement;\\n\\tdocumentIsHTML = !isXML( document );\\n\\n\\t// Support: IE 9-11, Edge\\n\\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\\n\\tif ( preferredDoc !== document &&\\n\\t\\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\\n\\n\\t\\t// Support: IE 11, Edge\\n\\t\\tif ( subWindow.addEventListener ) {\\n\\t\\t\\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\\n\\n\\t\\t// Support: IE 9 - 10 only\\n\\t\\t} else if ( subWindow.attachEvent ) {\\n\\t\\t\\tsubWindow.attachEvent( \"onunload\", unloadHandler );\\n\\t\\t}\\n\\t}\\n\\n\\t/* Attributes\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Support: IE<8\\n\\t// Verify that getAttribute really returns attributes and not properties\\n\\t// (excepting IE8 booleans)\\n\\tsupport.attributes = assert(function( el ) {\\n\\t\\tel.className = \"i\";\\n\\t\\treturn !el.getAttribute(\"className\");\\n\\t});\\n\\n\\t/* getElement(s)By*\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Check if getElementsByTagName(\"*\") returns only elements\\n\\tsupport.getElementsByTagName = assert(function( el ) {\\n\\t\\tel.appendChild( document.createComment(\"\") );\\n\\t\\treturn !el.getElementsByTagName(\"*\").length;\\n\\t});\\n\\n\\t// Support: IE<9\\n\\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\\n\\n\\t// Support: IE<10\\n\\t// Check if getElementById returns elements by name\\n\\t// The broken getElementById methods don\\'t pick up programmatically-set names,\\n\\t// so use a roundabout getElementsByName test\\n\\tsupport.getById = assert(function( el ) {\\n\\t\\tdocElem.appendChild( el ).id = expando;\\n\\t\\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\\n\\t});\\n\\n\\t// ID filter and find\\n\\tif ( support.getById ) {\\n\\t\\tExpr.filter[\"ID\"] = function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn elem.getAttribute(\"id\") === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\tExpr.find[\"ID\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar elem = context.getElementById( id );\\n\\t\\t\\t\\treturn elem ? [ elem ] : [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} else {\\n\\t\\tExpr.filter[\"ID\"] =  function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\\n\\t\\t\\t\\t\\telem.getAttributeNode(\"id\");\\n\\t\\t\\t\\treturn node && node.value === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\t// Support: IE 6 - 7 only\\n\\t\\t// getElementById is not reliable as a find shortcut\\n\\t\\tExpr.find[\"ID\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar node, i, elems,\\n\\t\\t\\t\\t\\telem = context.getElementById( id );\\n\\n\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t// Verify the id attribute\\n\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\"id\");\\n\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Fall back on getElementsByName\\n\\t\\t\\t\\t\\telems = context.getElementsByName( id );\\n\\t\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\t\\twhile ( (elem = elems[i++]) ) {\\n\\t\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\"id\");\\n\\t\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t// Tag\\n\\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\\n\\t\\t\\t\\treturn context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// DocumentFragment nodes don\\'t have gEBTN\\n\\t\\t\\t} else if ( support.qsa ) {\\n\\t\\t\\t\\treturn context.querySelectorAll( tag );\\n\\t\\t\\t}\\n\\t\\t} :\\n\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tvar elem,\\n\\t\\t\\t\\ttmp = [],\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\\n\\t\\t\\t\\tresults = context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// Filter out possible comments\\n\\t\\t\\tif ( tag === \"*\" ) {\\n\\t\\t\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\ttmp.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t};\\n\\n\\t// Class\\n\\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\\n\\t\\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\\n\\t\\t\\treturn context.getElementsByClassName( className );\\n\\t\\t}\\n\\t};\\n\\n\\t/* QSA/matchesSelector\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// QSA and matchesSelector support\\n\\n\\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\\n\\trbuggyMatches = [];\\n\\n\\t// qSa(:focus) reports false when true (Chrome 21)\\n\\t// We allow this because of a bug in IE8/9 that throws an error\\n\\t// whenever `document.activeElement` is accessed on an iframe\\n\\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\\n\\t// See https://bugs.jquery.com/ticket/13378\\n\\trbuggyQSA = [];\\n\\n\\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\\n\\t\\t// Build QSA regex\\n\\t\\t// Regex strategy adopted from Diego Perini\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Select is set to empty string on purpose\\n\\t\\t\\t// This is to test IE\\'s treatment of not explicitly\\n\\t\\t\\t// setting a boolean content attribute,\\n\\t\\t\\t// since its presence should be enough\\n\\t\\t\\t// https://bugs.jquery.com/ticket/12359\\n\\t\\t\\tdocElem.appendChild( el ).innerHTML = \"<a id=\\'\" + expando + \"\\'></a>\" +\\n\\t\\t\\t\\t\"<select id=\\'\" + expando + \"-\\\\r\\\\\\\\\\' msallowcapture=\\'\\'>\" +\\n\\t\\t\\t\\t\"<option selected=\\'\\'></option></select>\";\\n\\n\\t\\t\\t// Support: IE8, Opera 11-12.16\\n\\t\\t\\t// Nothing should be selected when empty strings follow ^= or $= or *=\\n\\t\\t\\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\\n\\t\\t\\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\\n\\t\\t\\tif ( el.querySelectorAll(\"[msallowcapture^=\\'\\']\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:\\'\\'|\\\\\"\\\\\")\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Boolean attributes and \"value\" are not treated correctly\\n\\t\\t\\tif ( !el.querySelectorAll(\"[selected]\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \"\\\\\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\\n\\t\\t\\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\"~=\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Webkit/Opera - :checked should return selected option elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( !el.querySelectorAll(\":checked\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\":checked\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Safari 8+, iOS 8+\\n\\t\\t\\t// https://bugs.webkit.org/show_bug.cgi?id=136851\\n\\t\\t\\t// In-page `selector#id sibling-combinator selector` fails\\n\\t\\t\\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\".#.+[+~]\");\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\tel.innerHTML = \"<a href=\\'\\' disabled=\\'disabled\\'></a>\" +\\n\\t\\t\\t\\t\"<select disabled=\\'disabled\\'><option/></select>\";\\n\\n\\t\\t\\t// Support: Windows 8 Native Apps\\n\\t\\t\\t// The type and name attributes are restricted during .innerHTML assignment\\n\\t\\t\\tvar input = document.createElement(\"input\");\\n\\t\\t\\tinput.setAttribute( \"type\", \"hidden\" );\\n\\t\\t\\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Enforce case-sensitivity of name attribute\\n\\t\\t\\tif ( el.querySelectorAll(\"[name=d]\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \":enabled\", \":disabled\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE9-11+\\n\\t\\t\\t// IE\\'s :disabled selector does not pick up the children of disabled fieldsets\\n\\t\\t\\tdocElem.appendChild( el ).disabled = true;\\n\\t\\t\\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \":enabled\", \":disabled\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Opera 10-11 does not throw on post-comma invalid pseudos\\n\\t\\t\\tel.querySelectorAll(\"*,:x\");\\n\\t\\t\\trbuggyQSA.push(\",.*:\");\\n\\t\\t});\\n\\t}\\n\\n\\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\\n\\t\\tdocElem.webkitMatchesSelector ||\\n\\t\\tdocElem.mozMatchesSelector ||\\n\\t\\tdocElem.oMatchesSelector ||\\n\\t\\tdocElem.msMatchesSelector) )) ) {\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Check to see if it\\'s possible to do matchesSelector\\n\\t\\t\\t// on a disconnected node (IE 9)\\n\\t\\t\\tsupport.disconnectedMatch = matches.call( el, \"*\" );\\n\\n\\t\\t\\t// This should fail with an exception\\n\\t\\t\\t// Gecko does not error, returns false instead\\n\\t\\t\\tmatches.call( el, \"[s!=\\'\\']:x\" );\\n\\t\\t\\trbuggyMatches.push( \"!=\", pseudos );\\n\\t\\t});\\n\\t}\\n\\n\\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\\n\\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\\n\\n\\t/* Contains\\n\\t---------------------------------------------------------------------- */\\n\\thasCompare = rnative.test( docElem.compareDocumentPosition );\\n\\n\\t// Element contains another\\n\\t// Purposefully self-exclusive\\n\\t// As in, an element does not contain itself\\n\\tcontains = hasCompare || rnative.test( docElem.contains ) ?\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tvar adown = a.nodeType === 9 ? a.documentElement : a,\\n\\t\\t\\t\\tbup = b && b.parentNode;\\n\\t\\t\\treturn a === bup || !!( bup && bup.nodeType === 1 && (\\n\\t\\t\\t\\tadown.contains ?\\n\\t\\t\\t\\t\\tadown.contains( bup ) :\\n\\t\\t\\t\\t\\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\\n\\t\\t\\t));\\n\\t\\t} :\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tif ( b ) {\\n\\t\\t\\t\\twhile ( (b = b.parentNode) ) {\\n\\t\\t\\t\\t\\tif ( b === a ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t/* Sorting\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Document order sorting\\n\\tsortOrder = hasCompare ?\\n\\tfunction( a, b ) {\\n\\n\\t\\t// Flag for duplicate removal\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// Sort on method existence if only one input has compareDocumentPosition\\n\\t\\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\\n\\t\\tif ( compare ) {\\n\\t\\t\\treturn compare;\\n\\t\\t}\\n\\n\\t\\t// Calculate position if both inputs belong to the same document\\n\\t\\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\\n\\t\\t\\ta.compareDocumentPosition( b ) :\\n\\n\\t\\t\\t// Otherwise we know they are disconnected\\n\\t\\t\\t1;\\n\\n\\t\\t// Disconnected nodes\\n\\t\\tif ( compare & 1 ||\\n\\t\\t\\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\\n\\n\\t\\t\\t// Choose the first element that is related to our preferred document\\n\\t\\t\\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Maintain original order\\n\\t\\t\\treturn sortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\t\\t}\\n\\n\\t\\treturn compare & 4 ? -1 : 1;\\n\\t} :\\n\\tfunction( a, b ) {\\n\\t\\t// Exit early if the nodes are identical\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\taup = a.parentNode,\\n\\t\\t\\tbup = b.parentNode,\\n\\t\\t\\tap = [ a ],\\n\\t\\t\\tbp = [ b ];\\n\\n\\t\\t// Parentless nodes are either documents or disconnected\\n\\t\\tif ( !aup || !bup ) {\\n\\t\\t\\treturn a === document ? -1 :\\n\\t\\t\\t\\tb === document ? 1 :\\n\\t\\t\\t\\taup ? -1 :\\n\\t\\t\\t\\tbup ? 1 :\\n\\t\\t\\t\\tsortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\n\\t\\t// If the nodes are siblings, we can do a quick check\\n\\t\\t} else if ( aup === bup ) {\\n\\t\\t\\treturn siblingCheck( a, b );\\n\\t\\t}\\n\\n\\t\\t// Otherwise we need full lists of their ancestors for comparison\\n\\t\\tcur = a;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tap.unshift( cur );\\n\\t\\t}\\n\\t\\tcur = b;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tbp.unshift( cur );\\n\\t\\t}\\n\\n\\t\\t// Walk down the tree looking for a discrepancy\\n\\t\\twhile ( ap[i] === bp[i] ) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn i ?\\n\\t\\t\\t// Do a sibling check if the nodes have a common ancestor\\n\\t\\t\\tsiblingCheck( ap[i], bp[i] ) :\\n\\n\\t\\t\\t// Otherwise nodes in our document sort first\\n\\t\\t\\tap[i] === preferredDoc ? -1 :\\n\\t\\t\\tbp[i] === preferredDoc ? 1 :\\n\\t\\t\\t0;\\n\\t};\\n\\n\\treturn document;\\n};\\n\\nSizzle.matches = function( expr, elements ) {\\n\\treturn Sizzle( expr, null, null, elements );\\n};\\n\\nSizzle.matchesSelector = function( elem, expr ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\t// Make sure that attribute selectors are quoted\\n\\texpr = expr.replace( rattributeQuotes, \"=\\'$1\\']\" );\\n\\n\\tif ( support.matchesSelector && documentIsHTML &&\\n\\t\\t!compilerCache[ expr + \" \" ] &&\\n\\t\\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\\n\\t\\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\\n\\n\\t\\ttry {\\n\\t\\t\\tvar ret = matches.call( elem, expr );\\n\\n\\t\\t\\t// IE 9\\'s matchesSelector returns false on disconnected nodes\\n\\t\\t\\tif ( ret || support.disconnectedMatch ||\\n\\t\\t\\t\\t\\t// As well, disconnected nodes are said to be in a document\\n\\t\\t\\t\\t\\t// fragment in IE 9\\n\\t\\t\\t\\t\\telem.document && elem.document.nodeType !== 11 ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {}\\n\\t}\\n\\n\\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\\n};\\n\\nSizzle.contains = function( context, elem ) {\\n\\t// Set document vars if needed\\n\\tif ( ( context.ownerDocument || context ) !== document ) {\\n\\t\\tsetDocument( context );\\n\\t}\\n\\treturn contains( context, elem );\\n};\\n\\nSizzle.attr = function( elem, name ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\\n\\t\\t// Don\\'t get fooled by Object.prototype properties (jQuery #13807)\\n\\t\\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\\n\\t\\t\\tfn( elem, name, !documentIsHTML ) :\\n\\t\\t\\tundefined;\\n\\n\\treturn val !== undefined ?\\n\\t\\tval :\\n\\t\\tsupport.attributes || !documentIsHTML ?\\n\\t\\t\\telem.getAttribute( name ) :\\n\\t\\t\\t(val = elem.getAttributeNode(name)) && val.specified ?\\n\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n};\\n\\nSizzle.escape = function( sel ) {\\n\\treturn (sel + \"\").replace( rcssescape, fcssescape );\\n};\\n\\nSizzle.error = function( msg ) {\\n\\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\\n};\\n\\n/**\\n * Document sorting and removing duplicates\\n * @param {ArrayLike} results\\n */\\nSizzle.uniqueSort = function( results ) {\\n\\tvar elem,\\n\\t\\tduplicates = [],\\n\\t\\tj = 0,\\n\\t\\ti = 0;\\n\\n\\t// Unless we *know* we can detect duplicates, assume their presence\\n\\thasDuplicate = !support.detectDuplicates;\\n\\tsortInput = !support.sortStable && results.slice( 0 );\\n\\tresults.sort( sortOrder );\\n\\n\\tif ( hasDuplicate ) {\\n\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\tif ( elem === results[ i ] ) {\\n\\t\\t\\t\\tj = duplicates.push( i );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile ( j-- ) {\\n\\t\\t\\tresults.splice( duplicates[ j ], 1 );\\n\\t\\t}\\n\\t}\\n\\n\\t// Clear input after sorting to release objects\\n\\t// See https://github.com/jquery/sizzle/pull/225\\n\\tsortInput = null;\\n\\n\\treturn results;\\n};\\n\\n/**\\n * Utility function for retrieving the text value of an array of DOM nodes\\n * @param {Array|Element} elem\\n */\\ngetText = Sizzle.getText = function( elem ) {\\n\\tvar node,\\n\\t\\tret = \"\",\\n\\t\\ti = 0,\\n\\t\\tnodeType = elem.nodeType;\\n\\n\\tif ( !nodeType ) {\\n\\t\\t// If no nodeType, this is expected to be an array\\n\\t\\twhile ( (node = elem[i++]) ) {\\n\\t\\t\\t// Do not traverse comment nodes\\n\\t\\t\\tret += getText( node );\\n\\t\\t}\\n\\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\\n\\t\\t// Use textContent for elements\\n\\t\\t// innerText usage removed for consistency of new lines (jQuery #11153)\\n\\t\\tif ( typeof elem.textContent === \"string\" ) {\\n\\t\\t\\treturn elem.textContent;\\n\\t\\t} else {\\n\\t\\t\\t// Traverse its children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tret += getText( elem );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if ( nodeType === 3 || nodeType === 4 ) {\\n\\t\\treturn elem.nodeValue;\\n\\t}\\n\\t// Do not include comment or processing instruction nodes\\n\\n\\treturn ret;\\n};\\n\\nExpr = Sizzle.selectors = {\\n\\n\\t// Can be adjusted by the user\\n\\tcacheLength: 50,\\n\\n\\tcreatePseudo: markFunction,\\n\\n\\tmatch: matchExpr,\\n\\n\\tattrHandle: {},\\n\\n\\tfind: {},\\n\\n\\trelative: {\\n\\t\\t\">\": { dir: \"parentNode\", first: true },\\n\\t\\t\" \": { dir: \"parentNode\" },\\n\\t\\t\"+\": { dir: \"previousSibling\", first: true },\\n\\t\\t\"~\": { dir: \"previousSibling\" }\\n\\t},\\n\\n\\tpreFilter: {\\n\\t\\t\"ATTR\": function( match ) {\\n\\t\\t\\tmatch[1] = match[1].replace( runescape, funescape );\\n\\n\\t\\t\\t// Move the given value to match[3] whether quoted or unquoted\\n\\t\\t\\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\\n\\n\\t\\t\\tif ( match[2] === \"~=\" ) {\\n\\t\\t\\t\\tmatch[3] = \" \" + match[3] + \" \";\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match.slice( 0, 4 );\\n\\t\\t},\\n\\n\\t\\t\"CHILD\": function( match ) {\\n\\t\\t\\t/* matches from matchExpr[\"CHILD\"]\\n\\t\\t\\t\\t1 type (only|nth|...)\\n\\t\\t\\t\\t2 what (child|of-type)\\n\\t\\t\\t\\t3 argument (even|odd|\\\\d*|\\\\d*n([+-]\\\\d+)?|...)\\n\\t\\t\\t\\t4 xn-component of xn+y argument ([+-]?\\\\d*n|)\\n\\t\\t\\t\\t5 sign of xn-component\\n\\t\\t\\t\\t6 x of xn-component\\n\\t\\t\\t\\t7 sign of y-component\\n\\t\\t\\t\\t8 y of y-component\\n\\t\\t\\t*/\\n\\t\\t\\tmatch[1] = match[1].toLowerCase();\\n\\n\\t\\t\\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\\n\\t\\t\\t\\t// nth-* requires argument\\n\\t\\t\\t\\tif ( !match[3] ) {\\n\\t\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// numeric x and y parameters for Expr.filter.CHILD\\n\\t\\t\\t\\t// remember that false/true cast respectively to 0/1\\n\\t\\t\\t\\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\\n\\t\\t\\t\\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\\n\\n\\t\\t\\t// other types prohibit arguments\\n\\t\\t\\t} else if ( match[3] ) {\\n\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match;\\n\\t\\t},\\n\\n\\t\\t\"PSEUDO\": function( match ) {\\n\\t\\t\\tvar excess,\\n\\t\\t\\t\\tunquoted = !match[6] && match[2];\\n\\n\\t\\t\\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Accept quoted arguments as-is\\n\\t\\t\\tif ( match[3] ) {\\n\\t\\t\\t\\tmatch[2] = match[4] || match[5] || \"\";\\n\\n\\t\\t\\t// Strip excess characters from unquoted arguments\\n\\t\\t\\t} else if ( unquoted && rpseudo.test( unquoted ) &&\\n\\t\\t\\t\\t// Get excess from tokenize (recursively)\\n\\t\\t\\t\\t(excess = tokenize( unquoted, true )) &&\\n\\t\\t\\t\\t// advance to the next closing parenthesis\\n\\t\\t\\t\\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\\n\\n\\t\\t\\t\\t// excess is a negative index\\n\\t\\t\\t\\tmatch[0] = match[0].slice( 0, excess );\\n\\t\\t\\t\\tmatch[2] = unquoted.slice( 0, excess );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Return only captures needed by the pseudo filter method (type and argument)\\n\\t\\t\\treturn match.slice( 0, 3 );\\n\\t\\t}\\n\\t},\\n\\n\\tfilter: {\\n\\n\\t\\t\"TAG\": function( nodeNameSelector ) {\\n\\t\\t\\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn nodeNameSelector === \"*\" ?\\n\\t\\t\\t\\tfunction() { return true; } :\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\"CLASS\": function( className ) {\\n\\t\\t\\tvar pattern = classCache[ className + \" \" ];\\n\\n\\t\\t\\treturn pattern ||\\n\\t\\t\\t\\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\\n\\t\\t\\t\\tclassCache( className, function( elem ) {\\n\\t\\t\\t\\t\\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\\n\\t\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\t\"ATTR\": function( name, operator, check ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar result = Sizzle.attr( elem, name );\\n\\n\\t\\t\\t\\tif ( result == null ) {\\n\\t\\t\\t\\t\\treturn operator === \"!=\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !operator ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult += \"\";\\n\\n\\t\\t\\t\\treturn operator === \"=\" ? result === check :\\n\\t\\t\\t\\t\\toperator === \"!=\" ? result !== check :\\n\\t\\t\\t\\t\\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\\n\\t\\t\\t\\t\\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\\n\\t\\t\\t\\t\\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\\n\\t\\t\\t\\t\\tfalse;\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\"CHILD\": function( type, what, argument, first, last ) {\\n\\t\\t\\tvar simple = type.slice( 0, 3 ) !== \"nth\",\\n\\t\\t\\t\\tforward = type.slice( -4 ) !== \"last\",\\n\\t\\t\\t\\tofType = what === \"of-type\";\\n\\n\\t\\t\\treturn first === 1 && last === 0 ?\\n\\n\\t\\t\\t\\t// Shortcut for :nth-*(n)\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn !!elem.parentNode;\\n\\t\\t\\t\\t} :\\n\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\\n\\t\\t\\t\\t\\t\\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\\n\\t\\t\\t\\t\\t\\tparent = elem.parentNode,\\n\\t\\t\\t\\t\\t\\tname = ofType && elem.nodeName.toLowerCase(),\\n\\t\\t\\t\\t\\t\\tuseCache = !xml && !ofType,\\n\\t\\t\\t\\t\\t\\tdiff = false;\\n\\n\\t\\t\\t\\t\\tif ( parent ) {\\n\\n\\t\\t\\t\\t\\t\\t// :(first|last|only)-(child|of-type)\\n\\t\\t\\t\\t\\t\\tif ( simple ) {\\n\\t\\t\\t\\t\\t\\t\\twhile ( dir ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = node[ dir ]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t// Reverse direction for :only-* (if we haven\\'t yet done so)\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = dir = type === \"only\" && !start && \"nextSibling\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tstart = [ forward ? parent.firstChild : parent.lastChild ];\\n\\n\\t\\t\\t\\t\\t\\t// non-xml :nth-child(...) stores cache data on `parent`\\n\\t\\t\\t\\t\\t\\tif ( forward && useCache ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Seek `elem` from a previously-cached index\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\tnode = parent;\\n\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex && cache[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Fallback to seeking `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// When found, cache indexes on `parent` and break\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( node.nodeType === 1 && ++diff && node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Use previously-cached element index if available\\n\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// xml :nth-child(...)\\n\\t\\t\\t\\t\\t\\t\\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\\n\\t\\t\\t\\t\\t\\t\\tif ( diff === false ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Use the same loop as above to seek `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++diff ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Cache the index of each encountered element\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Incorporate the offset, then check against cycle size\\n\\t\\t\\t\\t\\t\\tdiff -= last;\\n\\t\\t\\t\\t\\t\\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\"PSEUDO\": function( pseudo, argument ) {\\n\\t\\t\\t// pseudo-class names are case-insensitive\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#pseudo-classes\\n\\t\\t\\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\\n\\t\\t\\t// Remember that setFilters inherits from pseudos\\n\\t\\t\\tvar args,\\n\\t\\t\\t\\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\\n\\t\\t\\t\\t\\tSizzle.error( \"unsupported pseudo: \" + pseudo );\\n\\n\\t\\t\\t// The user may use createPseudo to indicate that\\n\\t\\t\\t// arguments are needed to create the filter function\\n\\t\\t\\t// just as Sizzle does\\n\\t\\t\\tif ( fn[ expando ] ) {\\n\\t\\t\\t\\treturn fn( argument );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// But maintain support for old signatures\\n\\t\\t\\tif ( fn.length > 1 ) {\\n\\t\\t\\t\\targs = [ pseudo, pseudo, \"\", argument ];\\n\\t\\t\\t\\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\\n\\t\\t\\t\\t\\tmarkFunction(function( seed, matches ) {\\n\\t\\t\\t\\t\\t\\tvar idx,\\n\\t\\t\\t\\t\\t\\t\\tmatched = fn( seed, argument ),\\n\\t\\t\\t\\t\\t\\t\\ti = matched.length;\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tidx = indexOf( seed, matched[i] );\\n\\t\\t\\t\\t\\t\\t\\tseed[ idx ] = !( matches[ idx ] = matched[i] );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}) :\\n\\t\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\t\\treturn fn( elem, 0, args );\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn fn;\\n\\t\\t}\\n\\t},\\n\\n\\tpseudos: {\\n\\t\\t// Potentially complex pseudos\\n\\t\\t\"not\": markFunction(function( selector ) {\\n\\t\\t\\t// Trim the selector passed to compile\\n\\t\\t\\t// to avoid treating leading and trailing\\n\\t\\t\\t// spaces as combinators\\n\\t\\t\\tvar input = [],\\n\\t\\t\\t\\tresults = [],\\n\\t\\t\\t\\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\\n\\n\\t\\t\\treturn matcher[ expando ] ?\\n\\t\\t\\t\\tmarkFunction(function( seed, matches, context, xml ) {\\n\\t\\t\\t\\t\\tvar elem,\\n\\t\\t\\t\\t\\t\\tunmatched = matcher( seed, null, xml, [] ),\\n\\t\\t\\t\\t\\t\\ti = seed.length;\\n\\n\\t\\t\\t\\t\\t// Match elements unmatched by `matcher`\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\tseed[i] = !(matches[i] = elem);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}) :\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tinput[0] = elem;\\n\\t\\t\\t\\t\\tmatcher( input, null, xml, results );\\n\\t\\t\\t\\t\\t// Don\\'t keep the element (issue #299)\\n\\t\\t\\t\\t\\tinput[0] = null;\\n\\t\\t\\t\\t\\treturn !results.pop();\\n\\t\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\"has\": markFunction(function( selector ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn Sizzle( selector, elem ).length > 0;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\"contains\": markFunction(function( text ) {\\n\\t\\t\\ttext = text.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// \"Whether an element is represented by a :lang() selector\\n\\t\\t// is based solely on the element\\'s language value\\n\\t\\t// being equal to the identifier C,\\n\\t\\t// or beginning with the identifier C immediately followed by \"-\".\\n\\t\\t// The matching of C against the element\\'s language value is performed case-insensitively.\\n\\t\\t// The identifier C does not have to be a valid language name.\"\\n\\t\\t// http://www.w3.org/TR/selectors/#lang-pseudo\\n\\t\\t\"lang\": markFunction( function( lang ) {\\n\\t\\t\\t// lang value must be a valid identifier\\n\\t\\t\\tif ( !ridentifier.test(lang || \"\") ) {\\n\\t\\t\\t\\tSizzle.error( \"unsupported lang: \" + lang );\\n\\t\\t\\t}\\n\\t\\t\\tlang = lang.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar elemLang;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tif ( (elemLang = documentIsHTML ?\\n\\t\\t\\t\\t\\t\\telem.lang :\\n\\t\\t\\t\\t\\t\\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\\n\\n\\t\\t\\t\\t\\t\\telemLang = elemLang.toLowerCase();\\n\\t\\t\\t\\t\\t\\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// Miscellaneous\\n\\t\\t\"target\": function( elem ) {\\n\\t\\t\\tvar hash = window.location && window.location.hash;\\n\\t\\t\\treturn hash && hash.slice( 1 ) === elem.id;\\n\\t\\t},\\n\\n\\t\\t\"root\": function( elem ) {\\n\\t\\t\\treturn elem === docElem;\\n\\t\\t},\\n\\n\\t\\t\"focus\": function( elem ) {\\n\\t\\t\\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\\n\\t\\t},\\n\\n\\t\\t// Boolean properties\\n\\t\\t\"enabled\": createDisabledPseudo( false ),\\n\\t\\t\"disabled\": createDisabledPseudo( true ),\\n\\n\\t\\t\"checked\": function( elem ) {\\n\\t\\t\\t// In CSS3, :checked should return both checked and selected elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\tvar nodeName = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\\n\\t\\t},\\n\\n\\t\\t\"selected\": function( elem ) {\\n\\t\\t\\t// Accessing this property makes selected-by-default\\n\\t\\t\\t// options in Safari work properly\\n\\t\\t\\tif ( elem.parentNode ) {\\n\\t\\t\\t\\telem.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.selected === true;\\n\\t\\t},\\n\\n\\t\\t// Contents\\n\\t\\t\"empty\": function( elem ) {\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#empty-pseudo\\n\\t\\t\\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\\n\\t\\t\\t//   but not by others (comment: 8; processing instruction: 7; etc.)\\n\\t\\t\\t// nodeType < 6 works because attributes (2) do not appear as children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tif ( elem.nodeType < 6 ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\t\"parent\": function( elem ) {\\n\\t\\t\\treturn !Expr.pseudos[\"empty\"]( elem );\\n\\t\\t},\\n\\n\\t\\t// Element/input types\\n\\t\\t\"header\": function( elem ) {\\n\\t\\t\\treturn rheader.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\"input\": function( elem ) {\\n\\t\\t\\treturn rinputs.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\"button\": function( elem ) {\\n\\t\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\\n\\t\\t},\\n\\n\\t\\t\"text\": function( elem ) {\\n\\t\\t\\tvar attr;\\n\\t\\t\\treturn elem.nodeName.toLowerCase() === \"input\" &&\\n\\t\\t\\t\\telem.type === \"text\" &&\\n\\n\\t\\t\\t\\t// Support: IE<8\\n\\t\\t\\t\\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\\n\\t\\t\\t\\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\\n\\t\\t},\\n\\n\\t\\t// Position-in-collection\\n\\t\\t\"first\": createPositionalPseudo(function() {\\n\\t\\t\\treturn [ 0 ];\\n\\t\\t}),\\n\\n\\t\\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\treturn [ length - 1 ];\\n\\t\\t}),\\n\\n\\t\\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\treturn [ argument < 0 ? argument + length : argument ];\\n\\t\\t}),\\n\\n\\t\\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 1;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; --i >= 0; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; ++i < length; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t})\\n\\t}\\n};\\n\\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\\n\\n// Add button/input type pseudos\\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\\n\\tExpr.pseudos[ i ] = createInputPseudo( i );\\n}\\nfor ( i in { submit: true, reset: true } ) {\\n\\tExpr.pseudos[ i ] = createButtonPseudo( i );\\n}\\n\\n// Easy API for creating new setFilters\\nfunction setFilters() {}\\nsetFilters.prototype = Expr.filters = Expr.pseudos;\\nExpr.setFilters = new setFilters();\\n\\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\\n\\tvar matched, match, tokens, type,\\n\\t\\tsoFar, groups, preFilters,\\n\\t\\tcached = tokenCache[ selector + \" \" ];\\n\\n\\tif ( cached ) {\\n\\t\\treturn parseOnly ? 0 : cached.slice( 0 );\\n\\t}\\n\\n\\tsoFar = selector;\\n\\tgroups = [];\\n\\tpreFilters = Expr.preFilter;\\n\\n\\twhile ( soFar ) {\\n\\n\\t\\t// Comma and first run\\n\\t\\tif ( !matched || (match = rcomma.exec( soFar )) ) {\\n\\t\\t\\tif ( match ) {\\n\\t\\t\\t\\t// Don\\'t consume trailing commas as valid\\n\\t\\t\\t\\tsoFar = soFar.slice( match[0].length ) || soFar;\\n\\t\\t\\t}\\n\\t\\t\\tgroups.push( (tokens = []) );\\n\\t\\t}\\n\\n\\t\\tmatched = false;\\n\\n\\t\\t// Combinators\\n\\t\\tif ( (match = rcombinators.exec( soFar )) ) {\\n\\t\\t\\tmatched = match.shift();\\n\\t\\t\\ttokens.push({\\n\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t// Cast descendant combinators to space\\n\\t\\t\\t\\ttype: match[0].replace( rtrim, \" \" )\\n\\t\\t\\t});\\n\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t}\\n\\n\\t\\t// Filters\\n\\t\\tfor ( type in Expr.filter ) {\\n\\t\\t\\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\\n\\t\\t\\t\\t(match = preFilters[ type ]( match ))) ) {\\n\\t\\t\\t\\tmatched = match.shift();\\n\\t\\t\\t\\ttokens.push({\\n\\t\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\t\\tmatches: match\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( !matched ) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the length of the invalid excess\\n\\t// if we\\'re just parsing\\n\\t// Otherwise, throw an error or return tokens\\n\\treturn parseOnly ?\\n\\t\\tsoFar.length :\\n\\t\\tsoFar ?\\n\\t\\t\\tSizzle.error( selector ) :\\n\\t\\t\\t// Cache the tokens\\n\\t\\t\\ttokenCache( selector, groups ).slice( 0 );\\n};\\n\\nfunction toSelector( tokens ) {\\n\\tvar i = 0,\\n\\t\\tlen = tokens.length,\\n\\t\\tselector = \"\";\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tselector += tokens[i].value;\\n\\t}\\n\\treturn selector;\\n}\\n\\nfunction addCombinator( matcher, combinator, base ) {\\n\\tvar dir = combinator.dir,\\n\\t\\tskip = combinator.next,\\n\\t\\tkey = skip || dir,\\n\\t\\tcheckNonElements = base && key === \"parentNode\",\\n\\t\\tdoneName = done++;\\n\\n\\treturn combinator.first ?\\n\\t\\t// Check against closest ancestor/preceding element\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\treturn matcher( elem, context, xml );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t} :\\n\\n\\t\\t// Check against all ancestor/preceding elements\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar oldCache, uniqueCache, outerCache,\\n\\t\\t\\t\\tnewCache = [ dirruns, doneName ];\\n\\n\\t\\t\\t// We can\\'t set arbitrary data on XML nodes, so they don\\'t benefit from combinator caching\\n\\t\\t\\tif ( xml ) {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\touterCache = elem[ expando ] || (elem[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\\n\\t\\t\\t\\t\\t\\t\\telem = elem[ dir ] || elem;\\n\\t\\t\\t\\t\\t\\t} else if ( (oldCache = uniqueCache[ key ]) &&\\n\\t\\t\\t\\t\\t\\t\\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Assign to newCache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\treturn (newCache[ 2 ] = oldCache[ 2 ]);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Reuse newcache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache[ key ] = newCache;\\n\\n\\t\\t\\t\\t\\t\\t\\t// A match means we\\'re done; a fail means we have to keep checking\\n\\t\\t\\t\\t\\t\\t\\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n}\\n\\nfunction elementMatcher( matchers ) {\\n\\treturn matchers.length > 1 ?\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar i = matchers.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( !matchers[i]( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} :\\n\\t\\tmatchers[0];\\n}\\n\\nfunction multipleContexts( selector, contexts, results ) {\\n\\tvar i = 0,\\n\\t\\tlen = contexts.length;\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tSizzle( selector, contexts[i], results );\\n\\t}\\n\\treturn results;\\n}\\n\\nfunction condense( unmatched, map, filter, context, xml ) {\\n\\tvar elem,\\n\\t\\tnewUnmatched = [],\\n\\t\\ti = 0,\\n\\t\\tlen = unmatched.length,\\n\\t\\tmapped = map != null;\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\tif ( !filter || filter( elem, context, xml ) ) {\\n\\t\\t\\t\\tnewUnmatched.push( elem );\\n\\t\\t\\t\\tif ( mapped ) {\\n\\t\\t\\t\\t\\tmap.push( i );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn newUnmatched;\\n}\\n\\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\\n\\tif ( postFilter && !postFilter[ expando ] ) {\\n\\t\\tpostFilter = setMatcher( postFilter );\\n\\t}\\n\\tif ( postFinder && !postFinder[ expando ] ) {\\n\\t\\tpostFinder = setMatcher( postFinder, postSelector );\\n\\t}\\n\\treturn markFunction(function( seed, results, context, xml ) {\\n\\t\\tvar temp, i, elem,\\n\\t\\t\\tpreMap = [],\\n\\t\\t\\tpostMap = [],\\n\\t\\t\\tpreexisting = results.length,\\n\\n\\t\\t\\t// Get initial elements from seed or context\\n\\t\\t\\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\\n\\n\\t\\t\\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\\n\\t\\t\\tmatcherIn = preFilter && ( seed || !selector ) ?\\n\\t\\t\\t\\tcondense( elems, preMap, preFilter, context, xml ) :\\n\\t\\t\\t\\telems,\\n\\n\\t\\t\\tmatcherOut = matcher ?\\n\\t\\t\\t\\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\\n\\t\\t\\t\\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\\n\\n\\t\\t\\t\\t\\t// ...intermediate processing is necessary\\n\\t\\t\\t\\t\\t[] :\\n\\n\\t\\t\\t\\t\\t// ...otherwise use results directly\\n\\t\\t\\t\\t\\tresults :\\n\\t\\t\\t\\tmatcherIn;\\n\\n\\t\\t// Find primary matches\\n\\t\\tif ( matcher ) {\\n\\t\\t\\tmatcher( matcherIn, matcherOut, context, xml );\\n\\t\\t}\\n\\n\\t\\t// Apply postFilter\\n\\t\\tif ( postFilter ) {\\n\\t\\t\\ttemp = condense( matcherOut, postMap );\\n\\t\\t\\tpostFilter( temp, [], context, xml );\\n\\n\\t\\t\\t// Un-match failing elements by moving them back to matcherIn\\n\\t\\t\\ti = temp.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( (elem = temp[i]) ) {\\n\\t\\t\\t\\t\\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( seed ) {\\n\\t\\t\\tif ( postFinder || preFilter ) {\\n\\t\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\t\\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\\n\\t\\t\\t\\t\\ttemp = [];\\n\\t\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t// Restore matcherIn since elem is not yet a final match\\n\\t\\t\\t\\t\\t\\t\\ttemp.push( (matcherIn[i] = elem) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpostFinder( null, (matcherOut = []), temp, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Move matched elements from seed to results to keep them synchronized\\n\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) &&\\n\\t\\t\\t\\t\\t\\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\\n\\n\\t\\t\\t\\t\\t\\tseed[temp] = !(results[temp] = elem);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Add elements to results, through postFinder if defined\\n\\t\\t} else {\\n\\t\\t\\tmatcherOut = condense(\\n\\t\\t\\t\\tmatcherOut === results ?\\n\\t\\t\\t\\t\\tmatcherOut.splice( preexisting, matcherOut.length ) :\\n\\t\\t\\t\\t\\tmatcherOut\\n\\t\\t\\t);\\n\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\tpostFinder( null, results, matcherOut, xml );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.apply( results, matcherOut );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n}\\n\\nfunction matcherFromTokens( tokens ) {\\n\\tvar checkContext, matcher, j,\\n\\t\\tlen = tokens.length,\\n\\t\\tleadingRelative = Expr.relative[ tokens[0].type ],\\n\\t\\timplicitRelative = leadingRelative || Expr.relative[\" \"],\\n\\t\\ti = leadingRelative ? 1 : 0,\\n\\n\\t\\t// The foundational matcher ensures that elements are reachable from top-level context(s)\\n\\t\\tmatchContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn elem === checkContext;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchAnyContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn indexOf( checkContext, elem ) > -1;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchers = [ function( elem, context, xml ) {\\n\\t\\t\\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\\n\\t\\t\\t\\t(checkContext = context).nodeType ?\\n\\t\\t\\t\\t\\tmatchContext( elem, context, xml ) :\\n\\t\\t\\t\\t\\tmatchAnyContext( elem, context, xml ) );\\n\\t\\t\\t// Avoid hanging onto element (issue #299)\\n\\t\\t\\tcheckContext = null;\\n\\t\\t\\treturn ret;\\n\\t\\t} ];\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\\n\\t\\t\\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\\n\\t\\t} else {\\n\\t\\t\\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\\n\\n\\t\\t\\t// Return special upon seeing a positional matcher\\n\\t\\t\\tif ( matcher[ expando ] ) {\\n\\t\\t\\t\\t// Find the next relative operator (if any) for proper handling\\n\\t\\t\\t\\tj = ++i;\\n\\t\\t\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\t\\t\\tif ( Expr.relative[ tokens[j].type ] ) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn setMatcher(\\n\\t\\t\\t\\t\\ti > 1 && elementMatcher( matchers ),\\n\\t\\t\\t\\t\\ti > 1 && toSelector(\\n\\t\\t\\t\\t\\t\\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\\n\\t\\t\\t\\t\\t\\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\\n\\t\\t\\t\\t\\t).replace( rtrim, \"$1\" ),\\n\\t\\t\\t\\t\\tmatcher,\\n\\t\\t\\t\\t\\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\\n\\t\\t\\t\\t\\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\\n\\t\\t\\t\\t\\tj < len && toSelector( tokens )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tmatchers.push( matcher );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elementMatcher( matchers );\\n}\\n\\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\\n\\tvar bySet = setMatchers.length > 0,\\n\\t\\tbyElement = elementMatchers.length > 0,\\n\\t\\tsuperMatcher = function( seed, context, xml, results, outermost ) {\\n\\t\\t\\tvar elem, j, matcher,\\n\\t\\t\\t\\tmatchedCount = 0,\\n\\t\\t\\t\\ti = \"0\",\\n\\t\\t\\t\\tunmatched = seed && [],\\n\\t\\t\\t\\tsetMatched = [],\\n\\t\\t\\t\\tcontextBackup = outermostContext,\\n\\t\\t\\t\\t// We must always have either seed elements or outermost context\\n\\t\\t\\t\\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\\n\\t\\t\\t\\t// Use integer dirruns iff this is the outermost matcher\\n\\t\\t\\t\\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\\n\\t\\t\\t\\tlen = elems.length;\\n\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\toutermostContext = context === document || context || outermost;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add elements passing elementMatchers directly to results\\n\\t\\t\\t// Support: IE<9, Safari\\n\\t\\t\\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\\n\\t\\t\\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\\n\\t\\t\\t\\tif ( byElement && elem ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\tif ( !context && elem.ownerDocument !== document ) {\\n\\t\\t\\t\\t\\t\\tsetDocument( elem );\\n\\t\\t\\t\\t\\t\\txml = !documentIsHTML;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile ( (matcher = elementMatchers[j++]) ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context || document, xml) ) {\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Track unmatched elements for set filters\\n\\t\\t\\t\\tif ( bySet ) {\\n\\t\\t\\t\\t\\t// They will have gone through all possible matchers\\n\\t\\t\\t\\t\\tif ( (elem = !matcher && elem) ) {\\n\\t\\t\\t\\t\\t\\tmatchedCount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Lengthen the array for every element, matched or not\\n\\t\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t\\tunmatched.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\\n\\t\\t\\t// makes the latter nonnegative.\\n\\t\\t\\tmatchedCount += i;\\n\\n\\t\\t\\t// Apply set filters to unmatched elements\\n\\t\\t\\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\\n\\t\\t\\t// equals `i`), unless we didn\\'t visit _any_ elements in the above loop because we have\\n\\t\\t\\t// no element matchers and no seed.\\n\\t\\t\\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\\n\\t\\t\\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\\n\\t\\t\\t// numerically zero.\\n\\t\\t\\tif ( bySet && i !== matchedCount ) {\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\twhile ( (matcher = setMatchers[j++]) ) {\\n\\t\\t\\t\\t\\tmatcher( unmatched, setMatched, context, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t// Reintegrate element matches to eliminate the need for sorting\\n\\t\\t\\t\\t\\tif ( matchedCount > 0 ) {\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( !(unmatched[i] || setMatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tsetMatched[i] = pop.call( results );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Discard index placeholder values to get only actual matches\\n\\t\\t\\t\\t\\tsetMatched = condense( setMatched );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Add matches to results\\n\\t\\t\\t\\tpush.apply( results, setMatched );\\n\\n\\t\\t\\t\\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\\n\\t\\t\\t\\tif ( outermost && !seed && setMatched.length > 0 &&\\n\\t\\t\\t\\t\\t( matchedCount + setMatchers.length ) > 1 ) {\\n\\n\\t\\t\\t\\t\\tSizzle.uniqueSort( results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Override manipulation of globals by nested matchers\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\toutermostContext = contextBackup;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unmatched;\\n\\t\\t};\\n\\n\\treturn bySet ?\\n\\t\\tmarkFunction( superMatcher ) :\\n\\t\\tsuperMatcher;\\n}\\n\\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\\n\\tvar i,\\n\\t\\tsetMatchers = [],\\n\\t\\telementMatchers = [],\\n\\t\\tcached = compilerCache[ selector + \" \" ];\\n\\n\\tif ( !cached ) {\\n\\t\\t// Generate a function of recursive functions that can be used to check each element\\n\\t\\tif ( !match ) {\\n\\t\\t\\tmatch = tokenize( selector );\\n\\t\\t}\\n\\t\\ti = match.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tcached = matcherFromTokens( match[i] );\\n\\t\\t\\tif ( cached[ expando ] ) {\\n\\t\\t\\t\\tsetMatchers.push( cached );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telementMatchers.push( cached );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Cache the compiled function\\n\\t\\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\\n\\n\\t\\t// Save selector and tokenization\\n\\t\\tcached.selector = selector;\\n\\t}\\n\\treturn cached;\\n};\\n\\n/**\\n * A low-level selection function that works with Sizzle\\'s compiled\\n *  selector functions\\n * @param {String|Function} selector A selector or a pre-compiled\\n *  selector function built with Sizzle.compile\\n * @param {Element} context\\n * @param {Array} [results]\\n * @param {Array} [seed] A set of elements to match against\\n */\\nselect = Sizzle.select = function( selector, context, results, seed ) {\\n\\tvar i, tokens, token, type, find,\\n\\t\\tcompiled = typeof selector === \"function\" && selector,\\n\\t\\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\\n\\n\\tresults = results || [];\\n\\n\\t// Try to minimize operations if there is only one selector in the list and no seed\\n\\t// (the latter of which guarantees us context)\\n\\tif ( match.length === 1 ) {\\n\\n\\t\\t// Reduce context if the leading compound selector is an ID\\n\\t\\ttokens = match[0] = match[0].slice( 0 );\\n\\t\\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\\n\\t\\t\\t\\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\\n\\n\\t\\t\\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\\n\\t\\t\\tif ( !context ) {\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t// Precompiled matchers will still verify ancestry, so step up a level\\n\\t\\t\\t} else if ( compiled ) {\\n\\t\\t\\t\\tcontext = context.parentNode;\\n\\t\\t\\t}\\n\\n\\t\\t\\tselector = selector.slice( tokens.shift().value.length );\\n\\t\\t}\\n\\n\\t\\t// Fetch a seed set for right-to-left matching\\n\\t\\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttoken = tokens[i];\\n\\n\\t\\t\\t// Abort if we hit a combinator\\n\\t\\t\\tif ( Expr.relative[ (type = token.type) ] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( (find = Expr.find[ type ]) ) {\\n\\t\\t\\t\\t// Search, expanding context for leading sibling combinators\\n\\t\\t\\t\\tif ( (seed = find(\\n\\t\\t\\t\\t\\ttoken.matches[0].replace( runescape, funescape ),\\n\\t\\t\\t\\t\\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\\n\\t\\t\\t\\t)) ) {\\n\\n\\t\\t\\t\\t\\t// If seed is empty or no tokens remain, we can return early\\n\\t\\t\\t\\t\\ttokens.splice( i, 1 );\\n\\t\\t\\t\\t\\tselector = seed.length && toSelector( tokens );\\n\\t\\t\\t\\t\\tif ( !selector ) {\\n\\t\\t\\t\\t\\t\\tpush.apply( results, seed );\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Compile and execute a filtering function if one is not provided\\n\\t// Provide `match` to avoid retokenization if we modified the selector above\\n\\t( compiled || compile( selector, match ) )(\\n\\t\\tseed,\\n\\t\\tcontext,\\n\\t\\t!documentIsHTML,\\n\\t\\tresults,\\n\\t\\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\\n\\t);\\n\\treturn results;\\n};\\n\\n// One-time assignments\\n\\n// Sort stability\\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\\n\\n// Support: Chrome 14-35+\\n// Always assume duplicates if they aren\\'t passed to the comparison function\\nsupport.detectDuplicates = !!hasDuplicate;\\n\\n// Initialize against the default document\\nsetDocument();\\n\\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\\n// Detached nodes confoundingly follow *each other*\\nsupport.sortDetached = assert(function( el ) {\\n\\t// Should return 1, but returns 4 (following)\\n\\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\\n});\\n\\n// Support: IE<8\\n// Prevent attribute/property \"interpolation\"\\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\\nif ( !assert(function( el ) {\\n\\tel.innerHTML = \"<a href=\\'#\\'></a>\";\\n\\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\\n}) ) {\\n\\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use defaultValue in place of getAttribute(\"value\")\\nif ( !support.attributes || !assert(function( el ) {\\n\\tel.innerHTML = \"<input/>\";\\n\\tel.firstChild.setAttribute( \"value\", \"\" );\\n\\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\\n}) ) {\\n\\taddHandle( \"value\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\\n\\t\\t\\treturn elem.defaultValue;\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use getAttributeNode to fetch booleans when getAttribute lies\\nif ( !assert(function( el ) {\\n\\treturn el.getAttribute(\"disabled\") == null;\\n}) ) {\\n\\taddHandle( booleans, function( elem, name, isXML ) {\\n\\t\\tvar val;\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem[ name ] === true ? name.toLowerCase() :\\n\\t\\t\\t\\t\\t(val = elem.getAttributeNode( name )) && val.specified ?\\n\\t\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n\\t\\t}\\n\\t});\\n}\\n\\nreturn Sizzle;\\n\\n})( window );\\n\\n\\n\\njQuery.find = Sizzle;\\njQuery.expr = Sizzle.selectors;\\n\\n// Deprecated\\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\\njQuery.text = Sizzle.getText;\\njQuery.isXMLDoc = Sizzle.isXML;\\njQuery.contains = Sizzle.contains;\\njQuery.escapeSelector = Sizzle.escape;\\n\\n\\n\\n\\nvar dir = function( elem, dir, until ) {\\n\\tvar matched = [],\\n\\t\\ttruncate = until !== undefined;\\n\\n\\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\\n\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\tif ( truncate && jQuery( elem ).is( until ) ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tmatched.push( elem );\\n\\t\\t}\\n\\t}\\n\\treturn matched;\\n};\\n\\n\\nvar siblings = function( n, elem ) {\\n\\tvar matched = [];\\n\\n\\tfor ( ; n; n = n.nextSibling ) {\\n\\t\\tif ( n.nodeType === 1 && n !== elem ) {\\n\\t\\t\\tmatched.push( n );\\n\\t\\t}\\n\\t}\\n\\n\\treturn matched;\\n};\\n\\n\\nvar rneedsContext = jQuery.expr.match.needsContext;\\n\\n\\n\\nfunction nodeName( elem, name ) {\\n\\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\\n\\n};\\nvar rsingleTag = ( /^<([a-z][^\\\\/\\\\0>:\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[\\\\x20\\\\t\\\\r\\\\n\\\\f]*\\\\/?>(?:<\\\\/\\\\1>|)$/i );\\n\\n\\n\\nvar risSimple = /^.[^:#\\\\[\\\\.,]*$/;\\n\\n// Implement the identical functionality for filter and not\\nfunction winnow( elements, qualifier, not ) {\\n\\tif ( jQuery.isFunction( qualifier ) ) {\\n\\t\\treturn jQuery.grep( elements, function( elem, i ) {\\n\\t\\t\\treturn !!qualifier.call( elem, i, elem ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Single element\\n\\tif ( qualifier.nodeType ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( elem === qualifier ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Arraylike of elements (jQuery, arguments, Array)\\n\\tif ( typeof qualifier !== \"string\" ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Simple selector that can be filtered directly, removing non-Elements\\n\\tif ( risSimple.test( qualifier ) ) {\\n\\t\\treturn jQuery.filter( qualifier, elements, not );\\n\\t}\\n\\n\\t// Complex selector, compare the two sets, removing non-Elements\\n\\tqualifier = jQuery.filter( qualifier, elements );\\n\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\\n\\t} );\\n}\\n\\njQuery.filter = function( expr, elems, not ) {\\n\\tvar elem = elems[ 0 ];\\n\\n\\tif ( not ) {\\n\\t\\texpr = \":not(\" + expr + \")\";\\n\\t}\\n\\n\\tif ( elems.length === 1 && elem.nodeType === 1 ) {\\n\\t\\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\\n\\t}\\n\\n\\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\\n\\t\\treturn elem.nodeType === 1;\\n\\t} ) );\\n};\\n\\njQuery.fn.extend( {\\n\\tfind: function( selector ) {\\n\\t\\tvar i, ret,\\n\\t\\t\\tlen = this.length,\\n\\t\\t\\tself = this;\\n\\n\\t\\tif ( typeof selector !== \"string\" ) {\\n\\t\\t\\treturn this.pushStack( jQuery( selector ).filter( function() {\\n\\t\\t\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\t\\t\\tif ( jQuery.contains( self[ i ], this ) ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} ) );\\n\\t\\t}\\n\\n\\t\\tret = this.pushStack( [] );\\n\\n\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\tjQuery.find( selector, self[ i ], ret );\\n\\t\\t}\\n\\n\\t\\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\\n\\t},\\n\\tfilter: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], false ) );\\n\\t},\\n\\tnot: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], true ) );\\n\\t},\\n\\tis: function( selector ) {\\n\\t\\treturn !!winnow(\\n\\t\\t\\tthis,\\n\\n\\t\\t\\t// If this is a positional/relative selector, check membership in the returned set\\n\\t\\t\\t// so $(\"p:first\").is(\"p:last\") won\\'t return true for a doc with two \"p\".\\n\\t\\t\\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\\n\\t\\t\\t\\tjQuery( selector ) :\\n\\t\\t\\t\\tselector || [],\\n\\t\\t\\tfalse\\n\\t\\t).length;\\n\\t}\\n} );\\n\\n\\n// Initialize a jQuery object\\n\\n\\n// A central reference to the root jQuery(document)\\nvar rootjQuery,\\n\\n\\t// A simple way to check for HTML strings\\n\\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\\n\\t// Strict HTML recognition (#11290: must start with <)\\n\\t// Shortcut simple #id case for speed\\n\\trquickExpr = /^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]+))$/,\\n\\n\\tinit = jQuery.fn.init = function( selector, context, root ) {\\n\\t\\tvar match, elem;\\n\\n\\t\\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\\n\\t\\tif ( !selector ) {\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\t// Method init() accepts an alternate rootjQuery\\n\\t\\t// so migrate can support jQuery.sub (gh-2101)\\n\\t\\troot = root || rootjQuery;\\n\\n\\t\\t// Handle HTML strings\\n\\t\\tif ( typeof selector === \"string\" ) {\\n\\t\\t\\tif ( selector[ 0 ] === \"<\" &&\\n\\t\\t\\t\\tselector[ selector.length - 1 ] === \">\" &&\\n\\t\\t\\t\\tselector.length >= 3 ) {\\n\\n\\t\\t\\t\\t// Assume that strings that start and end with <> are HTML and skip the regex check\\n\\t\\t\\t\\tmatch = [ null, selector, null ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmatch = rquickExpr.exec( selector );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Match html or make sure no context is specified for #id\\n\\t\\t\\tif ( match && ( match[ 1 ] || !context ) ) {\\n\\n\\t\\t\\t\\t// HANDLE: $(html) -> $(array)\\n\\t\\t\\t\\tif ( match[ 1 ] ) {\\n\\t\\t\\t\\t\\tcontext = context instanceof jQuery ? context[ 0 ] : context;\\n\\n\\t\\t\\t\\t\\t// Option to run scripts is true for back-compat\\n\\t\\t\\t\\t\\t// Intentionally let the error be thrown if parseHTML is not present\\n\\t\\t\\t\\t\\tjQuery.merge( this, jQuery.parseHTML(\\n\\t\\t\\t\\t\\t\\tmatch[ 1 ],\\n\\t\\t\\t\\t\\t\\tcontext && context.nodeType ? context.ownerDocument || context : document,\\n\\t\\t\\t\\t\\t\\ttrue\\n\\t\\t\\t\\t\\t) );\\n\\n\\t\\t\\t\\t\\t// HANDLE: $(html, props)\\n\\t\\t\\t\\t\\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\\n\\t\\t\\t\\t\\t\\tfor ( match in context ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Properties of context are called as methods if possible\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( this[ match ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis[ match ]( context[ match ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...and otherwise set as attributes\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.attr( match, context[ match ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t// HANDLE: $(#id)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\telem = document.getElementById( match[ 2 ] );\\n\\n\\t\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t\\t// Inject the element directly into the jQuery object\\n\\t\\t\\t\\t\\t\\tthis[ 0 ] = elem;\\n\\t\\t\\t\\t\\t\\tthis.length = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// HANDLE: $(expr, $(...))\\n\\t\\t\\t} else if ( !context || context.jquery ) {\\n\\t\\t\\t\\treturn ( context || root ).find( selector );\\n\\n\\t\\t\\t// HANDLE: $(expr, context)\\n\\t\\t\\t// (which is just equivalent to: $(context).find(expr)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this.constructor( context ).find( selector );\\n\\t\\t\\t}\\n\\n\\t\\t// HANDLE: $(DOMElement)\\n\\t\\t} else if ( selector.nodeType ) {\\n\\t\\t\\tthis[ 0 ] = selector;\\n\\t\\t\\tthis.length = 1;\\n\\t\\t\\treturn this;\\n\\n\\t\\t// HANDLE: $(function)\\n\\t\\t// Shortcut for document ready\\n\\t\\t} else if ( jQuery.isFunction( selector ) ) {\\n\\t\\t\\treturn root.ready !== undefined ?\\n\\t\\t\\t\\troot.ready( selector ) :\\n\\n\\t\\t\\t\\t// Execute immediately if ready is not present\\n\\t\\t\\t\\tselector( jQuery );\\n\\t\\t}\\n\\n\\t\\treturn jQuery.makeArray( selector, this );\\n\\t};\\n\\n// Give the init function the jQuery prototype for later instantiation\\ninit.prototype = jQuery.fn;\\n\\n// Initialize central reference\\nrootjQuery = jQuery( document );\\n\\n\\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\\n\\n\\t// Methods guaranteed to produce a unique set when starting from a unique set\\n\\tguaranteedUnique = {\\n\\t\\tchildren: true,\\n\\t\\tcontents: true,\\n\\t\\tnext: true,\\n\\t\\tprev: true\\n\\t};\\n\\njQuery.fn.extend( {\\n\\thas: function( target ) {\\n\\t\\tvar targets = jQuery( target, this ),\\n\\t\\t\\tl = targets.length;\\n\\n\\t\\treturn this.filter( function() {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tif ( jQuery.contains( this, targets[ i ] ) ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tclosest: function( selectors, context ) {\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tl = this.length,\\n\\t\\t\\tmatched = [],\\n\\t\\t\\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\\n\\n\\t\\t// Positional selectors never match, since there\\'s no _selection_ context\\n\\t\\tif ( !rneedsContext.test( selectors ) ) {\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\\n\\n\\t\\t\\t\\t\\t// Always skip document fragments\\n\\t\\t\\t\\t\\tif ( cur.nodeType < 11 && ( targets ?\\n\\t\\t\\t\\t\\t\\ttargets.index( cur ) > -1 :\\n\\n\\t\\t\\t\\t\\t\\t// Don\\'t pass non-elements to Sizzle\\n\\t\\t\\t\\t\\t\\tcur.nodeType === 1 &&\\n\\t\\t\\t\\t\\t\\t\\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tmatched.push( cur );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\\n\\t},\\n\\n\\t// Determine the position of an element within the set\\n\\tindex: function( elem ) {\\n\\n\\t\\t// No argument, return index in parent\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\\n\\t\\t}\\n\\n\\t\\t// Index in selector\\n\\t\\tif ( typeof elem === \"string\" ) {\\n\\t\\t\\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\\n\\t\\t}\\n\\n\\t\\t// Locate the position of the desired element\\n\\t\\treturn indexOf.call( this,\\n\\n\\t\\t\\t// If it receives a jQuery object, the first element is used\\n\\t\\t\\telem.jquery ? elem[ 0 ] : elem\\n\\t\\t);\\n\\t},\\n\\n\\tadd: function( selector, context ) {\\n\\t\\treturn this.pushStack(\\n\\t\\t\\tjQuery.uniqueSort(\\n\\t\\t\\t\\tjQuery.merge( this.get(), jQuery( selector, context ) )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t},\\n\\n\\taddBack: function( selector ) {\\n\\t\\treturn this.add( selector == null ?\\n\\t\\t\\tthis.prevObject : this.prevObject.filter( selector )\\n\\t\\t);\\n\\t}\\n} );\\n\\nfunction sibling( cur, dir ) {\\n\\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\\n\\treturn cur;\\n}\\n\\njQuery.each( {\\n\\tparent: function( elem ) {\\n\\t\\tvar parent = elem.parentNode;\\n\\t\\treturn parent && parent.nodeType !== 11 ? parent : null;\\n\\t},\\n\\tparents: function( elem ) {\\n\\t\\treturn dir( elem, \"parentNode\" );\\n\\t},\\n\\tparentsUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \"parentNode\", until );\\n\\t},\\n\\tnext: function( elem ) {\\n\\t\\treturn sibling( elem, \"nextSibling\" );\\n\\t},\\n\\tprev: function( elem ) {\\n\\t\\treturn sibling( elem, \"previousSibling\" );\\n\\t},\\n\\tnextAll: function( elem ) {\\n\\t\\treturn dir( elem, \"nextSibling\" );\\n\\t},\\n\\tprevAll: function( elem ) {\\n\\t\\treturn dir( elem, \"previousSibling\" );\\n\\t},\\n\\tnextUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \"nextSibling\", until );\\n\\t},\\n\\tprevUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \"previousSibling\", until );\\n\\t},\\n\\tsiblings: function( elem ) {\\n\\t\\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\\n\\t},\\n\\tchildren: function( elem ) {\\n\\t\\treturn siblings( elem.firstChild );\\n\\t},\\n\\tcontents: function( elem ) {\\n        if ( nodeName( elem, \"iframe\" ) ) {\\n            return elem.contentDocument;\\n        }\\n\\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\\n        // Treat the template element as a regular one in browsers that\\n        // don\\'t support it.\\n        if ( nodeName( elem, \"template\" ) ) {\\n            elem = elem.content || elem;\\n        }\\n\\n        return jQuery.merge( [], elem.childNodes );\\n\\t}\\n}, function( name, fn ) {\\n\\tjQuery.fn[ name ] = function( until, selector ) {\\n\\t\\tvar matched = jQuery.map( this, fn, until );\\n\\n\\t\\tif ( name.slice( -5 ) !== \"Until\" ) {\\n\\t\\t\\tselector = until;\\n\\t\\t}\\n\\n\\t\\tif ( selector && typeof selector === \"string\" ) {\\n\\t\\t\\tmatched = jQuery.filter( selector, matched );\\n\\t\\t}\\n\\n\\t\\tif ( this.length > 1 ) {\\n\\n\\t\\t\\t// Remove duplicates\\n\\t\\t\\tif ( !guaranteedUnique[ name ] ) {\\n\\t\\t\\t\\tjQuery.uniqueSort( matched );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reverse order for parents* and prev-derivatives\\n\\t\\t\\tif ( rparentsprev.test( name ) ) {\\n\\t\\t\\t\\tmatched.reverse();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched );\\n\\t};\\n} );\\nvar rnothtmlwhite = ( /[^\\\\x20\\\\t\\\\r\\\\n\\\\f]+/g );\\n\\n\\n\\n// Convert String-formatted options into Object-formatted ones\\nfunction createOptions( options ) {\\n\\tvar object = {};\\n\\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\\n\\t\\tobject[ flag ] = true;\\n\\t} );\\n\\treturn object;\\n}\\n\\n/*\\n * Create a callback list using the following parameters:\\n *\\n *\\toptions: an optional list of space-separated options that will change how\\n *\\t\\t\\tthe callback list behaves or a more traditional option object\\n *\\n * By default a callback list will act like an event callback list and can be\\n * \"fired\" multiple times.\\n *\\n * Possible options:\\n *\\n *\\tonce:\\t\\t\\twill ensure the callback list can only be fired once (like a Deferred)\\n *\\n *\\tmemory:\\t\\t\\twill keep track of previous values and will call any callback added\\n *\\t\\t\\t\\t\\tafter the list has been fired right away with the latest \"memorized\"\\n *\\t\\t\\t\\t\\tvalues (like a Deferred)\\n *\\n *\\tunique:\\t\\t\\twill ensure a callback can only be added once (no duplicate in the list)\\n *\\n *\\tstopOnFalse:\\tinterrupt callings when a callback returns false\\n *\\n */\\njQuery.Callbacks = function( options ) {\\n\\n\\t// Convert options from String-formatted to Object-formatted if needed\\n\\t// (we check in cache first)\\n\\toptions = typeof options === \"string\" ?\\n\\t\\tcreateOptions( options ) :\\n\\t\\tjQuery.extend( {}, options );\\n\\n\\tvar // Flag to know if list is currently firing\\n\\t\\tfiring,\\n\\n\\t\\t// Last fire value for non-forgettable lists\\n\\t\\tmemory,\\n\\n\\t\\t// Flag to know if list was already fired\\n\\t\\tfired,\\n\\n\\t\\t// Flag to prevent firing\\n\\t\\tlocked,\\n\\n\\t\\t// Actual callback list\\n\\t\\tlist = [],\\n\\n\\t\\t// Queue of execution data for repeatable lists\\n\\t\\tqueue = [],\\n\\n\\t\\t// Index of currently firing callback (modified by add/remove as needed)\\n\\t\\tfiringIndex = -1,\\n\\n\\t\\t// Fire callbacks\\n\\t\\tfire = function() {\\n\\n\\t\\t\\t// Enforce single-firing\\n\\t\\t\\tlocked = locked || options.once;\\n\\n\\t\\t\\t// Execute callbacks for all pending executions,\\n\\t\\t\\t// respecting firingIndex overrides and runtime changes\\n\\t\\t\\tfired = firing = true;\\n\\t\\t\\tfor ( ; queue.length; firingIndex = -1 ) {\\n\\t\\t\\t\\tmemory = queue.shift();\\n\\t\\t\\t\\twhile ( ++firingIndex < list.length ) {\\n\\n\\t\\t\\t\\t\\t// Run callback and check for early termination\\n\\t\\t\\t\\t\\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\\n\\t\\t\\t\\t\\t\\toptions.stopOnFalse ) {\\n\\n\\t\\t\\t\\t\\t\\t// Jump to end and forget the data so .add doesn\\'t re-fire\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length;\\n\\t\\t\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Forget the data if we\\'re done with it\\n\\t\\t\\tif ( !options.memory ) {\\n\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfiring = false;\\n\\n\\t\\t\\t// Clean up if we\\'re done firing for good\\n\\t\\t\\tif ( locked ) {\\n\\n\\t\\t\\t\\t// Keep an empty list if we have data for future add calls\\n\\t\\t\\t\\tif ( memory ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\n\\t\\t\\t\\t// Otherwise, this object is spent\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlist = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Actual Callbacks object\\n\\t\\tself = {\\n\\n\\t\\t\\t// Add a callback or a collection of callbacks to the list\\n\\t\\t\\tadd: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\n\\t\\t\\t\\t\\t// If we have memory from a past run, we should fire after adding\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length - 1;\\n\\t\\t\\t\\t\\t\\tqueue.push( memory );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t( function add( args ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( args, function( _, arg ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( !options.unique || !self.has( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlist.push( arg );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Inspect recursively\\n\\t\\t\\t\\t\\t\\t\\t\\tadd( arg );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t} )( arguments );\\n\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove a callback from the list\\n\\t\\t\\tremove: function() {\\n\\t\\t\\t\\tjQuery.each( arguments, function( _, arg ) {\\n\\t\\t\\t\\t\\tvar index;\\n\\t\\t\\t\\t\\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\\n\\t\\t\\t\\t\\t\\tlist.splice( index, 1 );\\n\\n\\t\\t\\t\\t\\t\\t// Handle firing indexes\\n\\t\\t\\t\\t\\t\\tif ( index <= firingIndex ) {\\n\\t\\t\\t\\t\\t\\t\\tfiringIndex--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Check if a given callback is in the list.\\n\\t\\t\\t// If no argument is given, return whether or not list has callbacks attached.\\n\\t\\t\\thas: function( fn ) {\\n\\t\\t\\t\\treturn fn ?\\n\\t\\t\\t\\t\\tjQuery.inArray( fn, list ) > -1 :\\n\\t\\t\\t\\t\\tlist.length > 0;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove all callbacks from the list\\n\\t\\t\\tempty: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire and .add\\n\\t\\t\\t// Abort any current/pending executions\\n\\t\\t\\t// Clear all callbacks and values\\n\\t\\t\\tdisable: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tlist = memory = \"\";\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tdisabled: function() {\\n\\t\\t\\t\\treturn !list;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire\\n\\t\\t\\t// Also disable .add unless we have memory (since it would have no effect)\\n\\t\\t\\t// Abort any pending executions\\n\\t\\t\\tlock: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tif ( !memory && !firing ) {\\n\\t\\t\\t\\t\\tlist = memory = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tlocked: function() {\\n\\t\\t\\t\\treturn !!locked;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all callbacks with the given context and arguments\\n\\t\\t\\tfireWith: function( context, args ) {\\n\\t\\t\\t\\tif ( !locked ) {\\n\\t\\t\\t\\t\\targs = args || [];\\n\\t\\t\\t\\t\\targs = [ context, args.slice ? args.slice() : args ];\\n\\t\\t\\t\\t\\tqueue.push( args );\\n\\t\\t\\t\\t\\tif ( !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all the callbacks with the given arguments\\n\\t\\t\\tfire: function() {\\n\\t\\t\\t\\tself.fireWith( this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// To know if the callbacks have already been called at least once\\n\\t\\t\\tfired: function() {\\n\\t\\t\\t\\treturn !!fired;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\treturn self;\\n};\\n\\n\\nfunction Identity( v ) {\\n\\treturn v;\\n}\\nfunction Thrower( ex ) {\\n\\tthrow ex;\\n}\\n\\nfunction adoptValue( value, resolve, reject, noValue ) {\\n\\tvar method;\\n\\n\\ttry {\\n\\n\\t\\t// Check for promise aspect first to privilege synchronous behavior\\n\\t\\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\\n\\t\\t\\tmethod.call( value ).done( resolve ).fail( reject );\\n\\n\\t\\t// Other thenables\\n\\t\\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\\n\\t\\t\\tmethod.call( value, resolve, reject );\\n\\n\\t\\t// Other non-thenables\\n\\t\\t} else {\\n\\n\\t\\t\\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\\n\\t\\t\\t// * false: [ value ].slice( 0 ) => resolve( value )\\n\\t\\t\\t// * true: [ value ].slice( 1 ) => resolve()\\n\\t\\t\\tresolve.apply( undefined, [ value ].slice( noValue ) );\\n\\t\\t}\\n\\n\\t// For Promises/A+, convert exceptions into rejections\\n\\t// Since jQuery.when doesn\\'t unwrap thenables, we can skip the extra checks appearing in\\n\\t// Deferred#then to conditionally suppress rejection.\\n\\t} catch ( value ) {\\n\\n\\t\\t// Support: Android 4.0 only\\n\\t\\t// Strict mode functions invoked without .call/.apply get global-object context\\n\\t\\treject.apply( undefined, [ value ] );\\n\\t}\\n}\\n\\njQuery.extend( {\\n\\n\\tDeferred: function( func ) {\\n\\t\\tvar tuples = [\\n\\n\\t\\t\\t\\t// action, add listener, callbacks,\\n\\t\\t\\t\\t// ... .then handlers, argument index, [final state]\\n\\t\\t\\t\\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \"memory\" ), 2 ],\\n\\t\\t\\t\\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\\n\\t\\t\\t\\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\\n\\t\\t\\t],\\n\\t\\t\\tstate = \"pending\",\\n\\t\\t\\tpromise = {\\n\\t\\t\\t\\tstate: function() {\\n\\t\\t\\t\\t\\treturn state;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\talways: function() {\\n\\t\\t\\t\\t\\tdeferred.done( arguments ).fail( arguments );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"catch\": function( fn ) {\\n\\t\\t\\t\\t\\treturn promise.then( null, fn );\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Keep pipe for back-compat\\n\\t\\t\\t\\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\\n\\t\\t\\t\\t\\tvar fns = arguments;\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\\n\\t\\t\\t\\t\\t\\t\\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\\n\\t\\t\\t\\t\\t\\t\\tdeferred[ tuple[ 1 ] ]( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar returned = fn && fn.apply( this, arguments );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( returned && jQuery.isFunction( returned.promise ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.promise()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.progress( newDefer.notify )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.done( newDefer.resolve )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.fail( newDefer.reject );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnewDefer[ tuple[ 0 ] + \"With\" ](\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfn ? [ returned ] : arguments\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\tfns = null;\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tthen: function( onFulfilled, onRejected, onProgress ) {\\n\\t\\t\\t\\t\\tvar maxDepth = 0;\\n\\t\\t\\t\\t\\tfunction resolve( depth, deferred, handler, special ) {\\n\\t\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\t\\tvar that = this,\\n\\t\\t\\t\\t\\t\\t\\t\\targs = arguments,\\n\\t\\t\\t\\t\\t\\t\\t\\tmightThrow = function() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar returned, then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-59\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore double-resolution attempts\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth < maxDepth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned = handler.apply( that, args );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-48\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( returned === deferred.promise() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthrow new TypeError( \"Thenable self-resolution\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ sections 2.3.3.1, 3.5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-54\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-75\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Retrieve `then` only once\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthen = returned &&\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-64\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only check objects and functions for thenability\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( typeof returned === \"object\" ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof returned === \"function\" ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle a returned thenable\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( then ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Special processors (notify) just wait for resolution\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( special ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Normal processors (resolve) also hook into progress\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// ...and disregard older resolution values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmaxDepth++;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.notifyWith )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle all other returned values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Identity ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ returned ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Process the value(s)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Default process is resolve\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( special || deferred.resolveWith )( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Only normal processors (resolve) catch and reject exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess = special ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.exceptionHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tjQuery.Deferred.exceptionHook( e,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.4.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-61\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore post-resolution exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth + 1 >= maxDepth ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Thrower ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ e ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.rejectWith( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.1\\n\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-57\\n\\t\\t\\t\\t\\t\\t\\t// Re-resolve promises immediately to dodge false rejection from\\n\\t\\t\\t\\t\\t\\t\\t// subsequent errors\\n\\t\\t\\t\\t\\t\\t\\tif ( depth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess();\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Call an optional hook to record the stack, in case of exception\\n\\t\\t\\t\\t\\t\\t\\t\\t// since it\\'s otherwise lost when execution goes async\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.getStackHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace = jQuery.Deferred.getStackHook();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( process );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\n\\t\\t\\t\\t\\t\\t// progress_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onProgress ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonProgress :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer.notifyWith\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// fulfilled_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 1 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onFulfilled ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonFulfilled :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// rejected_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 2 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onRejected ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonRejected :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tThrower\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Get a promise for this deferred\\n\\t\\t\\t\\t// If obj is provided, the promise aspect is added to the object\\n\\t\\t\\t\\tpromise: function( obj ) {\\n\\t\\t\\t\\t\\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdeferred = {};\\n\\n\\t\\t// Add list-specific methods\\n\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\t\\t\\tvar list = tuple[ 2 ],\\n\\t\\t\\t\\tstateString = tuple[ 5 ];\\n\\n\\t\\t\\t// promise.progress = list.add\\n\\t\\t\\t// promise.done = list.add\\n\\t\\t\\t// promise.fail = list.add\\n\\t\\t\\tpromise[ tuple[ 1 ] ] = list.add;\\n\\n\\t\\t\\t// Handle state\\n\\t\\t\\tif ( stateString ) {\\n\\t\\t\\t\\tlist.add(\\n\\t\\t\\t\\t\\tfunction() {\\n\\n\\t\\t\\t\\t\\t\\t// state = \"resolved\" (i.e., fulfilled)\\n\\t\\t\\t\\t\\t\\t// state = \"rejected\"\\n\\t\\t\\t\\t\\t\\tstate = stateString;\\n\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t// rejected_callbacks.disable\\n\\t\\t\\t\\t\\t// fulfilled_callbacks.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 2 ].disable,\\n\\n\\t\\t\\t\\t\\t// progress_callbacks.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 2 ].lock\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// progress_handlers.fire\\n\\t\\t\\t// fulfilled_handlers.fire\\n\\t\\t\\t// rejected_handlers.fire\\n\\t\\t\\tlist.add( tuple[ 3 ].fire );\\n\\n\\t\\t\\t// deferred.notify = function() { deferred.notifyWith(...) }\\n\\t\\t\\t// deferred.resolve = function() { deferred.resolveWith(...) }\\n\\t\\t\\t// deferred.reject = function() { deferred.rejectWith(...) }\\n\\t\\t\\tdeferred[ tuple[ 0 ] ] = function() {\\n\\t\\t\\t\\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t};\\n\\n\\t\\t\\t// deferred.notifyWith = list.fireWith\\n\\t\\t\\t// deferred.resolveWith = list.fireWith\\n\\t\\t\\t// deferred.rejectWith = list.fireWith\\n\\t\\t\\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\\n\\t\\t} );\\n\\n\\t\\t// Make the deferred a promise\\n\\t\\tpromise.promise( deferred );\\n\\n\\t\\t// Call given func if any\\n\\t\\tif ( func ) {\\n\\t\\t\\tfunc.call( deferred, deferred );\\n\\t\\t}\\n\\n\\t\\t// All done!\\n\\t\\treturn deferred;\\n\\t},\\n\\n\\t// Deferred helper\\n\\twhen: function( singleValue ) {\\n\\t\\tvar\\n\\n\\t\\t\\t// count of uncompleted subordinates\\n\\t\\t\\tremaining = arguments.length,\\n\\n\\t\\t\\t// count of unprocessed arguments\\n\\t\\t\\ti = remaining,\\n\\n\\t\\t\\t// subordinate fulfillment data\\n\\t\\t\\tresolveContexts = Array( i ),\\n\\t\\t\\tresolveValues = slice.call( arguments ),\\n\\n\\t\\t\\t// the master Deferred\\n\\t\\t\\tmaster = jQuery.Deferred(),\\n\\n\\t\\t\\t// subordinate callback factory\\n\\t\\t\\tupdateFunc = function( i ) {\\n\\t\\t\\t\\treturn function( value ) {\\n\\t\\t\\t\\t\\tresolveContexts[ i ] = this;\\n\\t\\t\\t\\t\\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\\n\\t\\t\\t\\t\\tif ( !( --remaining ) ) {\\n\\t\\t\\t\\t\\t\\tmaster.resolveWith( resolveContexts, resolveValues );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\t};\\n\\n\\t\\t// Single- and empty arguments are adopted like Promise.resolve\\n\\t\\tif ( remaining <= 1 ) {\\n\\t\\t\\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\\n\\t\\t\\t\\t!remaining );\\n\\n\\t\\t\\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\\n\\t\\t\\tif ( master.state() === \"pending\" ||\\n\\t\\t\\t\\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\\n\\n\\t\\t\\t\\treturn master.then();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Multiple arguments are aggregated like Promise.all array elements\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\\n\\t\\t}\\n\\n\\t\\treturn master.promise();\\n\\t}\\n} );\\n\\n\\n// These usually indicate a programmer mistake during development,\\n// warn about them ASAP rather than swallowing them by default.\\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\\n\\njQuery.Deferred.exceptionHook = function( error, stack ) {\\n\\n\\t// Support: IE 8 - 9 only\\n\\t// Console exists when dev tools are open, which can happen at any time\\n\\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\\n\\t\\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\\n\\t}\\n};\\n\\n\\n\\n\\njQuery.readyException = function( error ) {\\n\\twindow.setTimeout( function() {\\n\\t\\tthrow error;\\n\\t} );\\n};\\n\\n\\n\\n\\n// The deferred used on DOM ready\\nvar readyList = jQuery.Deferred();\\n\\njQuery.fn.ready = function( fn ) {\\n\\n\\treadyList\\n\\t\\t.then( fn )\\n\\n\\t\\t// Wrap jQuery.readyException in a function so that the lookup\\n\\t\\t// happens at the time of error handling instead of callback\\n\\t\\t// registration.\\n\\t\\t.catch( function( error ) {\\n\\t\\t\\tjQuery.readyException( error );\\n\\t\\t} );\\n\\n\\treturn this;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Is the DOM ready to be used? Set to true once it occurs.\\n\\tisReady: false,\\n\\n\\t// A counter to track how many items to wait for before\\n\\t// the ready event fires. See #6781\\n\\treadyWait: 1,\\n\\n\\t// Handle when the DOM is ready\\n\\tready: function( wait ) {\\n\\n\\t\\t// Abort if there are pending holds or we\\'re already ready\\n\\t\\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Remember that the DOM is ready\\n\\t\\tjQuery.isReady = true;\\n\\n\\t\\t// If a normal DOM Ready event fired, decrement, and wait if need be\\n\\t\\tif ( wait !== true && --jQuery.readyWait > 0 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// If there are functions bound, to execute\\n\\t\\treadyList.resolveWith( document, [ jQuery ] );\\n\\t}\\n} );\\n\\njQuery.ready.then = readyList.then;\\n\\n// The ready event handler and self cleanup method\\nfunction completed() {\\n\\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\\n\\twindow.removeEventListener( \"load\", completed );\\n\\tjQuery.ready();\\n}\\n\\n// Catch cases where $(document).ready() is called\\n// after the browser event has already occurred.\\n// Support: IE <=9 - 10 only\\n// Older IE sometimes signals \"interactive\" too soon\\nif ( document.readyState === \"complete\" ||\\n\\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\\n\\n\\t// Handle it asynchronously to allow scripts the opportunity to delay ready\\n\\twindow.setTimeout( jQuery.ready );\\n\\n} else {\\n\\n\\t// Use the handy event callback\\n\\tdocument.addEventListener( \"DOMContentLoaded\", completed );\\n\\n\\t// A fallback to window.onload, that will always work\\n\\twindow.addEventListener( \"load\", completed );\\n}\\n\\n\\n\\n\\n// Multifunctional method to get and set values of a collection\\n// The value/s can optionally be executed if it\\'s a function\\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\\n\\tvar i = 0,\\n\\t\\tlen = elems.length,\\n\\t\\tbulk = key == null;\\n\\n\\t// Sets many values\\n\\tif ( jQuery.type( key ) === \"object\" ) {\\n\\t\\tchainable = true;\\n\\t\\tfor ( i in key ) {\\n\\t\\t\\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\\n\\t\\t}\\n\\n\\t// Sets one value\\n\\t} else if ( value !== undefined ) {\\n\\t\\tchainable = true;\\n\\n\\t\\tif ( !jQuery.isFunction( value ) ) {\\n\\t\\t\\traw = true;\\n\\t\\t}\\n\\n\\t\\tif ( bulk ) {\\n\\n\\t\\t\\t// Bulk operations run against the entire set\\n\\t\\t\\tif ( raw ) {\\n\\t\\t\\t\\tfn.call( elems, value );\\n\\t\\t\\t\\tfn = null;\\n\\n\\t\\t\\t// ...except when executing function values\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbulk = fn;\\n\\t\\t\\t\\tfn = function( elem, key, value ) {\\n\\t\\t\\t\\t\\treturn bulk.call( jQuery( elem ), value );\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\tfn(\\n\\t\\t\\t\\t\\telems[ i ], key, raw ?\\n\\t\\t\\t\\t\\tvalue :\\n\\t\\t\\t\\t\\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( chainable ) {\\n\\t\\treturn elems;\\n\\t}\\n\\n\\t// Gets\\n\\tif ( bulk ) {\\n\\t\\treturn fn.call( elems );\\n\\t}\\n\\n\\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\\n};\\nvar acceptData = function( owner ) {\\n\\n\\t// Accepts only:\\n\\t//  - Node\\n\\t//    - Node.ELEMENT_NODE\\n\\t//    - Node.DOCUMENT_NODE\\n\\t//  - Object\\n\\t//    - Any\\n\\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\\n};\\n\\n\\n\\n\\nfunction Data() {\\n\\tthis.expando = jQuery.expando + Data.uid++;\\n}\\n\\nData.uid = 1;\\n\\nData.prototype = {\\n\\n\\tcache: function( owner ) {\\n\\n\\t\\t// Check if the owner object already has a cache\\n\\t\\tvar value = owner[ this.expando ];\\n\\n\\t\\t// If not, create one\\n\\t\\tif ( !value ) {\\n\\t\\t\\tvalue = {};\\n\\n\\t\\t\\t// We can accept data for non-element nodes in modern browsers,\\n\\t\\t\\t// but we should not, see #8335.\\n\\t\\t\\t// Always return an empty object.\\n\\t\\t\\tif ( acceptData( owner ) ) {\\n\\n\\t\\t\\t\\t// If it is a node unlikely to be stringify-ed or looped over\\n\\t\\t\\t\\t// use plain assignment\\n\\t\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\t\\towner[ this.expando ] = value;\\n\\n\\t\\t\\t\\t// Otherwise secure it in a non-enumerable property\\n\\t\\t\\t\\t// configurable must be true to allow the property to be\\n\\t\\t\\t\\t// deleted when data is removed\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty( owner, this.expando, {\\n\\t\\t\\t\\t\\t\\tvalue: value,\\n\\t\\t\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t},\\n\\tset: function( owner, data, value ) {\\n\\t\\tvar prop,\\n\\t\\t\\tcache = this.cache( owner );\\n\\n\\t\\t// Handle: [ owner, key, value ] args\\n\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\tif ( typeof data === \"string\" ) {\\n\\t\\t\\tcache[ jQuery.camelCase( data ) ] = value;\\n\\n\\t\\t// Handle: [ owner, { properties } ] args\\n\\t\\t} else {\\n\\n\\t\\t\\t// Copy the properties one-by-one to the cache object\\n\\t\\t\\tfor ( prop in data ) {\\n\\t\\t\\t\\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cache;\\n\\t},\\n\\tget: function( owner, key ) {\\n\\t\\treturn key === undefined ?\\n\\t\\t\\tthis.cache( owner ) :\\n\\n\\t\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\t\\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\\n\\t},\\n\\taccess: function( owner, key, value ) {\\n\\n\\t\\t// In cases where either:\\n\\t\\t//\\n\\t\\t//   1. No key was specified\\n\\t\\t//   2. A string key was specified, but no value provided\\n\\t\\t//\\n\\t\\t// Take the \"read\" path and allow the get method to determine\\n\\t\\t// which value to return, respectively either:\\n\\t\\t//\\n\\t\\t//   1. The entire cache object\\n\\t\\t//   2. The data stored at the key\\n\\t\\t//\\n\\t\\tif ( key === undefined ||\\n\\t\\t\\t\\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\\n\\n\\t\\t\\treturn this.get( owner, key );\\n\\t\\t}\\n\\n\\t\\t// When the key is not a string, or both a key and value\\n\\t\\t// are specified, set or extend (existing objects) with either:\\n\\t\\t//\\n\\t\\t//   1. An object of properties\\n\\t\\t//   2. A key and value\\n\\t\\t//\\n\\t\\tthis.set( owner, key, value );\\n\\n\\t\\t// Since the \"set\" path can have two possible entry points\\n\\t\\t// return the expected data based on which path was taken[*]\\n\\t\\treturn value !== undefined ? value : key;\\n\\t},\\n\\tremove: function( owner, key ) {\\n\\t\\tvar i,\\n\\t\\t\\tcache = owner[ this.expando ];\\n\\n\\t\\tif ( cache === undefined ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key !== undefined ) {\\n\\n\\t\\t\\t// Support array or space separated string of keys\\n\\t\\t\\tif ( Array.isArray( key ) ) {\\n\\n\\t\\t\\t\\t// If key is an array of keys...\\n\\t\\t\\t\\t// We always set camelCase keys, so remove that.\\n\\t\\t\\t\\tkey = key.map( jQuery.camelCase );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tkey = jQuery.camelCase( key );\\n\\n\\t\\t\\t\\t// If a key with the spaces exists, use it.\\n\\t\\t\\t\\t// Otherwise, create an array by matching non-whitespace\\n\\t\\t\\t\\tkey = key in cache ?\\n\\t\\t\\t\\t\\t[ key ] :\\n\\t\\t\\t\\t\\t( key.match( rnothtmlwhite ) || [] );\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = key.length;\\n\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tdelete cache[ key[ i ] ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove the expando if there\\'s no more data\\n\\t\\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\\n\\n\\t\\t\\t// Support: Chrome <=35 - 45\\n\\t\\t\\t// Webkit & Blink performance suffers when deleting properties\\n\\t\\t\\t// from DOM nodes, so set to undefined instead\\n\\t\\t\\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\\n\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\towner[ this.expando ] = undefined;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete owner[ this.expando ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\thasData: function( owner ) {\\n\\t\\tvar cache = owner[ this.expando ];\\n\\t\\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\\n\\t}\\n};\\nvar dataPriv = new Data();\\n\\nvar dataUser = new Data();\\n\\n\\n\\n//\\tImplementation Summary\\n//\\n//\\t1. Enforce API surface and semantic compatibility with 1.9.x branch\\n//\\t2. Improve the module\\'s maintainability by reducing the storage\\n//\\t\\tpaths to a single mechanism.\\n//\\t3. Use the same single mechanism to support \"private\" and \"user\" data.\\n//\\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\\n//\\t5. Avoid exposing implementation details on user objects (eg. expando properties)\\n//\\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\\n\\nvar rbrace = /^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,\\n\\trmultiDash = /[A-Z]/g;\\n\\nfunction getData( data ) {\\n\\tif ( data === \"true\" ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif ( data === \"false\" ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif ( data === \"null\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Only convert to a number if it doesn\\'t change the string\\n\\tif ( data === +data + \"\" ) {\\n\\t\\treturn +data;\\n\\t}\\n\\n\\tif ( rbrace.test( data ) ) {\\n\\t\\treturn JSON.parse( data );\\n\\t}\\n\\n\\treturn data;\\n}\\n\\nfunction dataAttr( elem, key, data ) {\\n\\tvar name;\\n\\n\\t// If nothing was found internally, try to fetch any\\n\\t// data from the HTML5 data-* attribute\\n\\tif ( data === undefined && elem.nodeType === 1 ) {\\n\\t\\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\\n\\t\\tdata = elem.getAttribute( name );\\n\\n\\t\\tif ( typeof data === \"string\" ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = getData( data );\\n\\t\\t\\t} catch ( e ) {}\\n\\n\\t\\t\\t// Make sure we set the data so it isn\\'t changed later\\n\\t\\t\\tdataUser.set( elem, key, data );\\n\\t\\t} else {\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\t}\\n\\treturn data;\\n}\\n\\njQuery.extend( {\\n\\thasData: function( elem ) {\\n\\t\\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\\n\\t},\\n\\n\\tdata: function( elem, name, data ) {\\n\\t\\treturn dataUser.access( elem, name, data );\\n\\t},\\n\\n\\tremoveData: function( elem, name ) {\\n\\t\\tdataUser.remove( elem, name );\\n\\t},\\n\\n\\t// TODO: Now that all calls to _data and _removeData have been replaced\\n\\t// with direct calls to dataPriv methods, these can be deprecated.\\n\\t_data: function( elem, name, data ) {\\n\\t\\treturn dataPriv.access( elem, name, data );\\n\\t},\\n\\n\\t_removeData: function( elem, name ) {\\n\\t\\tdataPriv.remove( elem, name );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdata: function( key, value ) {\\n\\t\\tvar i, name, data,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tattrs = elem && elem.attributes;\\n\\n\\t\\t// Gets all values\\n\\t\\tif ( key === undefined ) {\\n\\t\\t\\tif ( this.length ) {\\n\\t\\t\\t\\tdata = dataUser.get( elem );\\n\\n\\t\\t\\t\\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\\n\\t\\t\\t\\t\\ti = attrs.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t\\t\\t\\t// The attrs elements can be null (#14894)\\n\\t\\t\\t\\t\\t\\tif ( attrs[ i ] ) {\\n\\t\\t\\t\\t\\t\\t\\tname = attrs[ i ].name;\\n\\t\\t\\t\\t\\t\\t\\tif ( name.indexOf( \"data-\" ) === 0 ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tname = jQuery.camelCase( name.slice( 5 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tdataAttr( elem, name, data[ name ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdataPriv.set( elem, \"hasDataAttrs\", true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\t\\t}\\n\\n\\t\\t// Sets multiple values\\n\\t\\tif ( typeof key === \"object\" ) {\\n\\t\\t\\treturn this.each( function() {\\n\\t\\t\\t\\tdataUser.set( this, key );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar data;\\n\\n\\t\\t\\t// The calling jQuery object (element matches) is not empty\\n\\t\\t\\t// (and therefore has an element appears at this[ 0 ]) and the\\n\\t\\t\\t// `value` parameter was not undefined. An empty jQuery object\\n\\t\\t\\t// will result in `undefined` for elem = this[ 0 ] which will\\n\\t\\t\\t// throw an exception if an attempt to read a data cache is made.\\n\\t\\t\\tif ( elem && value === undefined ) {\\n\\n\\t\\t\\t\\t// Attempt to get data from the cache\\n\\t\\t\\t\\t// The key will always be camelCased in Data\\n\\t\\t\\t\\tdata = dataUser.get( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Attempt to \"discover\" the data in\\n\\t\\t\\t\\t// HTML5 custom data-* attrs\\n\\t\\t\\t\\tdata = dataAttr( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// We tried really hard, but the data doesn\\'t exist.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the data...\\n\\t\\t\\tthis.each( function() {\\n\\n\\t\\t\\t\\t// We always store the camelCased key\\n\\t\\t\\t\\tdataUser.set( this, key, value );\\n\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length > 1, null, true );\\n\\t},\\n\\n\\tremoveData: function( key ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdataUser.remove( this, key );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\njQuery.extend( {\\n\\tqueue: function( elem, type, data ) {\\n\\t\\tvar queue;\\n\\n\\t\\tif ( elem ) {\\n\\t\\t\\ttype = ( type || \"fx\" ) + \"queue\";\\n\\t\\t\\tqueue = dataPriv.get( elem, type );\\n\\n\\t\\t\\t// Speed up dequeue by getting out quickly if this is just a lookup\\n\\t\\t\\tif ( data ) {\\n\\t\\t\\t\\tif ( !queue || Array.isArray( data ) ) {\\n\\t\\t\\t\\t\\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tqueue.push( data );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn queue || [];\\n\\t\\t}\\n\\t},\\n\\n\\tdequeue: function( elem, type ) {\\n\\t\\ttype = type || \"fx\";\\n\\n\\t\\tvar queue = jQuery.queue( elem, type ),\\n\\t\\t\\tstartLength = queue.length,\\n\\t\\t\\tfn = queue.shift(),\\n\\t\\t\\thooks = jQuery._queueHooks( elem, type ),\\n\\t\\t\\tnext = function() {\\n\\t\\t\\t\\tjQuery.dequeue( elem, type );\\n\\t\\t\\t};\\n\\n\\t\\t// If the fx queue is dequeued, always remove the progress sentinel\\n\\t\\tif ( fn === \"inprogress\" ) {\\n\\t\\t\\tfn = queue.shift();\\n\\t\\t\\tstartLength--;\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\n\\t\\t\\t// Add a progress sentinel to prevent the fx queue from being\\n\\t\\t\\t// automatically dequeued\\n\\t\\t\\tif ( type === \"fx\" ) {\\n\\t\\t\\t\\tqueue.unshift( \"inprogress\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Clear up the last queue stop function\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tfn.call( elem, next, hooks );\\n\\t\\t}\\n\\n\\t\\tif ( !startLength && hooks ) {\\n\\t\\t\\thooks.empty.fire();\\n\\t\\t}\\n\\t},\\n\\n\\t// Not public - generate a queueHooks object, or return the current one\\n\\t_queueHooks: function( elem, type ) {\\n\\t\\tvar key = type + \"queueHooks\";\\n\\t\\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\\n\\t\\t\\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\\n\\t\\t\\t\\tdataPriv.remove( elem, [ type + \"queue\", key ] );\\n\\t\\t\\t} )\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tqueue: function( type, data ) {\\n\\t\\tvar setter = 2;\\n\\n\\t\\tif ( typeof type !== \"string\" ) {\\n\\t\\t\\tdata = type;\\n\\t\\t\\ttype = \"fx\";\\n\\t\\t\\tsetter--;\\n\\t\\t}\\n\\n\\t\\tif ( arguments.length < setter ) {\\n\\t\\t\\treturn jQuery.queue( this[ 0 ], type );\\n\\t\\t}\\n\\n\\t\\treturn data === undefined ?\\n\\t\\t\\tthis :\\n\\t\\t\\tthis.each( function() {\\n\\t\\t\\t\\tvar queue = jQuery.queue( this, type, data );\\n\\n\\t\\t\\t\\t// Ensure a hooks for this queue\\n\\t\\t\\t\\tjQuery._queueHooks( this, type );\\n\\n\\t\\t\\t\\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\\n\\t\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t},\\n\\tdequeue: function( type ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t} );\\n\\t},\\n\\tclearQueue: function( type ) {\\n\\t\\treturn this.queue( type || \"fx\", [] );\\n\\t},\\n\\n\\t// Get a promise resolved when queues of a certain type\\n\\t// are emptied (fx is the type by default)\\n\\tpromise: function( type, obj ) {\\n\\t\\tvar tmp,\\n\\t\\t\\tcount = 1,\\n\\t\\t\\tdefer = jQuery.Deferred(),\\n\\t\\t\\telements = this,\\n\\t\\t\\ti = this.length,\\n\\t\\t\\tresolve = function() {\\n\\t\\t\\t\\tif ( !( --count ) ) {\\n\\t\\t\\t\\t\\tdefer.resolveWith( elements, [ elements ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\tif ( typeof type !== \"string\" ) {\\n\\t\\t\\tobj = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\ttype = type || \"fx\";\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\\n\\t\\t\\tif ( tmp && tmp.empty ) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\ttmp.empty.add( resolve );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresolve();\\n\\t\\treturn defer.promise( obj );\\n\\t}\\n} );\\nvar pnum = ( /[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/ ).source;\\n\\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\\n\\n\\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\\n\\nvar isHiddenWithinTree = function( elem, el ) {\\n\\n\\t\\t// isHiddenWithinTree might be called from jQuery#filter function;\\n\\t\\t// in that case, element will be second argument\\n\\t\\telem = el || elem;\\n\\n\\t\\t// Inline style trumps all\\n\\t\\treturn elem.style.display === \"none\" ||\\n\\t\\t\\telem.style.display === \"\" &&\\n\\n\\t\\t\\t// Otherwise, check computed style\\n\\t\\t\\t// Support: Firefox <=43 - 45\\n\\t\\t\\t// Disconnected elements can have computed display: none, so first confirm that elem is\\n\\t\\t\\t// in the document.\\n\\t\\t\\tjQuery.contains( elem.ownerDocument, elem ) &&\\n\\n\\t\\t\\tjQuery.css( elem, \"display\" ) === \"none\";\\n\\t};\\n\\nvar swap = function( elem, options, callback, args ) {\\n\\tvar ret, name,\\n\\t\\told = {};\\n\\n\\t// Remember the old values, and insert the new ones\\n\\tfor ( name in options ) {\\n\\t\\told[ name ] = elem.style[ name ];\\n\\t\\telem.style[ name ] = options[ name ];\\n\\t}\\n\\n\\tret = callback.apply( elem, args || [] );\\n\\n\\t// Revert the old values\\n\\tfor ( name in options ) {\\n\\t\\telem.style[ name ] = old[ name ];\\n\\t}\\n\\n\\treturn ret;\\n};\\n\\n\\n\\n\\nfunction adjustCSS( elem, prop, valueParts, tween ) {\\n\\tvar adjusted,\\n\\t\\tscale = 1,\\n\\t\\tmaxIterations = 20,\\n\\t\\tcurrentValue = tween ?\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn tween.cur();\\n\\t\\t\\t} :\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn jQuery.css( elem, prop, \"\" );\\n\\t\\t\\t},\\n\\t\\tinitial = currentValue(),\\n\\t\\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\\n\\n\\t\\t// Starting value computation is required for potential unit mismatches\\n\\t\\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\\n\\t\\t\\trcssNum.exec( jQuery.css( elem, prop ) );\\n\\n\\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\\n\\n\\t\\t// Trust units reported by jQuery.css\\n\\t\\tunit = unit || initialInUnit[ 3 ];\\n\\n\\t\\t// Make sure we update the tween properties later on\\n\\t\\tvalueParts = valueParts || [];\\n\\n\\t\\t// Iteratively approximate from a nonzero starting point\\n\\t\\tinitialInUnit = +initial || 1;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\t// If previous iteration zeroed out, double until we get *something*.\\n\\t\\t\\t// Use string for doubling so we don\\'t accidentally see scale as unchanged below\\n\\t\\t\\tscale = scale || \".5\";\\n\\n\\t\\t\\t// Adjust and apply\\n\\t\\t\\tinitialInUnit = initialInUnit / scale;\\n\\t\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\n\\t\\t// Update scale, tolerating zero or NaN from tween.cur()\\n\\t\\t// Break the loop if scale is unchanged or perfect, or if we\\'ve just had enough.\\n\\t\\t} while (\\n\\t\\t\\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\\n\\t\\t);\\n\\t}\\n\\n\\tif ( valueParts ) {\\n\\t\\tinitialInUnit = +initialInUnit || +initial || 0;\\n\\n\\t\\t// Apply relative offset (+=/-=) if specified\\n\\t\\tadjusted = valueParts[ 1 ] ?\\n\\t\\t\\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\\n\\t\\t\\t+valueParts[ 2 ];\\n\\t\\tif ( tween ) {\\n\\t\\t\\ttween.unit = unit;\\n\\t\\t\\ttween.start = initialInUnit;\\n\\t\\t\\ttween.end = adjusted;\\n\\t\\t}\\n\\t}\\n\\treturn adjusted;\\n}\\n\\n\\nvar defaultDisplayMap = {};\\n\\nfunction getDefaultDisplay( elem ) {\\n\\tvar temp,\\n\\t\\tdoc = elem.ownerDocument,\\n\\t\\tnodeName = elem.nodeName,\\n\\t\\tdisplay = defaultDisplayMap[ nodeName ];\\n\\n\\tif ( display ) {\\n\\t\\treturn display;\\n\\t}\\n\\n\\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\\n\\tdisplay = jQuery.css( temp, \"display\" );\\n\\n\\ttemp.parentNode.removeChild( temp );\\n\\n\\tif ( display === \"none\" ) {\\n\\t\\tdisplay = \"block\";\\n\\t}\\n\\tdefaultDisplayMap[ nodeName ] = display;\\n\\n\\treturn display;\\n}\\n\\nfunction showHide( elements, show ) {\\n\\tvar display, elem,\\n\\t\\tvalues = [],\\n\\t\\tindex = 0,\\n\\t\\tlength = elements.length;\\n\\n\\t// Determine new display value for elements that need to change\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\telem = elements[ index ];\\n\\t\\tif ( !elem.style ) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tdisplay = elem.style.display;\\n\\t\\tif ( show ) {\\n\\n\\t\\t\\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\\n\\t\\t\\t// check is required in this first loop unless we have a nonempty display value (either\\n\\t\\t\\t// inline or about-to-be-restored)\\n\\t\\t\\tif ( display === \"none\" ) {\\n\\t\\t\\t\\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\\n\\t\\t\\t\\tif ( !values[ index ] ) {\\n\\t\\t\\t\\t\\telem.style.display = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\\n\\t\\t\\t\\tvalues[ index ] = getDefaultDisplay( elem );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif ( display !== \"none\" ) {\\n\\t\\t\\t\\tvalues[ index ] = \"none\";\\n\\n\\t\\t\\t\\t// Remember what we\\'re overwriting\\n\\t\\t\\t\\tdataPriv.set( elem, \"display\", display );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Set the display of the elements in a second loop to avoid constant reflow\\n\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\tif ( values[ index ] != null ) {\\n\\t\\t\\telements[ index ].style.display = values[ index ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn elements;\\n}\\n\\njQuery.fn.extend( {\\n\\tshow: function() {\\n\\t\\treturn showHide( this, true );\\n\\t},\\n\\thide: function() {\\n\\t\\treturn showHide( this );\\n\\t},\\n\\ttoggle: function( state ) {\\n\\t\\tif ( typeof state === \"boolean\" ) {\\n\\t\\t\\treturn state ? this.show() : this.hide();\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tif ( isHiddenWithinTree( this ) ) {\\n\\t\\t\\t\\tjQuery( this ).show();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tjQuery( this ).hide();\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\\n\\nvar rtagName = ( /<([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]+)/i );\\n\\nvar rscriptType = ( /^$|\\\\/(?:java|ecma)script/i );\\n\\n\\n\\n// We have to close these tags to support XHTML (#13200)\\nvar wrapMap = {\\n\\n\\t// Support: IE <=9 only\\n\\toption: [ 1, \"<select multiple=\\'multiple\\'>\", \"</select>\" ],\\n\\n\\t// XHTML parsers do not magically insert elements in the\\n\\t// same way that tag soup parsers do. So we cannot shorten\\n\\t// this by omitting <tbody> or other required elements.\\n\\tthead: [ 1, \"<table>\", \"</table>\" ],\\n\\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\\n\\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\\n\\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\\n\\n\\t_default: [ 0, \"\", \"\" ]\\n};\\n\\n// Support: IE <=9 only\\nwrapMap.optgroup = wrapMap.option;\\n\\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\\nwrapMap.th = wrapMap.td;\\n\\n\\nfunction getAll( context, tag ) {\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\\n\\tvar ret;\\n\\n\\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\\n\\t\\tret = context.getElementsByTagName( tag || \"*\" );\\n\\n\\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\\n\\t\\tret = context.querySelectorAll( tag || \"*\" );\\n\\n\\t} else {\\n\\t\\tret = [];\\n\\t}\\n\\n\\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\\n\\t\\treturn jQuery.merge( [ context ], ret );\\n\\t}\\n\\n\\treturn ret;\\n}\\n\\n\\n// Mark scripts as having already been evaluated\\nfunction setGlobalEval( elems, refElements ) {\\n\\tvar i = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\tdataPriv.set(\\n\\t\\t\\telems[ i ],\\n\\t\\t\\t\"globalEval\",\\n\\t\\t\\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\\n\\t\\t);\\n\\t}\\n}\\n\\n\\nvar rhtml = /<|&#?\\\\w+;/;\\n\\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\\n\\tvar elem, tmp, tag, wrap, contains, j,\\n\\t\\tfragment = context.createDocumentFragment(),\\n\\t\\tnodes = [],\\n\\t\\ti = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\telem = elems[ i ];\\n\\n\\t\\tif ( elem || elem === 0 ) {\\n\\n\\t\\t\\t// Add nodes directly\\n\\t\\t\\tif ( jQuery.type( elem ) === \"object\" ) {\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\\n\\n\\t\\t\\t// Convert non-html into a text node\\n\\t\\t\\t} else if ( !rhtml.test( elem ) ) {\\n\\t\\t\\t\\tnodes.push( context.createTextNode( elem ) );\\n\\n\\t\\t\\t// Convert html into DOM nodes\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\\n\\n\\t\\t\\t\\t// Deserialize a standard representation\\n\\t\\t\\t\\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\\n\\t\\t\\t\\twrap = wrapMap[ tag ] || wrapMap._default;\\n\\t\\t\\t\\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\\n\\n\\t\\t\\t\\t// Descend through wrappers to the right content\\n\\t\\t\\t\\tj = wrap[ 0 ];\\n\\t\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\t\\ttmp = tmp.lastChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, tmp.childNodes );\\n\\n\\t\\t\\t\\t// Remember the top-level container\\n\\t\\t\\t\\ttmp = fragment.firstChild;\\n\\n\\t\\t\\t\\t// Ensure the created nodes are orphaned (#12392)\\n\\t\\t\\t\\ttmp.textContent = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Remove wrapper from fragment\\n\\tfragment.textContent = \"\";\\n\\n\\ti = 0;\\n\\twhile ( ( elem = nodes[ i++ ] ) ) {\\n\\n\\t\\t// Skip elements already in the context collection (trac-4087)\\n\\t\\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\\n\\t\\t\\tif ( ignored ) {\\n\\t\\t\\t\\tignored.push( elem );\\n\\t\\t\\t}\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tcontains = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Append to fragment\\n\\t\\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tif ( contains ) {\\n\\t\\t\\tsetGlobalEval( tmp );\\n\\t\\t}\\n\\n\\t\\t// Capture executables\\n\\t\\tif ( scripts ) {\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( elem = tmp[ j++ ] ) ) {\\n\\t\\t\\t\\tif ( rscriptType.test( elem.type || \"\" ) ) {\\n\\t\\t\\t\\t\\tscripts.push( elem );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn fragment;\\n}\\n\\n\\n( function() {\\n\\tvar fragment = document.createDocumentFragment(),\\n\\t\\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\\n\\t\\tinput = document.createElement( \"input\" );\\n\\n\\t// Support: Android 4.0 - 4.3 only\\n\\t// Check state lost if the name is set (#11217)\\n\\t// Support: Windows Web Apps (WWA)\\n\\t// `name` and `type` must use .setAttribute for WWA (#14901)\\n\\tinput.setAttribute( \"type\", \"radio\" );\\n\\tinput.setAttribute( \"checked\", \"checked\" );\\n\\tinput.setAttribute( \"name\", \"t\" );\\n\\n\\tdiv.appendChild( input );\\n\\n\\t// Support: Android <=4.1 only\\n\\t// Older WebKit doesn\\'t clone checked state correctly in fragments\\n\\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\\n\\n\\t// Support: IE <=11 only\\n\\t// Make sure textarea (and checkbox) defaultValue is properly cloned\\n\\tdiv.innerHTML = \"<textarea>x</textarea>\";\\n\\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\\n} )();\\nvar documentElement = document.documentElement;\\n\\n\\n\\nvar\\n\\trkeyEvent = /^key/,\\n\\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\\n\\trtypenamespace = /^([^.]*)(?:\\\\.(.+)|)/;\\n\\nfunction returnTrue() {\\n\\treturn true;\\n}\\n\\nfunction returnFalse() {\\n\\treturn false;\\n}\\n\\n// Support: IE <=9 only\\n// See #13393 for more info\\nfunction safeActiveElement() {\\n\\ttry {\\n\\t\\treturn document.activeElement;\\n\\t} catch ( err ) { }\\n}\\n\\nfunction on( elem, types, selector, data, fn, one ) {\\n\\tvar origFn, type;\\n\\n\\t// Types can be a map of types/handlers\\n\\tif ( typeof types === \"object\" ) {\\n\\n\\t\\t// ( types-Object, selector, data )\\n\\t\\tif ( typeof selector !== \"string\" ) {\\n\\n\\t\\t\\t// ( types-Object, data )\\n\\t\\t\\tdata = data || selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tfor ( type in types ) {\\n\\t\\t\\ton( elem, type, selector, data, types[ type ], one );\\n\\t\\t}\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( data == null && fn == null ) {\\n\\n\\t\\t// ( types, fn )\\n\\t\\tfn = selector;\\n\\t\\tdata = selector = undefined;\\n\\t} else if ( fn == null ) {\\n\\t\\tif ( typeof selector === \"string\" ) {\\n\\n\\t\\t\\t// ( types, selector, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t} else {\\n\\n\\t\\t\\t// ( types, data, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t}\\n\\tif ( fn === false ) {\\n\\t\\tfn = returnFalse;\\n\\t} else if ( !fn ) {\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( one === 1 ) {\\n\\t\\torigFn = fn;\\n\\t\\tfn = function( event ) {\\n\\n\\t\\t\\t// Can use an empty set, since event contains the info\\n\\t\\t\\tjQuery().off( event );\\n\\t\\t\\treturn origFn.apply( this, arguments );\\n\\t\\t};\\n\\n\\t\\t// Use same guid so caller can remove using origFn\\n\\t\\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\\n\\t}\\n\\treturn elem.each( function() {\\n\\t\\tjQuery.event.add( this, types, fn, data, selector );\\n\\t} );\\n}\\n\\n/*\\n * Helper functions for managing events -- not part of the public interface.\\n * Props to Dean Edwards\\' addEvent library for many of the ideas.\\n */\\njQuery.event = {\\n\\n\\tglobal: {},\\n\\n\\tadd: function( elem, types, handler, data, selector ) {\\n\\n\\t\\tvar handleObjIn, eventHandle, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.get( elem );\\n\\n\\t\\t// Don\\'t attach events to noData or text/comment nodes (but allow plain objects)\\n\\t\\tif ( !elemData ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Caller can pass in an object of custom data in lieu of the handler\\n\\t\\tif ( handler.handler ) {\\n\\t\\t\\thandleObjIn = handler;\\n\\t\\t\\thandler = handleObjIn.handler;\\n\\t\\t\\tselector = handleObjIn.selector;\\n\\t\\t}\\n\\n\\t\\t// Ensure that invalid selectors throw exceptions at attach time\\n\\t\\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\\n\\t\\tif ( selector ) {\\n\\t\\t\\tjQuery.find.matchesSelector( documentElement, selector );\\n\\t\\t}\\n\\n\\t\\t// Make sure that the handler has a unique ID, used to find/remove it later\\n\\t\\tif ( !handler.guid ) {\\n\\t\\t\\thandler.guid = jQuery.guid++;\\n\\t\\t}\\n\\n\\t\\t// Init the element\\'s event structure and main handler, if this is the first\\n\\t\\tif ( !( events = elemData.events ) ) {\\n\\t\\t\\tevents = elemData.events = {};\\n\\t\\t}\\n\\t\\tif ( !( eventHandle = elemData.handle ) ) {\\n\\t\\t\\teventHandle = elemData.handle = function( e ) {\\n\\n\\t\\t\\t\\t// Discard the second event of a jQuery.event.trigger() and\\n\\t\\t\\t\\t// when an event is called after a page has unloaded\\n\\t\\t\\t\\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\\n\\t\\t\\t\\t\\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Handle multiple events separated by a space\\n\\t\\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\\n\\n\\t\\t\\t// There *must* be a type, no attaching namespace-only handlers\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If event changes its type, use the special event handlers for the changed type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// If selector defined, determine special event api type, otherwise given type\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\n\\t\\t\\t// Update special based on newly reset type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// handleObj is passed to all event handlers\\n\\t\\t\\thandleObj = jQuery.extend( {\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\torigType: origType,\\n\\t\\t\\t\\tdata: data,\\n\\t\\t\\t\\thandler: handler,\\n\\t\\t\\t\\tguid: handler.guid,\\n\\t\\t\\t\\tselector: selector,\\n\\t\\t\\t\\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\\n\\t\\t\\t\\tnamespace: namespaces.join( \".\" )\\n\\t\\t\\t}, handleObjIn );\\n\\n\\t\\t\\t// Init the event handler queue if we\\'re the first\\n\\t\\t\\tif ( !( handlers = events[ type ] ) ) {\\n\\t\\t\\t\\thandlers = events[ type ] = [];\\n\\t\\t\\t\\thandlers.delegateCount = 0;\\n\\n\\t\\t\\t\\t// Only use addEventListener if the special events handler returns false\\n\\t\\t\\t\\tif ( !special.setup ||\\n\\t\\t\\t\\t\\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\\n\\n\\t\\t\\t\\t\\tif ( elem.addEventListener ) {\\n\\t\\t\\t\\t\\t\\telem.addEventListener( type, eventHandle );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( special.add ) {\\n\\t\\t\\t\\tspecial.add.call( elem, handleObj );\\n\\n\\t\\t\\t\\tif ( !handleObj.handler.guid ) {\\n\\t\\t\\t\\t\\thandleObj.handler.guid = handler.guid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add to the element\\'s handler list, delegates in front\\n\\t\\t\\tif ( selector ) {\\n\\t\\t\\t\\thandlers.splice( handlers.delegateCount++, 0, handleObj );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thandlers.push( handleObj );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Keep track of which events have ever been used, for event optimization\\n\\t\\t\\tjQuery.event.global[ type ] = true;\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// Detach an event or set of events from an element\\n\\tremove: function( elem, types, handler, selector, mappedTypes ) {\\n\\n\\t\\tvar j, origCount, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\\n\\n\\t\\tif ( !elemData || !( events = elemData.events ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Once for each type.namespace in types; type may be omitted\\n\\t\\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\\n\\n\\t\\t\\t// Unbind all events (on this namespace, if provided) for the element\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\t\\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\t\\t\\thandlers = events[ type ] || [];\\n\\t\\t\\ttmp = tmp[ 2 ] &&\\n\\t\\t\\t\\tnew RegExp( \"(^|\\\\\\\\.)\" + namespaces.join( \"\\\\\\\\.(?:.*\\\\\\\\.|)\" ) + \"(\\\\\\\\.|$)\" );\\n\\n\\t\\t\\t// Remove matching events\\n\\t\\t\\torigCount = j = handlers.length;\\n\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\thandleObj = handlers[ j ];\\n\\n\\t\\t\\t\\tif ( ( mappedTypes || origType === handleObj.origType ) &&\\n\\t\\t\\t\\t\\t( !handler || handler.guid === handleObj.guid ) &&\\n\\t\\t\\t\\t\\t( !tmp || tmp.test( handleObj.namespace ) ) &&\\n\\t\\t\\t\\t\\t( !selector || selector === handleObj.selector ||\\n\\t\\t\\t\\t\\t\\tselector === \"**\" && handleObj.selector ) ) {\\n\\t\\t\\t\\t\\thandlers.splice( j, 1 );\\n\\n\\t\\t\\t\\t\\tif ( handleObj.selector ) {\\n\\t\\t\\t\\t\\t\\thandlers.delegateCount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( special.remove ) {\\n\\t\\t\\t\\t\\t\\tspecial.remove.call( elem, handleObj );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove generic event handler if we removed something and no more handlers exist\\n\\t\\t\\t// (avoids potential for endless recursion during removal of special event handlers)\\n\\t\\t\\tif ( origCount && !handlers.length ) {\\n\\t\\t\\t\\tif ( !special.teardown ||\\n\\t\\t\\t\\t\\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\\n\\n\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, elemData.handle );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete events[ type ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove data and the expando if it\\'s no longer used\\n\\t\\tif ( jQuery.isEmptyObject( events ) ) {\\n\\t\\t\\tdataPriv.remove( elem, \"handle events\" );\\n\\t\\t}\\n\\t},\\n\\n\\tdispatch: function( nativeEvent ) {\\n\\n\\t\\t// Make a writable jQuery.Event from the native event object\\n\\t\\tvar event = jQuery.event.fix( nativeEvent );\\n\\n\\t\\tvar i, j, ret, matched, handleObj, handlerQueue,\\n\\t\\t\\targs = new Array( arguments.length ),\\n\\t\\t\\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\\n\\t\\t\\tspecial = jQuery.event.special[ event.type ] || {};\\n\\n\\t\\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\\n\\t\\targs[ 0 ] = event;\\n\\n\\t\\tfor ( i = 1; i < arguments.length; i++ ) {\\n\\t\\t\\targs[ i ] = arguments[ i ];\\n\\t\\t}\\n\\n\\t\\tevent.delegateTarget = this;\\n\\n\\t\\t// Call the preDispatch hook for the mapped type, and let it bail if desired\\n\\t\\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine handlers\\n\\t\\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\\n\\n\\t\\t// Run delegates first; they may want to stop propagation beneath us\\n\\t\\ti = 0;\\n\\t\\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tevent.currentTarget = matched.elem;\\n\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\\n\\t\\t\\t\\t!event.isImmediatePropagationStopped() ) {\\n\\n\\t\\t\\t\\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\\n\\t\\t\\t\\t// a subset or equal to those in the bound event (both can have no namespace).\\n\\t\\t\\t\\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\\n\\n\\t\\t\\t\\t\\tevent.handleObj = handleObj;\\n\\t\\t\\t\\t\\tevent.data = handleObj.data;\\n\\n\\t\\t\\t\\t\\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\\n\\t\\t\\t\\t\\t\\thandleObj.handler ).apply( matched.elem, args );\\n\\n\\t\\t\\t\\t\\tif ( ret !== undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ( event.result = ret ) === false ) {\\n\\t\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\t\\tevent.stopPropagation();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Call the postDispatch hook for the mapped type\\n\\t\\tif ( special.postDispatch ) {\\n\\t\\t\\tspecial.postDispatch.call( this, event );\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\thandlers: function( event, handlers ) {\\n\\t\\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\\n\\t\\t\\thandlerQueue = [],\\n\\t\\t\\tdelegateCount = handlers.delegateCount,\\n\\t\\t\\tcur = event.target;\\n\\n\\t\\t// Find delegate handlers\\n\\t\\tif ( delegateCount &&\\n\\n\\t\\t\\t// Support: IE <=9\\n\\t\\t\\t// Black-hole SVG <use> instance trees (trac-13180)\\n\\t\\t\\tcur.nodeType &&\\n\\n\\t\\t\\t// Support: Firefox <=42\\n\\t\\t\\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\\n\\t\\t\\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\\n\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\\n\\t\\t\\t!( event.type === \"click\" && event.button >= 1 ) ) {\\n\\n\\t\\t\\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\\n\\n\\t\\t\\t\\t// Don\\'t check non-elements (#13208)\\n\\t\\t\\t\\t// Don\\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\\n\\t\\t\\t\\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\\n\\t\\t\\t\\t\\tmatchedHandlers = [];\\n\\t\\t\\t\\t\\tmatchedSelectors = {};\\n\\t\\t\\t\\t\\tfor ( i = 0; i < delegateCount; i++ ) {\\n\\t\\t\\t\\t\\t\\thandleObj = handlers[ i ];\\n\\n\\t\\t\\t\\t\\t\\t// Don\\'t conflict with Object.prototype properties (#13203)\\n\\t\\t\\t\\t\\t\\tsel = handleObj.selector + \" \";\\n\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] === undefined ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedSelectors[ sel ] = handleObj.needsContext ?\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery( sel, this ).index( cur ) > -1 :\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.find( sel, this, null, [ cur ] ).length;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedHandlers.push( handleObj );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( matchedHandlers.length ) {\\n\\t\\t\\t\\t\\t\\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Add the remaining (directly-bound) handlers\\n\\t\\tcur = this;\\n\\t\\tif ( delegateCount < handlers.length ) {\\n\\t\\t\\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\\n\\t\\t}\\n\\n\\t\\treturn handlerQueue;\\n\\t},\\n\\n\\taddProp: function( name, hook ) {\\n\\t\\tObject.defineProperty( jQuery.Event.prototype, name, {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tconfigurable: true,\\n\\n\\t\\t\\tget: jQuery.isFunction( hook ) ?\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn hook( this.originalEvent );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} :\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn this.originalEvent[ name ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\tset: function( value ) {\\n\\t\\t\\t\\tObject.defineProperty( this, name, {\\n\\t\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\t\\tconfigurable: true,\\n\\t\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\t\\tvalue: value\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tfix: function( originalEvent ) {\\n\\t\\treturn originalEvent[ jQuery.expando ] ?\\n\\t\\t\\toriginalEvent :\\n\\t\\t\\tnew jQuery.Event( originalEvent );\\n\\t},\\n\\n\\tspecial: {\\n\\t\\tload: {\\n\\n\\t\\t\\t// Prevent triggered image.load events from bubbling to window.load\\n\\t\\t\\tnoBubble: true\\n\\t\\t},\\n\\t\\tfocus: {\\n\\n\\t\\t\\t// Fire native event if possible so blur/focus sequence is correct\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this !== safeActiveElement() && this.focus ) {\\n\\t\\t\\t\\t\\tthis.focus();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \"focusin\"\\n\\t\\t},\\n\\t\\tblur: {\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this === safeActiveElement() && this.blur ) {\\n\\t\\t\\t\\t\\tthis.blur();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \"focusout\"\\n\\t\\t},\\n\\t\\tclick: {\\n\\n\\t\\t\\t// For checkbox, fire native event so checked state will be right\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\\n\\t\\t\\t\\t\\tthis.click();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\t// For cross-browser consistency, don\\'t fire native .click() on links\\n\\t\\t\\t_default: function( event ) {\\n\\t\\t\\t\\treturn nodeName( event.target, \"a\" );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tbeforeunload: {\\n\\t\\t\\tpostDispatch: function( event ) {\\n\\n\\t\\t\\t\\t// Support: Firefox 20+\\n\\t\\t\\t\\t// Firefox doesn\\'t alert if the returnValue field is not set.\\n\\t\\t\\t\\tif ( event.result !== undefined && event.originalEvent ) {\\n\\t\\t\\t\\t\\tevent.originalEvent.returnValue = event.result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.removeEvent = function( elem, type, handle ) {\\n\\n\\t// This \"if\" is needed for plain objects\\n\\tif ( elem.removeEventListener ) {\\n\\t\\telem.removeEventListener( type, handle );\\n\\t}\\n};\\n\\njQuery.Event = function( src, props ) {\\n\\n\\t// Allow instantiation without the \\'new\\' keyword\\n\\tif ( !( this instanceof jQuery.Event ) ) {\\n\\t\\treturn new jQuery.Event( src, props );\\n\\t}\\n\\n\\t// Event object\\n\\tif ( src && src.type ) {\\n\\t\\tthis.originalEvent = src;\\n\\t\\tthis.type = src.type;\\n\\n\\t\\t// Events bubbling up the document may have been marked as prevented\\n\\t\\t// by a handler lower down the tree; reflect the correct value.\\n\\t\\tthis.isDefaultPrevented = src.defaultPrevented ||\\n\\t\\t\\t\\tsrc.defaultPrevented === undefined &&\\n\\n\\t\\t\\t\\t// Support: Android <=2.3 only\\n\\t\\t\\t\\tsrc.returnValue === false ?\\n\\t\\t\\treturnTrue :\\n\\t\\t\\treturnFalse;\\n\\n\\t\\t// Create target properties\\n\\t\\t// Support: Safari <=6 - 7 only\\n\\t\\t// Target should not be a text node (#504, #13143)\\n\\t\\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\\n\\t\\t\\tsrc.target.parentNode :\\n\\t\\t\\tsrc.target;\\n\\n\\t\\tthis.currentTarget = src.currentTarget;\\n\\t\\tthis.relatedTarget = src.relatedTarget;\\n\\n\\t// Event type\\n\\t} else {\\n\\t\\tthis.type = src;\\n\\t}\\n\\n\\t// Put explicitly provided properties onto the event object\\n\\tif ( props ) {\\n\\t\\tjQuery.extend( this, props );\\n\\t}\\n\\n\\t// Create a timestamp if incoming event doesn\\'t have one\\n\\tthis.timeStamp = src && src.timeStamp || jQuery.now();\\n\\n\\t// Mark it as fixed\\n\\tthis[ jQuery.expando ] = true;\\n};\\n\\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\\njQuery.Event.prototype = {\\n\\tconstructor: jQuery.Event,\\n\\tisDefaultPrevented: returnFalse,\\n\\tisPropagationStopped: returnFalse,\\n\\tisImmediatePropagationStopped: returnFalse,\\n\\tisSimulated: false,\\n\\n\\tpreventDefault: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isDefaultPrevented = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.preventDefault();\\n\\t\\t}\\n\\t},\\n\\tstopPropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isPropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopPropagation();\\n\\t\\t}\\n\\t},\\n\\tstopImmediatePropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isImmediatePropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopImmediatePropagation();\\n\\t\\t}\\n\\n\\t\\tthis.stopPropagation();\\n\\t}\\n};\\n\\n// Includes all common event props including KeyEvent and MouseEvent specific props\\njQuery.each( {\\n\\taltKey: true,\\n\\tbubbles: true,\\n\\tcancelable: true,\\n\\tchangedTouches: true,\\n\\tctrlKey: true,\\n\\tdetail: true,\\n\\teventPhase: true,\\n\\tmetaKey: true,\\n\\tpageX: true,\\n\\tpageY: true,\\n\\tshiftKey: true,\\n\\tview: true,\\n\\t\"char\": true,\\n\\tcharCode: true,\\n\\tkey: true,\\n\\tkeyCode: true,\\n\\tbutton: true,\\n\\tbuttons: true,\\n\\tclientX: true,\\n\\tclientY: true,\\n\\toffsetX: true,\\n\\toffsetY: true,\\n\\tpointerId: true,\\n\\tpointerType: true,\\n\\tscreenX: true,\\n\\tscreenY: true,\\n\\ttargetTouches: true,\\n\\ttoElement: true,\\n\\ttouches: true,\\n\\n\\twhich: function( event ) {\\n\\t\\tvar button = event.button;\\n\\n\\t\\t// Add which for key events\\n\\t\\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\\n\\t\\t\\treturn event.charCode != null ? event.charCode : event.keyCode;\\n\\t\\t}\\n\\n\\t\\t// Add which for click: 1 === left; 2 === middle; 3 === right\\n\\t\\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\\n\\t\\t\\tif ( button & 1 ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 2 ) {\\n\\t\\t\\t\\treturn 3;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 4 ) {\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn event.which;\\n\\t}\\n}, jQuery.event.addProp );\\n\\n// Create mouseenter/leave events using mouseover/out and event-time checks\\n// so that event delegation works in jQuery.\\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\\n//\\n// Support: Safari 7 only\\n// Safari sends mouseenter too often; see:\\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\\n// for the description of the bug (it existed in older Chrome versions as well).\\njQuery.each( {\\n\\tmouseenter: \"mouseover\",\\n\\tmouseleave: \"mouseout\",\\n\\tpointerenter: \"pointerover\",\\n\\tpointerleave: \"pointerout\"\\n}, function( orig, fix ) {\\n\\tjQuery.event.special[ orig ] = {\\n\\t\\tdelegateType: fix,\\n\\t\\tbindType: fix,\\n\\n\\t\\thandle: function( event ) {\\n\\t\\t\\tvar ret,\\n\\t\\t\\t\\ttarget = this,\\n\\t\\t\\t\\trelated = event.relatedTarget,\\n\\t\\t\\t\\thandleObj = event.handleObj;\\n\\n\\t\\t\\t// For mouseenter/leave call the handler if related is outside the target.\\n\\t\\t\\t// NB: No relatedTarget if the mouse left/entered the browser window\\n\\t\\t\\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\\n\\t\\t\\t\\tevent.type = handleObj.origType;\\n\\t\\t\\t\\tret = handleObj.handler.apply( this, arguments );\\n\\t\\t\\t\\tevent.type = fix;\\n\\t\\t\\t}\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ton: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn );\\n\\t},\\n\\tone: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn, 1 );\\n\\t},\\n\\toff: function( types, selector, fn ) {\\n\\t\\tvar handleObj, type;\\n\\t\\tif ( types && types.preventDefault && types.handleObj ) {\\n\\n\\t\\t\\t// ( event )  dispatched jQuery.Event\\n\\t\\t\\thandleObj = types.handleObj;\\n\\t\\t\\tjQuery( types.delegateTarget ).off(\\n\\t\\t\\t\\thandleObj.namespace ?\\n\\t\\t\\t\\t\\thandleObj.origType + \".\" + handleObj.namespace :\\n\\t\\t\\t\\t\\thandleObj.origType,\\n\\t\\t\\t\\thandleObj.selector,\\n\\t\\t\\t\\thandleObj.handler\\n\\t\\t\\t);\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( typeof types === \"object\" ) {\\n\\n\\t\\t\\t// ( types-object [, selector] )\\n\\t\\t\\tfor ( type in types ) {\\n\\t\\t\\t\\tthis.off( type, selector, types[ type ] );\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( selector === false || typeof selector === \"function\" ) {\\n\\n\\t\\t\\t// ( types [, fn] )\\n\\t\\t\\tfn = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tif ( fn === false ) {\\n\\t\\t\\tfn = returnFalse;\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.remove( this, types, fn, selector );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\nvar\\n\\n\\t/* eslint-disable max-len */\\n\\n\\t// See https://github.com/eslint/eslint/issues/3229\\n\\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[^>]*)\\\\/>/gi,\\n\\n\\t/* eslint-enable */\\n\\n\\t// Support: IE <=10 - 11, Edge 12 - 13\\n\\t// In IE/Edge using regex groups here causes severe slowdowns.\\n\\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\\n\\trnoInnerhtml = /<script|<style|<link/i,\\n\\n\\t// checked=\"checked\" or checked\\n\\trchecked = /checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,\\n\\trscriptTypeMasked = /^true\\\\/(.*)/,\\n\\trcleanScript = /^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g;\\n\\n// Prefer a tbody over its parent table for containing new rows\\nfunction manipulationTarget( elem, content ) {\\n\\tif ( nodeName( elem, \"table\" ) &&\\n\\t\\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\\n\\n\\t\\treturn jQuery( \">tbody\", elem )[ 0 ] || elem;\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\n// Replace/restore the type attribute of script elements for safe DOM manipulation\\nfunction disableScript( elem ) {\\n\\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\\n\\treturn elem;\\n}\\nfunction restoreScript( elem ) {\\n\\tvar match = rscriptTypeMasked.exec( elem.type );\\n\\n\\tif ( match ) {\\n\\t\\telem.type = match[ 1 ];\\n\\t} else {\\n\\t\\telem.removeAttribute( \"type\" );\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\nfunction cloneCopyEvent( src, dest ) {\\n\\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\\n\\n\\tif ( dest.nodeType !== 1 ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// 1. Copy private data: events, handlers, etc.\\n\\tif ( dataPriv.hasData( src ) ) {\\n\\t\\tpdataOld = dataPriv.access( src );\\n\\t\\tpdataCur = dataPriv.set( dest, pdataOld );\\n\\t\\tevents = pdataOld.events;\\n\\n\\t\\tif ( events ) {\\n\\t\\t\\tdelete pdataCur.handle;\\n\\t\\t\\tpdataCur.events = {};\\n\\n\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tjQuery.event.add( dest, type, events[ type ][ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// 2. Copy user data\\n\\tif ( dataUser.hasData( src ) ) {\\n\\t\\tudataOld = dataUser.access( src );\\n\\t\\tudataCur = jQuery.extend( {}, udataOld );\\n\\n\\t\\tdataUser.set( dest, udataCur );\\n\\t}\\n}\\n\\n// Fix IE bugs, see support tests\\nfunction fixInput( src, dest ) {\\n\\tvar nodeName = dest.nodeName.toLowerCase();\\n\\n\\t// Fails to persist the checked state of a cloned checkbox or radio button.\\n\\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\\n\\t\\tdest.checked = src.checked;\\n\\n\\t// Fails to return the selected option to the default selected state when cloning options\\n\\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\\n\\t\\tdest.defaultValue = src.defaultValue;\\n\\t}\\n}\\n\\nfunction domManip( collection, args, callback, ignored ) {\\n\\n\\t// Flatten any nested arrays\\n\\targs = concat.apply( [], args );\\n\\n\\tvar fragment, first, scripts, hasScripts, node, doc,\\n\\t\\ti = 0,\\n\\t\\tl = collection.length,\\n\\t\\tiNoClone = l - 1,\\n\\t\\tvalue = args[ 0 ],\\n\\t\\tisFunction = jQuery.isFunction( value );\\n\\n\\t// We can\\'t cloneNode fragments that contain checked, in WebKit\\n\\tif ( isFunction ||\\n\\t\\t\\t( l > 1 && typeof value === \"string\" &&\\n\\t\\t\\t\\t!support.checkClone && rchecked.test( value ) ) ) {\\n\\t\\treturn collection.each( function( index ) {\\n\\t\\t\\tvar self = collection.eq( index );\\n\\t\\t\\tif ( isFunction ) {\\n\\t\\t\\t\\targs[ 0 ] = value.call( this, index, self.html() );\\n\\t\\t\\t}\\n\\t\\t\\tdomManip( self, args, callback, ignored );\\n\\t\\t} );\\n\\t}\\n\\n\\tif ( l ) {\\n\\t\\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\\n\\t\\tfirst = fragment.firstChild;\\n\\n\\t\\tif ( fragment.childNodes.length === 1 ) {\\n\\t\\t\\tfragment = first;\\n\\t\\t}\\n\\n\\t\\t// Require either new content or an interest in ignored elements to invoke the callback\\n\\t\\tif ( first || ignored ) {\\n\\t\\t\\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\\n\\t\\t\\thasScripts = scripts.length;\\n\\n\\t\\t\\t// Use the original fragment for the last item\\n\\t\\t\\t// instead of the first because it can end up\\n\\t\\t\\t// being emptied incorrectly in certain situations (#8070).\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tnode = fragment;\\n\\n\\t\\t\\t\\tif ( i !== iNoClone ) {\\n\\t\\t\\t\\t\\tnode = jQuery.clone( node, true, true );\\n\\n\\t\\t\\t\\t\\t// Keep references to cloned scripts for later restoration\\n\\t\\t\\t\\t\\tif ( hasScripts ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\t\\t\\tjQuery.merge( scripts, getAll( node, \"script\" ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcallback.call( collection[ i ], node, i );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasScripts ) {\\n\\t\\t\\t\\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\\n\\n\\t\\t\\t\\t// Reenable scripts\\n\\t\\t\\t\\tjQuery.map( scripts, restoreScript );\\n\\n\\t\\t\\t\\t// Evaluate executable scripts on first document insertion\\n\\t\\t\\t\\tfor ( i = 0; i < hasScripts; i++ ) {\\n\\t\\t\\t\\t\\tnode = scripts[ i ];\\n\\t\\t\\t\\t\\tif ( rscriptType.test( node.type || \"\" ) &&\\n\\t\\t\\t\\t\\t\\t!dataPriv.access( node, \"globalEval\" ) &&\\n\\t\\t\\t\\t\\t\\tjQuery.contains( doc, node ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( node.src ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Optional AJAX dependency, but won\\'t run scripts if not present\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery._evalUrl ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery._evalUrl( node.src );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn collection;\\n}\\n\\nfunction remove( elem, selector, keepData ) {\\n\\tvar node,\\n\\t\\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\\n\\t\\ti = 0;\\n\\n\\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\\n\\t\\tif ( !keepData && node.nodeType === 1 ) {\\n\\t\\t\\tjQuery.cleanData( getAll( node ) );\\n\\t\\t}\\n\\n\\t\\tif ( node.parentNode ) {\\n\\t\\t\\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\\n\\t\\t\\t\\tsetGlobalEval( getAll( node, \"script\" ) );\\n\\t\\t\\t}\\n\\t\\t\\tnode.parentNode.removeChild( node );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\njQuery.extend( {\\n\\thtmlPrefilter: function( html ) {\\n\\t\\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\\n\\t},\\n\\n\\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\\n\\t\\tvar i, l, srcElements, destElements,\\n\\t\\t\\tclone = elem.cloneNode( true ),\\n\\t\\t\\tinPage = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Fix IE cloning issues\\n\\t\\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\\n\\t\\t\\t\\t!jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\\n\\t\\t\\tdestElements = getAll( clone );\\n\\t\\t\\tsrcElements = getAll( elem );\\n\\n\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\tfixInput( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Copy the events from the original to the clone\\n\\t\\tif ( dataAndEvents ) {\\n\\t\\t\\tif ( deepDataAndEvents ) {\\n\\t\\t\\t\\tsrcElements = srcElements || getAll( elem );\\n\\t\\t\\t\\tdestElements = destElements || getAll( clone );\\n\\n\\t\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcloneCopyEvent( elem, clone );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tdestElements = getAll( clone, \"script\" );\\n\\t\\tif ( destElements.length > 0 ) {\\n\\t\\t\\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\\n\\t\\t}\\n\\n\\t\\t// Return the cloned set\\n\\t\\treturn clone;\\n\\t},\\n\\n\\tcleanData: function( elems ) {\\n\\t\\tvar data, elem, type,\\n\\t\\t\\tspecial = jQuery.event.special,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\\n\\t\\t\\tif ( acceptData( elem ) ) {\\n\\t\\t\\t\\tif ( ( data = elem[ dataPriv.expando ] ) ) {\\n\\t\\t\\t\\t\\tif ( data.events ) {\\n\\t\\t\\t\\t\\t\\tfor ( type in data.events ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( special[ type ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.event.remove( elem, type );\\n\\n\\t\\t\\t\\t\\t\\t\\t// This is a shortcut to avoid jQuery.event.remove\\'s overhead\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, data.handle );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataPriv.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( elem[ dataUser.expando ] ) {\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataUser.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdetach: function( selector ) {\\n\\t\\treturn remove( this, selector, true );\\n\\t},\\n\\n\\tremove: function( selector ) {\\n\\t\\treturn remove( this, selector );\\n\\t},\\n\\n\\ttext: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\treturn value === undefined ?\\n\\t\\t\\t\\tjQuery.text( this ) :\\n\\t\\t\\t\\tthis.empty().each( function() {\\n\\t\\t\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tthis.textContent = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\tappend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.appendChild( elem );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tprepend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.insertBefore( elem, target.firstChild );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tbefore: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tafter: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this.nextSibling );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tempty: function() {\\n\\t\\tvar elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\\n\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Prevent memory leaks\\n\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\n\\t\\t\\t\\t// Remove any remaining nodes\\n\\t\\t\\t\\telem.textContent = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tclone: function( dataAndEvents, deepDataAndEvents ) {\\n\\t\\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\\n\\t\\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\\n\\n\\t\\treturn this.map( function() {\\n\\t\\t\\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\\n\\t\\t} );\\n\\t},\\n\\n\\thtml: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar elem = this[ 0 ] || {},\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\tl = this.length;\\n\\n\\t\\t\\tif ( value === undefined && elem.nodeType === 1 ) {\\n\\t\\t\\t\\treturn elem.innerHTML;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// See if we can take a shortcut and just use innerHTML\\n\\t\\t\\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\\n\\t\\t\\t\\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\\n\\n\\t\\t\\t\\tvalue = jQuery.htmlPrefilter( value );\\n\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\telem = this[ i ] || {};\\n\\n\\t\\t\\t\\t\\t\\t// Remove element nodes and prevent memory leaks\\n\\t\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\t\\t\\t\\t\\t\\t\\telem.innerHTML = value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem = 0;\\n\\n\\t\\t\\t\\t// If using innerHTML throws an exception, use the fallback method\\n\\t\\t\\t\\t} catch ( e ) {}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\tthis.empty().append( value );\\n\\t\\t\\t}\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\treplaceWith: function() {\\n\\t\\tvar ignored = [];\\n\\n\\t\\t// Make the changes, replacing each non-ignored context element with the new content\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tvar parent = this.parentNode;\\n\\n\\t\\t\\tif ( jQuery.inArray( this, ignored ) < 0 ) {\\n\\t\\t\\t\\tjQuery.cleanData( getAll( this ) );\\n\\t\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\t\\tparent.replaceChild( elem, this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Force callback invocation\\n\\t\\t}, ignored );\\n\\t}\\n} );\\n\\njQuery.each( {\\n\\tappendTo: \"append\",\\n\\tprependTo: \"prepend\",\\n\\tinsertBefore: \"before\",\\n\\tinsertAfter: \"after\",\\n\\treplaceAll: \"replaceWith\"\\n}, function( name, original ) {\\n\\tjQuery.fn[ name ] = function( selector ) {\\n\\t\\tvar elems,\\n\\t\\t\\tret = [],\\n\\t\\t\\tinsert = jQuery( selector ),\\n\\t\\t\\tlast = insert.length - 1,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; i <= last; i++ ) {\\n\\t\\t\\telems = i === last ? this : this.clone( true );\\n\\t\\t\\tjQuery( insert[ i ] )[ original ]( elems );\\n\\n\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\tpush.apply( ret, elems.get() );\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( ret );\\n\\t};\\n} );\\nvar rmargin = ( /^margin/ );\\n\\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\\n\\nvar getStyles = function( elem ) {\\n\\n\\t\\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\\n\\t\\t// IE throws on elements created in popups\\n\\t\\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\\n\\t\\tvar view = elem.ownerDocument.defaultView;\\n\\n\\t\\tif ( !view || !view.opener ) {\\n\\t\\t\\tview = window;\\n\\t\\t}\\n\\n\\t\\treturn view.getComputedStyle( elem );\\n\\t};\\n\\n\\n\\n( function() {\\n\\n\\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\\n\\t// so they\\'re executed at the same time to save the second computation.\\n\\tfunction computeStyleTests() {\\n\\n\\t\\t// This is a singleton, we need to execute it only once\\n\\t\\tif ( !div ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tdiv.style.cssText =\\n\\t\\t\\t\"box-sizing:border-box;\" +\\n\\t\\t\\t\"position:relative;display:block;\" +\\n\\t\\t\\t\"margin:auto;border:1px;padding:1px;\" +\\n\\t\\t\\t\"top:1%;width:50%\";\\n\\t\\tdiv.innerHTML = \"\";\\n\\t\\tdocumentElement.appendChild( container );\\n\\n\\t\\tvar divStyle = window.getComputedStyle( div );\\n\\t\\tpixelPositionVal = divStyle.top !== \"1%\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\\n\\t\\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\\n\\t\\tboxSizingReliableVal = divStyle.width === \"4px\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only\\n\\t\\t// Some styles come back with percentage values, even though they shouldn\\'t\\n\\t\\tdiv.style.marginRight = \"50%\";\\n\\t\\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\\n\\n\\t\\tdocumentElement.removeChild( container );\\n\\n\\t\\t// Nullify the div so it wouldn\\'t be stored in the memory and\\n\\t\\t// it will also be a sign that checks already performed\\n\\t\\tdiv = null;\\n\\t}\\n\\n\\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\\n\\t\\tcontainer = document.createElement( \"div\" ),\\n\\t\\tdiv = document.createElement( \"div\" );\\n\\n\\t// Finish early in limited (non-browser) environments\\n\\tif ( !div.style ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Style of cloned element affects source element cloned (#8908)\\n\\tdiv.style.backgroundClip = \"content-box\";\\n\\tdiv.cloneNode( true ).style.backgroundClip = \"\";\\n\\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\\n\\n\\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\\n\\t\\t\"padding:0;margin-top:1px;position:absolute\";\\n\\tcontainer.appendChild( div );\\n\\n\\tjQuery.extend( support, {\\n\\t\\tpixelPosition: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelPositionVal;\\n\\t\\t},\\n\\t\\tboxSizingReliable: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn boxSizingReliableVal;\\n\\t\\t},\\n\\t\\tpixelMarginRight: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelMarginRightVal;\\n\\t\\t},\\n\\t\\treliableMarginLeft: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn reliableMarginLeftVal;\\n\\t\\t}\\n\\t} );\\n} )();\\n\\n\\nfunction curCSS( elem, name, computed ) {\\n\\tvar width, minWidth, maxWidth, ret,\\n\\n\\t\\t// Support: Firefox 51+\\n\\t\\t// Retrieving style before computed somehow\\n\\t\\t// fixes an issue with getting wrong values\\n\\t\\t// on detached elements\\n\\t\\tstyle = elem.style;\\n\\n\\tcomputed = computed || getStyles( elem );\\n\\n\\t// getPropertyValue is needed for:\\n\\t//   .css(\\'filter\\') (IE 9 only, #12537)\\n\\t//   .css(\\'--customProperty) (#3144)\\n\\tif ( computed ) {\\n\\t\\tret = computed.getPropertyValue( name ) || computed[ name ];\\n\\n\\t\\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\\n\\t\\t\\tret = jQuery.style( elem, name );\\n\\t\\t}\\n\\n\\t\\t// A tribute to the \"awesome hack by Dean Edwards\"\\n\\t\\t// Android Browser returns percentage for some values,\\n\\t\\t// but width seems to be reliably pixels.\\n\\t\\t// This is against the CSSOM draft spec:\\n\\t\\t// https://drafts.csswg.org/cssom/#resolved-values\\n\\t\\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\\n\\n\\t\\t\\t// Remember the original values\\n\\t\\t\\twidth = style.width;\\n\\t\\t\\tminWidth = style.minWidth;\\n\\t\\t\\tmaxWidth = style.maxWidth;\\n\\n\\t\\t\\t// Put in the new values to get a computed value out\\n\\t\\t\\tstyle.minWidth = style.maxWidth = style.width = ret;\\n\\t\\t\\tret = computed.width;\\n\\n\\t\\t\\t// Revert the changed values\\n\\t\\t\\tstyle.width = width;\\n\\t\\t\\tstyle.minWidth = minWidth;\\n\\t\\t\\tstyle.maxWidth = maxWidth;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret !== undefined ?\\n\\n\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t// IE returns zIndex value as an integer.\\n\\t\\tret + \"\" :\\n\\t\\tret;\\n}\\n\\n\\nfunction addGetHookIf( conditionFn, hookFn ) {\\n\\n\\t// Define the hook, we\\'ll check on the first run if it\\'s really needed.\\n\\treturn {\\n\\t\\tget: function() {\\n\\t\\t\\tif ( conditionFn() ) {\\n\\n\\t\\t\\t\\t// Hook not needed (or it\\'s not possible to use it due\\n\\t\\t\\t\\t// to missing dependency), remove it.\\n\\t\\t\\t\\tdelete this.get;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Hook needed; redefine it so that the support test is not executed again.\\n\\t\\t\\treturn ( this.get = hookFn ).apply( this, arguments );\\n\\t\\t}\\n\\t};\\n}\\n\\n\\nvar\\n\\n\\t// Swappable if display is none or starts with table\\n\\t// except \"table\", \"table-cell\", or \"table-caption\"\\n\\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\\n\\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\\n\\trcustomProp = /^--/,\\n\\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\\n\\tcssNormalTransform = {\\n\\t\\tletterSpacing: \"0\",\\n\\t\\tfontWeight: \"400\"\\n\\t},\\n\\n\\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\\n\\temptyStyle = document.createElement( \"div\" ).style;\\n\\n// Return a css property mapped to a potentially vendor prefixed property\\nfunction vendorPropName( name ) {\\n\\n\\t// Shortcut for names that are not vendor prefixed\\n\\tif ( name in emptyStyle ) {\\n\\t\\treturn name;\\n\\t}\\n\\n\\t// Check for vendor prefixed names\\n\\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\\n\\t\\ti = cssPrefixes.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tname = cssPrefixes[ i ] + capName;\\n\\t\\tif ( name in emptyStyle ) {\\n\\t\\t\\treturn name;\\n\\t\\t}\\n\\t}\\n}\\n\\n// Return a property mapped along what jQuery.cssProps suggests or to\\n// a vendor prefixed property.\\nfunction finalPropName( name ) {\\n\\tvar ret = jQuery.cssProps[ name ];\\n\\tif ( !ret ) {\\n\\t\\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\\n\\t}\\n\\treturn ret;\\n}\\n\\nfunction setPositiveNumber( elem, value, subtract ) {\\n\\n\\t// Any relative (+/-) values have already been\\n\\t// normalized at this point\\n\\tvar matches = rcssNum.exec( value );\\n\\treturn matches ?\\n\\n\\t\\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\\n\\t\\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\\n\\t\\tvalue;\\n}\\n\\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\\n\\tvar i,\\n\\t\\tval = 0;\\n\\n\\t// If we already have the right measurement, avoid augmentation\\n\\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\\n\\t\\ti = 4;\\n\\n\\t// Otherwise initialize for horizontal or vertical properties\\n\\t} else {\\n\\t\\ti = name === \"width\" ? 1 : 0;\\n\\t}\\n\\n\\tfor ( ; i < 4; i += 2 ) {\\n\\n\\t\\t// Both box models exclude margin, so add it if we want it\\n\\t\\tif ( extra === \"margin\" ) {\\n\\t\\t\\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\\n\\t\\t}\\n\\n\\t\\tif ( isBorderBox ) {\\n\\n\\t\\t\\t// border-box includes padding, so remove it if we want content\\n\\t\\t\\tif ( extra === \"content\" ) {\\n\\t\\t\\t\\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// At this point, extra isn\\'t border nor margin, so remove border\\n\\t\\t\\tif ( extra !== \"margin\" ) {\\n\\t\\t\\t\\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\n\\t\\t\\t// At this point, extra isn\\'t content, so add padding\\n\\t\\t\\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\\n\\n\\t\\t\\t// At this point, extra isn\\'t content nor padding, so add border\\n\\t\\t\\tif ( extra !== \"padding\" ) {\\n\\t\\t\\t\\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nfunction getWidthOrHeight( elem, name, extra ) {\\n\\n\\t// Start with computed style\\n\\tvar valueIsBorderBox,\\n\\t\\tstyles = getStyles( elem ),\\n\\t\\tval = curCSS( elem, name, styles ),\\n\\t\\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\\n\\n\\t// Computed unit is not pixels. Stop here and return.\\n\\tif ( rnumnonpx.test( val ) ) {\\n\\t\\treturn val;\\n\\t}\\n\\n\\t// Check for style in case a browser which returns unreliable values\\n\\t// for getComputedStyle silently falls back to the reliable elem.style\\n\\tvalueIsBorderBox = isBorderBox &&\\n\\t\\t( support.boxSizingReliable() || val === elem.style[ name ] );\\n\\n\\t// Fall back to offsetWidth/Height when value is \"auto\"\\n\\t// This happens for inline elements with no explicit setting (gh-3571)\\n\\tif ( val === \"auto\" ) {\\n\\t\\tval = elem[ \"offset\" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];\\n\\t}\\n\\n\\t// Normalize \"\", auto, and prepare for extra\\n\\tval = parseFloat( val ) || 0;\\n\\n\\t// Use the active box-sizing model to add/subtract irrelevant styles\\n\\treturn ( val +\\n\\t\\taugmentWidthOrHeight(\\n\\t\\t\\telem,\\n\\t\\t\\tname,\\n\\t\\t\\textra || ( isBorderBox ? \"border\" : \"content\" ),\\n\\t\\t\\tvalueIsBorderBox,\\n\\t\\t\\tstyles\\n\\t\\t)\\n\\t) + \"px\";\\n}\\n\\njQuery.extend( {\\n\\n\\t// Add in style property hooks for overriding the default\\n\\t// behavior of getting and setting a style property\\n\\tcssHooks: {\\n\\t\\topacity: {\\n\\t\\t\\tget: function( elem, computed ) {\\n\\t\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t\\t// We should always get a number back from opacity\\n\\t\\t\\t\\t\\tvar ret = curCSS( elem, \"opacity\" );\\n\\t\\t\\t\\t\\treturn ret === \"\" ? \"1\" : ret;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// Don\\'t automatically add \"px\" to these possibly-unitless properties\\n\\tcssNumber: {\\n\\t\\t\"animationIterationCount\": true,\\n\\t\\t\"columnCount\": true,\\n\\t\\t\"fillOpacity\": true,\\n\\t\\t\"flexGrow\": true,\\n\\t\\t\"flexShrink\": true,\\n\\t\\t\"fontWeight\": true,\\n\\t\\t\"lineHeight\": true,\\n\\t\\t\"opacity\": true,\\n\\t\\t\"order\": true,\\n\\t\\t\"orphans\": true,\\n\\t\\t\"widows\": true,\\n\\t\\t\"zIndex\": true,\\n\\t\\t\"zoom\": true\\n\\t},\\n\\n\\t// Add in properties whose names you wish to fix before\\n\\t// setting or getting the value\\n\\tcssProps: {\\n\\t\\t\"float\": \"cssFloat\"\\n\\t},\\n\\n\\t// Get and set the style property on a DOM Node\\n\\tstyle: function( elem, name, value, extra ) {\\n\\n\\t\\t// Don\\'t set styles on text and comment nodes\\n\\t\\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Make sure that we\\'re working with the right name\\n\\t\\tvar ret, type, hooks,\\n\\t\\t\\torigName = jQuery.camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name ),\\n\\t\\t\\tstyle = elem.style;\\n\\n\\t\\t// Make sure that we\\'re working with the right name. We don\\'t\\n\\t\\t// want to query the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Gets hook for the prefixed version, then unprefixed version\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// Check if we\\'re setting a value\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\ttype = typeof value;\\n\\n\\t\\t\\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\\n\\t\\t\\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\\n\\t\\t\\t\\tvalue = adjustCSS( elem, name, ret );\\n\\n\\t\\t\\t\\t// Fixes bug #9237\\n\\t\\t\\t\\ttype = \"number\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make sure that null and NaN values aren\\'t set (#7116)\\n\\t\\t\\tif ( value == null || value !== value ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a number was passed in, add the unit (except for certain CSS properties)\\n\\t\\t\\tif ( type === \"number\" ) {\\n\\t\\t\\t\\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// background-* props affect original clone\\'s values\\n\\t\\t\\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\\n\\t\\t\\t\\tstyle[ name ] = \"inherit\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a hook was provided, use that value, otherwise just set the specified value\\n\\t\\t\\tif ( !hooks || !( \"set\" in hooks ) ||\\n\\t\\t\\t\\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\tif ( isCustomProp ) {\\n\\t\\t\\t\\t\\tstyle.setProperty( name, value );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstyle[ name ] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// If a hook was provided get the non-computed value from there\\n\\t\\t\\tif ( hooks && \"get\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Otherwise just get the value from the style object\\n\\t\\t\\treturn style[ name ];\\n\\t\\t}\\n\\t},\\n\\n\\tcss: function( elem, name, extra, styles ) {\\n\\t\\tvar val, num, hooks,\\n\\t\\t\\torigName = jQuery.camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name );\\n\\n\\t\\t// Make sure that we\\'re working with the right name. We don\\'t\\n\\t\\t// want to modify the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Try prefixed name followed by the unprefixed name\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// If a hook was provided get the computed value from there\\n\\t\\tif ( hooks && \"get\" in hooks ) {\\n\\t\\t\\tval = hooks.get( elem, true, extra );\\n\\t\\t}\\n\\n\\t\\t// Otherwise, if a way to get the computed value exists, use that\\n\\t\\tif ( val === undefined ) {\\n\\t\\t\\tval = curCSS( elem, name, styles );\\n\\t\\t}\\n\\n\\t\\t// Convert \"normal\" to computed value\\n\\t\\tif ( val === \"normal\" && name in cssNormalTransform ) {\\n\\t\\t\\tval = cssNormalTransform[ name ];\\n\\t\\t}\\n\\n\\t\\t// Make numeric if forced or a qualifier was provided and val looks numeric\\n\\t\\tif ( extra === \"\" || extra ) {\\n\\t\\t\\tnum = parseFloat( val );\\n\\t\\t\\treturn extra === true || isFinite( num ) ? num || 0 : val;\\n\\t\\t}\\n\\n\\t\\treturn val;\\n\\t}\\n} );\\n\\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\\n\\tjQuery.cssHooks[ name ] = {\\n\\t\\tget: function( elem, computed, extra ) {\\n\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t// Certain elements can have dimension info if we invisibly show them\\n\\t\\t\\t\\t// but it must have a current display style that would benefit\\n\\t\\t\\t\\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\\n\\n\\t\\t\\t\\t\\t// Support: Safari 8+\\n\\t\\t\\t\\t\\t// Table columns in Safari have non-zero offsetWidth & zero\\n\\t\\t\\t\\t\\t// getBoundingClientRect().width unless display is changed.\\n\\t\\t\\t\\t\\t// Support: IE <=11 only\\n\\t\\t\\t\\t\\t// Running getBoundingClientRect on a disconnected node\\n\\t\\t\\t\\t\\t// in IE throws an error.\\n\\t\\t\\t\\t\\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\\n\\t\\t\\t\\t\\t\\tswap( elem, cssShow, function() {\\n\\t\\t\\t\\t\\t\\t\\treturn getWidthOrHeight( elem, name, extra );\\n\\t\\t\\t\\t\\t\\t} ) :\\n\\t\\t\\t\\t\\t\\tgetWidthOrHeight( elem, name, extra );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tset: function( elem, value, extra ) {\\n\\t\\t\\tvar matches,\\n\\t\\t\\t\\tstyles = extra && getStyles( elem ),\\n\\t\\t\\t\\tsubtract = extra && augmentWidthOrHeight(\\n\\t\\t\\t\\t\\telem,\\n\\t\\t\\t\\t\\tname,\\n\\t\\t\\t\\t\\textra,\\n\\t\\t\\t\\t\\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\\n\\t\\t\\t\\t\\tstyles\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t// Convert to pixels if value adjustment is needed\\n\\t\\t\\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\\n\\t\\t\\t\\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\\n\\n\\t\\t\\t\\telem.style[ name ] = value;\\n\\t\\t\\t\\tvalue = jQuery.css( elem, name );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn setPositiveNumber( elem, value, subtract );\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\\n\\tfunction( elem, computed ) {\\n\\t\\tif ( computed ) {\\n\\t\\t\\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\\n\\t\\t\\t\\telem.getBoundingClientRect().left -\\n\\t\\t\\t\\t\\tswap( elem, { marginLeft: 0 }, function() {\\n\\t\\t\\t\\t\\t\\treturn elem.getBoundingClientRect().left;\\n\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t) + \"px\";\\n\\t\\t}\\n\\t}\\n);\\n\\n// These hooks are used by animate to expand properties\\njQuery.each( {\\n\\tmargin: \"\",\\n\\tpadding: \"\",\\n\\tborder: \"Width\"\\n}, function( prefix, suffix ) {\\n\\tjQuery.cssHooks[ prefix + suffix ] = {\\n\\t\\texpand: function( value ) {\\n\\t\\t\\tvar i = 0,\\n\\t\\t\\t\\texpanded = {},\\n\\n\\t\\t\\t\\t// Assumes a single number if not a string\\n\\t\\t\\t\\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\\n\\n\\t\\t\\tfor ( ; i < 4; i++ ) {\\n\\t\\t\\t\\texpanded[ prefix + cssExpand[ i ] + suffix ] =\\n\\t\\t\\t\\t\\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn expanded;\\n\\t\\t}\\n\\t};\\n\\n\\tif ( !rmargin.test( prefix ) ) {\\n\\t\\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tcss: function( name, value ) {\\n\\t\\treturn access( this, function( elem, name, value ) {\\n\\t\\t\\tvar styles, len,\\n\\t\\t\\t\\tmap = {},\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tif ( Array.isArray( name ) ) {\\n\\t\\t\\t\\tstyles = getStyles( elem );\\n\\t\\t\\t\\tlen = name.length;\\n\\n\\t\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\t\\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn map;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value !== undefined ?\\n\\t\\t\\t\\tjQuery.style( elem, name, value ) :\\n\\t\\t\\t\\tjQuery.css( elem, name );\\n\\t\\t}, name, value, arguments.length > 1 );\\n\\t}\\n} );\\n\\n\\nfunction Tween( elem, options, prop, end, easing ) {\\n\\treturn new Tween.prototype.init( elem, options, prop, end, easing );\\n}\\njQuery.Tween = Tween;\\n\\nTween.prototype = {\\n\\tconstructor: Tween,\\n\\tinit: function( elem, options, prop, end, easing, unit ) {\\n\\t\\tthis.elem = elem;\\n\\t\\tthis.prop = prop;\\n\\t\\tthis.easing = easing || jQuery.easing._default;\\n\\t\\tthis.options = options;\\n\\t\\tthis.start = this.now = this.cur();\\n\\t\\tthis.end = end;\\n\\t\\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\\n\\t},\\n\\tcur: function() {\\n\\t\\tvar hooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\treturn hooks && hooks.get ?\\n\\t\\t\\thooks.get( this ) :\\n\\t\\t\\tTween.propHooks._default.get( this );\\n\\t},\\n\\trun: function( percent ) {\\n\\t\\tvar eased,\\n\\t\\t\\thooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\tif ( this.options.duration ) {\\n\\t\\t\\tthis.pos = eased = jQuery.easing[ this.easing ](\\n\\t\\t\\t\\tpercent, this.options.duration * percent, 0, 1, this.options.duration\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tthis.pos = eased = percent;\\n\\t\\t}\\n\\t\\tthis.now = ( this.end - this.start ) * eased + this.start;\\n\\n\\t\\tif ( this.options.step ) {\\n\\t\\t\\tthis.options.step.call( this.elem, this.now, this );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && hooks.set ) {\\n\\t\\t\\thooks.set( this );\\n\\t\\t} else {\\n\\t\\t\\tTween.propHooks._default.set( this );\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n};\\n\\nTween.prototype.init.prototype = Tween.prototype;\\n\\nTween.propHooks = {\\n\\t_default: {\\n\\t\\tget: function( tween ) {\\n\\t\\t\\tvar result;\\n\\n\\t\\t\\t// Use a property on the element directly when it is not a DOM element,\\n\\t\\t\\t// or when there is no matching style property that exists.\\n\\t\\t\\tif ( tween.elem.nodeType !== 1 ||\\n\\t\\t\\t\\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\\n\\t\\t\\t\\treturn tween.elem[ tween.prop ];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Passing an empty string as a 3rd parameter to .css will automatically\\n\\t\\t\\t// attempt a parseFloat and fallback to a string if the parse fails.\\n\\t\\t\\t// Simple values such as \"10px\" are parsed to Float;\\n\\t\\t\\t// complex values such as \"rotate(1rad)\" are returned as-is.\\n\\t\\t\\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\\n\\n\\t\\t\\t// Empty strings, null, undefined and \"auto\" are converted to 0.\\n\\t\\t\\treturn !result || result === \"auto\" ? 0 : result;\\n\\t\\t},\\n\\t\\tset: function( tween ) {\\n\\n\\t\\t\\t// Use step hook for back compat.\\n\\t\\t\\t// Use cssHook if its there.\\n\\t\\t\\t// Use .style if available and use plain properties where available.\\n\\t\\t\\tif ( jQuery.fx.step[ tween.prop ] ) {\\n\\t\\t\\t\\tjQuery.fx.step[ tween.prop ]( tween );\\n\\t\\t\\t} else if ( tween.elem.nodeType === 1 &&\\n\\t\\t\\t\\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\\n\\t\\t\\t\\t\\tjQuery.cssHooks[ tween.prop ] ) ) {\\n\\t\\t\\t\\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n// Support: IE <=9 only\\n// Panic based approach to setting things on disconnected nodes\\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\\n\\tset: function( tween ) {\\n\\t\\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\\n\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.easing = {\\n\\tlinear: function( p ) {\\n\\t\\treturn p;\\n\\t},\\n\\tswing: function( p ) {\\n\\t\\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\\n\\t},\\n\\t_default: \"swing\"\\n};\\n\\njQuery.fx = Tween.prototype.init;\\n\\n// Back compat <1.8 extension point\\njQuery.fx.step = {};\\n\\n\\n\\n\\nvar\\n\\tfxNow, inProgress,\\n\\trfxtypes = /^(?:toggle|show|hide)$/,\\n\\trrun = /queueHooks$/;\\n\\nfunction schedule() {\\n\\tif ( inProgress ) {\\n\\t\\tif ( document.hidden === false && window.requestAnimationFrame ) {\\n\\t\\t\\twindow.requestAnimationFrame( schedule );\\n\\t\\t} else {\\n\\t\\t\\twindow.setTimeout( schedule, jQuery.fx.interval );\\n\\t\\t}\\n\\n\\t\\tjQuery.fx.tick();\\n\\t}\\n}\\n\\n// Animations created synchronously will run synchronously\\nfunction createFxNow() {\\n\\twindow.setTimeout( function() {\\n\\t\\tfxNow = undefined;\\n\\t} );\\n\\treturn ( fxNow = jQuery.now() );\\n}\\n\\n// Generate parameters to create a standard animation\\nfunction genFx( type, includeWidth ) {\\n\\tvar which,\\n\\t\\ti = 0,\\n\\t\\tattrs = { height: type };\\n\\n\\t// If we include width, step value is 1 to do all cssExpand values,\\n\\t// otherwise step value is 2 to skip over Left and Right\\n\\tincludeWidth = includeWidth ? 1 : 0;\\n\\tfor ( ; i < 4; i += 2 - includeWidth ) {\\n\\t\\twhich = cssExpand[ i ];\\n\\t\\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\\n\\t}\\n\\n\\tif ( includeWidth ) {\\n\\t\\tattrs.opacity = attrs.width = type;\\n\\t}\\n\\n\\treturn attrs;\\n}\\n\\nfunction createTween( value, prop, animation ) {\\n\\tvar tween,\\n\\t\\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\\n\\t\\tindex = 0,\\n\\t\\tlength = collection.length;\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\\n\\n\\t\\t\\t// We\\'re done with this property\\n\\t\\t\\treturn tween;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction defaultPrefilter( elem, props, opts ) {\\n\\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\\n\\t\\tisBox = \"width\" in props || \"height\" in props,\\n\\t\\tanim = this,\\n\\t\\torig = {},\\n\\t\\tstyle = elem.style,\\n\\t\\thidden = elem.nodeType && isHiddenWithinTree( elem ),\\n\\t\\tdataShow = dataPriv.get( elem, \"fxshow\" );\\n\\n\\t// Queue-skipping animations hijack the fx hooks\\n\\tif ( !opts.queue ) {\\n\\t\\thooks = jQuery._queueHooks( elem, \"fx\" );\\n\\t\\tif ( hooks.unqueued == null ) {\\n\\t\\t\\thooks.unqueued = 0;\\n\\t\\t\\toldfire = hooks.empty.fire;\\n\\t\\t\\thooks.empty.fire = function() {\\n\\t\\t\\t\\tif ( !hooks.unqueued ) {\\n\\t\\t\\t\\t\\toldfire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\thooks.unqueued++;\\n\\n\\t\\tanim.always( function() {\\n\\n\\t\\t\\t// Ensure the complete handler is called before this completes\\n\\t\\t\\tanim.always( function() {\\n\\t\\t\\t\\thooks.unqueued--;\\n\\t\\t\\t\\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\\n\\t\\t\\t\\t\\thooks.empty.fire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\t// Detect show/hide animations\\n\\tfor ( prop in props ) {\\n\\t\\tvalue = props[ prop ];\\n\\t\\tif ( rfxtypes.test( value ) ) {\\n\\t\\t\\tdelete props[ prop ];\\n\\t\\t\\ttoggle = toggle || value === \"toggle\";\\n\\t\\t\\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\\n\\n\\t\\t\\t\\t// Pretend to be hidden if this is a \"show\" and\\n\\t\\t\\t\\t// there is still data from a stopped show/hide\\n\\t\\t\\t\\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\\n\\t\\t\\t\\t\\thidden = true;\\n\\n\\t\\t\\t\\t// Ignore all other no-op show/hide data\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\\n\\t\\t}\\n\\t}\\n\\n\\t// Bail out if this is a no-op like .hide().hide()\\n\\tpropTween = !jQuery.isEmptyObject( props );\\n\\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Restrict \"overflow\" and \"display\" styles during box animations\\n\\tif ( isBox && elem.nodeType === 1 ) {\\n\\n\\t\\t// Support: IE <=9 - 11, Edge 12 - 13\\n\\t\\t// Record all 3 overflow attributes because IE does not infer the shorthand\\n\\t\\t// from identically-valued overflowX and overflowY\\n\\t\\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\\n\\n\\t\\t// Identify a display type, preferring old show/hide data over the CSS cascade\\n\\t\\trestoreDisplay = dataShow && dataShow.display;\\n\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\trestoreDisplay = dataPriv.get( elem, \"display\" );\\n\\t\\t}\\n\\t\\tdisplay = jQuery.css( elem, \"display\" );\\n\\t\\tif ( display === \"none\" ) {\\n\\t\\t\\tif ( restoreDisplay ) {\\n\\t\\t\\t\\tdisplay = restoreDisplay;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Get nonempty value(s) by temporarily forcing visibility\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t\\trestoreDisplay = elem.style.display || restoreDisplay;\\n\\t\\t\\t\\tdisplay = jQuery.css( elem, \"display\" );\\n\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Animate inline elements as inline-block\\n\\t\\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\\n\\t\\t\\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\\n\\n\\t\\t\\t\\t// Restore the original display value at the end of pure show/hide animations\\n\\t\\t\\t\\tif ( !propTween ) {\\n\\t\\t\\t\\t\\tanim.done( function() {\\n\\t\\t\\t\\t\\t\\tstyle.display = restoreDisplay;\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\t\\t\\t\\tdisplay = style.display;\\n\\t\\t\\t\\t\\t\\trestoreDisplay = display === \"none\" ? \"\" : display;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstyle.display = \"inline-block\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( opts.overflow ) {\\n\\t\\tstyle.overflow = \"hidden\";\\n\\t\\tanim.always( function() {\\n\\t\\t\\tstyle.overflow = opts.overflow[ 0 ];\\n\\t\\t\\tstyle.overflowX = opts.overflow[ 1 ];\\n\\t\\t\\tstyle.overflowY = opts.overflow[ 2 ];\\n\\t\\t} );\\n\\t}\\n\\n\\t// Implement show/hide animations\\n\\tpropTween = false;\\n\\tfor ( prop in orig ) {\\n\\n\\t\\t// General show/hide setup for this element animation\\n\\t\\tif ( !propTween ) {\\n\\t\\t\\tif ( dataShow ) {\\n\\t\\t\\t\\tif ( \"hidden\" in dataShow ) {\\n\\t\\t\\t\\t\\thidden = dataShow.hidden;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\\n\\t\\t\\tif ( toggle ) {\\n\\t\\t\\t\\tdataShow.hidden = !hidden;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Show elements before animating them\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* eslint-disable no-loop-func */\\n\\n\\t\\t\\tanim.done( function() {\\n\\n\\t\\t\\t/* eslint-enable no-loop-func */\\n\\n\\t\\t\\t\\t// The final step of a \"hide\" animation is actually hiding the element\\n\\t\\t\\t\\tif ( !hidden ) {\\n\\t\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.remove( elem, \"fxshow\" );\\n\\t\\t\\t\\tfor ( prop in orig ) {\\n\\t\\t\\t\\t\\tjQuery.style( elem, prop, orig[ prop ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\t// Per-property setup\\n\\t\\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\\n\\t\\tif ( !( prop in dataShow ) ) {\\n\\t\\t\\tdataShow[ prop ] = propTween.start;\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tpropTween.end = propTween.start;\\n\\t\\t\\t\\tpropTween.start = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction propFilter( props, specialEasing ) {\\n\\tvar index, name, easing, value, hooks;\\n\\n\\t// camelCase, specialEasing and expand cssHook pass\\n\\tfor ( index in props ) {\\n\\t\\tname = jQuery.camelCase( index );\\n\\t\\teasing = specialEasing[ name ];\\n\\t\\tvalue = props[ index ];\\n\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\teasing = value[ 1 ];\\n\\t\\t\\tvalue = props[ index ] = value[ 0 ];\\n\\t\\t}\\n\\n\\t\\tif ( index !== name ) {\\n\\t\\t\\tprops[ name ] = value;\\n\\t\\t\\tdelete props[ index ];\\n\\t\\t}\\n\\n\\t\\thooks = jQuery.cssHooks[ name ];\\n\\t\\tif ( hooks && \"expand\" in hooks ) {\\n\\t\\t\\tvalue = hooks.expand( value );\\n\\t\\t\\tdelete props[ name ];\\n\\n\\t\\t\\t// Not quite $.extend, this won\\'t overwrite existing keys.\\n\\t\\t\\t// Reusing \\'index\\' because we have the correct \"name\"\\n\\t\\t\\tfor ( index in value ) {\\n\\t\\t\\t\\tif ( !( index in props ) ) {\\n\\t\\t\\t\\t\\tprops[ index ] = value[ index ];\\n\\t\\t\\t\\t\\tspecialEasing[ index ] = easing;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tspecialEasing[ name ] = easing;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction Animation( elem, properties, options ) {\\n\\tvar result,\\n\\t\\tstopped,\\n\\t\\tindex = 0,\\n\\t\\tlength = Animation.prefilters.length,\\n\\t\\tdeferred = jQuery.Deferred().always( function() {\\n\\n\\t\\t\\t// Don\\'t match elem in the :animated selector\\n\\t\\t\\tdelete tick.elem;\\n\\t\\t} ),\\n\\t\\ttick = function() {\\n\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tvar currentTime = fxNow || createFxNow(),\\n\\t\\t\\t\\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\\n\\n\\t\\t\\t\\t// Support: Android 2.3 only\\n\\t\\t\\t\\t// Archaic crash bug won\\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\\n\\t\\t\\t\\ttemp = remaining / animation.duration || 0,\\n\\t\\t\\t\\tpercent = 1 - temp,\\n\\t\\t\\t\\tindex = 0,\\n\\t\\t\\t\\tlength = animation.tweens.length;\\n\\n\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\tanimation.tweens[ index ].run( percent );\\n\\t\\t\\t}\\n\\n\\t\\t\\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\\n\\n\\t\\t\\t// If there\\'s more to do, yield\\n\\t\\t\\tif ( percent < 1 && length ) {\\n\\t\\t\\t\\treturn remaining;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If this was an empty animation, synthesize a final progress notification\\n\\t\\t\\tif ( !length ) {\\n\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Resolve the animation and report its conclusion\\n\\t\\t\\tdeferred.resolveWith( elem, [ animation ] );\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tanimation = deferred.promise( {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tprops: jQuery.extend( {}, properties ),\\n\\t\\t\\topts: jQuery.extend( true, {\\n\\t\\t\\t\\tspecialEasing: {},\\n\\t\\t\\t\\teasing: jQuery.easing._default\\n\\t\\t\\t}, options ),\\n\\t\\t\\toriginalProperties: properties,\\n\\t\\t\\toriginalOptions: options,\\n\\t\\t\\tstartTime: fxNow || createFxNow(),\\n\\t\\t\\tduration: options.duration,\\n\\t\\t\\ttweens: [],\\n\\t\\t\\tcreateTween: function( prop, end ) {\\n\\t\\t\\t\\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\\n\\t\\t\\t\\t\\t\\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\\n\\t\\t\\t\\tanimation.tweens.push( tween );\\n\\t\\t\\t\\treturn tween;\\n\\t\\t\\t},\\n\\t\\t\\tstop: function( gotoEnd ) {\\n\\t\\t\\t\\tvar index = 0,\\n\\n\\t\\t\\t\\t\\t// If we are going to the end, we want to run all the tweens\\n\\t\\t\\t\\t\\t// otherwise we skip this part\\n\\t\\t\\t\\t\\tlength = gotoEnd ? animation.tweens.length : 0;\\n\\t\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstopped = true;\\n\\t\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\t\\tanimation.tweens[ index ].run( 1 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Resolve when we played the last frame; otherwise, reject\\n\\t\\t\\t\\tif ( gotoEnd ) {\\n\\t\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t\\t\\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t} ),\\n\\t\\tprops = animation.props;\\n\\n\\tpropFilter( props, animation.opts.specialEasing );\\n\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\\n\\t\\tif ( result ) {\\n\\t\\t\\tif ( jQuery.isFunction( result.stop ) ) {\\n\\t\\t\\t\\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\\n\\t\\t\\t\\t\\tjQuery.proxy( result.stop, result );\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\n\\tjQuery.map( props, createTween, animation );\\n\\n\\tif ( jQuery.isFunction( animation.opts.start ) ) {\\n\\t\\tanimation.opts.start.call( elem, animation );\\n\\t}\\n\\n\\t// Attach callbacks from options\\n\\tanimation\\n\\t\\t.progress( animation.opts.progress )\\n\\t\\t.done( animation.opts.done, animation.opts.complete )\\n\\t\\t.fail( animation.opts.fail )\\n\\t\\t.always( animation.opts.always );\\n\\n\\tjQuery.fx.timer(\\n\\t\\tjQuery.extend( tick, {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tanim: animation,\\n\\t\\t\\tqueue: animation.opts.queue\\n\\t\\t} )\\n\\t);\\n\\n\\treturn animation;\\n}\\n\\njQuery.Animation = jQuery.extend( Animation, {\\n\\n\\ttweeners: {\\n\\t\\t\"*\": [ function( prop, value ) {\\n\\t\\t\\tvar tween = this.createTween( prop, value );\\n\\t\\t\\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\\n\\t\\t\\treturn tween;\\n\\t\\t} ]\\n\\t},\\n\\n\\ttweener: function( props, callback ) {\\n\\t\\tif ( jQuery.isFunction( props ) ) {\\n\\t\\t\\tcallback = props;\\n\\t\\t\\tprops = [ \"*\" ];\\n\\t\\t} else {\\n\\t\\t\\tprops = props.match( rnothtmlwhite );\\n\\t\\t}\\n\\n\\t\\tvar prop,\\n\\t\\t\\tindex = 0,\\n\\t\\t\\tlength = props.length;\\n\\n\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\tprop = props[ index ];\\n\\t\\t\\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\\n\\t\\t\\tAnimation.tweeners[ prop ].unshift( callback );\\n\\t\\t}\\n\\t},\\n\\n\\tprefilters: [ defaultPrefilter ],\\n\\n\\tprefilter: function( callback, prepend ) {\\n\\t\\tif ( prepend ) {\\n\\t\\t\\tAnimation.prefilters.unshift( callback );\\n\\t\\t} else {\\n\\t\\t\\tAnimation.prefilters.push( callback );\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.speed = function( speed, easing, fn ) {\\n\\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\\n\\t\\tcomplete: fn || !fn && easing ||\\n\\t\\t\\tjQuery.isFunction( speed ) && speed,\\n\\t\\tduration: speed,\\n\\t\\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\\n\\t};\\n\\n\\t// Go to the end state if fx are off\\n\\tif ( jQuery.fx.off ) {\\n\\t\\topt.duration = 0;\\n\\n\\t} else {\\n\\t\\tif ( typeof opt.duration !== \"number\" ) {\\n\\t\\t\\tif ( opt.duration in jQuery.fx.speeds ) {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds[ opt.duration ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds._default;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Normalize opt.queue - true/undefined/null -> \"fx\"\\n\\tif ( opt.queue == null || opt.queue === true ) {\\n\\t\\topt.queue = \"fx\";\\n\\t}\\n\\n\\t// Queueing\\n\\topt.old = opt.complete;\\n\\n\\topt.complete = function() {\\n\\t\\tif ( jQuery.isFunction( opt.old ) ) {\\n\\t\\t\\topt.old.call( this );\\n\\t\\t}\\n\\n\\t\\tif ( opt.queue ) {\\n\\t\\t\\tjQuery.dequeue( this, opt.queue );\\n\\t\\t}\\n\\t};\\n\\n\\treturn opt;\\n};\\n\\njQuery.fn.extend( {\\n\\tfadeTo: function( speed, to, easing, callback ) {\\n\\n\\t\\t// Show any hidden elements after setting opacity to 0\\n\\t\\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\\n\\n\\t\\t\\t// Animate to the value specified\\n\\t\\t\\t.end().animate( { opacity: to }, speed, easing, callback );\\n\\t},\\n\\tanimate: function( prop, speed, easing, callback ) {\\n\\t\\tvar empty = jQuery.isEmptyObject( prop ),\\n\\t\\t\\toptall = jQuery.speed( speed, easing, callback ),\\n\\t\\t\\tdoAnimation = function() {\\n\\n\\t\\t\\t\\t// Operate on a copy of prop so per-property easing won\\'t be lost\\n\\t\\t\\t\\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\\n\\n\\t\\t\\t\\t// Empty animations, or finishing resolves immediately\\n\\t\\t\\t\\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\\n\\t\\t\\t\\t\\tanim.stop( true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tdoAnimation.finish = doAnimation;\\n\\n\\t\\treturn empty || optall.queue === false ?\\n\\t\\t\\tthis.each( doAnimation ) :\\n\\t\\t\\tthis.queue( optall.queue, doAnimation );\\n\\t},\\n\\tstop: function( type, clearQueue, gotoEnd ) {\\n\\t\\tvar stopQueue = function( hooks ) {\\n\\t\\t\\tvar stop = hooks.stop;\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tstop( gotoEnd );\\n\\t\\t};\\n\\n\\t\\tif ( typeof type !== \"string\" ) {\\n\\t\\t\\tgotoEnd = clearQueue;\\n\\t\\t\\tclearQueue = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\tif ( clearQueue && type !== false ) {\\n\\t\\t\\tthis.queue( type || \"fx\", [] );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar dequeue = true,\\n\\t\\t\\t\\tindex = type != null && type + \"queueHooks\",\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tdata = dataPriv.get( this );\\n\\n\\t\\t\\tif ( index ) {\\n\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop ) {\\n\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor ( index in data ) {\\n\\t\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\\n\\t\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this &&\\n\\t\\t\\t\\t\\t( type == null || timers[ index ].queue === type ) ) {\\n\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( gotoEnd );\\n\\t\\t\\t\\t\\tdequeue = false;\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Start the next in the queue if the last step wasn\\'t forced.\\n\\t\\t\\t// Timers currently will call their complete callbacks, which\\n\\t\\t\\t// will dequeue but only if they were gotoEnd.\\n\\t\\t\\tif ( dequeue || !gotoEnd ) {\\n\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\tfinish: function( type ) {\\n\\t\\tif ( type !== false ) {\\n\\t\\t\\ttype = type || \"fx\";\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar index,\\n\\t\\t\\t\\tdata = dataPriv.get( this ),\\n\\t\\t\\t\\tqueue = data[ type + \"queue\" ],\\n\\t\\t\\t\\thooks = data[ type + \"queueHooks\" ],\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tlength = queue ? queue.length : 0;\\n\\n\\t\\t\\t// Enable finishing flag on private data\\n\\t\\t\\tdata.finish = true;\\n\\n\\t\\t\\t// Empty the queue first\\n\\t\\t\\tjQuery.queue( this, type, [] );\\n\\n\\t\\t\\tif ( hooks && hooks.stop ) {\\n\\t\\t\\t\\thooks.stop.call( this, true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any active animations, and finish them\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( true );\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any animations in the old queue and finish them\\n\\t\\t\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\t\\t\\tif ( queue[ index ] && queue[ index ].finish ) {\\n\\t\\t\\t\\t\\tqueue[ index ].finish.call( this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Turn off finishing flag\\n\\t\\t\\tdelete data.finish;\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\\n\\tvar cssFn = jQuery.fn[ name ];\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn speed == null || typeof speed === \"boolean\" ?\\n\\t\\t\\tcssFn.apply( this, arguments ) :\\n\\t\\t\\tthis.animate( genFx( name, true ), speed, easing, callback );\\n\\t};\\n} );\\n\\n// Generate shortcuts for custom animations\\njQuery.each( {\\n\\tslideDown: genFx( \"show\" ),\\n\\tslideUp: genFx( \"hide\" ),\\n\\tslideToggle: genFx( \"toggle\" ),\\n\\tfadeIn: { opacity: \"show\" },\\n\\tfadeOut: { opacity: \"hide\" },\\n\\tfadeToggle: { opacity: \"toggle\" }\\n}, function( name, props ) {\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn this.animate( props, speed, easing, callback );\\n\\t};\\n} );\\n\\njQuery.timers = [];\\njQuery.fx.tick = function() {\\n\\tvar timer,\\n\\t\\ti = 0,\\n\\t\\ttimers = jQuery.timers;\\n\\n\\tfxNow = jQuery.now();\\n\\n\\tfor ( ; i < timers.length; i++ ) {\\n\\t\\ttimer = timers[ i ];\\n\\n\\t\\t// Run the timer and safely remove it when done (allowing for external removal)\\n\\t\\tif ( !timer() && timers[ i ] === timer ) {\\n\\t\\t\\ttimers.splice( i--, 1 );\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !timers.length ) {\\n\\t\\tjQuery.fx.stop();\\n\\t}\\n\\tfxNow = undefined;\\n};\\n\\njQuery.fx.timer = function( timer ) {\\n\\tjQuery.timers.push( timer );\\n\\tjQuery.fx.start();\\n};\\n\\njQuery.fx.interval = 13;\\njQuery.fx.start = function() {\\n\\tif ( inProgress ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tinProgress = true;\\n\\tschedule();\\n};\\n\\njQuery.fx.stop = function() {\\n\\tinProgress = null;\\n};\\n\\njQuery.fx.speeds = {\\n\\tslow: 600,\\n\\tfast: 200,\\n\\n\\t// Default speed\\n\\t_default: 400\\n};\\n\\n\\n// Based off of the plugin by Clint Helfers, with permission.\\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\\njQuery.fn.delay = function( time, type ) {\\n\\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\\n\\ttype = type || \"fx\";\\n\\n\\treturn this.queue( type, function( next, hooks ) {\\n\\t\\tvar timeout = window.setTimeout( next, time );\\n\\t\\thooks.stop = function() {\\n\\t\\t\\twindow.clearTimeout( timeout );\\n\\t\\t};\\n\\t} );\\n};\\n\\n\\n( function() {\\n\\tvar input = document.createElement( \"input\" ),\\n\\t\\tselect = document.createElement( \"select\" ),\\n\\t\\topt = select.appendChild( document.createElement( \"option\" ) );\\n\\n\\tinput.type = \"checkbox\";\\n\\n\\t// Support: Android <=4.3 only\\n\\t// Default value for a checkbox should be \"on\"\\n\\tsupport.checkOn = input.value !== \"\";\\n\\n\\t// Support: IE <=11 only\\n\\t// Must access selectedIndex to make default options select\\n\\tsupport.optSelected = opt.selected;\\n\\n\\t// Support: IE <=11 only\\n\\t// An input loses its value after becoming a radio\\n\\tinput = document.createElement( \"input\" );\\n\\tinput.value = \"t\";\\n\\tinput.type = \"radio\";\\n\\tsupport.radioValue = input.value === \"t\";\\n} )();\\n\\n\\nvar boolHook,\\n\\tattrHandle = jQuery.expr.attrHandle;\\n\\njQuery.fn.extend( {\\n\\tattr: function( name, value ) {\\n\\t\\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveAttr: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.removeAttr( this, name );\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tattr: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don\\'t get/set attributes on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Fallback to prop when attributes are not supported\\n\\t\\tif ( typeof elem.getAttribute === \"undefined\" ) {\\n\\t\\t\\treturn jQuery.prop( elem, name, value );\\n\\t\\t}\\n\\n\\t\\t// Attribute hooks are determined by the lowercase version\\n\\t\\t// Grab necessary hook if one is defined\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\t\\t\\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\\n\\t\\t\\t\\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( value === null ) {\\n\\t\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hooks && \"set\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\telem.setAttribute( name, value + \"\" );\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\tret = jQuery.find.attr( elem, name );\\n\\n\\t\\t// Non-existent attributes return null, we normalize to undefined\\n\\t\\treturn ret == null ? undefined : ret;\\n\\t},\\n\\n\\tattrHooks: {\\n\\t\\ttype: {\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tif ( !support.radioValue && value === \"radio\" &&\\n\\t\\t\\t\\t\\tnodeName( elem, \"input\" ) ) {\\n\\t\\t\\t\\t\\tvar val = elem.value;\\n\\t\\t\\t\\t\\telem.setAttribute( \"type\", value );\\n\\t\\t\\t\\t\\tif ( val ) {\\n\\t\\t\\t\\t\\t\\telem.value = val;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tremoveAttr: function( elem, value ) {\\n\\t\\tvar name,\\n\\t\\t\\ti = 0,\\n\\n\\t\\t\\t// Attribute names can contain non-HTML whitespace characters\\n\\t\\t\\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\\n\\t\\t\\tattrNames = value && value.match( rnothtmlwhite );\\n\\n\\t\\tif ( attrNames && elem.nodeType === 1 ) {\\n\\t\\t\\twhile ( ( name = attrNames[ i++ ] ) ) {\\n\\t\\t\\t\\telem.removeAttribute( name );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Hooks for boolean attributes\\nboolHook = {\\n\\tset: function( elem, value, name ) {\\n\\t\\tif ( value === false ) {\\n\\n\\t\\t\\t// Remove boolean attributes when set to false\\n\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t} else {\\n\\t\\t\\telem.setAttribute( name, name );\\n\\t\\t}\\n\\t\\treturn name;\\n\\t}\\n};\\n\\njQuery.each( jQuery.expr.match.bool.source.match( /\\\\w+/g ), function( i, name ) {\\n\\tvar getter = attrHandle[ name ] || jQuery.find.attr;\\n\\n\\tattrHandle[ name ] = function( elem, name, isXML ) {\\n\\t\\tvar ret, handle,\\n\\t\\t\\tlowercaseName = name.toLowerCase();\\n\\n\\t\\tif ( !isXML ) {\\n\\n\\t\\t\\t// Avoid an infinite loop by temporarily removing this function from the getter\\n\\t\\t\\thandle = attrHandle[ lowercaseName ];\\n\\t\\t\\tattrHandle[ lowercaseName ] = ret;\\n\\t\\t\\tret = getter( elem, name, isXML ) != null ?\\n\\t\\t\\t\\tlowercaseName :\\n\\t\\t\\t\\tnull;\\n\\t\\t\\tattrHandle[ lowercaseName ] = handle;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t};\\n} );\\n\\n\\n\\n\\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\\n\\trclickable = /^(?:a|area)$/i;\\n\\njQuery.fn.extend( {\\n\\tprop: function( name, value ) {\\n\\t\\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveProp: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdelete this[ jQuery.propFix[ name ] || name ];\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tprop: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don\\'t get/set properties on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// Fix name and attach hooks\\n\\t\\t\\tname = jQuery.propFix[ name ] || name;\\n\\t\\t\\thooks = jQuery.propHooks[ name ];\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( hooks && \"set\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( elem[ name ] = value );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\treturn elem[ name ];\\n\\t},\\n\\n\\tpropHooks: {\\n\\t\\ttabIndex: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t\\t\\t// elem.tabIndex doesn\\'t always return the\\n\\t\\t\\t\\t// correct value when it hasn\\'t been explicitly set\\n\\t\\t\\t\\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\\n\\t\\t\\t\\t// Use proper attribute retrieval(#12072)\\n\\t\\t\\t\\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\\n\\n\\t\\t\\t\\tif ( tabindex ) {\\n\\t\\t\\t\\t\\treturn parseInt( tabindex, 10 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\trfocusable.test( elem.nodeName ) ||\\n\\t\\t\\t\\t\\trclickable.test( elem.nodeName ) &&\\n\\t\\t\\t\\t\\telem.href\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tpropFix: {\\n\\t\\t\"for\": \"htmlFor\",\\n\\t\\t\"class\": \"className\"\\n\\t}\\n} );\\n\\n// Support: IE <=11 only\\n// Accessing the selectedIndex property\\n// forces the browser to respect setting selected\\n// on the option\\n// The getter ensures a default option is selected\\n// when in an optgroup\\n// eslint rule \"no-unused-expressions\" is disabled for this code\\n// since it considers such accessions noop\\nif ( !support.optSelected ) {\\n\\tjQuery.propHooks.selected = {\\n\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \"off\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent && parent.parentNode ) {\\n\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tset: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \"off\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\tparent.selectedIndex;\\n\\n\\t\\t\\t\\tif ( parent.parentNode ) {\\n\\t\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\njQuery.each( [\\n\\t\"tabIndex\",\\n\\t\"readOnly\",\\n\\t\"maxLength\",\\n\\t\"cellSpacing\",\\n\\t\"cellPadding\",\\n\\t\"rowSpan\",\\n\\t\"colSpan\",\\n\\t\"useMap\",\\n\\t\"frameBorder\",\\n\\t\"contentEditable\"\\n], function() {\\n\\tjQuery.propFix[ this.toLowerCase() ] = this;\\n} );\\n\\n\\n\\n\\n\\t// Strip and collapse whitespace according to HTML spec\\n\\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\\n\\tfunction stripAndCollapse( value ) {\\n\\t\\tvar tokens = value.match( rnothtmlwhite ) || [];\\n\\t\\treturn tokens.join( \" \" );\\n\\t}\\n\\n\\nfunction getClass( elem ) {\\n\\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\\n}\\n\\njQuery.fn.extend( {\\n\\taddClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( typeof value === \"string\" && value ) {\\n\\t\\t\\tclasses = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\t\\t\\t\\t\\t\\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur += clazz + \" \";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \"class\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tremoveClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\treturn this.attr( \"class\", \"\" );\\n\\t\\t}\\n\\n\\t\\tif ( typeof value === \"string\" && value ) {\\n\\t\\t\\tclasses = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\n\\t\\t\\t\\t// This expression is here for better compressibility (see addClass)\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Remove *all* instances\\n\\t\\t\\t\\t\\t\\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \"class\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\ttoggleClass: function( value, stateVal ) {\\n\\t\\tvar type = typeof value;\\n\\n\\t\\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\\n\\t\\t\\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\\n\\t\\t}\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).toggleClass(\\n\\t\\t\\t\\t\\tvalue.call( this, i, getClass( this ), stateVal ),\\n\\t\\t\\t\\t\\tstateVal\\n\\t\\t\\t\\t);\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar className, i, self, classNames;\\n\\n\\t\\t\\tif ( type === \"string\" ) {\\n\\n\\t\\t\\t\\t// Toggle individual class names\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\tself = jQuery( this );\\n\\t\\t\\t\\tclassNames = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\t\\twhile ( ( className = classNames[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t// Check each className given, space separated list\\n\\t\\t\\t\\t\\tif ( self.hasClass( className ) ) {\\n\\t\\t\\t\\t\\t\\tself.removeClass( className );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tself.addClass( className );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// Toggle whole class name\\n\\t\\t\\t} else if ( value === undefined || type === \"boolean\" ) {\\n\\t\\t\\t\\tclassName = getClass( this );\\n\\t\\t\\t\\tif ( className ) {\\n\\n\\t\\t\\t\\t\\t// Store className if set\\n\\t\\t\\t\\t\\tdataPriv.set( this, \"__className__\", className );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the element has a class name or if we\\'re passed `false`,\\n\\t\\t\\t\\t// then remove the whole classname (if there was one, the above saved it).\\n\\t\\t\\t\\t// Otherwise bring back whatever was previously saved (if anything),\\n\\t\\t\\t\\t// falling back to the empty string if nothing was stored.\\n\\t\\t\\t\\tif ( this.setAttribute ) {\\n\\t\\t\\t\\t\\tthis.setAttribute( \"class\",\\n\\t\\t\\t\\t\\t\\tclassName || value === false ?\\n\\t\\t\\t\\t\\t\\t\"\" :\\n\\t\\t\\t\\t\\t\\tdataPriv.get( this, \"__className__\" ) || \"\"\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\thasClass: function( selector ) {\\n\\t\\tvar className, elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tclassName = \" \" + selector + \" \";\\n\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\tif ( elem.nodeType === 1 &&\\n\\t\\t\\t\\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n} );\\n\\n\\n\\n\\nvar rreturn = /\\\\r/g;\\n\\njQuery.fn.extend( {\\n\\tval: function( value ) {\\n\\t\\tvar hooks, ret, isFunction,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\thooks = jQuery.valHooks[ elem.type ] ||\\n\\t\\t\\t\\t\\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t\\tif ( hooks &&\\n\\t\\t\\t\\t\\t\"get\" in hooks &&\\n\\t\\t\\t\\t\\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tret = elem.value;\\n\\n\\t\\t\\t\\t// Handle most common string cases\\n\\t\\t\\t\\tif ( typeof ret === \"string\" ) {\\n\\t\\t\\t\\t\\treturn ret.replace( rreturn, \"\" );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Handle cases where value is null/undef or number\\n\\t\\t\\t\\treturn ret == null ? \"\" : ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tisFunction = jQuery.isFunction( value );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tvar val;\\n\\n\\t\\t\\tif ( this.nodeType !== 1 ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isFunction ) {\\n\\t\\t\\t\\tval = value.call( this, i, jQuery( this ).val() );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tval = value;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Treat null/undefined as \"\"; convert numbers to string\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\tval = \"\";\\n\\n\\t\\t\\t} else if ( typeof val === \"number\" ) {\\n\\t\\t\\t\\tval += \"\";\\n\\n\\t\\t\\t} else if ( Array.isArray( val ) ) {\\n\\t\\t\\t\\tval = jQuery.map( val, function( value ) {\\n\\t\\t\\t\\t\\treturn value == null ? \"\" : value + \"\";\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t// If set returns undefined, fall back to normal setting\\n\\t\\t\\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\\n\\t\\t\\t\\tthis.value = val;\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tvalHooks: {\\n\\t\\toption: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\tvar val = jQuery.find.attr( elem, \"value\" );\\n\\t\\t\\t\\treturn val != null ?\\n\\t\\t\\t\\t\\tval :\\n\\n\\t\\t\\t\\t\\t// Support: IE <=10 - 11 only\\n\\t\\t\\t\\t\\t// option.text throws exceptions (#14686, #14858)\\n\\t\\t\\t\\t\\t// Strip and collapse whitespace\\n\\t\\t\\t\\t\\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\\n\\t\\t\\t\\t\\tstripAndCollapse( jQuery.text( elem ) );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tselect: {\\n\\t\\t\\tget: function( elem ) {\\n\\t\\t\\t\\tvar value, option, i,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tindex = elem.selectedIndex,\\n\\t\\t\\t\\t\\tone = elem.type === \"select-one\",\\n\\t\\t\\t\\t\\tvalues = one ? null : [],\\n\\t\\t\\t\\t\\tmax = one ? index + 1 : options.length;\\n\\n\\t\\t\\t\\tif ( index < 0 ) {\\n\\t\\t\\t\\t\\ti = max;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ti = one ? index : 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Loop through all the selected options\\n\\t\\t\\t\\tfor ( ; i < max; i++ ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t// IE8-9 doesn\\'t update selected after form reset (#2551)\\n\\t\\t\\t\\t\\tif ( ( option.selected || i === index ) &&\\n\\n\\t\\t\\t\\t\\t\\t\\t// Don\\'t return options that are disabled or in a disabled optgroup\\n\\t\\t\\t\\t\\t\\t\\t!option.disabled &&\\n\\t\\t\\t\\t\\t\\t\\t( !option.parentNode.disabled ||\\n\\t\\t\\t\\t\\t\\t\\t\\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Get the specific value for the option\\n\\t\\t\\t\\t\\t\\tvalue = jQuery( option ).val();\\n\\n\\t\\t\\t\\t\\t\\t// We don\\'t need an array for one selects\\n\\t\\t\\t\\t\\t\\tif ( one ) {\\n\\t\\t\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Multi-Selects return an array\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tvar optionSet, option,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tvalues = jQuery.makeArray( value ),\\n\\t\\t\\t\\t\\ti = options.length;\\n\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t/* eslint-disable no-cond-assign */\\n\\n\\t\\t\\t\\t\\tif ( option.selected =\\n\\t\\t\\t\\t\\t\\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\toptionSet = true;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t/* eslint-enable no-cond-assign */\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Force browsers to behave consistently when non-matching value is set\\n\\t\\t\\t\\tif ( !optionSet ) {\\n\\t\\t\\t\\t\\telem.selectedIndex = -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Radios and checkboxes getter/setter\\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\\n\\tjQuery.valHooks[ this ] = {\\n\\t\\tset: function( elem, value ) {\\n\\t\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\t\\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tif ( !support.checkOn ) {\\n\\t\\tjQuery.valHooks[ this ].get = function( elem ) {\\n\\t\\t\\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Return jQuery for attributes-only inclusion\\n\\n\\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\\n\\njQuery.extend( jQuery.event, {\\n\\n\\ttrigger: function( event, data, elem, onlyHandlers ) {\\n\\n\\t\\tvar i, cur, tmp, bubbleType, ontype, handle, special,\\n\\t\\t\\teventPath = [ elem || document ],\\n\\t\\t\\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\\n\\t\\t\\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\\n\\n\\t\\tcur = tmp = elem = elem || document;\\n\\n\\t\\t// Don\\'t do events on text and comment nodes\\n\\t\\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// focus/blur morphs to focusin/out; ensure we\\'re not firing them right now\\n\\t\\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( type.indexOf( \".\" ) > -1 ) {\\n\\n\\t\\t\\t// Namespaced trigger; create a regexp to match event type in handle()\\n\\t\\t\\tnamespaces = type.split( \".\" );\\n\\t\\t\\ttype = namespaces.shift();\\n\\t\\t\\tnamespaces.sort();\\n\\t\\t}\\n\\t\\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\\n\\n\\t\\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\\n\\t\\tevent = event[ jQuery.expando ] ?\\n\\t\\t\\tevent :\\n\\t\\t\\tnew jQuery.Event( type, typeof event === \"object\" && event );\\n\\n\\t\\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\\n\\t\\tevent.isTrigger = onlyHandlers ? 2 : 3;\\n\\t\\tevent.namespace = namespaces.join( \".\" );\\n\\t\\tevent.rnamespace = event.namespace ?\\n\\t\\t\\tnew RegExp( \"(^|\\\\\\\\.)\" + namespaces.join( \"\\\\\\\\.(?:.*\\\\\\\\.|)\" ) + \"(\\\\\\\\.|$)\" ) :\\n\\t\\t\\tnull;\\n\\n\\t\\t// Clean up the event in case it is being reused\\n\\t\\tevent.result = undefined;\\n\\t\\tif ( !event.target ) {\\n\\t\\t\\tevent.target = elem;\\n\\t\\t}\\n\\n\\t\\t// Clone any incoming data and prepend the event, creating the handler arg list\\n\\t\\tdata = data == null ?\\n\\t\\t\\t[ event ] :\\n\\t\\t\\tjQuery.makeArray( data, [ event ] );\\n\\n\\t\\t// Allow special events to draw outside the lines\\n\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\t\\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\\n\\t\\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\tbubbleType = special.delegateType || type;\\n\\t\\t\\tif ( !rfocusMorph.test( bubbleType + type ) ) {\\n\\t\\t\\t\\tcur = cur.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( ; cur; cur = cur.parentNode ) {\\n\\t\\t\\t\\teventPath.push( cur );\\n\\t\\t\\t\\ttmp = cur;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\\n\\t\\t\\tif ( tmp === ( elem.ownerDocument || document ) ) {\\n\\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Fire handlers on the event path\\n\\t\\ti = 0;\\n\\t\\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\n\\t\\t\\tevent.type = i > 1 ?\\n\\t\\t\\t\\tbubbleType :\\n\\t\\t\\t\\tspecial.bindType || type;\\n\\n\\t\\t\\t// jQuery handler\\n\\t\\t\\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\\n\\t\\t\\t\\tdataPriv.get( cur, \"handle\" );\\n\\t\\t\\tif ( handle ) {\\n\\t\\t\\t\\thandle.apply( cur, data );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Native handler\\n\\t\\t\\thandle = ontype && cur[ ontype ];\\n\\t\\t\\tif ( handle && handle.apply && acceptData( cur ) ) {\\n\\t\\t\\t\\tevent.result = handle.apply( cur, data );\\n\\t\\t\\t\\tif ( event.result === false ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tevent.type = type;\\n\\n\\t\\t// If nobody prevented the default action, do it now\\n\\t\\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\\n\\n\\t\\t\\tif ( ( !special._default ||\\n\\t\\t\\t\\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\\n\\t\\t\\t\\tacceptData( elem ) ) {\\n\\n\\t\\t\\t\\t// Call a native DOM method on the target with the same name as the event.\\n\\t\\t\\t\\t// Don\\'t do default actions on window, that\\'s where global variables be (#6170)\\n\\t\\t\\t\\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// Don\\'t re-trigger an onFOO event when we call its FOO() method\\n\\t\\t\\t\\t\\ttmp = elem[ ontype ];\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prevent re-triggering of the same event, since we already bubbled it above\\n\\t\\t\\t\\t\\tjQuery.event.triggered = type;\\n\\t\\t\\t\\t\\telem[ type ]();\\n\\t\\t\\t\\t\\tjQuery.event.triggered = undefined;\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = tmp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\t// Piggyback on a donor event to simulate a different one\\n\\t// Used only for `focus(in | out)` events\\n\\tsimulate: function( type, elem, event ) {\\n\\t\\tvar e = jQuery.extend(\\n\\t\\t\\tnew jQuery.Event(),\\n\\t\\t\\tevent,\\n\\t\\t\\t{\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tisSimulated: true\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\tjQuery.event.trigger( e, null, elem );\\n\\t}\\n\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ttrigger: function( type, data ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.trigger( type, data, this );\\n\\t\\t} );\\n\\t},\\n\\ttriggerHandler: function( type, data ) {\\n\\t\\tvar elem = this[ 0 ];\\n\\t\\tif ( elem ) {\\n\\t\\t\\treturn jQuery.event.trigger( type, data, elem, true );\\n\\t\\t}\\n\\t}\\n} );\\n\\n\\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\\n\\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\\n\\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\\n\\tfunction( i, name ) {\\n\\n\\t// Handle event binding\\n\\tjQuery.fn[ name ] = function( data, fn ) {\\n\\t\\treturn arguments.length > 0 ?\\n\\t\\t\\tthis.on( name, null, data, fn ) :\\n\\t\\t\\tthis.trigger( name );\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\thover: function( fnOver, fnOut ) {\\n\\t\\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\\n\\t}\\n} );\\n\\n\\n\\n\\nsupport.focusin = \"onfocusin\" in window;\\n\\n\\n// Support: Firefox <=44\\n// Firefox doesn\\'t have focus(in | out) events\\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\\n//\\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\\n// focus(in | out) events fire after focus & blur events,\\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\\nif ( !support.focusin ) {\\n\\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\\n\\n\\t\\t// Attach a single capturing handler on the document while someone wants focusin/focusout\\n\\t\\tvar handler = function( event ) {\\n\\t\\t\\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\\n\\t\\t};\\n\\n\\t\\tjQuery.event.special[ fix ] = {\\n\\t\\t\\tsetup: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix );\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.addEventListener( orig, handler, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\\n\\t\\t\\t},\\n\\t\\t\\tteardown: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix ) - 1;\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.removeEventListener( orig, handler, true );\\n\\t\\t\\t\\t\\tdataPriv.remove( doc, fix );\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdataPriv.access( doc, fix, attaches );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} );\\n}\\nvar location = window.location;\\n\\nvar nonce = jQuery.now();\\n\\nvar rquery = ( /\\\\?/ );\\n\\n\\n\\n// Cross-browser xml parsing\\njQuery.parseXML = function( data ) {\\n\\tvar xml;\\n\\tif ( !data || typeof data !== \"string\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Support: IE 9 - 11 only\\n\\t// IE throws on parseFromString with invalid input.\\n\\ttry {\\n\\t\\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\\n\\t} catch ( e ) {\\n\\t\\txml = undefined;\\n\\t}\\n\\n\\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\\n\\t\\tjQuery.error( \"Invalid XML: \" + data );\\n\\t}\\n\\treturn xml;\\n};\\n\\n\\nvar\\n\\trbracket = /\\\\[\\\\]$/,\\n\\trCRLF = /\\\\r?\\\\n/g,\\n\\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\\n\\trsubmittable = /^(?:input|select|textarea|keygen)/i;\\n\\nfunction buildParams( prefix, obj, traditional, add ) {\\n\\tvar name;\\n\\n\\tif ( Array.isArray( obj ) ) {\\n\\n\\t\\t// Serialize array item.\\n\\t\\tjQuery.each( obj, function( i, v ) {\\n\\t\\t\\tif ( traditional || rbracket.test( prefix ) ) {\\n\\n\\t\\t\\t\\t// Treat each array item as a scalar.\\n\\t\\t\\t\\tadd( prefix, v );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Item is non-scalar (array or object), encode its numeric index.\\n\\t\\t\\t\\tbuildParams(\\n\\t\\t\\t\\t\\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\\n\\t\\t\\t\\t\\tv,\\n\\t\\t\\t\\t\\ttraditional,\\n\\t\\t\\t\\t\\tadd\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\\n\\n\\t\\t// Serialize object item.\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\\n\\t\\t}\\n\\n\\t} else {\\n\\n\\t\\t// Serialize scalar item.\\n\\t\\tadd( prefix, obj );\\n\\t}\\n}\\n\\n// Serialize an array of form elements or a set of\\n// key/values into a query string\\njQuery.param = function( a, traditional ) {\\n\\tvar prefix,\\n\\t\\ts = [],\\n\\t\\tadd = function( key, valueOrFunction ) {\\n\\n\\t\\t\\t// If value is a function, invoke it and use its return value\\n\\t\\t\\tvar value = jQuery.isFunction( valueOrFunction ) ?\\n\\t\\t\\t\\tvalueOrFunction() :\\n\\t\\t\\t\\tvalueOrFunction;\\n\\n\\t\\t\\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\\n\\t\\t\\t\\tencodeURIComponent( value == null ? \"\" : value );\\n\\t\\t};\\n\\n\\t// If an array was passed in, assume that it is an array of form elements.\\n\\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\\n\\n\\t\\t// Serialize the form elements\\n\\t\\tjQuery.each( a, function() {\\n\\t\\t\\tadd( this.name, this.value );\\n\\t\\t} );\\n\\n\\t} else {\\n\\n\\t\\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\\n\\t\\t// did it), otherwise encode params recursively.\\n\\t\\tfor ( prefix in a ) {\\n\\t\\t\\tbuildParams( prefix, a[ prefix ], traditional, add );\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the resulting serialization\\n\\treturn s.join( \"&\" );\\n};\\n\\njQuery.fn.extend( {\\n\\tserialize: function() {\\n\\t\\treturn jQuery.param( this.serializeArray() );\\n\\t},\\n\\tserializeArray: function() {\\n\\t\\treturn this.map( function() {\\n\\n\\t\\t\\t// Can add propHook for \"elements\" to filter or add form elements\\n\\t\\t\\tvar elements = jQuery.prop( this, \"elements\" );\\n\\t\\t\\treturn elements ? jQuery.makeArray( elements ) : this;\\n\\t\\t} )\\n\\t\\t.filter( function() {\\n\\t\\t\\tvar type = this.type;\\n\\n\\t\\t\\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\\n\\t\\t\\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\\n\\t\\t\\t\\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\\n\\t\\t\\t\\t( this.checked || !rcheckableType.test( type ) );\\n\\t\\t} )\\n\\t\\t.map( function( i, elem ) {\\n\\t\\t\\tvar val = jQuery( this ).val();\\n\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( Array.isArray( val ) ) {\\n\\t\\t\\t\\treturn jQuery.map( val, function( val ) {\\n\\t\\t\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \"\\\\r\\\\n\" ) };\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \"\\\\r\\\\n\" ) };\\n\\t\\t} ).get();\\n\\t}\\n} );\\n\\n\\nvar\\n\\tr20 = /%20/g,\\n\\trhash = /#.*$/,\\n\\trantiCache = /([?&])_=[^&]*/,\\n\\trheaders = /^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)$/mg,\\n\\n\\t// #7653, #8125, #8152: local protocol detection\\n\\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\\n\\trnoContent = /^(?:GET|HEAD)$/,\\n\\trprotocol = /^\\\\/\\\\//,\\n\\n\\t/* Prefilters\\n\\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\\n\\t * 2) These are called:\\n\\t *    - BEFORE asking for a transport\\n\\t *    - AFTER param serialization (s.data is a string if s.processData is true)\\n\\t * 3) key is the dataType\\n\\t * 4) the catchall symbol \"*\" can be used\\n\\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\\n\\t */\\n\\tprefilters = {},\\n\\n\\t/* Transports bindings\\n\\t * 1) key is the dataType\\n\\t * 2) the catchall symbol \"*\" can be used\\n\\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\\n\\t */\\n\\ttransports = {},\\n\\n\\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\\n\\tallTypes = \"*/\".concat( \"*\" ),\\n\\n\\t// Anchor tag for parsing the document origin\\n\\toriginAnchor = document.createElement( \"a\" );\\n\\toriginAnchor.href = location.href;\\n\\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\\nfunction addToPrefiltersOrTransports( structure ) {\\n\\n\\t// dataTypeExpression is optional and defaults to \"*\"\\n\\treturn function( dataTypeExpression, func ) {\\n\\n\\t\\tif ( typeof dataTypeExpression !== \"string\" ) {\\n\\t\\t\\tfunc = dataTypeExpression;\\n\\t\\t\\tdataTypeExpression = \"*\";\\n\\t\\t}\\n\\n\\t\\tvar dataType,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\\n\\n\\t\\tif ( jQuery.isFunction( func ) ) {\\n\\n\\t\\t\\t// For each dataType in the dataTypeExpression\\n\\t\\t\\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t// Prepend if requested\\n\\t\\t\\t\\tif ( dataType[ 0 ] === \"+\" ) {\\n\\t\\t\\t\\t\\tdataType = dataType.slice( 1 ) || \"*\";\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\\n\\n\\t\\t\\t\\t// Otherwise append\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\n// Base inspection function for prefilters and transports\\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\\n\\n\\tvar inspected = {},\\n\\t\\tseekingTransport = ( structure === transports );\\n\\n\\tfunction inspect( dataType ) {\\n\\t\\tvar selected;\\n\\t\\tinspected[ dataType ] = true;\\n\\t\\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\\n\\t\\t\\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\\n\\t\\t\\tif ( typeof dataTypeOrTransport === \"string\" &&\\n\\t\\t\\t\\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\\n\\n\\t\\t\\t\\toptions.dataTypes.unshift( dataTypeOrTransport );\\n\\t\\t\\t\\tinspect( dataTypeOrTransport );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if ( seekingTransport ) {\\n\\t\\t\\t\\treturn !( selected = dataTypeOrTransport );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\treturn selected;\\n\\t}\\n\\n\\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\\n}\\n\\n// A special extend for ajax options\\n// that takes \"flat\" options (not to be deep extended)\\n// Fixes #9887\\nfunction ajaxExtend( target, src ) {\\n\\tvar key, deep,\\n\\t\\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\\n\\n\\tfor ( key in src ) {\\n\\t\\tif ( src[ key ] !== undefined ) {\\n\\t\\t\\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\\n\\t\\t}\\n\\t}\\n\\tif ( deep ) {\\n\\t\\tjQuery.extend( true, target, deep );\\n\\t}\\n\\n\\treturn target;\\n}\\n\\n/* Handles responses to an ajax request:\\n * - finds the right dataType (mediates between content-type and expected dataType)\\n * - returns the corresponding response\\n */\\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\\n\\n\\tvar ct, type, finalDataType, firstDataType,\\n\\t\\tcontents = s.contents,\\n\\t\\tdataTypes = s.dataTypes;\\n\\n\\t// Remove auto dataType and get content-type in the process\\n\\twhile ( dataTypes[ 0 ] === \"*\" ) {\\n\\t\\tdataTypes.shift();\\n\\t\\tif ( ct === undefined ) {\\n\\t\\t\\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\\n\\t\\t}\\n\\t}\\n\\n\\t// Check if we\\'re dealing with a known content-type\\n\\tif ( ct ) {\\n\\t\\tfor ( type in contents ) {\\n\\t\\t\\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\\n\\t\\t\\t\\tdataTypes.unshift( type );\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Check to see if we have a response for the expected dataType\\n\\tif ( dataTypes[ 0 ] in responses ) {\\n\\t\\tfinalDataType = dataTypes[ 0 ];\\n\\t} else {\\n\\n\\t\\t// Try convertible dataTypes\\n\\t\\tfor ( type in responses ) {\\n\\t\\t\\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\\n\\t\\t\\t\\tfinalDataType = type;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( !firstDataType ) {\\n\\t\\t\\t\\tfirstDataType = type;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Or just use first one\\n\\t\\tfinalDataType = finalDataType || firstDataType;\\n\\t}\\n\\n\\t// If we found a dataType\\n\\t// We add the dataType to the list if needed\\n\\t// and return the corresponding response\\n\\tif ( finalDataType ) {\\n\\t\\tif ( finalDataType !== dataTypes[ 0 ] ) {\\n\\t\\t\\tdataTypes.unshift( finalDataType );\\n\\t\\t}\\n\\t\\treturn responses[ finalDataType ];\\n\\t}\\n}\\n\\n/* Chain conversions given the request and the original response\\n * Also sets the responseXXX fields on the jqXHR instance\\n */\\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\\n\\tvar conv2, current, conv, tmp, prev,\\n\\t\\tconverters = {},\\n\\n\\t\\t// Work with a copy of dataTypes in case we need to modify it for conversion\\n\\t\\tdataTypes = s.dataTypes.slice();\\n\\n\\t// Create converters map with lowercased keys\\n\\tif ( dataTypes[ 1 ] ) {\\n\\t\\tfor ( conv in s.converters ) {\\n\\t\\t\\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\\n\\t\\t}\\n\\t}\\n\\n\\tcurrent = dataTypes.shift();\\n\\n\\t// Convert to each sequential dataType\\n\\twhile ( current ) {\\n\\n\\t\\tif ( s.responseFields[ current ] ) {\\n\\t\\t\\tjqXHR[ s.responseFields[ current ] ] = response;\\n\\t\\t}\\n\\n\\t\\t// Apply the dataFilter if provided\\n\\t\\tif ( !prev && isSuccess && s.dataFilter ) {\\n\\t\\t\\tresponse = s.dataFilter( response, s.dataType );\\n\\t\\t}\\n\\n\\t\\tprev = current;\\n\\t\\tcurrent = dataTypes.shift();\\n\\n\\t\\tif ( current ) {\\n\\n\\t\\t\\t// There\\'s only work to do if current dataType is non-auto\\n\\t\\t\\tif ( current === \"*\" ) {\\n\\n\\t\\t\\t\\tcurrent = prev;\\n\\n\\t\\t\\t// Convert response if prev dataType is non-auto and differs from current\\n\\t\\t\\t} else if ( prev !== \"*\" && prev !== current ) {\\n\\n\\t\\t\\t\\t// Seek a direct converter\\n\\t\\t\\t\\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\\n\\n\\t\\t\\t\\t// If none found, seek a pair\\n\\t\\t\\t\\tif ( !conv ) {\\n\\t\\t\\t\\t\\tfor ( conv2 in converters ) {\\n\\n\\t\\t\\t\\t\\t\\t// If conv2 outputs current\\n\\t\\t\\t\\t\\t\\ttmp = conv2.split( \" \" );\\n\\t\\t\\t\\t\\t\\tif ( tmp[ 1 ] === current ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// If prev can be converted to accepted input\\n\\t\\t\\t\\t\\t\\t\\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tconverters[ \"* \" + tmp[ 0 ] ];\\n\\t\\t\\t\\t\\t\\t\\tif ( conv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Condense equivalence converters\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( conv === true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tconv = converters[ conv2 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Otherwise, insert the intermediate dataType\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if ( converters[ conv2 ] !== true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrent = tmp[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdataTypes.unshift( tmp[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Apply converter (if not an equivalence)\\n\\t\\t\\t\\tif ( conv !== true ) {\\n\\n\\t\\t\\t\\t\\t// Unless errors are allowed to bubble, catch and return them\\n\\t\\t\\t\\t\\tif ( conv && s.throws ) {\\n\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\tstate: \"parsererror\",\\n\\t\\t\\t\\t\\t\\t\\t\\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn { state: \"success\", data: response };\\n}\\n\\njQuery.extend( {\\n\\n\\t// Counter for holding the number of active queries\\n\\tactive: 0,\\n\\n\\t// Last-Modified header cache for next request\\n\\tlastModified: {},\\n\\tetag: {},\\n\\n\\tajaxSettings: {\\n\\t\\turl: location.href,\\n\\t\\ttype: \"GET\",\\n\\t\\tisLocal: rlocalProtocol.test( location.protocol ),\\n\\t\\tglobal: true,\\n\\t\\tprocessData: true,\\n\\t\\tasync: true,\\n\\t\\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\\n\\n\\t\\t/*\\n\\t\\ttimeout: 0,\\n\\t\\tdata: null,\\n\\t\\tdataType: null,\\n\\t\\tusername: null,\\n\\t\\tpassword: null,\\n\\t\\tcache: null,\\n\\t\\tthrows: false,\\n\\t\\ttraditional: false,\\n\\t\\theaders: {},\\n\\t\\t*/\\n\\n\\t\\taccepts: {\\n\\t\\t\\t\"*\": allTypes,\\n\\t\\t\\ttext: \"text/plain\",\\n\\t\\t\\thtml: \"text/html\",\\n\\t\\t\\txml: \"application/xml, text/xml\",\\n\\t\\t\\tjson: \"application/json, text/javascript\"\\n\\t\\t},\\n\\n\\t\\tcontents: {\\n\\t\\t\\txml: /\\\\bxml\\\\b/,\\n\\t\\t\\thtml: /\\\\bhtml/,\\n\\t\\t\\tjson: /\\\\bjson\\\\b/\\n\\t\\t},\\n\\n\\t\\tresponseFields: {\\n\\t\\t\\txml: \"responseXML\",\\n\\t\\t\\ttext: \"responseText\",\\n\\t\\t\\tjson: \"responseJSON\"\\n\\t\\t},\\n\\n\\t\\t// Data converters\\n\\t\\t// Keys separate source (or catchall \"*\") and destination types with a single space\\n\\t\\tconverters: {\\n\\n\\t\\t\\t// Convert anything to text\\n\\t\\t\\t\"* text\": String,\\n\\n\\t\\t\\t// Text to html (true = no transformation)\\n\\t\\t\\t\"text html\": true,\\n\\n\\t\\t\\t// Evaluate text as a json expression\\n\\t\\t\\t\"text json\": JSON.parse,\\n\\n\\t\\t\\t// Parse text as xml\\n\\t\\t\\t\"text xml\": jQuery.parseXML\\n\\t\\t},\\n\\n\\t\\t// For options that shouldn\\'t be deep extended:\\n\\t\\t// you can add your own custom options here if\\n\\t\\t// and when you create one that shouldn\\'t be\\n\\t\\t// deep extended (see ajaxExtend)\\n\\t\\tflatOptions: {\\n\\t\\t\\turl: true,\\n\\t\\t\\tcontext: true\\n\\t\\t}\\n\\t},\\n\\n\\t// Creates a full fledged settings object into target\\n\\t// with both ajaxSettings and settings fields.\\n\\t// If target is omitted, writes into ajaxSettings.\\n\\tajaxSetup: function( target, settings ) {\\n\\t\\treturn settings ?\\n\\n\\t\\t\\t// Building a settings object\\n\\t\\t\\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\\n\\n\\t\\t\\t// Extending ajaxSettings\\n\\t\\t\\tajaxExtend( jQuery.ajaxSettings, target );\\n\\t},\\n\\n\\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\\n\\tajaxTransport: addToPrefiltersOrTransports( transports ),\\n\\n\\t// Main method\\n\\tajax: function( url, options ) {\\n\\n\\t\\t// If url is an object, simulate pre-1.5 signature\\n\\t\\tif ( typeof url === \"object\" ) {\\n\\t\\t\\toptions = url;\\n\\t\\t\\turl = undefined;\\n\\t\\t}\\n\\n\\t\\t// Force options to be an object\\n\\t\\toptions = options || {};\\n\\n\\t\\tvar transport,\\n\\n\\t\\t\\t// URL without anti-cache param\\n\\t\\t\\tcacheURL,\\n\\n\\t\\t\\t// Response headers\\n\\t\\t\\tresponseHeadersString,\\n\\t\\t\\tresponseHeaders,\\n\\n\\t\\t\\t// timeout handle\\n\\t\\t\\ttimeoutTimer,\\n\\n\\t\\t\\t// Url cleanup var\\n\\t\\t\\turlAnchor,\\n\\n\\t\\t\\t// Request state (becomes false upon send and true upon completion)\\n\\t\\t\\tcompleted,\\n\\n\\t\\t\\t// To know if global events are to be dispatched\\n\\t\\t\\tfireGlobals,\\n\\n\\t\\t\\t// Loop variable\\n\\t\\t\\ti,\\n\\n\\t\\t\\t// uncached part of the url\\n\\t\\t\\tuncached,\\n\\n\\t\\t\\t// Create the final options object\\n\\t\\t\\ts = jQuery.ajaxSetup( {}, options ),\\n\\n\\t\\t\\t// Callbacks context\\n\\t\\t\\tcallbackContext = s.context || s,\\n\\n\\t\\t\\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\\n\\t\\t\\tglobalEventContext = s.context &&\\n\\t\\t\\t\\t( callbackContext.nodeType || callbackContext.jquery ) ?\\n\\t\\t\\t\\t\\tjQuery( callbackContext ) :\\n\\t\\t\\t\\t\\tjQuery.event,\\n\\n\\t\\t\\t// Deferreds\\n\\t\\t\\tdeferred = jQuery.Deferred(),\\n\\t\\t\\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tstatusCode = s.statusCode || {},\\n\\n\\t\\t\\t// Headers (they are sent all at once)\\n\\t\\t\\trequestHeaders = {},\\n\\t\\t\\trequestHeadersNames = {},\\n\\n\\t\\t\\t// Default abort message\\n\\t\\t\\tstrAbort = \"canceled\",\\n\\n\\t\\t\\t// Fake xhr\\n\\t\\t\\tjqXHR = {\\n\\t\\t\\t\\treadyState: 0,\\n\\n\\t\\t\\t\\t// Builds headers hashtable if needed\\n\\t\\t\\t\\tgetResponseHeader: function( key ) {\\n\\t\\t\\t\\t\\tvar match;\\n\\t\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\t\\tif ( !responseHeaders ) {\\n\\t\\t\\t\\t\\t\\t\\tresponseHeaders = {};\\n\\t\\t\\t\\t\\t\\t\\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmatch = responseHeaders[ key.toLowerCase() ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn match == null ? null : match;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Raw string\\n\\t\\t\\t\\tgetAllResponseHeaders: function() {\\n\\t\\t\\t\\t\\treturn completed ? responseHeadersString : null;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Caches the header\\n\\t\\t\\t\\tsetRequestHeader: function( name, value ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\tname = requestHeadersNames[ name.toLowerCase() ] =\\n\\t\\t\\t\\t\\t\\t\\trequestHeadersNames[ name.toLowerCase() ] || name;\\n\\t\\t\\t\\t\\t\\trequestHeaders[ name ] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Overrides response content-type header\\n\\t\\t\\t\\toverrideMimeType: function( type ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\ts.mimeType = type;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\t\\tstatusCode: function( map ) {\\n\\t\\t\\t\\t\\tvar code;\\n\\t\\t\\t\\t\\tif ( map ) {\\n\\t\\t\\t\\t\\t\\tif ( completed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Execute the appropriate callbacks\\n\\t\\t\\t\\t\\t\\t\\tjqXHR.always( map[ jqXHR.status ] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Lazy-add the new callbacks in a way that preserves old ones\\n\\t\\t\\t\\t\\t\\t\\tfor ( code in map ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Cancel the request\\n\\t\\t\\t\\tabort: function( statusText ) {\\n\\t\\t\\t\\t\\tvar finalText = statusText || strAbort;\\n\\t\\t\\t\\t\\tif ( transport ) {\\n\\t\\t\\t\\t\\t\\ttransport.abort( finalText );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdone( 0, finalText );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t// Attach deferreds\\n\\t\\tdeferred.promise( jqXHR );\\n\\n\\t\\t// Add protocol if not provided (prefilters might expect it)\\n\\t\\t// Handle falsy url in the settings object (#10093: consistency with old signature)\\n\\t\\t// We also use the url parameter if available\\n\\t\\ts.url = ( ( url || s.url || location.href ) + \"\" )\\n\\t\\t\\t.replace( rprotocol, location.protocol + \"//\" );\\n\\n\\t\\t// Alias method option to type as per ticket #12004\\n\\t\\ts.type = options.method || options.type || s.method || s.type;\\n\\n\\t\\t// Extract dataTypes list\\n\\t\\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\\n\\n\\t\\t// A cross-domain request is in order when the origin doesn\\'t match the current origin.\\n\\t\\tif ( s.crossDomain == null ) {\\n\\t\\t\\turlAnchor = document.createElement( \"a\" );\\n\\n\\t\\t\\t// Support: IE <=8 - 11, Edge 12 - 13\\n\\t\\t\\t// IE throws exception on accessing the href property if url is malformed,\\n\\t\\t\\t// e.g. http://example.com:80x/\\n\\t\\t\\ttry {\\n\\t\\t\\t\\turlAnchor.href = s.url;\\n\\n\\t\\t\\t\\t// Support: IE <=8 - 11 only\\n\\t\\t\\t\\t// Anchor\\'s host property isn\\'t correctly set when s.url is relative\\n\\t\\t\\t\\turlAnchor.href = urlAnchor.href;\\n\\t\\t\\t\\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\\n\\t\\t\\t\\t\\turlAnchor.protocol + \"//\" + urlAnchor.host;\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// If there is an error parsing the URL, assume it is crossDomain,\\n\\t\\t\\t\\t// it can be rejected by the transport if it is invalid\\n\\t\\t\\t\\ts.crossDomain = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Convert data if not already a string\\n\\t\\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\\n\\t\\t\\ts.data = jQuery.param( s.data, s.traditional );\\n\\t\\t}\\n\\n\\t\\t// Apply prefilters\\n\\t\\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\\n\\n\\t\\t// If request was aborted inside a prefilter, stop there\\n\\t\\tif ( completed ) {\\n\\t\\t\\treturn jqXHR;\\n\\t\\t}\\n\\n\\t\\t// We can fire global events as of now if asked to\\n\\t\\t// Don\\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\\n\\t\\tfireGlobals = jQuery.event && s.global;\\n\\n\\t\\t// Watch for a new set of requests\\n\\t\\tif ( fireGlobals && jQuery.active++ === 0 ) {\\n\\t\\t\\tjQuery.event.trigger( \"ajaxStart\" );\\n\\t\\t}\\n\\n\\t\\t// Uppercase the type\\n\\t\\ts.type = s.type.toUpperCase();\\n\\n\\t\\t// Determine if request has content\\n\\t\\ts.hasContent = !rnoContent.test( s.type );\\n\\n\\t\\t// Save the URL in case we\\'re toying with the If-Modified-Since\\n\\t\\t// and/or If-None-Match header later on\\n\\t\\t// Remove hash to simplify url manipulation\\n\\t\\tcacheURL = s.url.replace( rhash, \"\" );\\n\\n\\t\\t// More options handling for requests with no content\\n\\t\\tif ( !s.hasContent ) {\\n\\n\\t\\t\\t// Remember the hash so we can put it back\\n\\t\\t\\tuncached = s.url.slice( cacheURL.length );\\n\\n\\t\\t\\t// If data is available, append data to url\\n\\t\\t\\tif ( s.data ) {\\n\\t\\t\\t\\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\\n\\n\\t\\t\\t\\t// #9682: remove data so that it\\'s not used in an eventual retry\\n\\t\\t\\t\\tdelete s.data;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add or update anti-cache param if needed\\n\\t\\t\\tif ( s.cache === false ) {\\n\\t\\t\\t\\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\\n\\t\\t\\t\\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\\n\\t\\t\\ts.url = cacheURL + uncached;\\n\\n\\t\\t// Change \\'%20\\' to \\'+\\' if this is encoded form body content (gh-2658)\\n\\t\\t} else if ( s.data && s.processData &&\\n\\t\\t\\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\\n\\t\\t\\ts.data = s.data.replace( r20, \"+\" );\\n\\t\\t}\\n\\n\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\tif ( s.ifModified ) {\\n\\t\\t\\tif ( jQuery.lastModified[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t\\tif ( jQuery.etag[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Set the correct header, if data is being sent\\n\\t\\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\\n\\t\\t\\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\\n\\t\\t}\\n\\n\\t\\t// Set the Accepts header for the server, depending on the dataType\\n\\t\\tjqXHR.setRequestHeader(\\n\\t\\t\\t\"Accept\",\\n\\t\\t\\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\\n\\t\\t\\t\\ts.accepts[ s.dataTypes[ 0 ] ] +\\n\\t\\t\\t\\t\\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\\n\\t\\t\\t\\ts.accepts[ \"*\" ]\\n\\t\\t);\\n\\n\\t\\t// Check for headers option\\n\\t\\tfor ( i in s.headers ) {\\n\\t\\t\\tjqXHR.setRequestHeader( i, s.headers[ i ] );\\n\\t\\t}\\n\\n\\t\\t// Allow custom headers/mimetypes and early abort\\n\\t\\tif ( s.beforeSend &&\\n\\t\\t\\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\\n\\n\\t\\t\\t// Abort if not done already and return\\n\\t\\t\\treturn jqXHR.abort();\\n\\t\\t}\\n\\n\\t\\t// Aborting is no longer a cancellation\\n\\t\\tstrAbort = \"abort\";\\n\\n\\t\\t// Install callbacks on deferreds\\n\\t\\tcompleteDeferred.add( s.complete );\\n\\t\\tjqXHR.done( s.success );\\n\\t\\tjqXHR.fail( s.error );\\n\\n\\t\\t// Get transport\\n\\t\\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\\n\\n\\t\\t// If no transport, we auto-abort\\n\\t\\tif ( !transport ) {\\n\\t\\t\\tdone( -1, \"No Transport\" );\\n\\t\\t} else {\\n\\t\\t\\tjqXHR.readyState = 1;\\n\\n\\t\\t\\t// Send global event\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If request was aborted inside ajaxSend, stop there\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn jqXHR;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Timeout\\n\\t\\t\\tif ( s.async && s.timeout > 0 ) {\\n\\t\\t\\t\\ttimeoutTimer = window.setTimeout( function() {\\n\\t\\t\\t\\t\\tjqXHR.abort( \"timeout\" );\\n\\t\\t\\t\\t}, s.timeout );\\n\\t\\t\\t}\\n\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tcompleted = false;\\n\\t\\t\\t\\ttransport.send( requestHeaders, done );\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// Rethrow post-completion exceptions\\n\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Propagate others as results\\n\\t\\t\\t\\tdone( -1, e );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Callback for when everything is done\\n\\t\\tfunction done( status, nativeStatusText, responses, headers ) {\\n\\t\\t\\tvar isSuccess, success, error, response, modified,\\n\\t\\t\\t\\tstatusText = nativeStatusText;\\n\\n\\t\\t\\t// Ignore repeat invocations\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcompleted = true;\\n\\n\\t\\t\\t// Clear timeout if it exists\\n\\t\\t\\tif ( timeoutTimer ) {\\n\\t\\t\\t\\twindow.clearTimeout( timeoutTimer );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Dereference transport for early garbage collection\\n\\t\\t\\t// (no matter how long the jqXHR object will be used)\\n\\t\\t\\ttransport = undefined;\\n\\n\\t\\t\\t// Cache response headers\\n\\t\\t\\tresponseHeadersString = headers || \"\";\\n\\n\\t\\t\\t// Set readyState\\n\\t\\t\\tjqXHR.readyState = status > 0 ? 4 : 0;\\n\\n\\t\\t\\t// Determine if successful\\n\\t\\t\\tisSuccess = status >= 200 && status < 300 || status === 304;\\n\\n\\t\\t\\t// Get response data\\n\\t\\t\\tif ( responses ) {\\n\\t\\t\\t\\tresponse = ajaxHandleResponses( s, jqXHR, responses );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert no matter what (that way responseXXX fields are always set)\\n\\t\\t\\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\\n\\n\\t\\t\\t// If successful, handle type chaining\\n\\t\\t\\tif ( isSuccess ) {\\n\\n\\t\\t\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\t\\t\\tif ( s.ifModified ) {\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.lastModified[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \"etag\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.etag[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if no content\\n\\t\\t\\t\\tif ( status === 204 || s.type === \"HEAD\" ) {\\n\\t\\t\\t\\t\\tstatusText = \"nocontent\";\\n\\n\\t\\t\\t\\t// if not modified\\n\\t\\t\\t\\t} else if ( status === 304 ) {\\n\\t\\t\\t\\t\\tstatusText = \"notmodified\";\\n\\n\\t\\t\\t\\t// If we have data, let\\'s convert it\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstatusText = response.state;\\n\\t\\t\\t\\t\\tsuccess = response.data;\\n\\t\\t\\t\\t\\terror = response.error;\\n\\t\\t\\t\\t\\tisSuccess = !error;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Extract error from statusText and normalize for non-aborts\\n\\t\\t\\t\\terror = statusText;\\n\\t\\t\\t\\tif ( status || !statusText ) {\\n\\t\\t\\t\\t\\tstatusText = \"error\";\\n\\t\\t\\t\\t\\tif ( status < 0 ) {\\n\\t\\t\\t\\t\\t\\tstatus = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set data for the fake xhr object\\n\\t\\t\\tjqXHR.status = status;\\n\\t\\t\\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\\n\\n\\t\\t\\t// Success/Error\\n\\t\\t\\tif ( isSuccess ) {\\n\\t\\t\\t\\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tjqXHR.statusCode( statusCode );\\n\\t\\t\\tstatusCode = undefined;\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\\n\\t\\t\\t\\t\\t[ jqXHR, s, isSuccess ? success : error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Complete\\n\\t\\t\\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\\n\\n\\t\\t\\t\\t// Handle the global AJAX counter\\n\\t\\t\\t\\tif ( !( --jQuery.active ) ) {\\n\\t\\t\\t\\t\\tjQuery.event.trigger( \"ajaxStop\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn jqXHR;\\n\\t},\\n\\n\\tgetJSON: function( url, data, callback ) {\\n\\t\\treturn jQuery.get( url, data, callback, \"json\" );\\n\\t},\\n\\n\\tgetScript: function( url, callback ) {\\n\\t\\treturn jQuery.get( url, undefined, callback, \"script\" );\\n\\t}\\n} );\\n\\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\\n\\tjQuery[ method ] = function( url, data, callback, type ) {\\n\\n\\t\\t// Shift arguments if data argument was omitted\\n\\t\\tif ( jQuery.isFunction( data ) ) {\\n\\t\\t\\ttype = type || callback;\\n\\t\\t\\tcallback = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\n\\t\\t// The url can be an options object (which then must have .url)\\n\\t\\treturn jQuery.ajax( jQuery.extend( {\\n\\t\\t\\turl: url,\\n\\t\\t\\ttype: method,\\n\\t\\t\\tdataType: type,\\n\\t\\t\\tdata: data,\\n\\t\\t\\tsuccess: callback\\n\\t\\t}, jQuery.isPlainObject( url ) && url ) );\\n\\t};\\n} );\\n\\n\\njQuery._evalUrl = function( url ) {\\n\\treturn jQuery.ajax( {\\n\\t\\turl: url,\\n\\n\\t\\t// Make this explicit, since user can override this through ajaxSetup (#11264)\\n\\t\\ttype: \"GET\",\\n\\t\\tdataType: \"script\",\\n\\t\\tcache: true,\\n\\t\\tasync: false,\\n\\t\\tglobal: false,\\n\\t\\t\"throws\": true\\n\\t} );\\n};\\n\\n\\njQuery.fn.extend( {\\n\\twrapAll: function( html ) {\\n\\t\\tvar wrap;\\n\\n\\t\\tif ( this[ 0 ] ) {\\n\\t\\t\\tif ( jQuery.isFunction( html ) ) {\\n\\t\\t\\t\\thtml = html.call( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// The elements to wrap the target around\\n\\t\\t\\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\\n\\n\\t\\t\\tif ( this[ 0 ].parentNode ) {\\n\\t\\t\\t\\twrap.insertBefore( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\twrap.map( function() {\\n\\t\\t\\t\\tvar elem = this;\\n\\n\\t\\t\\t\\twhile ( elem.firstElementChild ) {\\n\\t\\t\\t\\t\\telem = elem.firstElementChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn elem;\\n\\t\\t\\t} ).append( this );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\twrapInner: function( html ) {\\n\\t\\tif ( jQuery.isFunction( html ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).wrapInner( html.call( this, i ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar self = jQuery( this ),\\n\\t\\t\\t\\tcontents = self.contents();\\n\\n\\t\\t\\tif ( contents.length ) {\\n\\t\\t\\t\\tcontents.wrapAll( html );\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tself.append( html );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\twrap: function( html ) {\\n\\t\\tvar isFunction = jQuery.isFunction( html );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\\n\\t\\t} );\\n\\t},\\n\\n\\tunwrap: function( selector ) {\\n\\t\\tthis.parent( selector ).not( \"body\" ).each( function() {\\n\\t\\t\\tjQuery( this ).replaceWith( this.childNodes );\\n\\t\\t} );\\n\\t\\treturn this;\\n\\t}\\n} );\\n\\n\\njQuery.expr.pseudos.hidden = function( elem ) {\\n\\treturn !jQuery.expr.pseudos.visible( elem );\\n};\\njQuery.expr.pseudos.visible = function( elem ) {\\n\\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\\n};\\n\\n\\n\\n\\njQuery.ajaxSettings.xhr = function() {\\n\\ttry {\\n\\t\\treturn new window.XMLHttpRequest();\\n\\t} catch ( e ) {}\\n};\\n\\nvar xhrSuccessStatus = {\\n\\n\\t\\t// File protocol always yields status code 0, assume 200\\n\\t\\t0: 200,\\n\\n\\t\\t// Support: IE <=9 only\\n\\t\\t// #1450: sometimes IE returns 1223 when it should be 204\\n\\t\\t1223: 204\\n\\t},\\n\\txhrSupported = jQuery.ajaxSettings.xhr();\\n\\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\\nsupport.ajax = xhrSupported = !!xhrSupported;\\n\\njQuery.ajaxTransport( function( options ) {\\n\\tvar callback, errorCallback;\\n\\n\\t// Cross domain only allowed if supported through XMLHttpRequest\\n\\tif ( support.cors || xhrSupported && !options.crossDomain ) {\\n\\t\\treturn {\\n\\t\\t\\tsend: function( headers, complete ) {\\n\\t\\t\\t\\tvar i,\\n\\t\\t\\t\\t\\txhr = options.xhr();\\n\\n\\t\\t\\t\\txhr.open(\\n\\t\\t\\t\\t\\toptions.type,\\n\\t\\t\\t\\t\\toptions.url,\\n\\t\\t\\t\\t\\toptions.async,\\n\\t\\t\\t\\t\\toptions.username,\\n\\t\\t\\t\\t\\toptions.password\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Apply custom fields if provided\\n\\t\\t\\t\\tif ( options.xhrFields ) {\\n\\t\\t\\t\\t\\tfor ( i in options.xhrFields ) {\\n\\t\\t\\t\\t\\t\\txhr[ i ] = options.xhrFields[ i ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Override mime type if needed\\n\\t\\t\\t\\tif ( options.mimeType && xhr.overrideMimeType ) {\\n\\t\\t\\t\\t\\txhr.overrideMimeType( options.mimeType );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// X-Requested-With header\\n\\t\\t\\t\\t// For cross-domain requests, seeing as conditions for a preflight are\\n\\t\\t\\t\\t// akin to a jigsaw puzzle, we simply never set it to be sure.\\n\\t\\t\\t\\t// (it can always be set on a per-request basis or even using ajaxSetup)\\n\\t\\t\\t\\t// For same-domain requests, won\\'t change header if already provided.\\n\\t\\t\\t\\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\\n\\t\\t\\t\\t\\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Set headers\\n\\t\\t\\t\\tfor ( i in headers ) {\\n\\t\\t\\t\\t\\txhr.setRequestHeader( i, headers[ i ] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Callback\\n\\t\\t\\t\\tcallback = function( type ) {\\n\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\tcallback = errorCallback = xhr.onload =\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( type === \"abort\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.abort();\\n\\t\\t\\t\\t\\t\\t\\t} else if ( type === \"error\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// On a manual native abort, IE9 throws\\n\\t\\t\\t\\t\\t\\t\\t\\t// errors on any property access that is not readyState\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( typeof xhr.status !== \"number\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete( 0, \"error\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// File: protocol always yields status 0; see #8605, #14207\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhrSuccessStatus[ xhr.status ] || xhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// IE9 has no XHR2 but throws on binary (trac-11426)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// For XHR2 non-text, let the caller handle it (gh-2498)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( xhr.responseType || \"text\" ) !== \"text\"  ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof xhr.responseText !== \"string\" ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ binary: xhr.response } :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ text: xhr.responseText },\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.getAllResponseHeaders()\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// Listen to events\\n\\t\\t\\t\\txhr.onload = callback();\\n\\t\\t\\t\\terrorCallback = xhr.onerror = callback( \"error\" );\\n\\n\\t\\t\\t\\t// Support: IE 9 only\\n\\t\\t\\t\\t// Use onreadystatechange to replace onabort\\n\\t\\t\\t\\t// to handle uncaught aborts\\n\\t\\t\\t\\tif ( xhr.onabort !== undefined ) {\\n\\t\\t\\t\\t\\txhr.onabort = errorCallback;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\txhr.onreadystatechange = function() {\\n\\n\\t\\t\\t\\t\\t\\t// Check readyState before timeout as it changes\\n\\t\\t\\t\\t\\t\\tif ( xhr.readyState === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Allow onerror to be called first,\\n\\t\\t\\t\\t\\t\\t\\t// but that will not handle a native abort\\n\\t\\t\\t\\t\\t\\t\\t// Also, save errorCallback to a variable\\n\\t\\t\\t\\t\\t\\t\\t// as xhr.onerror cannot be accessed\\n\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\terrorCallback();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Create the abort callback\\n\\t\\t\\t\\tcallback = callback( \"abort\" );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\t// Do send the request (this may raise an exception)\\n\\t\\t\\t\\t\\txhr.send( options.hasContent && options.data || null );\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t// #14683: Only rethrow if this hasn\\'t been notified as an error yet\\n\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\\njQuery.ajaxPrefilter( function( s ) {\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.contents.script = false;\\n\\t}\\n} );\\n\\n// Install script dataType\\njQuery.ajaxSetup( {\\n\\taccepts: {\\n\\t\\tscript: \"text/javascript, application/javascript, \" +\\n\\t\\t\\t\"application/ecmascript, application/x-ecmascript\"\\n\\t},\\n\\tcontents: {\\n\\t\\tscript: /\\\\b(?:java|ecma)script\\\\b/\\n\\t},\\n\\tconverters: {\\n\\t\\t\"text script\": function( text ) {\\n\\t\\t\\tjQuery.globalEval( text );\\n\\t\\t\\treturn text;\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Handle cache\\'s special case and crossDomain\\njQuery.ajaxPrefilter( \"script\", function( s ) {\\n\\tif ( s.cache === undefined ) {\\n\\t\\ts.cache = false;\\n\\t}\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.type = \"GET\";\\n\\t}\\n} );\\n\\n// Bind script tag hack transport\\njQuery.ajaxTransport( \"script\", function( s ) {\\n\\n\\t// This transport only deals with cross domain requests\\n\\tif ( s.crossDomain ) {\\n\\t\\tvar script, callback;\\n\\t\\treturn {\\n\\t\\t\\tsend: function( _, complete ) {\\n\\t\\t\\t\\tscript = jQuery( \"<script>\" ).prop( {\\n\\t\\t\\t\\t\\tcharset: s.scriptCharset,\\n\\t\\t\\t\\t\\tsrc: s.url\\n\\t\\t\\t\\t} ).on(\\n\\t\\t\\t\\t\\t\"load error\",\\n\\t\\t\\t\\t\\tcallback = function( evt ) {\\n\\t\\t\\t\\t\\t\\tscript.remove();\\n\\t\\t\\t\\t\\t\\tcallback = null;\\n\\t\\t\\t\\t\\t\\tif ( evt ) {\\n\\t\\t\\t\\t\\t\\t\\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Use native DOM manipulation to avoid our domManip AJAX trickery\\n\\t\\t\\t\\tdocument.head.appendChild( script[ 0 ] );\\n\\t\\t\\t},\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\nvar oldCallbacks = [],\\n\\trjsonp = /(=)\\\\?(?=&|$)|\\\\?\\\\?/;\\n\\n// Default jsonp settings\\njQuery.ajaxSetup( {\\n\\tjsonp: \"callback\",\\n\\tjsonpCallback: function() {\\n\\t\\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\\n\\t\\tthis[ callback ] = true;\\n\\t\\treturn callback;\\n\\t}\\n} );\\n\\n// Detect, normalize options and install callbacks for jsonp requests\\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\\n\\n\\tvar callbackName, overwritten, responseContainer,\\n\\t\\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\\n\\t\\t\\t\"url\" :\\n\\t\\t\\ttypeof s.data === \"string\" &&\\n\\t\\t\\t\\t( s.contentType || \"\" )\\n\\t\\t\\t\\t\\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\\n\\t\\t\\t\\trjsonp.test( s.data ) && \"data\"\\n\\t\\t);\\n\\n\\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\\n\\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\\n\\n\\t\\t// Get callback name, remembering preexisting value associated with it\\n\\t\\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\\n\\t\\t\\ts.jsonpCallback() :\\n\\t\\t\\ts.jsonpCallback;\\n\\n\\t\\t// Insert callback into url or form data\\n\\t\\tif ( jsonProp ) {\\n\\t\\t\\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\\n\\t\\t} else if ( s.jsonp !== false ) {\\n\\t\\t\\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\\n\\t\\t}\\n\\n\\t\\t// Use data converter to retrieve json after script execution\\n\\t\\ts.converters[ \"script json\" ] = function() {\\n\\t\\t\\tif ( !responseContainer ) {\\n\\t\\t\\t\\tjQuery.error( callbackName + \" was not called\" );\\n\\t\\t\\t}\\n\\t\\t\\treturn responseContainer[ 0 ];\\n\\t\\t};\\n\\n\\t\\t// Force json dataType\\n\\t\\ts.dataTypes[ 0 ] = \"json\";\\n\\n\\t\\t// Install callback\\n\\t\\toverwritten = window[ callbackName ];\\n\\t\\twindow[ callbackName ] = function() {\\n\\t\\t\\tresponseContainer = arguments;\\n\\t\\t};\\n\\n\\t\\t// Clean-up function (fires after converters)\\n\\t\\tjqXHR.always( function() {\\n\\n\\t\\t\\t// If previous value didn\\'t exist - remove it\\n\\t\\t\\tif ( overwritten === undefined ) {\\n\\t\\t\\t\\tjQuery( window ).removeProp( callbackName );\\n\\n\\t\\t\\t// Otherwise restore preexisting value\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twindow[ callbackName ] = overwritten;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save back as free\\n\\t\\t\\tif ( s[ callbackName ] ) {\\n\\n\\t\\t\\t\\t// Make sure that re-using the options doesn\\'t screw things around\\n\\t\\t\\t\\ts.jsonpCallback = originalSettings.jsonpCallback;\\n\\n\\t\\t\\t\\t// Save the callback name for future use\\n\\t\\t\\t\\toldCallbacks.push( callbackName );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Call if it was a function and we have a response\\n\\t\\t\\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\\n\\t\\t\\t\\toverwritten( responseContainer[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\tresponseContainer = overwritten = undefined;\\n\\t\\t} );\\n\\n\\t\\t// Delegate to script\\n\\t\\treturn \"script\";\\n\\t}\\n} );\\n\\n\\n\\n\\n// Support: Safari 8 only\\n// In Safari 8 documents created via document.implementation.createHTMLDocument\\n// collapse sibling forms: the second one becomes a child of the first one.\\n// Because of that, this security measure has to be disabled in Safari 8.\\n// https://bugs.webkit.org/show_bug.cgi?id=137337\\nsupport.createHTMLDocument = ( function() {\\n\\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\\n\\tbody.innerHTML = \"<form></form><form></form>\";\\n\\treturn body.childNodes.length === 2;\\n} )();\\n\\n\\n// Argument \"data\" should be string of html\\n// context (optional): If specified, the fragment will be created in this context,\\n// defaults to document\\n// keepScripts (optional): If true, will include scripts passed in the html string\\njQuery.parseHTML = function( data, context, keepScripts ) {\\n\\tif ( typeof data !== \"string\" ) {\\n\\t\\treturn [];\\n\\t}\\n\\tif ( typeof context === \"boolean\" ) {\\n\\t\\tkeepScripts = context;\\n\\t\\tcontext = false;\\n\\t}\\n\\n\\tvar base, parsed, scripts;\\n\\n\\tif ( !context ) {\\n\\n\\t\\t// Stop scripts or inline event handlers from being executed immediately\\n\\t\\t// by using document.implementation\\n\\t\\tif ( support.createHTMLDocument ) {\\n\\t\\t\\tcontext = document.implementation.createHTMLDocument( \"\" );\\n\\n\\t\\t\\t// Set the base href for the created document\\n\\t\\t\\t// so any parsed elements with URLs\\n\\t\\t\\t// are based on the document\\'s URL (gh-2965)\\n\\t\\t\\tbase = context.createElement( \"base\" );\\n\\t\\t\\tbase.href = document.location.href;\\n\\t\\t\\tcontext.head.appendChild( base );\\n\\t\\t} else {\\n\\t\\t\\tcontext = document;\\n\\t\\t}\\n\\t}\\n\\n\\tparsed = rsingleTag.exec( data );\\n\\tscripts = !keepScripts && [];\\n\\n\\t// Single tag\\n\\tif ( parsed ) {\\n\\t\\treturn [ context.createElement( parsed[ 1 ] ) ];\\n\\t}\\n\\n\\tparsed = buildFragment( [ data ], context, scripts );\\n\\n\\tif ( scripts && scripts.length ) {\\n\\t\\tjQuery( scripts ).remove();\\n\\t}\\n\\n\\treturn jQuery.merge( [], parsed.childNodes );\\n};\\n\\n\\n/**\\n * Load a url into a page\\n */\\njQuery.fn.load = function( url, params, callback ) {\\n\\tvar selector, type, response,\\n\\t\\tself = this,\\n\\t\\toff = url.indexOf( \" \" );\\n\\n\\tif ( off > -1 ) {\\n\\t\\tselector = stripAndCollapse( url.slice( off ) );\\n\\t\\turl = url.slice( 0, off );\\n\\t}\\n\\n\\t// If it\\'s a function\\n\\tif ( jQuery.isFunction( params ) ) {\\n\\n\\t\\t// We assume that it\\'s the callback\\n\\t\\tcallback = params;\\n\\t\\tparams = undefined;\\n\\n\\t// Otherwise, build a param string\\n\\t} else if ( params && typeof params === \"object\" ) {\\n\\t\\ttype = \"POST\";\\n\\t}\\n\\n\\t// If we have elements to modify, make the request\\n\\tif ( self.length > 0 ) {\\n\\t\\tjQuery.ajax( {\\n\\t\\t\\turl: url,\\n\\n\\t\\t\\t// If \"type\" variable is undefined, then \"GET\" method will be used.\\n\\t\\t\\t// Make value of this field explicit since\\n\\t\\t\\t// user can override it through ajaxSetup method\\n\\t\\t\\ttype: type || \"GET\",\\n\\t\\t\\tdataType: \"html\",\\n\\t\\t\\tdata: params\\n\\t\\t} ).done( function( responseText ) {\\n\\n\\t\\t\\t// Save response for use in complete callback\\n\\t\\t\\tresponse = arguments;\\n\\n\\t\\t\\tself.html( selector ?\\n\\n\\t\\t\\t\\t// If a selector was specified, locate the right elements in a dummy div\\n\\t\\t\\t\\t// Exclude scripts to avoid IE \\'Permission Denied\\' errors\\n\\t\\t\\t\\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\\n\\n\\t\\t\\t\\t// Otherwise use the full result\\n\\t\\t\\t\\tresponseText );\\n\\n\\t\\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\\n\\t\\t// but they are ignored because response was set above.\\n\\t\\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\\n\\t\\t} ).always( callback && function( jqXHR, status ) {\\n\\t\\t\\tself.each( function() {\\n\\t\\t\\t\\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\treturn this;\\n};\\n\\n\\n\\n\\n// Attach a bunch of functions for handling common AJAX events\\njQuery.each( [\\n\\t\"ajaxStart\",\\n\\t\"ajaxStop\",\\n\\t\"ajaxComplete\",\\n\\t\"ajaxError\",\\n\\t\"ajaxSuccess\",\\n\\t\"ajaxSend\"\\n], function( i, type ) {\\n\\tjQuery.fn[ type ] = function( fn ) {\\n\\t\\treturn this.on( type, fn );\\n\\t};\\n} );\\n\\n\\n\\n\\njQuery.expr.pseudos.animated = function( elem ) {\\n\\treturn jQuery.grep( jQuery.timers, function( fn ) {\\n\\t\\treturn elem === fn.elem;\\n\\t} ).length;\\n};\\n\\n\\n\\n\\njQuery.offset = {\\n\\tsetOffset: function( elem, options, i ) {\\n\\t\\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\\n\\t\\t\\tposition = jQuery.css( elem, \"position\" ),\\n\\t\\t\\tcurElem = jQuery( elem ),\\n\\t\\t\\tprops = {};\\n\\n\\t\\t// Set position first, in-case top/left are set even on static elem\\n\\t\\tif ( position === \"static\" ) {\\n\\t\\t\\telem.style.position = \"relative\";\\n\\t\\t}\\n\\n\\t\\tcurOffset = curElem.offset();\\n\\t\\tcurCSSTop = jQuery.css( elem, \"top\" );\\n\\t\\tcurCSSLeft = jQuery.css( elem, \"left\" );\\n\\t\\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\\n\\t\\t\\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\\n\\n\\t\\t// Need to be able to calculate position if either\\n\\t\\t// top or left is auto and position is either absolute or fixed\\n\\t\\tif ( calculatePosition ) {\\n\\t\\t\\tcurPosition = curElem.position();\\n\\t\\t\\tcurTop = curPosition.top;\\n\\t\\t\\tcurLeft = curPosition.left;\\n\\n\\t\\t} else {\\n\\t\\t\\tcurTop = parseFloat( curCSSTop ) || 0;\\n\\t\\t\\tcurLeft = parseFloat( curCSSLeft ) || 0;\\n\\t\\t}\\n\\n\\t\\tif ( jQuery.isFunction( options ) ) {\\n\\n\\t\\t\\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\\n\\t\\t\\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\\n\\t\\t}\\n\\n\\t\\tif ( options.top != null ) {\\n\\t\\t\\tprops.top = ( options.top - curOffset.top ) + curTop;\\n\\t\\t}\\n\\t\\tif ( options.left != null ) {\\n\\t\\t\\tprops.left = ( options.left - curOffset.left ) + curLeft;\\n\\t\\t}\\n\\n\\t\\tif ( \"using\" in options ) {\\n\\t\\t\\toptions.using.call( elem, props );\\n\\n\\t\\t} else {\\n\\t\\t\\tcurElem.css( props );\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.fn.extend( {\\n\\toffset: function( options ) {\\n\\n\\t\\t// Preserve chaining for setter\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\treturn options === undefined ?\\n\\t\\t\\t\\tthis :\\n\\t\\t\\t\\tthis.each( function( i ) {\\n\\t\\t\\t\\t\\tjQuery.offset.setOffset( this, options, i );\\n\\t\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tvar doc, docElem, rect, win,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\\n\\t\\t// Support: IE <=11 only\\n\\t\\t// Running getBoundingClientRect on a\\n\\t\\t// disconnected node in IE throws an error\\n\\t\\tif ( !elem.getClientRects().length ) {\\n\\t\\t\\treturn { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t\\trect = elem.getBoundingClientRect();\\n\\n\\t\\tdoc = elem.ownerDocument;\\n\\t\\tdocElem = doc.documentElement;\\n\\t\\twin = doc.defaultView;\\n\\n\\t\\treturn {\\n\\t\\t\\ttop: rect.top + win.pageYOffset - docElem.clientTop,\\n\\t\\t\\tleft: rect.left + win.pageXOffset - docElem.clientLeft\\n\\t\\t};\\n\\t},\\n\\n\\tposition: function() {\\n\\t\\tif ( !this[ 0 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar offsetParent, offset,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tparentOffset = { top: 0, left: 0 };\\n\\n\\t\\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\\n\\t\\t// because it is its only offset parent\\n\\t\\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\\n\\n\\t\\t\\t// Assume getBoundingClientRect is there when computed position is fixed\\n\\t\\t\\toffset = elem.getBoundingClientRect();\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// Get *real* offsetParent\\n\\t\\t\\toffsetParent = this.offsetParent();\\n\\n\\t\\t\\t// Get correct offsets\\n\\t\\t\\toffset = this.offset();\\n\\t\\t\\tif ( !nodeName( offsetParent[ 0 ], \"html\" ) ) {\\n\\t\\t\\t\\tparentOffset = offsetParent.offset();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add offsetParent borders\\n\\t\\t\\tparentOffset = {\\n\\t\\t\\t\\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\\n\\t\\t\\t\\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Subtract parent offsets and element margins\\n\\t\\treturn {\\n\\t\\t\\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\\n\\t\\t\\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\\n\\t\\t};\\n\\t},\\n\\n\\t// This method will return documentElement in the following cases:\\n\\t// 1) For the element inside the iframe without offsetParent, this method will return\\n\\t//    documentElement of the parent window\\n\\t// 2) For the hidden or detached element\\n\\t// 3) For body or html element, i.e. in case of the html node - it will return itself\\n\\t//\\n\\t// but those exceptions were never presented as a real life use-cases\\n\\t// and might be considered as more preferable results.\\n\\t//\\n\\t// This logic, however, is not guaranteed and can change at any point in the future\\n\\toffsetParent: function() {\\n\\t\\treturn this.map( function() {\\n\\t\\t\\tvar offsetParent = this.offsetParent;\\n\\n\\t\\t\\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\\n\\t\\t\\t\\toffsetParent = offsetParent.offsetParent;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn offsetParent || documentElement;\\n\\t\\t} );\\n\\t}\\n} );\\n\\n// Create scrollLeft and scrollTop methods\\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\\n\\tvar top = \"pageYOffset\" === prop;\\n\\n\\tjQuery.fn[ method ] = function( val ) {\\n\\t\\treturn access( this, function( elem, method, val ) {\\n\\n\\t\\t\\t// Coalesce documents and windows\\n\\t\\t\\tvar win;\\n\\t\\t\\tif ( jQuery.isWindow( elem ) ) {\\n\\t\\t\\t\\twin = elem;\\n\\t\\t\\t} else if ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\twin = elem.defaultView;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( val === undefined ) {\\n\\t\\t\\t\\treturn win ? win[ prop ] : elem[ method ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( win ) {\\n\\t\\t\\t\\twin.scrollTo(\\n\\t\\t\\t\\t\\t!top ? val : win.pageXOffset,\\n\\t\\t\\t\\t\\ttop ? val : win.pageYOffset\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telem[ method ] = val;\\n\\t\\t\\t}\\n\\t\\t}, method, val, arguments.length );\\n\\t};\\n} );\\n\\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\\n// Add the top/left cssHooks using jQuery.fn.position\\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\\n// getComputedStyle returns percent when specified for top/left/bottom/right;\\n// rather than make the css module depend on the offset module, just check for it here\\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\\n\\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\\n\\t\\tfunction( elem, computed ) {\\n\\t\\t\\tif ( computed ) {\\n\\t\\t\\t\\tcomputed = curCSS( elem, prop );\\n\\n\\t\\t\\t\\t// If curCSS returns percentage, fallback to offset\\n\\t\\t\\t\\treturn rnumnonpx.test( computed ) ?\\n\\t\\t\\t\\t\\tjQuery( elem ).position()[ prop ] + \"px\" :\\n\\t\\t\\t\\t\\tcomputed;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t);\\n} );\\n\\n\\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\\n\\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\\n\\t\\tfunction( defaultExtra, funcName ) {\\n\\n\\t\\t// Margin is only for outerHeight, outerWidth\\n\\t\\tjQuery.fn[ funcName ] = function( margin, value ) {\\n\\t\\t\\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\\n\\t\\t\\t\\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\\n\\n\\t\\t\\treturn access( this, function( elem, type, value ) {\\n\\t\\t\\t\\tvar doc;\\n\\n\\t\\t\\t\\tif ( jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\\n\\t\\t\\t\\t\\treturn funcName.indexOf( \"outer\" ) === 0 ?\\n\\t\\t\\t\\t\\t\\telem[ \"inner\" + name ] :\\n\\t\\t\\t\\t\\t\\telem.document.documentElement[ \"client\" + name ];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Get document width or height\\n\\t\\t\\t\\tif ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\t\\tdoc = elem.documentElement;\\n\\n\\t\\t\\t\\t\\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\\n\\t\\t\\t\\t\\t// whichever is greatest\\n\\t\\t\\t\\t\\treturn Math.max(\\n\\t\\t\\t\\t\\t\\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\\n\\t\\t\\t\\t\\t\\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\\n\\t\\t\\t\\t\\t\\tdoc[ \"client\" + name ]\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn value === undefined ?\\n\\n\\t\\t\\t\\t\\t// Get width or height on the element, requesting but not forcing parseFloat\\n\\t\\t\\t\\t\\tjQuery.css( elem, type, extra ) :\\n\\n\\t\\t\\t\\t\\t// Set width or height on the element\\n\\t\\t\\t\\t\\tjQuery.style( elem, type, value, extra );\\n\\t\\t\\t}, type, chainable ? margin : undefined, chainable );\\n\\t\\t};\\n\\t} );\\n} );\\n\\n\\njQuery.fn.extend( {\\n\\n\\tbind: function( types, data, fn ) {\\n\\t\\treturn this.on( types, null, data, fn );\\n\\t},\\n\\tunbind: function( types, fn ) {\\n\\t\\treturn this.off( types, null, fn );\\n\\t},\\n\\n\\tdelegate: function( selector, types, data, fn ) {\\n\\t\\treturn this.on( types, selector, data, fn );\\n\\t},\\n\\tundelegate: function( selector, types, fn ) {\\n\\n\\t\\t// ( namespace ) or ( selector, types [, fn] )\\n\\t\\treturn arguments.length === 1 ?\\n\\t\\t\\tthis.off( selector, \"**\" ) :\\n\\t\\t\\tthis.off( types, selector || \"**\", fn );\\n\\t}\\n} );\\n\\njQuery.holdReady = function( hold ) {\\n\\tif ( hold ) {\\n\\t\\tjQuery.readyWait++;\\n\\t} else {\\n\\t\\tjQuery.ready( true );\\n\\t}\\n};\\njQuery.isArray = Array.isArray;\\njQuery.parseJSON = JSON.parse;\\njQuery.nodeName = nodeName;\\n\\n\\n\\n\\n// Register as a named AMD module, since jQuery can be concatenated with other\\n// files that may use define, but not via a proper concatenation script that\\n// understands anonymous AMD modules. A named AMD is safest and most robust\\n// way to register. Lowercase jquery is used because AMD module names are\\n// derived from file names, and jQuery is normally delivered in a lowercase\\n// file name. Do this after creating the global so that if an AMD module wants\\n// to call noConflict to hide this version of jQuery, it will work.\\n\\n// Note that for maximum portability, libraries that are not jQuery should\\n// declare themselves as anonymous modules, and avoid setting a global if an\\n// AMD loader is present. jQuery is a special case. For more information, see\\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\\n\\nif ( true ) {\\n\\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\\n\\t\\treturn jQuery;\\n\\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n}\\n\\n\\n\\n\\nvar\\n\\n\\t// Map over jQuery in case of overwrite\\n\\t_jQuery = window.jQuery,\\n\\n\\t// Map over the $ in case of overwrite\\n\\t_$ = window.$;\\n\\njQuery.noConflict = function( deep ) {\\n\\tif ( window.$ === jQuery ) {\\n\\t\\twindow.$ = _$;\\n\\t}\\n\\n\\tif ( deep && window.jQuery === jQuery ) {\\n\\t\\twindow.jQuery = _jQuery;\\n\\t}\\n\\n\\treturn jQuery;\\n};\\n\\n// Expose jQuery and $ identifiers, even in AMD\\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\\n// and CommonJS for browser emulators (#13566)\\nif ( !noGlobal ) {\\n\\twindow.jQuery = window.$ = jQuery;\\n}\\n\\n\\n\\n\\nreturn jQuery;\\n} );\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanM/MjdkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMi4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wMy0yMFQxODo1OVpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMi4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZyxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdFx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHRcdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdFx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDgtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiAoXCJmb3JtXCIgaW4gZWxlbSB8fCBcImxhYmVsXCIgaW4gZWxlbSk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW1wbGUgc2VsZWN0b3IgdGhhdCBjYW4gYmUgZmlsdGVyZWQgZGlyZWN0bHksIHJlbW92aW5nIG5vbi1FbGVtZW50c1xuXHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdH1cblxuXHQvLyBDb21wbGV4IHNlbGVjdG9yLCBjb21wYXJlIHRoZSB0d28gc2V0cywgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG5cdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdCAmJiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgalF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsXG5cdFx0c2NhbGUgPSAxLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBqUXVlcnkuaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgbm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggXCI+dGJvZHlcIiwgZWxlbSApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ0b3A6MSU7d2lkdGg6NTAlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZGl2U3R5bGUubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCI7XG5cdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcHJvcGVydHkgbWFwcGVkIGFsb25nIHdoYXQgalF1ZXJ5LmNzc1Byb3BzIHN1Z2dlc3RzIG9yIHRvXG4vLyBhIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXTtcblx0aWYgKCAhcmV0ICkge1xuXHRcdHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xuXHR9XG5cdHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGksXG5cdFx0dmFsID0gMDtcblxuXHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0aWYgKCBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdGkgPSA0O1xuXG5cdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0fSBlbHNlIHtcblx0XHRpID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgdmFsdWVJc0JvcmRlckJveCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcblx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9IZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdGlmICggdmFsID09PSBcImF1dG9cIiApIHtcblx0XHR2YWwgPSBlbGVtWyBcIm9mZnNldFwiICsgbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICkgXTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRqUXVlcnkucHJveHkoIHJlc3VsdC5zdG9wLCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jLCBkb2NFbGVtLCByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdHdpbiA9IGRvYy5kZWZhdWx0VmlldztcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7XG5cdFx0XHRcdHRvcDogcGFyZW50T2Zmc2V0LnRvcCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKSxcblx0XHRcdFx0bGVmdDogcGFyZW50T2Zmc2V0LmxlZnQgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA4NjRcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9')\n},965:function(module,exports){eval(\"module.exports = \\\".cv-content {\\\\n  flex: 1; }\\\\n\\\\nmain {\\\\n  display: block;\\\\n  flex: 1;\\\\n  font-family: Arial, Helvetica, sans-serif;\\\\n  margin-top: 50px;\\\\n  padding: 1em;\\\\n  text-align: center; }\\\\n\\\\nh1 {\\\\n  font-family: 'Tangerine', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\\\\n  font-size: 4.8rem; }\\\\n\\\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9hcHAuY29tcG9uZW50LnNjc3M/ODk3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLmN2LWNvbnRlbnQge1xcbiAgZmxleDogMTsgfVxcblxcbm1haW4ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbGV4OiAxO1xcbiAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxuICBtYXJnaW4tdG9wOiA1MHB4O1xcbiAgcGFkZGluZzogMWVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuXFxuaDEge1xcbiAgZm9udC1mYW1pbHk6ICdUYW5nZXJpbmUnLCAnU2Vnb2UgVUknLCBUYWhvbWEsIEdlbmV2YSwgVmVyZGFuYSwgc2Fucy1zZXJpZjtcXG4gIGZvbnQtc2l6ZTogNC44cmVtOyB9XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvYXBwLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSA5NjVcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\")},966:function(module,exports){eval('module.exports = \".cv-editor {\\\\n  background-color: #fff;\\\\n  color: #222831; }\\\\n  .cv-editor .ql-container {\\\\n    min-height: 28rem; }\\\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ibG9nLWVkaXQvYmxvZy1lZGl0LmNvbXBvbmVudC5zY3NzPzk4NzEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi5jdi1lZGl0b3Ige1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGNvbG9yOiAjMjIyODMxOyB9XFxuICAuY3YtZWRpdG9yIC5xbC1jb250YWluZXIge1xcbiAgICBtaW4taGVpZ2h0OiAyOHJlbTsgfVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2Jsb2ctZWRpdC9ibG9nLWVkaXQuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDk2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9')},967:function(module,exports){eval('module.exports = \".css-gradient {\\\\n  background: linear-gradient(to bottom left, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9)); }\\\\n\\\\n.container {\\\\n  max-width: 1200px; }\\\\n\\\\n.overflow-auto {\\\\n  overflow: auto; }\\\\n\\\\n.css-animation {\\\\n  background: linear-gradient(to bottom left, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9));\\\\n  width: 100px;\\\\n  height: 100px;\\\\n  animation: cv-css-rotate 1s linear 3s infinite alternate; }\\\\n\\\\n@keyframes cv-css-rotate {\\\\n  0% {\\\\n    background: linear-gradient(to bottom right, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9));\\\\n    transform: rotate(0); }\\\\n  25% {\\\\n    background: linear-gradient(to bottom left, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9));\\\\n    transform: rotate(90deg); }\\\\n  50% {\\\\n    background: linear-gradient(to top left, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9));\\\\n    transform: rotate(180deg); }\\\\n  75% {\\\\n    transform: rotate(90deg);\\\\n    background: linear-gradient(to top right, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9)); }\\\\n  100% {\\\\n    transform: rotate(0deg);\\\\n    background: linear-gradient(to bottom right, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9)); } }\\\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ibG9nLWxpc3QvYmxvZy1saXN0LmNvbXBvbmVudC5zY3NzPzVmY2EiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi5jc3MtZ3JhZGllbnQge1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSBsZWZ0LCByZ2JhKDE0MiwgMjQ2LCAyMjgsIDAuOSksIHJnYmEoNTEsIDIwNCwgMjA0LCAwLjkpKTsgfVxcblxcbi5jb250YWluZXIge1xcbiAgbWF4LXdpZHRoOiAxMjAwcHg7IH1cXG5cXG4ub3ZlcmZsb3ctYXV0byB7XFxuICBvdmVyZmxvdzogYXV0bzsgfVxcblxcbi5jc3MtYW5pbWF0aW9uIHtcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20gbGVmdCwgcmdiYSgxNDIsIDI0NiwgMjI4LCAwLjkpLCByZ2JhKDUxLCAyMDQsIDIwNCwgMC45KSk7XFxuICB3aWR0aDogMTAwcHg7XFxuICBoZWlnaHQ6IDEwMHB4O1xcbiAgYW5pbWF0aW9uOiBjdi1jc3Mtcm90YXRlIDFzIGxpbmVhciAzcyBpbmZpbml0ZSBhbHRlcm5hdGU7IH1cXG5cXG5Aa2V5ZnJhbWVzIGN2LWNzcy1yb3RhdGUge1xcbiAgMCUge1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tIHJpZ2h0LCByZ2JhKDE0MiwgMjQ2LCAyMjgsIDAuOSksIHJnYmEoNTEsIDIwNCwgMjA0LCAwLjkpKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMCk7IH1cXG4gIDI1JSB7XFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20gbGVmdCwgcmdiYSgxNDIsIDI0NiwgMjI4LCAwLjkpLCByZ2JhKDUxLCAyMDQsIDIwNCwgMC45KSk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTsgfVxcbiAgNTAlIHtcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHRvcCBsZWZ0LCByZ2JhKDE0MiwgMjQ2LCAyMjgsIDAuOSksIHJnYmEoNTEsIDIwNCwgMjA0LCAwLjkpKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxcbiAgNzUlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gdG9wIHJpZ2h0LCByZ2JhKDE0MiwgMjQ2LCAyMjgsIDAuOSksIHJnYmEoNTEsIDIwNCwgMjA0LCAwLjkpKTsgfVxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tIHJpZ2h0LCByZ2JhKDE0MiwgMjQ2LCAyMjgsIDAuOSksIHJnYmEoNTEsIDIwNCwgMjA0LCAwLjkpKTsgfSB9XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvYmxvZy1saXN0L2Jsb2ctbGlzdC5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gOTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=')},968:function(module,exports){eval('module.exports = \".node circle {\\\\n  fill: #999; }\\\\n\\\\n.node text {\\\\n  font: 10px sans-serif; }\\\\n\\\\n.node--internal circle {\\\\n  fill: #555; }\\\\n\\\\n.node--internal text {\\\\n  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff; }\\\\n\\\\n.link {\\\\n  fill: none;\\\\n  stroke: #555;\\\\n  stroke-opacity: 0.4;\\\\n  stroke-width: 1.5px; }\\\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9kYXRhdi9kYXRhdi5jb21wb25lbnQuc2Nzcz81ZGQ4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIubm9kZSBjaXJjbGUge1xcbiAgZmlsbDogIzk5OTsgfVxcblxcbi5ub2RlIHRleHQge1xcbiAgZm9udDogMTBweCBzYW5zLXNlcmlmOyB9XFxuXFxuLm5vZGUtLWludGVybmFsIGNpcmNsZSB7XFxuICBmaWxsOiAjNTU1OyB9XFxuXFxuLm5vZGUtLWludGVybmFsIHRleHQge1xcbiAgdGV4dC1zaGFkb3c6IDAgMXB4IDAgI2ZmZiwgMCAtMXB4IDAgI2ZmZiwgMXB4IDAgMCAjZmZmLCAtMXB4IDAgMCAjZmZmOyB9XFxuXFxuLmxpbmsge1xcbiAgZmlsbDogbm9uZTtcXG4gIHN0cm9rZTogIzU1NTtcXG4gIHN0cm9rZS1vcGFjaXR5OiAwLjQ7XFxuICBzdHJva2Utd2lkdGg6IDEuNXB4OyB9XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvZGF0YXYvZGF0YXYuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDk2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9')},969:function(module,exports){eval('module.exports = \"body {\\\\n  color: #61443e;\\\\n  font-family: monospace;\\\\n  font-size: 13px;\\\\n  text-align: center;\\\\n  background-color: #fff;\\\\n  margin: auto;\\\\n  overflow: hidden; }\\\\n\\\\na {\\\\n  color: #a06851; }\\\\n\\\\n#info {\\\\n  position: absolute;\\\\n  top: 0;\\\\n  width: 100%;\\\\n  padding: 5px; }\\\\n\\\\n#oldie {\\\\n  background: #640000;\\\\n  color: #fff;\\\\n  margin-top: 10em; }\\\\n\\\\n#oldie a {\\\\n  color: #fff; }\\\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50LnNjc3M/ZThkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiYm9keSB7XFxuICBjb2xvcjogIzYxNDQzZTtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgbWFyZ2luOiBhdXRvO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblxcbmEge1xcbiAgY29sb3I6ICNhMDY4NTE7IH1cXG5cXG4jaW5mbyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBhZGRpbmc6IDVweDsgfVxcblxcbiNvbGRpZSB7XFxuICBiYWNrZ3JvdW5kOiAjNjQwMDAwO1xcbiAgY29sb3I6ICNmZmY7XFxuICBtYXJnaW4tdG9wOiAxMGVtOyB9XFxuXFxuI29sZGllIGEge1xcbiAgY29sb3I6ICNmZmY7IH1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDk2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9')},970:function(module,exports){eval('module.exports = \".login-bg {\\\\n  background-color: #222831;\\\\n  background-image: url(\\\\\"src/assets/images/usercenter/login_bg_2.jpg\\\\\");\\\\n  background-repeat: no-repeat;\\\\n  background-position: center center;\\\\n  background-size: cover;\\\\n  overflow: hidden; }\\\\n\\\\n.mat-card-header .mat-card-title {\\\\n  font-family: \\'Dancing Script\\', cursive;\\\\n  font-size: 2.8rem; }\\\\n\\\\n.mat-card {\\\\n  box-shadow: 0.3rem 0.3rem 0.3rem #222831, 0.3rem -0.3rem 0.3rem #222831, -0.3rem -0.3rem 0.3rem #222831, -0.3rem 0.3rem 0.3rem #222831;\\\\n  padding: 0; }\\\\n\\\\n.starme {\\\\n  position: relative; }\\\\n  .starme a {\\\\n    color: #fff;\\\\n    background-color: #b83b5e;\\\\n    padding-left: 3rem;\\\\n    padding-right: 3rem;\\\\n    position: absolute;\\\\n    left: -2.4rem;\\\\n    top: 1rem;\\\\n    transform: rotate(-45deg);\\\\n    transition-delay: 1s;\\\\n    font-family: \\\\\"Abel\\\\\", sans-serif; }\\\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9sb2dpbi9sb2dpbi5jb21wb25lbnQuc2Nzcz9lNjJlIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIubG9naW4tYmcge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzIyMjgzMTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwic3JjL2Fzc2V0cy9pbWFnZXMvdXNlcmNlbnRlci9sb2dpbl9iZ18yLmpwZ1xcXCIpO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblxcbi5tYXQtY2FyZC1oZWFkZXIgLm1hdC1jYXJkLXRpdGxlIHtcXG4gIGZvbnQtZmFtaWx5OiAnRGFuY2luZyBTY3JpcHQnLCBjdXJzaXZlO1xcbiAgZm9udC1zaXplOiAyLjhyZW07IH1cXG5cXG4ubWF0LWNhcmQge1xcbiAgYm94LXNoYWRvdzogMC4zcmVtIDAuM3JlbSAwLjNyZW0gIzIyMjgzMSwgMC4zcmVtIC0wLjNyZW0gMC4zcmVtICMyMjI4MzEsIC0wLjNyZW0gLTAuM3JlbSAwLjNyZW0gIzIyMjgzMSwgLTAuM3JlbSAwLjNyZW0gMC4zcmVtICMyMjI4MzE7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxuLnN0YXJtZSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gIC5zdGFybWUgYSB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYjgzYjVlO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDNyZW07XFxuICAgIHBhZGRpbmctcmlnaHQ6IDNyZW07XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogLTIuNHJlbTtcXG4gICAgdG9wOiAxcmVtO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpO1xcbiAgICB0cmFuc2l0aW9uLWRlbGF5OiAxcztcXG4gICAgZm9udC1mYW1pbHk6IFxcXCJBYmVsXFxcIiwgc2Fucy1zZXJpZjsgfVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2xvZ2luL2xvZ2luLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSA5NzBcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==')}},[1264]);","map":"{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"}"}