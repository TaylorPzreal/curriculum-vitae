{"source":"webpackJsonp([2],{1241:function(t,exports,n){n(139),n(147),t.exports=n(1242)},1242:function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function(process) {\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar platform_browser_dynamic_1 = __webpack_require__(259);\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar app_module_1 = __webpack_require__(1243);\\r\\nif (process.env.ENV === 'production') {\\r\\n    core_1.enableProdMode();\\r\\n}\\r\\nplatform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYWluLnRzPzUzZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG5pbXBvcnQgeyBlbmFibGVQcm9kTW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQXBwTW9kdWxlIH0gZnJvbSAnLi9hcHAvYXBwLm1vZHVsZSc7XG5pZiAocHJvY2Vzcy5lbnYuRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgZW5hYmxlUHJvZE1vZGUoKTtcbn1cbnBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL21haW4udHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1242\\n\")},1243:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar platform_browser_1 = __webpack_require__(46);\\r\\nvar animations_1 = __webpack_require__(261);\\r\\nvar material_1 = __webpack_require__(1244);\\r\\n// flex layout\\r\\nvar flex_layout_1 = __webpack_require__(271);\\r\\nvar app_routing_module_1 = __webpack_require__(1246);\\r\\nvar app_component_1 = __webpack_require__(1266);\\r\\nvar login_1 = __webpack_require__(477);\\r\\nvar home_1 = __webpack_require__(478);\\r\\nvar datav_1 = __webpack_require__(479);\\r\\nvar blog_list_1 = __webpack_require__(480);\\r\\nvar blog_edit_1 = __webpack_require__(481);\\r\\nvar AppModule = (function () {\\r\\n    function AppModule() {\\r\\n    }\\r\\n    AppModule = __decorate([\\r\\n        core_1.NgModule({\\r\\n            imports: [\\r\\n                platform_browser_1.BrowserModule,\\r\\n                animations_1.BrowserAnimationsModule,\\r\\n                material_1.MdButtonModule,\\r\\n                material_1.MdCheckboxModule,\\r\\n                material_1.MdToolbarModule,\\r\\n                material_1.MdIconModule,\\r\\n                material_1.MdMenuModule,\\r\\n                material_1.MdProgressSpinnerModule,\\r\\n                material_1.MdCardModule,\\r\\n                material_1.MdInputModule,\\r\\n                material_1.MdGridListModule,\\r\\n                flex_layout_1.FlexLayoutModule,\\r\\n                app_routing_module_1.AppRoutingModule\\r\\n            ],\\r\\n            declarations: [\\r\\n                app_component_1.AppComponent,\\r\\n                login_1.LoginComponent,\\r\\n                home_1.HomeComponent,\\r\\n                datav_1.DatavComponent,\\r\\n                blog_list_1.BlogListComponent,\\r\\n                blog_edit_1.BlogEditComponent\\r\\n            ],\\r\\n            bootstrap: [app_component_1.AppComponent]\\r\\n        })\\r\\n    ], AppModule);\\r\\n    return AppModule;\\r\\n}());\\r\\nexports.AppModule = AppModule;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLm1vZHVsZS50cz8xYWEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEh0dHBNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9odHRwJztcblxuXG5pbXBvcnQgeyBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICBNZEJ1dHRvbk1vZHVsZSxcbiAgTWRDaGVja2JveE1vZHVsZSxcbiAgTWRUb29sYmFyTW9kdWxlLFxuICBNZEljb25Nb2R1bGUsXG4gIE1kTWVudU1vZHVsZSxcbiAgTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUsXG4gIE1kQ2FyZE1vZHVsZSxcbiAgTWRJbnB1dE1vZHVsZSxcbiAgTWRHcmlkTGlzdE1vZHVsZVxufSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5cbi8vIGZsZXggbGF5b3V0XG5pbXBvcnQgeyBGbGV4TGF5b3V0TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZmxleC1sYXlvdXQnO1xuXG5pbXBvcnQgeyBBcHBSb3V0aW5nTW9kdWxlIH0gZnJvbSAnLi9hcHAtcm91dGluZy5tb2R1bGUnO1xuXG5pbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBMb2dpbkNvbXBvbmVudCB9IGZyb20gJy4vbG9naW4nO1xuaW1wb3J0IHsgSG9tZUNvbXBvbmVudCB9IGZyb20gJy4vaG9tZSc7XG5pbXBvcnQgeyBEYXRhdkNvbXBvbmVudCB9IGZyb20gJy4vZGF0YXYnO1xuaW1wb3J0IHsgQmxvZ0xpc3RDb21wb25lbnQgfSBmcm9tICcuL2Jsb2ctbGlzdCc7XG5pbXBvcnQgeyBCbG9nRWRpdENvbXBvbmVudCB9IGZyb20gJy4vYmxvZy1lZGl0JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIEJyb3dzZXJNb2R1bGUsXG4gICAgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUsXG4gICAgTWRCdXR0b25Nb2R1bGUsXG4gICAgTWRDaGVja2JveE1vZHVsZSxcbiAgICBNZFRvb2xiYXJNb2R1bGUsXG4gICAgTWRJY29uTW9kdWxlLFxuICAgIE1kTWVudU1vZHVsZSxcbiAgICBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZSxcbiAgICBNZENhcmRNb2R1bGUsXG4gICAgTWRJbnB1dE1vZHVsZSxcbiAgICBNZEdyaWRMaXN0TW9kdWxlLFxuICAgIEZsZXhMYXlvdXRNb2R1bGUsXG4gICAgQXBwUm91dGluZ01vZHVsZVxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBBcHBDb21wb25lbnQsXG4gICAgTG9naW5Db21wb25lbnQsXG4gICAgSG9tZUNvbXBvbmVudCxcbiAgICBEYXRhdkNvbXBvbmVudCxcbiAgICBCbG9nTGlzdENvbXBvbmVudCxcbiAgICBCbG9nRWRpdENvbXBvbmVudFxuICBdLFxuICBib290c3RyYXA6IFsgQXBwQ29tcG9uZW50IF1cbn0pXG5leHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvdHNsaW50LWxvYWRlcj8/cmVmLS0wLTAhLi9zcmMvYXBwL2FwcC5tb2R1bGUudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFZQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE0QkE7QUFBQTtBQUFBO0FBQUE7QUExQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1243\\n')},1244:function(module,__webpack_exports__,__webpack_require__){\"use strict\"\n;eval('Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GestureConfig\", function() { return GestureConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniqueSelectionDispatcher\", function() { return UniqueSelectionDispatcher; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UNIQUE_SELECTION_DISPATCHER_PROVIDER\", function() { return UNIQUE_SELECTION_DISPATCHER_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdLineModule\", function() { return MdLineModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdLine\", function() { return MdLine; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdLineSetter\", function() { return MdLineSetter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompatibilityModule\", function() { return CompatibilityModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoConflictStyleCompatibilityMode\", function() { return NoConflictStyleCompatibilityMode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCommonModule\", function() { return MdCommonModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MATERIAL_SANITY_CHECKS\", function() { return MATERIAL_SANITY_CHECKS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_PLACEHOLDER_GLOBAL_OPTIONS\", function() { return MD_PLACEHOLDER_GLOBAL_OPTIONS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_ERROR_GLOBAL_OPTIONS\", function() { return MD_ERROR_GLOBAL_OPTIONS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultErrorStateMatcher\", function() { return defaultErrorStateMatcher; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"showOnDirtyErrorStateMatcher\", function() { return showOnDirtyErrorStateMatcher; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCoreModule\", function() { return MdCoreModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdOptionModule\", function() { return MdOptionModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdOptionSelectionChange\", function() { return MdOptionSelectionChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdOption\", function() { return MdOption; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdOptgroupBase\", function() { return MdOptgroupBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdOptgroupMixinBase\", function() { return _MdOptgroupMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdOptgroup\", function() { return MdOptgroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OVERLAY_PROVIDERS\", function() { return OVERLAY_PROVIDERS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayModule\", function() { return OverlayModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Overlay\", function() { return Overlay; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayContainer\", function() { return OverlayContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FullscreenOverlayContainer\", function() { return FullscreenOverlayContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayRef\", function() { return OverlayRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayState\", function() { return OverlayState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConnectedOverlayDirective\", function() { return ConnectedOverlayDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayOrigin\", function() { return OverlayOrigin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewportRuler\", function() { return ViewportRuler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GlobalPositionStrategy\", function() { return GlobalPositionStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConnectedPositionStrategy\", function() { return ConnectedPositionStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConnectionPositionPair\", function() { return ConnectionPositionPair; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollableViewProperties\", function() { return ScrollableViewProperties; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConnectedOverlayPositionChange\", function() { return ConnectedOverlayPositionChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scrollable\", function() { return Scrollable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollDispatcher\", function() { return ScrollDispatcher; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollStrategyOptions\", function() { return ScrollStrategyOptions; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RepositionScrollStrategy\", function() { return RepositionScrollStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CloseScrollStrategy\", function() { return CloseScrollStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoopScrollStrategy\", function() { return NoopScrollStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BlockScrollStrategy\", function() { return BlockScrollStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollDispatchModule\", function() { return ScrollDispatchModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRipple\", function() { return MdRipple; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_RIPPLE_GLOBAL_OPTIONS\", function() { return MD_RIPPLE_GLOBAL_OPTIONS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RippleRef\", function() { return RippleRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RippleState\", function() { return RippleState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RIPPLE_FADE_IN_DURATION\", function() { return RIPPLE_FADE_IN_DURATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RIPPLE_FADE_OUT_DURATION\", function() { return RIPPLE_FADE_OUT_DURATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRippleModule\", function() { return MdRippleModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectionModel\", function() { return SelectionModel; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectionChange\", function() { return SelectionChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StyleModule\", function() { return StyleModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TOUCH_BUFFER_MS\", function() { return TOUCH_BUFFER_MS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FocusOriginMonitor\", function() { return FocusOriginMonitor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkMonitorFocus\", function() { return CdkMonitorFocus; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY\", function() { return FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FOCUS_ORIGIN_MONITOR_PROVIDER\", function() { return FOCUS_ORIGIN_MONITOR_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyCssTransform\", function() { return applyCssTransform; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MATERIAL_COMPATIBILITY_MODE\", function() { return MATERIAL_COMPATIBILITY_MODE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdCompatibilityInvalidPrefixError\", function() { return getMdCompatibilityInvalidPrefixError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAT_ELEMENTS_SELECTOR\", function() { return MAT_ELEMENTS_SELECTOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_ELEMENTS_SELECTOR\", function() { return MD_ELEMENTS_SELECTOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatPrefixRejector\", function() { return MatPrefixRejector; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPrefixRejector\", function() { return MdPrefixRejector; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationCurves\", function() { return AnimationCurves; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationDurations\", function() { return AnimationDurations; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSelectionModule\", function() { return MdSelectionModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPseudoCheckboxBase\", function() { return MdPseudoCheckboxBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdPseudoCheckboxBase\", function() { return _MdPseudoCheckboxBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPseudoCheckbox\", function() { return MdPseudoCheckbox; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NativeDateModule\", function() { return NativeDateModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdNativeDateModule\", function() { return MdNativeDateModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DateAdapter\", function() { return DateAdapter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_DATE_FORMATS\", function() { return MD_DATE_FORMATS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NativeDateAdapter\", function() { return NativeDateAdapter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_NATIVE_DATE_FORMATS\", function() { return MD_NATIVE_DATE_FORMATS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaterialModule\", function() { return MaterialModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdAutocompleteModule\", function() { return MdAutocompleteModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdAutocomplete\", function() { return MdAutocomplete; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AUTOCOMPLETE_OPTION_HEIGHT\", function() { return AUTOCOMPLETE_OPTION_HEIGHT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AUTOCOMPLETE_PANEL_HEIGHT\", function() { return AUTOCOMPLETE_PANEL_HEIGHT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_AUTOCOMPLETE_VALUE_ACCESSOR\", function() { return MD_AUTOCOMPLETE_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdAutocompleteMissingPanelError\", function() { return getMdAutocompleteMissingPanelError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdAutocompleteTrigger\", function() { return MdAutocompleteTrigger; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonModule\", function() { return MdButtonModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonCssMatStyler\", function() { return MdButtonCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRaisedButtonCssMatStyler\", function() { return MdRaisedButtonCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdIconButtonCssMatStyler\", function() { return MdIconButtonCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdFab\", function() { return MdFab; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMiniFab\", function() { return MdMiniFab; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonBase\", function() { return MdButtonBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdButtonMixinBase\", function() { return _MdButtonMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButton\", function() { return MdButton; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdAnchor\", function() { return MdAnchor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggleModule\", function() { return MdButtonToggleModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggleGroupBase\", function() { return MdButtonToggleGroupBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdButtonToggleGroupMixinBase\", function() { return _MdButtonToggleGroupMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR\", function() { return MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggleChange\", function() { return MdButtonToggleChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggleGroup\", function() { return MdButtonToggleGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggleGroupMultiple\", function() { return MdButtonToggleGroupMultiple; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdButtonToggle\", function() { return MdButtonToggle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardModule\", function() { return MdCardModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardContent\", function() { return MdCardContent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardTitle\", function() { return MdCardTitle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardSubtitle\", function() { return MdCardSubtitle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardActions\", function() { return MdCardActions; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardFooter\", function() { return MdCardFooter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardImage\", function() { return MdCardImage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardSmImage\", function() { return MdCardSmImage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardMdImage\", function() { return MdCardMdImage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardLgImage\", function() { return MdCardLgImage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardXlImage\", function() { return MdCardXlImage; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardAvatar\", function() { return MdCardAvatar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCard\", function() { return MdCard; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardHeader\", function() { return MdCardHeader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCardTitleGroup\", function() { return MdCardTitleGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdChipsModule\", function() { return MdChipsModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdChipList\", function() { return MdChipList; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdChipBase\", function() { return MdChipBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdChipMixinBase\", function() { return _MdChipMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdBasicChip\", function() { return MdBasicChip; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdChip\", function() { return MdChip; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCheckboxModule\", function() { return MdCheckboxModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_CHECKBOX_CONTROL_VALUE_ACCESSOR\", function() { return MD_CHECKBOX_CONTROL_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransitionCheckState\", function() { return TransitionCheckState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCheckboxChange\", function() { return MdCheckboxChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCheckboxBase\", function() { return MdCheckboxBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdCheckboxMixinBase\", function() { return _MdCheckboxMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCheckbox\", function() { return MdCheckbox; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepickerModule\", function() { return MdDatepickerModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCalendar\", function() { return MdCalendar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCalendarCell\", function() { return MdCalendarCell; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCalendarBody\", function() { return MdCalendarBody; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepickerContent\", function() { return MdDatepickerContent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepicker\", function() { return MdDatepicker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_DATEPICKER_VALUE_ACCESSOR\", function() { return MD_DATEPICKER_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_DATEPICKER_VALIDATORS\", function() { return MD_DATEPICKER_VALIDATORS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepickerInput\", function() { return MdDatepickerInput; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepickerIntl\", function() { return MdDatepickerIntl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDatepickerToggle\", function() { return MdDatepickerToggle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMonthView\", function() { return MdMonthView; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdYearView\", function() { return MdYearView; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogModule\", function() { return MdDialogModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_DIALOG_DATA\", function() { return MD_DIALOG_DATA; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialog\", function() { return MdDialog; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"throwMdDialogContentAlreadyAttachedError\", function() { return throwMdDialogContentAlreadyAttachedError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogContainer\", function() { return MdDialogContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogClose\", function() { return MdDialogClose; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogTitle\", function() { return MdDialogTitle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogContent\", function() { return MdDialogContent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogActions\", function() { return MdDialogActions; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogConfig\", function() { return MdDialogConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDialogRef\", function() { return MdDialogRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdExpansionModule\", function() { return MdExpansionModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkAccordion\", function() { return CdkAccordion; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdAccordion\", function() { return MdAccordion; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AccordionItem\", function() { return AccordionItem; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdExpansionPanel\", function() { return MdExpansionPanel; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdExpansionPanelActionRow\", function() { return MdExpansionPanelActionRow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdExpansionPanelHeader\", function() { return MdExpansionPanelHeader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdExpansionPanelDescription\", function() { return MdExpansionPanelDescription; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdExpansionPanelTitle\", function() { return MdExpansionPanelTitle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdGridListModule\", function() { return MdGridListModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdGridTile\", function() { return MdGridTile; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdGridList\", function() { return MdGridList; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdIconModule\", function() { return MdIconModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdIconBase\", function() { return MdIconBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdIconMixinBase\", function() { return _MdIconMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdIcon\", function() { return MdIcon; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdIconNameNotFoundError\", function() { return getMdIconNameNotFoundError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdIconNoHttpProviderError\", function() { return getMdIconNoHttpProviderError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdIconFailedToSanitizeError\", function() { return getMdIconFailedToSanitizeError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdIconRegistry\", function() { return MdIconRegistry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ICON_REGISTRY_PROVIDER_FACTORY\", function() { return ICON_REGISTRY_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ICON_REGISTRY_PROVIDER\", function() { return ICON_REGISTRY_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdInputModule\", function() { return MdInputModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTextareaAutosize\", function() { return MdTextareaAutosize; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPlaceholder\", function() { return MdPlaceholder; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdHint\", function() { return MdHint; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdErrorDirective\", function() { return MdErrorDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPrefix\", function() { return MdPrefix; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSuffix\", function() { return MdSuffix; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdInputDirective\", function() { return MdInputDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdInputContainer\", function() { return MdInputContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdInputContainerPlaceholderConflictError\", function() { return getMdInputContainerPlaceholderConflictError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdInputContainerUnsupportedTypeError\", function() { return getMdInputContainerUnsupportedTypeError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdInputContainerDuplicatedHintError\", function() { return getMdInputContainerDuplicatedHintError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdInputContainerMissingMdInputError\", function() { return getMdInputContainerMissingMdInputError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListModule\", function() { return MdListModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListDivider\", function() { return MdListDivider; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdList\", function() { return MdList; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListCssMatStyler\", function() { return MdListCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdNavListCssMatStyler\", function() { return MdNavListCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdDividerCssMatStyler\", function() { return MdDividerCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListAvatarCssMatStyler\", function() { return MdListAvatarCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListIconCssMatStyler\", function() { return MdListIconCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListSubheaderCssMatStyler\", function() { return MdListSubheaderCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdListItem\", function() { return MdListItem; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMenuModule\", function() { return MdMenuModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeInItems\", function() { return fadeInItems; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMenu\", function() { return transformMenu; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMenu\", function() { return MdMenu; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMenuItem\", function() { return MdMenuItem; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdMenuTrigger\", function() { return MdMenuTrigger; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPaginatorModule\", function() { return MdPaginatorModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PageEvent\", function() { return PageEvent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdPaginator\", function() { return MdPaginator; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressBarModule\", function() { return MdProgressBarModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressBar\", function() { return MdProgressBar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressSpinnerModule\", function() { return MdProgressSpinnerModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PROGRESS_SPINNER_STROKE_WIDTH\", function() { return PROGRESS_SPINNER_STROKE_WIDTH; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressSpinnerCssMatStyler\", function() { return MdProgressSpinnerCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressSpinnerBase\", function() { return MdProgressSpinnerBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdProgressSpinnerMixinBase\", function() { return _MdProgressSpinnerMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdProgressSpinner\", function() { return MdProgressSpinner; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSpinner\", function() { return MdSpinner; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioModule\", function() { return MdRadioModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR\", function() { return MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioChange\", function() { return MdRadioChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioGroupBase\", function() { return MdRadioGroupBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdRadioGroupMixinBase\", function() { return _MdRadioGroupMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioGroup\", function() { return MdRadioGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioButtonBase\", function() { return MdRadioButtonBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdRadioButtonMixinBase\", function() { return _MdRadioButtonMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRadioButton\", function() { return MdRadioButton; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSelectModule\", function() { return MdSelectModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeInContent\", function() { return fadeInContent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformPanel\", function() { return transformPanel; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformPlaceholder\", function() { return transformPlaceholder; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_ITEM_HEIGHT\", function() { return SELECT_ITEM_HEIGHT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_PANEL_MAX_HEIGHT\", function() { return SELECT_PANEL_MAX_HEIGHT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_MAX_OPTIONS_DISPLAYED\", function() { return SELECT_MAX_OPTIONS_DISPLAYED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_TRIGGER_HEIGHT\", function() { return SELECT_TRIGGER_HEIGHT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_OPTION_HEIGHT_ADJUSTMENT\", function() { return SELECT_OPTION_HEIGHT_ADJUSTMENT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_PANEL_PADDING_X\", function() { return SELECT_PANEL_PADDING_X; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_PANEL_INDENT_PADDING_X\", function() { return SELECT_PANEL_INDENT_PADDING_X; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_MULTIPLE_PANEL_PADDING_X\", function() { return SELECT_MULTIPLE_PANEL_PADDING_X; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_PANEL_PADDING_Y\", function() { return SELECT_PANEL_PADDING_Y; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SELECT_PANEL_VIEWPORT_PADDING\", function() { return SELECT_PANEL_VIEWPORT_PADDING; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSelectChange\", function() { return MdSelectChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSelectBase\", function() { return MdSelectBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdSelectMixinBase\", function() { return _MdSelectMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSelect\", function() { return MdSelect; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSidenavModule\", function() { return MdSidenavModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"throwMdDuplicatedSidenavError\", function() { return throwMdDuplicatedSidenavError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSidenavToggleResult\", function() { return MdSidenavToggleResult; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSidenav\", function() { return MdSidenav; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSidenavContainer\", function() { return MdSidenavContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSliderModule\", function() { return MdSliderModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_SLIDER_VALUE_ACCESSOR\", function() { return MD_SLIDER_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSliderChange\", function() { return MdSliderChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSliderBase\", function() { return MdSliderBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdSliderMixinBase\", function() { return _MdSliderMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSlider\", function() { return MdSlider; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SliderRenderer\", function() { return SliderRenderer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSlideToggleModule\", function() { return MdSlideToggleModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MD_SLIDE_TOGGLE_VALUE_ACCESSOR\", function() { return MD_SLIDE_TOGGLE_VALUE_ACCESSOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSlideToggleChange\", function() { return MdSlideToggleChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSlideToggleBase\", function() { return MdSlideToggleBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdSlideToggleMixinBase\", function() { return _MdSlideToggleMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSlideToggle\", function() { return MdSlideToggle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSnackBarModule\", function() { return MdSnackBarModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSnackBar\", function() { return MdSnackBar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHOW_ANIMATION\", function() { return SHOW_ANIMATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HIDE_ANIMATION\", function() { return HIDE_ANIMATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSnackBarContainer\", function() { return MdSnackBarContainer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSnackBarConfig\", function() { return MdSnackBarConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSnackBarRef\", function() { return MdSnackBarRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimpleSnackBar\", function() { return SimpleSnackBar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSortModule\", function() { return MdSortModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSortHeader\", function() { return MdSortHeader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSortHeaderIntl\", function() { return MdSortHeaderIntl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdSort\", function() { return MdSort; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTableModule\", function() { return MdTableModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdHeaderCellBase\", function() { return _MdHeaderCellBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdCell\", function() { return _MdCell; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdHeaderCell\", function() { return MdHeaderCell; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdCell\", function() { return MdCell; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdTable\", function() { return _MdTable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTable\", function() { return MdTable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdHeaderRow\", function() { return _MdHeaderRow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdRow\", function() { return _MdRow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdHeaderRow\", function() { return MdHeaderRow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdRow\", function() { return MdRow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabsModule\", function() { return MdTabsModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdInkBar\", function() { return MdInkBar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabBody\", function() { return MdTabBody; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabHeader\", function() { return MdTabHeader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabLabelWrapper\", function() { return MdTabLabelWrapper; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTab\", function() { return MdTab; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabLabel\", function() { return MdTabLabel; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabNav\", function() { return MdTabNav; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabLink\", function() { return MdTabLink; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabChangeEvent\", function() { return MdTabChangeEvent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabGroup\", function() { return MdTabGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTabLinkBase\", function() { return MdTabLinkBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdTabLinkMixinBase\", function() { return _MdTabLinkMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdToolbarModule\", function() { return MdToolbarModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdToolbarRow\", function() { return MdToolbarRow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdToolbarBase\", function() { return MdToolbarBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_MdToolbarMixinBase\", function() { return _MdToolbarMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdToolbar\", function() { return MdToolbar; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTooltipModule\", function() { return MdTooltipModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TOUCHEND_HIDE_DELAY\", function() { return TOUCHEND_HIDE_DELAY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SCROLL_THROTTLE_MS\", function() { return SCROLL_THROTTLE_MS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMdTooltipInvalidPositionError\", function() { return getMdTooltipInvalidPositionError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MdTooltip\", function() { return MdTooltip; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TooltipComponent\", function() { return TooltipComponent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵu\", function() { return mixinColor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵv\", function() { return mixinDisabled; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵh\", function() { return UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵb\", function() { return OVERLAY_CONTAINER_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵa\", function() { return OVERLAY_CONTAINER_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵt\", function() { return OverlayPositionBuilder; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵd\", function() { return VIEWPORT_RULER_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵc\", function() { return VIEWPORT_RULER_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵf\", function() { return SCROLL_DISPATCHER_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵe\", function() { return SCROLL_DISPATCHER_PROVIDER_FACTORY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵg\", function() { return RippleRenderer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵi\", function() { return EXPANSION_PANEL_ANIMATION_TIMING; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵk\", function() { return MdGridAvatarCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵm\", function() { return MdGridTileFooterCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵl\", function() { return MdGridTileHeaderCssMatStyler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵj\", function() { return MdGridTileText; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵn\", function() { return MdMenuItemBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵo\", function() { return _MdMenuItemMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵx\", function() { return MdPaginatorIntl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵr\", function() { return MdTabBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵs\", function() { return _MdTabMixinBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵp\", function() { return MdTabLabelWrapperBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵq\", function() { return _MdTabLabelWrapperMixinBase; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(37);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_cdk__ = __webpack_require__(1245);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__ = __webpack_require__(46);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_common__ = __webpack_require__(65);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__ = __webpack_require__(19);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_Subscription__ = __webpack_require__(21);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_Subscription___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_Subscription__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromEvent__ = __webpack_require__(284);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromEvent___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromEvent__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge__ = __webpack_require__(126);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__ = __webpack_require__(175);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__angular_forms__ = __webpack_require__(263);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__angular_animations__ = __webpack_require__(128);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__angular_http__ = __webpack_require__(262);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_Observable__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_rxjs_Observable__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_observable_throw__ = __webpack_require__(288);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_observable_throw___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_rxjs_observable_throw__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_observable_forkJoin__ = __webpack_require__(171);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_observable_forkJoin___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_rxjs_observable_forkJoin__);\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"coerceBooleanProperty\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"coerceNumberProperty\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_0\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ObserveContentModule\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"I\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ObserveContent\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"H\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Dir\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"q\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Directionality\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"BidiModule\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"d\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Portal\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"N\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"BasePortalHost\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"c\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentPortal\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"n\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplatePortal\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"U\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PortalHostDirective\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"O\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplatePortalDirective\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"V\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PortalModule\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"P\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"DomPortalHost\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"s\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"LiveAnnouncer\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"G\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"LIVE_ANNOUNCER_ELEMENT_TOKEN\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"D\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"LIVE_ANNOUNCER_PROVIDER\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"E\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"InteractivityChecker\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"B\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"isFakeMousedownFromScreenReader\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_6\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"A11yModule\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"a\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PlatformModule\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"M\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Platform\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"getSupportedInputTypes\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_5\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"FocusTrap\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"w\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"FocusTrapFactory\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"z\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"FocusTrapDeprecatedDirective\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"x\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"FocusTrapDirective\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"y\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"UP_ARROW\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"W\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"DOWN_ARROW\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"p\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"RIGHT_ARROW\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Q\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"LEFT_ARROW\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"C\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PAGE_UP\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"K\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PAGE_DOWN\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"J\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"HOME\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"A\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"END\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"t\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ENTER\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"u\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"SPACE\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"S\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"TAB\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"T\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ESCAPE\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"v\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"BACKSPACE\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"b\"]; });\\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"DELETE\", function() { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"o\"]; });\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar MATERIAL_COMPATIBILITY_MODE = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-compatibility-mode\\');\\n/**\\n * Returns an exception to be thrown if the consumer has used\\n * an invalid Material prefix on a component.\\n * \\\\@docs-private\\n * @param {?} prefix\\n * @param {?} nodeName\\n * @return {?}\\n */\\nfunction getMdCompatibilityInvalidPrefixError(prefix, nodeName) {\\n    return Error(\"The \\\\\"\" + prefix + \"-\\\\\" prefix cannot be used in ng-material v1 compatibility mode. \" +\\n        (\"It was used on an \\\\\"\" + nodeName.toLowerCase() + \"\\\\\" element.\"));\\n}\\n/**\\n * Selector that matches all elements that may have style collisions with AngularJS Material.\\n */\\nvar MAT_ELEMENTS_SELECTOR = \"\\\\n  [mat-button],\\\\n  [mat-fab],\\\\n  [mat-icon-button],\\\\n  [mat-mini-fab],\\\\n  [mat-raised-button],\\\\n  [matCardSubtitle],\\\\n  [matCardTitle],\\\\n  [matDialogActions],\\\\n  [matDialogClose],\\\\n  [matDialogContent],\\\\n  [matDialogTitle],\\\\n  [matLine],\\\\n  [matTabLabel],\\\\n  [matTabLink],\\\\n  [matTabNav],\\\\n  [matTooltip],\\\\n  mat-autocomplete,\\\\n  mat-button-toggle,\\\\n  mat-button-toggle,\\\\n  mat-button-toggle-group,\\\\n  mat-card,\\\\n  mat-card-actions,\\\\n  mat-card-content,\\\\n  mat-card-footer,\\\\n  mat-card-header,\\\\n  mat-card-subtitle,\\\\n  mat-card-title,\\\\n  mat-card-title-group,\\\\n  mat-cell,\\\\n  mat-checkbox,\\\\n  mat-chip,\\\\n  mat-dialog-actions,\\\\n  mat-dialog-container,\\\\n  mat-dialog-content,\\\\n  mat-divider,\\\\n  mat-error,\\\\n  mat-grid-list,\\\\n  mat-grid-tile,\\\\n  mat-grid-tile-footer,\\\\n  mat-grid-tile-header,\\\\n  mat-header-cell,\\\\n  mat-hint,\\\\n  mat-icon,\\\\n  mat-list,\\\\n  mat-list-item,\\\\n  mat-menu,\\\\n  mat-nav-list,\\\\n  mat-option,\\\\n  mat-placeholder,\\\\n  mat-progress-bar,\\\\n  mat-pseudo-checkbox,\\\\n  mat-radio-button,\\\\n  mat-radio-group,\\\\n  mat-row,\\\\n  mat-select,\\\\n  mat-sidenav,\\\\n  mat-sidenav-container,\\\\n  mat-slider,\\\\n  mat-spinner,\\\\n  mat-tab,\\\\n  mat-table,\\\\n  mat-tab-group,\\\\n  mat-toolbar\";\\n/**\\n * Selector that matches all elements that may have style collisions with AngularJS Material.\\n */\\nvar MD_ELEMENTS_SELECTOR = \"\\\\n  [md-button],\\\\n  [md-fab],\\\\n  [md-icon-button],\\\\n  [md-mini-fab],\\\\n  [md-raised-button],\\\\n  [mdCardSubtitle],\\\\n  [mdCardTitle],\\\\n  [mdDialogActions],\\\\n  [mdDialogClose],\\\\n  [mdDialogContent],\\\\n  [mdDialogTitle],\\\\n  [mdLine],\\\\n  [mdTabLabel],\\\\n  [mdTabLink],\\\\n  [mdTabNav],\\\\n  [mdTooltip],\\\\n  md-autocomplete,\\\\n  md-button-toggle,\\\\n  md-button-toggle,\\\\n  md-button-toggle-group,\\\\n  md-card,\\\\n  md-card-actions,\\\\n  md-card-content,\\\\n  md-card-footer,\\\\n  md-card-header,\\\\n  md-card-subtitle,\\\\n  md-card-title,\\\\n  md-card-title-group,\\\\n  md-cell,\\\\n  md-checkbox,\\\\n  md-chip,\\\\n  md-dialog-actions,\\\\n  md-dialog-container,\\\\n  md-dialog-content,\\\\n  md-divider,\\\\n  md-error,\\\\n  md-grid-list,\\\\n  md-grid-tile,\\\\n  md-grid-tile-footer,\\\\n  md-grid-tile-header,\\\\n  md-header-cell,\\\\n  md-hint,\\\\n  md-icon,\\\\n  md-list,\\\\n  md-list-item,\\\\n  md-menu,\\\\n  md-nav-list,\\\\n  md-option,\\\\n  md-placeholder,\\\\n  md-progress-bar,\\\\n  md-pseudo-checkbox,\\\\n  md-radio-button,\\\\n  md-radio-group,\\\\n  md-row,\\\\n  md-select,\\\\n  md-sidenav,\\\\n  md-sidenav-container,\\\\n  md-slider,\\\\n  md-spinner,\\\\n  md-tab,\\\\n  md-table,\\\\n  md-tab-group,\\\\n  md-toolbar\";\\n/**\\n * Directive that enforces that the `mat-` prefix cannot be used.\\n */\\nvar MatPrefixRejector = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} isCompatibilityMode\\n     * @param {?} elementRef\\n     */\\n    function MatPrefixRejector(isCompatibilityMode, elementRef) {\\n        if (!isCompatibilityMode) {\\n            throw getMdCompatibilityInvalidPrefixError(\\'mat\\', elementRef.nativeElement.nodeName);\\n        }\\n    }\\n    return MatPrefixRejector;\\n}());\\nMatPrefixRejector.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: MAT_ELEMENTS_SELECTOR },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMatPrefixRejector.ctorParameters = function () { return [\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MATERIAL_COMPATIBILITY_MODE,] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\n/**\\n * Directive that enforces that the `md-` prefix cannot be used.\\n */\\nvar MdPrefixRejector = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} isCompatibilityMode\\n     * @param {?} elementRef\\n     */\\n    function MdPrefixRejector(isCompatibilityMode, elementRef) {\\n        if (isCompatibilityMode) {\\n            throw getMdCompatibilityInvalidPrefixError(\\'md\\', elementRef.nativeElement.nodeName);\\n        }\\n    }\\n    return MdPrefixRejector;\\n}());\\nMdPrefixRejector.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: MD_ELEMENTS_SELECTOR },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPrefixRejector.ctorParameters = function () { return [\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MATERIAL_COMPATIBILITY_MODE,] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\n/**\\n * Module that enforces the default compatibility mode settings. When this module is loaded\\n * without NoConflictStyleCompatibilityMode also being imported, it will throw an error if\\n * there are any uses of the `mat-` prefix.\\n */\\nvar CompatibilityModule = /*@__PURE__*/(function () {\\n    function CompatibilityModule() {\\n    }\\n    return CompatibilityModule;\\n}());\\nCompatibilityModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                declarations: [MatPrefixRejector, MdPrefixRejector],\\n                exports: [MatPrefixRejector, MdPrefixRejector],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCompatibilityModule.ctorParameters = function () { return []; };\\n/**\\n * Module that enforces \"no-conflict\" compatibility mode settings. When this module is loaded,\\n * it will throw an error if there are any uses of the `md-` prefix.\\n */\\nvar NoConflictStyleCompatibilityMode = /*@__PURE__*/(function () {\\n    function NoConflictStyleCompatibilityMode() {\\n    }\\n    return NoConflictStyleCompatibilityMode;\\n}());\\nNoConflictStyleCompatibilityMode.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                providers: [{\\n                        provide: MATERIAL_COMPATIBILITY_MODE, useValue: true,\\n                    }],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nNoConflictStyleCompatibilityMode.ctorParameters = function () { return []; };\\n/**\\n * Injection token that configures whether the Material sanity checks are enabled.\\n */\\nvar MATERIAL_SANITY_CHECKS = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-sanity-checks\\');\\n/**\\n * Module that captures anything that should be loaded and/or run for *all* Angular Material\\n * components. This includes Bidi, compatibility mode, etc.\\n *\\n * This module should be imported to each top-level component module (e.g., MdTabsModule).\\n */\\nvar MdCommonModule = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _document\\n     * @param {?} _sanityChecksEnabled\\n     */\\n    function MdCommonModule(_document, _sanityChecksEnabled) {\\n        this._document = _document;\\n        /**\\n         * Whether we\\'ve done the global sanity checks (e.g. a theme is loaded, there is a doctype).\\n         */\\n        this._hasDoneGlobalChecks = false;\\n        if (_sanityChecksEnabled && !this._hasDoneGlobalChecks && _document && __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"]()) {\\n            this._checkDoctype();\\n            this._checkTheme();\\n            this._hasDoneGlobalChecks = true;\\n        }\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdCommonModule.prototype._checkDoctype = function () {\\n        if (!this._document.doctype) {\\n            console.warn(\\'Current document does not have a doctype. This may cause \\' +\\n                \\'some Angular Material components not to behave as expected.\\');\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdCommonModule.prototype._checkTheme = function () {\\n        if (typeof getComputedStyle === \\'function\\') {\\n            var /** @type {?} */ testElement = this._document.createElement(\\'div\\');\\n            testElement.classList.add(\\'mat-theme-loaded-marker\\');\\n            this._document.body.appendChild(testElement);\\n            if (getComputedStyle(testElement).display !== \\'none\\') {\\n                console.warn(\\'Could not find Angular Material core theme. Most Material \\' +\\n                    \\'components may not work as expected. For more info refer \\' +\\n                    \\'to the theming guide: https://material.angular.io/guide/theming\\');\\n            }\\n            this._document.body.removeChild(testElement);\\n        }\\n    };\\n    return MdCommonModule;\\n}());\\nMdCommonModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [CompatibilityModule, __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"d\" /* BidiModule */]],\\n                exports: [CompatibilityModule, __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"d\" /* BidiModule */]],\\n                providers: [{\\n                        provide: MATERIAL_SANITY_CHECKS, useValue: true,\\n                    }],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCommonModule.ctorParameters = function () { return [\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"DOCUMENT\"],] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MATERIAL_SANITY_CHECKS,] },] },\\n]; };\\n/**\\n * Shared directive to count lines inside a text area, such as a list item.\\n * Line elements can be extracted with a \\\\@ContentChildren(MdLine) query, then\\n * counted by checking the query list\\'s length.\\n */\\nvar MdLine = /*@__PURE__*/(function () {\\n    function MdLine() {\\n    }\\n    return MdLine;\\n}());\\nMdLine.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-line], [mat-line], [mdLine], [matLine]\\',\\n                host: { \\'class\\': \\'mat-line\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdLine.ctorParameters = function () { return []; };\\n/**\\n * Helper that takes a query list of lines and sets the correct class on the host.\\n * \\\\@docs-private\\n */\\nvar MdLineSetter = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _lines\\n     * @param {?} _renderer\\n     * @param {?} _element\\n     */\\n    function MdLineSetter(_lines, _renderer, _element) {\\n        var _this = this;\\n        this._lines = _lines;\\n        this._renderer = _renderer;\\n        this._element = _element;\\n        this._setLineClass(this._lines.length);\\n        this._lines.changes.subscribe(function () {\\n            _this._setLineClass(_this._lines.length);\\n        });\\n    }\\n    /**\\n     * @param {?} count\\n     * @return {?}\\n     */\\n    MdLineSetter.prototype._setLineClass = function (count) {\\n        this._resetClasses();\\n        if (count === 2 || count === 3) {\\n            this._setClass(\"mat-\" + count + \"-line\", true);\\n        }\\n        else if (count > 3) {\\n            this._setClass(\"mat-multi-line\", true);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdLineSetter.prototype._resetClasses = function () {\\n        this._setClass(\\'mat-2-line\\', false);\\n        this._setClass(\\'mat-3-line\\', false);\\n        this._setClass(\\'mat-multi-line\\', false);\\n    };\\n    /**\\n     * @param {?} className\\n     * @param {?} isAdd\\n     * @return {?}\\n     */\\n    MdLineSetter.prototype._setClass = function (className, isAdd) {\\n        if (isAdd) {\\n            this._renderer.addClass(this._element.nativeElement, className);\\n        }\\n        else {\\n            this._renderer.removeClass(this._element.nativeElement, className);\\n        }\\n    };\\n    return MdLineSetter;\\n}());\\nvar MdLineModule = /*@__PURE__*/(function () {\\n    function MdLineModule() {\\n    }\\n    return MdLineModule;\\n}());\\nMdLineModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule],\\n                exports: [MdLine, MdCommonModule],\\n                declarations: [MdLine],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdLineModule.ctorParameters = function () { return []; };\\nvar RippleState = {};\\nRippleState.FADING_IN = 0;\\nRippleState.VISIBLE = 1;\\nRippleState.FADING_OUT = 2;\\nRippleState.HIDDEN = 3;\\nRippleState[RippleState.FADING_IN] = \"FADING_IN\";\\nRippleState[RippleState.VISIBLE] = \"VISIBLE\";\\nRippleState[RippleState.FADING_OUT] = \"FADING_OUT\";\\nRippleState[RippleState.HIDDEN] = \"HIDDEN\";\\n/**\\n * Reference to a previously launched ripple element.\\n */\\nvar RippleRef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} element\\n     * @param {?} config\\n     */\\n    function RippleRef(_renderer, element, config) {\\n        this._renderer = _renderer;\\n        this.element = element;\\n        this.config = config;\\n        /**\\n         * Current state of the ripple reference.\\n         */\\n        this.state = RippleState.HIDDEN;\\n    }\\n    /**\\n     * Fades out the ripple element.\\n     * @return {?}\\n     */\\n    RippleRef.prototype.fadeOut = function () {\\n        this._renderer.fadeOutRipple(this);\\n    };\\n    return RippleRef;\\n}());\\n/**\\n * Fade-in duration for the ripples. Can be modified with the speedFactor option.\\n */\\nvar RIPPLE_FADE_IN_DURATION = 450;\\n/**\\n * Fade-out duration for the ripples in milliseconds. This can\\'t be modified by the speedFactor.\\n */\\nvar RIPPLE_FADE_OUT_DURATION = 400;\\n/**\\n * Helper service that performs DOM manipulations. Not intended to be used outside this module.\\n * The constructor takes a reference to the ripple directive\\'s host element and a map of DOM\\n * event handlers to be installed on the element that triggers ripple animations.\\n * This will eventually become a custom renderer once Angular support exists.\\n * \\\\@docs-private\\n */\\nvar RippleRenderer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementRef\\n     * @param {?} _ngZone\\n     * @param {?} _ruler\\n     * @param {?} platform\\n     */\\n    function RippleRenderer(elementRef, _ngZone, _ruler, platform) {\\n        this._ngZone = _ngZone;\\n        this._ruler = _ruler;\\n        /**\\n         * Whether the mouse is currently down or not.\\n         */\\n        this._isMousedown = false;\\n        /**\\n         * Events to be registered on the trigger element.\\n         */\\n        this._triggerEvents = new Map();\\n        /**\\n         * Set of currently active ripple references.\\n         */\\n        this._activeRipples = new Set();\\n        /**\\n         * Ripple config for all ripples created by events.\\n         */\\n        this.rippleConfig = {};\\n        /**\\n         * Whether mouse ripples should be created or not.\\n         */\\n        this.rippleDisabled = false;\\n        // Only do anything if we\\'re on the browser.\\n        if (platform.isBrowser) {\\n            this._containerElement = elementRef.nativeElement;\\n            // Specify events which need to be registered on the trigger.\\n            this._triggerEvents.set(\\'mousedown\\', this.onMousedown.bind(this));\\n            this._triggerEvents.set(\\'mouseup\\', this.onMouseup.bind(this));\\n            this._triggerEvents.set(\\'mouseleave\\', this.onMouseLeave.bind(this));\\n            // By default use the host element as trigger element.\\n            this.setTriggerElement(this._containerElement);\\n        }\\n    }\\n    /**\\n     * Fades in a ripple at the given coordinates.\\n     * @param {?} pageX\\n     * @param {?} pageY\\n     * @param {?=} config\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.fadeInRipple = function (pageX, pageY, config) {\\n        var _this = this;\\n        if (config === void 0) { config = {}; }\\n        var /** @type {?} */ containerRect = this._containerElement.getBoundingClientRect();\\n        if (config.centered) {\\n            pageX = containerRect.left + containerRect.width / 2;\\n            pageY = containerRect.top + containerRect.height / 2;\\n        }\\n        else {\\n            // Subtract scroll values from the coordinates because calculations below\\n            // are always relative to the viewport rectangle.\\n            var /** @type {?} */ scrollPosition = this._ruler.getViewportScrollPosition();\\n            pageX -= scrollPosition.left;\\n            pageY -= scrollPosition.top;\\n        }\\n        var /** @type {?} */ radius = config.radius || distanceToFurthestCorner(pageX, pageY, containerRect);\\n        var /** @type {?} */ duration = RIPPLE_FADE_IN_DURATION * (1 / (config.speedFactor || 1));\\n        var /** @type {?} */ offsetX = pageX - containerRect.left;\\n        var /** @type {?} */ offsetY = pageY - containerRect.top;\\n        var /** @type {?} */ ripple = document.createElement(\\'div\\');\\n        ripple.classList.add(\\'mat-ripple-element\\');\\n        ripple.style.left = offsetX - radius + \"px\";\\n        ripple.style.top = offsetY - radius + \"px\";\\n        ripple.style.height = radius * 2 + \"px\";\\n        ripple.style.width = radius * 2 + \"px\";\\n        // If the color is not set, the default CSS color will be used.\\n        ripple.style.backgroundColor = config.color || null;\\n        ripple.style.transitionDuration = duration + \"ms\";\\n        this._containerElement.appendChild(ripple);\\n        // By default the browser does not recalculate the styles of dynamically created\\n        // ripple elements. This is critical because then the `scale` would not animate properly.\\n        enforceStyleRecalculation(ripple);\\n        ripple.style.transform = \\'scale(1)\\';\\n        // Exposed reference to the ripple that will be returned.\\n        var /** @type {?} */ rippleRef = new RippleRef(this, ripple, config);\\n        rippleRef.state = RippleState.FADING_IN;\\n        // Add the ripple reference to the list of all active ripples.\\n        this._activeRipples.add(rippleRef);\\n        // Wait for the ripple element to be completely faded in.\\n        // Once it\\'s faded in, the ripple can be hidden immediately if the mouse is released.\\n        this.runTimeoutOutsideZone(function () {\\n            rippleRef.state = RippleState.VISIBLE;\\n            if (!config.persistent && !_this._isMousedown) {\\n                rippleRef.fadeOut();\\n            }\\n        }, duration);\\n        return rippleRef;\\n    };\\n    /**\\n     * Fades out a ripple reference.\\n     * @param {?} rippleRef\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.fadeOutRipple = function (rippleRef) {\\n        // For ripples that are not active anymore, don\\'t re-un the fade-out animation.\\n        if (!this._activeRipples.delete(rippleRef)) {\\n            return;\\n        }\\n        var /** @type {?} */ rippleEl = rippleRef.element;\\n        rippleEl.style.transitionDuration = RIPPLE_FADE_OUT_DURATION + \"ms\";\\n        rippleEl.style.opacity = \\'0\\';\\n        rippleRef.state = RippleState.FADING_OUT;\\n        // Once the ripple faded out, the ripple can be safely removed from the DOM.\\n        this.runTimeoutOutsideZone(function () {\\n            rippleRef.state = RippleState.HIDDEN; /** @type {?} */\\n            ((rippleEl.parentNode)).removeChild(rippleEl);\\n        }, RIPPLE_FADE_OUT_DURATION);\\n    };\\n    /**\\n     * Fades out all currently active ripples.\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.fadeOutAll = function () {\\n        this._activeRipples.forEach(function (ripple) { return ripple.fadeOut(); });\\n    };\\n    /**\\n     * Sets the trigger element and registers the mouse events.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.setTriggerElement = function (element) {\\n        var _this = this;\\n        // Remove all previously register event listeners from the trigger element.\\n        if (this._triggerElement) {\\n            this._triggerEvents.forEach(function (fn, type) {\\n                ((_this._triggerElement)).removeEventListener(type, fn);\\n            });\\n        }\\n        if (element) {\\n            // If the element is not null, register all event listeners on the trigger element.\\n            this._ngZone.runOutsideAngular(function () {\\n                _this._triggerEvents.forEach(function (fn, type) { return element.addEventListener(type, fn); });\\n            });\\n        }\\n        this._triggerElement = element;\\n    };\\n    /**\\n     * Listener being called on mousedown event.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.onMousedown = function (event) {\\n        if (!this.rippleDisabled) {\\n            this._isMousedown = true;\\n            this.fadeInRipple(event.pageX, event.pageY, this.rippleConfig);\\n        }\\n    };\\n    /**\\n     * Listener being called on mouseup event.\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.onMouseup = function () {\\n        this._isMousedown = false;\\n        // Fade-out all ripples that are completely visible and not persistent.\\n        this._activeRipples.forEach(function (ripple) {\\n            if (!ripple.config.persistent && ripple.state === RippleState.VISIBLE) {\\n                ripple.fadeOut();\\n            }\\n        });\\n    };\\n    /**\\n     * Listener being called on mouseleave event.\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.onMouseLeave = function () {\\n        if (this._isMousedown) {\\n            this.onMouseup();\\n        }\\n    };\\n    /**\\n     * Runs a timeout outside of the Angular zone to avoid triggering the change detection.\\n     * @param {?} fn\\n     * @param {?=} delay\\n     * @return {?}\\n     */\\n    RippleRenderer.prototype.runTimeoutOutsideZone = function (fn, delay) {\\n        if (delay === void 0) { delay = 0; }\\n        this._ngZone.runOutsideAngular(function () { return setTimeout(fn, delay); });\\n    };\\n    return RippleRenderer;\\n}());\\n/**\\n * @param {?} element\\n * @return {?}\\n */\\nfunction enforceStyleRecalculation(element) {\\n    // Enforce a style recalculation by calling `getComputedStyle` and accessing any property.\\n    // Calling `getPropertyValue` is important to let optimizers know that this is not a noop.\\n    // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a\\n    window.getComputedStyle(element).getPropertyValue(\\'opacity\\');\\n}\\n/**\\n * Returns the distance from the point (x, y) to the furthest corner of a rectangle.\\n * @param {?} x\\n * @param {?} y\\n * @param {?} rect\\n * @return {?}\\n */\\nfunction distanceToFurthestCorner(x, y, rect) {\\n    var /** @type {?} */ distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));\\n    var /** @type {?} */ distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));\\n    return Math.sqrt(distX * distX + distY * distY);\\n}\\n/**\\n * Time in ms to throttle the scrolling events by default.\\n */\\nvar DEFAULT_SCROLL_TIME = 20;\\n/**\\n * Service contained all registered Scrollable references and emits an event when any one of the\\n * Scrollable references emit a scrolled event.\\n */\\nvar ScrollDispatcher = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _ngZone\\n     * @param {?} _platform\\n     */\\n    function ScrollDispatcher(_ngZone, _platform) {\\n        this._ngZone = _ngZone;\\n        this._platform = _platform;\\n        /**\\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\\n         */\\n        this._scrolled = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        /**\\n         * Keeps track of the global `scroll` and `resize` subscriptions.\\n         */\\n        this._globalSubscription = null;\\n        /**\\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\\n         */\\n        this._scrolledCount = 0;\\n        /**\\n         * Map of all the scrollable references that are registered with the service and their\\n         * scroll event subscriptions.\\n         */\\n        this.scrollableReferences = new Map();\\n    }\\n    /**\\n     * Registers a Scrollable with the service and listens for its scrolled events. When the\\n     * scrollable is scrolled, the service emits the event in its scrolled observable.\\n     * @param {?} scrollable Scrollable instance to be registered.\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype.register = function (scrollable) {\\n        var _this = this;\\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled().subscribe(function () { return _this._notify(); });\\n        this.scrollableReferences.set(scrollable, scrollSubscription);\\n    };\\n    /**\\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\\n     * @param {?} scrollable Scrollable instance to be deregistered.\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype.deregister = function (scrollable) {\\n        var /** @type {?} */ scrollableReference = this.scrollableReferences.get(scrollable);\\n        if (scrollableReference) {\\n            scrollableReference.unsubscribe();\\n            this.scrollableReferences.delete(scrollable);\\n        }\\n    };\\n    /**\\n     * Subscribes to an observable that emits an event whenever any of the registered Scrollable\\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\\n     * to override the default \"throttle\" time.\\n     * @param {?=} auditTimeInMs\\n     * @param {?=} callback\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype.scrolled = function (auditTimeInMs, callback) {\\n        var _this = this;\\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\\n        // Scroll events can only happen on the browser, so do nothing if we\\'re not on the browser.\\n        if (!this._platform.isBrowser) {\\n            return __WEBPACK_IMPORTED_MODULE_6_rxjs_Subscription__[\"Subscription\"].EMPTY;\\n        }\\n        // In the case of a 0ms delay, use an observable without auditTime\\n        // since it does add a perceptible delay in processing overhead.\\n        var /** @type {?} */ observable = auditTimeInMs > 0 ?\\n            __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"X\" /* auditTime */].call(this._scrolled.asObservable(), auditTimeInMs) :\\n            this._scrolled.asObservable();\\n        this._scrolledCount++;\\n        if (!this._globalSubscription) {\\n            this._globalSubscription = this._ngZone.runOutsideAngular(function () {\\n                return __WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge__[\"merge\"](__WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromEvent__[\"fromEvent\"](window.document, \\'scroll\\'), __WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromEvent__[\"fromEvent\"](window, \\'resize\\')).subscribe(function () { return _this._notify(); });\\n            });\\n        }\\n        // Note that we need to do the subscribing from here, in order to be able to remove\\n        // the global event listeners once there are no more subscriptions.\\n        var /** @type {?} */ subscription = observable.subscribe(callback);\\n        subscription.add(function () {\\n            _this._scrolledCount--;\\n            if (_this._globalSubscription && !_this.scrollableReferences.size && !_this._scrolledCount) {\\n                _this._globalSubscription.unsubscribe();\\n                _this._globalSubscription = null;\\n            }\\n        });\\n        return subscription;\\n    };\\n    /**\\n     * Returns all registered Scrollables that contain the provided element.\\n     * @param {?} elementRef\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype.getScrollContainers = function (elementRef) {\\n        var _this = this;\\n        var /** @type {?} */ scrollingContainers = [];\\n        this.scrollableReferences.forEach(function (_subscription, scrollable) {\\n            if (_this.scrollableContainsElement(scrollable, elementRef)) {\\n                scrollingContainers.push(scrollable);\\n            }\\n        });\\n        return scrollingContainers;\\n    };\\n    /**\\n     * Returns true if the element is contained within the provided Scrollable.\\n     * @param {?} scrollable\\n     * @param {?} elementRef\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype.scrollableContainsElement = function (scrollable, elementRef) {\\n        var /** @type {?} */ element = elementRef.nativeElement;\\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\\n        // Traverse through the element parents until we reach null, checking if any of the elements\\n        // are the scrollable\\'s element.\\n        do {\\n            if (element == scrollableElement) {\\n                return true;\\n            }\\n        } while (element = element.parentElement);\\n        return false;\\n    };\\n    /**\\n     * Sends a notification that a scroll event has been fired.\\n     * @return {?}\\n     */\\n    ScrollDispatcher.prototype._notify = function () {\\n        this._scrolled.next();\\n    };\\n    return ScrollDispatcher;\\n}());\\nScrollDispatcher.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nScrollDispatcher.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */], },\\n]; };\\n/**\\n * @param {?} parentDispatcher\\n * @param {?} ngZone\\n * @param {?} platform\\n * @return {?}\\n */\\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\\n    return parentDispatcher || new ScrollDispatcher(ngZone, platform);\\n}\\nvar SCROLL_DISPATCHER_PROVIDER = {\\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\\n    provide: ScrollDispatcher,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), ScrollDispatcher], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */]],\\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\\n};\\n/**\\n * Simple utility for getting the bounds of the browser viewport.\\n * \\\\@docs-private\\n */\\nvar ViewportRuler = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} scrollDispatcher\\n     */\\n    function ViewportRuler(scrollDispatcher) {\\n        var _this = this;\\n        // Subscribe to scroll and resize events and update the document rectangle on changes.\\n        scrollDispatcher.scrolled(0, function () { return _this._cacheViewportGeometry(); });\\n    }\\n    /**\\n     * Gets a ClientRect for the viewport\\'s bounds.\\n     * @param {?=} documentRect\\n     * @return {?}\\n     */\\n    ViewportRuler.prototype.getViewportRect = function (documentRect) {\\n        if (documentRect === void 0) { documentRect = this._documentRect; }\\n        // Cache the document bounding rect so that we don\\'t recompute it for multiple calls.\\n        if (!documentRect) {\\n            this._cacheViewportGeometry();\\n            documentRect = this._documentRect;\\n        }\\n        // Use the document element\\'s bounding rect rather than the window scroll properties\\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\\n        // We use the documentElement instead of the body because, by default (without a css reset)\\n        // browsers typically give the document body an 8px margin, which is not included in\\n        // getBoundingClientRect().\\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition(documentRect);\\n        var /** @type {?} */ height = window.innerHeight;\\n        var /** @type {?} */ width = window.innerWidth;\\n        return {\\n            top: scrollPosition.top,\\n            left: scrollPosition.left,\\n            bottom: scrollPosition.top + height,\\n            right: scrollPosition.left + width,\\n            height: height,\\n            width: width,\\n        };\\n    };\\n    /**\\n     * Gets the (top, left) scroll position of the viewport.\\n     * @param {?=} documentRect\\n     * @return {?}\\n     */\\n    ViewportRuler.prototype.getViewportScrollPosition = function (documentRect) {\\n        if (documentRect === void 0) { documentRect = this._documentRect; }\\n        // Cache the document bounding rect so that we don\\'t recompute it for multiple calls.\\n        if (!documentRect) {\\n            this._cacheViewportGeometry();\\n            documentRect = this._documentRect;\\n        }\\n        // The top-left-corner of the viewport is determined by the scroll position of the document\\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\\n        // `document.documentElement` works consistently, where the `top` and `left` values will\\n        // equal negative the scroll position.\\n        var /** @type {?} */ top = -((documentRect)).top || document.body.scrollTop || window.scrollY ||\\n            document.documentElement.scrollTop || 0;\\n        var /** @type {?} */ left = -((documentRect)).left || document.body.scrollLeft || window.scrollX ||\\n            document.documentElement.scrollLeft || 0;\\n        return { top: top, left: left };\\n    };\\n    /**\\n     * Caches the latest client rectangle of the document element.\\n     * @return {?}\\n     */\\n    ViewportRuler.prototype._cacheViewportGeometry = function () {\\n        this._documentRect = document.documentElement.getBoundingClientRect();\\n    };\\n    return ViewportRuler;\\n}());\\nViewportRuler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nViewportRuler.ctorParameters = function () { return [\\n    { type: ScrollDispatcher, },\\n]; };\\n/**\\n * @param {?} parentRuler\\n * @param {?} scrollDispatcher\\n * @return {?}\\n */\\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, scrollDispatcher) {\\n    return parentRuler || new ViewportRuler(scrollDispatcher);\\n}\\nvar VIEWPORT_RULER_PROVIDER = {\\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\\n    provide: ViewportRuler,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), ViewportRuler], ScrollDispatcher],\\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\\n};\\n/**\\n * Injection token that can be used to specify the global ripple options.\\n */\\nvar MD_RIPPLE_GLOBAL_OPTIONS = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-ripple-global-options\\');\\nvar MdRipple = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementRef\\n     * @param {?} ngZone\\n     * @param {?} ruler\\n     * @param {?} platform\\n     * @param {?} globalOptions\\n     */\\n    function MdRipple(elementRef, ngZone, ruler, platform, globalOptions) {\\n        /**\\n         * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius\\n         * will be the distance from the center of the ripple to the furthest corner of the host element\\'s\\n         * bounding rectangle.\\n         */\\n        this.radius = 0;\\n        /**\\n         * If set, the normal duration of ripple animations is divided by this value. For example,\\n         * setting it to 0.5 will cause the animations to take twice as long.\\n         * A changed speedFactor will not modify the fade-out duration of the ripples.\\n         */\\n        this.speedFactor = 1;\\n        this._rippleRenderer = new RippleRenderer(elementRef, ngZone, ruler, platform);\\n        this._globalOptions = globalOptions ? globalOptions : {};\\n        this._updateRippleRenderer();\\n    }\\n    /**\\n     * @param {?} changes\\n     * @return {?}\\n     */\\n    MdRipple.prototype.ngOnChanges = function (changes) {\\n        if (changes[\\'trigger\\'] && this.trigger) {\\n            this._rippleRenderer.setTriggerElement(this.trigger);\\n        }\\n        this._updateRippleRenderer();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRipple.prototype.ngOnDestroy = function () {\\n        // Set the trigger element to null to cleanup all listeners.\\n        this._rippleRenderer.setTriggerElement(null);\\n    };\\n    /**\\n     * Launches a manual ripple at the specified position.\\n     * @param {?} pageX\\n     * @param {?} pageY\\n     * @param {?=} config\\n     * @return {?}\\n     */\\n    MdRipple.prototype.launch = function (pageX, pageY, config) {\\n        if (config === void 0) { config = this.rippleConfig; }\\n        return this._rippleRenderer.fadeInRipple(pageX, pageY, config);\\n    };\\n    /**\\n     * Fades out all currently showing ripple elements.\\n     * @return {?}\\n     */\\n    MdRipple.prototype.fadeOutAll = function () {\\n        this._rippleRenderer.fadeOutAll();\\n    };\\n    Object.defineProperty(MdRipple.prototype, \"rippleConfig\", {\\n        /**\\n         * Ripple configuration from the directive\\'s input values.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return {\\n                centered: this.centered,\\n                speedFactor: this.speedFactor * (this._globalOptions.baseSpeedFactor || 1),\\n                radius: this.radius,\\n                color: this.color\\n            };\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Updates the ripple renderer with the latest ripple configuration.\\n     * @return {?}\\n     */\\n    MdRipple.prototype._updateRippleRenderer = function () {\\n        this._rippleRenderer.rippleDisabled = this._globalOptions.disabled || this.disabled;\\n        this._rippleRenderer.rippleConfig = this.rippleConfig;\\n    };\\n    return MdRipple;\\n}());\\nMdRipple.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-ripple], [mat-ripple], [mdRipple], [matRipple]\\',\\n                exportAs: \\'mdRipple\\',\\n                host: {\\n                    \\'class\\': \\'mat-ripple\\',\\n                    \\'[class.mat-ripple-unbounded]\\': \\'unbounded\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRipple.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: ViewportRuler, },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */], },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_RIPPLE_GLOBAL_OPTIONS,] },] },\\n]; };\\nMdRipple.propDecorators = {\\n    \\'trigger\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleTrigger\\',] },],\\n    \\'centered\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleCentered\\',] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleDisabled\\',] },],\\n    \\'radius\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleRadius\\',] },],\\n    \\'speedFactor\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleSpeedFactor\\',] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleColor\\',] },],\\n    \\'unbounded\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdRippleUnbounded\\',] },],\\n};\\n/**\\n * Sends an event when the directive\\'s element is scrolled. Registers itself with the\\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\\n * can be listened to through the service.\\n */\\nvar Scrollable = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _scroll\\n     * @param {?} _ngZone\\n     * @param {?} _renderer\\n     */\\n    function Scrollable(_elementRef, _scroll, _ngZone, _renderer) {\\n        this._elementRef = _elementRef;\\n        this._scroll = _scroll;\\n        this._ngZone = _ngZone;\\n        this._renderer = _renderer;\\n        this._elementScrolled = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    Scrollable.prototype.ngOnInit = function () {\\n        var _this = this;\\n        this._scrollListener = this._ngZone.runOutsideAngular(function () {\\n            return _this._renderer.listen(_this.getElementRef().nativeElement, \\'scroll\\', function (event) {\\n                _this._elementScrolled.next(event);\\n            });\\n        });\\n        this._scroll.register(this);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    Scrollable.prototype.ngOnDestroy = function () {\\n        this._scroll.deregister(this);\\n        if (this._scrollListener) {\\n            this._scrollListener();\\n            this._scrollListener = null;\\n        }\\n    };\\n    /**\\n     * Returns observable that emits when a scroll event is fired on the host element.\\n     * @return {?}\\n     */\\n    Scrollable.prototype.elementScrolled = function () {\\n        return this._elementScrolled.asObservable();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    Scrollable.prototype.getElementRef = function () {\\n        return this._elementRef;\\n    };\\n    return Scrollable;\\n}());\\nScrollable.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdk-scrollable], [cdkScrollable]\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nScrollable.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: ScrollDispatcher, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\n/**\\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\\n * @return {?}\\n */\\nfunction getMdScrollStrategyAlreadyAttachedError() {\\n    return Error(\"Scroll strategy has already been attached.\");\\n}\\n/**\\n * Strategy that will close the overlay as soon as the user starts scrolling.\\n */\\nvar CloseScrollStrategy = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _scrollDispatcher\\n     */\\n    function CloseScrollStrategy(_scrollDispatcher) {\\n        this._scrollDispatcher = _scrollDispatcher;\\n        this._scrollSubscription = null;\\n    }\\n    /**\\n     * @param {?} overlayRef\\n     * @return {?}\\n     */\\n    CloseScrollStrategy.prototype.attach = function (overlayRef) {\\n        if (this._overlayRef) {\\n            throw getMdScrollStrategyAlreadyAttachedError();\\n        }\\n        this._overlayRef = overlayRef;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    CloseScrollStrategy.prototype.enable = function () {\\n        var _this = this;\\n        if (!this._scrollSubscription) {\\n            this._scrollSubscription = this._scrollDispatcher.scrolled(0, function () {\\n                if (_this._overlayRef.hasAttached()) {\\n                    _this._overlayRef.detach();\\n                }\\n                _this.disable();\\n            });\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    CloseScrollStrategy.prototype.disable = function () {\\n        if (this._scrollSubscription) {\\n            this._scrollSubscription.unsubscribe();\\n            this._scrollSubscription = null;\\n        }\\n    };\\n    return CloseScrollStrategy;\\n}());\\n/**\\n * Scroll strategy that doesn\\'t do anything.\\n */\\nvar NoopScrollStrategy = /*@__PURE__*/(function () {\\n    function NoopScrollStrategy() {\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    NoopScrollStrategy.prototype.enable = function () { };\\n    /**\\n     * @return {?}\\n     */\\n    NoopScrollStrategy.prototype.disable = function () { };\\n    /**\\n     * @return {?}\\n     */\\n    NoopScrollStrategy.prototype.attach = function () { };\\n    return NoopScrollStrategy;\\n}());\\n/**\\n * Strategy that will prevent the user from scrolling while the overlay is visible.\\n */\\nvar BlockScrollStrategy = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _viewportRuler\\n     */\\n    function BlockScrollStrategy(_viewportRuler) {\\n        this._viewportRuler = _viewportRuler;\\n        this._previousHTMLStyles = { top: \\'\\', left: \\'\\' };\\n        this._isEnabled = false;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    BlockScrollStrategy.prototype.attach = function () { };\\n    /**\\n     * @return {?}\\n     */\\n    BlockScrollStrategy.prototype.enable = function () {\\n        if (this._canBeEnabled()) {\\n            var /** @type {?} */ root = document.documentElement;\\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\\n            // Cache the previous inline styles in case the user had set them.\\n            this._previousHTMLStyles.left = root.style.left || \\'\\';\\n            this._previousHTMLStyles.top = root.style.top || \\'\\';\\n            // Note: we\\'re using the `html` node, instead of the `body`, because the `body` may\\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\\n            root.style.left = -this._previousScrollPosition.left + \"px\";\\n            root.style.top = -this._previousScrollPosition.top + \"px\";\\n            root.classList.add(\\'cdk-global-scrollblock\\');\\n            this._isEnabled = true;\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    BlockScrollStrategy.prototype.disable = function () {\\n        if (this._isEnabled) {\\n            this._isEnabled = false;\\n            document.documentElement.style.left = this._previousHTMLStyles.left;\\n            document.documentElement.style.top = this._previousHTMLStyles.top;\\n            document.documentElement.classList.remove(\\'cdk-global-scrollblock\\');\\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    BlockScrollStrategy.prototype._canBeEnabled = function () {\\n        // Since the scroll strategies can\\'t be singletons, we have to use a global CSS class\\n        // (`cdk-global-scrollblock`) to make sure that we don\\'t try to disable global\\n        // scrolling multiple times.\\n        if (document.documentElement.classList.contains(\\'cdk-global-scrollblock\\') || this._isEnabled) {\\n            return false;\\n        }\\n        var /** @type {?} */ body = document.body;\\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportRect();\\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\\n    };\\n    return BlockScrollStrategy;\\n}());\\n/**\\n * Strategy that will update the element position as the user is scrolling.\\n */\\nvar RepositionScrollStrategy = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _scrollDispatcher\\n     * @param {?=} _config\\n     */\\n    function RepositionScrollStrategy(_scrollDispatcher, _config) {\\n        this._scrollDispatcher = _scrollDispatcher;\\n        this._config = _config;\\n        this._scrollSubscription = null;\\n    }\\n    /**\\n     * @param {?} overlayRef\\n     * @return {?}\\n     */\\n    RepositionScrollStrategy.prototype.attach = function (overlayRef) {\\n        if (this._overlayRef) {\\n            throw getMdScrollStrategyAlreadyAttachedError();\\n        }\\n        this._overlayRef = overlayRef;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    RepositionScrollStrategy.prototype.enable = function () {\\n        var _this = this;\\n        if (!this._scrollSubscription) {\\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle, function () {\\n                _this._overlayRef.updatePosition();\\n            });\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    RepositionScrollStrategy.prototype.disable = function () {\\n        if (this._scrollSubscription) {\\n            this._scrollSubscription.unsubscribe();\\n            this._scrollSubscription = null;\\n        }\\n    };\\n    return RepositionScrollStrategy;\\n}());\\n/**\\n * Options for how an overlay will handle scrolling.\\n *\\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\\n */\\nvar ScrollStrategyOptions = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _scrollDispatcher\\n     * @param {?} _viewportRuler\\n     */\\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler) {\\n        var _this = this;\\n        this._scrollDispatcher = _scrollDispatcher;\\n        this._viewportRuler = _viewportRuler;\\n        /**\\n         * Do nothing on scroll.\\n         */\\n        this.noop = function () { return new NoopScrollStrategy(); };\\n        /**\\n         * Close the overlay as soon as the user scrolls.\\n         */\\n        this.close = function () { return new CloseScrollStrategy(_this._scrollDispatcher); };\\n        /**\\n         * Block scrolling.\\n         */\\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler); };\\n        /**\\n         * Update the overlay\\'s position on scroll.\\n         * @param config Configuration to be used inside the scroll strategy.\\n         * Allows debouncing the reposition calls.\\n         */\\n        this.reposition = function (config) { return new RepositionScrollStrategy(_this._scrollDispatcher, config); };\\n    }\\n    return ScrollStrategyOptions;\\n}());\\nScrollStrategyOptions.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nScrollStrategyOptions.ctorParameters = function () { return [\\n    { type: ScrollDispatcher, },\\n    { type: ViewportRuler, },\\n]; };\\nvar ScrollDispatchModule = /*@__PURE__*/(function () {\\n    function ScrollDispatchModule() {\\n    }\\n    return ScrollDispatchModule;\\n}());\\nScrollDispatchModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"M\" /* PlatformModule */]],\\n                exports: [Scrollable],\\n                declarations: [Scrollable],\\n                providers: [SCROLL_DISPATCHER_PROVIDER, ScrollStrategyOptions],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nScrollDispatchModule.ctorParameters = function () { return []; };\\nvar MdRippleModule = /*@__PURE__*/(function () {\\n    function MdRippleModule() {\\n    }\\n    return MdRippleModule;\\n}());\\nMdRippleModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule, __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"M\" /* PlatformModule */], ScrollDispatchModule],\\n                exports: [MdRipple, MdCommonModule],\\n                declarations: [MdRipple],\\n                providers: [VIEWPORT_RULER_PROVIDER],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRippleModule.ctorParameters = function () { return []; };\\n/**\\n * Mixin to augment a directive with a `color` property.\\n * @template T\\n * @param {?} base\\n * @param {?=} defaultColor\\n * @return {?}\\n */\\nfunction mixinColor(base, defaultColor) {\\n    return (function (_super) {\\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](class_1, _super);\\n        /**\\n         * @param {...?} args\\n         */\\n        function class_1() {\\n            var args = [];\\n            for (var _i = 0; _i < arguments.length; _i++) {\\n                args[_i] = arguments[_i];\\n            }\\n            var _this = _super.apply(this, args) || this;\\n            // Set the default color that can be specified from the mixin.\\n            _this.color = defaultColor;\\n            return _this;\\n        }\\n        Object.defineProperty(class_1.prototype, \"color\", {\\n            /**\\n             * @return {?}\\n             */\\n            get: function () { return this._color; },\\n            /**\\n             * @param {?} value\\n             * @return {?}\\n             */\\n            set: function (value) {\\n                var /** @type {?} */ colorPalette = value || defaultColor;\\n                if (colorPalette !== this._color) {\\n                    if (this._color) {\\n                        this._renderer.removeClass(this._elementRef.nativeElement, \"mat-\" + this._color);\\n                    }\\n                    if (colorPalette) {\\n                        this._renderer.addClass(this._elementRef.nativeElement, \"mat-\" + colorPalette);\\n                    }\\n                    this._color = colorPalette;\\n                }\\n            },\\n            enumerable: true,\\n            configurable: true\\n        });\\n        return class_1;\\n    }(base));\\n}\\n/**\\n * \\\\@docs-private\\n */\\nvar MdPseudoCheckboxBase = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdPseudoCheckboxBase(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n    }\\n    return MdPseudoCheckboxBase;\\n}());\\nvar _MdPseudoCheckboxBase = mixinColor(MdPseudoCheckboxBase, \\'accent\\');\\n/**\\n * Component that shows a simplified checkbox without including any kind of \"real\" checkbox.\\n * Meant to be used when the checkbox is purely decorative and a large number of them will be\\n * included, such as for the options in a multi-select. Uses no SVGs or complex animations.\\n *\\n * Note that this component will be completely invisible to screen-reader users. This is *not*\\n * interchangeable with <md-checkbox> and should *not* be used if the user would directly interact\\n * with the checkbox. The pseudo-checkbox should only be used as an implementation detail of\\n * more complex components that appropriately handle selected / checked state.\\n * \\\\@docs-private\\n */\\nvar MdPseudoCheckbox = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdPseudoCheckbox, _super);\\n    /**\\n     * @param {?} elementRef\\n     * @param {?} renderer\\n     */\\n    function MdPseudoCheckbox(elementRef, renderer) {\\n        var _this = _super.call(this, renderer, elementRef) || this;\\n        /**\\n         * Display state of the checkbox.\\n         */\\n        _this.state = \\'unchecked\\';\\n        /**\\n         * Whether the checkbox is disabled.\\n         */\\n        _this.disabled = false;\\n        return _this;\\n    }\\n    return MdPseudoCheckbox;\\n}(_MdPseudoCheckboxBase));\\nMdPseudoCheckbox.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                selector: \\'md-pseudo-checkbox, mat-pseudo-checkbox\\',\\n                styles: [\".mat-pseudo-checkbox{width:20px;height:20px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;transition:border-color 90ms cubic-bezier(0,0,.2,.1),background-color 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:\\'\\';border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:9px;left:2px;width:16px;opacity:1}.mat-pseudo-checkbox-checked::after{top:5px;left:3px;width:12px;height:5px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1}\"],\\n                inputs: [\\'color\\'],\\n                template: \\'\\',\\n                host: {\\n                    \\'class\\': \\'mat-pseudo-checkbox\\',\\n                    \\'[class.mat-pseudo-checkbox-indeterminate]\\': \\'state === \"indeterminate\"\\',\\n                    \\'[class.mat-pseudo-checkbox-checked]\\': \\'state === \"checked\"\\',\\n                    \\'[class.mat-pseudo-checkbox-disabled]\\': \\'disabled\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPseudoCheckbox.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\nMdPseudoCheckbox.propDecorators = {\\n    \\'state\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdSelectionModule = /*@__PURE__*/(function () {\\n    function MdSelectionModule() {\\n    }\\n    return MdSelectionModule;\\n}());\\nMdSelectionModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                exports: [MdPseudoCheckbox],\\n                declarations: [MdPseudoCheckbox]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSelectionModule.ctorParameters = function () { return []; };\\n/**\\n * Mixin to augment a directive with a `disabled` property.\\n * @template T\\n * @param {?} base\\n * @return {?}\\n */\\nfunction mixinDisabled(base) {\\n    return (function (_super) {\\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](class_2, _super);\\n        /**\\n         * @param {...?} args\\n         */\\n        function class_2() {\\n            var args = [];\\n            for (var _i = 0; _i < arguments.length; _i++) {\\n                args[_i] = arguments[_i];\\n            }\\n            var _this = _super.apply(this, args) || this;\\n            _this._disabled = false;\\n            return _this;\\n        }\\n        Object.defineProperty(class_2.prototype, \"disabled\", {\\n            /**\\n             * @return {?}\\n             */\\n            get: function () { return this._disabled; },\\n            /**\\n             * @param {?} value\\n             * @return {?}\\n             */\\n            set: function (value) { this._disabled = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n            enumerable: true,\\n            configurable: true\\n        });\\n        return class_2;\\n    }(base));\\n}\\n/**\\n * \\\\@docs-private\\n */\\nvar MdOptgroupBase = /*@__PURE__*/(function () {\\n    function MdOptgroupBase() {\\n    }\\n    return MdOptgroupBase;\\n}());\\nvar _MdOptgroupMixinBase = mixinDisabled(MdOptgroupBase);\\n// Counter for unique group ids.\\nvar _uniqueOptgroupIdCounter = 0;\\n/**\\n * Component that is used to group instances of `md-option`.\\n */\\nvar MdOptgroup = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdOptgroup, _super);\\n    function MdOptgroup() {\\n        var _this = _super.apply(this, arguments) || this;\\n        /**\\n         * Unique id for the underlying label.\\n         */\\n        _this._labelId = \"mat-optgroup-label-\" + _uniqueOptgroupIdCounter++;\\n        return _this;\\n    }\\n    return MdOptgroup;\\n}(_MdOptgroupMixinBase));\\nMdOptgroup.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-optgroup, mat-optgroup\\',\\n                template: \"<label class=\\\\\"mat-optgroup-label\\\\\" [id]=\\\\\"_labelId\\\\\">{{ label }}</label><ng-content select=\\\\\"md-option, mat-option\\\\\"></ng-content>\",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                inputs: [\\'disabled\\'],\\n                host: {\\n                    \\'class\\': \\'mat-optgroup\\',\\n                    \\'role\\': \\'group\\',\\n                    \\'[class.mat-optgroup-disabled]\\': \\'disabled\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled.toString()\\',\\n                    \\'[attr.aria-labelledby]\\': \\'_labelId\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdOptgroup.ctorParameters = function () { return []; };\\nMdOptgroup.propDecorators = {\\n    \\'label\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Option IDs need to be unique across components, so this counter exists outside of\\n * the component definition.\\n */\\nvar _uniqueIdCounter = 0;\\n/**\\n * Event object emitted by MdOption when selected or deselected.\\n */\\nvar MdOptionSelectionChange = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} source\\n     * @param {?=} isUserInput\\n     */\\n    function MdOptionSelectionChange(source, isUserInput) {\\n        if (isUserInput === void 0) { isUserInput = false; }\\n        this.source = source;\\n        this.isUserInput = isUserInput;\\n    }\\n    return MdOptionSelectionChange;\\n}());\\n/**\\n * Single option inside of a `<md-select>` element.\\n */\\nvar MdOption = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _element\\n     * @param {?} group\\n     * @param {?} _isCompatibilityMode\\n     */\\n    function MdOption(_element, group, _isCompatibilityMode) {\\n        this._element = _element;\\n        this.group = group;\\n        this._isCompatibilityMode = _isCompatibilityMode;\\n        this._selected = false;\\n        this._active = false;\\n        /**\\n         * Whether the option is disabled.\\n         */\\n        this._disabled = false;\\n        this._id = \"md-option-\" + _uniqueIdCounter++;\\n        /**\\n         * Whether the wrapping component is in multiple selection mode.\\n         */\\n        this.multiple = false;\\n        /**\\n         * Event emitted when the option is selected or deselected.\\n         */\\n        this.onSelectionChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(MdOption.prototype, \"id\", {\\n        /**\\n         * The unique ID of the option.\\n         * @return {?}\\n         */\\n        get: function () { return this._id; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdOption.prototype, \"selected\", {\\n        /**\\n         * Whether or not the option is currently selected.\\n         * @return {?}\\n         */\\n        get: function () { return this._selected; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdOption.prototype, \"disabled\", {\\n        /**\\n         * Whether the option is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return (this.group && this.group.disabled) || this._disabled; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disabled = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdOption.prototype, \"active\", {\\n        /**\\n         * Whether or not the option is currently active and ready to be selected.\\n         * An active option displays styles as if it is focused, but the\\n         * focus is actually retained somewhere else. This comes in handy\\n         * for components like autocomplete where focus must remain on the input.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._active;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdOption.prototype, \"viewValue\", {\\n        /**\\n         * The displayed value of the option. It is necessary to show the selected option in the\\n         * select\\'s trigger.\\n         * @return {?}\\n         */\\n        get: function () {\\n            // TODO(kara): Add input property alternative for node envs.\\n            return (this._getHostElement().textContent || \\'\\').trim();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Selects the option.\\n     * @return {?}\\n     */\\n    MdOption.prototype.select = function () {\\n        this._selected = true;\\n        this._emitSelectionChangeEvent();\\n    };\\n    /**\\n     * Deselects the option.\\n     * @return {?}\\n     */\\n    MdOption.prototype.deselect = function () {\\n        this._selected = false;\\n        this._emitSelectionChangeEvent();\\n    };\\n    /**\\n     * Sets focus onto this option.\\n     * @return {?}\\n     */\\n    MdOption.prototype.focus = function () {\\n        this._getHostElement().focus();\\n    };\\n    /**\\n     * This method sets display styles on the option to make it appear\\n     * active. This is used by the ActiveDescendantKeyManager so key\\n     * events will display the proper options as active on arrow key events.\\n     * @return {?}\\n     */\\n    MdOption.prototype.setActiveStyles = function () {\\n        this._active = true;\\n    };\\n    /**\\n     * This method removes display styles on the option that made it appear\\n     * active. This is used by the ActiveDescendantKeyManager so key\\n     * events will display the proper options as active on arrow key events.\\n     * @return {?}\\n     */\\n    MdOption.prototype.setInactiveStyles = function () {\\n        this._active = false;\\n    };\\n    /**\\n     * Ensures the option is selected when activated from the keyboard.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdOption.prototype._handleKeydown = function (event) {\\n        if (event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"u\" /* ENTER */] || event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"S\" /* SPACE */]) {\\n            this._selectViaInteraction();\\n            // Prevent the page from scrolling down and form submits.\\n            event.preventDefault();\\n        }\\n    };\\n    /**\\n     * Selects the option while indicating the selection came from the user. Used to\\n     * determine if the select\\'s view -> model callback should be invoked.\\n     * @return {?}\\n     */\\n    MdOption.prototype._selectViaInteraction = function () {\\n        if (!this.disabled) {\\n            this._selected = this.multiple ? !this._selected : true;\\n            this._emitSelectionChangeEvent(true);\\n        }\\n    };\\n    /**\\n     * Returns the correct tabindex for the option depending on disabled state.\\n     * @return {?}\\n     */\\n    MdOption.prototype._getTabIndex = function () {\\n        return this.disabled ? \\'-1\\' : \\'0\\';\\n    };\\n    /**\\n     * Fetches the host DOM element.\\n     * @return {?}\\n     */\\n    MdOption.prototype._getHostElement = function () {\\n        return this._element.nativeElement;\\n    };\\n    /**\\n     * Emits the selection change event.\\n     * @param {?=} isUserInput\\n     * @return {?}\\n     */\\n    MdOption.prototype._emitSelectionChangeEvent = function (isUserInput) {\\n        if (isUserInput === void 0) { isUserInput = false; }\\n        this.onSelectionChange.emit(new MdOptionSelectionChange(this, isUserInput));\\n    };\\n    return MdOption;\\n}());\\nMdOption.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-option, mat-option\\',\\n                host: {\\n                    \\'role\\': \\'option\\',\\n                    \\'[attr.tabindex]\\': \\'_getTabIndex()\\',\\n                    \\'[class.mat-selected]\\': \\'selected\\',\\n                    \\'[class.mat-option-multiple]\\': \\'multiple\\',\\n                    \\'[class.mat-active]\\': \\'active\\',\\n                    \\'[id]\\': \\'id\\',\\n                    \\'[attr.aria-selected]\\': \\'selected.toString()\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled.toString()\\',\\n                    \\'[class.mat-option-disabled]\\': \\'disabled\\',\\n                    \\'(click)\\': \\'_selectViaInteraction()\\',\\n                    \\'(keydown)\\': \\'_handleKeydown($event)\\',\\n                    \\'class\\': \\'mat-option\\',\\n                },\\n                template: \"<span [ngSwitch]=\\\\\"_isCompatibilityMode\\\\\" *ngIf=\\\\\"multiple\\\\\"><mat-pseudo-checkbox class=\\\\\"mat-option-pseudo-checkbox\\\\\" *ngSwitchCase=\\\\\"true\\\\\" [state]=\\\\\"selected ? \\'checked\\' : \\'\\'\\\\\" color=\\\\\"primary\\\\\"></mat-pseudo-checkbox><md-pseudo-checkbox class=\\\\\"mat-option-pseudo-checkbox\\\\\" *ngSwitchDefault [state]=\\\\\"selected ? \\'checked\\' : \\'\\'\\\\\" color=\\\\\"primary\\\\\"></md-pseudo-checkbox></span><ng-content></ng-content><div class=\\\\\"mat-option-ripple\\\\\" *ngIf=\\\\\"!disabled\\\\\" md-ripple [mdRippleTrigger]=\\\\\"_getHostElement()\\\\\"></div>\",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdOption.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: MdOptgroup, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MATERIAL_COMPATIBILITY_MODE,] },] },\\n]; };\\nMdOption.propDecorators = {\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'onSelectionChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdOptionModule = /*@__PURE__*/(function () {\\n    function MdOptionModule() {\\n    }\\n    return MdOptionModule;\\n}());\\nMdOptionModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdRippleModule, __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"], MdSelectionModule],\\n                exports: [MdOption, MdOptgroup],\\n                declarations: [MdOption, MdOptgroup]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdOptionModule.ctorParameters = function () { return []; };\\n/**\\n * OverlayState is a bag of values for either the initial configuration or current state of an\\n * overlay.\\n */\\nvar OverlayState = /*@__PURE__*/(function () {\\n    function OverlayState() {\\n        /**\\n         * Custom class to add to the overlay pane.\\n         */\\n        this.panelClass = \\'\\';\\n        /**\\n         * Whether the overlay has a backdrop.\\n         */\\n        this.hasBackdrop = false;\\n        /**\\n         * Custom class to add to the backdrop\\n         */\\n        this.backdropClass = \\'cdk-overlay-dark-backdrop\\';\\n        /**\\n         * The direction of the text in the overlay panel.\\n         */\\n        this.direction = \\'ltr\\';\\n        // TODO(jelbourn): configuration still to add\\n        // - focus trap\\n        // - disable pointer events\\n        // - z-index\\n    }\\n    return OverlayState;\\n}());\\n/**\\n * Reference to an overlay that has been created with the Overlay service.\\n * Used to manipulate or dispose of said overlay.\\n */\\nvar OverlayRef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _portalHost\\n     * @param {?} _pane\\n     * @param {?} _state\\n     * @param {?} _scrollStrategy\\n     * @param {?} _ngZone\\n     */\\n    function OverlayRef(_portalHost, _pane, _state, _scrollStrategy, _ngZone) {\\n        this._portalHost = _portalHost;\\n        this._pane = _pane;\\n        this._state = _state;\\n        this._scrollStrategy = _scrollStrategy;\\n        this._ngZone = _ngZone;\\n        this._backdropElement = null;\\n        this._backdropClick = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        this._attachments = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        this._detachments = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        _scrollStrategy.attach(this);\\n    }\\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\\n        /**\\n         * The overlay\\'s HTML element\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._pane;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Attaches the overlay to a portal instance and adds the backdrop.\\n     * @param {?} portal Portal instance to which to attach the overlay.\\n     * @return {?} The portal attachment result.\\n     */\\n    OverlayRef.prototype.attach = function (portal) {\\n        var /** @type {?} */ attachResult = this._portalHost.attach(portal);\\n        // Update the pane element with the given state configuration.\\n        this._updateStackingOrder();\\n        this.updateSize();\\n        this.updateDirection();\\n        this.updatePosition();\\n        this._scrollStrategy.enable();\\n        // Enable pointer events for the overlay pane element.\\n        this._togglePointerEvents(true);\\n        if (this._state.hasBackdrop) {\\n            this._attachBackdrop();\\n        }\\n        if (this._state.panelClass) {\\n            this._pane.classList.add(this._state.panelClass);\\n        }\\n        // Only emit the `attachments` event once all other setup is done.\\n        this._attachments.next();\\n        return attachResult;\\n    };\\n    /**\\n     * Detaches an overlay from a portal.\\n     * @return {?} Resolves when the overlay has been detached.\\n     */\\n    OverlayRef.prototype.detach = function () {\\n        this.detachBackdrop();\\n        // When the overlay is detached, the pane element should disable pointer events.\\n        // This is necessary because otherwise the pane element will cover the page and disable\\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\\n        this._togglePointerEvents(false);\\n        this._scrollStrategy.disable();\\n        var /** @type {?} */ detachmentResult = this._portalHost.detach();\\n        // Only emit after everything is detached.\\n        this._detachments.next();\\n        return detachmentResult;\\n    };\\n    /**\\n     * Cleans up the overlay from the DOM.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.dispose = function () {\\n        if (this._state.positionStrategy) {\\n            this._state.positionStrategy.dispose();\\n        }\\n        if (this._scrollStrategy) {\\n            this._scrollStrategy.disable();\\n        }\\n        this.detachBackdrop();\\n        this._portalHost.dispose();\\n        this._attachments.complete();\\n        this._backdropClick.complete();\\n        this._detachments.next();\\n        this._detachments.complete();\\n    };\\n    /**\\n     * Checks whether the overlay has been attached.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.hasAttached = function () {\\n        return this._portalHost.hasAttached();\\n    };\\n    /**\\n     * Returns an observable that emits when the backdrop has been clicked.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.backdropClick = function () {\\n        return this._backdropClick.asObservable();\\n    };\\n    /**\\n     * Returns an observable that emits when the overlay has been attached.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.attachments = function () {\\n        return this._attachments.asObservable();\\n    };\\n    /**\\n     * Returns an observable that emits when the overlay has been detached.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.detachments = function () {\\n        return this._detachments.asObservable();\\n    };\\n    /**\\n     * Gets the current state config of the overlay.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.getState = function () {\\n        return this._state;\\n    };\\n    /**\\n     * Updates the position of the overlay based on the position strategy.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.updatePosition = function () {\\n        if (this._state.positionStrategy) {\\n            this._state.positionStrategy.apply(this._pane);\\n        }\\n    };\\n    /**\\n     * Updates the text direction of the overlay panel.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.updateDirection = function () {\\n        this._pane.setAttribute(\\'dir\\', /** @type {?} */ ((this._state.direction)));\\n    };\\n    /**\\n     * Updates the size of the overlay based on the overlay config.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.updateSize = function () {\\n        if (this._state.width || this._state.width === 0) {\\n            this._pane.style.width = formatCssUnit(this._state.width);\\n        }\\n        if (this._state.height || this._state.height === 0) {\\n            this._pane.style.height = formatCssUnit(this._state.height);\\n        }\\n        if (this._state.minWidth || this._state.minWidth === 0) {\\n            this._pane.style.minWidth = formatCssUnit(this._state.minWidth);\\n        }\\n        if (this._state.minHeight || this._state.minHeight === 0) {\\n            this._pane.style.minHeight = formatCssUnit(this._state.minHeight);\\n        }\\n    };\\n    /**\\n     * Toggles the pointer events for the overlay pane element.\\n     * @param {?} enablePointer\\n     * @return {?}\\n     */\\n    OverlayRef.prototype._togglePointerEvents = function (enablePointer) {\\n        this._pane.style.pointerEvents = enablePointer ? \\'auto\\' : \\'none\\';\\n    };\\n    /**\\n     * Attaches a backdrop for this overlay.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype._attachBackdrop = function () {\\n        var _this = this;\\n        this._backdropElement = document.createElement(\\'div\\');\\n        this._backdropElement.classList.add(\\'cdk-overlay-backdrop\\');\\n        if (this._state.backdropClass) {\\n            this._backdropElement.classList.add(this._state.backdropClass);\\n        } /** @type {?} */\\n        ((\\n        // Insert the backdrop before the pane in the DOM order,\\n        // in order to handle stacked overlays properly.\\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\\n        // action desired when such a click occurs (usually closing the overlay).\\n        this._backdropElement.addEventListener(\\'click\\', function () { return _this._backdropClick.next(null); });\\n        // Add class to fade-in the backdrop after one frame.\\n        requestAnimationFrame(function () {\\n            if (_this._backdropElement) {\\n                _this._backdropElement.classList.add(\\'cdk-overlay-backdrop-showing\\');\\n            }\\n        });\\n    };\\n    /**\\n     * Updates the stacking order of the element, moving it to the top if necessary.\\n     * This is required in cases where one overlay was detached, while another one,\\n     * that should be behind it, was destroyed. The next time both of them are opened,\\n     * the stacking will be wrong, because the detached element\\'s pane will still be\\n     * in its original DOM position.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype._updateStackingOrder = function () {\\n        if (this._pane.nextSibling) {\\n            ((this._pane.parentNode)).appendChild(this._pane);\\n        }\\n    };\\n    /**\\n     * Detaches the backdrop (if any) associated with the overlay.\\n     * @return {?}\\n     */\\n    OverlayRef.prototype.detachBackdrop = function () {\\n        var _this = this;\\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\\n        if (backdropToDetach) {\\n            var /** @type {?} */ finishDetach_1 = function () {\\n                // It may not be attached to anything in certain cases (e.g. unit tests).\\n                if (backdropToDetach && backdropToDetach.parentNode) {\\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\\n                }\\n                // It is possible that a new portal has been attached to this overlay since we started\\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\\n                // is still the same instance that we started to remove.\\n                if (_this._backdropElement == backdropToDetach) {\\n                    _this._backdropElement = null;\\n                }\\n            };\\n            backdropToDetach.classList.remove(\\'cdk-overlay-backdrop-showing\\');\\n            if (this._state.backdropClass) {\\n                backdropToDetach.classList.remove(this._state.backdropClass);\\n            }\\n            backdropToDetach.addEventListener(\\'transitionend\\', finishDetach_1);\\n            // If the backdrop doesn\\'t have a transition, the `transitionend` event won\\'t fire.\\n            // In this case we make it unclickable and we try to remove it after a delay.\\n            backdropToDetach.style.pointerEvents = \\'none\\';\\n            // Run this outside the Angular zone because there\\'s nothing that Angular cares about.\\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\\n            // either async or fakeAsync.\\n            this._ngZone.runOutsideAngular(function () {\\n                setTimeout(finishDetach_1, 500);\\n            });\\n        }\\n    };\\n    return OverlayRef;\\n}());\\n/**\\n * @param {?} value\\n * @return {?}\\n */\\nfunction formatCssUnit(value) {\\n    return typeof value === \\'string\\' ? (value) : value + \"px\";\\n}\\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\\n/**\\n * The points of the origin element and the overlay element to connect.\\n */\\nvar ConnectionPositionPair = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} origin\\n     * @param {?} overlay\\n     */\\n    function ConnectionPositionPair(origin, overlay) {\\n        this.originX = origin.originX;\\n        this.originY = origin.originY;\\n        this.overlayX = overlay.overlayX;\\n        this.overlayY = overlay.overlayY;\\n    }\\n    return ConnectionPositionPair;\\n}());\\n/**\\n * Set of properties regarding the position of the origin and overlay relative to the viewport\\n * with respect to the containing Scrollable elements.\\n *\\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\\n * bounds of any one of the strategy\\'s Scrollable\\'s bounding client rectangle.\\n *\\n * The overlay and origin are outside view if there is no overlap between their bounding client\\n * rectangle and any one of the strategy\\'s Scrollable\\'s bounding client rectangle.\\n *\\n *       -----------                    -----------\\n *       | outside |                    | clipped |\\n *       |  view   |              --------------------------\\n *       |         |              |     |         |        |\\n *       ----------               |     -----------        |\\n *  --------------------------    |                        |\\n *  |                        |    |      Scrollable        |\\n *  |                        |    |                        |\\n *  |                        |     --------------------------\\n *  |      Scrollable        |\\n *  |                        |\\n *  --------------------------\\n */\\nvar ScrollableViewProperties = /*@__PURE__*/(function () {\\n    function ScrollableViewProperties() {\\n    }\\n    return ScrollableViewProperties;\\n}());\\n/**\\n * The change event emitted by the strategy when a fallback position is used.\\n */\\nvar ConnectedOverlayPositionChange = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} connectionPair\\n     * @param {?} scrollableViewProperties\\n     */\\n    function ConnectedOverlayPositionChange(connectionPair, scrollableViewProperties) {\\n        this.connectionPair = connectionPair;\\n        this.scrollableViewProperties = scrollableViewProperties;\\n    }\\n    return ConnectedOverlayPositionChange;\\n}());\\n/**\\n * @nocollapse\\n */\\nConnectedOverlayPositionChange.ctorParameters = function () { return [\\n    { type: ConnectionPositionPair, },\\n    { type: ScrollableViewProperties, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\n/**\\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\\n * implicit position relative some origin element. The relative position is defined in terms of\\n * a point on the origin element that is connected to a point on the overlay element. For example,\\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\\n * of the overlay.\\n */\\nvar ConnectedPositionStrategy = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _connectedTo\\n     * @param {?} _originPos\\n     * @param {?} _overlayPos\\n     * @param {?} _viewportRuler\\n     */\\n    function ConnectedPositionStrategy(_connectedTo, _originPos, _overlayPos, _viewportRuler) {\\n        this._connectedTo = _connectedTo;\\n        this._originPos = _originPos;\\n        this._overlayPos = _overlayPos;\\n        this._viewportRuler = _viewportRuler;\\n        this._dir = \\'ltr\\';\\n        /**\\n         * The offset in pixels for the overlay connection point on the x-axis\\n         */\\n        this._offsetX = 0;\\n        /**\\n         * The offset in pixels for the overlay connection point on the y-axis\\n         */\\n        this._offsetY = 0;\\n        /**\\n         * The Scrollable containers used to check scrollable view properties on position change.\\n         */\\n        this.scrollables = [];\\n        /**\\n         * Ordered list of preferred positions, from most to least desirable.\\n         */\\n        this._preferredPositions = [];\\n        this._onPositionChange = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        this._origin = this._connectedTo.nativeElement;\\n        this.withFallbackPosition(_originPos, _overlayPos);\\n    }\\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\\n        /**\\n         * Whether the we\\'re dealing with an RTL context\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._dir === \\'rtl\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\\n        /**\\n         * Emits an event when the connection point changes.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._onPositionChange.asObservable();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\\n        /**\\n         * Ordered list of preferred positions, from most to least desirable.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._preferredPositions;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * To be used to for any cleanup after the element gets destroyed.\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.dispose = function () { };\\n    /**\\n     * Updates the position of the overlay element, using whichever preferred position relative\\n     * to the origin fits on-screen.\\n     * \\\\@docs-private\\n     *\\n     * @param {?} element Element to which to apply the CSS styles.\\n     * @return {?} Resolves when the styles have been applied.\\n     */\\n    ConnectedPositionStrategy.prototype.apply = function (element) {\\n        // Cache the overlay pane element in case re-calculating position is necessary\\n        this._pane = element;\\n        // We need the bounding rects for the origin and the overlay to determine how to position\\n        // the overlay relative to the origin.\\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\\n        // We use the viewport rect to determine whether a position would go off-screen.\\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\\n        // Fallback point if none of the fallbacks fit into the viewport.\\n        var /** @type {?} */ fallbackPoint;\\n        var /** @type {?} */ fallbackPosition;\\n        // We want to place the overlay in the first of the preferred positions such that the\\n        // overlay fits on-screen.\\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\\n            var pos = _a[_i];\\n            // Get the (x, y) point of connection on the origin, and then use that to get the\\n            // (top, left) coordinate for the overlay at `pos`.\\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);\\n            // If the overlay in the calculated position fits on-screen, put it there and we\\'re done.\\n            if (overlayPoint.fitsInViewport) {\\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\\n                // Save the last connected position in case the position needs to be re-calculated.\\n                this._lastConnectedPosition = pos;\\n                // Notify that the position has been changed along with its change properties.\\n                var /** @type {?} */ scrollableViewProperties = this.getScrollableViewProperties(element);\\n                var /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\\n                this._onPositionChange.next(positionChange);\\n                return;\\n            }\\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\\n                fallbackPoint = overlayPoint;\\n                fallbackPosition = pos;\\n            }\\n        }\\n        // If none of the preferred positions were in the viewport, take the one\\n        // with the largest visible area.\\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\\n    };\\n    /**\\n     * This re-aligns the overlay element with the trigger in its last calculated position,\\n     * even if a position higher in the \"preferred positions\" list would now fit. This\\n     * allows one to re-align the panel without changing the orientation of the panel.\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = function () {\\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, lastPosition);\\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\\n    };\\n    /**\\n     * Sets the list of Scrollable containers that host the origin element so that\\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\\n     * Scrollable must be an ancestor element of the strategy\\'s origin element.\\n     * @param {?} scrollables\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {\\n        this.scrollables = scrollables;\\n    };\\n    /**\\n     * Adds a new preferred fallback position.\\n     * @param {?} originPos\\n     * @param {?} overlayPos\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.withFallbackPosition = function (originPos, overlayPos) {\\n        this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\\n        return this;\\n    };\\n    /**\\n     * Sets the layout direction so the overlay\\'s position can be adjusted to match.\\n     * @param {?} dir New layout direction.\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.withDirection = function (dir) {\\n        this._dir = dir;\\n        return this;\\n    };\\n    /**\\n     * Sets an offset for the overlay\\'s connection point on the x-axis\\n     * @param {?} offset New offset in the X axis.\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.withOffsetX = function (offset) {\\n        this._offsetX = offset;\\n        return this;\\n    };\\n    /**\\n     * Sets an offset for the overlay\\'s connection point on the y-axis\\n     * @param {?} offset New offset in the Y axis.\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.withOffsetY = function (offset) {\\n        this._offsetY = offset;\\n        return this;\\n    };\\n    /**\\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\\n     * @param {?} rect\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._getStartX = function (rect) {\\n        return this._isRtl ? rect.right : rect.left;\\n    };\\n    /**\\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\\n     * @param {?} rect\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._getEndX = function (rect) {\\n        return this._isRtl ? rect.left : rect.right;\\n    };\\n    /**\\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\\n     * @param {?} originRect\\n     * @param {?} pos\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = function (originRect, pos) {\\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\\n        var /** @type {?} */ x;\\n        if (pos.originX == \\'center\\') {\\n            x = originStartX + (originRect.width / 2);\\n        }\\n        else {\\n            x = pos.originX == \\'start\\' ? originStartX : originEndX;\\n        }\\n        var /** @type {?} */ y;\\n        if (pos.originY == \\'center\\') {\\n            y = originRect.top + (originRect.height / 2);\\n        }\\n        else {\\n            y = pos.originY == \\'top\\' ? originRect.top : originRect.bottom;\\n        }\\n        return { x: x, y: y };\\n    };\\n    /**\\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\\n     * origin point to which the overlay should be connected, as well as how much of the element\\n     * would be inside the viewport at that position.\\n     * @param {?} originPoint\\n     * @param {?} overlayRect\\n     * @param {?} viewportRect\\n     * @param {?} pos\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._getOverlayPoint = function (originPoint, overlayRect, viewportRect, pos) {\\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\\n        // relative to the origin point.\\n        var /** @type {?} */ overlayStartX;\\n        if (pos.overlayX == \\'center\\') {\\n            overlayStartX = -overlayRect.width / 2;\\n        }\\n        else if (pos.overlayX === \\'start\\') {\\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\\n        }\\n        else {\\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\\n        }\\n        var /** @type {?} */ overlayStartY;\\n        if (pos.overlayY == \\'center\\') {\\n            overlayStartY = -overlayRect.height / 2;\\n        }\\n        else {\\n            overlayStartY = pos.overlayY == \\'top\\' ? 0 : -overlayRect.height;\\n        }\\n        // The (x, y) coordinates of the overlay.\\n        var /** @type {?} */ x = originPoint.x + overlayStartX + this._offsetX;\\n        var /** @type {?} */ y = originPoint.y + overlayStartY + this._offsetY;\\n        // How much the overlay would overflow at this position, on each side.\\n        var /** @type {?} */ leftOverflow = 0 - x;\\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportRect.width;\\n        var /** @type {?} */ topOverflow = 0 - y;\\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportRect.height;\\n        // Visible parts of the element on each axis.\\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\\n        // The area of the element that\\'s within the viewport.\\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\\n    };\\n    /**\\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\\n     * or completely outside the view of any of the strategy\\'s scrollables.\\n     * @param {?} overlay\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.getScrollableViewProperties = function (overlay) {\\n        var _this = this;\\n        var /** @type {?} */ originBounds = this._getElementBounds(this._origin);\\n        var /** @type {?} */ overlayBounds = this._getElementBounds(overlay);\\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (scrollable) {\\n            return _this._getElementBounds(scrollable.getElementRef().nativeElement);\\n        });\\n        return {\\n            isOriginClipped: this.isElementClipped(originBounds, scrollContainerBounds),\\n            isOriginOutsideView: this.isElementOutsideView(originBounds, scrollContainerBounds),\\n            isOverlayClipped: this.isElementClipped(overlayBounds, scrollContainerBounds),\\n            isOverlayOutsideView: this.isElementOutsideView(overlayBounds, scrollContainerBounds),\\n        };\\n    };\\n    /**\\n     * Whether the element is completely out of the view of any of the containers.\\n     * @param {?} elementBounds\\n     * @param {?} containersBounds\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.isElementOutsideView = function (elementBounds, containersBounds) {\\n        return containersBounds.some(function (containerBounds) {\\n            var /** @type {?} */ outsideAbove = elementBounds.bottom < containerBounds.top;\\n            var /** @type {?} */ outsideBelow = elementBounds.top > containerBounds.bottom;\\n            var /** @type {?} */ outsideLeft = elementBounds.right < containerBounds.left;\\n            var /** @type {?} */ outsideRight = elementBounds.left > containerBounds.right;\\n            return outsideAbove || outsideBelow || outsideLeft || outsideRight;\\n        });\\n    };\\n    /**\\n     * Whether the element is clipped by any of the containers.\\n     * @param {?} elementBounds\\n     * @param {?} containersBounds\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype.isElementClipped = function (elementBounds, containersBounds) {\\n        return containersBounds.some(function (containerBounds) {\\n            var /** @type {?} */ clippedAbove = elementBounds.top < containerBounds.top;\\n            var /** @type {?} */ clippedBelow = elementBounds.bottom > containerBounds.bottom;\\n            var /** @type {?} */ clippedLeft = elementBounds.left < containerBounds.left;\\n            var /** @type {?} */ clippedRight = elementBounds.right > containerBounds.right;\\n            return clippedAbove || clippedBelow || clippedLeft || clippedRight;\\n        });\\n    };\\n    /**\\n     * Physically positions the overlay element to the given coordinate.\\n     * @param {?} element\\n     * @param {?} overlayRect\\n     * @param {?} overlayPoint\\n     * @param {?} pos\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._setElementPosition = function (element, overlayRect, overlayPoint, pos) {\\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\\n        // or below the origin and the direction in which the element will expand.\\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === \\'bottom\\' ? \\'bottom\\' : \\'top\\';\\n        // When using `bottom`, we adjust the y position such that it is the distance\\n        // from the bottom of the viewport rather than the top.\\n        var /** @type {?} */ y = verticalStyleProperty === \\'top\\' ?\\n            overlayPoint.y :\\n            document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\\n        // or \"after\" the origin, which determines the direction in which the element will expand.\\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\\n        // page is in RTL or LTR.\\n        var /** @type {?} */ horizontalStyleProperty;\\n        if (this._dir === \\'rtl\\') {\\n            horizontalStyleProperty = pos.overlayX === \\'end\\' ? \\'left\\' : \\'right\\';\\n        }\\n        else {\\n            horizontalStyleProperty = pos.overlayX === \\'end\\' ? \\'right\\' : \\'left\\';\\n        }\\n        // When we\\'re setting `right`, we adjust the x position such that it is the distance\\n        // from the right edge of the viewport rather than the left edge.\\n        var /** @type {?} */ x = horizontalStyleProperty === \\'left\\' ?\\n            overlayPoint.x :\\n            document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\\n        // Reset any existing styles. This is necessary in case the preferred position has\\n        // changed since the last `apply`.\\n        [\\'top\\', \\'bottom\\', \\'left\\', \\'right\\'].forEach(function (p) { return element.style[p] = null; });\\n        element.style[verticalStyleProperty] = y + \"px\";\\n        element.style[horizontalStyleProperty] = x + \"px\";\\n    };\\n    /**\\n     * Returns the bounding positions of the provided element with respect to the viewport.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._getElementBounds = function (element) {\\n        var /** @type {?} */ boundingClientRect = element.getBoundingClientRect();\\n        return {\\n            top: boundingClientRect.top,\\n            right: boundingClientRect.left + boundingClientRect.width,\\n            bottom: boundingClientRect.top + boundingClientRect.height,\\n            left: boundingClientRect.left\\n        };\\n    };\\n    /**\\n     * Subtracts the amount that an element is overflowing on an axis from it\\'s length.\\n     * @param {?} length\\n     * @param {...?} overflows\\n     * @return {?}\\n     */\\n    ConnectedPositionStrategy.prototype._subtractOverflows = function (length) {\\n        var overflows = [];\\n        for (var _i = 1; _i < arguments.length; _i++) {\\n            overflows[_i - 1] = arguments[_i];\\n        }\\n        return overflows.reduce(function (currentValue, currentOverflow) {\\n            return currentValue - Math.max(currentOverflow, 0);\\n        }, length);\\n    };\\n    return ConnectedPositionStrategy;\\n}());\\n/**\\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\\n * explicit position relative to the browser\\'s viewport. We use flexbox, instead of\\n * transforms, in order to avoid issues with subpixel rendering which can cause the\\n * element to become blurry.\\n */\\nvar GlobalPositionStrategy = /*@__PURE__*/(function () {\\n    function GlobalPositionStrategy() {\\n        this._cssPosition = \\'static\\';\\n        this._topOffset = \\'\\';\\n        this._bottomOffset = \\'\\';\\n        this._leftOffset = \\'\\';\\n        this._rightOffset = \\'\\';\\n        this._alignItems = \\'\\';\\n        this._justifyContent = \\'\\';\\n        this._width = \\'\\';\\n        this._height = \\'\\';\\n        this._wrapper = null;\\n    }\\n    /**\\n     * Sets the top position of the overlay. Clears any previously set vertical position.\\n     * @param {?=} value New top offset.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.top = function (value) {\\n        if (value === void 0) { value = \\'\\'; }\\n        this._bottomOffset = \\'\\';\\n        this._topOffset = value;\\n        this._alignItems = \\'flex-start\\';\\n        return this;\\n    };\\n    /**\\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\\n     * @param {?=} value New left offset.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.left = function (value) {\\n        if (value === void 0) { value = \\'\\'; }\\n        this._rightOffset = \\'\\';\\n        this._leftOffset = value;\\n        this._justifyContent = \\'flex-start\\';\\n        return this;\\n    };\\n    /**\\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\\n     * @param {?=} value New bottom offset.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.bottom = function (value) {\\n        if (value === void 0) { value = \\'\\'; }\\n        this._topOffset = \\'\\';\\n        this._bottomOffset = value;\\n        this._alignItems = \\'flex-end\\';\\n        return this;\\n    };\\n    /**\\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\\n     * @param {?=} value New right offset.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.right = function (value) {\\n        if (value === void 0) { value = \\'\\'; }\\n        this._leftOffset = \\'\\';\\n        this._rightOffset = value;\\n        this._justifyContent = \\'flex-end\\';\\n        return this;\\n    };\\n    /**\\n     * Sets the overlay width and clears any previously set width.\\n     * @param {?=} value New width for the overlay\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.width = function (value) {\\n        if (value === void 0) { value = \\'\\'; }\\n        this._width = value;\\n        // When the width is 100%, we should reset the `left` and the offset,\\n        // in order to ensure that the element is flush against the viewport edge.\\n        if (value === \\'100%\\') {\\n            this.left(\\'0px\\');\\n        }\\n        return this;\\n    };\\n    /**\\n     * Sets the overlay height and clears any previously set height.\\n     * @param {?=} value New height for the overlay\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.height = function (value) {\\n        if (value === void 0) { value = \\'\\'; }\\n        this._height = value;\\n        // When the height is 100%, we should reset the `top` and the offset,\\n        // in order to ensure that the element is flush against the viewport edge.\\n        if (value === \\'100%\\') {\\n            this.top(\\'0px\\');\\n        }\\n        return this;\\n    };\\n    /**\\n     * Centers the overlay horizontally with an optional offset.\\n     * Clears any previously set horizontal position.\\n     *\\n     * @param {?=} offset Overlay offset from the horizontal center.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.centerHorizontally = function (offset) {\\n        if (offset === void 0) { offset = \\'\\'; }\\n        this.left(offset);\\n        this._justifyContent = \\'center\\';\\n        return this;\\n    };\\n    /**\\n     * Centers the overlay vertically with an optional offset.\\n     * Clears any previously set vertical position.\\n     *\\n     * @param {?=} offset Overlay offset from the vertical center.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.centerVertically = function (offset) {\\n        if (offset === void 0) { offset = \\'\\'; }\\n        this.top(offset);\\n        this._alignItems = \\'center\\';\\n        return this;\\n    };\\n    /**\\n     * Apply the position to the element.\\n     * \\\\@docs-private\\n     *\\n     * @param {?} element Element to which to apply the CSS.\\n     * @return {?} Resolved when the styles have been applied.\\n     */\\n    GlobalPositionStrategy.prototype.apply = function (element) {\\n        if (!this._wrapper && element.parentNode) {\\n            this._wrapper = document.createElement(\\'div\\');\\n            this._wrapper.classList.add(\\'cdk-global-overlay-wrapper\\');\\n            element.parentNode.insertBefore(this._wrapper, element);\\n            this._wrapper.appendChild(element);\\n        }\\n        var /** @type {?} */ styles = element.style;\\n        var /** @type {?} */ parentStyles = ((element.parentNode)).style;\\n        styles.position = this._cssPosition;\\n        styles.marginTop = this._topOffset;\\n        styles.marginLeft = this._leftOffset;\\n        styles.marginBottom = this._bottomOffset;\\n        styles.marginRight = this._rightOffset;\\n        styles.width = this._width;\\n        styles.height = this._height;\\n        parentStyles.justifyContent = this._justifyContent;\\n        parentStyles.alignItems = this._alignItems;\\n    };\\n    /**\\n     * Removes the wrapper element from the DOM.\\n     * @return {?}\\n     */\\n    GlobalPositionStrategy.prototype.dispose = function () {\\n        if (this._wrapper && this._wrapper.parentNode) {\\n            this._wrapper.parentNode.removeChild(this._wrapper);\\n            this._wrapper = null;\\n        }\\n    };\\n    return GlobalPositionStrategy;\\n}());\\n/**\\n * Builder for overlay position strategy.\\n */\\nvar OverlayPositionBuilder = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _viewportRuler\\n     */\\n    function OverlayPositionBuilder(_viewportRuler) {\\n        this._viewportRuler = _viewportRuler;\\n    }\\n    /**\\n     * Creates a global position strategy.\\n     * @return {?}\\n     */\\n    OverlayPositionBuilder.prototype.global = function () {\\n        return new GlobalPositionStrategy();\\n    };\\n    /**\\n     * Creates a relative position strategy.\\n     * @param {?} elementRef\\n     * @param {?} originPos\\n     * @param {?} overlayPos\\n     * @return {?}\\n     */\\n    OverlayPositionBuilder.prototype.connectedTo = function (elementRef, originPos, overlayPos) {\\n        return new ConnectedPositionStrategy(elementRef, originPos, overlayPos, this._viewportRuler);\\n    };\\n    return OverlayPositionBuilder;\\n}());\\nOverlayPositionBuilder.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nOverlayPositionBuilder.ctorParameters = function () { return [\\n    { type: ViewportRuler, },\\n]; };\\n/**\\n * The OverlayContainer is the container in which all overlays will load.\\n * It should be provided in the root component to ensure it is properly shared.\\n */\\nvar OverlayContainer = /*@__PURE__*/(function () {\\n    function OverlayContainer() {\\n    }\\n    Object.defineProperty(OverlayContainer.prototype, \"themeClass\", {\\n        /**\\n         * Base theme to be applied to all overlay-based components.\\n         * @return {?}\\n         */\\n        get: function () { return this._themeClass; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._containerElement) {\\n                this._containerElement.classList.remove(this._themeClass);\\n                if (value) {\\n                    this._containerElement.classList.add(value);\\n                }\\n            }\\n            this._themeClass = value;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * This method returns the overlay container element.  It will lazily\\n     * create the element the first time  it is called to facilitate using\\n     * the container in non-browser environments.\\n     * @return {?} the container element\\n     */\\n    OverlayContainer.prototype.getContainerElement = function () {\\n        if (!this._containerElement) {\\n            this._createContainer();\\n        }\\n        return this._containerElement;\\n    };\\n    /**\\n     * Create the overlay container element, which is simply a div\\n     * with the \\'cdk-overlay-container\\' class on the document body.\\n     * @return {?}\\n     */\\n    OverlayContainer.prototype._createContainer = function () {\\n        var /** @type {?} */ container = document.createElement(\\'div\\');\\n        container.classList.add(\\'cdk-overlay-container\\');\\n        if (this._themeClass) {\\n            container.classList.add(this._themeClass);\\n        }\\n        document.body.appendChild(container);\\n        this._containerElement = container;\\n    };\\n    return OverlayContainer;\\n}());\\nOverlayContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nOverlayContainer.ctorParameters = function () { return []; };\\n/**\\n * @param {?} parentContainer\\n * @return {?}\\n */\\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {\\n    return parentContainer || new OverlayContainer();\\n}\\nvar OVERLAY_CONTAINER_PROVIDER = {\\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\\n    provide: OverlayContainer,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), OverlayContainer]],\\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\\n};\\n/**\\n * Next overlay unique ID.\\n */\\nvar nextUniqueId = 0;\\n/**\\n * The default state for newly created overlays.\\n */\\nvar defaultState = new OverlayState();\\n/**\\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\\n * of re-usable components rather than developers building end-user applications.\\n *\\n * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.\\n */\\nvar Overlay = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} scrollStrategies\\n     * @param {?} _overlayContainer\\n     * @param {?} _componentFactoryResolver\\n     * @param {?} _positionBuilder\\n     * @param {?} _appRef\\n     * @param {?} _injector\\n     * @param {?} _ngZone\\n     */\\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _appRef, _injector, _ngZone) {\\n        this.scrollStrategies = scrollStrategies;\\n        this._overlayContainer = _overlayContainer;\\n        this._componentFactoryResolver = _componentFactoryResolver;\\n        this._positionBuilder = _positionBuilder;\\n        this._appRef = _appRef;\\n        this._injector = _injector;\\n        this._ngZone = _ngZone;\\n    }\\n    /**\\n     * Creates an overlay.\\n     * @param {?=} state State to apply to the overlay.\\n     * @return {?} Reference to the created overlay.\\n     */\\n    Overlay.prototype.create = function (state$$1) {\\n        if (state$$1 === void 0) { state$$1 = defaultState; }\\n        return this._createOverlayRef(this._createPaneElement(), state$$1);\\n    };\\n    /**\\n     * Returns a position builder that can be used, via fluent API,\\n     * to construct and configure a position strategy.\\n     * @return {?}\\n     */\\n    Overlay.prototype.position = function () {\\n        return this._positionBuilder;\\n    };\\n    /**\\n     * Creates the DOM element for an overlay and appends it to the overlay container.\\n     * @return {?} Newly-created pane element\\n     */\\n    Overlay.prototype._createPaneElement = function () {\\n        var /** @type {?} */ pane = document.createElement(\\'div\\');\\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\\n        pane.classList.add(\\'cdk-overlay-pane\\');\\n        this._overlayContainer.getContainerElement().appendChild(pane);\\n        return pane;\\n    };\\n    /**\\n     * Create a DomPortalHost into which the overlay content can be loaded.\\n     * @param {?} pane The DOM element to turn into a portal host.\\n     * @return {?} A portal host for the given DOM element.\\n     */\\n    Overlay.prototype._createPortalHost = function (pane) {\\n        return new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"s\" /* DomPortalHost */](pane, this._componentFactoryResolver, this._appRef, this._injector);\\n    };\\n    /**\\n     * Creates an OverlayRef for an overlay in the given DOM element.\\n     * @param {?} pane DOM element for the overlay\\n     * @param {?} state\\n     * @return {?}\\n     */\\n    Overlay.prototype._createOverlayRef = function (pane, state$$1) {\\n        var /** @type {?} */ scrollStrategy = state$$1.scrollStrategy || this.scrollStrategies.noop();\\n        var /** @type {?} */ portalHost = this._createPortalHost(pane);\\n        return new OverlayRef(portalHost, pane, state$$1, scrollStrategy, this._ngZone);\\n    };\\n    return Overlay;\\n}());\\nOverlay.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nOverlay.ctorParameters = function () { return [\\n    { type: ScrollStrategyOptions, },\\n    { type: OverlayContainer, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ComponentFactoryResolver\"], },\\n    { type: OverlayPositionBuilder, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ApplicationRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injector\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\n/**\\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\\n */\\nvar defaultPositionList = [\\n    new ConnectionPositionPair({ originX: \\'start\\', originY: \\'bottom\\' }, { overlayX: \\'start\\', overlayY: \\'top\\' }),\\n    new ConnectionPositionPair({ originX: \\'start\\', originY: \\'top\\' }, { overlayX: \\'start\\', overlayY: \\'bottom\\' }),\\n];\\n/**\\n * Directive applied to an element to make it usable as an origin for an Overlay using a\\n * ConnectedPositionStrategy.\\n */\\nvar OverlayOrigin = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementRef\\n     */\\n    function OverlayOrigin(elementRef) {\\n        this.elementRef = elementRef;\\n    }\\n    return OverlayOrigin;\\n}());\\nOverlayOrigin.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]\\',\\n                exportAs: \\'cdkOverlayOrigin\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nOverlayOrigin.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\n/**\\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\\n */\\nvar ConnectedOverlayDirective = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlay\\n     * @param {?} _renderer\\n     * @param {?} templateRef\\n     * @param {?} viewContainerRef\\n     * @param {?} _dir\\n     */\\n    function ConnectedOverlayDirective(_overlay, _renderer, templateRef, viewContainerRef, _dir) {\\n        this._overlay = _overlay;\\n        this._renderer = _renderer;\\n        this._dir = _dir;\\n        this._hasBackdrop = false;\\n        this._offsetX = 0;\\n        this._offsetY = 0;\\n        /**\\n         * Strategy to be used when handling scroll events while the overlay is open.\\n         */\\n        this.scrollStrategy = this._overlay.scrollStrategies.reposition();\\n        /**\\n         * Whether the overlay is open.\\n         */\\n        this.open = false;\\n        /**\\n         * Event emitted when the backdrop is clicked.\\n         */\\n        this.backdropClick = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the position has changed.\\n         */\\n        this.positionChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the overlay has been attached.\\n         */\\n        this.attach = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the overlay has been detached.\\n         */\\n        this.detach = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        this._templatePortal = new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"U\" /* TemplatePortal */](templateRef, viewContainerRef);\\n    }\\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"offsetX\", {\\n        /**\\n         * The offset in pixels for the overlay connection point on the x-axis\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._offsetX;\\n        },\\n        /**\\n         * @param {?} offsetX\\n         * @return {?}\\n         */\\n        set: function (offsetX) {\\n            this._offsetX = offsetX;\\n            if (this._position) {\\n                this._position.withOffsetX(offsetX);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"offsetY\", {\\n        /**\\n         * The offset in pixels for the overlay connection point on the y-axis\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._offsetY;\\n        },\\n        /**\\n         * @param {?} offsetY\\n         * @return {?}\\n         */\\n        set: function (offsetY) {\\n            this._offsetY = offsetY;\\n            if (this._position) {\\n                this._position.withOffsetY(offsetY);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"hasBackdrop\", {\\n        /**\\n         * Whether or not the overlay should attach a backdrop.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._hasBackdrop;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._hasBackdrop = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"overlayRef\", {\\n        /**\\n         * The associated overlay reference.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._overlayRef;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"dir\", {\\n        /**\\n         * The element\\'s layout direction.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._dir ? this._dir.value : \\'ltr\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype.ngOnDestroy = function () {\\n        this._destroyOverlay();\\n    };\\n    /**\\n     * @param {?} changes\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype.ngOnChanges = function (changes) {\\n        if (changes[\\'open\\']) {\\n            this.open ? this._attachOverlay() : this._detachOverlay();\\n        }\\n    };\\n    /**\\n     * Creates an overlay\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._createOverlay = function () {\\n        if (!this.positions || !this.positions.length) {\\n            this.positions = defaultPositionList;\\n        }\\n        this._overlayRef = this._overlay.create(this._buildConfig());\\n    };\\n    /**\\n     * Builds the overlay config based on the directive\\'s inputs\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._buildConfig = function () {\\n        var /** @type {?} */ overlayConfig = new OverlayState();\\n        if (this.width || this.width === 0) {\\n            overlayConfig.width = this.width;\\n        }\\n        if (this.height || this.height === 0) {\\n            overlayConfig.height = this.height;\\n        }\\n        if (this.minWidth || this.minWidth === 0) {\\n            overlayConfig.minWidth = this.minWidth;\\n        }\\n        if (this.minHeight || this.minHeight === 0) {\\n            overlayConfig.minHeight = this.minHeight;\\n        }\\n        overlayConfig.hasBackdrop = this.hasBackdrop;\\n        if (this.backdropClass) {\\n            overlayConfig.backdropClass = this.backdropClass;\\n        }\\n        this._position = (this._createPositionStrategy());\\n        overlayConfig.positionStrategy = this._position;\\n        overlayConfig.scrollStrategy = this.scrollStrategy;\\n        return overlayConfig;\\n    };\\n    /**\\n     * Returns the position strategy of the overlay to be set on the overlay config\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._createPositionStrategy = function () {\\n        var /** @type {?} */ pos = this.positions[0];\\n        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };\\n        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };\\n        var /** @type {?} */ strategy = this._overlay.position()\\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\\n            .withOffsetX(this.offsetX)\\n            .withOffsetY(this.offsetY);\\n        this._handlePositionChanges(strategy);\\n        return strategy;\\n    };\\n    /**\\n     * @param {?} strategy\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._handlePositionChanges = function (strategy) {\\n        var _this = this;\\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\\n        }\\n        this._positionSubscription =\\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\\n    };\\n    /**\\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._attachOverlay = function () {\\n        var _this = this;\\n        if (!this._overlayRef) {\\n            this._createOverlay();\\n        }\\n        this._position.withDirection(this.dir);\\n        this._overlayRef.getState().direction = this.dir;\\n        this._initEscapeListener();\\n        if (!this._overlayRef.hasAttached()) {\\n            this._overlayRef.attach(this._templatePortal);\\n            this.attach.emit();\\n        }\\n        if (this.hasBackdrop) {\\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\\n                _this.backdropClick.emit();\\n            });\\n        }\\n    };\\n    /**\\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._detachOverlay = function () {\\n        if (this._overlayRef) {\\n            this._overlayRef.detach();\\n            this.detach.emit();\\n        }\\n        if (this._backdropSubscription) {\\n            this._backdropSubscription.unsubscribe();\\n            this._backdropSubscription = null;\\n        }\\n        if (this._escapeListener) {\\n            this._escapeListener();\\n        }\\n    };\\n    /**\\n     * Destroys the overlay created by this directive.\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._destroyOverlay = function () {\\n        if (this._overlayRef) {\\n            this._overlayRef.dispose();\\n        }\\n        if (this._backdropSubscription) {\\n            this._backdropSubscription.unsubscribe();\\n        }\\n        if (this._positionSubscription) {\\n            this._positionSubscription.unsubscribe();\\n        }\\n        if (this._escapeListener) {\\n            this._escapeListener();\\n        }\\n    };\\n    /**\\n     * Sets the event listener that closes the overlay when pressing Escape.\\n     * @return {?}\\n     */\\n    ConnectedOverlayDirective.prototype._initEscapeListener = function () {\\n        var _this = this;\\n        this._escapeListener = this._renderer.listen(\\'document\\', \\'keydown\\', function (event) {\\n            if (event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"v\" /* ESCAPE */]) {\\n                _this._detachOverlay();\\n            }\\n        });\\n    };\\n    return ConnectedOverlayDirective;\\n}());\\nConnectedOverlayDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]\\',\\n                exportAs: \\'cdkConnectedOverlay\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nConnectedOverlayDirective.ctorParameters = function () { return [\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nConnectedOverlayDirective.propDecorators = {\\n    \\'origin\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'positions\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'offsetX\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'offsetY\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'width\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'height\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'minWidth\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'minHeight\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'backdropClass\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'scrollStrategy\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'open\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'hasBackdrop\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'backdropClick\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'positionChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'attach\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'detach\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * The FullscreenOverlayContainer is the alternative to OverlayContainer\\n * that supports correct displaying of overlay elements in Fullscreen mode\\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\\n * It should be provided in the root component that way:\\n * providers: [\\n *   {provide: OverlayContainer, useClass: FullscreenOverlayContainer}\\n * ],\\n */\\nvar FullscreenOverlayContainer = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FullscreenOverlayContainer, _super);\\n    function FullscreenOverlayContainer() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    FullscreenOverlayContainer.prototype._createContainer = function () {\\n        var _this = this;\\n        _super.prototype._createContainer.call(this);\\n        this._adjustParentForFullscreenChange();\\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = function () {\\n        if (!this._containerElement) {\\n            return;\\n        }\\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\\n        var /** @type {?} */ parent = fullscreenElement || document.body;\\n        parent.appendChild(this._containerElement);\\n    };\\n    /**\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = function (fn) {\\n        if (document.fullscreenEnabled) {\\n            document.addEventListener(\\'fullscreenchange\\', fn);\\n        }\\n        else if (document.webkitFullscreenEnabled) {\\n            document.addEventListener(\\'webkitfullscreenchange\\', fn);\\n        }\\n        else if (((document)).mozFullScreenEnabled) {\\n            document.addEventListener(\\'mozfullscreenchange\\', fn);\\n        }\\n        else if (((document)).msFullscreenEnabled) {\\n            document.addEventListener(\\'MSFullscreenChange\\', fn);\\n        }\\n    };\\n    /**\\n     * When the page is put into fullscreen mode, a specific element is specified.\\n     * Only that element and its children are visible when in fullscreen mode.\\n     * @return {?}\\n     */\\n    FullscreenOverlayContainer.prototype.getFullscreenElement = function () {\\n        return document.fullscreenElement ||\\n            document.webkitFullscreenElement ||\\n            ((document)).mozFullScreenElement ||\\n            ((document)).msFullscreenElement ||\\n            null;\\n    };\\n    return FullscreenOverlayContainer;\\n}(OverlayContainer));\\nFullscreenOverlayContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nFullscreenOverlayContainer.ctorParameters = function () { return []; };\\nvar OVERLAY_PROVIDERS = [\\n    Overlay,\\n    OverlayPositionBuilder,\\n    VIEWPORT_RULER_PROVIDER,\\n    OVERLAY_CONTAINER_PROVIDER,\\n];\\nvar OverlayModule = /*@__PURE__*/(function () {\\n    function OverlayModule() {\\n    }\\n    return OverlayModule;\\n}());\\nOverlayModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"P\" /* PortalModule */], ScrollDispatchModule],\\n                exports: [ConnectedOverlayDirective, OverlayOrigin, ScrollDispatchModule],\\n                declarations: [ConnectedOverlayDirective, OverlayOrigin],\\n                providers: [OVERLAY_PROVIDERS],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nOverlayModule.ctorParameters = function () { return []; };\\nvar GestureConfig = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](GestureConfig, _super);\\n    function GestureConfig() {\\n        var _this = _super.call(this) || this;\\n        _this._hammer = typeof window !== \\'undefined\\' ? ((window)).Hammer : null;\\n        /* List of new event names to add to the gesture support list */\\n        _this.events = _this._hammer ? [\\n            \\'longpress\\',\\n            \\'slide\\',\\n            \\'slidestart\\',\\n            \\'slideend\\',\\n            \\'slideright\\',\\n            \\'slideleft\\'\\n        ] : [];\\n        if (!_this._hammer && __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"]()) {\\n            console.warn(\\'Could not find HammerJS. Certain Angular Material \\' +\\n                \\'components may not work correctly.\\');\\n        }\\n        return _this;\\n    }\\n    /**\\n     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.\\n     *\\n     * Our gesture names come from the Material Design gestures spec:\\n     * https://www.google.com/design/spec/patterns/gestures.html#gestures-touch-mechanics\\n     *\\n     * More information on default recognizers can be found in Hammer docs:\\n     * http://hammerjs.github.io/recognizer-pan/\\n     * http://hammerjs.github.io/recognizer-press/\\n     *\\n     * @param {?} element Element to which to assign the new HammerJS gestures.\\n     * @return {?} Newly-created HammerJS instance.\\n     */\\n    GestureConfig.prototype.buildHammer = function (element) {\\n        var /** @type {?} */ mc = new this._hammer(element);\\n        // Default Hammer Recognizers.\\n        var /** @type {?} */ pan = new this._hammer.Pan();\\n        var /** @type {?} */ swipe = new this._hammer.Swipe();\\n        var /** @type {?} */ press = new this._hammer.Press();\\n        // Notice that a HammerJS recognizer can only depend on one other recognizer once.\\n        // Otherwise the previous `recognizeWith` will be dropped.\\n        // TODO: Confirm threshold numbers with Material Design UX Team\\n        var /** @type {?} */ slide = this._createRecognizer(pan, { event: \\'slide\\', threshold: 0 }, swipe);\\n        var /** @type {?} */ longpress = this._createRecognizer(press, { event: \\'longpress\\', time: 500 });\\n        // Overwrite the default `pan` event to use the swipe event.\\n        pan.recognizeWith(swipe);\\n        // Add customized gestures to Hammer manager\\n        mc.add([swipe, press, pan, slide, longpress]);\\n        return (mc);\\n    };\\n    /**\\n     * Creates a new recognizer, without affecting the default recognizers of HammerJS\\n     * @param {?} base\\n     * @param {?} options\\n     * @param {...?} inheritances\\n     * @return {?}\\n     */\\n    GestureConfig.prototype._createRecognizer = function (base, options) {\\n        var inheritances = [];\\n        for (var _i = 2; _i < arguments.length; _i++) {\\n            inheritances[_i - 2] = arguments[_i];\\n        }\\n        var /** @type {?} */ recognizer = new ((base.constructor))(options);\\n        inheritances.push(base);\\n        inheritances.forEach(function (item) { return recognizer.recognizeWith(item); });\\n        return recognizer;\\n    };\\n    return GestureConfig;\\n}(__WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"HammerGestureConfig\"]));\\nGestureConfig.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nGestureConfig.ctorParameters = function () { return []; };\\n/**\\n * Class to be used to power selecting one or more options from a list.\\n * \\\\@docs-private\\n */\\nvar SelectionModel = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?=} _isMulti\\n     * @param {?=} initiallySelectedValues\\n     * @param {?=} _emitChanges\\n     */\\n    function SelectionModel(_isMulti, initiallySelectedValues, _emitChanges) {\\n        if (_isMulti === void 0) { _isMulti = false; }\\n        if (_emitChanges === void 0) { _emitChanges = true; }\\n        var _this = this;\\n        this._isMulti = _isMulti;\\n        this._emitChanges = _emitChanges;\\n        /**\\n         * Currently-selected values.\\n         */\\n        this._selection = new Set();\\n        /**\\n         * Keeps track of the deselected options that haven\\'t been emitted by the change event.\\n         */\\n        this._deselectedToEmit = [];\\n        /**\\n         * Keeps track of the selected option that haven\\'t been emitted by the change event.\\n         */\\n        this._selectedToEmit = [];\\n        /**\\n         * Event emitted when the value has changed.\\n         */\\n        this.onChange = this._emitChanges ? new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]() : null;\\n        if (initiallySelectedValues) {\\n            if (_isMulti) {\\n                initiallySelectedValues.forEach(function (value) { return _this._markSelected(value); });\\n            }\\n            else {\\n                this._markSelected(initiallySelectedValues[0]);\\n            }\\n            // Clear the array in order to avoid firing the change event for preselected values.\\n            this._selectedToEmit.length = 0;\\n        }\\n    }\\n    Object.defineProperty(SelectionModel.prototype, \"selected\", {\\n        /**\\n         * Selected value(s).\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (!this._selected) {\\n                this._selected = Array.from(this._selection.values());\\n            }\\n            return this._selected;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Selects a value or an array of values.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.select = function (value) {\\n        this._markSelected(value);\\n        this._emitChangeEvent();\\n    };\\n    /**\\n     * Deselects a value or an array of values.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.deselect = function (value) {\\n        this._unmarkSelected(value);\\n        this._emitChangeEvent();\\n    };\\n    /**\\n     * Toggles a value between selected and deselected.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.toggle = function (value) {\\n        this.isSelected(value) ? this.deselect(value) : this.select(value);\\n    };\\n    /**\\n     * Clears all of the selected values.\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.clear = function () {\\n        this._unmarkAll();\\n        this._emitChangeEvent();\\n    };\\n    /**\\n     * Determines whether a value is selected.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.isSelected = function (value) {\\n        return this._selection.has(value);\\n    };\\n    /**\\n     * Determines whether the model does not have a value.\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.isEmpty = function () {\\n        return this._selection.size === 0;\\n    };\\n    /**\\n     * Determines whether the model has a value.\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.hasValue = function () {\\n        return !this.isEmpty();\\n    };\\n    /**\\n     * Sorts the selected values based on a predicate function.\\n     * @param {?=} predicate\\n     * @return {?}\\n     */\\n    SelectionModel.prototype.sort = function (predicate) {\\n        if (this._isMulti && this._selected) {\\n            this._selected.sort(predicate);\\n        }\\n    };\\n    /**\\n     * Emits a change event and clears the records of selected and deselected values.\\n     * @return {?}\\n     */\\n    SelectionModel.prototype._emitChangeEvent = function () {\\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\\n            var /** @type {?} */ eventData = new SelectionChange(this._selectedToEmit, this._deselectedToEmit);\\n            if (this.onChange) {\\n                this.onChange.next(eventData);\\n            }\\n            this._deselectedToEmit = [];\\n            this._selectedToEmit = [];\\n        }\\n        this._selected = null;\\n    };\\n    /**\\n     * Selects a value.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype._markSelected = function (value) {\\n        if (!this.isSelected(value)) {\\n            if (!this._isMulti) {\\n                this._unmarkAll();\\n            }\\n            this._selection.add(value);\\n            if (this._emitChanges) {\\n                this._selectedToEmit.push(value);\\n            }\\n        }\\n    };\\n    /**\\n     * Deselects a value.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    SelectionModel.prototype._unmarkSelected = function (value) {\\n        if (this.isSelected(value)) {\\n            this._selection.delete(value);\\n            if (this._emitChanges) {\\n                this._deselectedToEmit.push(value);\\n            }\\n        }\\n    };\\n    /**\\n     * Clears out the selected values.\\n     * @return {?}\\n     */\\n    SelectionModel.prototype._unmarkAll = function () {\\n        var _this = this;\\n        if (!this.isEmpty()) {\\n            this._selection.forEach(function (value) { return _this._unmarkSelected(value); });\\n        }\\n    };\\n    return SelectionModel;\\n}());\\n/**\\n * Describes an event emitted when the value of a MdSelectionModel has changed.\\n * \\\\@docs-private\\n */\\nvar SelectionChange = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?=} added\\n     * @param {?=} removed\\n     */\\n    function SelectionChange(added, removed) {\\n        this.added = added;\\n        this.removed = removed;\\n    }\\n    return SelectionChange;\\n}());\\n/**\\n * Class to coordinate unique selection based on name.\\n * Intended to be consumed as an Angular service.\\n * This service is needed because native radio change events are only fired on the item currently\\n * being selected, and we still need to uncheck the previous selection.\\n *\\n * This service does not *store* any IDs and names because they may change at any time, so it is\\n * less error-prone if they are simply passed through when the events occur.\\n */\\nvar UniqueSelectionDispatcher = /*@__PURE__*/(function () {\\n    function UniqueSelectionDispatcher() {\\n        this._listeners = [];\\n    }\\n    /**\\n     * Notify other items that selection for the given name has been set.\\n     * @param {?} id ID of the item.\\n     * @param {?} name Name of the item.\\n     * @return {?}\\n     */\\n    UniqueSelectionDispatcher.prototype.notify = function (id, name) {\\n        for (var _i = 0, _a = this._listeners; _i < _a.length; _i++) {\\n            var listener = _a[_i];\\n            listener(id, name);\\n        }\\n    };\\n    /**\\n     * Listen for future changes to item selection.\\n     * @param {?} listener\\n     * @return {?} Function used to deregister listener\\n     *\\n     */\\n    UniqueSelectionDispatcher.prototype.listen = function (listener) {\\n        var _this = this;\\n        this._listeners.push(listener);\\n        return function () {\\n            _this._listeners = _this._listeners.filter(function (registered) {\\n                return listener !== registered;\\n            });\\n        };\\n    };\\n    return UniqueSelectionDispatcher;\\n}());\\nUniqueSelectionDispatcher.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nUniqueSelectionDispatcher.ctorParameters = function () { return []; };\\n/**\\n * @param {?} parentDispatcher\\n * @return {?}\\n */\\nfunction UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY(parentDispatcher) {\\n    return parentDispatcher || new UniqueSelectionDispatcher();\\n}\\nvar UNIQUE_SELECTION_DISPATCHER_PROVIDER = {\\n    // If there is already a dispatcher available, use that. Otherwise, provide a new one.\\n    provide: UniqueSelectionDispatcher,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), UniqueSelectionDispatcher]],\\n    useFactory: UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY\\n};\\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\\n// that a value of around 650ms seems appropriate.\\nvar TOUCH_BUFFER_MS = 650;\\n/**\\n * Monitors mouse and keyboard events to determine the cause of focus events.\\n */\\nvar FocusOriginMonitor = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _ngZone\\n     * @param {?} _platform\\n     */\\n    function FocusOriginMonitor(_ngZone, _platform) {\\n        var _this = this;\\n        this._ngZone = _ngZone;\\n        this._platform = _platform;\\n        /**\\n         * The focus origin that the next focus event is a result of.\\n         */\\n        this._origin = null;\\n        /**\\n         * Whether the window has just been focused.\\n         */\\n        this._windowFocused = false;\\n        /**\\n         * Weak map of elements being monitored to their info.\\n         */\\n        this._elementInfo = new WeakMap();\\n        this._ngZone.runOutsideAngular(function () { return _this._registerDocumentEvents(); });\\n    }\\n    /**\\n     * Monitors focus on an element and applies appropriate CSS classes.\\n     * @param {?} element The element to monitor\\n     * @param {?} renderer The renderer to use to apply CSS classes to the element.\\n     * @param {?} checkChildren Whether to count the element as focused when its children are focused.\\n     * @return {?} An observable that emits when the focus state of the element changes.\\n     *     When the element is blurred, null will be emitted.\\n     */\\n    FocusOriginMonitor.prototype.monitor = function (element, renderer, checkChildren) {\\n        var _this = this;\\n        // Do nothing if we\\'re not on the browser platform.\\n        if (!this._platform.isBrowser) {\\n            return __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__[\"of\"](null);\\n        }\\n        // Check if we\\'re already monitoring this element.\\n        if (this._elementInfo.has(element)) {\\n            var /** @type {?} */ info_1 = this._elementInfo.get(element); /** @type {?} */\\n            ((info_1)).checkChildren = checkChildren;\\n            return ((info_1)).subject.asObservable();\\n        }\\n        // Create monitored element info.\\n        var /** @type {?} */ info = {\\n            unlisten: function () { },\\n            checkChildren: checkChildren,\\n            renderer: renderer,\\n            subject: new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]()\\n        };\\n        this._elementInfo.set(element, info);\\n        // Start listening. We need to listen in capture phase since focus events don\\'t bubble.\\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\\n        this._ngZone.runOutsideAngular(function () {\\n            element.addEventListener(\\'focus\\', focusListener, true);\\n            element.addEventListener(\\'blur\\', blurListener, true);\\n        });\\n        // Create an unlisten function for later.\\n        info.unlisten = function () {\\n            element.removeEventListener(\\'focus\\', focusListener, true);\\n            element.removeEventListener(\\'blur\\', blurListener, true);\\n        };\\n        return info.subject.asObservable();\\n    };\\n    /**\\n     * Stops monitoring an element and removes all focus classes.\\n     * @param {?} element The element to stop monitoring.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype.stopMonitoring = function (element) {\\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\\n        if (elementInfo) {\\n            elementInfo.unlisten();\\n            elementInfo.subject.complete();\\n            this._setClasses(element);\\n            this._elementInfo.delete(element);\\n        }\\n    };\\n    /**\\n     * Focuses the element via the specified focus origin.\\n     * @param {?} element The element to focus.\\n     * @param {?} origin The focus origin.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype.focusVia = function (element, origin) {\\n        this._setOriginForCurrentEventQueue(origin);\\n        element.focus();\\n    };\\n    /**\\n     * Register necessary event listeners on the document and window.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype._registerDocumentEvents = function () {\\n        var _this = this;\\n        // Do nothing if we\\'re not on the browser platform.\\n        if (!this._platform.isBrowser) {\\n            return;\\n        }\\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\\n        // propagation.\\n        // On keydown record the origin and clear any touch event that may be in progress.\\n        document.addEventListener(\\'keydown\\', function () {\\n            _this._lastTouchTarget = null;\\n            _this._setOriginForCurrentEventQueue(\\'keyboard\\');\\n        }, true);\\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\\n        // happen as a result of a touch event.\\n        document.addEventListener(\\'mousedown\\', function () {\\n            if (!_this._lastTouchTarget) {\\n                _this._setOriginForCurrentEventQueue(\\'mouse\\');\\n            }\\n        }, true);\\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\\n        // we can\\'t rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\\n        // see if a focus happens.\\n        document.addEventListener(\\'touchstart\\', function (event) {\\n            if (_this._touchTimeout != null) {\\n                clearTimeout(_this._touchTimeout);\\n            }\\n            _this._lastTouchTarget = event.target;\\n            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\\n        }, true);\\n        // Make a note of when the window regains focus, so we can restore the origin info for the\\n        // focused element.\\n        window.addEventListener(\\'focus\\', function () {\\n            _this._windowFocused = true;\\n            setTimeout(function () { return _this._windowFocused = false; }, 0);\\n        });\\n    };\\n    /**\\n     * Sets the focus classes on the element based on the given focus origin.\\n     * @param {?} element The element to update the classes on.\\n     * @param {?=} origin The focus origin.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype._setClasses = function (element, origin) {\\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\\n        if (elementInfo) {\\n            var /** @type {?} */ toggleClass = function (className, shouldSet) {\\n                shouldSet ? elementInfo.renderer.addClass(element, className) :\\n                    elementInfo.renderer.removeClass(element, className);\\n            };\\n            toggleClass(\\'cdk-focused\\', !!origin);\\n            toggleClass(\\'cdk-touch-focused\\', origin === \\'touch\\');\\n            toggleClass(\\'cdk-keyboard-focused\\', origin === \\'keyboard\\');\\n            toggleClass(\\'cdk-mouse-focused\\', origin === \\'mouse\\');\\n            toggleClass(\\'cdk-program-focused\\', origin === \\'program\\');\\n        }\\n    };\\n    /**\\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\\n     * @param {?} origin The origin to set.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype._setOriginForCurrentEventQueue = function (origin) {\\n        var _this = this;\\n        this._origin = origin;\\n        setTimeout(function () { return _this._origin = null; }, 0);\\n    };\\n    /**\\n     * Checks whether the given focus event was caused by a touchstart event.\\n     * @param {?} event The focus event to check.\\n     * @return {?} Whether the event was caused by a touch.\\n     */\\n    FocusOriginMonitor.prototype._wasCausedByTouch = function (event) {\\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\\n        // Consider the following dom structure:\\n        //\\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\\n        //   <div #child (click)=\"#parent.focus()\"></div>\\n        // </div>\\n        //\\n        // If the user touches the #child element and the #parent is programmatically focused as a\\n        // result, this code will still consider it to have been caused by the touch event and will\\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\\n        // relatively small edge-case that can be worked around by using\\n        // focusVia(parentEl, renderer,  \\'program\\') to focus the parent element.\\n        //\\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\\n        // for the first focus event after the touchstart, and then the first blur event after that\\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\\n        // touchstart.\\n        var /** @type {?} */ focusTarget = event.target;\\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\\n    };\\n    /**\\n     * Handles focus events on a registered element.\\n     * @param {?} event The focus event.\\n     * @param {?} element The monitored element.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype._onFocus = function (event, element) {\\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\\n        // focus event affecting the monitored element. If we want to use the origin of the first event\\n        // instead we should check for the cdk-focused class here and return if the element already has\\n        // it. (This only matters for elements that have includesChildren = true).\\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\\n        // monitored element itself.\\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\\n            return;\\n        }\\n        // If we couldn\\'t detect a cause for the focus event, it\\'s due to one of three reasons:\\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\\n        //    the element from before the window blurred.\\n        // 2) It was caused by a touch event, in which case we mark the origin as \\'touch\\'.\\n        // 3) The element was programmatically focused, in which case we should mark the origin as\\n        //    \\'program\\'.\\n        if (!this._origin) {\\n            if (this._windowFocused && this._lastFocusOrigin) {\\n                this._origin = this._lastFocusOrigin;\\n            }\\n            else if (this._wasCausedByTouch(event)) {\\n                this._origin = \\'touch\\';\\n            }\\n            else {\\n                this._origin = \\'program\\';\\n            }\\n        }\\n        this._setClasses(element, this._origin);\\n        elementInfo.subject.next(this._origin);\\n        this._lastFocusOrigin = this._origin;\\n        this._origin = null;\\n    };\\n    /**\\n     * Handles blur events on a registered element.\\n     * @param {?} event The blur event.\\n     * @param {?} element The monitored element.\\n     * @return {?}\\n     */\\n    FocusOriginMonitor.prototype._onBlur = function (event, element) {\\n        // If we are counting child-element-focus as focused, make sure that we aren\\'t just blurring in\\n        // order to focus another child of the monitored element.\\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\\n            element.contains(event.relatedTarget))) {\\n            return;\\n        }\\n        this._setClasses(element);\\n        elementInfo.subject.next(null);\\n    };\\n    return FocusOriginMonitor;\\n}());\\nFocusOriginMonitor.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nFocusOriginMonitor.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */], },\\n]; };\\n/**\\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\\n * programmatically) and adds corresponding classes to the element.\\n *\\n * There are two variants of this directive:\\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\\n *    focused.\\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\\n */\\nvar CdkMonitorFocus = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _focusOriginMonitor\\n     * @param {?} renderer\\n     */\\n    function CdkMonitorFocus(_elementRef, _focusOriginMonitor, renderer) {\\n        var _this = this;\\n        this._elementRef = _elementRef;\\n        this._focusOriginMonitor = _focusOriginMonitor;\\n        this.cdkFocusChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        this._monitorSubscription = this._focusOriginMonitor.monitor(this._elementRef.nativeElement, renderer, this._elementRef.nativeElement.hasAttribute(\\'cdkMonitorSubtreeFocus\\'))\\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    CdkMonitorFocus.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._elementRef.nativeElement);\\n        this._monitorSubscription.unsubscribe();\\n    };\\n    return CdkMonitorFocus;\\n}());\\nCdkMonitorFocus.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkMonitorFocus.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusOriginMonitor, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\nCdkMonitorFocus.propDecorators = {\\n    \\'cdkFocusChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * @param {?} parentDispatcher\\n * @param {?} ngZone\\n * @param {?} platform\\n * @return {?}\\n */\\nfunction FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\\n    return parentDispatcher || new FocusOriginMonitor(ngZone, platform);\\n}\\nvar FOCUS_ORIGIN_MONITOR_PROVIDER = {\\n    // If there is already a FocusOriginMonitor available, use that. Otherwise, provide a new one.\\n    provide: FocusOriginMonitor,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), FocusOriginMonitor], __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */]],\\n    useFactory: FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY\\n};\\n/**\\n * Applies a CSS transform to an element, including browser-prefixed properties.\\n * @param {?} element\\n * @param {?} transformValue\\n * @return {?}\\n */\\nfunction applyCssTransform(element, transformValue) {\\n    // It\\'s important to trim the result, because the browser will ignore the set operation\\n    // if the string contains only whitespace.\\n    var /** @type {?} */ value = transformValue.trim();\\n    element.style.transform = value;\\n    element.style.webkitTransform = value;\\n}\\nvar StyleModule = /*@__PURE__*/(function () {\\n    function StyleModule() {\\n    }\\n    return StyleModule;\\n}());\\nStyleModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"M\" /* PlatformModule */]],\\n                declarations: [CdkMonitorFocus],\\n                exports: [CdkMonitorFocus],\\n                providers: [FOCUS_ORIGIN_MONITOR_PROVIDER],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nStyleModule.ctorParameters = function () { return []; };\\n/**\\n * \\\\@docs-private\\n */\\nvar AnimationCurves = /*@__PURE__*/(function () {\\n    function AnimationCurves() {\\n    }\\n    return AnimationCurves;\\n}());\\nAnimationCurves.STANDARD_CURVE = \\'cubic-bezier(0.4,0.0,0.2,1)\\';\\nAnimationCurves.DECELERATION_CURVE = \\'cubic-bezier(0.0,0.0,0.2,1)\\';\\nAnimationCurves.ACCELERATION_CURVE = \\'cubic-bezier(0.4,0.0,1,1)\\';\\nAnimationCurves.SHARP_CURVE = \\'cubic-bezier(0.4,0.0,0.6,1)\\';\\n/**\\n * \\\\@docs-private\\n */\\nvar AnimationDurations = /*@__PURE__*/(function () {\\n    function AnimationDurations() {\\n    }\\n    return AnimationDurations;\\n}());\\nAnimationDurations.COMPLEX = \\'375ms\\';\\nAnimationDurations.ENTERING = \\'225ms\\';\\nAnimationDurations.EXITING = \\'195ms\\';\\n/**\\n * Adapts type `D` to be usable as a date by cdk-based components that work with dates.\\n * @abstract\\n */\\nvar DateAdapter = /*@__PURE__*/(function () {\\n    function DateAdapter() {\\n    }\\n    /**\\n     * Gets the year component of the given date.\\n     * @abstract\\n     * @param {?} date The date to extract the year from.\\n     * @return {?} The year component.\\n     */\\n    DateAdapter.prototype.getYear = function (date) { };\\n    /**\\n     * Gets the month component of the given date.\\n     * @abstract\\n     * @param {?} date The date to extract the month from.\\n     * @return {?} The month component (0-indexed, 0 = January).\\n     */\\n    DateAdapter.prototype.getMonth = function (date) { };\\n    /**\\n     * Gets the date of the month component of the given date.\\n     * @abstract\\n     * @param {?} date The date to extract the date of the month from.\\n     * @return {?} The month component (1-indexed, 1 = first of month).\\n     */\\n    DateAdapter.prototype.getDate = function (date) { };\\n    /**\\n     * Gets the day of the week component of the given date.\\n     * @abstract\\n     * @param {?} date The date to extract the day of the week from.\\n     * @return {?} The month component (0-indexed, 0 = Sunday).\\n     */\\n    DateAdapter.prototype.getDayOfWeek = function (date) { };\\n    /**\\n     * Gets a list of names for the months.\\n     * @abstract\\n     * @param {?} style The naming style (e.g. long = \\'January\\', short = \\'Jan\\', narrow = \\'J\\').\\n     * @return {?} An ordered list of all month names, starting with January.\\n     */\\n    DateAdapter.prototype.getMonthNames = function (style$$1) { };\\n    /**\\n     * Gets a list of names for the dates of the month.\\n     * @abstract\\n     * @return {?} An ordered list of all date of the month names, starting with \\'1\\'.\\n     */\\n    DateAdapter.prototype.getDateNames = function () { };\\n    /**\\n     * Gets a list of names for the days of the week.\\n     * @abstract\\n     * @param {?} style The naming style (e.g. long = \\'Sunday\\', short = \\'Sun\\', narrow = \\'S\\').\\n     * @return {?} An ordered list of all weekday names, starting with Sunday.\\n     */\\n    DateAdapter.prototype.getDayOfWeekNames = function (style$$1) { };\\n    /**\\n     * Gets the name for the year of the given date.\\n     * @abstract\\n     * @param {?} date The date to get the year name for.\\n     * @return {?} The name of the given year (e.g. \\'2017\\').\\n     */\\n    DateAdapter.prototype.getYearName = function (date) { };\\n    /**\\n     * Gets the first day of the week.\\n     * @abstract\\n     * @return {?} The first day of the week (0-indexed, 0 = Sunday).\\n     */\\n    DateAdapter.prototype.getFirstDayOfWeek = function () { };\\n    /**\\n     * Gets the number of days in the month of the given date.\\n     * @abstract\\n     * @param {?} date The date whose month should be checked.\\n     * @return {?} The number of days in the month of the given date.\\n     */\\n    DateAdapter.prototype.getNumDaysInMonth = function (date) { };\\n    /**\\n     * Clones the given date.\\n     * @abstract\\n     * @param {?} date The date to clone\\n     * @return {?} A new date equal to the given date.\\n     */\\n    DateAdapter.prototype.clone = function (date) { };\\n    /**\\n     * Creates a date with the given year, month, and date. Does not allow over/under-flow of the\\n     * month and date.\\n     * @abstract\\n     * @param {?} year The full year of the date. (e.g. 89 means the year 89, not the year 1989).\\n     * @param {?} month The month of the date (0-indexed, 0 = January). Must be an integer 0 - 11.\\n     * @param {?} date The date of month of the date. Must be an integer 1 - length of the given month.\\n     * @return {?} The new date, or null if invalid.\\n     */\\n    DateAdapter.prototype.createDate = function (year, month, date) { };\\n    /**\\n     * Gets today\\'s date.\\n     * @abstract\\n     * @return {?} Today\\'s date.\\n     */\\n    DateAdapter.prototype.today = function () { };\\n    /**\\n     * Parses a date from a value.\\n     * @abstract\\n     * @param {?} value The value to parse.\\n     * @param {?} parseFormat The expected format of the value being parsed\\n     *     (type is implementation-dependent).\\n     * @return {?} The parsed date, or null if date could not be parsed.\\n     */\\n    DateAdapter.prototype.parse = function (value, parseFormat) { };\\n    /**\\n     * Formats a date as a string.\\n     * @abstract\\n     * @param {?} date The value to parse.\\n     * @param {?} displayFormat The format to use to display the date as a string.\\n     * @return {?} The parsed date, or null if date could not be parsed.\\n     */\\n    DateAdapter.prototype.format = function (date, displayFormat) { };\\n    /**\\n     * Adds the given number of years to the date. Years are counted as if flipping 12 pages on the\\n     * calendar for each year and then finding the closest date in the new month. For example when\\n     * adding 1 year to Feb 29, 2016, the resulting date will be Feb 28, 2017.\\n     * @abstract\\n     * @param {?} date The date to add years to.\\n     * @param {?} years The number of years to add (may be negative).\\n     * @return {?} A new date equal to the given one with the specified number of years added.\\n     */\\n    DateAdapter.prototype.addCalendarYears = function (date, years) { };\\n    /**\\n     * Adds the given number of months to the date. Months are counted as if flipping a page on the\\n     * calendar for each month and then finding the closest date in the new month. For example when\\n     * adding 1 month to Jan 31, 2017, the resulting date will be Feb 28, 2017.\\n     * @abstract\\n     * @param {?} date The date to add months to.\\n     * @param {?} months The number of months to add (may be negative).\\n     * @return {?} A new date equal to the given one with the specified number of months added.\\n     */\\n    DateAdapter.prototype.addCalendarMonths = function (date, months) { };\\n    /**\\n     * Adds the given number of days to the date. Days are counted as if moving one cell on the\\n     * calendar for each day.\\n     * @abstract\\n     * @param {?} date The date to add days to.\\n     * @param {?} days The number of days to add (may be negative).\\n     * @return {?} A new date equal to the given one with the specified number of days added.\\n     */\\n    DateAdapter.prototype.addCalendarDays = function (date, days) { };\\n    /**\\n     * Gets the RFC 3339 compatible date string (https://tools.ietf.org/html/rfc3339)  for the given\\n     * date.\\n     * @abstract\\n     * @param {?} date The date to get the ISO date string for.\\n     * @return {?} The ISO date string date string.\\n     */\\n    DateAdapter.prototype.getISODateString = function (date) { };\\n    /**\\n     * Sets the locale used for all dates.\\n     * @param {?} locale The new locale.\\n     * @return {?}\\n     */\\n    DateAdapter.prototype.setLocale = function (locale) {\\n        this.locale = locale;\\n    };\\n    /**\\n     * Compares two dates.\\n     * @param {?} first The first date to compare.\\n     * @param {?} second The second date to compare.\\n     * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,\\n     *     a number greater than 0 if the first date is later.\\n     */\\n    DateAdapter.prototype.compareDate = function (first$$1, second) {\\n        return this.getYear(first$$1) - this.getYear(second) ||\\n            this.getMonth(first$$1) - this.getMonth(second) ||\\n            this.getDate(first$$1) - this.getDate(second);\\n    };\\n    /**\\n     * Checks if two dates are equal.\\n     * @param {?} first The first date to check.\\n     * @param {?} second The second date to check.\\n     *     Null dates are considered equal to other null dates.\\n     * @return {?}\\n     */\\n    DateAdapter.prototype.sameDate = function (first$$1, second) {\\n        return first$$1 && second ? !this.compareDate(first$$1, second) : first$$1 == second;\\n    };\\n    /**\\n     * Clamp the given date between min and max dates.\\n     * @param {?} date The date to clamp.\\n     * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.\\n     * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.\\n     * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,\\n     *     otherwise `date`.\\n     */\\n    DateAdapter.prototype.clampDate = function (date, min, max) {\\n        if (min && this.compareDate(date, min) < 0) {\\n            return min;\\n        }\\n        if (max && this.compareDate(date, max) > 0) {\\n            return max;\\n        }\\n        return date;\\n    };\\n    return DateAdapter;\\n}());\\n/**\\n * Whether the browser supports the Intl API.\\n */\\nvar SUPPORTS_INTL_API = typeof Intl != \\'undefined\\';\\n/**\\n * The default month names to use if Intl API is not available.\\n */\\nvar DEFAULT_MONTH_NAMES = {\\n    \\'long\\': [\\n        \\'January\\', \\'February\\', \\'March\\', \\'April\\', \\'May\\', \\'June\\', \\'July\\', \\'August\\', \\'September\\',\\n        \\'October\\', \\'November\\', \\'December\\'\\n    ],\\n    \\'short\\': [\\'Jan\\', \\'Feb\\', \\'Mar\\', \\'Apr\\', \\'May\\', \\'Jun\\', \\'Jul\\', \\'Aug\\', \\'Sep\\', \\'Oct\\', \\'Nov\\', \\'Dec\\'],\\n    \\'narrow\\': [\\'J\\', \\'F\\', \\'M\\', \\'A\\', \\'M\\', \\'J\\', \\'J\\', \\'A\\', \\'S\\', \\'O\\', \\'N\\', \\'D\\']\\n};\\n/**\\n * The default date names to use if Intl API is not available.\\n */\\nvar DEFAULT_DATE_NAMES = range(31, function (i) { return String(i + 1); });\\n/**\\n * The default day of the week names to use if Intl API is not available.\\n */\\nvar DEFAULT_DAY_OF_WEEK_NAMES = {\\n    \\'long\\': [\\'Sunday\\', \\'Monday\\', \\'Tuesday\\', \\'Wednesday\\', \\'Thursday\\', \\'Friday\\', \\'Saturday\\'],\\n    \\'short\\': [\\'Sun\\', \\'Mon\\', \\'Tue\\', \\'Wed\\', \\'Thu\\', \\'Fri\\', \\'Sat\\'],\\n    \\'narrow\\': [\\'S\\', \\'M\\', \\'T\\', \\'W\\', \\'T\\', \\'F\\', \\'S\\']\\n};\\n/**\\n * Creates an array and fills it with values.\\n * @template T\\n * @param {?} length\\n * @param {?} valueFunction\\n * @return {?}\\n */\\nfunction range(length, valueFunction) {\\n    var /** @type {?} */ valuesArray = Array(length);\\n    for (var /** @type {?} */ i = 0; i < length; i++) {\\n        valuesArray[i] = valueFunction(i);\\n    }\\n    return valuesArray;\\n}\\n/**\\n * Adapts the native JS Date for use with cdk-based components that work with dates.\\n */\\nvar NativeDateAdapter = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](NativeDateAdapter, _super);\\n    function NativeDateAdapter() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getYear = function (date) {\\n        return date.getFullYear();\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getMonth = function (date) {\\n        return date.getMonth();\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getDate = function (date) {\\n        return date.getDate();\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getDayOfWeek = function (date) {\\n        return date.getDay();\\n    };\\n    /**\\n     * @param {?} style\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getMonthNames = function (style$$1) {\\n        var _this = this;\\n        if (SUPPORTS_INTL_API) {\\n            var /** @type {?} */ dtf_1 = new Intl.DateTimeFormat(this.locale, { month: style$$1 });\\n            return range(12, function (i) { return _this._stripDirectionalityCharacters(dtf_1.format(new Date(2017, i, 1))); });\\n        }\\n        return DEFAULT_MONTH_NAMES[style$$1];\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getDateNames = function () {\\n        var _this = this;\\n        if (SUPPORTS_INTL_API) {\\n            var /** @type {?} */ dtf_2 = new Intl.DateTimeFormat(this.locale, { day: \\'numeric\\' });\\n            return range(31, function (i) { return _this._stripDirectionalityCharacters(dtf_2.format(new Date(2017, 0, i + 1))); });\\n        }\\n        return DEFAULT_DATE_NAMES;\\n    };\\n    /**\\n     * @param {?} style\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getDayOfWeekNames = function (style$$1) {\\n        var _this = this;\\n        if (SUPPORTS_INTL_API) {\\n            var /** @type {?} */ dtf_3 = new Intl.DateTimeFormat(this.locale, { weekday: style$$1 });\\n            return range(7, function (i) { return _this._stripDirectionalityCharacters(dtf_3.format(new Date(2017, 0, i + 1))); });\\n        }\\n        return DEFAULT_DAY_OF_WEEK_NAMES[style$$1];\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getYearName = function (date) {\\n        if (SUPPORTS_INTL_API) {\\n            var /** @type {?} */ dtf = new Intl.DateTimeFormat(this.locale, { year: \\'numeric\\' });\\n            return this._stripDirectionalityCharacters(dtf.format(date));\\n        }\\n        return String(this.getYear(date));\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getFirstDayOfWeek = function () {\\n        // We can\\'t tell using native JS Date what the first day of the week is, we default to Sunday.\\n        return 0;\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getNumDaysInMonth = function (date) {\\n        return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.clone = function (date) {\\n        return this.createDate(this.getYear(date), this.getMonth(date), this.getDate(date));\\n    };\\n    /**\\n     * @param {?} year\\n     * @param {?} month\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.createDate = function (year, month, date) {\\n        // Check for invalid month and date (except upper bound on date which we have to check after\\n        // creating the Date).\\n        if (month < 0 || month > 11) {\\n            throw Error(\"Invalid month index \\\\\"\" + month + \"\\\\\". Month index has to be between 0 and 11.\");\\n        }\\n        if (date < 1) {\\n            throw Error(\"Invalid date \\\\\"\" + date + \"\\\\\". Date has to be greater than 0.\");\\n        }\\n        var /** @type {?} */ result = this._createDateWithOverflow(year, month, date);\\n        // Check that the date wasn\\'t above the upper bound for the month, causing the month to overflow\\n        if (result.getMonth() != month) {\\n            throw Error(\"Invalid date \\\\\"\" + date + \"\\\\\" for month with index \\\\\"\" + month + \"\\\\\".\");\\n        }\\n        return result;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.today = function () {\\n        return new Date();\\n    };\\n    /**\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.parse = function (value) {\\n        // We have no way using the native JS Date to set the parse format or locale, so we ignore these\\n        // parameters.\\n        var /** @type {?} */ timestamp = typeof value == \\'number\\' ? value : Date.parse(value);\\n        return isNaN(timestamp) ? null : new Date(timestamp);\\n    };\\n    /**\\n     * @param {?} date\\n     * @param {?} displayFormat\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.format = function (date, displayFormat) {\\n        if (SUPPORTS_INTL_API) {\\n            var /** @type {?} */ dtf = new Intl.DateTimeFormat(this.locale, displayFormat);\\n            return this._stripDirectionalityCharacters(dtf.format(date));\\n        }\\n        return this._stripDirectionalityCharacters(date.toDateString());\\n    };\\n    /**\\n     * @param {?} date\\n     * @param {?} years\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.addCalendarYears = function (date, years) {\\n        return this.addCalendarMonths(date, years * 12);\\n    };\\n    /**\\n     * @param {?} date\\n     * @param {?} months\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.addCalendarMonths = function (date, months) {\\n        var /** @type {?} */ newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));\\n        // It\\'s possible to wind up in the wrong month if the original month has more days than the new\\n        // month. In this case we want to go to the last day of the desired month.\\n        // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn\\'t\\n        // guarantee this.\\n        if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {\\n            newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);\\n        }\\n        return newDate;\\n    };\\n    /**\\n     * @param {?} date\\n     * @param {?} days\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.addCalendarDays = function (date, days) {\\n        return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);\\n    };\\n    /**\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype.getISODateString = function (date) {\\n        return [\\n            date.getUTCFullYear(),\\n            this._2digit(date.getUTCMonth() + 1),\\n            this._2digit(date.getUTCDate())\\n        ].join(\\'-\\');\\n    };\\n    /**\\n     * Creates a date but allows the month and date to overflow.\\n     * @param {?} year\\n     * @param {?} month\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    NativeDateAdapter.prototype._createDateWithOverflow = function (year, month, date) {\\n        var /** @type {?} */ result = new Date(year, month, date);\\n        // We need to correct for the fact that JS native Date treats years in range [0, 99] as\\n        // abbreviations for 19xx.\\n        if (year >= 0 && year < 100) {\\n            result.setFullYear(this.getYear(result) - 1900);\\n        }\\n        return result;\\n    };\\n    /**\\n     * Pads a number to make it two digits.\\n     * @param {?} n The number to pad.\\n     * @return {?} The padded number.\\n     */\\n    NativeDateAdapter.prototype._2digit = function (n) {\\n        return (\\'00\\' + n).slice(-2);\\n    };\\n    /**\\n     * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while\\n     * other browsers do not. We remove them to make output consistent and because they interfere with\\n     * date parsing.\\n     * @param {?} str The string to strip direction characters from.\\n     * @return {?} The stripped string.\\n     */\\n    NativeDateAdapter.prototype._stripDirectionalityCharacters = function (str) {\\n        return str.replace(/[\\\\u200e\\\\u200f]/g, \\'\\');\\n    };\\n    return NativeDateAdapter;\\n}(DateAdapter));\\nvar MD_DATE_FORMATS = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-date-formats\\');\\nvar MD_NATIVE_DATE_FORMATS = {\\n    parse: {\\n        dateInput: null,\\n    },\\n    display: {\\n        dateInput: { year: \\'numeric\\', month: \\'numeric\\', day: \\'numeric\\' },\\n        monthYearLabel: { year: \\'numeric\\', month: \\'short\\' },\\n        dateA11yLabel: { year: \\'numeric\\', month: \\'long\\', day: \\'numeric\\' },\\n        monthYearA11yLabel: { year: \\'numeric\\', month: \\'long\\' },\\n    }\\n};\\nvar NativeDateModule = /*@__PURE__*/(function () {\\n    function NativeDateModule() {\\n    }\\n    return NativeDateModule;\\n}());\\nNativeDateModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                providers: [{ provide: DateAdapter, useClass: NativeDateAdapter }],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nNativeDateModule.ctorParameters = function () { return []; };\\nvar MdNativeDateModule = /*@__PURE__*/(function () {\\n    function MdNativeDateModule() {\\n    }\\n    return MdNativeDateModule;\\n}());\\nMdNativeDateModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [NativeDateModule],\\n                providers: [{ provide: MD_DATE_FORMATS, useValue: MD_NATIVE_DATE_FORMATS }],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdNativeDateModule.ctorParameters = function () { return []; };\\n/**\\n * InjectionToken that can be used to specify the global placeholder options.\\n */\\nvar MD_PLACEHOLDER_GLOBAL_OPTIONS = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-placeholder-global-options\\');\\n/**\\n * Injection token that can be used to specify the global error options.\\n */\\nvar MD_ERROR_GLOBAL_OPTIONS = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-error-global-options\\');\\n/**\\n * Returns whether control is invalid and is either touched or is a part of a submitted form.\\n * @param {?} control\\n * @param {?} form\\n * @return {?}\\n */\\nfunction defaultErrorStateMatcher(control, form) {\\n    var /** @type {?} */ isSubmitted = form && form.submitted;\\n    return !!(control.invalid && (control.touched || isSubmitted));\\n}\\n/**\\n * Returns whether control is invalid and is either dirty or is a part of a submitted form.\\n * @param {?} control\\n * @param {?} form\\n * @return {?}\\n */\\nfunction showOnDirtyErrorStateMatcher(control, form) {\\n    var /** @type {?} */ isSubmitted = form && form.submitted;\\n    return !!(control.invalid && (control.dirty || isSubmitted));\\n}\\nvar MdCoreModule = /*@__PURE__*/(function () {\\n    function MdCoreModule() {\\n    }\\n    return MdCoreModule;\\n}());\\nMdCoreModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    MdLineModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"d\" /* BidiModule */],\\n                    MdRippleModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"I\" /* ObserveContentModule */],\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"P\" /* PortalModule */],\\n                    OverlayModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"a\" /* A11yModule */],\\n                    MdOptionModule,\\n                    MdSelectionModule,\\n                ],\\n                exports: [\\n                    MdLineModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"d\" /* BidiModule */],\\n                    MdRippleModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"I\" /* ObserveContentModule */],\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"P\" /* PortalModule */],\\n                    OverlayModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"a\" /* A11yModule */],\\n                    MdOptionModule,\\n                    MdSelectionModule,\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCoreModule.ctorParameters = function () { return []; };\\n/**\\n * \\\\@docs-private\\n */\\nvar MdButtonToggleGroupBase = /*@__PURE__*/(function () {\\n    function MdButtonToggleGroupBase() {\\n    }\\n    return MdButtonToggleGroupBase;\\n}());\\nvar _MdButtonToggleGroupMixinBase = mixinDisabled(MdButtonToggleGroupBase);\\n/**\\n * Provider Expression that allows md-button-toggle-group to register as a ControlValueAccessor.\\n * This allows it to support [(ngModel)].\\n * \\\\@docs-private\\n */\\nvar MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdButtonToggleGroup; }),\\n    multi: true\\n};\\nvar _uniqueIdCounter$1 = 0;\\n/**\\n * Change event object emitted by MdButtonToggle.\\n */\\nvar MdButtonToggleChange = /*@__PURE__*/(function () {\\n    function MdButtonToggleChange() {\\n    }\\n    return MdButtonToggleChange;\\n}());\\n/**\\n * Exclusive selection button toggle group that behaves like a radio-button group.\\n */\\nvar MdButtonToggleGroup = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdButtonToggleGroup, _super);\\n    function MdButtonToggleGroup() {\\n        var _this = _super.apply(this, arguments) || this;\\n        /**\\n         * The value for the button toggle group. Should match currently selected button toggle.\\n         */\\n        _this._value = null;\\n        /**\\n         * The HTML name attribute applied to toggles in this group.\\n         */\\n        _this._name = \"md-button-toggle-group-\" + _uniqueIdCounter$1++;\\n        /**\\n         * Whether the button toggle group should be vertical.\\n         */\\n        _this._vertical = false;\\n        /**\\n         * The currently selected button toggle, should match the value.\\n         */\\n        _this._selected = null;\\n        /**\\n         * Whether the button toggle group is initialized or not.\\n         */\\n        _this._isInitialized = false;\\n        /**\\n         * The method to be called in order to update ngModel.\\n         * Now `ngModel` binding is not supported in multiple selection mode.\\n         */\\n        _this._controlValueAccessorChangeFn = function () { };\\n        /**\\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\\n         */\\n        _this.onTouched = function () { };\\n        /**\\n         * Event emitted when the group\\'s value changes.\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        return _this;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype.ngAfterViewInit = function () {\\n        this._isInitialized = true;\\n    };\\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"name\", {\\n        /**\\n         * `name` attribute for the underlying `input` element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._name;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._name = value;\\n            this._updateButtonToggleNames();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"vertical\", {\\n        /**\\n         * Whether the toggle group is vertical.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._vertical;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._vertical = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"value\", {\\n        /**\\n         * Value of the toggle group.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._value;\\n        },\\n        /**\\n         * @param {?} newValue\\n         * @return {?}\\n         */\\n        set: function (newValue) {\\n            if (this._value != newValue) {\\n                this._value = newValue;\\n                this._updateSelectedButtonToggleFromValue();\\n                // Only emit a change event if the view is completely initialized.\\n                // We don\\'t want to emit a change event for the initial values.\\n                if (this._isInitialized) {\\n                    this._emitChangeEvent();\\n                }\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"selected\", {\\n        /**\\n         * Whether the toggle group is selected.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._selected;\\n        },\\n        /**\\n         * @param {?} selected\\n         * @return {?}\\n         */\\n        set: function (selected) {\\n            this._selected = selected;\\n            this.value = selected ? selected.value : null;\\n            if (selected && !selected.checked) {\\n                selected.checked = true;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype._updateButtonToggleNames = function () {\\n        var _this = this;\\n        if (this._buttonToggles) {\\n            this._buttonToggles.forEach(function (toggle) {\\n                toggle.name = _this._name;\\n            });\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype._updateSelectedButtonToggleFromValue = function () {\\n        var _this = this;\\n        var /** @type {?} */ isAlreadySelected = this._selected != null && this._selected.value == this._value;\\n        if (this._buttonToggles != null && !isAlreadySelected) {\\n            var /** @type {?} */ matchingButtonToggle = this._buttonToggles.filter(function (buttonToggle) { return buttonToggle.value == _this._value; })[0];\\n            if (matchingButtonToggle) {\\n                this.selected = matchingButtonToggle;\\n            }\\n            else if (this.value == null) {\\n                this.selected = null;\\n                this._buttonToggles.forEach(function (buttonToggle) {\\n                    buttonToggle.checked = false;\\n                });\\n            }\\n        }\\n    };\\n    /**\\n     * Dispatch change event with current selection and group value.\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype._emitChangeEvent = function () {\\n        var /** @type {?} */ event = new MdButtonToggleChange();\\n        event.source = this._selected;\\n        event.value = this._value;\\n        this._controlValueAccessorChangeFn(event.value);\\n        this.change.emit(event);\\n    };\\n    /**\\n     * Sets the model value. Implemented as part of ControlValueAccessor.\\n     * @param {?} value Value to be set to the model.\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype.writeValue = function (value) {\\n        this.value = value;\\n    };\\n    /**\\n     * Registers a callback that will be triggered when the value has changed.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn On change callback function.\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype.registerOnChange = function (fn) {\\n        this._controlValueAccessorChangeFn = fn;\\n    };\\n    /**\\n     * Registers a callback that will be triggered when the control has been touched.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn On touch callback function.\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype.registerOnTouched = function (fn) {\\n        this.onTouched = fn;\\n    };\\n    /**\\n     * Toggles the disabled state of the component. Implemented as part of ControlValueAccessor.\\n     * @param {?} isDisabled Whether the component should be disabled.\\n     * @return {?}\\n     */\\n    MdButtonToggleGroup.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n    };\\n    return MdButtonToggleGroup;\\n}(_MdButtonToggleGroupMixinBase));\\nMdButtonToggleGroup.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-button-toggle-group:not([multiple]), mat-button-toggle-group:not([multiple])\\',\\n                providers: [MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR],\\n                inputs: [\\'disabled\\'],\\n                host: {\\n                    \\'role\\': \\'radiogroup\\',\\n                    \\'class\\': \\'mat-button-toggle-group\\',\\n                    \\'[class.mat-button-toggle-vertical]\\': \\'vertical\\'\\n                },\\n                exportAs: \\'mdButtonToggleGroup\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonToggleGroup.ctorParameters = function () { return []; };\\nMdButtonToggleGroup.propDecorators = {\\n    \\'_buttonToggles\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdButtonToggle; }),] },],\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'vertical\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Multiple selection button-toggle group. `ngModel` is not supported in this mode.\\n */\\nvar MdButtonToggleGroupMultiple = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdButtonToggleGroupMultiple, _super);\\n    function MdButtonToggleGroupMultiple() {\\n        var _this = _super.apply(this, arguments) || this;\\n        /**\\n         * Whether the button toggle group should be vertical.\\n         */\\n        _this._vertical = false;\\n        return _this;\\n    }\\n    Object.defineProperty(MdButtonToggleGroupMultiple.prototype, \"vertical\", {\\n        /**\\n         * Whether the toggle group is vertical.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._vertical;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._vertical = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return MdButtonToggleGroupMultiple;\\n}(_MdButtonToggleGroupMixinBase));\\nMdButtonToggleGroupMultiple.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-button-toggle-group[multiple], mat-button-toggle-group[multiple]\\',\\n                exportAs: \\'mdButtonToggleGroup\\',\\n                inputs: [\\'disabled\\'],\\n                host: {\\n                    \\'class\\': \\'mat-button-toggle-group\\',\\n                    \\'[class.mat-button-toggle-vertical]\\': \\'vertical\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonToggleGroupMultiple.ctorParameters = function () { return []; };\\nMdButtonToggleGroupMultiple.propDecorators = {\\n    \\'vertical\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Single button inside of a toggle group.\\n */\\nvar MdButtonToggle = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} toggleGroup\\n     * @param {?} toggleGroupMultiple\\n     * @param {?} _buttonToggleDispatcher\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     * @param {?} _focusOriginMonitor\\n     */\\n    function MdButtonToggle(toggleGroup, toggleGroupMultiple, _buttonToggleDispatcher, _renderer, _elementRef, _focusOriginMonitor) {\\n        var _this = this;\\n        this._buttonToggleDispatcher = _buttonToggleDispatcher;\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n        this._focusOriginMonitor = _focusOriginMonitor;\\n        /**\\n         * Whether or not this button toggle is checked.\\n         */\\n        this._checked = false;\\n        /**\\n         * Whether or not this button toggle is disabled.\\n         */\\n        this._disabled = false;\\n        /**\\n         * Value assigned to this button toggle.\\n         */\\n        this._value = null;\\n        /**\\n         * Whether or not the button toggle is a single selection.\\n         */\\n        this._isSingleSelector = false;\\n        /**\\n         * Unregister function for _buttonToggleDispatcher *\\n         */\\n        this._removeUniqueSelectionListener = function () { };\\n        /**\\n         * Event emitted when the group value changes.\\n         */\\n        this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        this.buttonToggleGroup = toggleGroup;\\n        this.buttonToggleGroupMultiple = toggleGroupMultiple;\\n        if (this.buttonToggleGroup) {\\n            this._removeUniqueSelectionListener =\\n                _buttonToggleDispatcher.listen(function (id, name) {\\n                    if (id != _this.id && name == _this.name) {\\n                        _this.checked = false;\\n                    }\\n                });\\n            this._type = \\'radio\\';\\n            this.name = this.buttonToggleGroup.name;\\n            this._isSingleSelector = true;\\n        }\\n        else {\\n            // Even if there is no group at all, treat the button toggle as a checkbox so it can be\\n            // toggled on or off.\\n            this._type = \\'checkbox\\';\\n            this._isSingleSelector = false;\\n        }\\n    }\\n    Object.defineProperty(MdButtonToggle.prototype, \"inputId\", {\\n        /**\\n         * Unique ID for the underlying `input` element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.id + \"-input\";\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggle.prototype, \"checked\", {\\n        /**\\n         * Whether the button is checked.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._checked;\\n        },\\n        /**\\n         * @param {?} newCheckedState\\n         * @return {?}\\n         */\\n        set: function (newCheckedState) {\\n            if (this._isSingleSelector) {\\n                if (newCheckedState) {\\n                    // Notify all button toggles with the same name (in the same group) to un-check.\\n                    this._buttonToggleDispatcher.notify(this.id, this.name);\\n                }\\n            }\\n            this._checked = newCheckedState;\\n            if (newCheckedState && this._isSingleSelector && this.buttonToggleGroup.value != this.value) {\\n                this.buttonToggleGroup.selected = this;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggle.prototype, \"value\", {\\n        /**\\n         * MdButtonToggleGroup reads this to assign its own value.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._value;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._value != value) {\\n                if (this.buttonToggleGroup != null && this.checked) {\\n                    this.buttonToggleGroup.value = value;\\n                }\\n                this._value = value;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdButtonToggle.prototype, \"disabled\", {\\n        /**\\n         * Whether the button is disabled.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._disabled || (this.buttonToggleGroup != null && this.buttonToggleGroup.disabled) ||\\n                (this.buttonToggleGroupMultiple != null && this.buttonToggleGroupMultiple.disabled);\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype.ngOnInit = function () {\\n        if (this.id == null) {\\n            this.id = \"md-button-toggle-\" + _uniqueIdCounter$1++;\\n        }\\n        if (this.buttonToggleGroup && this._value == this.buttonToggleGroup.value) {\\n            this._checked = true;\\n        }\\n        this._focusOriginMonitor.monitor(this._elementRef.nativeElement, this._renderer, true);\\n    };\\n    /**\\n     * Focuses the button.\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype.focus = function () {\\n        this._inputElement.nativeElement.focus();\\n    };\\n    /**\\n     * Toggle the state of the current button toggle.\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype._toggle = function () {\\n        this.checked = !this.checked;\\n    };\\n    /**\\n     * Checks the button toggle due to an interaction with the underlying native input.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype._onInputChange = function (event) {\\n        event.stopPropagation();\\n        if (this._isSingleSelector) {\\n            // Propagate the change one-way via the group, which will in turn mark this\\n            // button toggle as checked.\\n            this.checked = true;\\n            this.buttonToggleGroup.selected = this;\\n            this.buttonToggleGroup.onTouched();\\n        }\\n        else {\\n            this._toggle();\\n        }\\n        // Emit a change event when the native input does.\\n        this._emitChangeEvent();\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype._onInputClick = function (event) {\\n        // We have to stop propagation for click events on the visual hidden input element.\\n        // By default, when a user clicks on a label element, a generated click event will be\\n        // dispatched on the associated input element. Since we are using a label element as our\\n        // root container, the click event on the `slide-toggle` will be executed twice.\\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\\n        // This will lead to multiple click events.\\n        // Preventing bubbling for the second event will solve that issue.\\n        event.stopPropagation();\\n    };\\n    /**\\n     * Dispatch change event with current value.\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype._emitChangeEvent = function () {\\n        var /** @type {?} */ event = new MdButtonToggleChange();\\n        event.source = this;\\n        event.value = this._value;\\n        this.change.emit(event);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdButtonToggle.prototype.ngOnDestroy = function () {\\n        this._removeUniqueSelectionListener();\\n    };\\n    return MdButtonToggle;\\n}());\\nMdButtonToggle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-button-toggle, mat-button-toggle\\',\\n                template: \"<label [attr.for]=\\\\\"inputId\\\\\" class=\\\\\"mat-button-toggle-label\\\\\"><input #input class=\\\\\"mat-button-toggle-input cdk-visually-hidden\\\\\" [type]=\\\\\"_type\\\\\" [id]=\\\\\"inputId\\\\\" [checked]=\\\\\"checked\\\\\" [disabled]=\\\\\"disabled || null\\\\\" [name]=\\\\\"name\\\\\" (change)=\\\\\"_onInputChange($event)\\\\\" (click)=\\\\\"_onInputClick($event)\\\\\"><div class=\\\\\"mat-button-toggle-label-content\\\\\"><ng-content></ng-content></div></label><div class=\\\\\"mat-button-toggle-focus-overlay\\\\\"></div>\",\\n                styles: [\".mat-button-toggle-group,.mat-button-toggle-standalone{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);position:relative;display:inline-flex;flex-direction:row;border-radius:2px;cursor:pointer;white-space:nowrap}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle-disabled .mat-button-toggle-label-content{cursor:default}.mat-button-toggle{white-space:nowrap;position:relative}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:1}.mat-button-toggle-label-content{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:inline-block;line-height:36px;padding:0 16px;cursor:pointer}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{border-radius:inherit;pointer-events:none;opacity:0;position:absolute;top:0;left:0;right:0;bottom:0}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'[class.mat-button-toggle-standalone]\\': \\'!buttonToggleGroup && !buttonToggleGroupMultiple\\',\\n                    \\'class\\': \\'mat-button-toggle\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonToggle.ctorParameters = function () { return [\\n    { type: MdButtonToggleGroup, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: MdButtonToggleGroupMultiple, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: UniqueSelectionDispatcher, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusOriginMonitor, },\\n]; };\\nMdButtonToggle.propDecorators = {\\n    \\'_inputElement\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'input\\',] },],\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'checked\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'class.mat-button-toggle-checked\\',] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'class.mat-button-toggle-disabled\\',] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdButtonToggleModule = /*@__PURE__*/(function () {\\n    function MdButtonToggleModule() {\\n    }\\n    return MdButtonToggleModule;\\n}());\\nMdButtonToggleModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"FormsModule\"], MdCommonModule, StyleModule],\\n                exports: [\\n                    MdButtonToggleGroup,\\n                    MdButtonToggleGroupMultiple,\\n                    MdButtonToggle,\\n                    MdCommonModule,\\n                ],\\n                declarations: [MdButtonToggleGroup, MdButtonToggleGroupMultiple, MdButtonToggle],\\n                providers: [UNIQUE_SELECTION_DISPATCHER_PROVIDER]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonToggleModule.ctorParameters = function () { return []; };\\n/**\\n * Default color palette for round buttons (md-fab and md-mini-fab)\\n */\\nvar DEFAULT_ROUND_BUTTON_COLOR = \\'accent\\';\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdButtonCssMatStyler = /*@__PURE__*/(function () {\\n    function MdButtonCssMatStyler() {\\n    }\\n    return MdButtonCssMatStyler;\\n}());\\nMdButtonCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-button], button[mat-button], a[md-button], a[mat-button]\\',\\n                host: { \\'class\\': \\'mat-button\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdRaisedButtonCssMatStyler = /*@__PURE__*/(function () {\\n    function MdRaisedButtonCssMatStyler() {\\n    }\\n    return MdRaisedButtonCssMatStyler;\\n}());\\nMdRaisedButtonCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-raised-button], button[mat-raised-button], \\' +\\n                    \\'a[md-raised-button], a[mat-raised-button]\\',\\n                host: { \\'class\\': \\'mat-raised-button\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRaisedButtonCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdIconButtonCssMatStyler = /*@__PURE__*/(function () {\\n    function MdIconButtonCssMatStyler() {\\n    }\\n    return MdIconButtonCssMatStyler;\\n}());\\nMdIconButtonCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-icon-button], button[mat-icon-button], a[md-icon-button], a[mat-icon-button]\\',\\n                host: { \\'class\\': \\'mat-icon-button\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdIconButtonCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdFab = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} button\\n     * @param {?} anchor\\n     */\\n    function MdFab(button, anchor) {\\n        // Set the default color palette for the md-fab components.\\n        (button || anchor).color = DEFAULT_ROUND_BUTTON_COLOR;\\n    }\\n    return MdFab;\\n}());\\nMdFab.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-fab], button[mat-fab], a[md-fab], a[mat-fab]\\',\\n                host: { \\'class\\': \\'mat-fab\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdFab.ctorParameters = function () { return [\\n    { type: MdButton, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdButton; }),] },] },\\n    { type: MdAnchor, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdAnchor; }),] },] },\\n]; };\\n/**\\n * Directive that targets mini-fab buttons and anchors. It\\'s used to apply the `mat-` class\\n * to all mini-fab buttons and also is responsible for setting the default color palette.\\n * \\\\@docs-private\\n */\\nvar MdMiniFab = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} button\\n     * @param {?} anchor\\n     */\\n    function MdMiniFab(button, anchor) {\\n        // Set the default color palette for the md-mini-fab components.\\n        (button || anchor).color = DEFAULT_ROUND_BUTTON_COLOR;\\n    }\\n    return MdMiniFab;\\n}());\\nMdMiniFab.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-mini-fab], button[mat-mini-fab], a[md-mini-fab], a[mat-mini-fab]\\',\\n                host: { \\'class\\': \\'mat-mini-fab\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMiniFab.ctorParameters = function () { return [\\n    { type: MdButton, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdButton; }),] },] },\\n    { type: MdAnchor, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdAnchor; }),] },] },\\n]; };\\n/**\\n * \\\\@docs-private\\n */\\nvar MdButtonBase = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdButtonBase(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n    }\\n    return MdButtonBase;\\n}());\\nvar _MdButtonMixinBase = mixinColor(mixinDisabled(MdButtonBase));\\n/**\\n * Material design button.\\n */\\nvar MdButton = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdButton, _super);\\n    /**\\n     * @param {?} renderer\\n     * @param {?} elementRef\\n     * @param {?} _platform\\n     * @param {?} _focusOriginMonitor\\n     */\\n    function MdButton(renderer, elementRef, _platform, _focusOriginMonitor) {\\n        var _this = _super.call(this, renderer, elementRef) || this;\\n        _this._platform = _platform;\\n        _this._focusOriginMonitor = _focusOriginMonitor;\\n        /**\\n         * Whether the button is round.\\n         */\\n        _this._isRoundButton = _this._hasAttributeWithPrefix(\\'fab\\', \\'mini-fab\\');\\n        /**\\n         * Whether the button is icon button.\\n         */\\n        _this._isIconButton = _this._hasAttributeWithPrefix(\\'icon-button\\');\\n        /**\\n         * Whether the ripple effect on click should be disabled.\\n         */\\n        _this._disableRipple = false;\\n        _this._focusOriginMonitor.monitor(_this._elementRef.nativeElement, _this._renderer, true);\\n        return _this;\\n    }\\n    Object.defineProperty(MdButton.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect for this button is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this._disableRipple = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](v); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdButton.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._elementRef.nativeElement);\\n    };\\n    /**\\n     * Focuses the button.\\n     * @return {?}\\n     */\\n    MdButton.prototype.focus = function () {\\n        this._getHostElement().focus();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdButton.prototype._getHostElement = function () {\\n        return this._elementRef.nativeElement;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdButton.prototype._isRippleDisabled = function () {\\n        return this.disableRipple || this.disabled;\\n    };\\n    /**\\n     * Gets whether the button has one of the given attributes\\n     * with either an \\'md-\\' or \\'mat-\\' prefix.\\n     * @param {...?} unprefixedAttributeNames\\n     * @return {?}\\n     */\\n    MdButton.prototype._hasAttributeWithPrefix = function () {\\n        var _this = this;\\n        var unprefixedAttributeNames = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            unprefixedAttributeNames[_i] = arguments[_i];\\n        }\\n        // If not on the browser, say that there are none of the attributes present.\\n        // Since these only affect how the ripple displays (and ripples only happen on the client),\\n        // detecting these attributes isn\\'t necessary when not on the browser.\\n        if (!this._platform.isBrowser) {\\n            return false;\\n        }\\n        return unprefixedAttributeNames.some(function (suffix) {\\n            var /** @type {?} */ el = _this._getHostElement();\\n            return el.hasAttribute(\\'md-\\' + suffix) || el.hasAttribute(\\'mat-\\' + suffix);\\n        });\\n    };\\n    return MdButton;\\n}(_MdButtonMixinBase));\\nMdButton.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'button[md-button], button[md-raised-button], button[md-icon-button],\\' +\\n                    \\'button[md-fab], button[md-mini-fab],\\' +\\n                    \\'button[mat-button], button[mat-raised-button], button[mat-icon-button],\\' +\\n                    \\'button[mat-fab], button[mat-mini-fab]\\',\\n                host: {\\n                    \\'[disabled]\\': \\'disabled || null\\',\\n                },\\n                template: \"<span class=\\\\\"mat-button-wrapper\\\\\"><ng-content></ng-content></span><div md-ripple class=\\\\\"mat-button-ripple\\\\\" [class.mat-button-ripple-round]=\\\\\"_isRoundButton || _isIconButton\\\\\" [mdRippleDisabled]=\\\\\"_isRippleDisabled()\\\\\" [mdRippleCentered]=\\\\\"_isIconButton\\\\\" [mdRippleTrigger]=\\\\\"_getHostElement()\\\\\"></div><div class=\\\\\"mat-button-focus-overlay\\\\\"></div>\",\\n                styles: [\".mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:88px;line-height:36px;padding:0 16px;border-radius:2px}[disabled].mat-button,[disabled].mat-fab,[disabled].mat-icon-button,[disabled].mat-mini-fab,[disabled].mat-raised-button{cursor:default}.cdk-keyboard-focused.mat-button .mat-button-focus-overlay,.cdk-keyboard-focused.mat-fab .mat-button-focus-overlay,.cdk-keyboard-focused.mat-icon-button .mat-button-focus-overlay,.cdk-keyboard-focused.mat-mini-fab .mat-button-focus-overlay,.cdk-keyboard-focused.mat-raised-button .mat-button-focus-overlay{opacity:1}.mat-button::-moz-focus-inner,.mat-fab::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-mini-fab::-moz-focus-inner,.mat-raised-button::-moz-focus-inner{border:0}.mat-fab,.mat-mini-fab,.mat-raised-button{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-fab:not([disabled]):active,.mat-mini-fab:not([disabled]):active,.mat-raised-button:not([disabled]):active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}[disabled].mat-fab,[disabled].mat-mini-fab,[disabled].mat-raised-button{box-shadow:none}.mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{transition:none;opacity:0}.mat-button:hover .mat-button-focus-overlay{opacity:1}.mat-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-fab .mat-icon,.mat-fab i{padding:16px 0;line-height:24px}.mat-mini-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-mini-fab .mat-icon,.mat-mini-fab i{padding:8px 0;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button,.mat-icon-button,.mat-raised-button{color:currentColor}.mat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*{vertical-align:middle}.mat-button-focus-overlay,.mat-button-ripple{position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none}.mat-button-focus-overlay{background-color:rgba(0,0,0,.12);border-radius:inherit;opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}@media screen and (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:rgba(255,255,255,.5)}}.mat-button-ripple-round{border-radius:50%;z-index:1}@media screen and (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}\"],\\n                inputs: [\\'disabled\\', \\'color\\'],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButton.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */], },\\n    { type: FocusOriginMonitor, },\\n]; };\\nMdButton.propDecorators = {\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Raised Material design button.\\n */\\nvar MdAnchor = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdAnchor, _super);\\n    /**\\n     * @param {?} platform\\n     * @param {?} focusOriginMonitor\\n     * @param {?} elementRef\\n     * @param {?} renderer\\n     */\\n    function MdAnchor(platform, focusOriginMonitor, elementRef, renderer) {\\n        return _super.call(this, renderer, elementRef, platform, focusOriginMonitor) || this;\\n    }\\n    Object.defineProperty(MdAnchor.prototype, \"tabIndex\", {\\n        /**\\n         * \\\\@docs-private\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.disabled ? -1 : 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdAnchor.prototype._haltDisabledEvents = function (event) {\\n        // A disabled button shouldn\\'t apply any actions\\n        if (this.disabled) {\\n            event.preventDefault();\\n            event.stopImmediatePropagation();\\n        }\\n    };\\n    return MdAnchor;\\n}(MdButton));\\nMdAnchor.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \"a[md-button], a[md-raised-button], a[md-icon-button], a[md-fab], a[md-mini-fab],\\\\n             a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab], a[mat-mini-fab]\",\\n                host: {\\n                    \\'[attr.disabled]\\': \\'disabled || null\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled.toString()\\',\\n                    \\'(click)\\': \\'_haltDisabledEvents($event)\\',\\n                },\\n                inputs: [\\'disabled\\', \\'color\\'],\\n                template: \"<span class=\\\\\"mat-button-wrapper\\\\\"><ng-content></ng-content></span><div md-ripple class=\\\\\"mat-button-ripple\\\\\" [class.mat-button-ripple-round]=\\\\\"_isRoundButton || _isIconButton\\\\\" [mdRippleDisabled]=\\\\\"_isRippleDisabled()\\\\\" [mdRippleCentered]=\\\\\"_isIconButton\\\\\" [mdRippleTrigger]=\\\\\"_getHostElement()\\\\\"></div><div class=\\\\\"mat-button-focus-overlay\\\\\"></div>\",\\n                styles: [\".mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:88px;line-height:36px;padding:0 16px;border-radius:2px}[disabled].mat-button,[disabled].mat-fab,[disabled].mat-icon-button,[disabled].mat-mini-fab,[disabled].mat-raised-button{cursor:default}.cdk-keyboard-focused.mat-button .mat-button-focus-overlay,.cdk-keyboard-focused.mat-fab .mat-button-focus-overlay,.cdk-keyboard-focused.mat-icon-button .mat-button-focus-overlay,.cdk-keyboard-focused.mat-mini-fab .mat-button-focus-overlay,.cdk-keyboard-focused.mat-raised-button .mat-button-focus-overlay{opacity:1}.mat-button::-moz-focus-inner,.mat-fab::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-mini-fab::-moz-focus-inner,.mat-raised-button::-moz-focus-inner{border:0}.mat-fab,.mat-mini-fab,.mat-raised-button{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-fab:not([disabled]):active,.mat-mini-fab:not([disabled]):active,.mat-raised-button:not([disabled]):active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}[disabled].mat-fab,[disabled].mat-mini-fab,[disabled].mat-raised-button{box-shadow:none}.mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{transition:none;opacity:0}.mat-button:hover .mat-button-focus-overlay{opacity:1}.mat-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-fab .mat-icon,.mat-fab i{padding:16px 0;line-height:24px}.mat-mini-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-mini-fab .mat-icon,.mat-mini-fab i{padding:8px 0;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button,.mat-icon-button,.mat-raised-button{color:currentColor}.mat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*{vertical-align:middle}.mat-button-focus-overlay,.mat-button-ripple{position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none}.mat-button-focus-overlay{background-color:rgba(0,0,0,.12);border-radius:inherit;opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}@media screen and (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:rgba(255,255,255,.5)}}.mat-button-ripple-round{border-radius:50%;z-index:1}@media screen and (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdAnchor.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */], },\\n    { type: FocusOriginMonitor, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\nMdAnchor.propDecorators = {\\n    \\'tabIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'tabIndex\\',] },],\\n};\\nvar MdButtonModule = /*@__PURE__*/(function () {\\n    function MdButtonModule() {\\n    }\\n    return MdButtonModule;\\n}());\\nMdButtonModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"],\\n                    MdRippleModule,\\n                    MdCommonModule,\\n                    StyleModule,\\n                ],\\n                exports: [\\n                    MdButton,\\n                    MdAnchor,\\n                    MdMiniFab,\\n                    MdFab,\\n                    MdCommonModule,\\n                    MdButtonCssMatStyler,\\n                    MdRaisedButtonCssMatStyler,\\n                    MdIconButtonCssMatStyler,\\n                ],\\n                declarations: [\\n                    MdButton,\\n                    MdAnchor,\\n                    MdMiniFab,\\n                    MdFab,\\n                    MdButtonCssMatStyler,\\n                    MdRaisedButtonCssMatStyler,\\n                    MdIconButtonCssMatStyler,\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdButtonModule.ctorParameters = function () { return []; };\\n/**\\n * Monotonically increasing integer used to auto-generate unique ids for checkbox components.\\n */\\nvar nextId = 0;\\n/**\\n * Provider Expression that allows md-checkbox to register as a ControlValueAccessor.\\n * This allows it to support [(ngModel)].\\n * \\\\@docs-private\\n */\\nvar MD_CHECKBOX_CONTROL_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdCheckbox; }),\\n    multi: true\\n};\\nvar TransitionCheckState = {};\\nTransitionCheckState.Init = 0;\\nTransitionCheckState.Checked = 1;\\nTransitionCheckState.Unchecked = 2;\\nTransitionCheckState.Indeterminate = 3;\\nTransitionCheckState[TransitionCheckState.Init] = \"Init\";\\nTransitionCheckState[TransitionCheckState.Checked] = \"Checked\";\\nTransitionCheckState[TransitionCheckState.Unchecked] = \"Unchecked\";\\nTransitionCheckState[TransitionCheckState.Indeterminate] = \"Indeterminate\";\\n/**\\n * Change event object emitted by MdCheckbox.\\n */\\nvar MdCheckboxChange = /*@__PURE__*/(function () {\\n    function MdCheckboxChange() {\\n    }\\n    return MdCheckboxChange;\\n}());\\n/**\\n * \\\\@docs-private\\n */\\nvar MdCheckboxBase = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdCheckboxBase(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n    }\\n    return MdCheckboxBase;\\n}());\\nvar _MdCheckboxMixinBase = mixinColor(mixinDisabled(MdCheckboxBase), \\'accent\\');\\n/**\\n * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,\\n * and exposes a similar API. A MdCheckbox can be either checked, unchecked, indeterminate, or\\n * disabled. Note that all additional accessibility attributes are taken care of by the component,\\n * so there is no need to provide them yourself. However, if you want to omit a label and still\\n * have the checkbox be accessible, you may supply an [aria-label] input.\\n * See: https://www.google.com/design/spec/components/selection-controls.html\\n */\\nvar MdCheckbox = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdCheckbox, _super);\\n    /**\\n     * @param {?} renderer\\n     * @param {?} elementRef\\n     * @param {?} _changeDetectorRef\\n     * @param {?} _focusOriginMonitor\\n     */\\n    function MdCheckbox(renderer, elementRef, _changeDetectorRef, _focusOriginMonitor) {\\n        var _this = _super.call(this, renderer, elementRef) || this;\\n        _this._changeDetectorRef = _changeDetectorRef;\\n        _this._focusOriginMonitor = _focusOriginMonitor;\\n        /**\\n         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will\\n         * take precedence so this may be omitted.\\n         */\\n        _this.ariaLabel = \\'\\';\\n        /**\\n         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\\n         */\\n        _this.ariaLabelledby = null;\\n        /**\\n         * A unique id for the checkbox. If one is not supplied, it is auto-generated.\\n         */\\n        _this.id = \"md-checkbox-\" + ++nextId;\\n        /**\\n         * Whether the label should appear after or before the checkbox. Defaults to \\'after\\'\\n         */\\n        _this.labelPosition = \\'after\\';\\n        /**\\n         * Tabindex value that is passed to the underlying input element.\\n         */\\n        _this.tabIndex = 0;\\n        /**\\n         * Name value will be applied to the input element if present\\n         */\\n        _this.name = null;\\n        /**\\n         * Event emitted when the checkbox\\'s `checked` value changes.\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the checkbox\\'s `indeterminate` value changes.\\n         */\\n        _this.indeterminateChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\\n         * \\\\@docs-private\\n         */\\n        _this.onTouched = function () { };\\n        _this._currentAnimationClass = \\'\\';\\n        _this._currentCheckState = TransitionCheckState.Init;\\n        _this._checked = false;\\n        _this._indeterminate = false;\\n        _this._controlValueAccessorChangeFn = function () { };\\n        return _this;\\n    }\\n    Object.defineProperty(MdCheckbox.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect for this checkbox is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCheckbox.prototype, \"inputId\", {\\n        /**\\n         * ID of the native input element inside `<md-checkbox>`\\n         * @return {?}\\n         */\\n        get: function () {\\n            return \"input-\" + this.id;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCheckbox.prototype, \"required\", {\\n        /**\\n         * Whether the checkbox is required.\\n         * @return {?}\\n         */\\n        get: function () { return this._required; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._required = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCheckbox.prototype, \"align\", {\\n        /**\\n         * Whether or not the checkbox should appear before or after the label.\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () {\\n            // align refers to the checkbox relative to the label, while labelPosition refers to the\\n            // label relative to the checkbox. As such, they are inverted.\\n            return this.labelPosition == \\'after\\' ? \\'start\\' : \\'end\\';\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this.labelPosition = (v == \\'start\\') ? \\'after\\' : \\'before\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.ngAfterViewInit = function () {\\n        var _this = this;\\n        this._focusOriginMonitor\\n            .monitor(this._inputElement.nativeElement, this._renderer, false)\\n            .subscribe(function (focusOrigin) { return _this._onInputFocusChange(focusOrigin); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._inputElement.nativeElement);\\n    };\\n    Object.defineProperty(MdCheckbox.prototype, \"checked\", {\\n        /**\\n         * Whether the checkbox is checked.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._checked;\\n        },\\n        /**\\n         * @param {?} checked\\n         * @return {?}\\n         */\\n        set: function (checked) {\\n            if (checked != this.checked) {\\n                this._checked = checked;\\n                this._changeDetectorRef.markForCheck();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCheckbox.prototype, \"indeterminate\", {\\n        /**\\n         * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\\n         * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\\n         * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\\n         * set to false.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._indeterminate;\\n        },\\n        /**\\n         * @param {?} indeterminate\\n         * @return {?}\\n         */\\n        set: function (indeterminate) {\\n            var /** @type {?} */ changed = indeterminate != this._indeterminate;\\n            this._indeterminate = indeterminate;\\n            if (changed) {\\n                if (this._indeterminate) {\\n                    this._transitionCheckState(TransitionCheckState.Indeterminate);\\n                }\\n                else {\\n                    this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\\n                }\\n                this.indeterminateChange.emit(this._indeterminate);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._isRippleDisabled = function () {\\n        return this.disableRipple || this.disabled;\\n    };\\n    /**\\n     * Method being called whenever the label text changes.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._onLabelTextChange = function () {\\n        // This method is getting called whenever the label of the checkbox changes.\\n        // Since the checkbox uses the OnPush strategy we need to notify it about the change\\n        // that has been recognized by the cdkObserveContent directive.\\n        this._changeDetectorRef.markForCheck();\\n    };\\n    /**\\n     * Sets the model value. Implemented as part of ControlValueAccessor.\\n     * @param {?} value Value to be set to the model.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.writeValue = function (value) {\\n        this.checked = !!value;\\n    };\\n    /**\\n     * Registers a callback to be triggered when the value has changed.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Function to be called on change.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.registerOnChange = function (fn) {\\n        this._controlValueAccessorChangeFn = fn;\\n    };\\n    /**\\n     * Registers a callback to be triggered when the control has been touched.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Callback to be triggered when the checkbox is touched.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.registerOnTouched = function (fn) {\\n        this.onTouched = fn;\\n    };\\n    /**\\n     * Sets the checkbox\\'s disabled state. Implemented as a part of ControlValueAccessor.\\n     * @param {?} isDisabled Whether the checkbox should be disabled.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n        this._changeDetectorRef.markForCheck();\\n    };\\n    /**\\n     * @param {?} newState\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._transitionCheckState = function (newState) {\\n        var /** @type {?} */ oldState = this._currentCheckState;\\n        var /** @type {?} */ renderer = this._renderer;\\n        var /** @type {?} */ elementRef = this._elementRef;\\n        if (oldState === newState) {\\n            return;\\n        }\\n        if (this._currentAnimationClass.length > 0) {\\n            renderer.removeClass(elementRef.nativeElement, this._currentAnimationClass);\\n        }\\n        this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);\\n        this._currentCheckState = newState;\\n        if (this._currentAnimationClass.length > 0) {\\n            renderer.addClass(elementRef.nativeElement, this._currentAnimationClass);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._emitChangeEvent = function () {\\n        var /** @type {?} */ event = new MdCheckboxChange();\\n        event.source = this;\\n        event.checked = this.checked;\\n        this._controlValueAccessorChangeFn(this.checked);\\n        this.change.emit(event);\\n    };\\n    /**\\n     * Function is called whenever the focus changes for the input element.\\n     * @param {?} focusOrigin\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._onInputFocusChange = function (focusOrigin) {\\n        if (!this._focusRipple && focusOrigin === \\'keyboard\\') {\\n            this._focusRipple = this._ripple.launch(0, 0, { persistent: true, centered: true });\\n        }\\n        else if (!focusOrigin) {\\n            this._removeFocusRipple();\\n            this.onTouched();\\n        }\\n    };\\n    /**\\n     * Toggles the `checked` state of the checkbox.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.toggle = function () {\\n        this.checked = !this.checked;\\n    };\\n    /**\\n     * Event handler for checkbox input element.\\n     * Toggles checked state if element is not disabled.\\n     * Do not toggle on (change) event since IE doesn\\'t fire change event when\\n     *   indeterminate checkbox is clicked.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._onInputClick = function (event) {\\n        var _this = this;\\n        // We have to stop propagation for click events on the visual hidden input element.\\n        // By default, when a user clicks on a label element, a generated click event will be\\n        // dispatched on the associated input element. Since we are using a label element as our\\n        // root container, the click event on the `checkbox` will be executed twice.\\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\\n        // This will lead to multiple click events.\\n        // Preventing bubbling for the second event will solve that issue.\\n        event.stopPropagation();\\n        this._removeFocusRipple();\\n        if (!this.disabled) {\\n            // When user manually click on the checkbox, `indeterminate` is set to false.\\n            if (this._indeterminate) {\\n                Promise.resolve().then(function () {\\n                    _this._indeterminate = false;\\n                    _this.indeterminateChange.emit(_this._indeterminate);\\n                });\\n            }\\n            this.toggle();\\n            this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\\n            // Emit our custom change event if the native input emitted one.\\n            // It is important to only emit it, if the native input triggered one, because\\n            // we don\\'t want to trigger a change event, when the `checked` variable changes for example.\\n            this._emitChangeEvent();\\n        }\\n    };\\n    /**\\n     * Focuses the checkbox.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype.focus = function () {\\n        this._focusOriginMonitor.focusVia(this._inputElement.nativeElement, \\'keyboard\\');\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._onInteractionEvent = function (event) {\\n        // We always have to stop propagation on the change event.\\n        // Otherwise the change event, from the input element, will bubble up and\\n        // emit its event object to the `change` output.\\n        event.stopPropagation();\\n    };\\n    /**\\n     * @param {?} oldState\\n     * @param {?} newState\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._getAnimationClassForCheckStateTransition = function (oldState, newState) {\\n        var /** @type {?} */ animSuffix = \\'\\';\\n        switch (oldState) {\\n            case TransitionCheckState.Init:\\n                // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or\\n                // [checked] bound to it.\\n                if (newState === TransitionCheckState.Checked) {\\n                    animSuffix = \\'unchecked-checked\\';\\n                }\\n                else if (newState == TransitionCheckState.Indeterminate) {\\n                    animSuffix = \\'unchecked-indeterminate\\';\\n                }\\n                else {\\n                    return \\'\\';\\n                }\\n                break;\\n            case TransitionCheckState.Unchecked:\\n                animSuffix = newState === TransitionCheckState.Checked ?\\n                    \\'unchecked-checked\\' : \\'unchecked-indeterminate\\';\\n                break;\\n            case TransitionCheckState.Checked:\\n                animSuffix = newState === TransitionCheckState.Unchecked ?\\n                    \\'checked-unchecked\\' : \\'checked-indeterminate\\';\\n                break;\\n            case TransitionCheckState.Indeterminate:\\n                animSuffix = newState === TransitionCheckState.Checked ?\\n                    \\'indeterminate-checked\\' : \\'indeterminate-unchecked\\';\\n                break;\\n        }\\n        return \"mat-checkbox-anim-\" + animSuffix;\\n    };\\n    /**\\n     * Fades out the focus state ripple.\\n     * @return {?}\\n     */\\n    MdCheckbox.prototype._removeFocusRipple = function () {\\n        if (this._focusRipple) {\\n            this._focusRipple.fadeOut();\\n            this._focusRipple = null;\\n        }\\n    };\\n    return MdCheckbox;\\n}(_MdCheckboxMixinBase));\\nMdCheckbox.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-checkbox, mat-checkbox\\',\\n                template: \"<label [attr.for]=\\\\\"inputId\\\\\" class=\\\\\"mat-checkbox-layout\\\\\" #label><div class=\\\\\"mat-checkbox-inner-container\\\\\" [class.mat-checkbox-inner-container-no-side-margin]=\\\\\"!checkboxLabel.textContent.trim()\\\\\"><input #input class=\\\\\"mat-checkbox-input cdk-visually-hidden\\\\\" type=\\\\\"checkbox\\\\\" [id]=\\\\\"inputId\\\\\" [required]=\\\\\"required\\\\\" [checked]=\\\\\"checked\\\\\" [value]=\\\\\"value\\\\\" [disabled]=\\\\\"disabled\\\\\" [name]=\\\\\"name\\\\\" [tabIndex]=\\\\\"tabIndex\\\\\" [indeterminate]=\\\\\"indeterminate\\\\\" [attr.aria-label]=\\\\\"ariaLabel\\\\\" [attr.aria-labelledby]=\\\\\"ariaLabelledby\\\\\" (change)=\\\\\"_onInteractionEvent($event)\\\\\" (click)=\\\\\"_onInputClick($event)\\\\\"><div md-ripple class=\\\\\"mat-checkbox-ripple\\\\\" [mdRippleTrigger]=\\\\\"label\\\\\" [mdRippleDisabled]=\\\\\"_isRippleDisabled()\\\\\" [mdRippleCentered]=\\\\\"true\\\\\"></div><div class=\\\\\"mat-checkbox-frame\\\\\"></div><div class=\\\\\"mat-checkbox-background\\\\\"><svg version=\\\\\"1.1\\\\\" class=\\\\\"mat-checkbox-checkmark\\\\\" xmlns=\\\\\"http://www.w3.org/2000/svg\\\\\" viewBox=\\\\\"0 0 24 24\\\\\" xml:space=\\\\\"preserve\\\\\"><path class=\\\\\"mat-checkbox-checkmark-path\\\\\" fill=\\\\\"none\\\\\" stroke=\\\\\"white\\\\\" d=\\\\\"M4.1,12.7 9,17.6 20.3,6.3\\\\\"/></svg><div class=\\\\\"mat-checkbox-mixedmark\\\\\"></div></div></div><span class=\\\\\"mat-checkbox-label\\\\\" #checkboxLabel (cdkObserveContent)=\\\\\"_onLabelTextChange()\\\\\"><span style=\\\\\"display:none\\\\\">&nbsp;</span><ng-content></ng-content></span></label>\",\\n                styles: [\"@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.91026}50%{animation-timing-function:cubic-bezier(0,0,.2,.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0,0,0,1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(.4,0,1,1);stroke-dashoffset:0}to{stroke-dashoffset:-22.91026}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}100%,32.8%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-checkmark,.mat-checkbox-frame{bottom:0;left:0;position:absolute;right:0;top:0}.mat-checkbox-checkmark,.mat-checkbox-mixedmark{width:calc(100% - 4px)}.mat-checkbox-background,.mat-checkbox-frame{border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);cursor:pointer}.mat-checkbox-layout{cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex}.mat-checkbox-inner-container{display:inline-block;height:20px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:20px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0,0,.2,.1);border-width:2px;border-style:solid}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0,0,.2,.1),opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-checkbox-checkmark{width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.91026;stroke-dasharray:22.91026;stroke-width:2.66667px}.mat-checkbox-mixedmark{height:2px;opacity:0;transform:scaleX(0) rotate(0)}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0s mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0s mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:.3s linear 0s mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox-ripple{position:absolute;left:-15px;top:-15px;right:-15px;bottom:-15px;border-radius:50%;z-index:1;pointer-events:none}\"],\\n                host: {\\n                    \\'class\\': \\'mat-checkbox\\',\\n                    \\'[class.mat-checkbox-indeterminate]\\': \\'indeterminate\\',\\n                    \\'[class.mat-checkbox-checked]\\': \\'checked\\',\\n                    \\'[class.mat-checkbox-disabled]\\': \\'disabled\\',\\n                    \\'[class.mat-checkbox-label-before]\\': \\'labelPosition == \"before\"\\',\\n                },\\n                providers: [MD_CHECKBOX_CONTROL_VALUE_ACCESSOR],\\n                inputs: [\\'disabled\\', \\'color\\'],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCheckbox.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: FocusOriginMonitor, },\\n]; };\\nMdCheckbox.propDecorators = {\\n    \\'ariaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'ariaLabelledby\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-labelledby\\',] },],\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'required\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'labelPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'tabIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'indeterminateChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_inputElement\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'input\\',] },],\\n    \\'_ripple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdRipple,] },],\\n    \\'checked\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'indeterminate\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdCheckboxModule = /*@__PURE__*/(function () {\\n    function MdCheckboxModule() {\\n    }\\n    return MdCheckboxModule;\\n}());\\nMdCheckboxModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"], MdRippleModule, MdCommonModule, __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"I\" /* ObserveContentModule */]],\\n                exports: [MdCheckbox, MdCommonModule],\\n                declarations: [MdCheckbox],\\n                providers: [FocusOriginMonitor]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCheckboxModule.ctorParameters = function () { return []; };\\n/**\\n * Provider Expression that allows md-radio-group to register as a ControlValueAccessor. This\\n * allows it to support [(ngModel)] and ngControl.\\n * \\\\@docs-private\\n */\\nvar MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdRadioGroup; }),\\n    multi: true\\n};\\nvar _uniqueIdCounter$2 = 0;\\n/**\\n * Change event object emitted by MdRadio and MdRadioGroup.\\n */\\nvar MdRadioChange = /*@__PURE__*/(function () {\\n    function MdRadioChange() {\\n    }\\n    return MdRadioChange;\\n}());\\n/**\\n * \\\\@docs-private\\n */\\nvar MdRadioGroupBase = /*@__PURE__*/(function () {\\n    function MdRadioGroupBase() {\\n    }\\n    return MdRadioGroupBase;\\n}());\\nvar _MdRadioGroupMixinBase = mixinDisabled(MdRadioGroupBase);\\n/**\\n * A group of radio buttons. May contain one or more `<md-radio-button>` elements.\\n */\\nvar MdRadioGroup = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdRadioGroup, _super);\\n    /**\\n     * @param {?} _changeDetector\\n     */\\n    function MdRadioGroup(_changeDetector) {\\n        var _this = _super.call(this) || this;\\n        _this._changeDetector = _changeDetector;\\n        /**\\n         * Selected value for group. Should equal the value of the selected radio button if there *is*\\n         * a corresponding radio button with a matching value. If there is *not* such a corresponding\\n         * radio button, this value persists to be applied in case a new radio button is added with a\\n         * matching value.\\n         */\\n        _this._value = null;\\n        /**\\n         * The HTML name attribute applied to radio buttons in this group.\\n         */\\n        _this._name = \"md-radio-group-\" + _uniqueIdCounter$2++;\\n        /**\\n         * The currently selected radio button. Should match value.\\n         */\\n        _this._selected = null;\\n        /**\\n         * Whether the `value` has been set to its initial value.\\n         */\\n        _this._isInitialized = false;\\n        /**\\n         * Whether the labels should appear after or before the radio-buttons. Defaults to \\'after\\'\\n         */\\n        _this._labelPosition = \\'after\\';\\n        /**\\n         * Whether the radio group is disabled.\\n         */\\n        _this._disabled = false;\\n        /**\\n         * The method to be called in order to update ngModel\\n         */\\n        _this._controlValueAccessorChangeFn = function () { };\\n        /**\\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\\n         * \\\\@docs-private\\n         */\\n        _this.onTouched = function () { };\\n        /**\\n         * Event emitted when the group value changes.\\n         * Change events are only emitted when the value changes due to user interaction with\\n         * a radio button (the same behavior as `<input type-\"radio\">`).\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        return _this;\\n    }\\n    Object.defineProperty(MdRadioGroup.prototype, \"name\", {\\n        /**\\n         * Name of the radio button group. All radio buttons inside this group will use this name.\\n         * @return {?}\\n         */\\n        get: function () { return this._name; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._name = value;\\n            this._updateRadioButtonNames();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioGroup.prototype, \"align\", {\\n        /**\\n         * Alignment of the radio-buttons relative to their labels. Can be \\'before\\' or \\'after\\'.\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () {\\n            // align refers to the checkbox relative to the label, while labelPosition refers to the\\n            // label relative to the checkbox. As such, they are inverted.\\n            return this.labelPosition == \\'after\\' ? \\'start\\' : \\'end\\';\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this.labelPosition = (v == \\'start\\') ? \\'after\\' : \\'before\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioGroup.prototype, \"labelPosition\", {\\n        /**\\n         * Whether the labels should appear after or before the radio-buttons. Defaults to \\'after\\'\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._labelPosition;\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._labelPosition = (v == \\'before\\') ? \\'before\\' : \\'after\\';\\n            this._markRadiosForCheck();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioGroup.prototype, \"value\", {\\n        /**\\n         * Value of the radio button.\\n         * @return {?}\\n         */\\n        get: function () { return this._value; },\\n        /**\\n         * @param {?} newValue\\n         * @return {?}\\n         */\\n        set: function (newValue) {\\n            if (this._value != newValue) {\\n                // Set this before proceeding to ensure no circular loop occurs with selection.\\n                this._value = newValue;\\n                this._updateSelectedRadioFromValue();\\n                this._checkSelectedRadioButton();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._checkSelectedRadioButton = function () {\\n        if (this._selected && !this._selected.checked) {\\n            this._selected.checked = true;\\n        }\\n    };\\n    Object.defineProperty(MdRadioGroup.prototype, \"selected\", {\\n        /**\\n         * Whether the radio button is selected.\\n         * @return {?}\\n         */\\n        get: function () { return this._selected; },\\n        /**\\n         * @param {?} selected\\n         * @return {?}\\n         */\\n        set: function (selected) {\\n            this._selected = selected;\\n            this.value = selected ? selected.value : null;\\n            this._checkSelectedRadioButton();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioGroup.prototype, \"disabled\", {\\n        /**\\n         * Whether the radio group is diabled\\n         * @return {?}\\n         */\\n        get: function () { return this._disabled; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = value;\\n            this._markRadiosForCheck();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Initialize properties once content children are available.\\n     * This allows us to propagate relevant attributes to associated buttons.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype.ngAfterContentInit = function () {\\n        // Mark this component as initialized in AfterContentInit because the initial value can\\n        // possibly be set by NgModel on MdRadioGroup, and it is possible that the OnInit of the\\n        // NgModel occurs *after* the OnInit of the MdRadioGroup.\\n        this._isInitialized = true;\\n    };\\n    /**\\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\\n     * radio buttons upon their blur.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._touch = function () {\\n        if (this.onTouched) {\\n            this.onTouched();\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._updateRadioButtonNames = function () {\\n        var _this = this;\\n        if (this._radios) {\\n            this._radios.forEach(function (radio) {\\n                radio.name = _this.name;\\n            });\\n        }\\n    };\\n    /**\\n     * Updates the `selected` radio button from the internal _value state.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._updateSelectedRadioFromValue = function () {\\n        var _this = this;\\n        // If the value already matches the selected radio, do nothing.\\n        var /** @type {?} */ isAlreadySelected = this._selected != null && this._selected.value == this._value;\\n        if (this._radios != null && !isAlreadySelected) {\\n            this._selected = null;\\n            this._radios.forEach(function (radio) {\\n                radio.checked = _this.value == radio.value;\\n                if (radio.checked) {\\n                    _this._selected = radio;\\n                }\\n            });\\n        }\\n    };\\n    /**\\n     * Dispatch change event with current selection and group value.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._emitChangeEvent = function () {\\n        if (this._isInitialized) {\\n            var /** @type {?} */ event = new MdRadioChange();\\n            event.source = this._selected;\\n            event.value = this._value;\\n            this.change.emit(event);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype._markRadiosForCheck = function () {\\n        if (this._radios) {\\n            this._radios.forEach(function (radio) { return radio._markForCheck(); });\\n        }\\n    };\\n    /**\\n     * Sets the model value. Implemented as part of ControlValueAccessor.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype.writeValue = function (value) {\\n        this.value = value;\\n        this._changeDetector.markForCheck();\\n    };\\n    /**\\n     * Registers a callback to be triggered when the model value changes.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Callback to be registered.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype.registerOnChange = function (fn) {\\n        this._controlValueAccessorChangeFn = fn;\\n    };\\n    /**\\n     * Registers a callback to be triggered when the control is touched.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Callback to be registered.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype.registerOnTouched = function (fn) {\\n        this.onTouched = fn;\\n    };\\n    /**\\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\\n     * @param {?} isDisabled Whether the control should be disabled.\\n     * @return {?}\\n     */\\n    MdRadioGroup.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n        this._changeDetector.markForCheck();\\n    };\\n    return MdRadioGroup;\\n}(_MdRadioGroupMixinBase));\\nMdRadioGroup.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-radio-group, mat-radio-group\\',\\n                providers: [MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],\\n                host: {\\n                    \\'role\\': \\'radiogroup\\',\\n                    \\'class\\': \\'mat-radio-group\\',\\n                },\\n                inputs: [\\'disabled\\'],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRadioGroup.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n]; };\\nMdRadioGroup.propDecorators = {\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'_radios\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdRadioButton; }),] },],\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'labelPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * \\\\@docs-private\\n */\\nvar MdRadioButtonBase = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdRadioButtonBase(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n    }\\n    return MdRadioButtonBase;\\n}());\\n// As per Material design specifications the selection control radio should use the accent color\\n// palette by default. https://material.io/guidelines/components/selection-controls.html\\nvar _MdRadioButtonMixinBase = mixinColor(MdRadioButtonBase, \\'accent\\');\\n/**\\n * A radio-button. May be inside of\\n */\\nvar MdRadioButton = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdRadioButton, _super);\\n    /**\\n     * @param {?} radioGroup\\n     * @param {?} elementRef\\n     * @param {?} renderer\\n     * @param {?} _changeDetector\\n     * @param {?} _focusOriginMonitor\\n     * @param {?} _radioDispatcher\\n     */\\n    function MdRadioButton(radioGroup, elementRef, renderer, _changeDetector, _focusOriginMonitor, _radioDispatcher) {\\n        var _this = _super.call(this, renderer, elementRef) || this;\\n        _this._changeDetector = _changeDetector;\\n        _this._focusOriginMonitor = _focusOriginMonitor;\\n        _this._radioDispatcher = _radioDispatcher;\\n        /**\\n         * The unique ID for the radio button.\\n         */\\n        _this.id = \"md-radio-\" + _uniqueIdCounter$2++;\\n        /**\\n         * Event emitted when the checked state of this radio button changes.\\n         * Change events are only emitted when the value changes due to user interaction with\\n         * the radio button (the same behavior as `<input type-\"radio\">`).\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Whether this radio is checked.\\n         */\\n        _this._checked = false;\\n        /**\\n         * Value assigned to this radio.\\n         */\\n        _this._value = null;\\n        /**\\n         * Unregister function for _radioDispatcher *\\n         */\\n        _this._removeUniqueSelectionListener = function () { };\\n        // Assertions. Ideally these should be stripped out by the compiler.\\n        // TODO(jelbourn): Assert that there\\'s no name binding AND a parent radio group.\\n        _this.radioGroup = radioGroup;\\n        _this._removeUniqueSelectionListener =\\n            _radioDispatcher.listen(function (id, name) {\\n                if (id != _this.id && name == _this.name) {\\n                    _this.checked = false;\\n                }\\n            });\\n        return _this;\\n    }\\n    Object.defineProperty(MdRadioButton.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect for this radio button is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"checked\", {\\n        /**\\n         * Whether this radio button is checked.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._checked;\\n        },\\n        /**\\n         * @param {?} newCheckedState\\n         * @return {?}\\n         */\\n        set: function (newCheckedState) {\\n            if (this._checked != newCheckedState) {\\n                this._checked = newCheckedState;\\n                if (newCheckedState && this.radioGroup && this.radioGroup.value != this.value) {\\n                    this.radioGroup.selected = this;\\n                }\\n                else if (!newCheckedState && this.radioGroup && this.radioGroup.value == this.value) {\\n                    // When unchecking the selected radio button, update the selected radio\\n                    // property on the group.\\n                    this.radioGroup.selected = null;\\n                }\\n                if (newCheckedState) {\\n                    // Notify all radio buttons with the same name to un-check.\\n                    this._radioDispatcher.notify(this.id, this.name);\\n                }\\n                this._changeDetector.markForCheck();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"value\", {\\n        /**\\n         * The value of this radio button.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._value;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._value != value) {\\n                this._value = value;\\n                if (this.radioGroup != null) {\\n                    if (!this.checked) {\\n                        // Update checked when the value changed to match the radio group\\'s value\\n                        this.checked = this.radioGroup.value == value;\\n                    }\\n                    if (this.checked) {\\n                        this.radioGroup.selected = this;\\n                    }\\n                }\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"align\", {\\n        /**\\n         * Whether or not the radio-button should appear before or after the label.\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () {\\n            // align refers to the checkbox relative to the label, while labelPosition refers to the\\n            // label relative to the checkbox. As such, they are inverted.\\n            return this.labelPosition == \\'after\\' ? \\'start\\' : \\'end\\';\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this.labelPosition = (v == \\'start\\') ? \\'after\\' : \\'before\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"labelPosition\", {\\n        /**\\n         * Whether the label should appear after or before the radio button. Defaults to \\'after\\'\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || \\'after\\';\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._labelPosition = value;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"disabled\", {\\n        /**\\n         * Whether the radio button is disabled.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._disabled || (this.radioGroup != null && this.radioGroup.disabled);\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdRadioButton.prototype, \"inputId\", {\\n        /**\\n         * ID of the native input element inside `<md-radio-button>`\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.id + \"-input\";\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Focuses the radio button.\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype.focus = function () {\\n        this._focusOriginMonitor.focusVia(this._inputElement.nativeElement, \\'keyboard\\');\\n    };\\n    /**\\n     * Marks the radio button as needing checking for change detection.\\n     * This method is exposed because the parent radio group will directly\\n     * update bound properties of the radio button.\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._markForCheck = function () {\\n        // When group value changes, the button will not be notified. Use `markForCheck` to explicit\\n        // update radio button\\'s status\\n        this._changeDetector.markForCheck();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype.ngOnInit = function () {\\n        if (this.radioGroup) {\\n            // If the radio is inside a radio group, determine if it should be checked\\n            this.checked = this.radioGroup.value === this._value;\\n            // Copy name from parent radio group\\n            this.name = this.radioGroup.name;\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype.ngAfterViewInit = function () {\\n        var _this = this;\\n        this._focusOriginMonitor\\n            .monitor(this._inputElement.nativeElement, this._renderer, false)\\n            .subscribe(function (focusOrigin) { return _this._onInputFocusChange(focusOrigin); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._inputElement.nativeElement);\\n        this._removeUniqueSelectionListener();\\n    };\\n    /**\\n     * Dispatch change event with current value.\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._emitChangeEvent = function () {\\n        var /** @type {?} */ event = new MdRadioChange();\\n        event.source = this;\\n        event.value = this._value;\\n        this.change.emit(event);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._isRippleDisabled = function () {\\n        return this.disableRipple || this.disabled;\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._onInputClick = function (event) {\\n        // We have to stop propagation for click events on the visual hidden input element.\\n        // By default, when a user clicks on a label element, a generated click event will be\\n        // dispatched on the associated input element. Since we are using a label element as our\\n        // root container, the click event on the `radio-button` will be executed twice.\\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\\n        // This will lead to multiple click events.\\n        // Preventing bubbling for the second event will solve that issue.\\n        event.stopPropagation();\\n    };\\n    /**\\n     * Triggered when the radio button received a click or the input recognized any change.\\n     * Clicking on a label element, will trigger a change event on the associated input.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._onInputChange = function (event) {\\n        // We always have to stop propagation on the change event.\\n        // Otherwise the change event, from the input element, will bubble up and\\n        // emit its event object to the `change` output.\\n        event.stopPropagation();\\n        var /** @type {?} */ groupValueChanged = this.radioGroup && this.value != this.radioGroup.value;\\n        this.checked = true;\\n        this._emitChangeEvent();\\n        if (this.radioGroup) {\\n            this.radioGroup._controlValueAccessorChangeFn(this.value);\\n            this.radioGroup._touch();\\n            if (groupValueChanged) {\\n                this.radioGroup._emitChangeEvent();\\n            }\\n        }\\n    };\\n    /**\\n     * Function is called whenever the focus changes for the input element.\\n     * @param {?} focusOrigin\\n     * @return {?}\\n     */\\n    MdRadioButton.prototype._onInputFocusChange = function (focusOrigin) {\\n        if (!this._focusRipple && focusOrigin === \\'keyboard\\') {\\n            this._focusRipple = this._ripple.launch(0, 0, { persistent: true, centered: true });\\n        }\\n        else if (!focusOrigin) {\\n            if (this.radioGroup) {\\n                this.radioGroup._touch();\\n            }\\n            if (this._focusRipple) {\\n                this._focusRipple.fadeOut();\\n                this._focusRipple = null;\\n            }\\n        }\\n    };\\n    return MdRadioButton;\\n}(_MdRadioButtonMixinBase));\\nMdRadioButton.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-radio-button, mat-radio-button\\',\\n                template: \"<label [attr.for]=\\\\\"inputId\\\\\" class=\\\\\"mat-radio-label\\\\\" #label><div class=\\\\\"mat-radio-container\\\\\"><div class=\\\\\"mat-radio-outer-circle\\\\\"></div><div class=\\\\\"mat-radio-inner-circle\\\\\"></div><div md-ripple class=\\\\\"mat-radio-ripple\\\\\" [mdRippleTrigger]=\\\\\"label\\\\\" [mdRippleDisabled]=\\\\\"_isRippleDisabled()\\\\\" [mdRippleCentered]=\\\\\"true\\\\\"></div></div><input #input class=\\\\\"mat-radio-input cdk-visually-hidden\\\\\" type=\\\\\"radio\\\\\" [id]=\\\\\"inputId\\\\\" [checked]=\\\\\"checked\\\\\" [disabled]=\\\\\"disabled\\\\\" [name]=\\\\\"name\\\\\" [attr.aria-label]=\\\\\"ariaLabel\\\\\" [attr.aria-labelledby]=\\\\\"ariaLabelledby\\\\\" (change)=\\\\\"_onInputChange($event)\\\\\" (click)=\\\\\"_onInputClick($event)\\\\\"><div class=\\\\\"mat-radio-label-content\\\\\" [class.mat-radio-label-before]=\\\\\"labelPosition == \\'before\\'\\\\\"><span style=\\\\\"display:none\\\\\">&nbsp;</span><ng-content></ng-content></div></label>\",\\n                styles: [\".mat-radio-button{display:inline-block}.mat-radio-label{cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle}.mat-radio-container{box-sizing:border-box;display:inline-block;height:20px;position:relative;width:20px}.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:transform ease 280ms,background-color ease 280ms;transform:scale(0);width:20px}.mat-radio-checked .mat-radio-inner-circle{transform:scale(.5)}.mat-radio-label-content{display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-ripple{position:absolute;left:-15px;top:-15px;right:-15px;bottom:-15px;border-radius:50%;z-index:1;pointer-events:none}\"],\\n                inputs: [\\'color\\'],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'class\\': \\'mat-radio-button\\',\\n                    \\'[class.mat-radio-checked]\\': \\'checked\\',\\n                    \\'[class.mat-radio-disabled]\\': \\'disabled\\',\\n                    \\'[attr.id]\\': \\'id\\',\\n                },\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRadioButton.ctorParameters = function () { return [\\n    { type: MdRadioGroup, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: FocusOriginMonitor, },\\n    { type: UniqueSelectionDispatcher, },\\n]; };\\nMdRadioButton.propDecorators = {\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'ariaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'ariaLabelledby\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-labelledby\\',] },],\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'checked\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'labelPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'_ripple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdRipple,] },],\\n    \\'_inputElement\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'input\\',] },],\\n};\\nvar MdRadioModule = /*@__PURE__*/(function () {\\n    function MdRadioModule() {\\n    }\\n    return MdRadioModule;\\n}());\\nMdRadioModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"], MdRippleModule, MdCommonModule],\\n                exports: [MdRadioGroup, MdRadioButton, MdCommonModule],\\n                providers: [UNIQUE_SELECTION_DISPATCHER_PROVIDER, VIEWPORT_RULER_PROVIDER, FocusOriginMonitor],\\n                declarations: [MdRadioGroup, MdRadioButton],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRadioModule.ctorParameters = function () { return []; };\\nvar FocusKeyManager = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FocusKeyManager, _super);\\n    /**\\n     * @param {?} items\\n     */\\n    function FocusKeyManager(items) {\\n        return _super.call(this, items) || this;\\n    }\\n    /**\\n     * This method sets the active item to the item at the specified index.\\n     * It also adds focuses the newly active item.\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    FocusKeyManager.prototype.setActiveItem = function (index) {\\n        _super.prototype.setActiveItem.call(this, index);\\n        if (this.activeItem) {\\n            this.activeItem.focus();\\n        }\\n    };\\n    return FocusKeyManager;\\n}(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"F\" /* ListKeyManager */]));\\n/**\\n * This animation shrinks the placeholder text to 75% of its normal size and translates\\n * it to either the top left corner (ltr) or top right corner (rtl) of the trigger,\\n * depending on the text direction of the application.\\n */\\nvar transformPlaceholder = __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'transformPlaceholder\\', [\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'floating-ltr\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({\\n        top: \\'-22px\\',\\n        left: \\'-2px\\',\\n        transform: \\'scale(0.75)\\'\\n    })),\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'floating-rtl\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({\\n        top: \\'-22px\\',\\n        left: \\'2px\\',\\n        transform: \\'scale(0.75)\\'\\n    })),\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'* => *\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'400ms cubic-bezier(0.25, 0.8, 0.25, 1)\\'))\\n]);\\n/**\\n * This animation transforms the select\\'s overlay panel on and off the page.\\n *\\n * When the panel is attached to the DOM, it expands its width by the amount of padding, scales it\\n * up to 100% on the Y axis, fades in its border, and translates slightly up and to the\\n * side to ensure the option text correctly overlaps the trigger text.\\n *\\n * When the panel is removed from the DOM, it simply fades out linearly.\\n */\\nvar transformPanel = __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'transformPanel\\', [\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'showing\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({\\n        opacity: 1,\\n        minWidth: \\'calc(100% + 32px)\\',\\n        transform: \\'scaleY(1)\\'\\n    })),\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'showing-multiple\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({\\n        opacity: 1,\\n        minWidth: \\'calc(100% + 64px)\\',\\n        transform: \\'scaleY(1)\\'\\n    })),\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'void => *\\', [\\n        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({\\n            opacity: 0,\\n            minWidth: \\'100%\\',\\n            transform: \\'scaleY(0)\\'\\n        }),\\n        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'150ms cubic-bezier(0.25, 0.8, 0.25, 1)\\')\\n    ]),\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'* => void\\', [\\n        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'250ms 100ms linear\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ opacity: 0 }))\\n    ])\\n]);\\n/**\\n * This animation fades in the background color and text content of the\\n * select\\'s options. It is time delayed to occur 100ms after the overlay\\n * panel has transformed in.\\n */\\nvar fadeInContent = __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'fadeInContent\\', [\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'showing\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ opacity: 1 })),\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'void => showing\\', [\\n        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ opacity: 0 }),\\n        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)\\')\\n    ])\\n]);\\n/**\\n * Returns an exception to be thrown when attempting to change a s\\n * elect\\'s `multiple` option after initialization.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdSelectDynamicMultipleError() {\\n    return Error(\\'Cannot change `multiple` mode of select after initialization.\\');\\n}\\n/**\\n * Returns an exception to be thrown when attempting to assign a non-array value to a select\\n * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for\\n * resetting the value.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdSelectNonArrayValueError() {\\n    return Error(\\'Cannot assign truthy non-array value to select in `multiple` mode.\\');\\n}\\n/**\\n * The fixed height of every option element (option, group header etc.).\\n */\\nvar SELECT_ITEM_HEIGHT = 48;\\n/**\\n * The max height of the select\\'s overlay panel\\n */\\nvar SELECT_PANEL_MAX_HEIGHT = 256;\\n/**\\n * The max number of options visible at once in the select panel.\\n */\\nvar SELECT_MAX_OPTIONS_DISPLAYED = Math.floor(SELECT_PANEL_MAX_HEIGHT / SELECT_ITEM_HEIGHT);\\n/**\\n * The fixed height of the select\\'s trigger element.\\n */\\nvar SELECT_TRIGGER_HEIGHT = 30;\\n/**\\n * Must adjust for the difference in height between the option and the trigger,\\n * so the text will align on the y axis.\\n */\\nvar SELECT_OPTION_HEIGHT_ADJUSTMENT = (SELECT_ITEM_HEIGHT - SELECT_TRIGGER_HEIGHT) / 2;\\n/**\\n * The panel\\'s padding on the x-axis\\n */\\nvar SELECT_PANEL_PADDING_X = 16;\\n/**\\n * The panel\\'s x axis padding if it is indented (e.g. there is an option group).\\n */\\nvar SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_PADDING_X * 2;\\n/**\\n * Distance between the panel edge and the option text in\\n * multi-selection mode.\\n *\\n * (SELECT_PADDING * 1.75) + 20 = 48\\n * The padding is multiplied by 1.75 because the checkbox\\'s margin is half the padding, and\\n * the browser adds ~4px, because we\\'re using inline elements.\\n * The checkbox width is 20px.\\n */\\nvar SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_PANEL_PADDING_X * 1.75 + 20;\\n/**\\n * The panel\\'s padding on the y-axis. This padding indicates there are more\\n * options available if you scroll.\\n */\\nvar SELECT_PANEL_PADDING_Y = 16;\\n/**\\n * The select panel will only \"fit\" inside the viewport if it is positioned at\\n * this value or more away from the viewport boundary.\\n */\\nvar SELECT_PANEL_VIEWPORT_PADDING = 8;\\n/**\\n * Change event object that is emitted when the select value has changed.\\n */\\nvar MdSelectChange = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} source\\n     * @param {?} value\\n     */\\n    function MdSelectChange(source, value) {\\n        this.source = source;\\n        this.value = value;\\n    }\\n    return MdSelectChange;\\n}());\\n/**\\n * \\\\@docs-private\\n */\\nvar MdSelectBase = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdSelectBase(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n    }\\n    return MdSelectBase;\\n}());\\nvar _MdSelectMixinBase = mixinColor(mixinDisabled(MdSelectBase), \\'primary\\');\\nvar MdSelect = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdSelect, _super);\\n    /**\\n     * @param {?} _viewportRuler\\n     * @param {?} _changeDetectorRef\\n     * @param {?} renderer\\n     * @param {?} elementRef\\n     * @param {?} _dir\\n     * @param {?} _control\\n     * @param {?} tabIndex\\n     * @param {?} placeholderOptions\\n     */\\n    function MdSelect(_viewportRuler, _changeDetectorRef, renderer, elementRef, _dir, _control, tabIndex, placeholderOptions) {\\n        var _this = _super.call(this, renderer, elementRef) || this;\\n        _this._viewportRuler = _viewportRuler;\\n        _this._changeDetectorRef = _changeDetectorRef;\\n        _this._dir = _dir;\\n        _this._control = _control;\\n        /**\\n         * Whether or not the overlay panel is open.\\n         */\\n        _this._panelOpen = false;\\n        /**\\n         * Whether filling out the select is required in the form.\\n         */\\n        _this._required = false;\\n        /**\\n         * The scroll position of the overlay panel, calculated to center the selected option.\\n         */\\n        _this._scrollTop = 0;\\n        /**\\n         * Whether the component is in multiple selection mode.\\n         */\\n        _this._multiple = false;\\n        /**\\n         * The animation state of the placeholder.\\n         */\\n        _this._placeholderState = \\'\\';\\n        /**\\n         * View -> model callback called when value changes\\n         */\\n        _this._onChange = function () { };\\n        /**\\n         * View -> model callback called when select has been touched\\n         */\\n        _this._onTouched = function () { };\\n        /**\\n         * The IDs of child options to be passed to the aria-owns attribute.\\n         */\\n        _this._optionIds = \\'\\';\\n        /**\\n         * The value of the select panel\\'s transform-origin property.\\n         */\\n        _this._transformOrigin = \\'top\\';\\n        /**\\n         * Whether the panel\\'s animation is done.\\n         */\\n        _this._panelDoneAnimating = false;\\n        /**\\n         * The y-offset of the overlay panel in relation to the trigger\\'s top start corner.\\n         * This must be adjusted to align the selected option text over the trigger text.\\n         * when the panel opens. Will change based on the y-position of the selected option.\\n         */\\n        _this._offsetY = 0;\\n        /**\\n         * This position config ensures that the top \"start\" corner of the overlay\\n         * is aligned with with the top \"start\" of the origin by default (overlapping\\n         * the trigger completely). If the panel cannot fit below the trigger, it\\n         * will fall back to a position above the trigger.\\n         */\\n        _this._positions = [\\n            {\\n                originX: \\'start\\',\\n                originY: \\'top\\',\\n                overlayX: \\'start\\',\\n                overlayY: \\'top\\',\\n            },\\n            {\\n                originX: \\'start\\',\\n                originY: \\'bottom\\',\\n                overlayX: \\'start\\',\\n                overlayY: \\'bottom\\',\\n            },\\n        ];\\n        /**\\n         * Aria label of the select. If not specified, the placeholder will be used as label.\\n         */\\n        _this.ariaLabel = \\'\\';\\n        /**\\n         * Input that can be used to specify the `aria-labelledby` attribute.\\n         */\\n        _this.ariaLabelledby = \\'\\';\\n        /**\\n         * Event emitted when the select has been opened.\\n         */\\n        _this.onOpen = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the select has been closed.\\n         */\\n        _this.onClose = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the selected value has been changed by the user.\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        if (_this._control) {\\n            _this._control.valueAccessor = _this;\\n        }\\n        _this._tabIndex = parseInt(tabIndex) || 0;\\n        _this._placeholderOptions = placeholderOptions ? placeholderOptions : {};\\n        _this.floatPlaceholder = _this._placeholderOptions.float || \\'auto\\';\\n        return _this;\\n    }\\n    Object.defineProperty(MdSelect.prototype, \"placeholder\", {\\n        /**\\n         * Placeholder to be shown if no value has been selected.\\n         * @return {?}\\n         */\\n        get: function () { return this._placeholder; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            var _this = this;\\n            this._placeholder = value;\\n            // Must wait to record the trigger width to ensure placeholder width is included.\\n            Promise.resolve(null).then(function () { return _this._setTriggerWidth(); });\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"required\", {\\n        /**\\n         * Whether the component is required.\\n         * @return {?}\\n         */\\n        get: function () { return this._required; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._required = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"multiple\", {\\n        /**\\n         * Whether the user should be allowed to select multiple options.\\n         * @return {?}\\n         */\\n        get: function () { return this._multiple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._selectionModel) {\\n                throw getMdSelectDynamicMultipleError();\\n            }\\n            this._multiple = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"floatPlaceholder\", {\\n        /**\\n         * Whether to float the placeholder text.\\n         * @return {?}\\n         */\\n        get: function () { return this._floatPlaceholder; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._floatPlaceholder = value || this._placeholderOptions.float || \\'auto\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"tabIndex\", {\\n        /**\\n         * Tab index for the select element.\\n         * @return {?}\\n         */\\n        get: function () { return this.disabled ? -1 : this._tabIndex; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (typeof value !== \\'undefined\\') {\\n                this._tabIndex = value;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"optionSelectionChanges\", {\\n        /**\\n         * Combined stream of all of the child options\\' change events.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return __WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge__[\"merge\"].apply(void 0, this.options.map(function (option) { return option.onSelectionChange; }));\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdSelect.prototype.ngOnInit = function () {\\n        this._selectionModel = new SelectionModel(this.multiple, undefined, false);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSelect.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._initKeyManager();\\n        this._changeSubscription = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_9\" /* startWith */].call(this.options.changes, null).subscribe(function () {\\n            _this._resetOptions();\\n            if (_this._control) {\\n                // Defer setting the value in order to avoid the \"Expression\\n                // has changed after it was checked\" errors from Angular.\\n                Promise.resolve(null).then(function () { return _this._setSelectionByValue(_this._control.value); });\\n            }\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSelect.prototype.ngOnDestroy = function () {\\n        this._dropSubscriptions();\\n        if (this._changeSubscription) {\\n            this._changeSubscription.unsubscribe();\\n        }\\n        if (this._tabSubscription) {\\n            this._tabSubscription.unsubscribe();\\n        }\\n    };\\n    /**\\n     * Toggles the overlay panel open or closed.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.toggle = function () {\\n        this.panelOpen ? this.close() : this.open();\\n    };\\n    /**\\n     * Opens the overlay panel.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.open = function () {\\n        if (this.disabled || !this.options.length) {\\n            return;\\n        }\\n        if (!this._triggerWidth) {\\n            this._setTriggerWidth();\\n        }\\n        this._calculateOverlayPosition();\\n        this._placeholderState = this._floatPlaceholderState();\\n        this._panelOpen = true;\\n    };\\n    /**\\n     * Closes the overlay panel and focuses the host element.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.close = function () {\\n        if (this._panelOpen) {\\n            this._panelOpen = false;\\n            if (this._selectionModel.isEmpty()) {\\n                this._placeholderState = \\'\\';\\n            }\\n            this.focus();\\n        }\\n    };\\n    /**\\n     * Sets the select\\'s value. Part of the ControlValueAccessor interface\\n     * required to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} value New value to be written to the model.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.writeValue = function (value) {\\n        if (this.options) {\\n            this._setSelectionByValue(value);\\n        }\\n    };\\n    /**\\n     * Saves a callback function to be invoked when the select\\'s value\\n     * changes from user input. Part of the ControlValueAccessor interface\\n     * required to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} fn Callback to be triggered when the value changes.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.registerOnChange = function (fn) {\\n        this._onChange = fn;\\n    };\\n    /**\\n     * Saves a callback function to be invoked when the select is blurred\\n     * by the user. Part of the ControlValueAccessor interface required\\n     * to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} fn Callback to be triggered when the component has been touched.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.registerOnTouched = function (fn) {\\n        this._onTouched = fn;\\n    };\\n    /**\\n     * Disables the select. Part of the ControlValueAccessor interface required\\n     * to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} isDisabled Sets whether the component is disabled.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n    };\\n    Object.defineProperty(MdSelect.prototype, \"panelOpen\", {\\n        /**\\n         * Whether or not the overlay panel is open.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._panelOpen;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"selected\", {\\n        /**\\n         * The currently selected option.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSelect.prototype, \"triggerValue\", {\\n        /**\\n         * The value displayed in the trigger.\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (this._multiple) {\\n                var /** @type {?} */ selectedOptions = this._selectionModel.selected.map(function (option) { return option.viewValue; });\\n                if (this._isRtl()) {\\n                    selectedOptions.reverse();\\n                }\\n                // TODO(crisbeto): delimiter should be configurable for proper localization.\\n                return selectedOptions.join(\\', \\');\\n            }\\n            return this._selectionModel.selected[0].viewValue;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Whether the element is in RTL mode.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._isRtl = function () {\\n        return this._dir ? this._dir.value === \\'rtl\\' : false;\\n    };\\n    /**\\n     * Sets the width of the trigger element. This is necessary to match\\n     * the overlay width to the trigger width.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setTriggerWidth = function () {\\n        this._triggerWidth = this._getTriggerRect().width;\\n    };\\n    /**\\n     * Handles the keyboard interactions of a closed select.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSelect.prototype._handleClosedKeydown = function (event) {\\n        if (!this.disabled) {\\n            if (event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"u\" /* ENTER */] || event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"S\" /* SPACE */]) {\\n                event.preventDefault(); // prevents the page from scrolling down when pressing space\\n                this.open();\\n            }\\n            else if (event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"W\" /* UP_ARROW */] || event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"p\" /* DOWN_ARROW */]) {\\n                this._handleArrowKey(event);\\n            }\\n        }\\n    };\\n    /**\\n     * Handles keypresses inside the panel.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSelect.prototype._handlePanelKeydown = function (event) {\\n        if (event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"A\" /* HOME */] || event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"t\" /* END */]) {\\n            event.preventDefault();\\n            event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"A\" /* HOME */] ? this._keyManager.setFirstItemActive() :\\n                this._keyManager.setLastItemActive();\\n        }\\n        else {\\n            this._keyManager.onKeydown(event);\\n        }\\n    };\\n    /**\\n     * When the panel element is finished transforming in (though not fading in), it\\n     * emits an event and focuses an option if the panel is open.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._onPanelDone = function () {\\n        if (this.panelOpen) {\\n            this._focusCorrectOption();\\n            this.onOpen.emit();\\n        }\\n        else {\\n            this.onClose.emit();\\n            this._panelDoneAnimating = false;\\n            this.overlayDir.offsetX = 0;\\n        }\\n    };\\n    /**\\n     * When the panel content is done fading in, the _panelDoneAnimating property is\\n     * set so the proper class can be added to the panel.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._onFadeInDone = function () {\\n        this._panelDoneAnimating = this.panelOpen;\\n    };\\n    /**\\n     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\\n     * \"blur\" to the panel when it opens, causing a false positive.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._onBlur = function () {\\n        if (!this.panelOpen) {\\n            this._onTouched();\\n        }\\n    };\\n    /**\\n     * Callback that is invoked when the overlay panel has been attached.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._onAttached = function () {\\n        this._calculateOverlayOffsetX();\\n        this._setScrollTop();\\n    };\\n    /**\\n     * Sets the scroll position of the scroll container. This must be called after\\n     * the overlay pane is attached or the scroll container element will not yet be\\n     * present in the DOM.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setScrollTop = function () {\\n        var /** @type {?} */ scrollContainer = this.overlayDir.overlayRef.overlayElement.querySelector(\\'.mat-select-panel\\'); /** @type {?} */\\n        ((scrollContainer)).scrollTop = this._scrollTop;\\n    };\\n    /**\\n     * Sets the selected option based on a value. If no option can be\\n     * found with the designated value, the select trigger is cleared.\\n     * @param {?} value\\n     * @param {?=} isUserInput\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setSelectionByValue = function (value, isUserInput) {\\n        var _this = this;\\n        if (isUserInput === void 0) { isUserInput = false; }\\n        var /** @type {?} */ isArray = Array.isArray(value);\\n        if (this.multiple && value && !isArray) {\\n            throw getMdSelectNonArrayValueError();\\n        }\\n        this._clearSelection();\\n        if (isArray) {\\n            value.forEach(function (currentValue) { return _this._selectValue(currentValue, isUserInput); });\\n            this._sortValues();\\n        }\\n        else {\\n            this._selectValue(value, isUserInput);\\n        }\\n        this._setValueWidth();\\n        if (this._selectionModel.isEmpty()) {\\n            this._placeholderState = \\'\\';\\n        }\\n        this._changeDetectorRef.markForCheck();\\n    };\\n    /**\\n     * Finds and selects and option based on its value.\\n     * @param {?} value\\n     * @param {?=} isUserInput\\n     * @return {?} Option that has the corresponding value.\\n     */\\n    MdSelect.prototype._selectValue = function (value, isUserInput) {\\n        if (isUserInput === void 0) { isUserInput = false; }\\n        var /** @type {?} */ optionsArray = this.options.toArray();\\n        var /** @type {?} */ correspondingOption = optionsArray.find(function (option) {\\n            return option.value != null && option.value === value;\\n        });\\n        if (correspondingOption) {\\n            isUserInput ? correspondingOption._selectViaInteraction() : correspondingOption.select();\\n            this._selectionModel.select(correspondingOption);\\n            this._keyManager.setActiveItem(optionsArray.indexOf(correspondingOption));\\n        }\\n        return correspondingOption;\\n    };\\n    /**\\n     * Clears the select trigger and deselects every option in the list.\\n     * @param {?=} skip Option that should not be deselected.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._clearSelection = function (skip) {\\n        this._selectionModel.clear();\\n        this.options.forEach(function (option) {\\n            if (option !== skip) {\\n                option.deselect();\\n            }\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getTriggerRect = function () {\\n        return this.trigger.nativeElement.getBoundingClientRect();\\n    };\\n    /**\\n     * Sets up a key manager to listen to keyboard events on the overlay panel.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._initKeyManager = function () {\\n        var _this = this;\\n        this._keyManager = new FocusKeyManager(this.options);\\n        this._tabSubscription = this._keyManager.tabOut.subscribe(function () { return _this.close(); });\\n    };\\n    /**\\n     * Drops current option subscriptions and IDs and resets from scratch.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._resetOptions = function () {\\n        this._dropSubscriptions();\\n        this._listenToOptions();\\n        this._setOptionIds();\\n        this._setOptionMultiple();\\n    };\\n    /**\\n     * Listens to user-generated selection events on each option.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._listenToOptions = function () {\\n        var _this = this;\\n        this._optionSubscription = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_2\" /* filter */].call(this.optionSelectionChanges, function (event) { return event.isUserInput; }).subscribe(function (event) {\\n            _this._onSelect(event.source);\\n            _this._setValueWidth();\\n            if (!_this.multiple) {\\n                _this.close();\\n            }\\n        });\\n    };\\n    /**\\n     * Invoked when an option is clicked.\\n     * @param {?} option\\n     * @return {?}\\n     */\\n    MdSelect.prototype._onSelect = function (option) {\\n        var /** @type {?} */ wasSelected = this._selectionModel.isSelected(option);\\n        // TODO(crisbeto): handle blank/null options inside multi-select.\\n        if (this.multiple) {\\n            this._selectionModel.toggle(option);\\n            wasSelected ? option.deselect() : option.select();\\n            this._sortValues();\\n        }\\n        else {\\n            this._clearSelection(option.value == null ? undefined : option);\\n            if (option.value == null) {\\n                this._propagateChanges(option.value);\\n            }\\n            else {\\n                this._selectionModel.select(option);\\n            }\\n        }\\n        if (wasSelected !== this._selectionModel.isSelected(option)) {\\n            this._propagateChanges();\\n        }\\n    };\\n    /**\\n     * Sorts the model values, ensuring that they keep the same\\n     * order that they have in the panel.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._sortValues = function () {\\n        var _this = this;\\n        if (this._multiple) {\\n            this._selectionModel.clear();\\n            this.options.forEach(function (option) {\\n                if (option.selected) {\\n                    _this._selectionModel.select(option);\\n                }\\n            });\\n        }\\n    };\\n    /**\\n     * Unsubscribes from all option subscriptions.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._dropSubscriptions = function () {\\n        if (this._optionSubscription) {\\n            this._optionSubscription.unsubscribe();\\n            this._optionSubscription = null;\\n        }\\n    };\\n    /**\\n     * Emits change event to set the model value.\\n     * @param {?=} fallbackValue\\n     * @return {?}\\n     */\\n    MdSelect.prototype._propagateChanges = function (fallbackValue) {\\n        var /** @type {?} */ valueToEmit = null;\\n        if (Array.isArray(this.selected)) {\\n            valueToEmit = this.selected.map(function (option) { return option.value; });\\n        }\\n        else {\\n            valueToEmit = this.selected ? this.selected.value : fallbackValue;\\n        }\\n        this._onChange(valueToEmit);\\n        this.change.emit(new MdSelectChange(this, valueToEmit));\\n    };\\n    /**\\n     * Records option IDs to pass to the aria-owns property.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setOptionIds = function () {\\n        this._optionIds = this.options.map(function (option) { return option.id; }).join(\\' \\');\\n    };\\n    /**\\n     * Sets the `multiple` property on each option. The promise is necessary\\n     * in order to avoid Angular errors when modifying the property after init.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setOptionMultiple = function () {\\n        var _this = this;\\n        if (this.multiple) {\\n            Promise.resolve(null).then(function () {\\n                _this.options.forEach(function (option) { return option.multiple = _this.multiple; });\\n            });\\n        }\\n    };\\n    /**\\n     * Must set the width of the selected option\\'s value programmatically\\n     * because it is absolutely positioned and otherwise will not clip\\n     * overflow. The selection arrow is 9px wide, add 4px of padding = 13\\n     * @return {?}\\n     */\\n    MdSelect.prototype._setValueWidth = function () {\\n        this._selectedValueWidth = this._triggerWidth - 13;\\n    };\\n    /**\\n     * Focuses the selected item. If no option is selected, it will focus\\n     * the first item instead.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._focusCorrectOption = function () {\\n        if (this._selectionModel.isEmpty()) {\\n            this._keyManager.setFirstItemActive();\\n        }\\n        else {\\n            this._keyManager.setActiveItem(/** @type {?} */ ((this._getOptionIndex(this._selectionModel.selected[0]))));\\n        }\\n    };\\n    /**\\n     * Focuses the select element.\\n     * @return {?}\\n     */\\n    MdSelect.prototype.focus = function () {\\n        this._elementRef.nativeElement.focus();\\n    };\\n    /**\\n     * Gets the index of the provided option in the option list.\\n     * @param {?} option\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getOptionIndex = function (option) {\\n        return this.options.reduce(function (result, current, index) {\\n            return result === undefined ? (option === current ? index : undefined) : result;\\n        }, undefined);\\n    };\\n    /**\\n     * Calculates the scroll position and x- and y-offsets of the overlay panel.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._calculateOverlayPosition = function () {\\n        var /** @type {?} */ items = this._getItemCount();\\n        var /** @type {?} */ panelHeight = Math.min(items * SELECT_ITEM_HEIGHT, SELECT_PANEL_MAX_HEIGHT);\\n        var /** @type {?} */ scrollContainerHeight = items * SELECT_ITEM_HEIGHT;\\n        // The farthest the panel can be scrolled before it hits the bottom\\n        var /** @type {?} */ maxScroll = scrollContainerHeight - panelHeight;\\n        if (this._selectionModel.hasValue()) {\\n            var /** @type {?} */ selectedOptionOffset = ((this._getOptionIndex(this._selectionModel.selected[0])));\\n            selectedOptionOffset += this._getLabelCountBeforeOption(selectedOptionOffset);\\n            // We must maintain a scroll buffer so the selected option will be scrolled to the\\n            // center of the overlay panel rather than the top.\\n            var /** @type {?} */ scrollBuffer = panelHeight / 2;\\n            this._scrollTop = this._calculateOverlayScroll(selectedOptionOffset, scrollBuffer, maxScroll);\\n            this._offsetY = this._calculateOverlayOffsetY(selectedOptionOffset, scrollBuffer, maxScroll);\\n        }\\n        else {\\n            // If no option is selected, the panel centers on the first option. In this case,\\n            // we must only adjust for the height difference between the option element\\n            // and the trigger element, then multiply it by -1 to ensure the panel moves\\n            // in the correct direction up the page.\\n            this._offsetY = (SELECT_ITEM_HEIGHT - SELECT_TRIGGER_HEIGHT) / 2 * -1 -\\n                (this._getLabelCountBeforeOption(0) * SELECT_ITEM_HEIGHT);\\n        }\\n        this._checkOverlayWithinViewport(maxScroll);\\n    };\\n    /**\\n     * Calculates the scroll position of the select\\'s overlay panel.\\n     *\\n     * Attempts to center the selected option in the panel. If the option is\\n     * too high or too low in the panel to be scrolled to the center, it clamps the\\n     * scroll position to the min or max scroll positions respectively.\\n     * @param {?} selectedIndex\\n     * @param {?} scrollBuffer\\n     * @param {?} maxScroll\\n     * @return {?}\\n     */\\n    MdSelect.prototype._calculateOverlayScroll = function (selectedIndex, scrollBuffer, maxScroll) {\\n        var /** @type {?} */ optionOffsetFromScrollTop = SELECT_ITEM_HEIGHT * selectedIndex;\\n        var /** @type {?} */ halfOptionHeight = SELECT_ITEM_HEIGHT / 2;\\n        // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the\\n        // scroll container, then subtracts the scroll buffer to scroll the option down to\\n        // the center of the overlay panel. Half the option height must be re-added to the\\n        // scrollTop so the option is centered based on its middle, not its top edge.\\n        var /** @type {?} */ optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;\\n        return clampValue(0, optimalScrollPosition, maxScroll);\\n    };\\n    /**\\n     * Figures out the appropriate animation state for the placeholder.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getPlaceholderAnimationState = function () {\\n        if (this.floatPlaceholder === \\'never\\') {\\n            return \\'\\';\\n        }\\n        if (this.floatPlaceholder === \\'always\\') {\\n            return this._floatPlaceholderState();\\n        }\\n        return this._placeholderState;\\n    };\\n    /**\\n     * Determines the CSS `opacity` of the placeholder element.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getPlaceholderOpacity = function () {\\n        return (this.floatPlaceholder !== \\'never\\' || this._selectionModel.isEmpty()) ?\\n            \\'1\\' : \\'0\\';\\n    };\\n    Object.defineProperty(MdSelect.prototype, \"_ariaLabel\", {\\n        /**\\n         * Returns the aria-label of the select component.\\n         * @return {?}\\n         */\\n        get: function () {\\n            // If an ariaLabelledby value has been set, the select should not overwrite the\\n            // `aria-labelledby` value by setting the ariaLabel to the placeholder.\\n            return this.ariaLabelledby ? null : this.ariaLabel || this.placeholder;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the x-offset of the overlay panel in relation to the trigger\\'s top start corner.\\n     * This must be adjusted to align the selected option text over the trigger text when\\n     * the panel opens. Will change based on LTR or RTL text direction. Note that the offset\\n     * can\\'t be calculated until the panel has been attached, because we need to know the\\n     * content width in order to constrain the panel within the viewport.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._calculateOverlayOffsetX = function () {\\n        var /** @type {?} */ overlayRect = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect();\\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\\n        var /** @type {?} */ isRtl = this._isRtl();\\n        var /** @type {?} */ paddingWidth = this.multiple ? SELECT_MULTIPLE_PANEL_PADDING_X + SELECT_PANEL_PADDING_X :\\n            SELECT_PANEL_PADDING_X * 2;\\n        var /** @type {?} */ offsetX;\\n        // Adjust the offset, depending on the option padding.\\n        if (this.multiple) {\\n            offsetX = SELECT_MULTIPLE_PANEL_PADDING_X;\\n        }\\n        else {\\n            var /** @type {?} */ selected = this._selectionModel.selected[0] || this.options.first;\\n            offsetX = selected && selected.group ? SELECT_PANEL_INDENT_PADDING_X : SELECT_PANEL_PADDING_X;\\n        }\\n        // Invert the offset in LTR.\\n        if (!isRtl) {\\n            offsetX *= -1;\\n        }\\n        // Determine how much the select overflows on each side.\\n        var /** @type {?} */ leftOverflow = 0 - (overlayRect.left + offsetX - (isRtl ? paddingWidth : 0));\\n        var /** @type {?} */ rightOverflow = overlayRect.right + offsetX - viewportRect.width\\n            + (isRtl ? 0 : paddingWidth);\\n        // If the element overflows on either side, reduce the offset to allow it to fit.\\n        if (leftOverflow > 0) {\\n            offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;\\n        }\\n        else if (rightOverflow > 0) {\\n            offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;\\n        }\\n        // Set the offset directly in order to avoid having to go through change detection and\\n        // potentially triggering \"changed after it was checked\" errors.\\n        this.overlayDir.offsetX = offsetX;\\n        this.overlayDir.overlayRef.updatePosition();\\n    };\\n    /**\\n     * Calculates the y-offset of the select\\'s overlay panel in relation to the\\n     * top start corner of the trigger. It has to be adjusted in order for the\\n     * selected option to be aligned over the trigger when the panel opens.\\n     * @param {?} selectedIndex\\n     * @param {?} scrollBuffer\\n     * @param {?} maxScroll\\n     * @return {?}\\n     */\\n    MdSelect.prototype._calculateOverlayOffsetY = function (selectedIndex, scrollBuffer, maxScroll) {\\n        var /** @type {?} */ optionOffsetFromPanelTop;\\n        if (this._scrollTop === 0) {\\n            optionOffsetFromPanelTop = selectedIndex * SELECT_ITEM_HEIGHT;\\n        }\\n        else if (this._scrollTop === maxScroll) {\\n            var /** @type {?} */ firstDisplayedIndex = this._getItemCount() - SELECT_MAX_OPTIONS_DISPLAYED;\\n            var /** @type {?} */ selectedDisplayIndex = selectedIndex - firstDisplayedIndex;\\n            // Because the panel height is longer than the height of the options alone,\\n            // there is always extra padding at the top or bottom of the panel. When\\n            // scrolled to the very bottom, this padding is at the top of the panel and\\n            // must be added to the offset.\\n            optionOffsetFromPanelTop =\\n                selectedDisplayIndex * SELECT_ITEM_HEIGHT + SELECT_PANEL_PADDING_Y;\\n        }\\n        else {\\n            // If the option was scrolled to the middle of the panel using a scroll buffer,\\n            // its offset will be the scroll buffer minus the half height that was added to\\n            // center it.\\n            optionOffsetFromPanelTop = scrollBuffer - SELECT_ITEM_HEIGHT / 2;\\n        }\\n        // The final offset is the option\\'s offset from the top, adjusted for the height\\n        // difference, multiplied by -1 to ensure that the overlay moves in the correct\\n        // direction up the page.\\n        return optionOffsetFromPanelTop * -1 - SELECT_OPTION_HEIGHT_ADJUSTMENT;\\n    };\\n    /**\\n     * Checks that the attempted overlay position will fit within the viewport.\\n     * If it will not fit, tries to adjust the scroll position and the associated\\n     * y-offset so the panel can open fully on-screen. If it still won\\'t fit,\\n     * sets the offset back to 0 to allow the fallback position to take over.\\n     * @param {?} maxScroll\\n     * @return {?}\\n     */\\n    MdSelect.prototype._checkOverlayWithinViewport = function (maxScroll) {\\n        var /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\\n        var /** @type {?} */ triggerRect = this._getTriggerRect();\\n        var /** @type {?} */ topSpaceAvailable = triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;\\n        var /** @type {?} */ bottomSpaceAvailable = viewportRect.height - triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;\\n        var /** @type {?} */ panelHeightTop = Math.abs(this._offsetY);\\n        var /** @type {?} */ totalPanelHeight = Math.min(this._getItemCount() * SELECT_ITEM_HEIGHT, SELECT_PANEL_MAX_HEIGHT);\\n        var /** @type {?} */ panelHeightBottom = totalPanelHeight - panelHeightTop - triggerRect.height;\\n        if (panelHeightBottom > bottomSpaceAvailable) {\\n            this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);\\n        }\\n        else if (panelHeightTop > topSpaceAvailable) {\\n            this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);\\n        }\\n        else {\\n            this._transformOrigin = this._getOriginBasedOnOption();\\n        }\\n    };\\n    /**\\n     * Adjusts the overlay panel up to fit in the viewport.\\n     * @param {?} panelHeightBottom\\n     * @param {?} bottomSpaceAvailable\\n     * @return {?}\\n     */\\n    MdSelect.prototype._adjustPanelUp = function (panelHeightBottom, bottomSpaceAvailable) {\\n        var /** @type {?} */ distanceBelowViewport = panelHeightBottom - bottomSpaceAvailable;\\n        // Scrolls the panel up by the distance it was extending past the boundary, then\\n        // adjusts the offset by that amount to move the panel up into the viewport.\\n        this._scrollTop -= distanceBelowViewport;\\n        this._offsetY -= distanceBelowViewport;\\n        this._transformOrigin = this._getOriginBasedOnOption();\\n        // If the panel is scrolled to the very top, it won\\'t be able to fit the panel\\n        // by scrolling, so set the offset to 0 to allow the fallback position to take\\n        // effect.\\n        if (this._scrollTop <= 0) {\\n            this._scrollTop = 0;\\n            this._offsetY = 0;\\n            this._transformOrigin = \"50% bottom 0px\";\\n        }\\n    };\\n    /**\\n     * Adjusts the overlay panel down to fit in the viewport.\\n     * @param {?} panelHeightTop\\n     * @param {?} topSpaceAvailable\\n     * @param {?} maxScroll\\n     * @return {?}\\n     */\\n    MdSelect.prototype._adjustPanelDown = function (panelHeightTop, topSpaceAvailable, maxScroll) {\\n        var /** @type {?} */ distanceAboveViewport = panelHeightTop - topSpaceAvailable;\\n        // Scrolls the panel down by the distance it was extending past the boundary, then\\n        // adjusts the offset by that amount to move the panel down into the viewport.\\n        this._scrollTop += distanceAboveViewport;\\n        this._offsetY += distanceAboveViewport;\\n        this._transformOrigin = this._getOriginBasedOnOption();\\n        // If the panel is scrolled to the very bottom, it won\\'t be able to fit the\\n        // panel by scrolling, so set the offset to 0 to allow the fallback position\\n        // to take effect.\\n        if (this._scrollTop >= maxScroll) {\\n            this._scrollTop = maxScroll;\\n            this._offsetY = 0;\\n            this._transformOrigin = \"50% top 0px\";\\n            return;\\n        }\\n    };\\n    /**\\n     * Sets the transform origin point based on the selected option.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getOriginBasedOnOption = function () {\\n        var /** @type {?} */ originY = Math.abs(this._offsetY) - SELECT_OPTION_HEIGHT_ADJUSTMENT + SELECT_ITEM_HEIGHT / 2;\\n        return \"50% \" + originY + \"px 0px\";\\n    };\\n    /**\\n     * Figures out the floating placeholder state value.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._floatPlaceholderState = function () {\\n        return this._isRtl() ? \\'floating-rtl\\' : \\'floating-ltr\\';\\n    };\\n    /**\\n     * Handles the user pressing the arrow keys on a closed select.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSelect.prototype._handleArrowKey = function (event) {\\n        if (this._multiple) {\\n            event.preventDefault();\\n            this.open();\\n        }\\n        else {\\n            var /** @type {?} */ prevActiveItem = this._keyManager.activeItem;\\n            // Cycle though the select options even when the select is closed,\\n            // matching the behavior of the native select element.\\n            // TODO(crisbeto): native selects also cycle through the options with left/right arrows,\\n            // however the key manager only supports up/down at the moment.\\n            this._keyManager.onKeydown(event);\\n            var /** @type {?} */ currentActiveItem = (this._keyManager.activeItem);\\n            if (currentActiveItem !== prevActiveItem) {\\n                this._clearSelection();\\n                this._setSelectionByValue(currentActiveItem.value, true);\\n                this._propagateChanges();\\n            }\\n        }\\n    };\\n    /**\\n     * Calculates the amount of items in the select. This includes options and group labels.\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getItemCount = function () {\\n        return this.options.length + this.optionGroups.length;\\n    };\\n    /**\\n     * Calculates the amount of option group labels that precede the specified option.\\n     * Useful when positioning the panel, because the labels will offset the index of the\\n     * currently-selected option.\\n     * @param {?} optionIndex\\n     * @return {?}\\n     */\\n    MdSelect.prototype._getLabelCountBeforeOption = function (optionIndex) {\\n        if (this.optionGroups.length) {\\n            var /** @type {?} */ options = this.options.toArray();\\n            var /** @type {?} */ groups = this.optionGroups.toArray();\\n            var /** @type {?} */ groupCounter = 0;\\n            for (var /** @type {?} */ i = 0; i < optionIndex + 1; i++) {\\n                if (options[i].group && options[i].group === groups[groupCounter]) {\\n                    groupCounter++;\\n                }\\n            }\\n            return groupCounter;\\n        }\\n        return 0;\\n    };\\n    return MdSelect;\\n}(_MdSelectMixinBase));\\nMdSelect.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-select, mat-select\\',\\n                template: \"<div class=\\\\\"mat-select-trigger\\\\\" cdk-overlay-origin (click)=\\\\\"toggle()\\\\\" #origin=\\\\\"cdkOverlayOrigin\\\\\" #trigger><span class=\\\\\"mat-select-placeholder\\\\\" [class.mat-floating-placeholder]=\\\\\"_selectionModel.hasValue()\\\\\" [@transformPlaceholder]=\\\\\"_getPlaceholderAnimationState()\\\\\" [style.opacity]=\\\\\"_getPlaceholderOpacity()\\\\\" [style.width.px]=\\\\\"_selectedValueWidth\\\\\">{{ placeholder }} </span><span class=\\\\\"mat-select-value\\\\\" *ngIf=\\\\\"_selectionModel.hasValue()\\\\\"><span class=\\\\\"mat-select-value-text\\\\\">{{ triggerValue }}</span> </span><span class=\\\\\"mat-select-arrow\\\\\"></span> <span class=\\\\\"mat-select-underline\\\\\"></span></div><ng-template cdk-connected-overlay hasBackdrop backdropClass=\\\\\"cdk-overlay-transparent-backdrop\\\\\" [origin]=\\\\\"origin\\\\\" [open]=\\\\\"panelOpen\\\\\" [positions]=\\\\\"_positions\\\\\" [minWidth]=\\\\\"_triggerWidth\\\\\" [offsetY]=\\\\\"_offsetY\\\\\" (backdropClick)=\\\\\"close()\\\\\" (attach)=\\\\\"_onAttached()\\\\\" (detach)=\\\\\"close()\\\\\"><div class=\\\\\"mat-select-panel {{ \\'mat-\\' + color }}\\\\\" [ngClass]=\\\\\"panelClass\\\\\" [@transformPanel]=\\\\\"multiple ? \\'showing-multiple\\' : \\'showing\\'\\\\\" (@transformPanel.done)=\\\\\"_onPanelDone()\\\\\" (keydown)=\\\\\"_handlePanelKeydown($event)\\\\\" [style.transformOrigin]=\\\\\"_transformOrigin\\\\\" [class.mat-select-panel-done-animating]=\\\\\"_panelDoneAnimating\\\\\"><div class=\\\\\"mat-select-content\\\\\" [@fadeInContent]=\\\\\"\\'showing\\'\\\\\" (@fadeInContent.done)=\\\\\"_onFadeInDone()\\\\\"><ng-content></ng-content></div></div></ng-template>\",\\n                styles: [\".mat-select{display:inline-block;outline:0}.mat-select-trigger{display:flex;align-items:center;height:30px;min-width:112px;cursor:pointer;position:relative;box-sizing:border-box}[aria-disabled=true] .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-underline{position:absolute;bottom:0;left:0;right:0;height:1px}[aria-disabled=true] .mat-select-underline{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;background-color:transparent;background-position:0 bottom}.mat-select-placeholder{position:relative;padding:0 2px;transform-origin:left top;flex-grow:1}.mat-select-placeholder.mat-floating-placeholder{top:-22px;left:-2px;text-align:left;transform:scale(.75)}[dir=rtl] .mat-select-placeholder{transform-origin:right top}[dir=rtl] .mat-select-placeholder.mat-floating-placeholder{left:2px;text-align:right}[aria-required=true] .mat-select-placeholder::after{content:\\'*\\'}.mat-select-value{position:absolute;max-width:calc(100% - 18px);flex-grow:1;top:0;left:0;bottom:0;display:flex;align-items:center}[dir=rtl] .mat-select-value{left:auto;right:0}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;line-height:30px}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%}@media screen and (-ms-high-contrast:active){.mat-select-panel{outline:solid 1px}}\"],\\n                inputs: [\\'color\\', \\'disabled\\'],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'role\\': \\'listbox\\',\\n                    \\'[attr.tabindex]\\': \\'tabIndex\\',\\n                    \\'[attr.aria-label]\\': \\'_ariaLabel\\',\\n                    \\'[attr.aria-labelledby]\\': \\'ariaLabelledby\\',\\n                    \\'[attr.aria-required]\\': \\'required.toString()\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled.toString()\\',\\n                    \\'[attr.aria-invalid]\\': \\'_control?.invalid || \"false\"\\',\\n                    \\'[attr.aria-owns]\\': \\'_optionIds\\',\\n                    \\'[class.mat-select-disabled]\\': \\'disabled\\',\\n                    \\'class\\': \\'mat-select\\',\\n                    \\'(keydown)\\': \\'_handleClosedKeydown($event)\\',\\n                    \\'(blur)\\': \\'_onBlur()\\',\\n                },\\n                animations: [\\n                    transformPlaceholder,\\n                    transformPanel,\\n                    fadeInContent\\n                ],\\n                exportAs: \\'mdSelect\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSelect.ctorParameters = function () { return [\\n    { type: ViewportRuler, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NgControl\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Attribute\"], args: [\\'tabindex\\',] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_PLACEHOLDER_GLOBAL_OPTIONS,] },] },\\n]; };\\nMdSelect.propDecorators = {\\n    \\'trigger\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'trigger\\',] },],\\n    \\'overlayDir\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [ConnectedOverlayDirective,] },],\\n    \\'options\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdOption, { descendants: true },] },],\\n    \\'optionGroups\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdOptgroup,] },],\\n    \\'panelClass\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'placeholder\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'required\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'multiple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'floatPlaceholder\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'tabIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'ariaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'ariaLabelledby\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-labelledby\\',] },],\\n    \\'onOpen\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'onClose\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Clamps a value n between min and max values.\\n * @param {?} min\\n * @param {?} n\\n * @param {?} max\\n * @return {?}\\n */\\nfunction clampValue(min, n, max) {\\n    return Math.min(Math.max(min, n), max);\\n}\\nvar MdSelectModule = /*@__PURE__*/(function () {\\n    function MdSelectModule() {\\n    }\\n    return MdSelectModule;\\n}());\\nMdSelectModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"],\\n                    OverlayModule,\\n                    MdOptionModule,\\n                    MdCommonModule,\\n                ],\\n                exports: [MdSelect, MdOptionModule, MdCommonModule],\\n                declarations: [MdSelect],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSelectModule.ctorParameters = function () { return []; };\\nvar MD_SLIDE_TOGGLE_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdSlideToggle; }),\\n    multi: true\\n};\\nvar MdSlideToggleChange = /*@__PURE__*/(function () {\\n    function MdSlideToggleChange() {\\n    }\\n    return MdSlideToggleChange;\\n}());\\n// Increasing integer for generating unique ids for slide-toggle components.\\nvar nextId$1 = 0;\\n/**\\n * \\\\@docs-private\\n */\\nvar MdSlideToggleBase = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdSlideToggleBase(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n    }\\n    return MdSlideToggleBase;\\n}());\\nvar _MdSlideToggleMixinBase = mixinColor(mixinDisabled(MdSlideToggleBase), \\'accent\\');\\n/**\\n * Represents a slidable \"switch\" toggle that can be moved between on and off.\\n */\\nvar MdSlideToggle = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdSlideToggle, _super);\\n    /**\\n     * @param {?} elementRef\\n     * @param {?} renderer\\n     * @param {?} _platform\\n     * @param {?} _focusOriginMonitor\\n     * @param {?} _changeDetectorRef\\n     */\\n    function MdSlideToggle(elementRef, renderer, _platform, _focusOriginMonitor, _changeDetectorRef) {\\n        var _this = _super.call(this, renderer, elementRef) || this;\\n        _this._platform = _platform;\\n        _this._focusOriginMonitor = _focusOriginMonitor;\\n        _this._changeDetectorRef = _changeDetectorRef;\\n        _this.onChange = function (_) { };\\n        _this.onTouched = function () { };\\n        _this._uniqueId = \"md-slide-toggle-\" + ++nextId$1;\\n        _this._checked = false;\\n        _this._required = false;\\n        _this._disableRipple = false;\\n        /**\\n         * Name value will be applied to the input element if present\\n         */\\n        _this.name = null;\\n        /**\\n         * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.\\n         */\\n        _this.id = _this._uniqueId;\\n        /**\\n         * Used to specify the tabIndex value for the underlying input element.\\n         */\\n        _this.tabIndex = 0;\\n        /**\\n         * Whether the label should appear after or before the slide-toggle. Defaults to \\'after\\'\\n         */\\n        _this.labelPosition = \\'after\\';\\n        /**\\n         * Used to set the aria-label attribute on the underlying input element.\\n         */\\n        _this.ariaLabel = null;\\n        /**\\n         * Used to set the aria-labelledby attribute on the underlying input element.\\n         */\\n        _this.ariaLabelledby = null;\\n        /**\\n         * An event will be dispatched each time the slide-toggle changes its value.\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        return _this;\\n    }\\n    Object.defineProperty(MdSlideToggle.prototype, \"required\", {\\n        /**\\n         * Whether the slide-toggle is required.\\n         * @return {?}\\n         */\\n        get: function () { return this._required; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._required = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlideToggle.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect for this slide-toggle is disabled.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlideToggle.prototype, \"inputId\", {\\n        /**\\n         * Returns the unique id for the visual hidden input.\\n         * @return {?}\\n         */\\n        get: function () { return (this.id || this._uniqueId) + \"-input\"; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._slideRenderer = new SlideToggleRenderer(this._elementRef, this._platform);\\n        this._focusOriginMonitor\\n            .monitor(this._inputElement.nativeElement, this._renderer, false)\\n            .subscribe(function (focusOrigin) { return _this._onInputFocusChange(focusOrigin); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._inputElement.nativeElement);\\n    };\\n    /**\\n     * The onChangeEvent method will be also called on click.\\n     * This is because everything for the slide-toggle is wrapped inside of a label,\\n     * which triggers a onChange event on click.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onChangeEvent = function (event) {\\n        // We always have to stop propagation on the change event.\\n        // Otherwise the change event, from the input element, will bubble up and\\n        // emit its event object to the component\\'s `change` output.\\n        event.stopPropagation();\\n        // Once a drag is currently in progress, we do not want to toggle the slide-toggle on a click.\\n        if (!this.disabled && !this._slideRenderer.dragging) {\\n            this.toggle();\\n            // Emit our custom change event if the native input emitted one.\\n            // It is important to only emit it, if the native input triggered one, because\\n            // we don\\'t want to trigger a change event, when the `checked` variable changes for example.\\n            this._emitChangeEvent();\\n        }\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onInputClick = function (event) {\\n        this.onTouched();\\n        // We have to stop propagation for click events on the visual hidden input element.\\n        // By default, when a user clicks on a label element, a generated click event will be\\n        // dispatched on the associated input element. Since we are using a label element as our\\n        // root container, the click event on the `slide-toggle` will be executed twice.\\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\\n        // This will lead to multiple click events.\\n        // Preventing bubbling for the second event will solve that issue.\\n        event.stopPropagation();\\n    };\\n    /**\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.writeValue = function (value) {\\n        this.checked = value;\\n    };\\n    /**\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.registerOnChange = function (fn) {\\n        this.onChange = fn;\\n    };\\n    /**\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.registerOnTouched = function (fn) {\\n        this.onTouched = fn;\\n    };\\n    /**\\n     * Implemented as a part of ControlValueAccessor.\\n     * @param {?} isDisabled\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n        this._changeDetectorRef.markForCheck();\\n    };\\n    /**\\n     * Focuses the slide-toggle.\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.focus = function () {\\n        this._focusOriginMonitor.focusVia(this._inputElement.nativeElement, \\'keyboard\\');\\n    };\\n    Object.defineProperty(MdSlideToggle.prototype, \"checked\", {\\n        /**\\n         * Whether the slide-toggle is checked.\\n         * @return {?}\\n         */\\n        get: function () { return !!this._checked; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this.checked !== !!value) {\\n                this._checked = value;\\n                this.onChange(this._checked);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Toggles the checked state of the slide-toggle.\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype.toggle = function () {\\n        this.checked = !this.checked;\\n    };\\n    /**\\n     * Function is called whenever the focus changes for the input element.\\n     * @param {?} focusOrigin\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onInputFocusChange = function (focusOrigin) {\\n        if (!this._focusRipple && focusOrigin === \\'keyboard\\') {\\n            // For keyboard focus show a persistent ripple as focus indicator.\\n            this._focusRipple = this._ripple.launch(0, 0, { persistent: true, centered: true });\\n        }\\n        else if (!focusOrigin) {\\n            this.onTouched();\\n            // Fade out and clear the focus ripple if one is currently present.\\n            if (this._focusRipple) {\\n                this._focusRipple.fadeOut();\\n                this._focusRipple = null;\\n            }\\n        }\\n    };\\n    /**\\n     * Emits the change event to the `change` output EventEmitter\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._emitChangeEvent = function () {\\n        var /** @type {?} */ event = new MdSlideToggleChange();\\n        event.source = this;\\n        event.checked = this.checked;\\n        this.change.emit(event);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onDragStart = function () {\\n        if (!this.disabled) {\\n            this._slideRenderer.startThumbDrag(this.checked);\\n        }\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onDrag = function (event) {\\n        if (this._slideRenderer.dragging) {\\n            this._slideRenderer.updateThumbPosition(event.deltaX);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlideToggle.prototype._onDragEnd = function () {\\n        var _this = this;\\n        if (this._slideRenderer.dragging) {\\n            var /** @type {?} */ _previousChecked = this.checked;\\n            this.checked = this._slideRenderer.dragPercentage > 50;\\n            if (_previousChecked !== this.checked) {\\n                this._emitChangeEvent();\\n            }\\n            // The drag should be stopped outside of the current event handler, because otherwise the\\n            // click event will be fired before and will revert the drag change.\\n            setTimeout(function () { return _this._slideRenderer.stopThumbDrag(); });\\n        }\\n    };\\n    return MdSlideToggle;\\n}(_MdSlideToggleMixinBase));\\nMdSlideToggle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-slide-toggle, mat-slide-toggle\\',\\n                host: {\\n                    \\'class\\': \\'mat-slide-toggle\\',\\n                    \\'[class.mat-checked]\\': \\'checked\\',\\n                    \\'[class.mat-disabled]\\': \\'disabled\\',\\n                    \\'[class.mat-slide-toggle-label-before]\\': \\'labelPosition == \"before\"\\',\\n                },\\n                template: \"<label class=\\\\\"mat-slide-toggle-label\\\\\" #label><div class=\\\\\"mat-slide-toggle-bar\\\\\"><input #input class=\\\\\"mat-slide-toggle-input cdk-visually-hidden\\\\\" type=\\\\\"checkbox\\\\\" [id]=\\\\\"inputId\\\\\" [required]=\\\\\"required\\\\\" [tabIndex]=\\\\\"tabIndex\\\\\" [checked]=\\\\\"checked\\\\\" [disabled]=\\\\\"disabled\\\\\" [attr.name]=\\\\\"name\\\\\" [attr.aria-label]=\\\\\"ariaLabel\\\\\" [attr.aria-labelledby]=\\\\\"ariaLabelledby\\\\\" (change)=\\\\\"_onChangeEvent($event)\\\\\" (click)=\\\\\"_onInputClick($event)\\\\\"><div class=\\\\\"mat-slide-toggle-thumb-container\\\\\" (slidestart)=\\\\\"_onDragStart()\\\\\" (slide)=\\\\\"_onDrag($event)\\\\\" (slideend)=\\\\\"_onDragEnd()\\\\\"><div class=\\\\\"mat-slide-toggle-thumb\\\\\"></div><div class=\\\\\"mat-slide-toggle-ripple\\\\\" md-ripple [mdRippleTrigger]=\\\\\"label\\\\\" [mdRippleCentered]=\\\\\"true\\\\\" [mdRippleDisabled]=\\\\\"disableRipple || disabled\\\\\"></div></div></div><span class=\\\\\"mat-slide-toggle-content\\\\\"><ng-content></ng-content></span></label>\",\\n                styles: [\".mat-slide-toggle{display:inline-block;height:24px;line-height:24px;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px,0,0)}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;cursor:pointer}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}.mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-right:8px;margin-left:0}.mat-slide-toggle-label-before .mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0,0,0);transition:all 80ms linear;transition-property:transform;cursor:-webkit-grab;cursor:grab}.mat-slide-toggle-thumb-container.mat-dragging,.mat-slide-toggle-thumb-container:active{cursor:-webkit-grabbing;cursor:grabbing;transition-duration:0s}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%;box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-slide-toggle-thumb{background:#fff;border:solid 1px #000}}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;border-radius:8px}@media screen and (-ms-high-contrast:active){.mat-slide-toggle-bar{background:#fff}}.mat-slide-toggle-input{bottom:0;left:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}.mat-slide-toggle-ripple{position:absolute;top:-13px;left:-13px;height:46px;width:46px;border-radius:50%;z-index:1;pointer-events:none}\"],\\n                providers: [MD_SLIDE_TOGGLE_VALUE_ACCESSOR],\\n                inputs: [\\'disabled\\', \\'color\\'],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSlideToggle.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */], },\\n    { type: FocusOriginMonitor, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n]; };\\nMdSlideToggle.propDecorators = {\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'tabIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'labelPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'ariaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'ariaLabelledby\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-labelledby\\',] },],\\n    \\'required\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'_inputElement\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'input\\',] },],\\n    \\'_ripple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdRipple,] },],\\n    \\'checked\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Renderer for the Slide Toggle component, which separates DOM modification in its own class\\n */\\nvar SlideToggleRenderer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} platform\\n     */\\n    function SlideToggleRenderer(_elementRef, platform) {\\n        this._elementRef = _elementRef;\\n        /**\\n         * Whether the thumb is currently being dragged.\\n         */\\n        this.dragging = false;\\n        // We only need to interact with these elements when we\\'re on the browser, so only grab\\n        // the reference in that case.\\n        if (platform.isBrowser) {\\n            this._thumbEl = _elementRef.nativeElement.querySelector(\\'.mat-slide-toggle-thumb-container\\');\\n            this._thumbBarEl = _elementRef.nativeElement.querySelector(\\'.mat-slide-toggle-bar\\');\\n        }\\n    }\\n    /**\\n     * Initializes the drag of the slide-toggle.\\n     * @param {?} checked\\n     * @return {?}\\n     */\\n    SlideToggleRenderer.prototype.startThumbDrag = function (checked) {\\n        if (this.dragging) {\\n            return;\\n        }\\n        this._thumbBarWidth = this._thumbBarEl.clientWidth - this._thumbEl.clientWidth;\\n        this._thumbEl.classList.add(\\'mat-dragging\\');\\n        this._previousChecked = checked;\\n        this.dragging = true;\\n    };\\n    /**\\n     * Resets the current drag and returns the new checked value.\\n     * @return {?}\\n     */\\n    SlideToggleRenderer.prototype.stopThumbDrag = function () {\\n        if (!this.dragging) {\\n            return false;\\n        }\\n        this.dragging = false;\\n        this._thumbEl.classList.remove(\\'mat-dragging\\');\\n        // Reset the transform because the component will take care of the thumb position after drag.\\n        applyCssTransform(this._thumbEl, \\'\\');\\n        return this.dragPercentage > 50;\\n    };\\n    /**\\n     * Updates the thumb containers position from the specified distance.\\n     * @param {?} distance\\n     * @return {?}\\n     */\\n    SlideToggleRenderer.prototype.updateThumbPosition = function (distance) {\\n        this.dragPercentage = this._getDragPercentage(distance);\\n        // Calculate the moved distance based on the thumb bar width.\\n        var /** @type {?} */ dragX = (this.dragPercentage / 100) * this._thumbBarWidth;\\n        applyCssTransform(this._thumbEl, \"translate3d(\" + dragX + \"px, 0, 0)\");\\n    };\\n    /**\\n     * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.\\n     * @param {?} distance\\n     * @return {?}\\n     */\\n    SlideToggleRenderer.prototype._getDragPercentage = function (distance) {\\n        var /** @type {?} */ percentage = (distance / this._thumbBarWidth) * 100;\\n        // When the toggle was initially checked, then we have to start the drag at the end.\\n        if (this._previousChecked) {\\n            percentage += 100;\\n        }\\n        return Math.max(0, Math.min(percentage, 100));\\n    };\\n    return SlideToggleRenderer;\\n}());\\nvar MdSlideToggleModule = /*@__PURE__*/(function () {\\n    function MdSlideToggleModule() {\\n    }\\n    return MdSlideToggleModule;\\n}());\\nMdSlideToggleModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"FormsModule\"], MdRippleModule, MdCommonModule, __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"M\" /* PlatformModule */]],\\n                exports: [MdSlideToggle, MdCommonModule],\\n                declarations: [MdSlideToggle],\\n                providers: [\\n                    FOCUS_ORIGIN_MONITOR_PROVIDER,\\n                    { provide: __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"HAMMER_GESTURE_CONFIG\"], useClass: GestureConfig }\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSlideToggleModule.ctorParameters = function () { return []; };\\n/**\\n * Visually, a 30px separation between tick marks looks best. This is very subjective but it is\\n * the default separation we chose.\\n */\\nvar MIN_AUTO_TICK_SEPARATION = 30;\\n/**\\n * The thumb gap size for a disabled slider.\\n */\\nvar DISABLED_THUMB_GAP = 7;\\n/**\\n * The thumb gap size for a non-active slider at its minimum value.\\n */\\nvar MIN_VALUE_NONACTIVE_THUMB_GAP = 7;\\n/**\\n * The thumb gap size for an active slider at its minimum value.\\n */\\nvar MIN_VALUE_ACTIVE_THUMB_GAP = 10;\\n/**\\n * Provider Expression that allows md-slider to register as a ControlValueAccessor.\\n * This allows it to support [(ngModel)] and [formControl].\\n */\\nvar MD_SLIDER_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdSlider; }),\\n    multi: true\\n};\\n/**\\n * A simple change event emitted by the MdSlider component.\\n */\\nvar MdSliderChange = /*@__PURE__*/(function () {\\n    function MdSliderChange() {\\n    }\\n    return MdSliderChange;\\n}());\\n/**\\n * \\\\@docs-private\\n */\\nvar MdSliderBase = /*@__PURE__*/(function () {\\n    function MdSliderBase() {\\n    }\\n    return MdSliderBase;\\n}());\\nvar _MdSliderMixinBase = mixinDisabled(MdSliderBase);\\n/**\\n * Allows users to select from a range of values by moving the slider thumb. It is similar in\\n * behavior to the native `<input type=\"range\">` element.\\n */\\nvar MdSlider = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdSlider, _super);\\n    /**\\n     * @param {?} renderer\\n     * @param {?} _elementRef\\n     * @param {?} _focusOriginMonitor\\n     * @param {?} _dir\\n     */\\n    function MdSlider(renderer, _elementRef, _focusOriginMonitor, _dir) {\\n        var _this = _super.call(this) || this;\\n        _this._elementRef = _elementRef;\\n        _this._focusOriginMonitor = _focusOriginMonitor;\\n        _this._dir = _dir;\\n        _this._invert = false;\\n        _this._max = 100;\\n        _this._min = 0;\\n        _this._step = 1;\\n        _this._thumbLabel = false;\\n        _this._tickInterval = 0;\\n        _this._value = null;\\n        _this._vertical = false;\\n        _this.color = \\'accent\\';\\n        /**\\n         * Event emitted when the slider value has changed.\\n         */\\n        _this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the slider thumb moves.\\n         */\\n        _this.input = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\\n         */\\n        _this.onTouched = function () { };\\n        _this._percent = 0;\\n        /**\\n         * Whether or not the thumb is sliding.\\n         * Used to determine if there should be a transition for the thumb and fill track.\\n         */\\n        _this._isSliding = false;\\n        /**\\n         * Whether or not the slider is active (clicked or sliding).\\n         * Used to shrink and grow the thumb as according to the Material Design spec.\\n         */\\n        _this._isActive = false;\\n        /**\\n         * The size of a tick interval as a percentage of the size of the track.\\n         */\\n        _this._tickIntervalPercent = 0;\\n        /**\\n         * The dimensions of the slider.\\n         */\\n        _this._sliderDimensions = null;\\n        _this._controlValueAccessorChangeFn = function () { };\\n        _this._focusOriginMonitor.monitor(_this._elementRef.nativeElement, renderer, true)\\n            .subscribe(function (origin) { return _this._isActive = !!origin && origin !== \\'keyboard\\'; });\\n        _this._renderer = new SliderRenderer(_this._elementRef);\\n        return _this;\\n    }\\n    Object.defineProperty(MdSlider.prototype, \"invert\", {\\n        /**\\n         * Whether the slider is inverted.\\n         * @return {?}\\n         */\\n        get: function () { return this._invert; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._invert = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"max\", {\\n        /**\\n         * The maximum value that the slider can have.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._max;\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._max = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_0\" /* coerceNumberProperty */](v, this._max);\\n            this._percent = this._calculatePercentage(this._value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"min\", {\\n        /**\\n         * The minimum value that the slider can have.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._min;\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._min = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_0\" /* coerceNumberProperty */](v, this._min);\\n            // If the value wasn\\'t explicitly set by the user, set it to the min.\\n            if (this._value === null) {\\n                this.value = this._min;\\n            }\\n            this._percent = this._calculatePercentage(this._value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"step\", {\\n        /**\\n         * The values at which the thumb will snap.\\n         * @return {?}\\n         */\\n        get: function () { return this._step; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._step = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_0\" /* coerceNumberProperty */](v, this._step);\\n            if (this._step % 1 !== 0) {\\n                this._roundLabelTo = ((this._step.toString().split(\\'.\\').pop())).length;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"thumbLabel\", {\\n        /**\\n         * Whether or not to show the thumb label.\\n         * @return {?}\\n         */\\n        get: function () { return this._thumbLabel; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._thumbLabel = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_thumbLabelDeprecated\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this._thumbLabel; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._thumbLabel = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"tickInterval\", {\\n        /**\\n         * How often to show ticks. Relative to the step so that a tick always appears on a step.\\n         * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).\\n         * @return {?}\\n         */\\n        get: function () { return this._tickInterval; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value === \\'auto\\') {\\n                this._tickInterval = \\'auto\\';\\n            }\\n            else if (typeof value === \\'number\\' || typeof value === \\'string\\') {\\n                this._tickInterval = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_0\" /* coerceNumberProperty */](value, /** @type {?} */ (this._tickInterval));\\n            }\\n            else {\\n                this._tickInterval = 0;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_tickIntervalDeprecated\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this.tickInterval; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.tickInterval = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"value\", {\\n        /**\\n         * Value of the slider.\\n         * @return {?}\\n         */\\n        get: function () {\\n            // If the value needs to be read and it is still uninitialized, initialize it to the min.\\n            if (this._value === null) {\\n                this.value = this._min;\\n            }\\n            return this._value;\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._value = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_0\" /* coerceNumberProperty */](v, this._value || 0);\\n            this._percent = this._calculatePercentage(this._value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"vertical\", {\\n        /**\\n         * Whether the slider is vertical.\\n         * @return {?}\\n         */\\n        get: function () { return this._vertical; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._vertical = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"displayValue\", {\\n        /**\\n         * The value to be used for display purposes.\\n         * @return {?}\\n         */\\n        get: function () {\\n            // Note that this could be improved further by rounding something like 0.999 to 1 or\\n            // 0.899 to 0.9, however it is very performance sensitive, because it gets called on\\n            // every change detection cycle.\\n            if (this._roundLabelTo && this.value && this.value % 1 !== 0) {\\n                return this.value.toFixed(this._roundLabelTo);\\n            }\\n            return this.value || 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"percent\", {\\n        /**\\n         * The percentage of the slider that coincides with the value.\\n         * @return {?}\\n         */\\n        get: function () { return this._clamp(this._percent); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_invertAxis\", {\\n        /**\\n         * Whether the axis of the slider is inverted.\\n         * (i.e. whether moving the thumb in the positive x or y direction decreases the slider\\'s value).\\n         * @return {?}\\n         */\\n        get: function () {\\n            // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to\\n            // top. However from a y-axis standpoint this is inverted.\\n            return this.vertical ? !this.invert : this.invert;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_isMinValue\", {\\n        /**\\n         * Whether the slider is at its minimum value.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.percent === 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_thumbGap\", {\\n        /**\\n         * The amount of space to leave between the slider thumb and the track fill & track background\\n         * elements.\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (this.disabled) {\\n                return DISABLED_THUMB_GAP;\\n            }\\n            if (this._isMinValue && !this.thumbLabel) {\\n                return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;\\n            }\\n            return 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_trackBackgroundStyles\", {\\n        /**\\n         * CSS styles for the track background element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ axis = this.vertical ? \\'Y\\' : \\'X\\';\\n            var /** @type {?} */ sign = this._invertMouseCoords ? \\'-\\' : \\'\\';\\n            return {\\n                \\'transform\\': \"translate\" + axis + \"(\" + sign + this._thumbGap + \"px) scale\" + axis + \"(\" + (1 - this.percent) + \")\"\\n            };\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_trackFillStyles\", {\\n        /**\\n         * CSS styles for the track fill element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ axis = this.vertical ? \\'Y\\' : \\'X\\';\\n            var /** @type {?} */ sign = this._invertMouseCoords ? \\'\\' : \\'-\\';\\n            return {\\n                \\'transform\\': \"translate\" + axis + \"(\" + sign + this._thumbGap + \"px) scale\" + axis + \"(\" + this.percent + \")\"\\n            };\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_ticksContainerStyles\", {\\n        /**\\n         * CSS styles for the ticks container element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ axis = this.vertical ? \\'Y\\' : \\'X\\';\\n            // For a horizontal slider in RTL languages we push the ticks container off the left edge\\n            // instead of the right edge to avoid causing a horizontal scrollbar to appear.\\n            var /** @type {?} */ sign = !this.vertical && this._direction == \\'rtl\\' ? \\'\\' : \\'-\\';\\n            var /** @type {?} */ offset = this._tickIntervalPercent / 2 * 100;\\n            return {\\n                \\'transform\\': \"translate\" + axis + \"(\" + sign + offset + \"%)\"\\n            };\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_ticksStyles\", {\\n        /**\\n         * CSS styles for the ticks element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ tickSize = this._tickIntervalPercent * 100;\\n            var /** @type {?} */ backgroundSize = this.vertical ? \"2px \" + tickSize + \"%\" : tickSize + \"% 2px\";\\n            var /** @type {?} */ axis = this.vertical ? \\'Y\\' : \\'X\\';\\n            // Depending on the direction we pushed the ticks container, push the ticks the opposite\\n            // direction to re-center them but clip off the end edge. In RTL languages we need to flip the\\n            // ticks 180 degrees so we\\'re really cutting off the end edge abd not the start.\\n            var /** @type {?} */ sign = !this.vertical && this._direction == \\'rtl\\' ? \\'-\\' : \\'\\';\\n            var /** @type {?} */ rotate = !this.vertical && this._direction == \\'rtl\\' ? \\' rotate(180deg)\\' : \\'\\';\\n            var /** @type {?} */ styles = {\\n                \\'backgroundSize\\': backgroundSize,\\n                // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.\\n                \\'transform\\': \"translateZ(0) translate\" + axis + \"(\" + sign + tickSize / 2 + \"%)\" + rotate\\n            };\\n            if (this._isMinValue && this._thumbGap) {\\n                var /** @type {?} */ side = this.vertical ?\\n                    (this._invertAxis ? \\'Bottom\\' : \\'Top\\') :\\n                    (this._invertAxis ? \\'Right\\' : \\'Left\\');\\n                styles[\"padding\" + side] = this._thumbGap + \"px\";\\n            }\\n            return styles;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_thumbContainerStyles\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ axis = this.vertical ? \\'Y\\' : \\'X\\';\\n            // For a horizontal slider in RTL languages we push the thumb container off the left edge\\n            // instead of the right edge to avoid causing a horizontal scrollbar to appear.\\n            var /** @type {?} */ invertOffset = (this._direction == \\'rtl\\' && !this.vertical) ? !this._invertAxis : this._invertAxis;\\n            var /** @type {?} */ offset = (invertOffset ? this.percent : 1 - this.percent) * 100;\\n            return {\\n                \\'transform\\': \"translate\" + axis + \"(-\" + offset + \"%)\"\\n            };\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_invertMouseCoords\", {\\n        /**\\n         * Whether mouse events should be converted to a slider position by calculating their distance\\n         * from the right or bottom edge of the slider as opposed to the top or left.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return (this._direction == \\'rtl\\' && !this.vertical) ? !this._invertAxis : this._invertAxis;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSlider.prototype, \"_direction\", {\\n        /**\\n         * The language direction for this slider element.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return (this._dir && this._dir.value == \\'rtl\\') ? \\'rtl\\' : \\'ltr\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype.ngOnDestroy = function () {\\n        this._focusOriginMonitor.stopMonitoring(this._elementRef.nativeElement);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onMouseenter = function () {\\n        if (this.disabled) {\\n            return;\\n        }\\n        // We save the dimensions of the slider here so we can use them to update the spacing of the\\n        // ticks and determine where on the slider click and slide events happen.\\n        this._sliderDimensions = this._renderer.getSliderDimensions();\\n        this._updateTickIntervalPercent();\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onClick = function (event) {\\n        if (this.disabled) {\\n            return;\\n        }\\n        this._isSliding = false;\\n        this._renderer.addFocus();\\n        this._updateValueFromPosition({ x: event.clientX, y: event.clientY });\\n        /* Emits a change and input event if the value changed. */\\n        this._emitInputEvent();\\n        this._emitValueIfChanged();\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onSlide = function (event) {\\n        if (this.disabled) {\\n            return;\\n        }\\n        // Prevent the slide from selecting anything else.\\n        event.preventDefault();\\n        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });\\n        // Native range elements always emit `input` events when the value changed while sliding.\\n        this._emitInputEvent();\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onSlideStart = function (event) {\\n        if (this.disabled) {\\n            return;\\n        }\\n        // Simulate mouseenter in case this is a mobile device.\\n        this._onMouseenter();\\n        event.preventDefault();\\n        this._isSliding = true;\\n        this._renderer.addFocus();\\n        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onSlideEnd = function () {\\n        this._isSliding = false;\\n        this._emitValueIfChanged();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onFocus = function () {\\n        // We save the dimensions of the slider here so we can use them to update the spacing of the\\n        // ticks and determine where on the slider click and slide events happen.\\n        this._sliderDimensions = this._renderer.getSliderDimensions();\\n        this._updateTickIntervalPercent();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onBlur = function () {\\n        this.onTouched();\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onKeydown = function (event) {\\n        if (this.disabled) {\\n            return;\\n        }\\n        switch (event.keyCode) {\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"K\" /* PAGE_UP */]:\\n                this._increment(10);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"J\" /* PAGE_DOWN */]:\\n                this._increment(-10);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"t\" /* END */]:\\n                this.value = this.max;\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"A\" /* HOME */]:\\n                this.value = this.min;\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"C\" /* LEFT_ARROW */]:\\n                // NOTE: For a sighted user it would make more sense that when they press an arrow key on an\\n                // inverted slider the thumb moves in that direction. However for a blind user, nothing\\n                // about the slider indicates that it is inverted. They will expect left to be decrement,\\n                // regardless of how it appears on the screen. For speakers ofRTL languages, they probably\\n                // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for\\n                // RTL. For inverted sliders we prefer a good a11y experience to having it \"look right\" for\\n                // sighted users, therefore we do not swap the meaning.\\n                this._increment(this._direction == \\'rtl\\' ? 1 : -1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"W\" /* UP_ARROW */]:\\n                this._increment(1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Q\" /* RIGHT_ARROW */]:\\n                // See comment on LEFT_ARROW about the conditions under which we flip the meaning.\\n                this._increment(this._direction == \\'rtl\\' ? -1 : 1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"p\" /* DOWN_ARROW */]:\\n                this._increment(-1);\\n                break;\\n            default:\\n                // Return if the key is not one that we explicitly handle to avoid calling preventDefault on\\n                // it.\\n                return;\\n        }\\n        this._isSliding = true;\\n        event.preventDefault();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSlider.prototype._onKeyup = function () {\\n        this._isSliding = false;\\n    };\\n    /**\\n     * Increments the slider by the given number of steps (negative number decrements).\\n     * @param {?} numSteps\\n     * @return {?}\\n     */\\n    MdSlider.prototype._increment = function (numSteps) {\\n        this.value = this._clamp((this.value || 0) + this.step * numSteps, this.min, this.max);\\n        this._emitInputEvent();\\n        this._emitValueIfChanged();\\n    };\\n    /**\\n     * Calculate the new value from the new physical location. The value will always be snapped.\\n     * @param {?} pos\\n     * @return {?}\\n     */\\n    MdSlider.prototype._updateValueFromPosition = function (pos) {\\n        if (!this._sliderDimensions) {\\n            return;\\n        }\\n        var /** @type {?} */ offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;\\n        var /** @type {?} */ size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;\\n        var /** @type {?} */ posComponent = this.vertical ? pos.y : pos.x;\\n        // The exact value is calculated from the event and used to find the closest snap value.\\n        var /** @type {?} */ percent = this._clamp((posComponent - offset) / size);\\n        if (this._invertMouseCoords) {\\n            percent = 1 - percent;\\n        }\\n        var /** @type {?} */ exactValue = this._calculateValue(percent);\\n        // This calculation finds the closest step by finding the closest whole number divisible by the\\n        // step relative to the min.\\n        var /** @type {?} */ closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;\\n        // The value needs to snap to the min and max.\\n        this.value = this._clamp(closestValue, this.min, this.max);\\n    };\\n    /**\\n     * Emits a change event if the current value is different from the last emitted value.\\n     * @return {?}\\n     */\\n    MdSlider.prototype._emitValueIfChanged = function () {\\n        if (this.value != this._lastChangeValue) {\\n            var /** @type {?} */ event = this._createChangeEvent();\\n            this._lastChangeValue = this.value;\\n            this._controlValueAccessorChangeFn(this.value);\\n            this.change.emit(event);\\n        }\\n    };\\n    /**\\n     * Emits an input event when the current value is different from the last emitted value.\\n     * @return {?}\\n     */\\n    MdSlider.prototype._emitInputEvent = function () {\\n        if (this.value != this._lastInputValue) {\\n            var /** @type {?} */ event = this._createChangeEvent();\\n            this._lastInputValue = this.value;\\n            this.input.emit(event);\\n        }\\n    };\\n    /**\\n     * Updates the amount of space between ticks as a percentage of the width of the slider.\\n     * @return {?}\\n     */\\n    MdSlider.prototype._updateTickIntervalPercent = function () {\\n        if (!this.tickInterval || !this._sliderDimensions) {\\n            return;\\n        }\\n        if (this.tickInterval == \\'auto\\') {\\n            var /** @type {?} */ trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;\\n            var /** @type {?} */ pixelsPerStep = trackSize * this.step / (this.max - this.min);\\n            var /** @type {?} */ stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);\\n            var /** @type {?} */ pixelsPerTick = stepsPerTick * this.step;\\n            this._tickIntervalPercent = pixelsPerTick / trackSize;\\n        }\\n        else {\\n            this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);\\n        }\\n    };\\n    /**\\n     * Creates a slider change object from the specified value.\\n     * @param {?=} value\\n     * @return {?}\\n     */\\n    MdSlider.prototype._createChangeEvent = function (value) {\\n        if (value === void 0) { value = this.value; }\\n        var /** @type {?} */ event = new MdSliderChange();\\n        event.source = this;\\n        event.value = value;\\n        return event;\\n    };\\n    /**\\n     * Calculates the percentage of the slider that a value is.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdSlider.prototype._calculatePercentage = function (value) {\\n        return ((value || 0) - this.min) / (this.max - this.min);\\n    };\\n    /**\\n     * Calculates the value a percentage of the slider corresponds to.\\n     * @param {?} percentage\\n     * @return {?}\\n     */\\n    MdSlider.prototype._calculateValue = function (percentage) {\\n        return this.min + percentage * (this.max - this.min);\\n    };\\n    /**\\n     * Return a number between two numbers.\\n     * @param {?} value\\n     * @param {?=} min\\n     * @param {?=} max\\n     * @return {?}\\n     */\\n    MdSlider.prototype._clamp = function (value, min, max) {\\n        if (min === void 0) { min = 0; }\\n        if (max === void 0) { max = 1; }\\n        return Math.max(min, Math.min(value, max));\\n    };\\n    /**\\n     * Sets the model value. Implemented as part of ControlValueAccessor.\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdSlider.prototype.writeValue = function (value) {\\n        this.value = value;\\n    };\\n    /**\\n     * Registers a callback to eb triggered when the value has changed.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Callback to be registered.\\n     * @return {?}\\n     */\\n    MdSlider.prototype.registerOnChange = function (fn) {\\n        this._controlValueAccessorChangeFn = fn;\\n    };\\n    /**\\n     * Registers a callback to be triggered when the component is touched.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} fn Callback to be registered.\\n     * @return {?}\\n     */\\n    MdSlider.prototype.registerOnTouched = function (fn) {\\n        this.onTouched = fn;\\n    };\\n    /**\\n     * Sets whether the component should be disabled.\\n     * Implemented as part of ControlValueAccessor.\\n     * @param {?} isDisabled\\n     * @return {?}\\n     */\\n    MdSlider.prototype.setDisabledState = function (isDisabled) {\\n        this.disabled = isDisabled;\\n    };\\n    return MdSlider;\\n}(_MdSliderMixinBase));\\nMdSlider.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-slider, mat-slider\\',\\n                providers: [MD_SLIDER_VALUE_ACCESSOR],\\n                host: {\\n                    \\'(focus)\\': \\'_onFocus()\\',\\n                    \\'(blur)\\': \\'_onBlur()\\',\\n                    \\'(click)\\': \\'_onClick($event)\\',\\n                    \\'(keydown)\\': \\'_onKeydown($event)\\',\\n                    \\'(keyup)\\': \\'_onKeyup()\\',\\n                    \\'(mouseenter)\\': \\'_onMouseenter()\\',\\n                    \\'(slide)\\': \\'_onSlide($event)\\',\\n                    \\'(slideend)\\': \\'_onSlideEnd()\\',\\n                    \\'(slidestart)\\': \\'_onSlideStart($event)\\',\\n                    \\'class\\': \\'mat-slider\\',\\n                    \\'role\\': \\'slider\\',\\n                    \\'tabindex\\': \\'0\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled\\',\\n                    \\'[attr.aria-valuemax]\\': \\'max\\',\\n                    \\'[attr.aria-valuemin]\\': \\'min\\',\\n                    \\'[attr.aria-valuenow]\\': \\'value\\',\\n                    \\'[attr.aria-orientation]\\': \\'vertical ? \"vertical\" : \"horizontal\"\\',\\n                    \\'[class.mat-primary]\\': \\'color == \"primary\"\\',\\n                    \\'[class.mat-accent]\\': \\'color != \"primary\" && color != \"warn\"\\',\\n                    \\'[class.mat-warn]\\': \\'color == \"warn\"\\',\\n                    \\'[class.mat-slider-disabled]\\': \\'disabled\\',\\n                    \\'[class.mat-slider-has-ticks]\\': \\'tickInterval\\',\\n                    \\'[class.mat-slider-horizontal]\\': \\'!vertical\\',\\n                    \\'[class.mat-slider-axis-inverted]\\': \\'_invertAxis\\',\\n                    \\'[class.mat-slider-sliding]\\': \\'_isSliding\\',\\n                    \\'[class.mat-slider-thumb-label-showing]\\': \\'thumbLabel\\',\\n                    \\'[class.mat-slider-vertical]\\': \\'vertical\\',\\n                    \\'[class.mat-slider-min-value]\\': \\'_isMinValue\\',\\n                    \\'[class.mat-slider-hide-last-tick]\\': \\'disabled || _isMinValue && _thumbGap && _invertAxis\\',\\n                },\\n                template: \"<div class=\\\\\"mat-slider-wrapper\\\\\"><div class=\\\\\"mat-slider-track-wrapper\\\\\"><div class=\\\\\"mat-slider-track-background\\\\\" [ngStyle]=\\\\\"_trackBackgroundStyles\\\\\"></div><div class=\\\\\"mat-slider-track-fill\\\\\" [ngStyle]=\\\\\"_trackFillStyles\\\\\"></div></div><div class=\\\\\"mat-slider-ticks-container\\\\\" [ngStyle]=\\\\\"_ticksContainerStyles\\\\\"><div class=\\\\\"mat-slider-ticks\\\\\" [ngStyle]=\\\\\"_ticksStyles\\\\\"></div></div><div class=\\\\\"mat-slider-thumb-container\\\\\" [ngStyle]=\\\\\"_thumbContainerStyles\\\\\"><div class=\\\\\"mat-slider-focus-ring\\\\\"></div><div class=\\\\\"mat-slider-thumb\\\\\"></div><div class=\\\\\"mat-slider-thumb-label\\\\\"><span class=\\\\\"mat-slider-thumb-label-text\\\\\">{{displayValue}}</span></div></div></div>\",\\n                styles: [\".mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:0;vertical-align:middle}.mat-slider-wrapper{position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{background-repeat:repeat;background-clip:content-box;box-sizing:border-box;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),opacity .4s cubic-bezier(.25,.8,.25,1)}.cdk-keyboard-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb-label{cursor:-webkit-grab;cursor:grab}.mat-slider-sliding:not(.mat-slider-disabled) .mat-slider-thumb,.mat-slider-sliding:not(.mat-slider-disabled) .mat-slider-thumb-label,.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb-label:active,.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb:active{cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(.7);transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),border-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform .4s cubic-bezier(.25,.8,.25,1),border-radius .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-sliding .mat-slider-thumb-container,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-track-fill{transition-duration:0s}.mat-slider-has-ticks .mat-slider-wrapper::after{content:\\'\\';position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.cdk-focused .mat-slider-thumb-label-text{opacity:1}.cdk-mouse-focused .mat-slider-thumb,.cdk-program-focused .mat-slider-thumb,.cdk-touch-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}\"],\\n                inputs: [\\'disabled\\'],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSlider.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusOriginMonitor, },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdSlider.propDecorators = {\\n    \\'invert\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'max\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'min\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'step\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'thumbLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_thumbLabelDeprecated\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'thumb-label\\',] },],\\n    \\'tickInterval\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_tickIntervalDeprecated\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'tick-interval\\',] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'vertical\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'input\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Renderer class in order to keep all dom manipulation in one place and outside of the main class.\\n * \\\\@docs-private\\n */\\nvar SliderRenderer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementRef\\n     */\\n    function SliderRenderer(elementRef) {\\n        this._sliderElement = elementRef.nativeElement;\\n    }\\n    /**\\n     * Get the bounding client rect of the slider track element.\\n     * The track is used rather than the native element to ignore the extra space that the thumb can\\n     * take up.\\n     * @return {?}\\n     */\\n    SliderRenderer.prototype.getSliderDimensions = function () {\\n        var /** @type {?} */ wrapperElement = this._sliderElement.querySelector(\\'.mat-slider-wrapper\\');\\n        return wrapperElement ? wrapperElement.getBoundingClientRect() : null;\\n    };\\n    /**\\n     * Focuses the native element.\\n     * Currently only used to allow a blur event to fire but will be used with keyboard input later.\\n     * @return {?}\\n     */\\n    SliderRenderer.prototype.addFocus = function () {\\n        this._sliderElement.focus();\\n    };\\n    return SliderRenderer;\\n}());\\nvar MdSliderModule = /*@__PURE__*/(function () {\\n    function MdSliderModule() {\\n    }\\n    return MdSliderModule;\\n}());\\nMdSliderModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"], __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"FormsModule\"], MdCommonModule, StyleModule, __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"d\" /* BidiModule */]],\\n                exports: [MdSlider, MdCommonModule],\\n                declarations: [MdSlider],\\n                providers: [{ provide: __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"HAMMER_GESTURE_CONFIG\"], useClass: GestureConfig }]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSliderModule.ctorParameters = function () { return []; };\\n/**\\n * Throws an exception when two MdSidenav are matching the same side.\\n * @param {?} align\\n * @return {?}\\n */\\nfunction throwMdDuplicatedSidenavError(align) {\\n    throw Error(\"A sidenav was already declared for \\'align=\\\\\"\" + align + \"\\\\\"\\'\");\\n}\\n/**\\n * Sidenav toggle promise result.\\n */\\nvar MdSidenavToggleResult = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} type\\n     * @param {?} animationFinished\\n     */\\n    function MdSidenavToggleResult(type, animationFinished) {\\n        this.type = type;\\n        this.animationFinished = animationFinished;\\n    }\\n    return MdSidenavToggleResult;\\n}());\\n/**\\n * <md-sidenav> component.\\n *\\n * This component corresponds to the drawer of the sidenav.\\n *\\n * Please refer to README.md for examples on how to use it.\\n */\\nvar MdSidenav = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef The DOM element reference. Used for transition and width calculation.\\n     *     If not available we do not hook on transitions.\\n     * @param {?} _focusTrapFactory\\n     * @param {?} _doc\\n     */\\n    function MdSidenav(_elementRef, _focusTrapFactory, _doc) {\\n        var _this = this;\\n        this._elementRef = _elementRef;\\n        this._focusTrapFactory = _focusTrapFactory;\\n        this._doc = _doc;\\n        /**\\n         * Alignment of the sidenav (direction neutral); whether \\'start\\' or \\'end\\'.\\n         */\\n        this._align = \\'start\\';\\n        /**\\n         * Mode of the sidenav; one of \\'over\\', \\'push\\' or \\'side\\'.\\n         */\\n        this.mode = \\'over\\';\\n        this._disableClose = false;\\n        /**\\n         * Whether the sidenav is opened.\\n         */\\n        this._opened = false;\\n        /**\\n         * Event emitted when the sidenav is being opened. Use this to synchronize animations.\\n         */\\n        this.onOpenStart = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the sidenav is fully opened.\\n         */\\n        this.onOpen = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the sidenav is being closed. Use this to synchronize animations.\\n         */\\n        this.onCloseStart = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the sidenav is fully closed.\\n         */\\n        this.onClose = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the sidenav alignment changes.\\n         */\\n        this.onAlignChanged = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * The current toggle animation promise. `null` if no animation is in progress.\\n         */\\n        this._toggleAnimationPromise = null;\\n        /**\\n         * The current toggle animation promise resolution function.\\n         * `null` if no animation is in progress.\\n         */\\n        this._resolveToggleAnimationPromise = null;\\n        this._elementFocusedBeforeSidenavWasOpened = null;\\n        this.onOpen.subscribe(function () {\\n            if (_this._doc) {\\n                _this._elementFocusedBeforeSidenavWasOpened = _this._doc.activeElement;\\n            }\\n            if (_this.isFocusTrapEnabled && _this._focusTrap) {\\n                _this._focusTrap.focusInitialElementWhenReady();\\n            }\\n        });\\n        this.onClose.subscribe(function () { return _this._restoreFocus(); });\\n    }\\n    Object.defineProperty(MdSidenav.prototype, \"align\", {\\n        /**\\n         * Direction which the sidenav is aligned in.\\n         * @return {?}\\n         */\\n        get: function () { return this._align; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            // Make sure we have a valid value.\\n            value = (value == \\'end\\') ? \\'end\\' : \\'start\\';\\n            if (value != this._align) {\\n                this._align = value;\\n                this.onAlignChanged.emit();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"disableClose\", {\\n        /**\\n         * Whether the sidenav can be closed with the escape key or not.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableClose; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableClose = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"isFocusTrapEnabled\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            // The focus trap is only enabled when the sidenav is open in any mode other than side.\\n            return this.opened && this.mode !== \\'side\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * If focus is currently inside the sidenav, restores it to where it was before the sidenav\\n     * opened.\\n     * @return {?}\\n     */\\n    MdSidenav.prototype._restoreFocus = function () {\\n        var /** @type {?} */ activeEl = this._doc && this._doc.activeElement;\\n        if (activeEl && this._elementRef.nativeElement.contains(activeEl)) {\\n            if (this._elementFocusedBeforeSidenavWasOpened instanceof HTMLElement) {\\n                this._elementFocusedBeforeSidenavWasOpened.focus();\\n            }\\n            else {\\n                this._elementRef.nativeElement.blur();\\n            }\\n        }\\n        this._elementFocusedBeforeSidenavWasOpened = null;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenav.prototype.ngAfterContentInit = function () {\\n        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\\n        this._focusTrap.enabled = this.isFocusTrapEnabled;\\n        // This can happen when the sidenav is set to opened in\\n        // the template and the transition hasn\\'t ended.\\n        if (this._toggleAnimationPromise && this._resolveToggleAnimationPromise) {\\n            this._resolveToggleAnimationPromise(true);\\n            this._toggleAnimationPromise = this._resolveToggleAnimationPromise = null;\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenav.prototype.ngOnDestroy = function () {\\n        if (this._focusTrap) {\\n            this._focusTrap.destroy();\\n        }\\n    };\\n    Object.defineProperty(MdSidenav.prototype, \"opened\", {\\n        /**\\n         * Whether the sidenav is opened. We overload this because we trigger an event when it\\n         * starts or end.\\n         * @return {?}\\n         */\\n        get: function () { return this._opened; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this.toggle(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](v));\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Open this sidenav, and return a Promise that will resolve when it\\'s fully opened (or get\\n     * rejected if it didn\\'t).\\n     * @return {?}\\n     */\\n    MdSidenav.prototype.open = function () {\\n        return this.toggle(true);\\n    };\\n    /**\\n     * Close this sidenav, and return a Promise that will resolve when it\\'s fully closed (or get\\n     * rejected if it didn\\'t).\\n     * @return {?}\\n     */\\n    MdSidenav.prototype.close = function () {\\n        return this.toggle(false);\\n    };\\n    /**\\n     * Toggle this sidenav. This is equivalent to calling open() when it\\'s already opened, or\\n     * close() when it\\'s closed.\\n     * @param {?=} isOpen Whether the sidenav should be open.\\n     * @return {?} Resolves with the result of whether the sidenav was opened or closed.\\n     */\\n    MdSidenav.prototype.toggle = function (isOpen) {\\n        var _this = this;\\n        if (isOpen === void 0) { isOpen = !this.opened; }\\n        // Shortcut it if we\\'re already opened.\\n        if (isOpen === this.opened) {\\n            return this._toggleAnimationPromise ||\\n                Promise.resolve(new MdSidenavToggleResult(isOpen ? \\'open\\' : \\'close\\', true));\\n        }\\n        this._opened = isOpen;\\n        if (this._focusTrap) {\\n            this._focusTrap.enabled = this.isFocusTrapEnabled;\\n        }\\n        if (isOpen) {\\n            this.onOpenStart.emit();\\n        }\\n        else {\\n            this.onCloseStart.emit();\\n        }\\n        if (this._toggleAnimationPromise && this._resolveToggleAnimationPromise) {\\n            this._resolveToggleAnimationPromise(false);\\n        }\\n        this._toggleAnimationPromise = new Promise(function (resolve) {\\n            _this._resolveToggleAnimationPromise = function (animationFinished) { return resolve(new MdSidenavToggleResult(isOpen ? \\'open\\' : \\'close\\', animationFinished)); };\\n        });\\n        return this._toggleAnimationPromise;\\n    };\\n    /**\\n     * Handles the keyboard events.\\n     * \\\\@docs-private\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSidenav.prototype.handleKeydown = function (event) {\\n        if (event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"v\" /* ESCAPE */] && !this.disableClose) {\\n            this.close();\\n            event.stopPropagation();\\n        }\\n    };\\n    /**\\n     * When transition has finished, set the internal state for classes and emit the proper event.\\n     * The event passed is actually of type TransitionEvent, but that type is not available in\\n     * Android so we use any.\\n     * @param {?} transitionEvent\\n     * @return {?}\\n     */\\n    MdSidenav.prototype._onTransitionEnd = function (transitionEvent) {\\n        if (transitionEvent.target == this._elementRef.nativeElement\\n            && transitionEvent.propertyName.endsWith(\\'transform\\')) {\\n            if (this._opened) {\\n                this.onOpen.emit();\\n            }\\n            else {\\n                this.onClose.emit();\\n            }\\n            if (this._toggleAnimationPromise && this._resolveToggleAnimationPromise) {\\n                this._resolveToggleAnimationPromise(true);\\n                this._toggleAnimationPromise = this._resolveToggleAnimationPromise = null;\\n            }\\n        }\\n    };\\n    Object.defineProperty(MdSidenav.prototype, \"_isClosing\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return !this._opened && !!this._toggleAnimationPromise;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_isOpening\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._opened && !!this._toggleAnimationPromise;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_isClosed\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return !this._opened && !this._toggleAnimationPromise;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_isOpened\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._opened && !this._toggleAnimationPromise;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_isEnd\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.align == \\'end\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_modeSide\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.mode == \\'side\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_modeOver\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.mode == \\'over\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_modePush\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.mode == \\'push\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenav.prototype, \"_width\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (this._elementRef.nativeElement) {\\n                return this._elementRef.nativeElement.offsetWidth;\\n            }\\n            return 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return MdSidenav;\\n}());\\nMdSidenav.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-sidenav, mat-sidenav\\',\\n                // TODO(mmalerba): move template to separate file.\\n                template: \"<ng-content></ng-content>\",\\n                host: {\\n                    \\'class\\': \\'mat-sidenav\\',\\n                    \\'(transitionend)\\': \\'_onTransitionEnd($event)\\',\\n                    \\'(keydown)\\': \\'handleKeydown($event)\\',\\n                    // must prevent the browser from aligning text based on value\\n                    \\'[attr.align]\\': \\'null\\',\\n                    \\'[class.mat-sidenav-closed]\\': \\'_isClosed\\',\\n                    \\'[class.mat-sidenav-closing]\\': \\'_isClosing\\',\\n                    \\'[class.mat-sidenav-end]\\': \\'_isEnd\\',\\n                    \\'[class.mat-sidenav-opened]\\': \\'_isOpened\\',\\n                    \\'[class.mat-sidenav-opening]\\': \\'_isOpening\\',\\n                    \\'[class.mat-sidenav-over]\\': \\'_modeOver\\',\\n                    \\'[class.mat-sidenav-push]\\': \\'_modePush\\',\\n                    \\'[class.mat-sidenav-side]\\': \\'_modeSide\\',\\n                    \\'tabIndex\\': \\'-1\\'\\n                },\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSidenav.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"z\" /* FocusTrapFactory */], },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"DOCUMENT\"],] },] },\\n]; };\\nMdSidenav.propDecorators = {\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'mode\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disableClose\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'onOpenStart\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'open-start\\',] },],\\n    \\'onOpen\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'open\\',] },],\\n    \\'onCloseStart\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'close-start\\',] },],\\n    \\'onClose\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'close\\',] },],\\n    \\'onAlignChanged\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'align-changed\\',] },],\\n    \\'opened\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * <md-sidenav-container> component.\\n *\\n * This is the parent component to one or two <md-sidenav>s that validates the state internally\\n * and coordinates the backdrop and content styling.\\n */\\nvar MdSidenavContainer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dir\\n     * @param {?} _element\\n     * @param {?} _renderer\\n     * @param {?} _ngZone\\n     */\\n    function MdSidenavContainer(_dir, _element, _renderer, _ngZone) {\\n        var _this = this;\\n        this._dir = _dir;\\n        this._element = _element;\\n        this._renderer = _renderer;\\n        this._ngZone = _ngZone;\\n        /**\\n         * Event emitted when the sidenav backdrop is clicked.\\n         */\\n        this.backdropClick = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Whether to enable open/close trantions.\\n         */\\n        this._enableTransitions = false;\\n        // If a `Dir` directive exists up the tree, listen direction changes and update the left/right\\n        // properties to point to the proper start/end.\\n        if (_dir != null) {\\n            _dir.change.subscribe(function () { return _this._validateDrawers(); });\\n        }\\n    }\\n    Object.defineProperty(MdSidenavContainer.prototype, \"start\", {\\n        /**\\n         * The sidenav child with the `start` alignment.\\n         * @return {?}\\n         */\\n        get: function () { return this._start; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSidenavContainer.prototype, \"end\", {\\n        /**\\n         * The sidenav child with the `end` alignment.\\n         * @return {?}\\n         */\\n        get: function () { return this._end; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        // On changes, assert on consistency.\\n        this._sidenavs.changes.subscribe(function () { return _this._validateDrawers(); });\\n        this._sidenavs.forEach(function (sidenav) {\\n            _this._watchSidenavToggle(sidenav);\\n            _this._watchSidenavAlign(sidenav);\\n        });\\n        this._validateDrawers();\\n        // Give the view a chance to render the initial state, then enable transitions.\\n        __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_4\" /* first */].call(this._ngZone.onMicrotaskEmpty).subscribe(function () { return _this._enableTransitions = true; });\\n    };\\n    /**\\n     * Calls `open` of both start and end sidenavs\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype.open = function () {\\n        return Promise.all([this._start, this._end]\\n            .filter(function (sidenav) { return sidenav; })\\n            .map(function (sidenav) { return ((sidenav)).open(); }));\\n    };\\n    /**\\n     * Calls `close` of both start and end sidenavs\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype.close = function () {\\n        return Promise.all([this._start, this._end]\\n            .filter(function (sidenav) { return sidenav; })\\n            .map(function (sidenav) { return ((sidenav)).close(); }));\\n    };\\n    /**\\n     * Subscribes to sidenav events in order to set a class on the main container element when the\\n     * sidenav is open and the backdrop is visible. This ensures any overflow on the container element\\n     * is properly hidden.\\n     * @param {?} sidenav\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._watchSidenavToggle = function (sidenav) {\\n        var _this = this;\\n        if (!sidenav || sidenav.mode === \\'side\\') {\\n            return;\\n        }\\n        sidenav.onOpen.subscribe(function () { return _this._setContainerClass(true); });\\n        sidenav.onClose.subscribe(function () { return _this._setContainerClass(false); });\\n    };\\n    /**\\n     * Subscribes to sidenav onAlignChanged event in order to re-validate drawers when the align\\n     * changes.\\n     * @param {?} sidenav\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._watchSidenavAlign = function (sidenav) {\\n        var _this = this;\\n        if (!sidenav) {\\n            return;\\n        }\\n        // NOTE: We need to wait for the microtask queue to be empty before validating,\\n        // since both drawers may be swapping sides at the same time.\\n        sidenav.onAlignChanged.subscribe(function () { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_4\" /* first */].call(_this._ngZone.onMicrotaskEmpty).subscribe(function () { return _this._validateDrawers(); }); });\\n    };\\n    /**\\n     * Toggles the \\'mat-sidenav-opened\\' class on the main \\'md-sidenav-container\\' element.\\n     * @param {?} isAdd\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._setContainerClass = function (isAdd) {\\n        if (isAdd) {\\n            this._renderer.addClass(this._element.nativeElement, \\'mat-sidenav-opened\\');\\n        }\\n        else {\\n            this._renderer.removeClass(this._element.nativeElement, \\'mat-sidenav-opened\\');\\n        }\\n    };\\n    /**\\n     * Validate the state of the sidenav children components.\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._validateDrawers = function () {\\n        this._start = this._end = null;\\n        // Ensure that we have at most one start and one end sidenav.\\n        // NOTE: We must call toArray on _sidenavs even though it\\'s iterable\\n        // (see https://github.com/Microsoft/TypeScript/issues/3164).\\n        for (var _i = 0, _a = this._sidenavs.toArray(); _i < _a.length; _i++) {\\n            var sidenav = _a[_i];\\n            if (sidenav.align == \\'end\\') {\\n                if (this._end != null) {\\n                    throwMdDuplicatedSidenavError(\\'end\\');\\n                }\\n                this._end = sidenav;\\n            }\\n            else {\\n                if (this._start != null) {\\n                    throwMdDuplicatedSidenavError(\\'start\\');\\n                }\\n                this._start = sidenav;\\n            }\\n        }\\n        this._right = this._left = null;\\n        // Detect if we\\'re LTR or RTL.\\n        if (this._dir == null || this._dir.value == \\'ltr\\') {\\n            this._left = this._start;\\n            this._right = this._end;\\n        }\\n        else {\\n            this._left = this._end;\\n            this._right = this._start;\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._onBackdropClicked = function () {\\n        this.backdropClick.emit();\\n        this._closeModalSidenav();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._closeModalSidenav = function () {\\n        // Close all open sidenav\\'s where closing is not disabled and the mode is not `side`.\\n        [this._start, this._end]\\n            .filter(function (sidenav) { return sidenav && !sidenav.disableClose && sidenav.mode !== \\'side\\'; })\\n            .forEach(function (sidenav) { return ((sidenav)).close(); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._isShowingBackdrop = function () {\\n        return (this._isSidenavOpen(this._start) && ((this._start)).mode != \\'side\\')\\n            || (this._isSidenavOpen(this._end) && ((this._end)).mode != \\'side\\');\\n    };\\n    /**\\n     * @param {?} side\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._isSidenavOpen = function (side) {\\n        return side != null && side.opened;\\n    };\\n    /**\\n     * Return the width of the sidenav, if it\\'s in the proper mode and opened.\\n     * This may relayout the view, so do not call this often.\\n     * @param {?} sidenav\\n     * @param {?} mode\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getSidenavEffectiveWidth = function (sidenav, mode) {\\n        return (this._isSidenavOpen(sidenav) && sidenav.mode == mode) ? sidenav._width : 0;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getMarginLeft = function () {\\n        return this._left ? this._getSidenavEffectiveWidth(this._left, \\'side\\') : 0;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getMarginRight = function () {\\n        return this._right ? this._getSidenavEffectiveWidth(this._right, \\'side\\') : 0;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getPositionLeft = function () {\\n        return this._left ? this._getSidenavEffectiveWidth(this._left, \\'push\\') : 0;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getPositionRight = function () {\\n        return this._right ? this._getSidenavEffectiveWidth(this._right, \\'push\\') : 0;\\n    };\\n    /**\\n     * Returns the horizontal offset for the content area.  There should never be a value for both\\n     * left and right, so by subtracting the right value from the left value, we should always get\\n     * the appropriate offset.\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getPositionOffset = function () {\\n        return this._getPositionLeft() - this._getPositionRight();\\n    };\\n    /**\\n     * This is using [ngStyle] rather than separate [style...] properties because [style.transform]\\n     * doesn\\'t seem to work right now.\\n     * @return {?}\\n     */\\n    MdSidenavContainer.prototype._getStyles = function () {\\n        return {\\n            marginLeft: this._getMarginLeft() + \"px\",\\n            marginRight: this._getMarginRight() + \"px\",\\n            transform: \"translate3d(\" + this._getPositionOffset() + \"px, 0, 0)\"\\n        };\\n    };\\n    return MdSidenavContainer;\\n}());\\nMdSidenavContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-sidenav-container, mat-sidenav-container\\',\\n                // Do not use ChangeDetectionStrategy.OnPush. It does not work for this component because\\n                // technically it is a sibling of MdSidenav (on the content tree) and isn\\'t updated when MdSidenav\\n                // changes its state.\\n                template: \"<div class=\\\\\"mat-sidenav-backdrop\\\\\" (click)=\\\\\"_onBackdropClicked()\\\\\" [class.mat-sidenav-shown]=\\\\\"_isShowingBackdrop()\\\\\"></div><ng-content select=\\\\\"md-sidenav, mat-sidenav\\\\\"></ng-content><div class=\\\\\"mat-sidenav-content\\\\\" [ngStyle]=\\\\\"_getStyles()\\\\\" cdk-scrollable><ng-content></ng-content></div>\",\\n                styles: [\".mat-sidenav-container{position:relative;transform:translate3d(0,0,0);box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-sidenav-container[fullscreen]{position:absolute;top:0;left:0;right:0;bottom:0}.mat-sidenav-container[fullscreen].mat-sidenav-opened{overflow:hidden}.mat-sidenav-backdrop{position:absolute;top:0;left:0;right:0;bottom:0;display:block;z-index:2;visibility:hidden}.mat-sidenav-backdrop.mat-sidenav-shown{visibility:visible}@media screen and (-ms-high-contrast:active){.mat-sidenav-backdrop{opacity:.5}}.mat-sidenav-content{position:relative;transform:translate3d(0,0,0);display:block;height:100%;overflow:auto}.mat-sidenav{position:relative;transform:translate3d(0,0,0);display:block;position:absolute;top:0;bottom:0;z-index:3;min-width:5vw;outline:0;box-sizing:border-box;height:100%;overflow-y:auto;transform:translate3d(-100%,0,0)}.mat-sidenav.mat-sidenav-closed{visibility:hidden}.mat-sidenav.mat-sidenav-opened,.mat-sidenav.mat-sidenav-opening{transform:translate3d(0,0,0)}.mat-sidenav.mat-sidenav-side{z-index:1}.mat-sidenav.mat-sidenav-end{right:0;transform:translate3d(100%,0,0)}.mat-sidenav.mat-sidenav-end.mat-sidenav-closed{visibility:hidden}.mat-sidenav.mat-sidenav-end.mat-sidenav-opened,.mat-sidenav.mat-sidenav-end.mat-sidenav-opening{transform:translate3d(0,0,0)}[dir=rtl] .mat-sidenav{transform:translate3d(100%,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-closed{visibility:hidden}[dir=rtl] .mat-sidenav.mat-sidenav-opened,[dir=rtl] .mat-sidenav.mat-sidenav-opening{transform:translate3d(0,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-end{left:0;right:auto;transform:translate3d(-100%,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-closed{visibility:hidden}[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-opened,[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-opening{transform:translate3d(0,0,0)}.mat-sidenav.mat-sidenav-opened:not(.mat-sidenav-side),.mat-sidenav.mat-sidenav-opening:not(.mat-sidenav-side){box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)} .mat-sidenav-transition .mat-sidenav{transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-sidenav-transition .mat-sidenav-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-sidenav-transition .mat-sidenav-backdrop.mat-sidenav-shown{transition:background-color .4s cubic-bezier(.25,.8,.25,1)}\"],\\n                host: {\\n                    \\'class\\': \\'mat-sidenav-container\\',\\n                    \\'[class.mat-sidenav-transition]\\': \\'_enableTransitions\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSidenavContainer.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\nMdSidenavContainer.propDecorators = {\\n    \\'_sidenavs\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdSidenav,] },],\\n    \\'backdropClick\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdSidenavModule = /*@__PURE__*/(function () {\\n    function MdSidenavModule() {\\n    }\\n    return MdSidenavModule;\\n}());\\nMdSidenavModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"], MdCommonModule, __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"a\" /* A11yModule */], OverlayModule],\\n                exports: [MdSidenavContainer, MdSidenav, MdCommonModule],\\n                declarations: [MdSidenavContainer, MdSidenav],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSidenavModule.ctorParameters = function () { return []; };\\nvar MdListDivider = /*@__PURE__*/(function () {\\n    function MdListDivider() {\\n    }\\n    return MdListDivider;\\n}());\\nMdListDivider.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-divider, mat-divider\\',\\n                host: {\\n                    \\'role\\': \\'separator\\',\\n                    \\'aria-orientation\\': \\'horizontal\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListDivider.ctorParameters = function () { return []; };\\nvar MdList = /*@__PURE__*/(function () {\\n    function MdList() {\\n        this._disableRipple = false;\\n    }\\n    Object.defineProperty(MdList.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect should be disabled on the list-items or not.\\n         * This flag only has an effect for `md-nav-list` components.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return MdList;\\n}());\\nMdList.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-list, mat-list, md-nav-list, mat-nav-list\\',\\n                host: { \\'role\\': \\'list\\' },\\n                template: \\'<ng-content></ng-content>\\',\\n                styles: [\".mat-subheader{display:block;box-sizing:border-box;padding:16px;margin:0}.mat-list,.mat-nav-list{padding-top:8px;display:block}.mat-list .mat-subheader,.mat-nav-list .mat-subheader{height:48px}.mat-list .mat-subheader:first-child,.mat-nav-list .mat-subheader:first-child{margin-top:-8px}.mat-list .mat-list-item,.mat-nav-list .mat-list-item{display:block}.mat-list .mat-list-item .mat-list-item-content,.mat-nav-list .mat-list-item .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;height:48px;padding:0 16px;position:relative}.mat-list .mat-list-item .mat-list-item-ripple,.mat-nav-list .mat-list-item .mat-list-item-ripple{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none}.mat-list .mat-list-item.mat-list-item-avatar .mat-list-item-content,.mat-nav-list .mat-list-item.mat-list-item-avatar .mat-list-item-content{height:56px}.mat-list .mat-list-item.mat-2-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-2-line .mat-list-item-content{height:72px}.mat-list .mat-list-item.mat-3-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-3-line .mat-list-item-content{height:88px}.mat-list .mat-list-item.mat-multi-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-multi-line .mat-list-item-content{height:100%;padding:8px 16px}.mat-list .mat-list-item .mat-list-text,.mat-nav-list .mat-list-item .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0 16px}.mat-list .mat-list-item .mat-list-text>*,.mat-nav-list .mat-list-item .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list .mat-list-item .mat-list-text:empty,.mat-nav-list .mat-list-item .mat-list-text:empty{display:none}.mat-list .mat-list-item .mat-list-text:nth-child(2),.mat-nav-list .mat-list-item .mat-list-text:nth-child(2){padding:0}.mat-list .mat-list-item .mat-list-avatar,.mat-nav-list .mat-list-item .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%}.mat-list .mat-list-item .mat-list-icon,.mat-nav-list .mat-list-item .mat-list-icon{width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list[dense],.mat-nav-list[dense]{padding-top:4px;display:block}.mat-list[dense] .mat-subheader,.mat-nav-list[dense] .mat-subheader{height:40px}.mat-list[dense] .mat-subheader:first-child,.mat-nav-list[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list[dense] .mat-list-item,.mat-nav-list[dense] .mat-list-item{display:block}.mat-list[dense] .mat-list-item .mat-list-item-content,.mat-nav-list[dense] .mat-list-item .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;height:40px;padding:0 16px;position:relative}.mat-list[dense] .mat-list-item .mat-list-item-ripple,.mat-nav-list[dense] .mat-list-item .mat-list-item-ripple{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none}.mat-list[dense] .mat-list-item.mat-list-item-avatar .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-list-item-avatar .mat-list-item-content{height:48px}.mat-list[dense] .mat-list-item.mat-2-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-2-line .mat-list-item-content{height:60px}.mat-list[dense] .mat-list-item.mat-3-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-3-line .mat-list-item-content{height:76px}.mat-list[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-multi-line .mat-list-item-content{height:100%;padding:8px 16px}.mat-list[dense] .mat-list-item .mat-list-text,.mat-nav-list[dense] .mat-list-item .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0 16px}.mat-list[dense] .mat-list-item .mat-list-text>*,.mat-nav-list[dense] .mat-list-item .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list[dense] .mat-list-item .mat-list-text:empty,.mat-nav-list[dense] .mat-list-item .mat-list-text:empty{display:none}.mat-list[dense] .mat-list-item .mat-list-text:nth-child(2),.mat-nav-list[dense] .mat-list-item .mat-list-text:nth-child(2){padding:0}.mat-list[dense] .mat-list-item .mat-list-avatar,.mat-nav-list[dense] .mat-list-item .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%}.mat-list[dense] .mat-list-item .mat-list-icon,.mat-nav-list[dense] .mat-list-item .mat-list-icon{width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-divider{display:block;border-top-style:solid;border-top-width:1px;margin:0}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item-content{cursor:pointer}.mat-nav-list .mat-list-item-content.mat-list-item-focus,.mat-nav-list .mat-list-item-content:hover{outline:0}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdList.ctorParameters = function () { return []; };\\nMdList.propDecorators = {\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdListCssMatStyler = /*@__PURE__*/(function () {\\n    function MdListCssMatStyler() {\\n    }\\n    return MdListCssMatStyler;\\n}());\\nMdListCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-list, mat-list\\',\\n                host: { \\'class\\': \\'mat-list\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdNavListCssMatStyler = /*@__PURE__*/(function () {\\n    function MdNavListCssMatStyler() {\\n    }\\n    return MdNavListCssMatStyler;\\n}());\\nMdNavListCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-nav-list, mat-nav-list\\',\\n                host: { \\'class\\': \\'mat-nav-list\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdNavListCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdDividerCssMatStyler = /*@__PURE__*/(function () {\\n    function MdDividerCssMatStyler() {\\n    }\\n    return MdDividerCssMatStyler;\\n}());\\nMdDividerCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-divider, mat-divider\\',\\n                host: { \\'class\\': \\'mat-divider\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDividerCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdListAvatarCssMatStyler = /*@__PURE__*/(function () {\\n    function MdListAvatarCssMatStyler() {\\n    }\\n    return MdListAvatarCssMatStyler;\\n}());\\nMdListAvatarCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-list-avatar], [mat-list-avatar], [mdListAvatar], [matListAvatar]\\',\\n                host: { \\'class\\': \\'mat-list-avatar\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListAvatarCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdListIconCssMatStyler = /*@__PURE__*/(function () {\\n    function MdListIconCssMatStyler() {\\n    }\\n    return MdListIconCssMatStyler;\\n}());\\nMdListIconCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-list-icon], [mat-list-icon], [mdListIcon], [matListIcon]\\',\\n                host: { \\'class\\': \\'mat-list-icon\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListIconCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdListSubheaderCssMatStyler = /*@__PURE__*/(function () {\\n    function MdListSubheaderCssMatStyler() {\\n    }\\n    return MdListSubheaderCssMatStyler;\\n}());\\nMdListSubheaderCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-subheader], [mat-subheader]\\',\\n                host: { \\'class\\': \\'mat-subheader\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListSubheaderCssMatStyler.ctorParameters = function () { return []; };\\nvar MdListItem = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _element\\n     * @param {?} _list\\n     * @param {?} navList\\n     */\\n    function MdListItem(_renderer, _element, _list, navList) {\\n        this._renderer = _renderer;\\n        this._element = _element;\\n        this._list = _list;\\n        this._disableRipple = false;\\n        this._isNavList = false;\\n        this._isNavList = !!navList;\\n    }\\n    Object.defineProperty(MdListItem.prototype, \"disableRipple\", {\\n        /**\\n         * Whether the ripple effect on click should be disabled. This applies only to list items that are\\n         * part of a nav list. The value of `disableRipple` on the `md-nav-list` overrides this flag.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdListItem.prototype, \"_hasAvatar\", {\\n        /**\\n         * @param {?} avatar\\n         * @return {?}\\n         */\\n        set: function (avatar) {\\n            if (avatar != null) {\\n                this._renderer.addClass(this._element.nativeElement, \\'mat-list-item-avatar\\');\\n            }\\n            else {\\n                this._renderer.removeClass(this._element.nativeElement, \\'mat-list-item-avatar\\');\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdListItem.prototype.ngAfterContentInit = function () {\\n        this._lineSetter = new MdLineSetter(this._lines, this._renderer, this._element);\\n    };\\n    /**\\n     * Whether this list item should show a ripple effect when clicked.\\n     * @return {?}\\n     */\\n    MdListItem.prototype.isRippleEnabled = function () {\\n        return !this.disableRipple && this._isNavList && !this._list.disableRipple;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdListItem.prototype._handleFocus = function () {\\n        this._renderer.addClass(this._element.nativeElement, \\'mat-list-item-focus\\');\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdListItem.prototype._handleBlur = function () {\\n        this._renderer.removeClass(this._element.nativeElement, \\'mat-list-item-focus\\');\\n    };\\n    /**\\n     * Retrieves the DOM element of the component host.\\n     * @return {?}\\n     */\\n    MdListItem.prototype._getHostElement = function () {\\n        return this._element.nativeElement;\\n    };\\n    return MdListItem;\\n}());\\nMdListItem.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-list-item, mat-list-item, a[md-list-item], a[mat-list-item]\\',\\n                host: {\\n                    \\'role\\': \\'listitem\\',\\n                    \\'class\\': \\'mat-list-item\\',\\n                    \\'(focus)\\': \\'_handleFocus()\\',\\n                    \\'(blur)\\': \\'_handleBlur()\\',\\n                },\\n                template: \"<div class=\\\\\"mat-list-item-content\\\\\"><div class=\\\\\"mat-list-item-ripple\\\\\" md-ripple [mdRippleTrigger]=\\\\\"_getHostElement()\\\\\" [mdRippleDisabled]=\\\\\"!isRippleEnabled()\\\\\"></div><ng-content select=\\\\\"[md-list-avatar],[md-list-icon], [mat-list-avatar], [mat-list-icon]\\\\\"></ng-content><div class=\\\\\"mat-list-text\\\\\"><ng-content select=\\\\\"[md-line], [mat-line]\\\\\"></ng-content></div><ng-content></ng-content></div>\",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListItem.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: MdList, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: MdNavListCssMatStyler, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdListItem.propDecorators = {\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_lines\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdLine,] },],\\n    \\'_hasAvatar\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [MdListAvatarCssMatStyler,] },],\\n};\\nvar MdListModule = /*@__PURE__*/(function () {\\n    function MdListModule() {\\n    }\\n    return MdListModule;\\n}());\\nMdListModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdLineModule, MdRippleModule, MdCommonModule],\\n                exports: [\\n                    MdList,\\n                    MdListItem,\\n                    MdListDivider,\\n                    MdListAvatarCssMatStyler,\\n                    MdLineModule,\\n                    MdCommonModule,\\n                    MdListIconCssMatStyler,\\n                    MdListCssMatStyler,\\n                    MdNavListCssMatStyler,\\n                    MdDividerCssMatStyler,\\n                    MdListSubheaderCssMatStyler,\\n                ],\\n                declarations: [\\n                    MdList,\\n                    MdListItem,\\n                    MdListDivider,\\n                    MdListAvatarCssMatStyler,\\n                    MdListIconCssMatStyler,\\n                    MdListCssMatStyler,\\n                    MdNavListCssMatStyler,\\n                    MdDividerCssMatStyler,\\n                    MdListSubheaderCssMatStyler,\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdListModule.ctorParameters = function () { return []; };\\n/**\\n * Converts values into strings. Falsy values become empty strings.\\n * \\\\@docs-private\\n * @param {?} value\\n * @return {?}\\n */\\nfunction coerceToString(value) {\\n    return \"\" + (value || \\'\\');\\n}\\n/**\\n * Converts a value that might be a string into a number.\\n * \\\\@docs-private\\n * @param {?} value\\n * @return {?}\\n */\\nfunction coerceToNumber(value) {\\n    return typeof value === \\'string\\' ? parseInt(value, 10) : value;\\n}\\nvar MdGridTile = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _element\\n     */\\n    function MdGridTile(_renderer, _element) {\\n        this._renderer = _renderer;\\n        this._element = _element;\\n        this._rowspan = 1;\\n        this._colspan = 1;\\n    }\\n    Object.defineProperty(MdGridTile.prototype, \"rowspan\", {\\n        /**\\n         * Amount of rows that the grid tile takes up.\\n         * @return {?}\\n         */\\n        get: function () { return this._rowspan; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._rowspan = coerceToNumber(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdGridTile.prototype, \"colspan\", {\\n        /**\\n         * Amount of columns that the grid tile takes up.\\n         * @return {?}\\n         */\\n        get: function () { return this._colspan; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._colspan = coerceToNumber(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the style of the grid-tile element.  Needs to be set manually to avoid\\n     * \"Changed after checked\" errors that would occur with HostBinding.\\n     * @param {?} property\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdGridTile.prototype._setStyle = function (property, value) {\\n        this._renderer.setStyle(this._element.nativeElement, property, value);\\n    };\\n    return MdGridTile;\\n}());\\nMdGridTile.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-grid-tile, mat-grid-tile\\',\\n                host: {\\n                    \\'role\\': \\'listitem\\',\\n                    \\'class\\': \\'mat-grid-tile\\',\\n                },\\n                template: \"<figure class=\\\\\"mat-figure\\\\\"><ng-content></ng-content></figure>\",\\n                styles: [\".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{display:flex;position:absolute;align-items:center;justify-content:center;height:100%;top:0;right:0;bottom:0;left:0;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridTile.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdGridTile.propDecorators = {\\n    \\'rowspan\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'colspan\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdGridTileText = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _element\\n     */\\n    function MdGridTileText(_renderer, _element) {\\n        this._renderer = _renderer;\\n        this._element = _element;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdGridTileText.prototype.ngAfterContentInit = function () {\\n        this._lineSetter = new MdLineSetter(this._lines, this._renderer, this._element);\\n    };\\n    return MdGridTileText;\\n}());\\nMdGridTileText.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-grid-tile-header, mat-grid-tile-header, md-grid-tile-footer, mat-grid-tile-footer\\',\\n                template: \"<ng-content select=\\\\\"[md-grid-avatar], [mat-grid-avatar]\\\\\"></ng-content><div class=\\\\\"mat-grid-list-text\\\\\"><ng-content select=\\\\\"[md-line], [mat-line]\\\\\"></ng-content></div><ng-content></ng-content>\"\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridTileText.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdGridTileText.propDecorators = {\\n    \\'_lines\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdLine,] },],\\n};\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdGridAvatarCssMatStyler = /*@__PURE__*/(function () {\\n    function MdGridAvatarCssMatStyler() {\\n    }\\n    return MdGridAvatarCssMatStyler;\\n}());\\nMdGridAvatarCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-grid-avatar], [mat-grid-avatar], [mdGridAvatar], [matGridAvatar]\\',\\n                host: { \\'class\\': \\'mat-grid-avatar\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridAvatarCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdGridTileHeaderCssMatStyler = /*@__PURE__*/(function () {\\n    function MdGridTileHeaderCssMatStyler() {\\n    }\\n    return MdGridTileHeaderCssMatStyler;\\n}());\\nMdGridTileHeaderCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-grid-tile-header, mat-grid-tile-header\\',\\n                host: { \\'class\\': \\'mat-grid-tile-header\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridTileHeaderCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdGridTileFooterCssMatStyler = /*@__PURE__*/(function () {\\n    function MdGridTileFooterCssMatStyler() {\\n    }\\n    return MdGridTileFooterCssMatStyler;\\n}());\\nMdGridTileFooterCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-grid-tile-footer, mat-grid-tile-footer\\',\\n                host: { \\'class\\': \\'mat-grid-tile-footer\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridTileFooterCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * Class for determining, from a list of tiles, the (row, col) position of each of those tiles\\n * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)\\n * because the tiles can have a rowspan.\\n *\\n * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid\\n * large enough to accommodate it so that the tiles still render in the same order in which they\\n * are given.\\n *\\n * The basis of the algorithm is the use of an array to track the already placed tiles. Each\\n * element of the array corresponds to a column, and the value indicates how many cells in that\\n * column are already occupied; zero indicates an empty cell. Moving \"down\" to the next row\\n * decrements each value in the tracking array (indicating that the column is one cell closer to\\n * being free).\\n *\\n * \\\\@docs-private\\n */\\nvar TileCoordinator = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} numColumns\\n     * @param {?} tiles\\n     */\\n    function TileCoordinator(numColumns, tiles) {\\n        var _this = this;\\n        /**\\n         * Index at which the search for the next gap will start.\\n         */\\n        this.columnIndex = 0;\\n        /**\\n         * The current row index.\\n         */\\n        this.rowIndex = 0;\\n        this.tracker = new Array(numColumns);\\n        this.tracker.fill(0, 0, this.tracker.length);\\n        this.positions = tiles.map(function (tile) { return _this._trackTile(tile); });\\n    }\\n    Object.defineProperty(TileCoordinator.prototype, \"rowCount\", {\\n        /**\\n         * Gets the total number of rows occupied by tiles\\n         * @return {?}\\n         */\\n        get: function () { return this.rowIndex + 1; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(TileCoordinator.prototype, \"rowspan\", {\\n        /**\\n         * Gets the total span of rows occupied by tiles.\\n         * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ lastRowMax = Math.max.apply(Math, this.tracker);\\n            // if any of the tiles has a rowspan that pushes it beyond the total row count,\\n            // add the difference to the rowcount\\n            return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Calculates the row and col position of a tile.\\n     * @param {?} tile\\n     * @return {?}\\n     */\\n    TileCoordinator.prototype._trackTile = function (tile) {\\n        // Find a gap large enough for this tile.\\n        var /** @type {?} */ gapStartIndex = this._findMatchingGap(tile.colspan);\\n        // Place tile in the resulting gap.\\n        this._markTilePosition(gapStartIndex, tile);\\n        // The next time we look for a gap, the search will start at columnIndex, which should be\\n        // immediately after the tile that has just been placed.\\n        this.columnIndex = gapStartIndex + tile.colspan;\\n        return new TilePosition(this.rowIndex, gapStartIndex);\\n    };\\n    /**\\n     * Finds the next available space large enough to fit the tile.\\n     * @param {?} tileCols\\n     * @return {?}\\n     */\\n    TileCoordinator.prototype._findMatchingGap = function (tileCols) {\\n        if (tileCols > this.tracker.length) {\\n            throw Error(\"md-grid-list: tile with colspan \" + tileCols + \" is wider than \" +\\n                (\"grid with cols=\\\\\"\" + this.tracker.length + \"\\\\\".\"));\\n        }\\n        // Start index is inclusive, end index is exclusive.\\n        var /** @type {?} */ gapStartIndex = -1;\\n        var /** @type {?} */ gapEndIndex = -1;\\n        // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.\\n        do {\\n            // If we\\'ve reached the end of the row, go to the next row.\\n            if (this.columnIndex + tileCols > this.tracker.length) {\\n                this._nextRow();\\n                continue;\\n            }\\n            gapStartIndex = this.tracker.indexOf(0, this.columnIndex);\\n            // If there are no more empty spaces in this row at all, move on to the next row.\\n            if (gapStartIndex == -1) {\\n                this._nextRow();\\n                continue;\\n            }\\n            gapEndIndex = this._findGapEndIndex(gapStartIndex);\\n            // If a gap large enough isn\\'t found, we want to start looking immediately after the current\\n            // gap on the next iteration.\\n            this.columnIndex = gapStartIndex + 1;\\n            // Continue iterating until we find a gap wide enough for this tile.\\n        } while (gapEndIndex - gapStartIndex < tileCols);\\n        return gapStartIndex;\\n    };\\n    /**\\n     * Move \"down\" to the next row.\\n     * @return {?}\\n     */\\n    TileCoordinator.prototype._nextRow = function () {\\n        this.columnIndex = 0;\\n        this.rowIndex++;\\n        // Decrement all spaces by one to reflect moving down one row.\\n        for (var /** @type {?} */ i = 0; i < this.tracker.length; i++) {\\n            this.tracker[i] = Math.max(0, this.tracker[i] - 1);\\n        }\\n    };\\n    /**\\n     * Finds the end index (exclusive) of a gap given the index from which to start looking.\\n     * The gap ends when a non-zero value is found.\\n     * @param {?} gapStartIndex\\n     * @return {?}\\n     */\\n    TileCoordinator.prototype._findGapEndIndex = function (gapStartIndex) {\\n        for (var /** @type {?} */ i = gapStartIndex + 1; i < this.tracker.length; i++) {\\n            if (this.tracker[i] != 0) {\\n                return i;\\n            }\\n        }\\n        // The gap ends with the end of the row.\\n        return this.tracker.length;\\n    };\\n    /**\\n     * Update the tile tracker to account for the given tile in the given space.\\n     * @param {?} start\\n     * @param {?} tile\\n     * @return {?}\\n     */\\n    TileCoordinator.prototype._markTilePosition = function (start, tile) {\\n        for (var /** @type {?} */ i = 0; i < tile.colspan; i++) {\\n            this.tracker[start + i] = tile.rowspan;\\n        }\\n    };\\n    return TileCoordinator;\\n}());\\n/**\\n * Simple data structure for tile position (row, col).\\n * \\\\@docs-private\\n */\\nvar TilePosition = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} row\\n     * @param {?} col\\n     */\\n    function TilePosition(row, col) {\\n        this.row = row;\\n        this.col = col;\\n    }\\n    return TilePosition;\\n}());\\n/**\\n * Sets the style properties for an individual tile, given the position calculated by the\\n * Tile Coordinator.\\n * \\\\@docs-private\\n * @abstract\\n */\\nvar TileStyler = /*@__PURE__*/(function () {\\n    function TileStyler() {\\n        this._rows = 0;\\n        this._rowspan = 0;\\n    }\\n    /**\\n     * Adds grid-list layout info once it is available. Cannot be processed in the constructor\\n     * because these properties haven\\'t been calculated by that point.\\n     *\\n     * @param {?} gutterSize Size of the grid\\'s gutter.\\n     * @param {?} tracker Instance of the TileCoordinator.\\n     * @param {?} cols Amount of columns in the grid.\\n     * @param {?} direction Layout direction of the grid.\\n     * @return {?}\\n     */\\n    TileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {\\n        this._gutterSize = normalizeUnits(gutterSize);\\n        this._rows = tracker.rowCount;\\n        this._rowspan = tracker.rowspan;\\n        this._cols = cols;\\n        this._direction = direction;\\n    };\\n    /**\\n     * Computes the amount of space a single 1x1 tile would take up (width or height).\\n     * Used as a basis for other calculations.\\n     * @param {?} sizePercent Percent of the total grid-list space that one 1x1 tile would take up.\\n     * @param {?} gutterFraction Fraction of the gutter size taken up by one 1x1 tile.\\n     * @return {?} The size of a 1x1 tile as an expression that can be evaluated via CSS calc().\\n     */\\n    TileStyler.prototype.getBaseTileSize = function (sizePercent, gutterFraction) {\\n        // Take the base size percent (as would be if evenly dividing the size between cells),\\n        // and then subtracting the size of one gutter. However, since there are no gutters on the\\n        // edges, each tile only uses a fraction (gutterShare = numGutters / numCells) of the gutter\\n        // size. (Imagine having one gutter per tile, and then breaking up the extra gutter on the\\n        // edge evenly among the cells).\\n        return \"(\" + sizePercent + \"% - ( \" + this._gutterSize + \" * \" + gutterFraction + \" ))\";\\n    };\\n    /**\\n     * Gets The horizontal or vertical position of a tile, e.g., the \\'top\\' or \\'left\\' property value.\\n     * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).\\n     * @param {?} offset Number of tiles that have already been rendered in the row/column.\\n     * @return {?} Position of the tile as a CSS calc() expression.\\n     */\\n    TileStyler.prototype.getTilePosition = function (baseSize, offset) {\\n        // The position comes the size of a 1x1 tile plus gutter for each previous tile in the\\n        // row/column (offset).\\n        return calc(\"(\" + baseSize + \" + \" + this._gutterSize + \") * \" + offset);\\n    };\\n    /**\\n     * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.\\n     * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).\\n     * @param {?} span The tile\\'s rowspan or colspan.\\n     * @return {?} Size of the tile as a CSS calc() expression.\\n     */\\n    TileStyler.prototype.getTileSize = function (baseSize, span) {\\n        return \"(\" + baseSize + \" * \" + span + \") + (\" + (span - 1) + \" * \" + this._gutterSize + \")\";\\n    };\\n    /**\\n     * Sets the style properties to be applied to a tile for the given row and column index.\\n     * @param {?} tile Tile to which to apply the styling.\\n     * @param {?} rowIndex Index of the tile\\'s row.\\n     * @param {?} colIndex Index of the tile\\'s column.\\n     * @return {?}\\n     */\\n    TileStyler.prototype.setStyle = function (tile, rowIndex, colIndex) {\\n        // Percent of the available horizontal space that one column takes up.\\n        var /** @type {?} */ percentWidthPerTile = 100 / this._cols;\\n        // Fraction of the vertical gutter size that each column takes up.\\n        // For example, if there are 5 columns, each column uses 4/5 = 0.8 times the gutter width.\\n        var /** @type {?} */ gutterWidthFractionPerTile = (this._cols - 1) / this._cols;\\n        this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);\\n        this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);\\n    };\\n    /**\\n     * Sets the horizontal placement of the tile in the list.\\n     * @param {?} tile\\n     * @param {?} colIndex\\n     * @param {?} percentWidth\\n     * @param {?} gutterWidth\\n     * @return {?}\\n     */\\n    TileStyler.prototype.setColStyles = function (tile, colIndex, percentWidth, gutterWidth) {\\n        // Base horizontal size of a column.\\n        var /** @type {?} */ baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);\\n        // The width and horizontal position of each tile is always calculated the same way, but the\\n        // height and vertical position depends on the rowMode.\\n        var /** @type {?} */ side = this._direction === \\'ltr\\' ? \\'left\\' : \\'right\\';\\n        tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));\\n        tile._setStyle(\\'width\\', calc(this.getTileSize(baseTileWidth, tile.colspan)));\\n    };\\n    /**\\n     * Calculates the total size taken up by gutters across one axis of a list.\\n     * @return {?}\\n     */\\n    TileStyler.prototype.getGutterSpan = function () {\\n        return this._gutterSize + \" * (\" + this._rowspan + \" - 1)\";\\n    };\\n    /**\\n     * Calculates the total size taken up by tiles across one axis of a list.\\n     * @param {?} tileHeight Height of the tile.\\n     * @return {?}\\n     */\\n    TileStyler.prototype.getTileSpan = function (tileHeight) {\\n        return this._rowspan + \" * \" + this.getTileSize(tileHeight, 1);\\n    };\\n    /**\\n     * Sets the vertical placement of the tile in the list.\\n     * This method will be implemented by each type of TileStyler.\\n     * \\\\@docs-private\\n     * @abstract\\n     * @param {?} tile\\n     * @param {?} rowIndex\\n     * @param {?} percentWidth\\n     * @param {?} gutterWidth\\n     * @return {?}\\n     */\\n    TileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) { };\\n    /**\\n     * Calculates the computed height and returns the correct style property to set.\\n     * This method can be implemented by each type of TileStyler.\\n     * \\\\@docs-private\\n     * @return {?}\\n     */\\n    TileStyler.prototype.getComputedHeight = function () { return null; };\\n    return TileStyler;\\n}());\\n/**\\n * This type of styler is instantiated when the user passes in a fixed row height.\\n * Example <md-grid-list cols=\"3\" rowHeight=\"100px\">\\n * \\\\@docs-private\\n */\\nvar FixedTileStyler = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FixedTileStyler, _super);\\n    /**\\n     * @param {?} fixedRowHeight\\n     */\\n    function FixedTileStyler(fixedRowHeight) {\\n        var _this = _super.call(this) || this;\\n        _this.fixedRowHeight = fixedRowHeight;\\n        return _this;\\n    }\\n    /**\\n     * @param {?} gutterSize\\n     * @param {?} tracker\\n     * @param {?} cols\\n     * @param {?} direction\\n     * @return {?}\\n     */\\n    FixedTileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {\\n        _super.prototype.init.call(this, gutterSize, tracker, cols, direction);\\n        this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);\\n    };\\n    /**\\n     * @param {?} tile\\n     * @param {?} rowIndex\\n     * @return {?}\\n     */\\n    FixedTileStyler.prototype.setRowStyles = function (tile, rowIndex) {\\n        tile._setStyle(\\'top\\', this.getTilePosition(this.fixedRowHeight, rowIndex));\\n        tile._setStyle(\\'height\\', calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    FixedTileStyler.prototype.getComputedHeight = function () {\\n        return [\\n            \\'height\\', calc(this.getTileSpan(this.fixedRowHeight) + \" + \" + this.getGutterSpan())\\n        ];\\n    };\\n    return FixedTileStyler;\\n}(TileStyler));\\n/**\\n * This type of styler is instantiated when the user passes in a width:height ratio\\n * for the row height.  Example <md-grid-list cols=\"3\" rowHeight=\"3:1\">\\n * \\\\@docs-private\\n */\\nvar RatioTileStyler = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](RatioTileStyler, _super);\\n    /**\\n     * @param {?} value\\n     */\\n    function RatioTileStyler(value) {\\n        var _this = _super.call(this) || this;\\n        _this._parseRatio(value);\\n        return _this;\\n    }\\n    /**\\n     * @param {?} tile\\n     * @param {?} rowIndex\\n     * @param {?} percentWidth\\n     * @param {?} gutterWidth\\n     * @return {?}\\n     */\\n    RatioTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {\\n        var /** @type {?} */ percentHeightPerTile = percentWidth / this.rowHeightRatio;\\n        this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);\\n        // Use paddingTop and marginTop to maintain the given aspect ratio, as\\n        // a percentage-based value for these properties is applied versus the *width* of the\\n        // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties\\n        tile._setStyle(\\'marginTop\\', this.getTilePosition(this.baseTileHeight, rowIndex));\\n        tile._setStyle(\\'paddingTop\\', calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    RatioTileStyler.prototype.getComputedHeight = function () {\\n        return [\\n            \\'paddingBottom\\', calc(this.getTileSpan(this.baseTileHeight) + \" + \" + this.getGutterSpan())\\n        ];\\n    };\\n    /**\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    RatioTileStyler.prototype._parseRatio = function (value) {\\n        var /** @type {?} */ ratioParts = value.split(\\':\\');\\n        if (ratioParts.length !== 2) {\\n            throw Error(\"md-grid-list: invalid ratio given for row-height: \\\\\"\" + value + \"\\\\\"\");\\n        }\\n        this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);\\n    };\\n    return RatioTileStyler;\\n}(TileStyler));\\n/**\\n * This type of styler is instantiated when the user selects a \"fit\" row height mode.\\n * In other words, the row height will reflect the total height of the container divided\\n * by the number of rows.  Example <md-grid-list cols=\"3\" rowHeight=\"fit\">\\n *\\n * \\\\@docs-private\\n */\\nvar FitTileStyler = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FitTileStyler, _super);\\n    function FitTileStyler() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    /**\\n     * @param {?} tile\\n     * @param {?} rowIndex\\n     * @return {?}\\n     */\\n    FitTileStyler.prototype.setRowStyles = function (tile, rowIndex) {\\n        // Percent of the available vertical space that one row takes up.\\n        var /** @type {?} */ percentHeightPerTile = 100 / this._rowspan;\\n        // Fraction of the horizontal gutter size that each column takes up.\\n        var /** @type {?} */ gutterHeightPerTile = (this._rows - 1) / this._rows;\\n        // Base vertical size of a column.\\n        var /** @type {?} */ baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);\\n        tile._setStyle(\\'top\\', this.getTilePosition(baseTileHeight, rowIndex));\\n        tile._setStyle(\\'height\\', calc(this.getTileSize(baseTileHeight, tile.rowspan)));\\n    };\\n    return FitTileStyler;\\n}(TileStyler));\\n/**\\n * Wraps a CSS string in a calc function\\n * @param {?} exp\\n * @return {?}\\n */\\nfunction calc(exp) { return \"calc(\" + exp + \")\"; }\\n/**\\n * Appends pixels to a CSS string if no units are given.\\n * @param {?} value\\n * @return {?}\\n */\\nfunction normalizeUnits(value) {\\n    return (value.match(/px|em|rem/)) ? value : value + \\'px\\';\\n}\\n// TODO(kara): Conditional (responsive) column count / row size.\\n// TODO(kara): Re-layout on window resize / media change (debounced).\\n// TODO(kara): gridTileHeader and gridTileFooter.\\nvar MD_FIT_MODE = \\'fit\\';\\nvar MdGridList = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _element\\n     * @param {?} _dir\\n     */\\n    function MdGridList(_renderer, _element, _dir) {\\n        this._renderer = _renderer;\\n        this._element = _element;\\n        this._dir = _dir;\\n        /**\\n         * The amount of space between tiles. This will be something like \\'5px\\' or \\'2em\\'.\\n         */\\n        this._gutter = \\'1px\\';\\n    }\\n    Object.defineProperty(MdGridList.prototype, \"cols\", {\\n        /**\\n         * Amount of columns in the grid list.\\n         * @return {?}\\n         */\\n        get: function () { return this._cols; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._cols = coerceToNumber(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdGridList.prototype, \"gutterSize\", {\\n        /**\\n         * Size of the grid list\\'s gutter in pixels.\\n         * @return {?}\\n         */\\n        get: function () { return this._gutter; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._gutter = coerceToString(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdGridList.prototype, \"rowHeight\", {\\n        /**\\n         * Set internal representation of row height from the user-provided value.\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._rowHeight = coerceToString(value);\\n            this._setTileStyler();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdGridList.prototype.ngOnInit = function () {\\n        this._checkCols();\\n        this._checkRowHeight();\\n    };\\n    /**\\n     * The layout calculation is fairly cheap if nothing changes, so there\\'s little cost\\n     * to run it frequently.\\n     * @return {?}\\n     */\\n    MdGridList.prototype.ngAfterContentChecked = function () {\\n        this._layoutTiles();\\n    };\\n    /**\\n     * Throw a friendly error if cols property is missing\\n     * @return {?}\\n     */\\n    MdGridList.prototype._checkCols = function () {\\n        if (!this.cols) {\\n            throw Error(\"md-grid-list: must pass in number of columns. \" +\\n                \"Example: <md-grid-list cols=\\\\\"3\\\\\">\");\\n        }\\n    };\\n    /**\\n     * Default to equal width:height if rowHeight property is missing\\n     * @return {?}\\n     */\\n    MdGridList.prototype._checkRowHeight = function () {\\n        if (!this._rowHeight) {\\n            this._tileStyler = new RatioTileStyler(\\'1:1\\');\\n        }\\n    };\\n    /**\\n     * Creates correct Tile Styler subtype based on rowHeight passed in by user\\n     * @return {?}\\n     */\\n    MdGridList.prototype._setTileStyler = function () {\\n        if (this._rowHeight === MD_FIT_MODE) {\\n            this._tileStyler = new FitTileStyler();\\n        }\\n        else if (this._rowHeight && this._rowHeight.indexOf(\\':\\') > -1) {\\n            this._tileStyler = new RatioTileStyler(this._rowHeight);\\n        }\\n        else {\\n            this._tileStyler = new FixedTileStyler(this._rowHeight);\\n        }\\n    };\\n    /**\\n     * Computes and applies the size and position for all children grid tiles.\\n     * @return {?}\\n     */\\n    MdGridList.prototype._layoutTiles = function () {\\n        var _this = this;\\n        var /** @type {?} */ tracker = new TileCoordinator(this.cols, this._tiles);\\n        var /** @type {?} */ direction = this._dir ? this._dir.value : \\'ltr\\';\\n        this._tileStyler.init(this.gutterSize, tracker, this.cols, direction);\\n        this._tiles.forEach(function (tile, index) {\\n            var /** @type {?} */ pos = tracker.positions[index];\\n            _this._tileStyler.setStyle(tile, pos.row, pos.col);\\n        });\\n        this._setListStyle(this._tileStyler.getComputedHeight());\\n    };\\n    /**\\n     * Sets style on the main grid-list element, given the style name and value.\\n     * @param {?} style\\n     * @return {?}\\n     */\\n    MdGridList.prototype._setListStyle = function (style$$1) {\\n        if (style$$1) {\\n            this._renderer.setStyle(this._element.nativeElement, style$$1[0], style$$1[1]);\\n        }\\n    };\\n    return MdGridList;\\n}());\\nMdGridList.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-grid-list, mat-grid-list\\',\\n                template: \"<div><ng-content></ng-content></div>\",\\n                styles: [\".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{display:flex;position:absolute;align-items:center;justify-content:center;height:100%;top:0;right:0;bottom:0;left:0;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}\"],\\n                host: {\\n                    \\'role\\': \\'list\\',\\n                    \\'class\\': \\'mat-grid-list\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridList.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdGridList.propDecorators = {\\n    \\'_tiles\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdGridTile,] },],\\n    \\'cols\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'gutterSize\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'rowHeight\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdGridListModule = /*@__PURE__*/(function () {\\n    function MdGridListModule() {\\n    }\\n    return MdGridListModule;\\n}());\\nMdGridListModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdLineModule, MdCommonModule],\\n                exports: [\\n                    MdGridList,\\n                    MdGridTile,\\n                    MdGridTileText,\\n                    MdLineModule,\\n                    MdCommonModule,\\n                    MdGridTileHeaderCssMatStyler,\\n                    MdGridTileFooterCssMatStyler,\\n                    MdGridAvatarCssMatStyler\\n                ],\\n                declarations: [\\n                    MdGridList,\\n                    MdGridTile,\\n                    MdGridTileText,\\n                    MdGridTileHeaderCssMatStyler,\\n                    MdGridTileFooterCssMatStyler,\\n                    MdGridAvatarCssMatStyler\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdGridListModule.ctorParameters = function () { return []; };\\n/**\\n * Content of a card, needed as it\\'s used as a selector in the API.\\n * \\\\@docs-private\\n */\\nvar MdCardContent = /*@__PURE__*/(function () {\\n    function MdCardContent() {\\n    }\\n    return MdCardContent;\\n}());\\nMdCardContent.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-card-content, mat-card-content\\',\\n                host: { \\'class\\': \\'mat-card-content\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardContent.ctorParameters = function () { return []; };\\n/**\\n * Title of a card, needed as it\\'s used as a selector in the API.\\n * \\\\@docs-private\\n */\\nvar MdCardTitle = /*@__PURE__*/(function () {\\n    function MdCardTitle() {\\n    }\\n    return MdCardTitle;\\n}());\\nMdCardTitle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-card-title, mat-card-title, [md-card-title], [mat-card-title],\\' +\\n                    \\'[mdCardTitle], [matCardTitle]\\',\\n                host: {\\n                    \\'class\\': \\'mat-card-title \\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardTitle.ctorParameters = function () { return []; };\\n/**\\n * Sub-title of a card, needed as it\\'s used as a selector in the API.\\n * \\\\@docs-private\\n */\\nvar MdCardSubtitle = /*@__PURE__*/(function () {\\n    function MdCardSubtitle() {\\n    }\\n    return MdCardSubtitle;\\n}());\\nMdCardSubtitle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-card-subtitle, mat-card-subtitle, [md-card-subtitle], [mat-card-subtitle],\\' +\\n                    \\'[mdCardSubtitle], [matCardSubtitle]\\',\\n                host: {\\n                    \\'class\\': \\'mat-card-subtitle \\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardSubtitle.ctorParameters = function () { return []; };\\n/**\\n * Action section of a card, needed as it\\'s used as a selector in the API.\\n * \\\\@docs-private\\n */\\nvar MdCardActions = /*@__PURE__*/(function () {\\n    function MdCardActions() {\\n    }\\n    return MdCardActions;\\n}());\\nMdCardActions.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-card-actions, mat-card-actions\\',\\n                host: { \\'class\\': \\'mat-card-actions\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardActions.ctorParameters = function () { return []; };\\n/**\\n * Footer of a card, needed as it\\'s used as a selector in the API.\\n * \\\\@docs-private\\n */\\nvar MdCardFooter = /*@__PURE__*/(function () {\\n    function MdCardFooter() {\\n    }\\n    return MdCardFooter;\\n}());\\nMdCardFooter.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-card-footer, mat-card-footer\\',\\n                host: { \\'class\\': \\'mat-card-footer\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardFooter.ctorParameters = function () { return []; };\\n/**\\n * Image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardImage = /*@__PURE__*/(function () {\\n    function MdCardImage() {\\n    }\\n    return MdCardImage;\\n}());\\nMdCardImage.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-image], [mat-card-image], [mdCardImage], [matCardImage]\\',\\n                host: { \\'class\\': \\'mat-card-image\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardImage.ctorParameters = function () { return []; };\\n/**\\n * Image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardSmImage = /*@__PURE__*/(function () {\\n    function MdCardSmImage() {\\n    }\\n    return MdCardSmImage;\\n}());\\nMdCardSmImage.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-sm-image], [mat-card-sm-image], [mdCardImageSmall], [matCardImageSmall]\\',\\n                host: { \\'class\\': \\'mat-card-sm-image\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardSmImage.ctorParameters = function () { return []; };\\n/**\\n * Image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardMdImage = /*@__PURE__*/(function () {\\n    function MdCardMdImage() {\\n    }\\n    return MdCardMdImage;\\n}());\\nMdCardMdImage.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-md-image], [mat-card-md-image], [mdCardImageMedium], [matCardImageMedium]\\',\\n                host: { \\'class\\': \\'mat-card-md-image\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardMdImage.ctorParameters = function () { return []; };\\n/**\\n * Image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardLgImage = /*@__PURE__*/(function () {\\n    function MdCardLgImage() {\\n    }\\n    return MdCardLgImage;\\n}());\\nMdCardLgImage.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-lg-image], [mat-card-lg-image], [mdCardImageLarge], [matCardImageLarge]\\',\\n                host: { \\'class\\': \\'mat-card-lg-image\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardLgImage.ctorParameters = function () { return []; };\\n/**\\n * Large image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardXlImage = /*@__PURE__*/(function () {\\n    function MdCardXlImage() {\\n    }\\n    return MdCardXlImage;\\n}());\\nMdCardXlImage.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-xl-image], [mat-card-xl-image], [mdCardImageXLarge], [matCardImageXLarge]\\',\\n                host: { \\'class\\': \\'mat-card-xl-image\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardXlImage.ctorParameters = function () { return []; };\\n/**\\n * Avatar image used in a card, needed to add the mat- CSS styling.\\n * \\\\@docs-private\\n */\\nvar MdCardAvatar = /*@__PURE__*/(function () {\\n    function MdCardAvatar() {\\n    }\\n    return MdCardAvatar;\\n}());\\nMdCardAvatar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-card-avatar], [mat-card-avatar], [mdCardAvatar], [matCardAvatar]\\',\\n                host: { \\'class\\': \\'mat-card-avatar\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardAvatar.ctorParameters = function () { return []; };\\n/**\\n * A basic content container component that adds the styles of a Material design card.\\n *\\n * While this component can be used alone, it also provides a number\\n * of preset styles for common card sections, including:\\n * - md-card-title\\n * - md-card-subtitle\\n * - md-card-content\\n * - md-card-actions\\n * - md-card-footer\\n */\\nvar MdCard = /*@__PURE__*/(function () {\\n    function MdCard() {\\n    }\\n    return MdCard;\\n}());\\nMdCard.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-card, mat-card\\',\\n                template: \"<ng-content></ng-content>\",\\n                styles: [\".mat-card{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:block;position:relative;padding:24px;border-radius:2px}.mat-card:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-flat{box-shadow:none}.mat-card-actions,.mat-card-content,.mat-card-subtitle,.mat-card-title{display:block;margin-bottom:16px}.mat-card-actions{margin-left:-16px;margin-right:-16px;padding:8px 0}.mat-card-actions[align=end]{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 48px);margin:0 -24px 16px -24px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-footer{position:absolute;width:100%;min-height:5px;bottom:0;left:0}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button{margin:0 4px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header-text{margin:0 8px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0}.mat-card-lg-image,.mat-card-md-image,.mat-card-sm-image{margin:-8px 0}.mat-card-title-group{display:flex;justify-content:space-between;margin:0 -8px}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}@media (max-width:600px){.mat-card{padding:24px 16px}.mat-card-actions{margin-left:-8px;margin-right:-8px}.mat-card-image{width:calc(100% + 32px);margin:16px -16px}.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}.mat-card-header{margin:-8px 0 0 0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child,.mat-card>:last-child{margin-bottom:0}.mat-card-image:first-child{margin-top:-24px}.mat-card>.mat-card-actions:last-child{margin-bottom:-16px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child{margin-left:0;margin-right:0}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                host: { \\'class\\': \\'mat-card\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCard.ctorParameters = function () { return []; };\\n/**\\n * Component intended to be used within the `<md-card>` component. It adds styles for a\\n * preset header section (i.e. a title, subtitle, and avatar layout).\\n * \\\\@docs-private\\n */\\nvar MdCardHeader = /*@__PURE__*/(function () {\\n    function MdCardHeader() {\\n    }\\n    return MdCardHeader;\\n}());\\nMdCardHeader.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-card-header, mat-card-header\\',\\n                template: \"<ng-content select=\\\\\"[md-card-avatar], [mat-card-avatar]\\\\\"></ng-content><div class=\\\\\"mat-card-header-text\\\\\"><ng-content select=\\\\\"md-card-title, mat-card-title, md-card-subtitle, mat-card-subtitle, [md-card-title], [mat-card-title], [md-card-subtitle], [mat-card-subtitle]\\\\\"></ng-content></div><ng-content></ng-content>\",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                host: { \\'class\\': \\'mat-card-header\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardHeader.ctorParameters = function () { return []; };\\n/**\\n * Component intended to be used within the <md-card> component. It adds styles for a preset\\n * layout that groups an image with a title section.\\n * \\\\@docs-private\\n */\\nvar MdCardTitleGroup = /*@__PURE__*/(function () {\\n    function MdCardTitleGroup() {\\n    }\\n    return MdCardTitleGroup;\\n}());\\nMdCardTitleGroup.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-card-title-group, mat-card-title-group\\',\\n                template: \"<div><ng-content select=\\\\\"md-card-title, mat-card-title, md-card-subtitle, mat-card-subtitle, [md-card-title], [mat-card-title], [md-card-subtitle], [mat-card-subtitle]\\\\\"></ng-content></div><ng-content select=\\\\\"img\\\\\"></ng-content><ng-content></ng-content>\",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                host: { \\'class\\': \\'mat-card-title-group\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardTitleGroup.ctorParameters = function () { return []; };\\nvar MdCardModule = /*@__PURE__*/(function () {\\n    function MdCardModule() {\\n    }\\n    return MdCardModule;\\n}());\\nMdCardModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule],\\n                exports: [\\n                    MdCard,\\n                    MdCardHeader,\\n                    MdCardTitleGroup,\\n                    MdCardContent,\\n                    MdCardTitle,\\n                    MdCardSubtitle,\\n                    MdCardActions,\\n                    MdCardFooter,\\n                    MdCardSmImage,\\n                    MdCardMdImage,\\n                    MdCardLgImage,\\n                    MdCardImage,\\n                    MdCardXlImage,\\n                    MdCardAvatar,\\n                    MdCommonModule,\\n                ],\\n                declarations: [\\n                    MdCard, MdCardHeader, MdCardTitleGroup, MdCardContent, MdCardTitle, MdCardSubtitle,\\n                    MdCardActions, MdCardFooter, MdCardSmImage, MdCardMdImage, MdCardLgImage, MdCardImage,\\n                    MdCardXlImage, MdCardAvatar,\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCardModule.ctorParameters = function () { return []; };\\n/**\\n * \\\\@docs-private\\n */\\nvar MdChipBase = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdChipBase(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n    }\\n    return MdChipBase;\\n}());\\nvar _MdChipMixinBase = mixinColor(mixinDisabled(MdChipBase), \\'primary\\');\\n/**\\n * Dummy directive to add CSS class to basic chips.\\n * \\\\@docs-private\\n */\\nvar MdBasicChip = /*@__PURE__*/(function () {\\n    function MdBasicChip() {\\n    }\\n    return MdBasicChip;\\n}());\\nMdBasicChip.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \"md-basic-chip, [md-basic-chip], mat-basic-chip, [mat-basic-chip]\",\\n                host: { \\'class\\': \\'mat-basic-chip\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdBasicChip.ctorParameters = function () { return []; };\\n/**\\n * Material design styled Chip component. Used inside the MdChipList component.\\n */\\nvar MdChip = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdChip, _super);\\n    /**\\n     * @param {?} renderer\\n     * @param {?} elementRef\\n     */\\n    function MdChip(renderer, elementRef) {\\n        var _this = _super.call(this, renderer, elementRef) || this;\\n        _this._selected = false;\\n        /**\\n         * Whether the chip has focus.\\n         */\\n        _this._hasFocus = false;\\n        /**\\n         * Emitted when the chip is focused.\\n         */\\n        _this.onFocus = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Emitted when the chip is selected.\\n         */\\n        _this.select = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Emitted when the chip is deselected.\\n         */\\n        _this.deselect = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Emitted when the chip is destroyed.\\n         */\\n        _this.destroy = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        return _this;\\n    }\\n    Object.defineProperty(MdChip.prototype, \"selected\", {\\n        /**\\n         * Whether the chip is selected.\\n         * @return {?}\\n         */\\n        get: function () { return this._selected; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._selected = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n            (this.selected ? this.select : this.deselect).emit({ chip: this });\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdChip.prototype.ngOnDestroy = function () {\\n        this.destroy.emit({ chip: this });\\n    };\\n    /**\\n     * Toggles the current selected state of this chip.\\n     * @return {?} Whether the chip is selected.\\n     */\\n    MdChip.prototype.toggleSelected = function () {\\n        this.selected = !this.selected;\\n        return this.selected;\\n    };\\n    /**\\n     * Allows for programmatic focusing of the chip.\\n     * @return {?}\\n     */\\n    MdChip.prototype.focus = function () {\\n        this._elementRef.nativeElement.focus();\\n        this.onFocus.emit({ chip: this });\\n    };\\n    /**\\n     * Ensures events fire properly upon click.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdChip.prototype._handleClick = function (event) {\\n        // Check disabled\\n        if (this.disabled) {\\n            event.preventDefault();\\n            event.stopPropagation();\\n        }\\n        else {\\n            this.focus();\\n        }\\n    };\\n    return MdChip;\\n}(_MdChipMixinBase));\\nMdChip.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \"md-basic-chip, [md-basic-chip], md-chip, [md-chip],\\\\n             mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]\",\\n                inputs: [\\'color\\', \\'disabled\\'],\\n                host: {\\n                    \\'class\\': \\'mat-chip\\',\\n                    \\'tabindex\\': \\'-1\\',\\n                    \\'role\\': \\'option\\',\\n                    \\'[class.mat-chip-selected]\\': \\'selected\\',\\n                    \\'[attr.disabled]\\': \\'disabled || null\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled.toString()\\',\\n                    \\'(click)\\': \\'_handleClick($event)\\',\\n                    \\'(focus)\\': \\'_hasFocus = true\\',\\n                    \\'(blur)\\': \\'_hasFocus = false\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdChip.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdChip.propDecorators = {\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'select\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'deselect\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'destroy\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * A material design chips component (named ChipList for it\\'s similarity to the List component).\\n *\\n * Example:\\n *\\n *     <md-chip-list>\\n *       <md-chip>Chip 1<md-chip>\\n *       <md-chip>Chip 2<md-chip>\\n *     </md-chip-list>\\n */\\nvar MdChipList = /*@__PURE__*/(function () {\\n    function MdChipList() {\\n        /**\\n         * Track which chips we\\'re listening to for focus/destruction.\\n         */\\n        this._subscribed = new WeakMap();\\n        /**\\n         * Whether or not the chip is selectable.\\n         */\\n        this._selectable = true;\\n        /**\\n         * Tab index for the chip list.\\n         */\\n        this._tabIndex = 0;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdChipList.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._keyManager = new FocusKeyManager(this.chips).withWrap();\\n        // Prevents the chip list from capturing focus and redirecting\\n        // it back to the first chip when the user tabs out.\\n        this._tabOutSubscription = this._keyManager.tabOut.subscribe(function () {\\n            _this._tabIndex = -1;\\n            setTimeout(function () { return _this._tabIndex = 0; });\\n        });\\n        // Go ahead and subscribe all of the initial chips\\n        this._subscribeChips(this.chips);\\n        // When the list changes, re-subscribe\\n        this.chips.changes.subscribe(function (chips) {\\n            _this._subscribeChips(chips);\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdChipList.prototype.ngOnDestroy = function () {\\n        if (this._tabOutSubscription) {\\n            this._tabOutSubscription.unsubscribe();\\n        }\\n    };\\n    Object.defineProperty(MdChipList.prototype, \"selectable\", {\\n        /**\\n         * Whether or not this chip is selectable. When a chip is not selectable,\\n         * it\\'s selected state is always ignored.\\n         * @return {?}\\n         */\\n        get: function () { return this._selectable; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._selectable = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Programmatically focus the chip list. This in turn focuses the first\\n     * non-disabled chip in this chip list.\\n     * @return {?}\\n     */\\n    MdChipList.prototype.focus = function () {\\n        // TODO: ARIA says this should focus the first `selected` chip.\\n        this._keyManager.setFirstItemActive();\\n    };\\n    /**\\n     * Passes relevant key presses to our key manager.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdChipList.prototype._keydown = function (event) {\\n        var /** @type {?} */ target = (event.target);\\n        // If they are on a chip, check for space/left/right, otherwise pass to our key manager\\n        if (target && target.classList.contains(\\'mat-chip\\')) {\\n            switch (event.keyCode) {\\n                case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"S\" /* SPACE */]:\\n                    // If we are selectable, toggle the focused chip\\n                    if (this.selectable) {\\n                        this._toggleSelectOnFocusedChip();\\n                    }\\n                    // Always prevent space from scrolling the page since the list has focus\\n                    event.preventDefault();\\n                    break;\\n                case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"C\" /* LEFT_ARROW */]:\\n                    this._keyManager.setPreviousItemActive();\\n                    event.preventDefault();\\n                    break;\\n                case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Q\" /* RIGHT_ARROW */]:\\n                    this._keyManager.setNextItemActive();\\n                    event.preventDefault();\\n                    break;\\n                default:\\n                    this._keyManager.onKeydown(event);\\n            }\\n        }\\n    };\\n    /**\\n     * Toggles the selected state of the currently focused chip.\\n     * @return {?}\\n     */\\n    MdChipList.prototype._toggleSelectOnFocusedChip = function () {\\n        // Allow disabling of chip selection\\n        if (!this.selectable) {\\n            return;\\n        }\\n        var /** @type {?} */ focusedIndex = this._keyManager.activeItemIndex;\\n        if (typeof focusedIndex === \\'number\\' && this._isValidIndex(focusedIndex)) {\\n            var /** @type {?} */ focusedChip = this.chips.toArray()[focusedIndex];\\n            if (focusedChip) {\\n                focusedChip.toggleSelected();\\n            }\\n        }\\n    };\\n    /**\\n     * Iterate through the list of chips and add them to our list of\\n     * subscribed chips.\\n     *\\n     * @param {?} chips The list of chips to be subscribed.\\n     * @return {?}\\n     */\\n    MdChipList.prototype._subscribeChips = function (chips) {\\n        var _this = this;\\n        chips.forEach(function (chip) { return _this._addChip(chip); });\\n    };\\n    /**\\n     * Add a specific chip to our subscribed list. If the chip has\\n     * already been subscribed, this ensures it is only subscribed\\n     * once.\\n     *\\n     * @param {?} chip The chip to be subscribed (or checked for existing\\n     * subscription).\\n     * @return {?}\\n     */\\n    MdChipList.prototype._addChip = function (chip) {\\n        var _this = this;\\n        // If we\\'ve already been subscribed to a parent, do nothing\\n        if (this._subscribed.has(chip)) {\\n            return;\\n        }\\n        // Watch for focus events outside of the keyboard navigation\\n        chip.onFocus.subscribe(function () {\\n            var /** @type {?} */ chipIndex = _this.chips.toArray().indexOf(chip);\\n            if (_this._isValidIndex(chipIndex)) {\\n                _this._keyManager.updateActiveItemIndex(chipIndex);\\n            }\\n        });\\n        // On destroy, remove the item from our list, and check focus\\n        chip.destroy.subscribe(function () {\\n            var /** @type {?} */ chipIndex = _this.chips.toArray().indexOf(chip);\\n            if (_this._isValidIndex(chipIndex) && chip._hasFocus) {\\n                // Check whether the chip is the last item\\n                if (chipIndex < _this.chips.length - 1) {\\n                    _this._keyManager.setActiveItem(chipIndex);\\n                }\\n                else if (chipIndex - 1 >= 0) {\\n                    _this._keyManager.setActiveItem(chipIndex - 1);\\n                }\\n            }\\n            _this._subscribed.delete(chip);\\n            chip.destroy.unsubscribe();\\n        });\\n        this._subscribed.set(chip, true);\\n    };\\n    /**\\n     * Utility to ensure all indexes are valid.\\n     *\\n     * @param {?} index The index to be checked.\\n     * @return {?} True if the index is valid for our list of chips.\\n     */\\n    MdChipList.prototype._isValidIndex = function (index) {\\n        return index >= 0 && index < this.chips.length;\\n    };\\n    return MdChipList;\\n}());\\nMdChipList.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-chip-list, mat-chip-list\\',\\n                template: \"<div class=\\\\\"mat-chip-list-wrapper\\\\\"><ng-content></ng-content></div>\",\\n                host: {\\n                    // Properties\\n                    \\'[attr.tabindex]\\': \\'_tabIndex\\',\\n                    \\'role\\': \\'listbox\\',\\n                    \\'class\\': \\'mat-chip-list\\',\\n                    // Events\\n                    \\'(focus)\\': \\'focus()\\',\\n                    \\'(keydown)\\': \\'_keydown($event)\\'\\n                },\\n                queries: {\\n                    chips: new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"](MdChip)\\n                },\\n                styles: [\".mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:flex-start}.mat-chip:not(.mat-basic-chip){display:inline-block;padding:8px 12px 8px 12px;border-radius:24px}.mat-chip:not(.mat-basic-chip)+.mat-chip:not(.mat-basic-chip){margin:0 0 0 3px}[dir=rtl] .mat-chip:not(.mat-basic-chip)+.mat-chip:not(.mat-basic-chip){margin:0 3px 0 0}.mat-chip-list-stacked .mat-chip-list-wrapper{display:block}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip){display:block;margin:0;margin-bottom:8px}[dir=rtl] .mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip){margin:0;margin-bottom:8px}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child,[dir=rtl] .mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child{margin-bottom:0}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdChipList.ctorParameters = function () { return []; };\\nMdChipList.propDecorators = {\\n    \\'selectable\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdChipsModule = /*@__PURE__*/(function () {\\n    function MdChipsModule() {\\n    }\\n    return MdChipsModule;\\n}());\\nMdChipsModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [],\\n                exports: [MdChipList, MdChip, MdBasicChip],\\n                declarations: [MdChipList, MdChip, MdBasicChip]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdChipsModule.ctorParameters = function () { return []; };\\n/**\\n * Returns an exception to be thrown in the case when attempting to\\n * load an icon with a name that cannot be found.\\n * \\\\@docs-private\\n * @param {?} iconName\\n * @return {?}\\n */\\nfunction getMdIconNameNotFoundError(iconName) {\\n    return Error(\"Unable to find icon with the name \\\\\"\" + iconName + \"\\\\\"\");\\n}\\n/**\\n * Returns an exception to be thrown when the consumer attempts to use\\n * `<md-icon>` without including \\\\@angular/http.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdIconNoHttpProviderError() {\\n    return Error(\\'Could not find Http provider for use with Angular Material icons. \\' +\\n        \\'Please include the HttpModule from @angular/http in your app imports.\\');\\n}\\n/**\\n * Returns an exception to be thrown when a URL couldn\\'t be sanitized.\\n * \\\\@docs-private\\n * @param {?} url URL that was attempted to be sanitized.\\n * @return {?}\\n */\\nfunction getMdIconFailedToSanitizeError(url) {\\n    return Error(\"The URL provided to MdIconRegistry was not trusted as a resource URL \" +\\n        (\"via Angular\\'s DomSanitizer. Attempted URL was \\\\\"\" + url + \"\\\\\".\"));\\n}\\n/**\\n * Configuration for an icon, including the URL and possibly the cached SVG element.\\n * \\\\@docs-private\\n */\\nvar SvgIconConfig = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} url\\n     */\\n    function SvgIconConfig(url) {\\n        this.url = url;\\n        this.svgElement = null;\\n    }\\n    return SvgIconConfig;\\n}());\\n/**\\n * Service to register and display icons used by the <md-icon> component.\\n * - Registers icon URLs by namespace and name.\\n * - Registers icon set URLs by namespace.\\n * - Registers aliases for CSS classes, for use with icon fonts.\\n * - Loads icons from URLs and extracts individual icons from icon sets.\\n */\\nvar MdIconRegistry = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _http\\n     * @param {?} _sanitizer\\n     */\\n    function MdIconRegistry(_http, _sanitizer) {\\n        this._http = _http;\\n        this._sanitizer = _sanitizer;\\n        /**\\n         * URLs and cached SVG elements for individual icons. Keys are of the format \"[namespace]:[icon]\".\\n         */\\n        this._svgIconConfigs = new Map();\\n        /**\\n         * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.\\n         * Multiple icon sets can be registered under the same namespace.\\n         */\\n        this._iconSetConfigs = new Map();\\n        /**\\n         * Cache for icons loaded by direct URLs.\\n         */\\n        this._cachedIconsByUrl = new Map();\\n        /**\\n         * In-progress icon fetches. Used to coalesce multiple requests to the same URL.\\n         */\\n        this._inProgressUrlFetches = new Map();\\n        /**\\n         * Map from font identifiers to their CSS class names. Used for icon fonts.\\n         */\\n        this._fontCssClassesByAlias = new Map();\\n        /**\\n         * The CSS class to apply when an <md-icon> component has no icon name, url, or font specified.\\n         * The default \\'material-icons\\' value assumes that the material icon font has been loaded as\\n         * described at http://google.github.io/material-design-icons/#icon-font-for-the-web\\n         */\\n        this._defaultFontSetClass = \\'material-icons\\';\\n    }\\n    /**\\n     * Registers an icon by URL in the default namespace.\\n     * @param {?} iconName Name under which the icon should be registered.\\n     * @param {?} url\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.addSvgIcon = function (iconName, url) {\\n        return this.addSvgIconInNamespace(\\'\\', iconName, url);\\n    };\\n    /**\\n     * Registers an icon by URL in the specified namespace.\\n     * @param {?} namespace Namespace in which the icon should be registered.\\n     * @param {?} iconName Name under which the icon should be registered.\\n     * @param {?} url\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.addSvgIconInNamespace = function (namespace, iconName, url) {\\n        var /** @type {?} */ key = iconKey(namespace, iconName);\\n        this._svgIconConfigs.set(key, new SvgIconConfig(url));\\n        return this;\\n    };\\n    /**\\n     * Registers an icon set by URL in the default namespace.\\n     * @param {?} url\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.addSvgIconSet = function (url) {\\n        return this.addSvgIconSetInNamespace(\\'\\', url);\\n    };\\n    /**\\n     * Registers an icon set by URL in the specified namespace.\\n     * @param {?} namespace Namespace in which to register the icon set.\\n     * @param {?} url\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.addSvgIconSetInNamespace = function (namespace, url) {\\n        var /** @type {?} */ config = new SvgIconConfig(url);\\n        var /** @type {?} */ configNamespace = this._iconSetConfigs.get(namespace);\\n        if (configNamespace) {\\n            configNamespace.push(config);\\n        }\\n        else {\\n            this._iconSetConfigs.set(namespace, [config]);\\n        }\\n        return this;\\n    };\\n    /**\\n     * Defines an alias for a CSS class name to be used for icon fonts. Creating an mdIcon\\n     * component with the alias as the fontSet input will cause the class name to be applied\\n     * to the <md-icon> element.\\n     *\\n     * @param {?} alias Alias for the font.\\n     * @param {?=} className Class name override to be used instead of the alias.\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.registerFontClassAlias = function (alias, className) {\\n        if (className === void 0) { className = alias; }\\n        this._fontCssClassesByAlias.set(alias, className);\\n        return this;\\n    };\\n    /**\\n     * Returns the CSS class name associated with the alias by a previous call to\\n     * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.\\n     * @param {?} alias\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.classNameForFontAlias = function (alias) {\\n        return this._fontCssClassesByAlias.get(alias) || alias;\\n    };\\n    /**\\n     * Sets the CSS class name to be used for icon fonts when an <md-icon> component does not\\n     * have a fontSet input value, and is not loading an icon by name or URL.\\n     *\\n     * @param {?} className\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.setDefaultFontSetClass = function (className) {\\n        this._defaultFontSetClass = className;\\n        return this;\\n    };\\n    /**\\n     * Returns the CSS class name to be used for icon fonts when an <md-icon> component does not\\n     * have a fontSet input value, and is not loading an icon by name or URL.\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.getDefaultFontSetClass = function () {\\n        return this._defaultFontSetClass;\\n    };\\n    /**\\n     * Returns an Observable that produces the icon (as an <svg> DOM element) from the given URL.\\n     * The response from the URL may be cached so this will not always cause an HTTP request, but\\n     * the produced element will always be a new copy of the originally fetched icon. (That is,\\n     * it will not contain any modifications made to elements previously returned).\\n     *\\n     * @param {?} safeUrl URL from which to fetch the SVG icon.\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.getSvgIconFromUrl = function (safeUrl) {\\n        var _this = this;\\n        var /** @type {?} */ url = this._sanitizer.sanitize(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].RESOURCE_URL, safeUrl);\\n        if (!url) {\\n            throw getMdIconFailedToSanitizeError(safeUrl);\\n        }\\n        var /** @type {?} */ cachedIcon = this._cachedIconsByUrl.get(url);\\n        if (cachedIcon) {\\n            return __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__[\"of\"](cloneSvg(cachedIcon));\\n        }\\n        return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"R\" /* RxChain */].from(this._loadSvgIconFromConfig(new SvgIconConfig(url)))\\n            .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_1\" /* doOperator */], function (svg) { return _this._cachedIconsByUrl.set(/** @type {?} */ ((url)), svg); })\\n            .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_7\" /* map */], function (svg) { return cloneSvg(svg); })\\n            .result();\\n    };\\n    /**\\n     * Returns an Observable that produces the icon (as an <svg> DOM element) with the given name\\n     * and namespace. The icon must have been previously registered with addIcon or addIconSet;\\n     * if not, the Observable will throw an error.\\n     *\\n     * @param {?} name Name of the icon to be retrieved.\\n     * @param {?=} namespace Namespace in which to look for the icon.\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype.getNamedSvgIcon = function (name, namespace) {\\n        if (namespace === void 0) { namespace = \\'\\'; }\\n        // Return (copy of) cached icon if possible.\\n        var /** @type {?} */ key = iconKey(namespace, name);\\n        var /** @type {?} */ config = this._svgIconConfigs.get(key);\\n        if (config) {\\n            return this._getSvgFromConfig(config);\\n        }\\n        // See if we have any icon sets registered for the namespace.\\n        var /** @type {?} */ iconSetConfigs = this._iconSetConfigs.get(namespace);\\n        if (iconSetConfigs) {\\n            return this._getSvgFromIconSetConfigs(name, iconSetConfigs);\\n        }\\n        return __WEBPACK_IMPORTED_MODULE_14_rxjs_observable_throw__[\"_throw\"](getMdIconNameNotFoundError(key));\\n    };\\n    /**\\n     * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.\\n     * @param {?} config\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._getSvgFromConfig = function (config) {\\n        if (config.svgElement) {\\n            // We already have the SVG element for this icon, return a copy.\\n            return __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__[\"of\"](cloneSvg(config.svgElement));\\n        }\\n        else {\\n            // Fetch the icon from the config\\'s URL, cache it, and return a copy.\\n            return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"R\" /* RxChain */].from(this._loadSvgIconFromConfig(config))\\n                .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_1\" /* doOperator */], function (svg) { return config.svgElement = svg; })\\n                .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_7\" /* map */], function (svg) { return cloneSvg(svg); })\\n                .result();\\n        }\\n    };\\n    /**\\n     * Attempts to find an icon with the specified name in any of the SVG icon sets.\\n     * First searches the available cached icons for a nested element with a matching name, and\\n     * if found copies the element to a new <svg> element. If not found, fetches all icon sets\\n     * that have not been cached, and searches again after all fetches are completed.\\n     * The returned Observable produces the SVG element if possible, and throws\\n     * an error if no icon with the specified name can be found.\\n     * @param {?} name\\n     * @param {?} iconSetConfigs\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._getSvgFromIconSetConfigs = function (name, iconSetConfigs) {\\n        var _this = this;\\n        // For all the icon set SVG elements we\\'ve fetched, see if any contain an icon with the\\n        // requested name.\\n        var /** @type {?} */ namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\\n        if (namedIcon) {\\n            // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every\\n            // time anyway, there\\'s probably not much advantage compared to just always extracting\\n            // it from the icon set.\\n            return __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__[\"of\"](namedIcon);\\n        }\\n        // Not found in any cached icon sets. If there are icon sets with URLs that we haven\\'t\\n        // fetched, fetch them now and look for iconName in the results.\\n        var /** @type {?} */ iconSetFetchRequests = iconSetConfigs\\n            .filter(function (iconSetConfig) { return !iconSetConfig.svgElement; })\\n            .map(function (iconSetConfig) {\\n            return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"R\" /* RxChain */].from(_this._loadSvgIconSetFromConfig(iconSetConfig))\\n                .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Y\" /* catchOperator */], function (err) {\\n                var /** @type {?} */ url = _this._sanitizer.sanitize(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].RESOURCE_URL, iconSetConfig.url);\\n                // Swallow errors fetching individual URLs so the combined Observable won\\'t\\n                // necessarily fail.\\n                console.log(\"Loading icon set URL: \" + url + \" failed: \" + err);\\n                return __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__[\"of\"](null);\\n            })\\n                .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_1\" /* doOperator */], function (svg) {\\n                // Cache the SVG element.\\n                if (svg) {\\n                    iconSetConfig.svgElement = svg;\\n                }\\n            })\\n                .result();\\n        });\\n        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a\\n        // cached SVG element (unless the request failed), and we can check again for the icon.\\n        return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_7\" /* map */].call(__WEBPACK_IMPORTED_MODULE_15_rxjs_observable_forkJoin__[\"forkJoin\"].call(__WEBPACK_IMPORTED_MODULE_13_rxjs_Observable__[\"Observable\"], iconSetFetchRequests), function () {\\n            var /** @type {?} */ foundIcon = _this._extractIconWithNameFromAnySet(name, iconSetConfigs);\\n            if (!foundIcon) {\\n                throw getMdIconNameNotFoundError(name);\\n            }\\n            return foundIcon;\\n        });\\n    };\\n    /**\\n     * Searches the cached SVG elements for the given icon sets for a nested icon element whose \"id\"\\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\\n     * returns it. Returns null if no matching element is found.\\n     * @param {?} iconName\\n     * @param {?} iconSetConfigs\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._extractIconWithNameFromAnySet = function (iconName, iconSetConfigs) {\\n        // Iterate backwards, so icon sets added later have precedence.\\n        for (var /** @type {?} */ i = iconSetConfigs.length - 1; i >= 0; i--) {\\n            var /** @type {?} */ config = iconSetConfigs[i];\\n            if (config.svgElement) {\\n                var /** @type {?} */ foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName);\\n                if (foundIcon) {\\n                    return foundIcon;\\n                }\\n            }\\n        }\\n        return null;\\n    };\\n    /**\\n     * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element\\n     * from it.\\n     * @param {?} config\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._loadSvgIconFromConfig = function (config) {\\n        var _this = this;\\n        return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_7\" /* map */].call(this._fetchUrl(config.url), function (svgText) { return _this._createSvgElementForSingleIcon(svgText); });\\n    };\\n    /**\\n     * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element\\n     * from it.\\n     * @param {?} config\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._loadSvgIconSetFromConfig = function (config) {\\n        var _this = this;\\n        // TODO: Document that icons should only be loaded from trusted sources.\\n        return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_7\" /* map */].call(this._fetchUrl(config.url), function (svgText) { return _this._svgElementFromString(svgText); });\\n    };\\n    /**\\n     * Creates a DOM element from the given SVG string, and adds default attributes.\\n     * @param {?} responseText\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._createSvgElementForSingleIcon = function (responseText) {\\n        var /** @type {?} */ svg = this._svgElementFromString(responseText);\\n        this._setSvgAttributes(svg);\\n        return svg;\\n    };\\n    /**\\n     * Searches the cached element of the given SvgIconConfig for a nested icon element whose \"id\"\\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\\n     * returns it. Returns null if no matching element is found.\\n     * @param {?} iconSet\\n     * @param {?} iconName\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._extractSvgIconFromSet = function (iconSet, iconName) {\\n        var /** @type {?} */ iconNode = iconSet.querySelector(\\'#\\' + iconName);\\n        if (!iconNode) {\\n            return null;\\n        }\\n        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as\\n        // the content of a new <svg> node.\\n        if (iconNode.tagName.toLowerCase() === \\'svg\\') {\\n            return this._setSvgAttributes(/** @type {?} */ (iconNode.cloneNode(true)));\\n        }\\n        // If the node is a <symbol>, it won\\'t be rendered so we have to convert it into <svg>. Note\\n        // that the same could be achieved by referring to it via <use href=\"#id\">, however the <use>\\n        // tag is problematic on Firefox, because it needs to include the current page path.\\n        if (iconNode.nodeName.toLowerCase() === \\'symbol\\') {\\n            return this._setSvgAttributes(this._toSvgElement(iconNode));\\n        }\\n        // createElement(\\'SVG\\') doesn\\'t work as expected; the DOM ends up with\\n        // the correct nodes, but the SVG content doesn\\'t render. Instead we\\n        // have to create an empty SVG node using innerHTML and append its content.\\n        // Elements created using DOMParser.parseFromString have the same problem.\\n        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display\\n        var /** @type {?} */ svg = this._svgElementFromString(\\'<svg></svg>\\');\\n        // Clone the node so we don\\'t remove it from the parent icon set element.\\n        svg.appendChild(iconNode.cloneNode(true));\\n        return this._setSvgAttributes(svg);\\n    };\\n    /**\\n     * Creates a DOM element from the given SVG string.\\n     * @param {?} str\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._svgElementFromString = function (str) {\\n        // TODO: Is there a better way than innerHTML? Renderer doesn\\'t appear to have a method for\\n        // creating an element from an HTML string.\\n        var /** @type {?} */ div = document.createElement(\\'DIV\\');\\n        div.innerHTML = str;\\n        var /** @type {?} */ svg = (div.querySelector(\\'svg\\'));\\n        if (!svg) {\\n            throw Error(\\'<svg> tag not found\\');\\n        }\\n        return svg;\\n    };\\n    /**\\n     * Converts an element into an SVG node by cloning all of its children.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._toSvgElement = function (element) {\\n        var /** @type {?} */ svg = this._svgElementFromString(\\'<svg></svg>\\');\\n        for (var /** @type {?} */ i = 0; i < element.childNodes.length; i++) {\\n            if (element.childNodes[i].nodeType === Node.ELEMENT_NODE) {\\n                svg.appendChild(element.childNodes[i].cloneNode(true));\\n            }\\n        }\\n        return svg;\\n    };\\n    /**\\n     * Sets the default attributes for an SVG element to be used as an icon.\\n     * @param {?} svg\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._setSvgAttributes = function (svg) {\\n        if (!svg.getAttribute(\\'xmlns\\')) {\\n            svg.setAttribute(\\'xmlns\\', \\'http://www.w3.org/2000/svg\\');\\n        }\\n        svg.setAttribute(\\'fit\\', \\'\\');\\n        svg.setAttribute(\\'height\\', \\'100%\\');\\n        svg.setAttribute(\\'width\\', \\'100%\\');\\n        svg.setAttribute(\\'preserveAspectRatio\\', \\'xMidYMid meet\\');\\n        svg.setAttribute(\\'focusable\\', \\'false\\'); // Disable IE11 default behavior to make SVGs focusable.\\n        return svg;\\n    };\\n    /**\\n     * Returns an Observable which produces the string contents of the given URL. Results may be\\n     * cached, so future calls with the same URL may not cause another HTTP request.\\n     * @param {?} safeUrl\\n     * @return {?}\\n     */\\n    MdIconRegistry.prototype._fetchUrl = function (safeUrl) {\\n        var _this = this;\\n        if (!this._http) {\\n            throw getMdIconNoHttpProviderError();\\n        }\\n        var /** @type {?} */ url = this._sanitizer.sanitize(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SecurityContext\"].RESOURCE_URL, safeUrl);\\n        if (!url) {\\n            throw getMdIconFailedToSanitizeError(safeUrl);\\n        }\\n        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is\\n        // already a request in progress for that URL. It\\'s necessary to call share() on the\\n        // Observable returned by http.get() so that multiple subscribers don\\'t cause multiple XHRs.\\n        var /** @type {?} */ inProgressFetch = this._inProgressUrlFetches.get(url);\\n        if (inProgressFetch) {\\n            return inProgressFetch;\\n        }\\n        // TODO(jelbourn): for some reason, the `finally` operator \"loses\" the generic type on the\\n        // Observable. Figure out why and fix it.\\n        var /** @type {?} */ req = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"R\" /* RxChain */].from(this._http.get(url))\\n            .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_7\" /* map */], function (response) { return response.text(); })\\n            .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_3\" /* finallyOperator */], function () { return _this._inProgressUrlFetches.delete(url); })\\n            .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_8\" /* share */])\\n            .result();\\n        this._inProgressUrlFetches.set(url, req);\\n        return req;\\n    };\\n    return MdIconRegistry;\\n}());\\nMdIconRegistry.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdIconRegistry.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_12__angular_http__[\"Http\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"DomSanitizer\"], },\\n]; };\\n/**\\n * @param {?} parentRegistry\\n * @param {?} http\\n * @param {?} sanitizer\\n * @return {?}\\n */\\nfunction ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, http, sanitizer) {\\n    return parentRegistry || new MdIconRegistry(http, sanitizer);\\n}\\nvar ICON_REGISTRY_PROVIDER = {\\n    // If there is already an MdIconRegistry available, use that. Otherwise, provide a new one.\\n    provide: MdIconRegistry,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), MdIconRegistry], [new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), __WEBPACK_IMPORTED_MODULE_12__angular_http__[\"Http\"]], __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"DomSanitizer\"]],\\n    useFactory: ICON_REGISTRY_PROVIDER_FACTORY\\n};\\n/**\\n * Clones an SVGElement while preserving type information.\\n * @param {?} svg\\n * @return {?}\\n */\\nfunction cloneSvg(svg) {\\n    return (svg.cloneNode(true));\\n}\\n/**\\n * Returns the cache key to use for an icon namespace and name.\\n * @param {?} namespace\\n * @param {?} name\\n * @return {?}\\n */\\nfunction iconKey(namespace, name) {\\n    return namespace + \\':\\' + name;\\n}\\n/**\\n * \\\\@docs-private\\n */\\nvar MdIconBase = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdIconBase(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n    }\\n    return MdIconBase;\\n}());\\nvar _MdIconMixinBase = mixinColor(MdIconBase);\\n/**\\n * Component to display an icon. It can be used in the following ways:\\n * - Specify the svgSrc input to load an SVG icon from a URL. The SVG content is directly inlined\\n *   as a child of the <md-icon> component, so that CSS styles can easily be applied to it.\\n *   The URL is loaded via an XMLHttpRequest, so it must be on the same domain as the page or its\\n *   server must be configured to allow cross-domain requests.\\n *   Example:\\n *     <md-icon svgSrc=\"assets/arrow.svg\"></md-icon>\\n *\\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\\n *   MdIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\\n *   Examples:\\n *     <md-icon svgIcon=\"left-arrow\"></md-icon>\\n *     <md-icon svgIcon=\"animals:cat\"></md-icon>\\n *\\n * - Use a font ligature as an icon by putting the ligature text in the content of the <md-icon>\\n *   component. By default the Material icons font is used as described at\\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\\n *   desired font, or to an alias previously registered with MdIconRegistry.registerFontClassAlias.\\n *   Examples:\\n *     <md-icon>home</md-icon>\\n *     <md-icon fontSet=\"myfont\">sun</md-icon>\\n *\\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\\n *   https://fortawesome.github.io/Font-Awesome/examples/\\n *   Example:\\n *     <md-icon fontSet=\"fa\" fontIcon=\"alarm\"></md-icon>\\n */\\nvar MdIcon = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdIcon, _super);\\n    /**\\n     * @param {?} renderer\\n     * @param {?} elementRef\\n     * @param {?} _mdIconRegistry\\n     * @param {?} ariaHidden\\n     */\\n    function MdIcon(renderer, elementRef, _mdIconRegistry, ariaHidden) {\\n        var _this = _super.call(this, renderer, elementRef) || this;\\n        _this._mdIconRegistry = _mdIconRegistry;\\n        // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is\\n        // the right thing to do for the majority of icon use-cases.\\n        if (!ariaHidden) {\\n            renderer.setAttribute(elementRef.nativeElement, \\'aria-hidden\\', \\'true\\');\\n        }\\n        return _this;\\n    }\\n    /**\\n     * Splits an svgIcon binding value into its icon set and icon name components.\\n     * Returns a 2-element array of [(icon set), (icon name)].\\n     * The separator for the two fields is \\':\\'. If there is no separator, an empty\\n     * string is returned for the icon set and the entire value is returned for\\n     * the icon name. If the argument is falsy, returns an array of two empty strings.\\n     * Throws an error if the name contains two or more \\':\\' separators.\\n     * Examples:\\n     *   \\'social:cake\\' -> [\\'social\\', \\'cake\\']\\n     *   \\'penguin\\' -> [\\'\\', \\'penguin\\']\\n     *   null -> [\\'\\', \\'\\']\\n     *   \\'a:b:c\\' -> (throws Error)\\n     * @param {?} iconName\\n     * @return {?}\\n     */\\n    MdIcon.prototype._splitIconName = function (iconName) {\\n        if (!iconName) {\\n            return [\\'\\', \\'\\'];\\n        }\\n        var /** @type {?} */ parts = iconName.split(\\':\\');\\n        switch (parts.length) {\\n            case 1:\\n                // Use default namespace.\\n                return [\\'\\', parts[0]];\\n            case 2:\\n                return (parts);\\n            default:\\n                throw Error(\"Invalid icon name: \\\\\"\" + iconName + \"\\\\\"\");\\n        }\\n    };\\n    /**\\n     * @param {?} changes\\n     * @return {?}\\n     */\\n    MdIcon.prototype.ngOnChanges = function (changes) {\\n        var _this = this;\\n        var /** @type {?} */ changedInputs = Object.keys(changes);\\n        // Only update the inline SVG icon if the inputs changed, to avoid unnecessary DOM operations.\\n        if (changedInputs.indexOf(\\'svgIcon\\') != -1 || changedInputs.indexOf(\\'svgSrc\\') != -1) {\\n            if (this.svgIcon) {\\n                var _a = this._splitIconName(this.svgIcon), namespace = _a[0], iconName = _a[1];\\n                __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_4\" /* first */].call(this._mdIconRegistry.getNamedSvgIcon(iconName, namespace)).subscribe(function (svg) { return _this._setSvgElement(svg); }, function (err) { return console.log(\"Error retrieving icon: \" + err.message); });\\n            }\\n        }\\n        if (this._usingFontIcon()) {\\n            this._updateFontIconClasses();\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdIcon.prototype.ngOnInit = function () {\\n        // Update font classes because ngOnChanges won\\'t be called if none of the inputs are present,\\n        // e.g. <md-icon>arrow</md-icon>. In this case we need to add a CSS class for the default font.\\n        if (this._usingFontIcon()) {\\n            this._updateFontIconClasses();\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdIcon.prototype._usingFontIcon = function () {\\n        return !this.svgIcon;\\n    };\\n    /**\\n     * @param {?} svg\\n     * @return {?}\\n     */\\n    MdIcon.prototype._setSvgElement = function (svg) {\\n        var /** @type {?} */ layoutElement = this._elementRef.nativeElement;\\n        // Remove existing child nodes and add the new SVG element.\\n        // We would use renderer.detachView(Array.from(layoutElement.childNodes)) here,\\n        // but it fails in IE11: https://github.com/angular/angular/issues/6327\\n        layoutElement.innerHTML = \\'\\';\\n        this._renderer.appendChild(layoutElement, svg);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdIcon.prototype._updateFontIconClasses = function () {\\n        if (!this._usingFontIcon()) {\\n            return;\\n        }\\n        var /** @type {?} */ elem = this._elementRef.nativeElement;\\n        var /** @type {?} */ fontSetClass = this.fontSet ?\\n            this._mdIconRegistry.classNameForFontAlias(this.fontSet) :\\n            this._mdIconRegistry.getDefaultFontSetClass();\\n        if (fontSetClass != this._previousFontSetClass) {\\n            if (this._previousFontSetClass) {\\n                this._renderer.removeClass(elem, this._previousFontSetClass);\\n            }\\n            if (fontSetClass) {\\n                this._renderer.addClass(elem, fontSetClass);\\n            }\\n            this._previousFontSetClass = fontSetClass;\\n        }\\n        if (this.fontIcon != this._previousFontIconClass) {\\n            if (this._previousFontIconClass) {\\n                this._renderer.removeClass(elem, this._previousFontIconClass);\\n            }\\n            if (this.fontIcon) {\\n                this._renderer.addClass(elem, this.fontIcon);\\n            }\\n            this._previousFontIconClass = this.fontIcon;\\n        }\\n    };\\n    return MdIcon;\\n}(_MdIconMixinBase));\\nMdIcon.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ template: \\'<ng-content></ng-content>\\',\\n                selector: \\'md-icon, mat-icon\\',\\n                styles: [\".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}\"],\\n                inputs: [\\'color\\'],\\n                host: {\\n                    \\'role\\': \\'img\\',\\n                    \\'class\\': \\'mat-icon\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdIcon.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: MdIconRegistry, },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Attribute\"], args: [\\'aria-hidden\\',] },] },\\n]; };\\nMdIcon.propDecorators = {\\n    \\'svgIcon\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'fontSet\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'fontIcon\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdIconModule = /*@__PURE__*/(function () {\\n    function MdIconModule() {\\n    }\\n    return MdIconModule;\\n}());\\nMdIconModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule],\\n                exports: [MdIcon, MdCommonModule],\\n                declarations: [MdIcon],\\n                providers: [ICON_REGISTRY_PROVIDER],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdIconModule.ctorParameters = function () { return []; };\\n/**\\n * A single degree in radians.\\n */\\nvar DEGREE_IN_RADIANS = Math.PI / 180;\\n/**\\n * Duration of the indeterminate animation.\\n */\\nvar DURATION_INDETERMINATE = 667;\\n/**\\n * Duration of the indeterminate animation.\\n */\\nvar DURATION_DETERMINATE = 225;\\n/**\\n * Start animation value of the indeterminate animation\\n */\\nvar startIndeterminate = 3;\\n/**\\n * End animation value of the indeterminate animation\\n */\\nvar endIndeterminate = 80;\\n/**\\n * Maximum angle for the arc. The angle can\\'t be exactly 360, because the arc becomes hidden.\\n */\\nvar MAX_ANGLE = 359.99 / 100;\\n/**\\n * Whether the user\\'s browser supports requestAnimationFrame.\\n */\\nvar HAS_RAF = typeof requestAnimationFrame !== \\'undefined\\';\\n/**\\n * Default stroke width as a percentage of the viewBox.\\n */\\nvar PROGRESS_SPINNER_STROKE_WIDTH = 10;\\n/**\\n * Directive whose purpose is to add the mat- CSS styling to this selector.\\n * \\\\@docs-private\\n */\\nvar MdProgressSpinnerCssMatStyler = /*@__PURE__*/(function () {\\n    function MdProgressSpinnerCssMatStyler() {\\n    }\\n    return MdProgressSpinnerCssMatStyler;\\n}());\\nMdProgressSpinnerCssMatStyler.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-progress-spinner, mat-progress-spinner\\',\\n                host: { \\'class\\': \\'mat-progress-spinner\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdProgressSpinnerCssMatStyler.ctorParameters = function () { return []; };\\n/**\\n * \\\\@docs-private\\n */\\nvar MdProgressSpinnerBase = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdProgressSpinnerBase(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n    }\\n    return MdProgressSpinnerBase;\\n}());\\nvar _MdProgressSpinnerMixinBase = mixinColor(MdProgressSpinnerBase, \\'primary\\');\\n/**\\n * <md-progress-spinner> component.\\n */\\nvar MdProgressSpinner = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdProgressSpinner, _super);\\n    /**\\n     * @param {?} renderer\\n     * @param {?} elementRef\\n     * @param {?} _ngZone\\n     */\\n    function MdProgressSpinner(renderer, elementRef, _ngZone) {\\n        var _this = _super.call(this, renderer, elementRef) || this;\\n        _this._ngZone = _ngZone;\\n        /**\\n         * The id of the last requested animation.\\n         */\\n        _this._lastAnimationId = 0;\\n        _this._mode = \\'determinate\\';\\n        /**\\n         * Stroke width of the progress spinner. By default uses 10px as stroke width.\\n         */\\n        _this.strokeWidth = PROGRESS_SPINNER_STROKE_WIDTH;\\n        return _this;\\n    }\\n    Object.defineProperty(MdProgressSpinner.prototype, \"_ariaValueMin\", {\\n        /**\\n         * Values for aria max and min are only defined as numbers when in a determinate mode.  We do this\\n         * because voiceover does not report the progress indicator as indeterminate if the aria min\\n         * and/or max value are number values.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.mode == \\'determinate\\' ? 0 : null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdProgressSpinner.prototype, \"_ariaValueMax\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.mode == \\'determinate\\' ? 100 : null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdProgressSpinner.prototype, \"interdeterminateInterval\", {\\n        /**\\n         * \\\\@docs-private\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._interdeterminateInterval;\\n        },\\n        /**\\n         * \\\\@docs-private\\n         * @param {?} interval\\n         * @return {?}\\n         */\\n        set: function (interval) {\\n            if (this._interdeterminateInterval) {\\n                clearInterval(this._interdeterminateInterval);\\n            }\\n            this._interdeterminateInterval = interval;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Clean up any animations that were running.\\n     * @return {?}\\n     */\\n    MdProgressSpinner.prototype.ngOnDestroy = function () {\\n        this._cleanupIndeterminateAnimation();\\n    };\\n    Object.defineProperty(MdProgressSpinner.prototype, \"value\", {\\n        /**\\n         * Value of the progress circle. It is bound to the host as the attribute aria-valuenow.\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (this.mode == \\'determinate\\') {\\n                return this._value;\\n            }\\n            return 0;\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            if (v != null && this.mode == \\'determinate\\') {\\n                var /** @type {?} */ newValue = clamp(v);\\n                this._animateCircle(this.value || 0, newValue);\\n                this._value = newValue;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdProgressSpinner.prototype, \"mode\", {\\n        /**\\n         * Mode of the progress circle\\n         *\\n         * Input must be one of the values from ProgressMode, defaults to \\'determinate\\'.\\n         * mode is bound to the host as the attribute host.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._mode;\\n        },\\n        /**\\n         * @param {?} mode\\n         * @return {?}\\n         */\\n        set: function (mode) {\\n            if (mode !== this._mode) {\\n                if (mode === \\'indeterminate\\') {\\n                    this._startIndeterminateAnimation();\\n                }\\n                else {\\n                    this._cleanupIndeterminateAnimation();\\n                    this._animateCircle(0, this._value);\\n                }\\n                this._mode = mode;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Animates the circle from one percentage value to another.\\n     *\\n     * @param {?} animateFrom The percentage of the circle filled starting the animation.\\n     * @param {?} animateTo The percentage of the circle filled ending the animation.\\n     * @param {?=} ease The easing function to manage the pace of change in the animation.\\n     * @param {?=} duration The length of time to show the animation, in milliseconds.\\n     * @param {?=} rotation The starting angle of the circle fill, with 0° represented at the top center\\n     *    of the circle.\\n     * @return {?}\\n     */\\n    MdProgressSpinner.prototype._animateCircle = function (animateFrom, animateTo, ease, duration, rotation) {\\n        var _this = this;\\n        if (ease === void 0) { ease = linearEase; }\\n        if (duration === void 0) { duration = DURATION_DETERMINATE; }\\n        if (rotation === void 0) { rotation = 0; }\\n        var /** @type {?} */ id = ++this._lastAnimationId;\\n        var /** @type {?} */ startTime = Date.now();\\n        var /** @type {?} */ changeInValue = animateTo - animateFrom;\\n        // No need to animate it if the values are the same\\n        if (animateTo === animateFrom) {\\n            this._renderArc(animateTo, rotation);\\n        }\\n        else {\\n            var /** @type {?} */ animation_1 = function () {\\n                // If there is no requestAnimationFrame, skip ahead to the end of the animation.\\n                var /** @type {?} */ elapsedTime = HAS_RAF ?\\n                    Math.max(0, Math.min(Date.now() - startTime, duration)) :\\n                    duration;\\n                _this._renderArc(ease(elapsedTime, animateFrom, changeInValue, duration), rotation);\\n                // Prevent overlapping animations by checking if a new animation has been called for and\\n                // if the animation has lasted longer than the animation duration.\\n                if (id === _this._lastAnimationId && elapsedTime < duration) {\\n                    requestAnimationFrame(animation_1);\\n                }\\n            };\\n            // Run the animation outside of Angular\\'s zone, in order to avoid\\n            // hitting ZoneJS and change detection on each frame.\\n            this._ngZone.runOutsideAngular(animation_1);\\n        }\\n    };\\n    /**\\n     * Starts the indeterminate animation interval, if it is not already running.\\n     * @return {?}\\n     */\\n    MdProgressSpinner.prototype._startIndeterminateAnimation = function () {\\n        var _this = this;\\n        var /** @type {?} */ rotationStartPoint = 0;\\n        var /** @type {?} */ start = startIndeterminate;\\n        var /** @type {?} */ end = endIndeterminate;\\n        var /** @type {?} */ duration = DURATION_INDETERMINATE;\\n        var /** @type {?} */ animate$$1 = function () {\\n            _this._animateCircle(start, end, materialEase, duration, rotationStartPoint);\\n            // Prevent rotation from reaching Number.MAX_SAFE_INTEGER.\\n            rotationStartPoint = (rotationStartPoint + end) % 100;\\n            var /** @type {?} */ temp = start;\\n            start = -end;\\n            end = -temp;\\n        };\\n        if (!this.interdeterminateInterval) {\\n            this._ngZone.runOutsideAngular(function () {\\n                _this.interdeterminateInterval = setInterval(animate$$1, duration + 50, 0, false);\\n                animate$$1();\\n            });\\n        }\\n    };\\n    /**\\n     * Removes interval, ending the animation.\\n     * @return {?}\\n     */\\n    MdProgressSpinner.prototype._cleanupIndeterminateAnimation = function () {\\n        this.interdeterminateInterval = null;\\n    };\\n    /**\\n     * Renders the arc onto the SVG element. Proxies `getArc` while setting the proper\\n     * DOM attribute on the `<path>`.\\n     * @param {?} currentValue\\n     * @param {?=} rotation\\n     * @return {?}\\n     */\\n    MdProgressSpinner.prototype._renderArc = function (currentValue, rotation) {\\n        if (rotation === void 0) { rotation = 0; }\\n        if (this._path) {\\n            var /** @type {?} */ svgArc = getSvgArc(currentValue, rotation, this.strokeWidth);\\n            this._renderer.setAttribute(this._path.nativeElement, \\'d\\', svgArc);\\n        }\\n    };\\n    return MdProgressSpinner;\\n}(_MdProgressSpinnerMixinBase));\\nMdProgressSpinner.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-progress-spinner, mat-progress-spinner\\',\\n                host: {\\n                    \\'role\\': \\'progressbar\\',\\n                    \\'[attr.aria-valuemin]\\': \\'_ariaValueMin\\',\\n                    \\'[attr.aria-valuemax]\\': \\'_ariaValueMax\\'\\n                },\\n                inputs: [\\'color\\'],\\n                template: \"<svg viewBox=\\\\\"0 0 100 100\\\\\" preserveAspectRatio=\\\\\"xMidYMid meet\\\\\"><path #path [style.strokeWidth]=\\\\\"strokeWidth\\\\\"></path></svg>\",\\n                styles: [\":host{display:block;height:100px;width:100px;overflow:hidden}:host svg{height:100%;width:100%;transform-origin:center}:host path{fill:transparent;transition:stroke .3s cubic-bezier(.35,0,.25,1)}:host[mode=indeterminate] svg{animation-duration:5.25s,2.887s;animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;animation-timing-function:cubic-bezier(.35,0,.25,1),linear;animation-iteration-count:infinite;transition:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-sporadic-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}\"],\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdProgressSpinner.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\nMdProgressSpinner.propDecorators = {\\n    \\'_path\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'path\\',] },],\\n    \\'strokeWidth\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'attr.aria-valuenow\\',] },],\\n    \\'mode\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'attr.mode\\',] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * <md-spinner> component.\\n *\\n * This is a component definition to be used as a convenience reference to create an\\n * indeterminate <md-progress-spinner> instance.\\n */\\nvar MdSpinner = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdSpinner, _super);\\n    /**\\n     * @param {?} elementRef\\n     * @param {?} ngZone\\n     * @param {?} renderer\\n     */\\n    function MdSpinner(elementRef, ngZone, renderer) {\\n        var _this = _super.call(this, renderer, elementRef, ngZone) || this;\\n        _this.mode = \\'indeterminate\\';\\n        return _this;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdSpinner.prototype.ngOnDestroy = function () {\\n        // The `ngOnDestroy` from `MdProgressSpinner` should be called explicitly, because\\n        // in certain cases Angular won\\'t call it (e.g. when using AoT and in unit tests).\\n        _super.prototype.ngOnDestroy.call(this);\\n    };\\n    return MdSpinner;\\n}(MdProgressSpinner));\\nMdSpinner.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-spinner, mat-spinner\\',\\n                host: {\\n                    \\'role\\': \\'progressbar\\',\\n                    \\'mode\\': \\'indeterminate\\',\\n                    \\'class\\': \\'mat-spinner\\',\\n                },\\n                inputs: [\\'color\\'],\\n                template: \"<svg viewBox=\\\\\"0 0 100 100\\\\\" preserveAspectRatio=\\\\\"xMidYMid meet\\\\\"><path #path [style.strokeWidth]=\\\\\"strokeWidth\\\\\"></path></svg>\",\\n                styles: [\":host{display:block;height:100px;width:100px;overflow:hidden}:host svg{height:100%;width:100%;transform-origin:center}:host path{fill:transparent;transition:stroke .3s cubic-bezier(.35,0,.25,1)}:host[mode=indeterminate] svg{animation-duration:5.25s,2.887s;animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;animation-timing-function:cubic-bezier(.35,0,.25,1),linear;animation-iteration-count:infinite;transition:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-sporadic-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}\"],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSpinner.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\n/**\\n * Clamps a value to be between 0 and 100.\\n * @param {?} v\\n * @return {?}\\n */\\nfunction clamp(v) {\\n    return Math.max(0, Math.min(100, v));\\n}\\n/**\\n * Converts Polar coordinates to Cartesian.\\n * @param {?} radius\\n * @param {?} pathRadius\\n * @param {?} angleInDegrees\\n * @return {?}\\n */\\nfunction polarToCartesian(radius, pathRadius, angleInDegrees) {\\n    var /** @type {?} */ angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;\\n    return (radius + (pathRadius * Math.cos(angleInRadians))) +\\n        \\',\\' + (radius + (pathRadius * Math.sin(angleInRadians)));\\n}\\n/**\\n * Easing function for linear animation.\\n * @param {?} currentTime\\n * @param {?} startValue\\n * @param {?} changeInValue\\n * @param {?} duration\\n * @return {?}\\n */\\nfunction linearEase(currentTime, startValue, changeInValue, duration) {\\n    return changeInValue * currentTime / duration + startValue;\\n}\\n/**\\n * Easing function to match material design indeterminate animation.\\n * @param {?} currentTime\\n * @param {?} startValue\\n * @param {?} changeInValue\\n * @param {?} duration\\n * @return {?}\\n */\\nfunction materialEase(currentTime, startValue, changeInValue, duration) {\\n    var /** @type {?} */ time = currentTime / duration;\\n    var /** @type {?} */ timeCubed = Math.pow(time, 3);\\n    var /** @type {?} */ timeQuad = Math.pow(time, 4);\\n    var /** @type {?} */ timeQuint = Math.pow(time, 5);\\n    return startValue + changeInValue * ((6 * timeQuint) + (-15 * timeQuad) + (10 * timeCubed));\\n}\\n/**\\n * Determines the path value to define the arc.  Converting percentage values to to polar\\n * coordinates on the circle, and then to cartesian coordinates in the viewport.\\n *\\n * @param {?} currentValue The current percentage value of the progress circle, the percentage of the\\n *    circle to fill.\\n * @param {?} rotation The starting point of the circle with 0 being the 0 degree point.\\n * @param {?} strokeWidth Stroke width of the progress spinner arc.\\n * @return {?} A string for an SVG path representing a circle filled from the starting point to the\\n *    percentage value provided.\\n */\\nfunction getSvgArc(currentValue, rotation, strokeWidth) {\\n    var /** @type {?} */ startPoint = rotation || 0;\\n    var /** @type {?} */ radius = 50;\\n    var /** @type {?} */ pathRadius = radius - strokeWidth;\\n    var /** @type {?} */ startAngle = startPoint * MAX_ANGLE;\\n    var /** @type {?} */ endAngle = currentValue * MAX_ANGLE;\\n    var /** @type {?} */ start = polarToCartesian(radius, pathRadius, startAngle);\\n    var /** @type {?} */ end = polarToCartesian(radius, pathRadius, endAngle + startAngle);\\n    var /** @type {?} */ arcSweep = endAngle < 0 ? 0 : 1;\\n    var /** @type {?} */ largeArcFlag;\\n    if (endAngle < 0) {\\n        largeArcFlag = endAngle >= -180 ? 0 : 1;\\n    }\\n    else {\\n        largeArcFlag = endAngle <= 180 ? 0 : 1;\\n    }\\n    return \"M\" + start + \"A\" + pathRadius + \",\" + pathRadius + \" 0 \" + largeArcFlag + \",\" + arcSweep + \" \" + end;\\n}\\nvar MdProgressSpinnerModule = /*@__PURE__*/(function () {\\n    function MdProgressSpinnerModule() {\\n    }\\n    return MdProgressSpinnerModule;\\n}());\\nMdProgressSpinnerModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule],\\n                exports: [\\n                    MdProgressSpinner,\\n                    MdSpinner,\\n                    MdCommonModule,\\n                    MdProgressSpinnerCssMatStyler\\n                ],\\n                declarations: [\\n                    MdProgressSpinner,\\n                    MdSpinner,\\n                    MdProgressSpinnerCssMatStyler\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdProgressSpinnerModule.ctorParameters = function () { return []; };\\n/**\\n * <md-progress-bar> component.\\n */\\nvar MdProgressBar = /*@__PURE__*/(function () {\\n    function MdProgressBar() {\\n        /**\\n         * Color of the progress bar.\\n         */\\n        this.color = \\'primary\\';\\n        this._value = 0;\\n        this._bufferValue = 0;\\n        /**\\n         * Mode of the progress bar.\\n         *\\n         * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to\\n         * \\'determinate\\'.\\n         * Mirrored to mode attribute.\\n         */\\n        this.mode = \\'determinate\\';\\n    }\\n    Object.defineProperty(MdProgressBar.prototype, \"value\", {\\n        /**\\n         * Value of the progressbar. Defaults to zero. Mirrored to aria-valuenow.\\n         * @return {?}\\n         */\\n        get: function () { return this._value; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this._value = clamp$1(v || 0); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdProgressBar.prototype, \"bufferValue\", {\\n        /**\\n         * Buffer value of the progress bar. Defaults to zero.\\n         * @return {?}\\n         */\\n        get: function () { return this._bufferValue; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this._bufferValue = clamp$1(v || 0); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Gets the current transform value for the progress bar\\'s primary indicator.\\n     * @return {?}\\n     */\\n    MdProgressBar.prototype._primaryTransform = function () {\\n        var /** @type {?} */ scale = this.value / 100;\\n        return { transform: \"scaleX(\" + scale + \")\" };\\n    };\\n    /**\\n     * Gets the current transform value for the progress bar\\'s buffer indicator.  Only used if the\\n     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.\\n     * @return {?}\\n     */\\n    MdProgressBar.prototype._bufferTransform = function () {\\n        if (this.mode == \\'buffer\\') {\\n            var /** @type {?} */ scale = this.bufferValue / 100;\\n            return { transform: \"scaleX(\" + scale + \")\" };\\n        }\\n    };\\n    return MdProgressBar;\\n}());\\nMdProgressBar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-progress-bar, mat-progress-bar\\',\\n                host: {\\n                    \\'role\\': \\'progressbar\\',\\n                    \\'aria-valuemin\\': \\'0\\',\\n                    \\'aria-valuemax\\': \\'100\\',\\n                    \\'[class.mat-primary]\\': \\'color == \"primary\"\\',\\n                    \\'[class.mat-accent]\\': \\'color == \"accent\"\\',\\n                    \\'[class.mat-warn]\\': \\'color == \"warn\"\\',\\n                    \\'class\\': \\'mat-progress-bar\\',\\n                },\\n                template: \"<div class=\\\\\"mat-progress-bar-background mat-progress-bar-element\\\\\"></div><div class=\\\\\"mat-progress-bar-buffer mat-progress-bar-element\\\\\" [ngStyle]=\\\\\"_bufferTransform()\\\\\"></div><div class=\\\\\"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\\\\\" [ngStyle]=\\\\\"_primaryTransform()\\\\\"></div><div class=\\\\\"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\\\\\"></div>\",\\n                styles: [\":host{display:block;height:5px;overflow:hidden;position:relative;transform:translateZ(0);transition:opacity 250ms linear;width:100%}:host .mat-progress-bar-element,:host .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}:host .mat-progress-bar-background{background-repeat:repeat-x;background-size:10px 4px;display:none}:host .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease,stroke .3s cubic-bezier(.35,0,.25,1)}:host .mat-progress-bar-secondary{display:none}:host .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease,stroke .3s cubic-bezier(.35,0,.25,1)}:host .mat-progress-bar-fill::after{animation:none;content:\\'\\';display:inline-block;left:0}:host[mode=query]{transform:rotateZ(180deg)}:host[mode=indeterminate] .mat-progress-bar-fill,:host[mode=query] .mat-progress-bar-fill{transition:none}:host[mode=indeterminate] .mat-progress-bar-primary,:host[mode=query] .mat-progress-bar-primary{animation:mat-progress-bar-primary-indeterminate-translate 2s infinite linear;left:-145.166611%}:host[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,:host[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{animation:mat-progress-bar-primary-indeterminate-scale 2s infinite linear}:host[mode=indeterminate] .mat-progress-bar-secondary,:host[mode=query] .mat-progress-bar-secondary{animation:mat-progress-bar-secondary-indeterminate-translate 2s infinite linear;left:-54.888891%;display:block}:host[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,:host[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{animation:mat-progress-bar-secondary-indeterminate-scale 2s infinite linear}:host[mode=buffer] .mat-progress-bar-background{animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}:host-context([dir=rtl]){transform:rotateY(180deg)}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(.5,0,.70173,.49582);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);transform:translateX(83.67142%)}100%{transform:translateX(200.61106%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.66148)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:translateX(37.65191%)}48.35%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:translateX(84.38617%)}100%{transform:translateX(160.27778%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:scaleX(.4571)}44.15%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:scaleX(.72796)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-10px)}}\"],\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdProgressBar.ctorParameters = function () { return []; };\\nMdProgressBar.propDecorators = {\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'attr.aria-valuenow\\',] },],\\n    \\'bufferValue\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'mode\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'attr.mode\\',] },],\\n};\\n/**\\n * Clamps a value to be between two numbers, by default 0 and 100.\\n * @param {?} v\\n * @param {?=} min\\n * @param {?=} max\\n * @return {?}\\n */\\nfunction clamp$1(v, min, max) {\\n    if (min === void 0) { min = 0; }\\n    if (max === void 0) { max = 100; }\\n    return Math.max(min, Math.min(max, v));\\n}\\nvar MdProgressBarModule = /*@__PURE__*/(function () {\\n    function MdProgressBarModule() {\\n    }\\n    return MdProgressBarModule;\\n}());\\nMdProgressBarModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"], MdCommonModule],\\n                exports: [MdProgressBar, MdCommonModule],\\n                declarations: [MdProgressBar],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdProgressBarModule.ctorParameters = function () { return []; };\\n/**\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdInputContainerPlaceholderConflictError() {\\n    return Error(\\'Placeholder attribute and child element were both specified.\\');\\n}\\n/**\\n * \\\\@docs-private\\n * @param {?} type\\n * @return {?}\\n */\\nfunction getMdInputContainerUnsupportedTypeError(type) {\\n    return Error(\"Input type \\\\\"\" + type + \"\\\\\" isn\\'t supported by md-input-container.\");\\n}\\n/**\\n * \\\\@docs-private\\n * @param {?} align\\n * @return {?}\\n */\\nfunction getMdInputContainerDuplicatedHintError(align) {\\n    return Error(\"A hint was already declared for \\'align=\\\\\"\" + align + \"\\\\\"\\'.\");\\n}\\n/**\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdInputContainerMissingMdInputError() {\\n    return Error(\\'md-input-container must contain an mdInput directive. \\' +\\n        \\'Did you forget to add mdInput to the native input or textarea element?\\');\\n}\\n// Invalid input type. Using one of these will throw an MdInputContainerUnsupportedTypeError.\\nvar MD_INPUT_INVALID_TYPES = [\\n    \\'button\\',\\n    \\'checkbox\\',\\n    \\'color\\',\\n    \\'file\\',\\n    \\'hidden\\',\\n    \\'image\\',\\n    \\'radio\\',\\n    \\'range\\',\\n    \\'reset\\',\\n    \\'submit\\'\\n];\\nvar nextUniqueId$1 = 0;\\n/**\\n * The placeholder directive. The content can declare this to implement more\\n * complex placeholders.\\n */\\nvar MdPlaceholder = /*@__PURE__*/(function () {\\n    function MdPlaceholder() {\\n    }\\n    return MdPlaceholder;\\n}());\\nMdPlaceholder.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-placeholder, mat-placeholder\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPlaceholder.ctorParameters = function () { return []; };\\n/**\\n * Hint text to be shown underneath the input.\\n */\\nvar MdHint = /*@__PURE__*/(function () {\\n    function MdHint() {\\n        /**\\n         * Whether to align the hint label at the start or end of the line.\\n         */\\n        this.align = \\'start\\';\\n        /**\\n         * Unique ID for the hint. Used for the aria-describedby on the input.\\n         */\\n        this.id = \"md-input-hint-\" + nextUniqueId$1++;\\n    }\\n    return MdHint;\\n}());\\nMdHint.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-hint, mat-hint\\',\\n                host: {\\n                    \\'class\\': \\'mat-hint\\',\\n                    \\'[class.mat-right]\\': \\'align == \"end\"\\',\\n                    \\'[attr.id]\\': \\'id\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdHint.ctorParameters = function () { return []; };\\nMdHint.propDecorators = {\\n    \\'align\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Single error message to be shown underneath the input.\\n */\\nvar MdErrorDirective = /*@__PURE__*/(function () {\\n    function MdErrorDirective() {\\n    }\\n    return MdErrorDirective;\\n}());\\nMdErrorDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-error, mat-error\\',\\n                host: {\\n                    \\'class\\': \\'mat-input-error\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdErrorDirective.ctorParameters = function () { return []; };\\n/**\\n * Prefix to be placed the the front of the input.\\n */\\nvar MdPrefix = /*@__PURE__*/(function () {\\n    function MdPrefix() {\\n    }\\n    return MdPrefix;\\n}());\\nMdPrefix.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[mdPrefix], [matPrefix], [md-prefix]\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPrefix.ctorParameters = function () { return []; };\\n/**\\n * Suffix to be placed at the end of the input.\\n */\\nvar MdSuffix = /*@__PURE__*/(function () {\\n    function MdSuffix() {\\n    }\\n    return MdSuffix;\\n}());\\nMdSuffix.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[mdSuffix], [matSuffix], [md-suffix]\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSuffix.ctorParameters = function () { return []; };\\n/**\\n * Marker for the input element that `MdInputContainer` is wrapping.\\n */\\nvar MdInputDirective = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     * @param {?} _platform\\n     * @param {?} _ngControl\\n     * @param {?} _parentForm\\n     * @param {?} _parentFormGroup\\n     * @param {?} errorOptions\\n     */\\n    function MdInputDirective(_elementRef, _renderer, _platform, _ngControl, _parentForm, _parentFormGroup, errorOptions) {\\n        this._elementRef = _elementRef;\\n        this._renderer = _renderer;\\n        this._platform = _platform;\\n        this._ngControl = _ngControl;\\n        this._parentForm = _parentForm;\\n        this._parentFormGroup = _parentFormGroup;\\n        /**\\n         * Variables used as cache for getters and setters.\\n         */\\n        this._type = \\'text\\';\\n        this._placeholder = \\'\\';\\n        this._disabled = false;\\n        this._required = false;\\n        /**\\n         * Whether the element is focused or not.\\n         */\\n        this.focused = false;\\n        /**\\n         * Emits an event when the placeholder changes so that the `md-input-container` can re-validate.\\n         */\\n        this._placeholderChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        this._neverEmptyInputTypes = [\\n            \\'date\\',\\n            \\'datetime\\',\\n            \\'datetime-local\\',\\n            \\'month\\',\\n            \\'time\\',\\n            \\'week\\'\\n        ].filter(function (t) { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_5\" /* getSupportedInputTypes */]().has(t); });\\n        // Force setter to be called in case id was not specified.\\n        this.id = this.id;\\n        this._errorOptions = errorOptions ? errorOptions : {};\\n        this.errorStateMatcher = this._errorOptions.errorStateMatcher || defaultErrorStateMatcher;\\n    }\\n    Object.defineProperty(MdInputDirective.prototype, \"disabled\", {\\n        /**\\n         * Whether the element is disabled.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._ngControl ? this._ngControl.disabled : this._disabled;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"id\", {\\n        /**\\n         * Unique id of the element.\\n         * @return {?}\\n         */\\n        get: function () { return this._id; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._id = value || this._uid; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"placeholder\", {\\n        /**\\n         * Placeholder attribute of the element.\\n         * @return {?}\\n         */\\n        get: function () { return this._placeholder; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._placeholder !== value) {\\n                this._placeholder = value;\\n                this._placeholderChange.emit(this._placeholder);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"required\", {\\n        /**\\n         * Whether the element is required.\\n         * @return {?}\\n         */\\n        get: function () { return this._required; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._required = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"type\", {\\n        /**\\n         * Input type of the element.\\n         * @return {?}\\n         */\\n        get: function () { return this._type; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._type = value || \\'text\\';\\n            this._validateType();\\n            // When using Angular inputs, developers are no longer able to set the properties on the native\\n            // input element. To ensure that bindings for `type` work, we need to sync the setter\\n            // with the native property. Textarea elements don\\'t support the type property or attribute.\\n            if (!this._isTextarea() && __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_5\" /* getSupportedInputTypes */]().has(this._type)) {\\n                this._renderer.setProperty(this._elementRef.nativeElement, \\'type\\', this._type);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"value\", {\\n        /**\\n         * The input element\\'s value.\\n         * @return {?}\\n         */\\n        get: function () { return this._elementRef.nativeElement.value; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._elementRef.nativeElement.value = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"empty\", {\\n        /**\\n         * Whether the input is empty.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return !this._isNeverEmpty() &&\\n                (this.value == null || this.value === \\'\\') &&\\n                // Check if the input contains bad input. If so, we know that it only appears empty because\\n                // the value failed to parse. From the user\\'s perspective it is not empty.\\n                // TODO(mmalerba): Add e2e test for bad input case.\\n                !this._isBadInput();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputDirective.prototype, \"_uid\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._cachedUid = this._cachedUid || \"md-input-\" + nextUniqueId$1++; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Focuses the input element.\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype.focus = function () { this._elementRef.nativeElement.focus(); };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._onFocus = function () { this.focused = true; };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._onBlur = function () { this.focused = false; };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._onInput = function () {\\n        // This is a noop function and is used to let Angular know whenever the value changes.\\n        // Angular will run a new change detection each time the `input` event has been dispatched.\\n        // It\\'s necessary that Angular recognizes the value change, because when floatingLabel\\n        // is set to false and Angular forms aren\\'t used, the placeholder won\\'t recognize the\\n        // value changes and will not disappear.\\n        // Listening to the input event wouldn\\'t be necessary when the input is using the\\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\\n    };\\n    /**\\n     * Whether the input is in an error state.\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._isErrorState = function () {\\n        var /** @type {?} */ control = this._ngControl;\\n        var /** @type {?} */ form = this._parentFormGroup || this._parentForm;\\n        return control && this.errorStateMatcher(/** @type {?} */ (control.control), form);\\n    };\\n    /**\\n     * Make sure the input is a supported type.\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._validateType = function () {\\n        if (MD_INPUT_INVALID_TYPES.indexOf(this._type) !== -1) {\\n            throw getMdInputContainerUnsupportedTypeError(this._type);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._isNeverEmpty = function () { return this._neverEmptyInputTypes.indexOf(this._type) !== -1; };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._isBadInput = function () {\\n        // The `validity` property won\\'t be present on platform-server.\\n        var /** @type {?} */ validity = ((this._elementRef.nativeElement)).validity;\\n        return validity && validity.badInput;\\n    };\\n    /**\\n     * Determines if the component host is a textarea. If not recognizable it returns false.\\n     * @return {?}\\n     */\\n    MdInputDirective.prototype._isTextarea = function () {\\n        var /** @type {?} */ nativeElement = this._elementRef.nativeElement;\\n        // In Universal, we don\\'t have access to `nodeName`, but the same can be achieved with `name`.\\n        // Note that this shouldn\\'t be necessary once Angular switches to an API that resembles the\\n        // DOM closer.\\n        var /** @type {?} */ nodeName = this._platform.isBrowser ? nativeElement.nodeName : nativeElement.name;\\n        return nodeName ? nodeName.toLowerCase() === \\'textarea\\' : false;\\n    };\\n    return MdInputDirective;\\n}());\\nMdInputDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \"input[mdInput], textarea[mdInput], input[matInput], textarea[matInput]\",\\n                host: {\\n                    \\'class\\': \\'mat-input-element\\',\\n                    // Native input properties that are overwritten by Angular inputs need to be synced with\\n                    // the native input element. Otherwise property bindings for those don\\'t work.\\n                    \\'[id]\\': \\'id\\',\\n                    \\'[placeholder]\\': \\'placeholder\\',\\n                    \\'[disabled]\\': \\'disabled\\',\\n                    \\'[required]\\': \\'required\\',\\n                    \\'[attr.aria-describedby]\\': \\'ariaDescribedby || null\\',\\n                    \\'[attr.aria-invalid]\\': \\'_isErrorState()\\',\\n                    \\'(blur)\\': \\'_onBlur()\\',\\n                    \\'(focus)\\': \\'_onFocus()\\',\\n                    \\'(input)\\': \\'_onInput()\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdInputDirective.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */], },\\n    { type: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NgControl\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NgForm\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"FormGroupDirective\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_ERROR_GLOBAL_OPTIONS,] },] },\\n]; };\\nMdInputDirective.propDecorators = {\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'placeholder\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'required\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'type\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'errorStateMatcher\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_placeholderChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Container for text inputs that applies Material Design styling and behavior.\\n */\\nvar MdInputContainer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _changeDetectorRef\\n     * @param {?} placeholderOptions\\n     */\\n    function MdInputContainer(_elementRef, _changeDetectorRef, placeholderOptions) {\\n        this._elementRef = _elementRef;\\n        this._changeDetectorRef = _changeDetectorRef;\\n        /**\\n         * Color of the input divider, based on the theme.\\n         */\\n        this.color = \\'primary\\';\\n        /**\\n         * State of the md-hint and md-error animations.\\n         */\\n        this._subscriptAnimationState = \\'\\';\\n        this._hintLabel = \\'\\';\\n        // Unique id for the hint label.\\n        this._hintLabelId = \"md-input-hint-\" + nextUniqueId$1++;\\n        this._placeholderOptions = placeholderOptions ? placeholderOptions : {};\\n        this.floatPlaceholder = this._placeholderOptions.float || \\'auto\\';\\n    }\\n    Object.defineProperty(MdInputContainer.prototype, \"dividerColor\", {\\n        /**\\n         * @deprecated Use color instead.\\n         * @return {?}\\n         */\\n        get: function () { return this.color; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this.color = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputContainer.prototype, \"hideRequiredMarker\", {\\n        /**\\n         * Whether the required marker should be hidden.\\n         * @return {?}\\n         */\\n        get: function () { return this._hideRequiredMarker; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._hideRequiredMarker = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputContainer.prototype, \"_shouldAlwaysFloat\", {\\n        /**\\n         * Whether the floating label should always float or not.\\n         * @return {?}\\n         */\\n        get: function () { return this._floatPlaceholder === \\'always\\'; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputContainer.prototype, \"_canPlaceholderFloat\", {\\n        /**\\n         * Whether the placeholder can float or not.\\n         * @return {?}\\n         */\\n        get: function () { return this._floatPlaceholder !== \\'never\\'; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputContainer.prototype, \"hintLabel\", {\\n        /**\\n         * Text for the input hint.\\n         * @return {?}\\n         */\\n        get: function () { return this._hintLabel; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._hintLabel = value;\\n            this._processHints();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdInputContainer.prototype, \"floatPlaceholder\", {\\n        /**\\n         * Whether the placeholder should always float, never float or float as the user types.\\n         * @return {?}\\n         */\\n        get: function () { return this._floatPlaceholder; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._floatPlaceholder = value || this._placeholderOptions.float || \\'auto\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._validateInputChild();\\n        this._processHints();\\n        this._validatePlaceholders();\\n        // Re-validate when things change.\\n        this._hintChildren.changes.subscribe(function () { return _this._processHints(); });\\n        this._mdInputChild._placeholderChange.subscribe(function () { return _this._validatePlaceholders(); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype.ngAfterContentChecked = function () {\\n        this._validateInputChild();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype.ngAfterViewInit = function () {\\n        // Avoid animations on load.\\n        this._subscriptAnimationState = \\'enter\\';\\n        this._changeDetectorRef.detectChanges();\\n    };\\n    /**\\n     * Determines whether a class from the NgControl should be forwarded to the host element.\\n     * @param {?} prop\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._shouldForward = function (prop) {\\n        var /** @type {?} */ control = this._mdInputChild ? this._mdInputChild._ngControl : null;\\n        return control && ((control))[prop];\\n    };\\n    /**\\n     * Whether the input has a placeholder.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._hasPlaceholder = function () { return !!(this._mdInputChild.placeholder || this._placeholderChild); };\\n    /**\\n     * Focuses the underlying input.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._focusInput = function () { this._mdInputChild.focus(); };\\n    /**\\n     * Determines whether to display hints or errors.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._getDisplayedMessages = function () {\\n        var /** @type {?} */ input = this._mdInputChild;\\n        return (this._errorChildren.length > 0 && input._isErrorState()) ? \\'error\\' : \\'hint\\';\\n    };\\n    /**\\n     * Ensure that there is only one placeholder (either `input` attribute or child element with the\\n     * `md-placeholder` attribute.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._validatePlaceholders = function () {\\n        if (this._mdInputChild.placeholder && this._placeholderChild) {\\n            throw getMdInputContainerPlaceholderConflictError();\\n        }\\n    };\\n    /**\\n     * Does any extra processing that is required when handling the hints.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._processHints = function () {\\n        this._validateHints();\\n        this._syncAriaDescribedby();\\n    };\\n    /**\\n     * Ensure that there is a maximum of one of each `<md-hint>` alignment specified, with the\\n     * attribute being considered as `align=\"start\"`.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._validateHints = function () {\\n        var _this = this;\\n        if (this._hintChildren) {\\n            var /** @type {?} */ startHint_1;\\n            var /** @type {?} */ endHint_1;\\n            this._hintChildren.forEach(function (hint) {\\n                if (hint.align == \\'start\\') {\\n                    if (startHint_1 || _this.hintLabel) {\\n                        throw getMdInputContainerDuplicatedHintError(\\'start\\');\\n                    }\\n                    startHint_1 = hint;\\n                }\\n                else if (hint.align == \\'end\\') {\\n                    if (endHint_1) {\\n                        throw getMdInputContainerDuplicatedHintError(\\'end\\');\\n                    }\\n                    endHint_1 = hint;\\n                }\\n            });\\n        }\\n    };\\n    /**\\n     * Sets the child input\\'s `aria-describedby` to a space-separated list of the ids\\n     * of the currently-specified hints, as well as a generated id for the hint label.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._syncAriaDescribedby = function () {\\n        if (this._mdInputChild) {\\n            var /** @type {?} */ ids = [];\\n            var /** @type {?} */ startHint = this._hintChildren ?\\n                this._hintChildren.find(function (hint) { return hint.align === \\'start\\'; }) : null;\\n            var /** @type {?} */ endHint = this._hintChildren ?\\n                this._hintChildren.find(function (hint) { return hint.align === \\'end\\'; }) : null;\\n            if (startHint) {\\n                ids.push(startHint.id);\\n            }\\n            else if (this._hintLabel) {\\n                ids.push(this._hintLabelId);\\n            }\\n            if (endHint) {\\n                ids.push(endHint.id);\\n            }\\n            this._mdInputChild.ariaDescribedby = ids.join(\\' \\');\\n        }\\n    };\\n    /**\\n     * Throws an error if the container\\'s input child was removed.\\n     * @return {?}\\n     */\\n    MdInputContainer.prototype._validateInputChild = function () {\\n        if (!this._mdInputChild) {\\n            throw getMdInputContainerMissingMdInputError();\\n        }\\n    };\\n    return MdInputContainer;\\n}());\\nMdInputContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-input-container, mat-input-container\\',\\n                template: \"<div class=\\\\\"mat-input-wrapper\\\\\"><div class=\\\\\"mat-input-flex\\\\\"><div class=\\\\\"mat-input-prefix\\\\\" *ngIf=\\\\\"_prefixChildren.length\\\\\"><ng-content select=\\\\\"[mdPrefix], [matPrefix]\\\\\"></ng-content></div><div class=\\\\\"mat-input-infix\\\\\"><ng-content selector=\\\\\"input, textarea\\\\\"></ng-content><span class=\\\\\"mat-input-placeholder-wrapper\\\\\"><label class=\\\\\"mat-input-placeholder\\\\\" [attr.for]=\\\\\"_mdInputChild.id\\\\\" [class.mat-empty]=\\\\\"_mdInputChild.empty && !_shouldAlwaysFloat\\\\\" [class.mat-float]=\\\\\"_canPlaceholderFloat\\\\\" [class.mat-accent]=\\\\\"color == \\'accent\\'\\\\\" [class.mat-warn]=\\\\\"color == \\'warn\\'\\\\\" *ngIf=\\\\\"_hasPlaceholder()\\\\\"><ng-content select=\\\\\"md-placeholder, mat-placeholder\\\\\"></ng-content>{{_mdInputChild.placeholder}} <span class=\\\\\"mat-placeholder-required\\\\\" *ngIf=\\\\\"!hideRequiredMarker && _mdInputChild.required\\\\\">*</span></label></span></div><div class=\\\\\"mat-input-suffix\\\\\" *ngIf=\\\\\"_suffixChildren.length\\\\\"><ng-content select=\\\\\"[mdSuffix], [matSuffix]\\\\\"></ng-content></div></div><div class=\\\\\"mat-input-underline\\\\\" #underline [class.mat-disabled]=\\\\\"_mdInputChild.disabled\\\\\"><span class=\\\\\"mat-input-ripple\\\\\" [class.mat-accent]=\\\\\"color == \\'accent\\'\\\\\" [class.mat-warn]=\\\\\"color == \\'warn\\'\\\\\"></span></div><div class=\\\\\"mat-input-subscript-wrapper\\\\\" [ngSwitch]=\\\\\"_getDisplayedMessages()\\\\\"><div *ngSwitchCase=\\\\\"\\'error\\'\\\\\" [@transitionMessages]=\\\\\"_subscriptAnimationState\\\\\"><ng-content select=\\\\\"md-error, mat-error\\\\\"></ng-content></div><div class=\\\\\"mat-input-hint-wrapper\\\\\" *ngSwitchCase=\\\\\"\\'hint\\'\\\\\" [@transitionMessages]=\\\\\"_subscriptAnimationState\\\\\"><div *ngIf=\\\\\"hintLabel\\\\\" [id]=\\\\\"_hintLabelId\\\\\" class=\\\\\"mat-hint\\\\\">{{hintLabel}}</div><ng-content select=\\\\\"md-hint:not([align=\\'end\\']), mat-hint:not([align=\\'end\\'])\\\\\"></ng-content><div class=\\\\\"mat-input-hint-spacer\\\\\"></div><ng-content select=\\\\\"md-hint[align=\\'end\\'], mat-hint[align=\\'end\\']\\\\\"></ng-content></div></div></div>\",\\n                styles: [\".mat-input-container{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-input-container{text-align:right}.mat-input-wrapper{position:relative}.mat-input-flex{display:inline-flex;align-items:baseline;width:100%}.mat-input-prefix,.mat-input-suffix{white-space:nowrap;flex:none}.mat-input-prefix .mat-datepicker-toggle,.mat-input-prefix .mat-icon,.mat-input-suffix .mat-datepicker-toggle,.mat-input-suffix .mat-icon{width:1em;height:1em;vertical-align:text-bottom}.mat-input-prefix .mat-icon-button,.mat-input-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-input-prefix .mat-icon-button .mat-icon,.mat-input-suffix .mat-icon-button .mat-icon{font-size:inherit;width:1em;height:1em;vertical-align:baseline}.mat-input-infix{display:block;position:relative;flex:auto}.mat-input-element{font:inherit;background:0 0;color:currentColor;border:none;outline:0;padding:0;width:100%;vertical-align:bottom}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element:-webkit-autofill+.mat-input-placeholder-wrapper .mat-input-placeholder{display:none}.mat-input-element:-webkit-autofill+.mat-input-placeholder-wrapper .mat-float{display:block;transition:none}.mat-input-element::placeholder{color:transparent!important}.mat-input-element::-moz-placeholder{color:transparent!important}.mat-input-element::-webkit-input-placeholder{color:transparent!important}.mat-input-element:-ms-input-placeholder{color:transparent!important}.mat-input-placeholder-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}textarea.mat-input-element{overflow:auto}.mat-input-placeholder{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform:perspective(100px);-ms-transform:none;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),color .4s cubic-bezier(.25,.8,.25,1),width .4s cubic-bezier(.25,.8,.25,1);display:none}.mat-focused .mat-input-placeholder.mat-float,.mat-input-placeholder.mat-empty,.mat-input-placeholder.mat-float:not(.mat-empty){display:block}[dir=rtl] .mat-input-placeholder{transform-origin:100% 0;left:auto;right:0}.mat-input-placeholder:not(.mat-empty){transition:none}.mat-input-underline{position:absolute;height:1px;width:100%}.mat-input-underline.mat-disabled{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;background-position:0;background-color:transparent}.mat-input-underline .mat-input-ripple{position:absolute;height:2px;top:0;left:0;width:100%;transform-origin:50%;transform:scaleX(.5);visibility:hidden;transition:background-color .3s cubic-bezier(.55,0,.55,.2)}.mat-focused .mat-input-underline .mat-input-ripple,.mat-input-invalid .mat-input-underline .mat-input-ripple{visibility:visible;transform:scaleX(1);transition:transform 150ms linear,background-color .3s cubic-bezier(.55,0,.55,.2)}.mat-input-subscript-wrapper{position:absolute;width:100%;overflow:hidden}.mat-input-placeholder-wrapper .mat-datepicker-toggle,.mat-input-placeholder-wrapper .mat-icon,.mat-input-subscript-wrapper .mat-datepicker-toggle,.mat-input-subscript-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-input-hint-wrapper{display:flex}.mat-input-hint-spacer{flex:1 0 1em}.mat-input-error{display:block}\"],\\n                animations: [\\n                    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'transitionMessages\\', [\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'enter\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ opacity: 1, transform: \\'translateY(0%)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'void => enter\\', [\\n                            __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ opacity: 0, transform: \\'translateY(-100%)\\' }),\\n                            __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'300ms cubic-bezier(0.55, 0, 0.55, 0.2)\\')\\n                        ])\\n                    ])\\n                ],\\n                host: {\\n                    // Remove align attribute to prevent it from interfering with layout.\\n                    \\'[attr.align]\\': \\'null\\',\\n                    \\'class\\': \\'mat-input-container\\',\\n                    \\'[class.mat-input-invalid]\\': \\'_mdInputChild._isErrorState()\\',\\n                    \\'[class.mat-focused]\\': \\'_mdInputChild.focused\\',\\n                    \\'[class.ng-untouched]\\': \\'_shouldForward(\"untouched\")\\',\\n                    \\'[class.ng-touched]\\': \\'_shouldForward(\"touched\")\\',\\n                    \\'[class.ng-pristine]\\': \\'_shouldForward(\"pristine\")\\',\\n                    \\'[class.ng-dirty]\\': \\'_shouldForward(\"dirty\")\\',\\n                    \\'[class.ng-valid]\\': \\'_shouldForward(\"valid\")\\',\\n                    \\'[class.ng-invalid]\\': \\'_shouldForward(\"invalid\")\\',\\n                    \\'[class.ng-pending]\\': \\'_shouldForward(\"pending\")\\',\\n                    \\'(click)\\': \\'_focusInput()\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdInputContainer.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_PLACEHOLDER_GLOBAL_OPTIONS,] },] },\\n]; };\\nMdInputContainer.propDecorators = {\\n    \\'color\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'dividerColor\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'hideRequiredMarker\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'hintLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'floatPlaceholder\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'underlineRef\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'underline\\',] },],\\n    \\'_mdInputChild\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [MdInputDirective,] },],\\n    \\'_placeholderChild\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [MdPlaceholder,] },],\\n    \\'_errorChildren\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdErrorDirective,] },],\\n    \\'_hintChildren\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdHint,] },],\\n    \\'_prefixChildren\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdPrefix,] },],\\n    \\'_suffixChildren\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdSuffix,] },],\\n};\\n/**\\n * Directive to automatically resize a textarea to fit its content.\\n */\\nvar MdTextareaAutosize = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} formControl\\n     */\\n    function MdTextareaAutosize(_elementRef, formControl) {\\n        var _this = this;\\n        this._elementRef = _elementRef;\\n        if (formControl && formControl.valueChanges) {\\n            formControl.valueChanges.subscribe(function () { return _this.resizeToFitContent(); });\\n        }\\n    }\\n    Object.defineProperty(MdTextareaAutosize.prototype, \"minRows\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._minRows; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._minRows = value;\\n            this._setMinHeight();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTextareaAutosize.prototype, \"maxRows\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._maxRows; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._maxRows = value;\\n            this._setMaxHeight();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTextareaAutosize.prototype, \"_matAutosizeMinRows\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.minRows; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.minRows = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTextareaAutosize.prototype, \"_matAutosizeMaxRows\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.maxRows; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.maxRows = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the minimum height of the textarea as determined by minRows.\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype._setMinHeight = function () {\\n        var /** @type {?} */ minHeight = this.minRows && this._cachedLineHeight ?\\n            this.minRows * this._cachedLineHeight + \"px\" : null;\\n        if (minHeight) {\\n            this._setTextareaStyle(\\'minHeight\\', minHeight);\\n        }\\n    };\\n    /**\\n     * Sets the maximum height of the textarea as determined by maxRows.\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype._setMaxHeight = function () {\\n        var /** @type {?} */ maxHeight = this.maxRows && this._cachedLineHeight ?\\n            this.maxRows * this._cachedLineHeight + \"px\" : null;\\n        if (maxHeight) {\\n            this._setTextareaStyle(\\'maxHeight\\', maxHeight);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype.ngAfterViewInit = function () {\\n        this._cacheTextareaLineHeight();\\n        this.resizeToFitContent();\\n    };\\n    /**\\n     * Sets a style property on the textarea element.\\n     * @param {?} property\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype._setTextareaStyle = function (property, value) {\\n        var /** @type {?} */ textarea = (this._elementRef.nativeElement);\\n        textarea.style[property] = value;\\n    };\\n    /**\\n     * Cache the height of a single-row textarea.\\n     *\\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\\n     * maxRows. For the initial version, we will assume that the height of a single line in the\\n     * textarea does not ever change.\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype._cacheTextareaLineHeight = function () {\\n        var /** @type {?} */ textarea = (this._elementRef.nativeElement);\\n        // Use a clone element because we have to override some styles.\\n        var /** @type {?} */ textareaClone = (textarea.cloneNode(false));\\n        textareaClone.rows = 1;\\n        // Use `position: absolute` so that this doesn\\'t cause a browser layout and use\\n        // `visibility: hidden` so that nothing is rendered. Clear any other styles that\\n        // would affect the height.\\n        textareaClone.style.position = \\'absolute\\';\\n        textareaClone.style.visibility = \\'hidden\\';\\n        textareaClone.style.border = \\'none\\';\\n        textareaClone.style.padding = \\'0\\';\\n        textareaClone.style.height = \\'\\';\\n        textareaClone.style.minHeight = \\'\\';\\n        textareaClone.style.maxHeight = \\'\\'; /** @type {?} */\\n        ((textarea.parentNode)).appendChild(textareaClone);\\n        this._cachedLineHeight = textareaClone.clientHeight; /** @type {?} */\\n        ((textarea.parentNode)).removeChild(textareaClone);\\n        // Min and max heights have to be re-calculated if the cached line height changes\\n        this._setMinHeight();\\n        this._setMaxHeight();\\n    };\\n    /**\\n     * Resize the textarea to fit its content.\\n     * @return {?}\\n     */\\n    MdTextareaAutosize.prototype.resizeToFitContent = function () {\\n        var /** @type {?} */ textarea = (this._elementRef.nativeElement);\\n        if (textarea.value === this._previousValue) {\\n            return;\\n        }\\n        // Reset the textarea height to auto in order to shrink back to its default size.\\n        textarea.style.height = \\'auto\\';\\n        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\\n        textarea.style.height = textarea.scrollHeight + \"px\";\\n        this._previousValue = textarea.value;\\n    };\\n    return MdTextareaAutosize;\\n}());\\nMdTextareaAutosize.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'textarea[md-autosize], textarea[mdTextareaAutosize],\\' +\\n                    \\'textarea[mat-autosize], textarea[matTextareaAutosize]\\',\\n                exportAs: \\'mdTextareaAutosize\\',\\n                host: {\\n                    \\'(input)\\': \\'resizeToFitContent()\\',\\n                    // Textarea elements that have the directive applied should have a single row by default.\\n                    // Browsers normally show two rows by default and therefore this limits the minRows binding.\\n                    \\'rows\\': \\'1\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTextareaAutosize.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NgControl\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Self\"] },] },\\n]; };\\nMdTextareaAutosize.propDecorators = {\\n    \\'minRows\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdAutosizeMinRows\\',] },],\\n    \\'maxRows\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdAutosizeMaxRows\\',] },],\\n    \\'_matAutosizeMinRows\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matAutosizeMaxRows\\',] },],\\n    \\'_matAutosizeMaxRows\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matAutosizeMaxRows\\',] },],\\n};\\nvar MdInputModule = /*@__PURE__*/(function () {\\n    function MdInputModule() {\\n    }\\n    return MdInputModule;\\n}());\\nMdInputModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                declarations: [\\n                    MdErrorDirective,\\n                    MdHint,\\n                    MdInputContainer,\\n                    MdInputDirective,\\n                    MdPlaceholder,\\n                    MdPrefix,\\n                    MdSuffix,\\n                    MdTextareaAutosize,\\n                ],\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"],\\n                    __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"FormsModule\"],\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"M\" /* PlatformModule */],\\n                ],\\n                exports: [\\n                    MdErrorDirective,\\n                    MdHint,\\n                    MdInputContainer,\\n                    MdInputDirective,\\n                    MdPlaceholder,\\n                    MdPrefix,\\n                    MdSuffix,\\n                    MdTextareaAutosize,\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdInputModule.ctorParameters = function () { return []; };\\n/**\\n * Configuration used when opening a snack-bar.\\n */\\nvar MdSnackBarConfig = /*@__PURE__*/(function () {\\n    function MdSnackBarConfig() {\\n        /**\\n         * The politeness level for the MdAriaLiveAnnouncer announcement.\\n         */\\n        this.politeness = \\'assertive\\';\\n        /**\\n         * Message to be announced by the MdAriaLiveAnnouncer\\n         */\\n        this.announcementMessage = \\'\\';\\n        /**\\n         * The length of time in milliseconds to wait before automatically dismissing the snack bar.\\n         */\\n        this.duration = 0;\\n        /**\\n         * Text layout direction for the snack bar.\\n         */\\n        this.direction = \\'ltr\\';\\n    }\\n    return MdSnackBarConfig;\\n}());\\n/**\\n * Reference to a snack bar dispatched from the snack bar service.\\n */\\nvar MdSnackBarRef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} instance\\n     * @param {?} containerInstance\\n     * @param {?} _overlayRef\\n     */\\n    function MdSnackBarRef(instance, containerInstance, _overlayRef) {\\n        var _this = this;\\n        this._overlayRef = _overlayRef;\\n        /**\\n         * Subject for notifying the user that the snack bar has closed.\\n         */\\n        this._afterClosed = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        /**\\n         * Subject for notifying the user that the snack bar action was called.\\n         */\\n        this._onAction = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        // Sets the readonly instance of the snack bar content component.\\n        this._instance = instance;\\n        this.containerInstance = containerInstance;\\n        // Dismiss snackbar on action.\\n        this.onAction().subscribe(function () { return _this.dismiss(); });\\n        containerInstance._onExit().subscribe(function () { return _this._finishDismiss(); });\\n    }\\n    Object.defineProperty(MdSnackBarRef.prototype, \"instance\", {\\n        /**\\n         * The instance of the component making up the content of the snack bar.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._instance;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Dismisses the snack bar.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype.dismiss = function () {\\n        if (!this._afterClosed.closed) {\\n            this.containerInstance.exit();\\n        }\\n        clearTimeout(this._durationTimeoutId);\\n    };\\n    /**\\n     * Dismisses the snack bar after some duration\\n     * @param {?} duration\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype._dismissAfter = function (duration) {\\n        var _this = this;\\n        this._durationTimeoutId = setTimeout(function () { return _this.dismiss(); }, duration);\\n    };\\n    /**\\n     * Marks the snackbar action clicked.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype._action = function () {\\n        if (!this._onAction.closed) {\\n            this._onAction.next();\\n            this._onAction.complete();\\n        }\\n    };\\n    /**\\n     * Marks the snackbar as opened\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype._open = function () {\\n        if (!this._afterOpened.closed) {\\n            this._afterOpened.next();\\n            this._afterOpened.complete();\\n        }\\n    };\\n    /**\\n     * Cleans up the DOM after closing.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype._finishDismiss = function () {\\n        this._overlayRef.dispose();\\n        this._afterClosed.next();\\n        this._afterClosed.complete();\\n    };\\n    /**\\n     * Gets an observable that is notified when the snack bar is finished closing.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype.afterDismissed = function () {\\n        return this._afterClosed.asObservable();\\n    };\\n    /**\\n     * Gets an observable that is notified when the snack bar has opened and appeared.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype.afterOpened = function () {\\n        return this.containerInstance._onEnter();\\n    };\\n    /**\\n     * Gets an observable that is notified when the snack bar action is called.\\n     * @return {?}\\n     */\\n    MdSnackBarRef.prototype.onAction = function () {\\n        return this._onAction.asObservable();\\n    };\\n    return MdSnackBarRef;\\n}());\\n// TODO(jelbourn): we can\\'t use constants from animation.ts here because you can\\'t use\\n// a text interpolation in anything that is analyzed statically with ngc (for AoT compile).\\nvar SHOW_ANIMATION = \\'225ms cubic-bezier(0.4,0.0,1,1)\\';\\nvar HIDE_ANIMATION = \\'195ms cubic-bezier(0.0,0.0,0.2,1)\\';\\n/**\\n * Internal component that wraps user-provided snack bar content.\\n * \\\\@docs-private\\n */\\nvar MdSnackBarContainer = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdSnackBarContainer, _super);\\n    /**\\n     * @param {?} _ngZone\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdSnackBarContainer(_ngZone, _renderer, _elementRef) {\\n        var _this = _super.call(this) || this;\\n        _this._ngZone = _ngZone;\\n        _this._renderer = _renderer;\\n        _this._elementRef = _elementRef;\\n        /**\\n         * Subject for notifying that the snack bar has exited from view.\\n         */\\n        _this.onExit = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        /**\\n         * Subject for notifying that the snack bar has finished entering the view.\\n         */\\n        _this.onEnter = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        /**\\n         * The state of the snack bar animations.\\n         */\\n        _this.animationState = \\'initial\\';\\n        return _this;\\n    }\\n    /**\\n     * Attach a component portal as content to this snack bar container.\\n     * @template T\\n     * @param {?} portal\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.attachComponentPortal = function (portal) {\\n        if (this._portalHost.hasAttached()) {\\n            throw Error(\\'Attempting to attach snack bar content after content is already attached\\');\\n        }\\n        if (this.snackBarConfig.extraClasses) {\\n            // Not the most efficient way of adding classes, but the renderer doesn\\'t allow us\\n            // to pass in an array or a space-separated list.\\n            for (var _i = 0, _a = this.snackBarConfig.extraClasses; _i < _a.length; _i++) {\\n                var cssClass = _a[_i];\\n                this._renderer.addClass(this._elementRef.nativeElement, cssClass);\\n            }\\n        }\\n        return this._portalHost.attachComponentPortal(portal);\\n    };\\n    /**\\n     * Attach a template portal as content to this snack bar container.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.attachTemplatePortal = function () {\\n        throw Error(\\'Not yet implemented\\');\\n    };\\n    /**\\n     * Handle end of animations, updating the state of the snackbar.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.onAnimationEnd = function (event) {\\n        if (event.toState === \\'void\\' || event.toState === \\'complete\\') {\\n            this._completeExit();\\n        }\\n        if (event.toState === \\'visible\\') {\\n            // Note: we shouldn\\'t use `this` inside the zone callback,\\n            // because it can cause a memory leak.\\n            var /** @type {?} */ onEnter_1 = this.onEnter;\\n            this._ngZone.run(function () {\\n                onEnter_1.next();\\n                onEnter_1.complete();\\n            });\\n        }\\n    };\\n    /**\\n     * Begin animation of snack bar entrance into view.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.enter = function () {\\n        this.animationState = \\'visible\\';\\n    };\\n    /**\\n     * Returns an observable resolving when the enter animation completes.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype._onEnter = function () {\\n        this.animationState = \\'visible\\';\\n        return this.onEnter.asObservable();\\n    };\\n    /**\\n     * Begin animation of the snack bar exiting from view.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.exit = function () {\\n        this.animationState = \\'complete\\';\\n        return this._onExit();\\n    };\\n    /**\\n     * Returns an observable that completes after the closing animation is done.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype._onExit = function () {\\n        return this.onExit.asObservable();\\n    };\\n    /**\\n     * Makes sure the exit callbacks have been invoked when the element is destroyed.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype.ngOnDestroy = function () {\\n        this._completeExit();\\n    };\\n    /**\\n     * Waits for the zone to settle before removing the element. Helps prevent\\n     * errors where we end up removing an element which is in the middle of an animation.\\n     * @return {?}\\n     */\\n    MdSnackBarContainer.prototype._completeExit = function () {\\n        // Note: we shouldn\\'t use `this` inside the zone callback,\\n        // because it can cause a memory leak.\\n        var /** @type {?} */ onExit = this.onExit;\\n        __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_4\" /* first */].call(this._ngZone.onMicrotaskEmpty).subscribe(function () {\\n            onExit.next();\\n            onExit.complete();\\n        });\\n    };\\n    return MdSnackBarContainer;\\n}(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"c\" /* BasePortalHost */]));\\nMdSnackBarContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'snack-bar-container\\',\\n                template: \"<ng-template cdkPortalHost></ng-template>\",\\n                styles: [\":host{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);background:#323232;border-radius:2px;box-sizing:content-box;display:block;max-width:568px;min-width:288px;padding:14px 24px;transform:translateY(100%)}@media screen and (-ms-high-contrast:active){:host{border:solid 1px}}\"],\\n                host: {\\n                    \\'role\\': \\'alert\\',\\n                    \\'[@state]\\': \\'animationState\\',\\n                    \\'(@state.done)\\': \\'onAnimationEnd($event)\\'\\n                },\\n                animations: [\\n                    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'state\\', [\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'initial\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translateY(100%)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'visible\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translateY(0%)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'complete\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translateY(100%)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'visible => complete\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](HIDE_ANIMATION)),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'initial => visible, void => visible\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](SHOW_ANIMATION)),\\n                    ])\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSnackBarContainer.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdSnackBarContainer.propDecorators = {\\n    \\'_portalHost\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"O\" /* PortalHostDirective */],] },],\\n};\\n/**\\n * A component used to open as the default snack bar, matching material spec.\\n * This should only be used internally by the snack bar service.\\n */\\nvar SimpleSnackBar = /*@__PURE__*/(function () {\\n    function SimpleSnackBar() {\\n    }\\n    /**\\n     * Dismisses the snack bar.\\n     * @return {?}\\n     */\\n    SimpleSnackBar.prototype.dismiss = function () {\\n        this.snackBarRef._action();\\n    };\\n    Object.defineProperty(SimpleSnackBar.prototype, \"hasAction\", {\\n        /**\\n         * If the action button should be shown.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return !!this.action;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return SimpleSnackBar;\\n}());\\nSimpleSnackBar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'simple-snack-bar\\',\\n                template: \"{{message}} <button class=\\\\\"mat-simple-snackbar-action\\\\\" *ngIf=\\\\\"hasAction\\\\\" (click)=\\\\\"dismiss()\\\\\">{{action}}</button>\",\\n                styles: [\".mat-simple-snackbar{display:flex;justify-content:space-between;color:#fff;line-height:20px}.mat-simple-snackbar-action{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;background:0 0;color:inherit;flex-shrink:0;margin-left:48px}[dir=rtl] .mat-simple-snackbar-action{margin-right:48px;margin-left:0}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'class\\': \\'mat-simple-snackbar\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nSimpleSnackBar.ctorParameters = function () { return []; };\\n/**\\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\\n * similar to Object.assign.\\n *\\n * @param {?} dest The object which will have properties copied to it.\\n * @param {...?} sources The source objects from which properties will be copied.\\n * @return {?}\\n */\\nfunction extendObject(dest) {\\n    var sources = [];\\n    for (var _i = 1; _i < arguments.length; _i++) {\\n        sources[_i - 1] = arguments[_i];\\n    }\\n    if (dest == null) {\\n        throw TypeError(\\'Cannot convert undefined or null to object\\');\\n    }\\n    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\\n        var source = sources_1[_a];\\n        if (source != null) {\\n            for (var /** @type {?} */ key in source) {\\n                if (source.hasOwnProperty(key)) {\\n                    dest[key] = source[key];\\n                }\\n            }\\n        }\\n    }\\n    return dest;\\n}\\n/**\\n * Service to dispatch Material Design snack bar messages.\\n */\\nvar MdSnackBar = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlay\\n     * @param {?} _live\\n     * @param {?} _parentSnackBar\\n     */\\n    function MdSnackBar(_overlay, _live, _parentSnackBar) {\\n        this._overlay = _overlay;\\n        this._live = _live;\\n        this._parentSnackBar = _parentSnackBar;\\n        /**\\n         * Reference to the current snack bar in the view *at this level* (in the Angular injector tree).\\n         * If there is a parent snack-bar service, all operations should delegate to that parent\\n         * via `_openedSnackBarRef`.\\n         */\\n        this._snackBarRefAtThisLevel = null;\\n    }\\n    Object.defineProperty(MdSnackBar.prototype, \"_openedSnackBarRef\", {\\n        /**\\n         * Reference to the currently opened snackbar at *any* level.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var /** @type {?} */ parent = this._parentSnackBar;\\n            return parent ? parent._openedSnackBarRef : this._snackBarRefAtThisLevel;\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (this._parentSnackBar) {\\n                this._parentSnackBar._openedSnackBarRef = value;\\n            }\\n            else {\\n                this._snackBarRefAtThisLevel = value;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Creates and dispatches a snack bar with a custom component for the content, removing any\\n     * currently opened snack bars.\\n     *\\n     * @template T\\n     * @param {?} component Component to be instantiated.\\n     * @param {?=} config Extra configuration for the snack bar.\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype.openFromComponent = function (component, config) {\\n        var _this = this;\\n        config = _applyConfigDefaults(config);\\n        var /** @type {?} */ overlayRef = this._createOverlay(config);\\n        var /** @type {?} */ snackBarContainer = this._attachSnackBarContainer(overlayRef, config);\\n        var /** @type {?} */ snackBarRef = this._attachSnackbarContent(component, snackBarContainer, overlayRef);\\n        // When the snackbar is dismissed, clear the reference to it.\\n        snackBarRef.afterDismissed().subscribe(function () {\\n            // Clear the snackbar ref if it hasn\\'t already been replaced by a newer snackbar.\\n            if (_this._openedSnackBarRef == snackBarRef) {\\n                _this._openedSnackBarRef = null;\\n            }\\n        });\\n        // If a snack bar is already in view, dismiss it and enter the new snack bar after exit\\n        // animation is complete.\\n        if (this._openedSnackBarRef) {\\n            this._openedSnackBarRef.afterDismissed().subscribe(function () {\\n                snackBarRef.containerInstance.enter();\\n            });\\n            this._openedSnackBarRef.dismiss();\\n            // If no snack bar is in view, enter the new snack bar.\\n        }\\n        else {\\n            snackBarRef.containerInstance.enter();\\n        }\\n        // If a dismiss timeout is provided, set up dismiss based on after the snackbar is opened.\\n        if (config.duration && config.duration > 0) {\\n            snackBarRef.afterOpened().subscribe(function () {\\n                snackBarRef._dismissAfter(/** @type {?} */ ((((config)).duration)));\\n            });\\n        }\\n        if (config.announcementMessage) {\\n            this._live.announce(config.announcementMessage, config.politeness);\\n        }\\n        this._openedSnackBarRef = snackBarRef;\\n        return this._openedSnackBarRef;\\n    };\\n    /**\\n     * Opens a snackbar with a message and an optional action.\\n     * @param {?} message The message to show in the snackbar.\\n     * @param {?=} action The label for the snackbar action.\\n     * @param {?=} config Additional configuration options for the snackbar.\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype.open = function (message, action, config) {\\n        if (action === void 0) { action = \\'\\'; }\\n        var /** @type {?} */ _config = _applyConfigDefaults(config);\\n        _config.announcementMessage = message;\\n        var /** @type {?} */ simpleSnackBarRef = this.openFromComponent(SimpleSnackBar, _config);\\n        simpleSnackBarRef.instance.snackBarRef = simpleSnackBarRef;\\n        simpleSnackBarRef.instance.message = message;\\n        simpleSnackBarRef.instance.action = action;\\n        return simpleSnackBarRef;\\n    };\\n    /**\\n     * Dismisses the currently-visible snack bar.\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype.dismiss = function () {\\n        if (this._openedSnackBarRef) {\\n            this._openedSnackBarRef.dismiss();\\n        }\\n    };\\n    /**\\n     * Attaches the snack bar container component to the overlay.\\n     * @param {?} overlayRef\\n     * @param {?} config\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype._attachSnackBarContainer = function (overlayRef, config) {\\n        var /** @type {?} */ containerPortal = new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"n\" /* ComponentPortal */](MdSnackBarContainer, config.viewContainerRef);\\n        var /** @type {?} */ containerRef = overlayRef.attach(containerPortal);\\n        containerRef.instance.snackBarConfig = config;\\n        // The snackbar animation needs the content to be resolved in order to transform the bar\\n        // out of the view initially (so it can slide in). To make the content resolve, we manually\\n        // detect changes.\\n        containerRef.changeDetectorRef.detectChanges();\\n        return containerRef.instance;\\n    };\\n    /**\\n     * Places a new component as the content of the snack bar container.\\n     * @template T\\n     * @param {?} component\\n     * @param {?} container\\n     * @param {?} overlayRef\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype._attachSnackbarContent = function (component, container, overlayRef) {\\n        var /** @type {?} */ portal = new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"n\" /* ComponentPortal */](component);\\n        var /** @type {?} */ contentRef = container.attachComponentPortal(portal);\\n        return new MdSnackBarRef(contentRef.instance, container, overlayRef);\\n    };\\n    /**\\n     * Creates a new overlay and places it in the correct location.\\n     * @param {?} config The user-specified snack bar config.\\n     * @return {?}\\n     */\\n    MdSnackBar.prototype._createOverlay = function (config) {\\n        var /** @type {?} */ state$$1 = new OverlayState();\\n        state$$1.direction = config.direction;\\n        state$$1.positionStrategy = this._overlay.position().global().centerHorizontally().bottom(\\'0\\');\\n        return this._overlay.create(state$$1);\\n    };\\n    return MdSnackBar;\\n}());\\nMdSnackBar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSnackBar.ctorParameters = function () { return [\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"G\" /* LiveAnnouncer */], },\\n    { type: MdSnackBar, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"] },] },\\n]; };\\n/**\\n * Applies default options to the snackbar config.\\n * @param {?=} config The configuration to which the defaults will be applied.\\n * @return {?} The new configuration object with defaults applied.\\n */\\nfunction _applyConfigDefaults(config) {\\n    return extendObject(new MdSnackBarConfig(), config);\\n}\\nvar MdSnackBarModule = /*@__PURE__*/(function () {\\n    function MdSnackBarModule() {\\n    }\\n    return MdSnackBarModule;\\n}());\\nMdSnackBarModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    OverlayModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"P\" /* PortalModule */],\\n                    __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"],\\n                    MdCommonModule,\\n                ],\\n                exports: [MdSnackBarContainer, MdCommonModule],\\n                declarations: [MdSnackBarContainer, SimpleSnackBar],\\n                entryComponents: [MdSnackBarContainer, SimpleSnackBar],\\n                providers: [MdSnackBar, __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"E\" /* LIVE_ANNOUNCER_PROVIDER */]]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSnackBarModule.ctorParameters = function () { return []; };\\n/**\\n * Workaround for https://github.com/angular/angular/issues/17849\\n */\\nvar _MdTabLabelBaseClass = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"V\" /* TemplatePortalDirective */];\\n/**\\n * Used to flag tab labels for use with the portal directive\\n */\\nvar MdTabLabel = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdTabLabel, _super);\\n    /**\\n     * @param {?} templateRef\\n     * @param {?} viewContainerRef\\n     */\\n    function MdTabLabel(templateRef, viewContainerRef) {\\n        return _super.call(this, templateRef, viewContainerRef) || this;\\n    }\\n    return MdTabLabel;\\n}(_MdTabLabelBaseClass));\\nMdTabLabel.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-tab-label], [mat-tab-label], [mdTabLabel], [matTabLabel]\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabLabel.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\n/**\\n * \\\\@docs-private\\n */\\nvar MdTabBase = /*@__PURE__*/(function () {\\n    function MdTabBase() {\\n    }\\n    return MdTabBase;\\n}());\\nvar _MdTabMixinBase = mixinDisabled(MdTabBase);\\nvar MdTab = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdTab, _super);\\n    /**\\n     * @param {?} _viewContainerRef\\n     */\\n    function MdTab(_viewContainerRef) {\\n        var _this = _super.call(this) || this;\\n        _this._viewContainerRef = _viewContainerRef;\\n        /**\\n         * The plain text label for the tab, used when there is no template label.\\n         */\\n        _this.textLabel = \\'\\';\\n        /**\\n         * The portal that will be the hosted content of the tab\\n         */\\n        _this._contentPortal = null;\\n        /**\\n         * The relatively indexed position where 0 represents the center, negative is left, and positive\\n         * represents the right.\\n         */\\n        _this.position = null;\\n        /**\\n         * The initial relatively index origin of the tab if it was created and selected after there\\n         * was already a selected tab. Provides context of what position the tab should originate from.\\n         */\\n        _this.origin = null;\\n        return _this;\\n    }\\n    Object.defineProperty(MdTab.prototype, \"content\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._contentPortal; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdTab.prototype.ngOnInit = function () {\\n        this._contentPortal = new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"U\" /* TemplatePortal */](this._content, this._viewContainerRef);\\n    };\\n    return MdTab;\\n}(_MdTabMixinBase));\\nMdTab.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-tab, mat-tab\\',\\n                template: \"<ng-template><ng-content></ng-content></ng-template>\",\\n                inputs: [\\'disabled\\']\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTab.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\nMdTab.propDecorators = {\\n    \\'templateLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [MdTabLabel,] },],\\n    \\'_content\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"],] },],\\n    \\'textLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'label\\',] },],\\n};\\n/**\\n * Used to generate unique ID\\'s for each tab component\\n */\\nvar nextId$2 = 0;\\n/**\\n * A simple change event emitted on focus or selection changes.\\n */\\nvar MdTabChangeEvent = /*@__PURE__*/(function () {\\n    function MdTabChangeEvent() {\\n    }\\n    return MdTabChangeEvent;\\n}());\\n/**\\n * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\\n * animated ink-bar, keyboard navigation, and screen reader.\\n * See: https://www.google.com/design/spec/components/tabs.html\\n */\\nvar MdTabGroup = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     */\\n    function MdTabGroup(_renderer) {\\n        this._renderer = _renderer;\\n        /**\\n         * Whether this component has been initialized.\\n         */\\n        this._isInitialized = false;\\n        /**\\n         * The tab index that should be selected after the content has been checked.\\n         */\\n        this._indexToSelect = 0;\\n        /**\\n         * Snapshot of the height of the tab body wrapper before another tab is activated.\\n         */\\n        this._tabBodyWrapperHeight = 0;\\n        this._dynamicHeight = false;\\n        this._disableRipple = false;\\n        this._selectedIndex = null;\\n        /**\\n         * Position of the tab header.\\n         */\\n        this.headerPosition = \\'above\\';\\n        /**\\n         * Event emitted when focus has changed within a tab group.\\n         */\\n        this.focusChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the tab selection has changed.\\n         */\\n        this.selectChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"](true);\\n        this._groupId = nextId$2++;\\n    }\\n    Object.defineProperty(MdTabGroup.prototype, \"dynamicHeight\", {\\n        /**\\n         * Whether the tab group should grow to the size of the active tab.\\n         * @return {?}\\n         */\\n        get: function () { return this._dynamicHeight; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._dynamicHeight = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabGroup.prototype, \"_dynamicHeightDeprecated\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this._dynamicHeight; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._dynamicHeight = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabGroup.prototype, \"disableRipple\", {\\n        /**\\n         * Whether ripples for the tab-group should be disabled or not.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabGroup.prototype, \"selectedIndex\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._selectedIndex; },\\n        /**\\n         * The index of the active tab.\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._indexToSelect = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabGroup.prototype, \"selectedIndexChange\", {\\n        /**\\n         * Output to enable support for two-way binding on `[(selectedIndex)]`\\n         * @return {?}\\n         */\\n        get: function () {\\n            return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_7\" /* map */].call(this.selectChange, function (event) { return event.index; });\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * After the content is checked, this component knows what tabs have been defined\\n     * and what the selected index should be. This is where we can know exactly what position\\n     * each tab should be in according to the new selected index, and additionally we know how\\n     * a new selected tab should transition in (from the left or right).\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype.ngAfterContentChecked = function () {\\n        var _this = this;\\n        // Clamp the next selected index to the bounds of 0 and the tabs length. Note the `|| 0`, which\\n        // ensures that values like NaN can\\'t get through and which would otherwise throw the\\n        // component into an infinite loop (since Math.max(NaN, 0) === NaN).\\n        var /** @type {?} */ indexToSelect = this._indexToSelect =\\n            Math.min(this._tabs.length - 1, Math.max(this._indexToSelect || 0, 0));\\n        // If there is a change in selected index, emit a change event. Should not trigger if\\n        // the selected index has not yet been initialized.\\n        if (this._selectedIndex != indexToSelect && this._selectedIndex != null) {\\n            this.selectChange.emit(this._createChangeEvent(indexToSelect));\\n        }\\n        // Setup the position for each tab and optionally setup an origin on the next selected tab.\\n        this._tabs.forEach(function (tab, index) {\\n            tab.position = index - indexToSelect;\\n            // If there is already a selected tab, then set up an origin for the next selected tab\\n            // if it doesn\\'t have one already.\\n            if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {\\n                tab.origin = indexToSelect - _this._selectedIndex;\\n            }\\n        });\\n        this._selectedIndex = indexToSelect;\\n    };\\n    /**\\n     * Waits one frame for the view to update, then updates the ink bar\\n     * Note: This must be run outside of the zone or it will create an infinite change detection loop.\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype.ngAfterViewChecked = function () {\\n        this._isInitialized = true;\\n    };\\n    /**\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._focusChanged = function (index) {\\n        this.focusChange.emit(this._createChangeEvent(index));\\n    };\\n    /**\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._createChangeEvent = function (index) {\\n        var /** @type {?} */ event = new MdTabChangeEvent;\\n        event.index = index;\\n        if (this._tabs && this._tabs.length) {\\n            event.tab = this._tabs.toArray()[index];\\n        }\\n        return event;\\n    };\\n    /**\\n     * Returns a unique id for each tab label element\\n     * @param {?} i\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._getTabLabelId = function (i) {\\n        return \"md-tab-label-\" + this._groupId + \"-\" + i;\\n    };\\n    /**\\n     * Returns a unique id for each tab content element\\n     * @param {?} i\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._getTabContentId = function (i) {\\n        return \"md-tab-content-\" + this._groupId + \"-\" + i;\\n    };\\n    /**\\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\\n     * height property is true.\\n     * @param {?} tabHeight\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._setTabBodyWrapperHeight = function (tabHeight) {\\n        if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\\n            return;\\n        }\\n        this._renderer.setStyle(this._tabBodyWrapper.nativeElement, \\'height\\', this._tabBodyWrapperHeight + \\'px\\');\\n        // This conditional forces the browser to paint the height so that\\n        // the animation to the new height can have an origin.\\n        if (this._tabBodyWrapper.nativeElement.offsetHeight) {\\n            this._renderer.setStyle(this._tabBodyWrapper.nativeElement, \\'height\\', tabHeight + \\'px\\');\\n        }\\n    };\\n    /**\\n     * Removes the height of the tab body wrapper.\\n     * @return {?}\\n     */\\n    MdTabGroup.prototype._removeTabBodyWrapperHeight = function () {\\n        this._tabBodyWrapperHeight = this._tabBodyWrapper.nativeElement.clientHeight;\\n        this._renderer.setStyle(this._tabBodyWrapper.nativeElement, \\'height\\', \\'\\');\\n    };\\n    return MdTabGroup;\\n}());\\nMdTabGroup.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-tab-group, mat-tab-group\\',\\n                template: \"<md-tab-header #tabHeader [selectedIndex]=\\\\\"selectedIndex\\\\\" [disableRipple]=\\\\\"disableRipple\\\\\" (indexFocused)=\\\\\"_focusChanged($event)\\\\\" (selectFocusedIndex)=\\\\\"selectedIndex = $event\\\\\"><div class=\\\\\"mat-tab-label\\\\\" role=\\\\\"tab\\\\\" md-tab-label-wrapper md-ripple *ngFor=\\\\\"let tab of _tabs; let i = index\\\\\" [id]=\\\\\"_getTabLabelId(i)\\\\\" [tabIndex]=\\\\\"selectedIndex == i ? 0 : -1\\\\\" [attr.aria-controls]=\\\\\"_getTabContentId(i)\\\\\" [attr.aria-selected]=\\\\\"selectedIndex == i\\\\\" [class.mat-tab-label-active]=\\\\\"selectedIndex == i\\\\\" [disabled]=\\\\\"tab.disabled\\\\\" [mdRippleDisabled]=\\\\\"disableRipple\\\\\" (click)=\\\\\"tabHeader.focusIndex = selectedIndex = i\\\\\"><ng-template [ngIf]=\\\\\"tab.templateLabel\\\\\"><ng-template [cdkPortalHost]=\\\\\"tab.templateLabel\\\\\"></ng-template></ng-template><ng-template [ngIf]=\\\\\"!tab.templateLabel\\\\\">{{tab.textLabel}}</ng-template></div></md-tab-header><div class=\\\\\"mat-tab-body-wrapper\\\\\" #tabBodyWrapper><md-tab-body role=\\\\\"tabpanel\\\\\" *ngFor=\\\\\"let tab of _tabs; let i = index\\\\\" [id]=\\\\\"_getTabContentId(i)\\\\\" [attr.aria-labelledby]=\\\\\"_getTabLabelId(i)\\\\\" [class.mat-tab-body-active]=\\\\\"selectedIndex == i\\\\\" [content]=\\\\\"tab.content\\\\\" [position]=\\\\\"tab.position\\\\\" [origin]=\\\\\"tab.origin\\\\\" (onCentered)=\\\\\"_removeTabBodyWrapperHeight()\\\\\" (onCentering)=\\\\\"_setTabBodyWrapperHeight($event)\\\\\"></md-tab-body></div>\",\\n                styles: [\":host{display:flex;flex-direction:column}:host.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{line-height:48px;height:48px;padding:0 12px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;position:relative}.mat-tab-label:focus{outline:0;opacity:1}.mat-tab-label.mat-tab-disabled{cursor:default;pointer-events:none}@media (max-width:600px){.mat-tab-label{min-width:72px}}:host[mat-stretch-tabs] .mat-tab-label,:host[md-stretch-tabs] .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{position:absolute;top:0;left:0;right:0;bottom:0;display:block;overflow:hidden}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}:host.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\"],\\n                host: {\\n                    \\'class\\': \\'mat-tab-group\\',\\n                    \\'[class.mat-tab-group-dynamic-height]\\': \\'dynamicHeight\\',\\n                    \\'[class.mat-tab-group-inverted-header]\\': \\'headerPosition === \"below\"\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabGroup.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\nMdTabGroup.propDecorators = {\\n    \\'_tabs\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdTab,] },],\\n    \\'_tabBodyWrapper\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'tabBodyWrapper\\',] },],\\n    \\'dynamicHeight\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_dynamicHeightDeprecated\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'md-dynamic-height\\',] },],\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'headerPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedIndexChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'focusChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'selectChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * \\\\@docs-private\\n */\\nvar MdTabLabelWrapperBase = /*@__PURE__*/(function () {\\n    function MdTabLabelWrapperBase() {\\n    }\\n    return MdTabLabelWrapperBase;\\n}());\\nvar _MdTabLabelWrapperMixinBase = mixinDisabled(MdTabLabelWrapperBase);\\n/**\\n * Used in the `md-tab-group` view to display tab labels.\\n * \\\\@docs-private\\n */\\nvar MdTabLabelWrapper = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdTabLabelWrapper, _super);\\n    /**\\n     * @param {?} elementRef\\n     */\\n    function MdTabLabelWrapper(elementRef) {\\n        var _this = _super.call(this) || this;\\n        _this.elementRef = elementRef;\\n        return _this;\\n    }\\n    /**\\n     * Sets focus on the wrapper element\\n     * @return {?}\\n     */\\n    MdTabLabelWrapper.prototype.focus = function () {\\n        this.elementRef.nativeElement.focus();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTabLabelWrapper.prototype.getOffsetLeft = function () {\\n        return this.elementRef.nativeElement.offsetLeft;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTabLabelWrapper.prototype.getOffsetWidth = function () {\\n        return this.elementRef.nativeElement.offsetWidth;\\n    };\\n    return MdTabLabelWrapper;\\n}(_MdTabLabelWrapperMixinBase));\\nMdTabLabelWrapper.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-tab-label-wrapper], [mat-tab-label-wrapper]\\',\\n                inputs: [\\'disabled\\'],\\n                host: {\\n                    \\'[class.mat-tab-disabled]\\': \\'disabled\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabLabelWrapper.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\n/**\\n * The ink-bar is used to display and animate the line underneath the current active tab label.\\n * \\\\@docs-private\\n */\\nvar MdInkBar = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     * @param {?} _ngZone\\n     */\\n    function MdInkBar(_renderer, _elementRef, _ngZone) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n        this._ngZone = _ngZone;\\n    }\\n    /**\\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\\n     * Shows the ink bar if previously set as hidden.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    MdInkBar.prototype.alignToElement = function (element) {\\n        var _this = this;\\n        this.show();\\n        this._ngZone.runOutsideAngular(function () {\\n            requestAnimationFrame(function () {\\n                _this._renderer.setStyle(_this._elementRef.nativeElement, \\'left\\', _this._getLeftPosition(element));\\n                _this._renderer.setStyle(_this._elementRef.nativeElement, \\'width\\', _this._getElementWidth(element));\\n            });\\n        });\\n    };\\n    /**\\n     * Shows the ink bar.\\n     * @return {?}\\n     */\\n    MdInkBar.prototype.show = function () {\\n        this._renderer.setStyle(this._elementRef.nativeElement, \\'visibility\\', \\'visible\\');\\n    };\\n    /**\\n     * Hides the ink bar.\\n     * @return {?}\\n     */\\n    MdInkBar.prototype.hide = function () {\\n        this._renderer.setStyle(this._elementRef.nativeElement, \\'visibility\\', \\'hidden\\');\\n    };\\n    /**\\n     * Generates the pixel distance from the left based on the provided element in string format.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    MdInkBar.prototype._getLeftPosition = function (element) {\\n        return element ? element.offsetLeft + \\'px\\' : \\'0\\';\\n    };\\n    /**\\n     * Generates the pixel width from the provided element in string format.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    MdInkBar.prototype._getElementWidth = function (element) {\\n        return element ? element.offsetWidth + \\'px\\' : \\'0\\';\\n    };\\n    return MdInkBar;\\n}());\\nMdInkBar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-ink-bar, mat-ink-bar\\',\\n                host: {\\n                    \\'class\\': \\'mat-ink-bar\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdInkBar.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\n/**\\n * Navigation component matching the styles of the tab group header.\\n * Provides anchored navigation with animated ink bar.\\n */\\nvar MdTabNav = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dir\\n     * @param {?} _ngZone\\n     */\\n    function MdTabNav(_dir, _ngZone) {\\n        this._dir = _dir;\\n        this._ngZone = _ngZone;\\n        /**\\n         * Subject that emits when the component has been destroyed.\\n         */\\n        this._onDestroy = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n    }\\n    /**\\n     * Notifies the component that the active link has been changed.\\n     * @param {?} element\\n     * @return {?}\\n     */\\n    MdTabNav.prototype.updateActiveLink = function (element) {\\n        this._activeLinkChanged = this._activeLinkElement != element;\\n        this._activeLinkElement = element;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTabNav.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._resizeSubscription = this._ngZone.runOutsideAngular(function () {\\n            var /** @type {?} */ dirChange = _this._dir ? _this._dir.change : __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__[\"of\"](null);\\n            var /** @type {?} */ resize = typeof window !== \\'undefined\\' ?\\n                __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"X\" /* auditTime */].call(__WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromEvent__[\"fromEvent\"](window, \\'resize\\'), 10) :\\n                __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__[\"of\"](null);\\n            return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_11\" /* takeUntil */].call(__WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge__[\"merge\"](dirChange, resize), _this._onDestroy)\\n                .subscribe(function () { return _this._alignInkBar(); });\\n        });\\n    };\\n    /**\\n     * Checks if the active link has been changed and, if so, will update the ink bar.\\n     * @return {?}\\n     */\\n    MdTabNav.prototype.ngAfterContentChecked = function () {\\n        if (this._activeLinkChanged) {\\n            this._alignInkBar();\\n            this._activeLinkChanged = false;\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTabNav.prototype.ngOnDestroy = function () {\\n        this._onDestroy.next();\\n        this._resizeSubscription.unsubscribe();\\n    };\\n    /**\\n     * Aligns the ink bar to the active link.\\n     * @return {?}\\n     */\\n    MdTabNav.prototype._alignInkBar = function () {\\n        if (this._activeLinkElement) {\\n            this._inkBar.alignToElement(this._activeLinkElement.nativeElement);\\n        }\\n    };\\n    return MdTabNav;\\n}());\\nMdTabNav.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'[md-tab-nav-bar], [mat-tab-nav-bar]\\',\\n                template: \"<div class=\\\\\"mat-tab-links\\\\\" (cdkObserveContent)=\\\\\"_alignInkBar()\\\\\"><ng-content></ng-content><md-ink-bar></md-ink-bar></div>\",\\n                styles: [\".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative}.mat-tab-link{line-height:48px;height:48px;padding:0 12px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-block;vertical-align:top;text-decoration:none;position:relative;overflow:hidden}.mat-tab-link:focus{outline:0;opacity:1}.mat-tab-link.mat-tab-disabled{cursor:default;pointer-events:none}@media (max-width:600px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}\"],\\n                host: { \\'class\\': \\'mat-tab-nav-bar\\' },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabNav.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\nMdTabNav.propDecorators = {\\n    \\'_inkBar\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdInkBar,] },],\\n};\\nvar MdTabLinkBase = /*@__PURE__*/(function () {\\n    function MdTabLinkBase() {\\n    }\\n    return MdTabLinkBase;\\n}());\\nvar _MdTabLinkMixinBase = mixinDisabled(MdTabLinkBase);\\n/**\\n * Link inside of a `md-tab-nav-bar`.\\n */\\nvar MdTabLink = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdTabLink, _super);\\n    /**\\n     * @param {?} _mdTabNavBar\\n     * @param {?} _elementRef\\n     * @param {?} ngZone\\n     * @param {?} ruler\\n     * @param {?} platform\\n     * @param {?} globalOptions\\n     */\\n    function MdTabLink(_mdTabNavBar, _elementRef, ngZone, ruler, platform, globalOptions) {\\n        var _this = _super.call(this) || this;\\n        _this._mdTabNavBar = _mdTabNavBar;\\n        _this._elementRef = _elementRef;\\n        /**\\n         * Whether the tab link is active or not.\\n         */\\n        _this._isActive = false;\\n        // Manually create a ripple instance that uses the tab link element as trigger element.\\n        // Notice that the lifecycle hooks for the ripple config won\\'t be called anymore.\\n        _this._tabLinkRipple = new MdRipple(_elementRef, ngZone, ruler, platform, globalOptions);\\n        return _this;\\n    }\\n    Object.defineProperty(MdTabLink.prototype, \"active\", {\\n        /**\\n         * Whether the link is active.\\n         * @return {?}\\n         */\\n        get: function () { return this._isActive; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._isActive = value;\\n            if (value) {\\n                this._mdTabNavBar.updateActiveLink(this._elementRef);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabLink.prototype, \"tabIndex\", {\\n        /**\\n         * \\\\@docs-private\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.disabled ? -1 : 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdTabLink.prototype.ngOnDestroy = function () {\\n        // Manually call the ngOnDestroy lifecycle hook of the ripple instance because it won\\'t be\\n        // called automatically since its instance is not created by Angular.\\n        this._tabLinkRipple.ngOnDestroy();\\n    };\\n    return MdTabLink;\\n}(_MdTabLinkMixinBase));\\nMdTabLink.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-tab-link], [mat-tab-link], [mdTabLink], [matTabLink]\\',\\n                inputs: [\\'disabled\\'],\\n                host: {\\n                    \\'class\\': \\'mat-tab-link\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled.toString()\\',\\n                    \\'[class.mat-tab-disabled]\\': \\'disabled\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabLink.ctorParameters = function () { return [\\n    { type: MdTabNav, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: ViewportRuler, },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */], },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_RIPPLE_GLOBAL_OPTIONS,] },] },\\n]; };\\nMdTabLink.propDecorators = {\\n    \\'active\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'tabIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'tabIndex\\',] },],\\n};\\n/**\\n * Wrapper for the contents of a tab.\\n * \\\\@docs-private\\n */\\nvar MdTabBody = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _dir\\n     */\\n    function MdTabBody(_elementRef, _dir) {\\n        this._elementRef = _elementRef;\\n        this._dir = _dir;\\n        /**\\n         * Event emitted when the tab begins to animate towards the center as the active tab.\\n         */\\n        this.onCentering = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the tab completes its animation towards the center.\\n         */\\n        this.onCentered = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"](true);\\n    }\\n    Object.defineProperty(MdTabBody.prototype, \"position\", {\\n        /**\\n         * @param {?} position\\n         * @return {?}\\n         */\\n        set: function (position) {\\n            if (position < 0) {\\n                this._position = this._getLayoutDirection() == \\'ltr\\' ? \\'left\\' : \\'right\\';\\n            }\\n            else if (position > 0) {\\n                this._position = this._getLayoutDirection() == \\'ltr\\' ? \\'right\\' : \\'left\\';\\n            }\\n            else {\\n                this._position = \\'center\\';\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabBody.prototype, \"origin\", {\\n        /**\\n         * The origin position from which this tab should appear when it is centered into view.\\n         * @param {?} origin\\n         * @return {?}\\n         */\\n        set: function (origin) {\\n            if (origin == null) {\\n                return;\\n            }\\n            var /** @type {?} */ dir = this._getLayoutDirection();\\n            if ((dir == \\'ltr\\' && origin <= 0) || (dir == \\'rtl\\' && origin > 0)) {\\n                this._origin = \\'left\\';\\n            }\\n            else {\\n                this._origin = \\'right\\';\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * After initialized, check if the content is centered and has an origin. If so, set the\\n     * special position states that transition the tab from the left or right before centering.\\n     * @return {?}\\n     */\\n    MdTabBody.prototype.ngOnInit = function () {\\n        if (this._position == \\'center\\' && this._origin) {\\n            this._position = this._origin == \\'left\\' ? \\'left-origin-center\\' : \\'right-origin-center\\';\\n        }\\n    };\\n    /**\\n     * After the view has been set, check if the tab content is set to the center and attach the\\n     * content if it is not already attached.\\n     * @return {?}\\n     */\\n    MdTabBody.prototype.ngAfterViewChecked = function () {\\n        if (this._isCenterPosition(this._position) && !this._portalHost.hasAttached()) {\\n            this._portalHost.attach(this._content);\\n        }\\n    };\\n    /**\\n     * @param {?} e\\n     * @return {?}\\n     */\\n    MdTabBody.prototype._onTranslateTabStarted = function (e) {\\n        if (this._isCenterPosition(e.toState)) {\\n            this.onCentering.emit(this._elementRef.nativeElement.clientHeight);\\n        }\\n    };\\n    /**\\n     * @param {?} e\\n     * @return {?}\\n     */\\n    MdTabBody.prototype._onTranslateTabComplete = function (e) {\\n        // If the end state is that the tab is not centered, then detach the content.\\n        if (!this._isCenterPosition(e.toState) && !this._isCenterPosition(this._position)) {\\n            this._portalHost.detach();\\n        }\\n        // If the transition to the center is complete, emit an event.\\n        if (this._isCenterPosition(e.toState) && this._isCenterPosition(this._position)) {\\n            this.onCentered.emit();\\n        }\\n    };\\n    /**\\n     * The text direction of the containing app.\\n     * @return {?}\\n     */\\n    MdTabBody.prototype._getLayoutDirection = function () {\\n        return this._dir && this._dir.value === \\'rtl\\' ? \\'rtl\\' : \\'ltr\\';\\n    };\\n    /**\\n     * Whether the provided position state is considered center, regardless of origin.\\n     * @param {?} position\\n     * @return {?}\\n     */\\n    MdTabBody.prototype._isCenterPosition = function (position) {\\n        return position == \\'center\\' ||\\n            position == \\'left-origin-center\\' ||\\n            position == \\'right-origin-center\\';\\n    };\\n    return MdTabBody;\\n}());\\nMdTabBody.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-tab-body, mat-tab-body\\',\\n                template: \"<div class=\\\\\"mat-tab-body-content\\\\\" #content [@translateTab]=\\\\\"_position\\\\\" (@translateTab.start)=\\\\\"_onTranslateTabStarted($event)\\\\\" (@translateTab.done)=\\\\\"_onTranslateTabComplete($event)\\\\\"><ng-template cdkPortalHost></ng-template></div>\",\\n                styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'class\\': \\'mat-tab-body\\',\\n                },\\n                animations: [\\n                    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'translateTab\\', [\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'void\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translate3d(0%, 0, 0)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'left\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translate3d(-100%, 0, 0)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'left-origin-center\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translate3d(0%, 0, 0)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'right-origin-center\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translate3d(0%, 0, 0)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'center\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translate3d(0%, 0, 0)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'right\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translate3d(100%, 0, 0)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'* => left, * => right, left => center, right => center\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'500ms cubic-bezier(0.35, 0, 0.25, 1)\\')),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'void => left-origin-center\\', [\\n                            __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translate3d(-100%, 0, 0)\\' }),\\n                            __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'500ms cubic-bezier(0.35, 0, 0.25, 1)\\')\\n                        ]),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'void => right-origin-center\\', [\\n                            __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translate3d(100%, 0, 0)\\' }),\\n                            __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'500ms cubic-bezier(0.35, 0, 0.25, 1)\\')\\n                        ])\\n                    ])\\n                ]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabBody.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdTabBody.propDecorators = {\\n    \\'_portalHost\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"O\" /* PortalHostDirective */],] },],\\n    \\'onCentering\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'onCentered\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'_content\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'content\\',] },],\\n    \\'position\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'position\\',] },],\\n    \\'origin\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'origin\\',] },],\\n};\\n/**\\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\\n * provide a small affordance to the label next to it.\\n */\\nvar EXAGGERATED_OVERSCROLL = 60;\\n/**\\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\\n * an ink bar that follows the currently selected tab. When the tabs list\\'s width exceeds the\\n * width of the header container, then arrows will be displayed to allow the user to scroll\\n * left and right across the header.\\n * \\\\@docs-private\\n */\\nvar MdTabHeader = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _ngZone\\n     * @param {?} _renderer\\n     * @param {?} _dir\\n     */\\n    function MdTabHeader(_elementRef, _ngZone, _renderer, _dir) {\\n        this._elementRef = _elementRef;\\n        this._ngZone = _ngZone;\\n        this._renderer = _renderer;\\n        this._dir = _dir;\\n        /**\\n         * The tab index that is focused.\\n         */\\n        this._focusIndex = 0;\\n        /**\\n         * The distance in pixels that the tab labels should be translated to the left.\\n         */\\n        this._scrollDistance = 0;\\n        /**\\n         * Whether the header should scroll to the selected index after the view has been checked.\\n         */\\n        this._selectedIndexChanged = false;\\n        /**\\n         * Combines listeners that will re-align the ink bar whenever they\\'re invoked.\\n         */\\n        this._realignInkBar = null;\\n        /**\\n         * Whether the controls for pagination should be displayed\\n         */\\n        this._showPaginationControls = false;\\n        /**\\n         * Whether the tab list can be scrolled more towards the end of the tab label list.\\n         */\\n        this._disableScrollAfter = true;\\n        /**\\n         * Whether the tab list can be scrolled more towards the beginning of the tab label list.\\n         */\\n        this._disableScrollBefore = true;\\n        this._selectedIndex = 0;\\n        this._disableRipple = false;\\n        /**\\n         * Event emitted when the option is selected.\\n         */\\n        this.selectFocusedIndex = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when a label is focused.\\n         */\\n        this.indexFocused = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(MdTabHeader.prototype, \"selectedIndex\", {\\n        /**\\n         * The index of the active tab.\\n         * @return {?}\\n         */\\n        get: function () { return this._selectedIndex; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._selectedIndexChanged = this._selectedIndex != value;\\n            this._selectedIndex = value;\\n            this._focusIndex = value;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTabHeader.prototype, \"disableRipple\", {\\n        /**\\n         * Whether ripples for the tab-header labels should be disabled or not.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableRipple; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._disableRipple = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype.ngAfterContentChecked = function () {\\n        // If the number of tab labels have changed, check if scrolling should be enabled\\n        if (this._tabLabelCount != this._labelWrappers.length) {\\n            this._updatePagination();\\n            this._tabLabelCount = this._labelWrappers.length;\\n        }\\n        // If the selected index has changed, scroll to the label and check if the scrolling controls\\n        // should be disabled.\\n        if (this._selectedIndexChanged) {\\n            this._scrollToLabel(this._selectedIndex);\\n            this._checkScrollingControls();\\n            this._alignInkBarToSelectedTab();\\n            this._selectedIndexChanged = false;\\n        }\\n        // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\\n        // then translate the header to reflect this.\\n        if (this._scrollDistanceChanged) {\\n            this._updateTabScrollPosition();\\n            this._scrollDistanceChanged = false;\\n        }\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._handleKeydown = function (event) {\\n        switch (event.keyCode) {\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Q\" /* RIGHT_ARROW */]:\\n                this._focusNextTab();\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"C\" /* LEFT_ARROW */]:\\n                this._focusPreviousTab();\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"u\" /* ENTER */]:\\n                this.selectFocusedIndex.emit(this.focusIndex);\\n                break;\\n        }\\n    };\\n    /**\\n     * Aligns the ink bar to the selected tab on load.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._realignInkBar = this._ngZone.runOutsideAngular(function () {\\n            var /** @type {?} */ dirChange = _this._dir ? _this._dir.change : __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__[\"of\"](null);\\n            var /** @type {?} */ resize = typeof window !== \\'undefined\\' ?\\n                __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"X\" /* auditTime */].call(__WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromEvent__[\"fromEvent\"](window, \\'resize\\'), 10) :\\n                __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__[\"of\"](null);\\n            return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_9\" /* startWith */].call(__WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge__[\"merge\"](dirChange, resize), null).subscribe(function () {\\n                _this._updatePagination();\\n                _this._alignInkBarToSelectedTab();\\n            });\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype.ngOnDestroy = function () {\\n        if (this._realignInkBar) {\\n            this._realignInkBar.unsubscribe();\\n            this._realignInkBar = null;\\n        }\\n    };\\n    /**\\n     * Callback for when the MutationObserver detects that the content has changed.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._onContentChanges = function () {\\n        this._updatePagination();\\n        this._alignInkBarToSelectedTab();\\n    };\\n    /**\\n     * Updating the view whether pagination should be enabled or not\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._updatePagination = function () {\\n        this._checkPaginationEnabled();\\n        this._checkScrollingControls();\\n        this._updateTabScrollPosition();\\n    };\\n    Object.defineProperty(MdTabHeader.prototype, \"focusIndex\", {\\n        /**\\n         * Tracks which element has focus; used for keyboard navigation\\n         * @return {?}\\n         */\\n        get: function () { return this._focusIndex; },\\n        /**\\n         * When the focus index is set, we must manually send focus to the correct label\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (!this._isValidIndex(value) || this._focusIndex == value) {\\n                return;\\n            }\\n            this._focusIndex = value;\\n            this.indexFocused.emit(value);\\n            this._setTabFocus(value);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\\n     * providing a valid index and return true.\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._isValidIndex = function (index) {\\n        if (!this._labelWrappers) {\\n            return true;\\n        }\\n        var /** @type {?} */ tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\\n        return !!tab && !tab.disabled;\\n    };\\n    /**\\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\\n     * scrolling is enabled.\\n     * @param {?} tabIndex\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._setTabFocus = function (tabIndex) {\\n        if (this._showPaginationControls) {\\n            this._scrollToLabel(tabIndex);\\n        }\\n        if (this._labelWrappers && this._labelWrappers.length) {\\n            this._labelWrappers.toArray()[tabIndex].focus();\\n            // Do not let the browser manage scrolling to focus the element, this will be handled\\n            // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\\n            // should be the full width minus the offset width.\\n            var /** @type {?} */ containerEl = this._tabListContainer.nativeElement;\\n            var /** @type {?} */ dir = this._getLayoutDirection();\\n            if (dir == \\'ltr\\') {\\n                containerEl.scrollLeft = 0;\\n            }\\n            else {\\n                containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\\n            }\\n        }\\n    };\\n    /**\\n     * Moves the focus towards the beginning or the end of the list depending on the offset provided.\\n     * Valid offsets are 1 and -1.\\n     * @param {?} offset\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._moveFocus = function (offset) {\\n        if (this._labelWrappers) {\\n            var /** @type {?} */ tabs = this._labelWrappers.toArray();\\n            for (var /** @type {?} */ i = this.focusIndex + offset; i < tabs.length && i >= 0; i += offset) {\\n                if (this._isValidIndex(i)) {\\n                    this.focusIndex = i;\\n                    return;\\n                }\\n            }\\n        }\\n    };\\n    /**\\n     * Increment the focus index by 1 until a valid tab is found.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._focusNextTab = function () {\\n        this._moveFocus(this._getLayoutDirection() == \\'ltr\\' ? 1 : -1);\\n    };\\n    /**\\n     * Decrement the focus index by 1 until a valid tab is found.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._focusPreviousTab = function () {\\n        this._moveFocus(this._getLayoutDirection() == \\'ltr\\' ? -1 : 1);\\n    };\\n    /**\\n     * The layout direction of the containing app.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._getLayoutDirection = function () {\\n        return this._dir && this._dir.value === \\'rtl\\' ? \\'rtl\\' : \\'ltr\\';\\n    };\\n    /**\\n     * Performs the CSS transformation on the tab list that will cause the list to scroll.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._updateTabScrollPosition = function () {\\n        var /** @type {?} */ scrollDistance = this.scrollDistance;\\n        var /** @type {?} */ translateX = this._getLayoutDirection() === \\'ltr\\' ? -scrollDistance : scrollDistance;\\n        this._renderer.setStyle(this._tabList.nativeElement, \\'transform\\', \"translate3d(\" + translateX + \"px, 0, 0)\");\\n    };\\n    Object.defineProperty(MdTabHeader.prototype, \"scrollDistance\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._scrollDistance; },\\n        /**\\n         * Sets the distance in pixels that the tab header should be transformed in the X-axis.\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));\\n            // Mark that the scroll distance has changed so that after the view is checked, the CSS\\n            // transformation can move the header.\\n            this._scrollDistanceChanged = true;\\n            this._checkScrollingControls();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Moves the tab list in the \\'before\\' or \\'after\\' direction (towards the beginning of the list or\\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\\n     * length of the tab list view window.\\n     *\\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\\n     * should be called sparingly.\\n     * @param {?} scrollDir\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._scrollHeader = function (scrollDir) {\\n        var /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\\n        // Move the scroll distance one-third the length of the tab list\\'s viewport.\\n        this.scrollDistance += (scrollDir == \\'before\\' ? -1 : 1) * viewLength / 3;\\n    };\\n    /**\\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\\n     *\\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\\n     * should be called sparingly.\\n     * @param {?} labelIndex\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._scrollToLabel = function (labelIndex) {\\n        var /** @type {?} */ selectedLabel = this._labelWrappers\\n            ? this._labelWrappers.toArray()[labelIndex]\\n            : null;\\n        if (!selectedLabel) {\\n            return;\\n        }\\n        // The view length is the visible width of the tab labels.\\n        var /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\\n        var /** @type {?} */ labelBeforePos, /** @type {?} */ labelAfterPos;\\n        if (this._getLayoutDirection() == \\'ltr\\') {\\n            labelBeforePos = selectedLabel.getOffsetLeft();\\n            labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\\n        }\\n        else {\\n            labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\\n            labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\\n        }\\n        var /** @type {?} */ beforeVisiblePos = this.scrollDistance;\\n        var /** @type {?} */ afterVisiblePos = this.scrollDistance + viewLength;\\n        if (labelBeforePos < beforeVisiblePos) {\\n            // Scroll header to move label to the before direction\\n            this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\\n        }\\n        else if (labelAfterPos > afterVisiblePos) {\\n            // Scroll header to move label to the after direction\\n            this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\\n        }\\n    };\\n    /**\\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\\n     * tab list is wider than the size of the header container, then the pagination controls should\\n     * be shown.\\n     *\\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\\n     * should be called sparingly.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._checkPaginationEnabled = function () {\\n        this._showPaginationControls =\\n            this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\\n        if (!this._showPaginationControls) {\\n            this.scrollDistance = 0;\\n        }\\n    };\\n    /**\\n     * Evaluate whether the before and after controls should be enabled or disabled.\\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\\n     * before button. If the header is at the end of the list (scroll distance is equal to the\\n     * maximum distance we can scroll), then disable the after button.\\n     *\\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\\n     * should be called sparingly.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._checkScrollingControls = function () {\\n        // Check if the pagination arrows should be activated.\\n        this._disableScrollBefore = this.scrollDistance == 0;\\n        this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\\n    };\\n    /**\\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\\n     * is equal to the difference in width between the tab list container and tab header container.\\n     *\\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\\n     * should be called sparingly.\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._getMaxScrollDistance = function () {\\n        var /** @type {?} */ lengthOfTabList = this._tabList.nativeElement.scrollWidth;\\n        var /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\\n        return (lengthOfTabList - viewLength) || 0;\\n    };\\n    /**\\n     * Tells the ink-bar to align itself to the current label wrapper\\n     * @return {?}\\n     */\\n    MdTabHeader.prototype._alignInkBarToSelectedTab = function () {\\n        var /** @type {?} */ selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length\\n            ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement\\n            : null;\\n        this._inkBar.alignToElement(selectedLabelWrapper);\\n    };\\n    return MdTabHeader;\\n}());\\nMdTabHeader.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-tab-header, mat-tab-header\\',\\n                template: \"<div class=\\\\\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\\\\\" aria-hidden=\\\\\"true\\\\\" md-ripple [mdRippleDisabled]=\\\\\"_disableScrollBefore || disableRipple\\\\\" [class.mat-tab-header-pagination-disabled]=\\\\\"_disableScrollBefore\\\\\" (click)=\\\\\"_scrollHeader(\\'before\\')\\\\\"><div class=\\\\\"mat-tab-header-pagination-chevron\\\\\"></div></div><div class=\\\\\"mat-tab-label-container\\\\\" #tabListContainer (keydown)=\\\\\"_handleKeydown($event)\\\\\"><div class=\\\\\"mat-tab-list\\\\\" #tabList role=\\\\\"tablist\\\\\" (cdkObserveContent)=\\\\\"_onContentChanges()\\\\\"><div class=\\\\\"mat-tab-labels\\\\\"><ng-content></ng-content></div><md-ink-bar></md-ink-bar></div></div><div class=\\\\\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\\\\\" aria-hidden=\\\\\"true\\\\\" md-ripple [mdRippleDisabled]=\\\\\"_disableScrollAfter || disableRipple\\\\\" [class.mat-tab-header-pagination-disabled]=\\\\\"_disableScrollAfter\\\\\" (click)=\\\\\"_scrollHeader(\\'after\\')\\\\\"><div class=\\\\\"mat-tab-header-pagination-chevron\\\\\"></div></div>\",\\n                styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{line-height:48px;height:48px;padding:0 12px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;position:relative}.mat-tab-label:focus{outline:0;opacity:1}.mat-tab-label.mat-tab-disabled{cursor:default;pointer-events:none}@media (max-width:600px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.mat-tab-header-pagination{position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\\'\\';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#ccc}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'class\\': \\'mat-tab-header\\',\\n                    \\'[class.mat-tab-header-pagination-controls-enabled]\\': \\'_showPaginationControls\\',\\n                    \\'[class.mat-tab-header-rtl]\\': \"_getLayoutDirection() == \\'rtl\\'\",\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabHeader.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdTabHeader.propDecorators = {\\n    \\'_labelWrappers\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdTabLabelWrapper,] },],\\n    \\'_inkBar\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdInkBar,] },],\\n    \\'_tabListContainer\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'tabListContainer\\',] },],\\n    \\'_tabList\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'tabList\\',] },],\\n    \\'selectedIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'disableRipple\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectFocusedIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'indexFocused\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdTabsModule = /*@__PURE__*/(function () {\\n    function MdTabsModule() {\\n    }\\n    return MdTabsModule;\\n}());\\nMdTabsModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"],\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"P\" /* PortalModule */],\\n                    MdRippleModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"I\" /* ObserveContentModule */],\\n                    ScrollDispatchModule,\\n                ],\\n                // Don\\'t export all components because some are only to be used internally.\\n                exports: [\\n                    MdTabGroup,\\n                    MdTabLabel,\\n                    MdTab,\\n                    MdTabNav,\\n                    MdTabLink,\\n                ],\\n                declarations: [\\n                    MdTabGroup,\\n                    MdTabLabel,\\n                    MdTab,\\n                    MdInkBar,\\n                    MdTabLabelWrapper,\\n                    MdTabNav,\\n                    MdTabLink,\\n                    MdTabBody,\\n                    MdTabHeader\\n                ],\\n                providers: [VIEWPORT_RULER_PROVIDER],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTabsModule.ctorParameters = function () { return []; };\\nvar MdToolbarRow = /*@__PURE__*/(function () {\\n    function MdToolbarRow() {\\n    }\\n    return MdToolbarRow;\\n}());\\nMdToolbarRow.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-toolbar-row, mat-toolbar-row\\',\\n                host: { \\'class\\': \\'mat-toolbar-row\\' },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdToolbarRow.ctorParameters = function () { return []; };\\n/**\\n * \\\\@docs-private\\n */\\nvar MdToolbarBase = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _renderer\\n     * @param {?} _elementRef\\n     */\\n    function MdToolbarBase(_renderer, _elementRef) {\\n        this._renderer = _renderer;\\n        this._elementRef = _elementRef;\\n    }\\n    return MdToolbarBase;\\n}());\\nvar _MdToolbarMixinBase = mixinColor(MdToolbarBase);\\nvar MdToolbar = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdToolbar, _super);\\n    /**\\n     * @param {?} renderer\\n     * @param {?} elementRef\\n     */\\n    function MdToolbar(renderer, elementRef) {\\n        return _super.call(this, renderer, elementRef) || this;\\n    }\\n    return MdToolbar;\\n}(_MdToolbarMixinBase));\\nMdToolbar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-toolbar, mat-toolbar\\',\\n                template: \"<div class=\\\\\"mat-toolbar-layout\\\\\"><md-toolbar-row><ng-content></ng-content></md-toolbar-row><ng-content select=\\\\\"md-toolbar-row, mat-toolbar-row\\\\\"></ng-content></div>\",\\n                styles: [\".mat-toolbar{display:flex;box-sizing:border-box;width:100%;padding:0 16px;flex-direction:column}.mat-toolbar .mat-toolbar-row{display:flex;box-sizing:border-box;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar{min-height:64px}.mat-toolbar-row{height:64px}@media (max-width:600px){.mat-toolbar{min-height:56px}.mat-toolbar-row{height:56px}}\"],\\n                inputs: [\\'color\\'],\\n                host: {\\n                    \\'class\\': \\'mat-toolbar\\',\\n                    \\'role\\': \\'toolbar\\'\\n                },\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdToolbar.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nvar MdToolbarModule = /*@__PURE__*/(function () {\\n    function MdToolbarModule() {\\n    }\\n    return MdToolbarModule;\\n}());\\nMdToolbarModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdCommonModule],\\n                exports: [MdToolbar, MdToolbarRow, MdCommonModule],\\n                declarations: [MdToolbar, MdToolbarRow],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdToolbarModule.ctorParameters = function () { return []; };\\n/**\\n * Time in ms to delay before changing the tooltip visibility to hidden\\n */\\nvar TOUCHEND_HIDE_DELAY = 1500;\\n/**\\n * Time in ms to throttle repositioning after scroll events.\\n */\\nvar SCROLL_THROTTLE_MS = 20;\\n/**\\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\\n * @param {?} position\\n * @return {?}\\n */\\nfunction getMdTooltipInvalidPositionError(position) {\\n    return Error(\"Tooltip position \\\\\"\" + position + \"\\\\\" is invalid.\");\\n}\\n/**\\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\\n * hiding of a tooltip provided position (defaults to below the element).\\n *\\n * https://material.google.com/components/tooltips.html\\n */\\nvar MdTooltip = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlay\\n     * @param {?} _elementRef\\n     * @param {?} _scrollDispatcher\\n     * @param {?} _viewContainerRef\\n     * @param {?} _ngZone\\n     * @param {?} _renderer\\n     * @param {?} _platform\\n     * @param {?} _dir\\n     */\\n    function MdTooltip(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _renderer, _platform, _dir) {\\n        var _this = this;\\n        this._overlay = _overlay;\\n        this._elementRef = _elementRef;\\n        this._scrollDispatcher = _scrollDispatcher;\\n        this._viewContainerRef = _viewContainerRef;\\n        this._ngZone = _ngZone;\\n        this._renderer = _renderer;\\n        this._platform = _platform;\\n        this._dir = _dir;\\n        this._position = \\'below\\';\\n        this._disabled = false;\\n        /**\\n         * The default delay in ms before showing the tooltip after show is called\\n         */\\n        this.showDelay = 0;\\n        /**\\n         * The default delay in ms before hiding the tooltip after hide is called\\n         */\\n        this.hideDelay = 0;\\n        // The mouse events shouldn\\'t be bound on iOS devices, because\\n        // they can prevent the first tap from firing its click event.\\n        if (!_platform.IOS) {\\n            _renderer.listen(_elementRef.nativeElement, \\'mouseenter\\', function () { return _this.show(); });\\n            _renderer.listen(_elementRef.nativeElement, \\'mouseleave\\', function () { return _this.hide(); });\\n        }\\n    }\\n    Object.defineProperty(MdTooltip.prototype, \"position\", {\\n        /**\\n         * Allows the user to define the position of the tooltip relative to the parent element\\n         * @return {?}\\n         */\\n        get: function () { return this._position; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value !== this._position) {\\n                this._position = value;\\n                // TODO(andrewjs): When the overlay\\'s position can be dynamically changed, do not destroy\\n                // the tooltip.\\n                if (this._tooltipInstance) {\\n                    this._disposeTooltip();\\n                }\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"disabled\", {\\n        /**\\n         * Disables the display of the tooltip.\\n         * @return {?}\\n         */\\n        get: function () { return this._disabled; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._disabled = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](value);\\n            // If tooltip is disabled, hide immediately.\\n            if (this._disabled) {\\n                this.hide(0);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_positionDeprecated\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this._position; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this._position = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"message\", {\\n        /**\\n         * The message to be displayed in the tooltip\\n         * @return {?}\\n         */\\n        get: function () { return this._message; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._message = value;\\n            this._setTooltipMessage(this._message);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"tooltipClass\", {\\n        /**\\n         * Classes to be passed to the tooltip. Supports the same syntax as `ngClass`.\\n         * @return {?}\\n         */\\n        get: function () { return this._tooltipClass; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._tooltipClass = value;\\n            if (this._tooltipInstance) {\\n                this._setTooltipClass(this._tooltipClass);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_deprecatedMessage\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this.message; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.message = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matMessage\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.message; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.message = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matPosition\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.position; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.position = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matDisabled\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.disabled; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.disabled = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matHideDelay\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.hideDelay; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.hideDelay = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matShowDelay\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.showDelay; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.showDelay = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdTooltip.prototype, \"_matClass\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.tooltipClass; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.tooltipClass = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Dispose the tooltip when destroyed.\\n     * @return {?}\\n     */\\n    MdTooltip.prototype.ngOnDestroy = function () {\\n        if (this._tooltipInstance) {\\n            this._disposeTooltip();\\n        }\\n    };\\n    /**\\n     * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input\\n     * @param {?=} delay\\n     * @return {?}\\n     */\\n    MdTooltip.prototype.show = function (delay) {\\n        if (delay === void 0) { delay = this.showDelay; }\\n        if (this.disabled || !this._message || !this._message.trim()) {\\n            return;\\n        }\\n        if (!this._tooltipInstance) {\\n            this._createTooltip();\\n        }\\n        this._setTooltipClass(this._tooltipClass);\\n        this._setTooltipMessage(this._message); /** @type {?} */\\n        ((this._tooltipInstance)).show(this._position, delay);\\n    };\\n    /**\\n     * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input\\n     * @param {?=} delay\\n     * @return {?}\\n     */\\n    MdTooltip.prototype.hide = function (delay) {\\n        if (delay === void 0) { delay = this.hideDelay; }\\n        if (this._tooltipInstance) {\\n            this._tooltipInstance.hide(delay);\\n        }\\n    };\\n    /**\\n     * Shows/hides the tooltip\\n     * @return {?}\\n     */\\n    MdTooltip.prototype.toggle = function () {\\n        this._isTooltipVisible() ? this.hide() : this.show();\\n    };\\n    /**\\n     * Returns true if the tooltip is currently visible to the user\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._isTooltipVisible = function () {\\n        return !!this._tooltipInstance && this._tooltipInstance.isVisible();\\n    };\\n    /**\\n     * Create the tooltip to display\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._createTooltip = function () {\\n        var _this = this;\\n        var /** @type {?} */ overlayRef = this._createOverlay();\\n        var /** @type {?} */ portal = new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"n\" /* ComponentPortal */](TooltipComponent, this._viewContainerRef);\\n        this._tooltipInstance = overlayRef.attach(portal).instance; /** @type {?} */\\n        ((\\n        // Dispose the overlay when finished the shown tooltip.\\n        this._tooltipInstance)).afterHidden().subscribe(function () {\\n            // Check first if the tooltip has already been removed through this components destroy.\\n            if (_this._tooltipInstance) {\\n                _this._disposeTooltip();\\n            }\\n        });\\n    };\\n    /**\\n     * Create the overlay config and position strategy\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._createOverlay = function () {\\n        var _this = this;\\n        var /** @type {?} */ origin = this._getOrigin();\\n        var /** @type {?} */ position = this._getOverlayPosition();\\n        // Create connected position strategy that listens for scroll events to reposition.\\n        // After position changes occur and the overlay is clipped by a parent scrollable then\\n        // close the tooltip.\\n        var /** @type {?} */ strategy = this._overlay.position().connectedTo(this._elementRef, origin, position);\\n        strategy.withScrollableContainers(this._scrollDispatcher.getScrollContainers(this._elementRef));\\n        strategy.onPositionChange.subscribe(function (change) {\\n            if (change.scrollableViewProperties.isOverlayClipped &&\\n                _this._tooltipInstance && _this._tooltipInstance.isVisible()) {\\n                _this.hide(0);\\n            }\\n        });\\n        var /** @type {?} */ config = new OverlayState();\\n        config.direction = this._dir ? this._dir.value : \\'ltr\\';\\n        config.positionStrategy = strategy;\\n        config.scrollStrategy = this._overlay.scrollStrategies.reposition({\\n            scrollThrottle: SCROLL_THROTTLE_MS\\n        });\\n        this._overlayRef = this._overlay.create(config);\\n        return this._overlayRef;\\n    };\\n    /**\\n     * Disposes the current tooltip and the overlay it is attached to\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._disposeTooltip = function () {\\n        if (this._overlayRef) {\\n            this._overlayRef.dispose();\\n            this._overlayRef = null;\\n        }\\n        this._tooltipInstance = null;\\n    };\\n    /**\\n     * Returns the origin position based on the user\\'s position preference\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._getOrigin = function () {\\n        if (this.position == \\'above\\' || this.position == \\'below\\') {\\n            return { originX: \\'center\\', originY: this.position == \\'above\\' ? \\'top\\' : \\'bottom\\' };\\n        }\\n        var /** @type {?} */ isDirectionLtr = !this._dir || this._dir.value == \\'ltr\\';\\n        if (this.position == \\'left\\' ||\\n            this.position == \\'before\\' && isDirectionLtr ||\\n            this.position == \\'after\\' && !isDirectionLtr) {\\n            return { originX: \\'start\\', originY: \\'center\\' };\\n        }\\n        if (this.position == \\'right\\' ||\\n            this.position == \\'after\\' && isDirectionLtr ||\\n            this.position == \\'before\\' && !isDirectionLtr) {\\n            return { originX: \\'end\\', originY: \\'center\\' };\\n        }\\n        throw getMdTooltipInvalidPositionError(this.position);\\n    };\\n    /**\\n     * Returns the overlay position based on the user\\'s preference\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._getOverlayPosition = function () {\\n        if (this.position == \\'above\\') {\\n            return { overlayX: \\'center\\', overlayY: \\'bottom\\' };\\n        }\\n        if (this.position == \\'below\\') {\\n            return { overlayX: \\'center\\', overlayY: \\'top\\' };\\n        }\\n        var /** @type {?} */ isLtr = !this._dir || this._dir.value == \\'ltr\\';\\n        if (this.position == \\'left\\' ||\\n            this.position == \\'before\\' && isLtr ||\\n            this.position == \\'after\\' && !isLtr) {\\n            return { overlayX: \\'end\\', overlayY: \\'center\\' };\\n        }\\n        if (this.position == \\'right\\' ||\\n            this.position == \\'after\\' && isLtr ||\\n            this.position == \\'before\\' && !isLtr) {\\n            return { overlayX: \\'start\\', overlayY: \\'center\\' };\\n        }\\n        throw getMdTooltipInvalidPositionError(this.position);\\n    };\\n    /**\\n     * Updates the tooltip message and repositions the overlay according to the new message length\\n     * @param {?} message\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._setTooltipMessage = function (message) {\\n        var _this = this;\\n        // Must wait for the message to be painted to the tooltip so that the overlay can properly\\n        // calculate the correct positioning based on the size of the text.\\n        if (this._tooltipInstance) {\\n            this._tooltipInstance.message = message;\\n            this._tooltipInstance._markForCheck();\\n            __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_4\" /* first */].call(this._ngZone.onMicrotaskEmpty).subscribe(function () {\\n                if (_this._tooltipInstance) {\\n                    ((_this._overlayRef)).updatePosition();\\n                }\\n            });\\n        }\\n    };\\n    /**\\n     * Updates the tooltip class\\n     * @param {?} tooltipClass\\n     * @return {?}\\n     */\\n    MdTooltip.prototype._setTooltipClass = function (tooltipClass) {\\n        if (this._tooltipInstance) {\\n            this._tooltipInstance.tooltipClass = tooltipClass;\\n            this._tooltipInstance._markForCheck();\\n        }\\n    };\\n    return MdTooltip;\\n}());\\nMdTooltip.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-tooltip], [mdTooltip], [mat-tooltip], [matTooltip]\\',\\n                host: {\\n                    \\'(longpress)\\': \\'show()\\',\\n                    \\'(touchend)\\': \\'hide(\\' + TOUCHEND_HIDE_DELAY + \\')\\',\\n                },\\n                exportAs: \\'mdTooltip\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTooltip.ctorParameters = function () { return [\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: ScrollDispatcher, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"L\" /* Platform */], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdTooltip.propDecorators = {\\n    \\'position\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltipPosition\\',] },],\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltipDisabled\\',] },],\\n    \\'_positionDeprecated\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'tooltip-position\\',] },],\\n    \\'showDelay\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltipShowDelay\\',] },],\\n    \\'hideDelay\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltipHideDelay\\',] },],\\n    \\'message\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltip\\',] },],\\n    \\'tooltipClass\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdTooltipClass\\',] },],\\n    \\'_deprecatedMessage\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'md-tooltip\\',] },],\\n    \\'_matMessage\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltip\\',] },],\\n    \\'_matPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltipPosition\\',] },],\\n    \\'_matDisabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltipDisabled\\',] },],\\n    \\'_matHideDelay\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltipHideDelay\\',] },],\\n    \\'_matShowDelay\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltipShowDelay\\',] },],\\n    \\'_matClass\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matTooltipClass\\',] },],\\n};\\n/**\\n * Internal component that wraps the tooltip\\'s content.\\n * \\\\@docs-private\\n */\\nvar TooltipComponent = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dir\\n     * @param {?} _changeDetectorRef\\n     */\\n    function TooltipComponent(_dir, _changeDetectorRef) {\\n        this._dir = _dir;\\n        this._changeDetectorRef = _changeDetectorRef;\\n        /**\\n         * Property watched by the animation framework to show or hide the tooltip\\n         */\\n        this._visibility = \\'initial\\';\\n        /**\\n         * Whether interactions on the page should close the tooltip\\n         */\\n        this._closeOnInteraction = false;\\n        /**\\n         * The transform origin used in the animation for showing and hiding the tooltip\\n         */\\n        this._transformOrigin = \\'bottom\\';\\n        /**\\n         * Subject for notifying that the tooltip has been hidden from the view\\n         */\\n        this._onHide = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n    }\\n    /**\\n     * Shows the tooltip with an animation originating from the provided origin\\n     * @param {?} position Position of the tooltip.\\n     * @param {?} delay Amount of milliseconds to the delay showing the tooltip.\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype.show = function (position, delay) {\\n        var _this = this;\\n        // Cancel the delayed hide if it is scheduled\\n        if (this._hideTimeoutId) {\\n            clearTimeout(this._hideTimeoutId);\\n        }\\n        // Body interactions should cancel the tooltip if there is a delay in showing.\\n        this._closeOnInteraction = true;\\n        this._setTransformOrigin(position);\\n        this._showTimeoutId = setTimeout(function () {\\n            _this._visibility = \\'visible\\';\\n            // If this was set to true immediately, then a body click that triggers show() would\\n            // trigger interaction and close the tooltip right after it was displayed.\\n            _this._closeOnInteraction = false;\\n            // Mark for check so if any parent component has set the\\n            // ChangeDetectionStrategy to OnPush it will be checked anyways\\n            _this._markForCheck();\\n            setTimeout(function () { return _this._closeOnInteraction = true; }, 0);\\n        }, delay);\\n    };\\n    /**\\n     * Begins the animation to hide the tooltip after the provided delay in ms.\\n     * @param {?} delay Amount of milliseconds to delay showing the tooltip.\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype.hide = function (delay) {\\n        var _this = this;\\n        // Cancel the delayed show if it is scheduled\\n        if (this._showTimeoutId) {\\n            clearTimeout(this._showTimeoutId);\\n        }\\n        this._hideTimeoutId = setTimeout(function () {\\n            _this._visibility = \\'hidden\\';\\n            _this._closeOnInteraction = false;\\n            // Mark for check so if any parent component has set the\\n            // ChangeDetectionStrategy to OnPush it will be checked anyways\\n            _this._markForCheck();\\n        }, delay);\\n    };\\n    /**\\n     * Returns an observable that notifies when the tooltip has been hidden from view\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype.afterHidden = function () {\\n        return this._onHide.asObservable();\\n    };\\n    /**\\n     * Whether the tooltip is being displayed\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype.isVisible = function () {\\n        return this._visibility === \\'visible\\';\\n    };\\n    /**\\n     * Sets the tooltip transform origin according to the tooltip position\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype._setTransformOrigin = function (value) {\\n        var /** @type {?} */ isLtr = !this._dir || this._dir.value == \\'ltr\\';\\n        switch (value) {\\n            case \\'before\\':\\n                this._transformOrigin = isLtr ? \\'right\\' : \\'left\\';\\n                break;\\n            case \\'after\\':\\n                this._transformOrigin = isLtr ? \\'left\\' : \\'right\\';\\n                break;\\n            case \\'left\\':\\n                this._transformOrigin = \\'right\\';\\n                break;\\n            case \\'right\\':\\n                this._transformOrigin = \\'left\\';\\n                break;\\n            case \\'above\\':\\n                this._transformOrigin = \\'bottom\\';\\n                break;\\n            case \\'below\\':\\n                this._transformOrigin = \\'top\\';\\n                break;\\n            default: throw getMdTooltipInvalidPositionError(value);\\n        }\\n    };\\n    /**\\n     * @param {?} e\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype._afterVisibilityAnimation = function (e) {\\n        if (e.toState === \\'hidden\\' && !this.isVisible()) {\\n            this._onHide.next();\\n        }\\n    };\\n    /**\\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\\n     * material design spec.\\n     * https://material.google.com/components/tooltips.html#tooltips-interaction\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype._handleBodyInteraction = function () {\\n        if (this._closeOnInteraction) {\\n            this.hide(0);\\n        }\\n    };\\n    /**\\n     * Marks that the tooltip needs to be checked in the next change detection run.\\n     * Mainly used for rendering the initial text before positioning a tooltip, which\\n     * can be problematic in components with OnPush change detection.\\n     * @return {?}\\n     */\\n    TooltipComponent.prototype._markForCheck = function () {\\n        this._changeDetectorRef.markForCheck();\\n    };\\n    return TooltipComponent;\\n}());\\nTooltipComponent.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-tooltip-component, mat-tooltip-component\\',\\n                template: \"<div class=\\\\\"mat-tooltip\\\\\" [ngClass]=\\\\\"tooltipClass\\\\\" [style.transform-origin]=\\\\\"_transformOrigin\\\\\" [@state]=\\\\\"_visibility\\\\\" (@state.done)=\\\\\"_afterVisibilityAnimation($event)\\\\\">{{message}}</div>\",\\n                styles: [\":host{pointer-events:none}.mat-tooltip{color:#fff;border-radius:2px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px}@media screen and (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                animations: [\\n                    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'state\\', [\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'void\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'scale(0)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'initial\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'scale(0)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'visible\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'scale(1)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'hidden\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'scale(0)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'* => visible\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'150ms cubic-bezier(0.0, 0.0, 0.2, 1)\\')),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'* => hidden\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'150ms cubic-bezier(0.4, 0.0, 1, 1)\\')),\\n                    ])\\n                ],\\n                host: {\\n                    // Forces the element to have a layout in IE and Edge. This fixes issues where the element\\n                    // won\\'t be rendered if the animations are disabled or there is no web animations polyfill.\\n                    \\'[style.zoom]\\': \\'_visibility === \"visible\" ? 1 : null\\',\\n                    \\'(body:click)\\': \\'this._handleBodyInteraction()\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nTooltipComponent.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n]; };\\nvar MdTooltipModule = /*@__PURE__*/(function () {\\n    function MdTooltipModule() {\\n    }\\n    return MdTooltipModule;\\n}());\\nMdTooltipModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"],\\n                    OverlayModule,\\n                    MdCommonModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"M\" /* PlatformModule */]\\n                ],\\n                exports: [MdTooltip, TooltipComponent, MdCommonModule],\\n                declarations: [MdTooltip, TooltipComponent],\\n                entryComponents: [TooltipComponent],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTooltipModule.ctorParameters = function () { return []; };\\n/**\\n * Throws an exception for the case when menu trigger doesn\\'t have a valid md-menu instance\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwMdMenuMissingError() {\\n    throw Error(\"md-menu-trigger: must pass in an md-menu instance.\\\\n\\\\n    Example:\\\\n      <md-menu #menu=\\\\\"mdMenu\\\\\"></md-menu>\\\\n      <button [mdMenuTriggerFor]=\\\\\"menu\\\\\"></button>\");\\n}\\n/**\\n * Throws an exception for the case when menu\\'s x-position value isn\\'t valid.\\n * In other words, it doesn\\'t match \\'before\\' or \\'after\\'.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwMdMenuInvalidPositionX() {\\n    throw Error(\"x-position value must be either \\'before\\' or after\\'.\\\\n      Example: <md-menu x-position=\\\\\"before\\\\\" #menu=\\\\\"mdMenu\\\\\"></md-menu>\");\\n}\\n/**\\n * Throws an exception for the case when menu\\'s y-position value isn\\'t valid.\\n * In other words, it doesn\\'t match \\'above\\' or \\'below\\'.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwMdMenuInvalidPositionY() {\\n    throw Error(\"y-position value must be either \\'above\\' or below\\'.\\\\n      Example: <md-menu y-position=\\\\\"above\\\\\" #menu=\\\\\"mdMenu\\\\\"></md-menu>\");\\n}\\n/**\\n * \\\\@docs-private\\n */\\nvar MdMenuItemBase = /*@__PURE__*/(function () {\\n    function MdMenuItemBase() {\\n    }\\n    return MdMenuItemBase;\\n}());\\nvar _MdMenuItemMixinBase = mixinDisabled(MdMenuItemBase);\\n/**\\n * This directive is intended to be used inside an md-menu tag.\\n * It exists mostly to set the role attribute.\\n */\\nvar MdMenuItem = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdMenuItem, _super);\\n    /**\\n     * @param {?} _elementRef\\n     */\\n    function MdMenuItem(_elementRef) {\\n        var _this = _super.call(this) || this;\\n        _this._elementRef = _elementRef;\\n        return _this;\\n    }\\n    /**\\n     * Focuses the menu item.\\n     * @return {?}\\n     */\\n    MdMenuItem.prototype.focus = function () {\\n        this._getHostElement().focus();\\n    };\\n    /**\\n     * Used to set the `tabindex`.\\n     * @return {?}\\n     */\\n    MdMenuItem.prototype._getTabIndex = function () {\\n        return this.disabled ? \\'-1\\' : \\'0\\';\\n    };\\n    /**\\n     * Returns the host DOM element.\\n     * @return {?}\\n     */\\n    MdMenuItem.prototype._getHostElement = function () {\\n        return this._elementRef.nativeElement;\\n    };\\n    /**\\n     * Prevents the default element actions if it is disabled.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdMenuItem.prototype._checkDisabled = function (event) {\\n        if (this.disabled) {\\n            event.preventDefault();\\n            event.stopPropagation();\\n        }\\n    };\\n    return MdMenuItem;\\n}(_MdMenuItemMixinBase));\\nMdMenuItem.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'[md-menu-item], [mat-menu-item]\\',\\n                inputs: [\\'disabled\\'],\\n                host: {\\n                    \\'role\\': \\'menuitem\\',\\n                    \\'class\\': \\'mat-menu-item\\',\\n                    \\'[attr.tabindex]\\': \\'_getTabIndex()\\',\\n                    \\'[attr.aria-disabled]\\': \\'disabled.toString()\\',\\n                    \\'[attr.disabled]\\': \\'disabled || null\\',\\n                    \\'(click)\\': \\'_checkDisabled($event)\\',\\n                },\\n                template: \"<ng-content></ng-content><div class=\\\\\"mat-menu-ripple\\\\\" *ngIf=\\\\\"!disabled\\\\\" md-ripple [mdRippleTrigger]=\\\\\"_getHostElement()\\\\\"></div>\",\\n                exportAs: \\'mdMenuItem\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMenuItem.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\n/**\\n * Below are all the animations for the md-menu component.\\n * Animation duration and timing values are based on AngularJS Material.\\n */\\n/**\\n * This animation controls the menu panel\\'s entry and exit from the page.\\n *\\n * When the menu panel is added to the DOM, it scales in and fades in its border.\\n *\\n * When the menu panel is removed from the DOM, it simply fades out after a brief\\n * delay to display the ripple.\\n */\\n// TODO(kara): switch to :enter and :leave once Mobile Safari is sorted out.\\nvar transformMenu = __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'transformMenu\\', [\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'showing\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({\\n        opacity: 1,\\n        transform: \"scale(1)\"\\n    })),\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'void => *\\', [\\n        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({\\n            opacity: 0,\\n            transform: \"scale(0)\"\\n        }),\\n        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\"200ms cubic-bezier(0.25, 0.8, 0.25, 1)\")\\n    ]),\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'* => void\\', [\\n        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'50ms 100ms linear\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ opacity: 0 }))\\n    ])\\n]);\\n/**\\n * This animation fades in the background color and content of the menu panel\\n * after its containing element is scaled in.\\n */\\nvar fadeInItems = __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'fadeInItems\\', [\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'showing\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ opacity: 1 })),\\n    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'void => *\\', [\\n        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ opacity: 0 }),\\n        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\"200ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)\")\\n    ])\\n]);\\nvar MdMenu = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     */\\n    function MdMenu(_elementRef) {\\n        this._elementRef = _elementRef;\\n        this._xPosition = \\'after\\';\\n        this._yPosition = \\'below\\';\\n        /**\\n         * Config object to be passed into the menu\\'s ngClass\\n         */\\n        this._classList = {};\\n        /**\\n         * Whether the menu should overlap its trigger.\\n         */\\n        this.overlapTrigger = true;\\n        /**\\n         * Event emitted when the menu is closed.\\n         */\\n        this.close = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(MdMenu.prototype, \"xPosition\", {\\n        /**\\n         * Position of the menu in the X axis.\\n         * @return {?}\\n         */\\n        get: function () { return this._xPosition; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value !== \\'before\\' && value !== \\'after\\') {\\n                throwMdMenuInvalidPositionX();\\n            }\\n            this._xPosition = value;\\n            this.setPositionClasses();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdMenu.prototype, \"yPosition\", {\\n        /**\\n         * Position of the menu in the Y axis.\\n         * @return {?}\\n         */\\n        get: function () { return this._yPosition; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value !== \\'above\\' && value !== \\'below\\') {\\n                throwMdMenuInvalidPositionY();\\n            }\\n            this._yPosition = value;\\n            this.setPositionClasses();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdMenu.prototype, \"classList\", {\\n        /**\\n         * This method takes classes set on the host md-menu element and applies them on the\\n         * menu template that displays in the overlay container.  Otherwise, it\\'s difficult\\n         * to style the containing menu from outside the component.\\n         * @param {?} classes list of class names\\n         * @return {?}\\n         */\\n        set: function (classes) {\\n            if (classes && classes.length) {\\n                this._classList = classes.split(\\' \\').reduce(function (obj, className) {\\n                    obj[className] = true;\\n                    return obj;\\n                }, {});\\n                this._elementRef.nativeElement.className = \\'\\';\\n                this.setPositionClasses();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdMenu.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this._keyManager = new FocusKeyManager(this.items).withWrap();\\n        this._tabSubscription = this._keyManager.tabOut.subscribe(function () { return _this._emitCloseEvent(); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdMenu.prototype.ngOnDestroy = function () {\\n        if (this._tabSubscription) {\\n            this._tabSubscription.unsubscribe();\\n        }\\n    };\\n    /**\\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdMenu.prototype._handleKeydown = function (event) {\\n        switch (event.keyCode) {\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"v\" /* ESCAPE */]:\\n                this._emitCloseEvent();\\n                return;\\n            default:\\n                this._keyManager.onKeydown(event);\\n        }\\n    };\\n    /**\\n     * Focus the first item in the menu. This method is used by the menu trigger\\n     * to focus the first item when the menu is opened by the ENTER key.\\n     * @return {?}\\n     */\\n    MdMenu.prototype.focusFirstItem = function () {\\n        this._keyManager.setFirstItemActive();\\n    };\\n    /**\\n     * This emits a close event to which the trigger is subscribed. When emitted, the\\n     * trigger will close the menu.\\n     * @return {?}\\n     */\\n    MdMenu.prototype._emitCloseEvent = function () {\\n        this.close.emit();\\n    };\\n    /**\\n     * It\\'s necessary to set position-based classes to ensure the menu panel animation\\n     * folds out from the correct direction.\\n     * @param {?=} posX\\n     * @param {?=} posY\\n     * @return {?}\\n     */\\n    MdMenu.prototype.setPositionClasses = function (posX, posY) {\\n        if (posX === void 0) { posX = this.xPosition; }\\n        if (posY === void 0) { posY = this.yPosition; }\\n        this._classList[\\'mat-menu-before\\'] = posX === \\'before\\';\\n        this._classList[\\'mat-menu-after\\'] = posX === \\'after\\';\\n        this._classList[\\'mat-menu-above\\'] = posY === \\'above\\';\\n        this._classList[\\'mat-menu-below\\'] = posY === \\'below\\';\\n    };\\n    return MdMenu;\\n}());\\nMdMenu.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-menu, mat-menu\\',\\n                template: \"<ng-template><div class=\\\\\"mat-menu-panel\\\\\" [ngClass]=\\\\\"_classList\\\\\" (keydown)=\\\\\"_handleKeydown($event)\\\\\" (click)=\\\\\"_emitCloseEvent()\\\\\" [@transformMenu]=\\\\\"\\'showing\\'\\\\\" role=\\\\\"menu\\\\\"><div class=\\\\\"mat-menu-content\\\\\" [@fadeInItems]=\\\\\"\\'showing\\'\\\\\"><ng-content></ng-content></div></div></ng-template>\",\\n                styles: [\".mat-menu-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px)}.mat-menu-panel.mat-menu-after.mat-menu-below{transform-origin:left top}.mat-menu-panel.mat-menu-after.mat-menu-above{transform-origin:left bottom}.mat-menu-panel.mat-menu-before.mat-menu-below{transform-origin:right top}.mat-menu-panel.mat-menu-before.mat-menu-above{transform-origin:right bottom}[dir=rtl] .mat-menu-panel.mat-menu-after.mat-menu-below{transform-origin:right top}[dir=rtl] .mat-menu-panel.mat-menu-after.mat-menu-above{transform-origin:right bottom}[dir=rtl] .mat-menu-panel.mat-menu-before.mat-menu-below{transform-origin:left top}[dir=rtl] .mat-menu-panel.mat-menu-before.mat-menu-above{transform-origin:left bottom}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content{padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;position:relative}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}button.mat-menu-item{width:100%}.mat-menu-ripple{position:absolute;top:0;left:0;bottom:0;right:0}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                animations: [\\n                    transformMenu,\\n                    fadeInItems\\n                ],\\n                exportAs: \\'mdMenu\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMenu.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nMdMenu.propDecorators = {\\n    \\'xPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'yPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'templateRef\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"],] },],\\n    \\'items\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdMenuItem,] },],\\n    \\'overlapTrigger\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'classList\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'class\\',] },],\\n    \\'close\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * This directive is intended to be used in conjunction with an md-menu tag.  It is\\n * responsible for toggling the display of the provided menu instance.\\n */\\nvar MdMenuTrigger = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlay\\n     * @param {?} _element\\n     * @param {?} _viewContainerRef\\n     * @param {?} _dir\\n     */\\n    function MdMenuTrigger(_overlay, _element, _viewContainerRef, _dir) {\\n        this._overlay = _overlay;\\n        this._element = _element;\\n        this._viewContainerRef = _viewContainerRef;\\n        this._dir = _dir;\\n        this._overlayRef = null;\\n        this._menuOpen = false;\\n        this._openedByMouse = false;\\n        /**\\n         * Event emitted when the associated menu is opened.\\n         */\\n        this.onMenuOpen = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the associated menu is closed.\\n         */\\n        this.onMenuClose = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(MdMenuTrigger.prototype, \"_deprecatedMdMenuTriggerFor\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this.menu; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.menu = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdMenuTrigger.prototype, \"_deprecatedMatMenuTriggerFor\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this.menu; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.menu = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdMenuTrigger.prototype, \"_matMenuTriggerFor\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.menu; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.menu = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.ngAfterViewInit = function () {\\n        var _this = this;\\n        this._checkMenu();\\n        this.menu.close.subscribe(function () { return _this.closeMenu(); });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.ngOnDestroy = function () { this.destroyMenu(); };\\n    Object.defineProperty(MdMenuTrigger.prototype, \"menuOpen\", {\\n        /**\\n         * Whether the menu is open.\\n         * @return {?}\\n         */\\n        get: function () { return this._menuOpen; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Toggles the menu between the open and closed states.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.toggleMenu = function () {\\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\\n    };\\n    /**\\n     * Opens the menu.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.openMenu = function () {\\n        if (!this._menuOpen) {\\n            this._createOverlay().attach(this._portal);\\n            this._subscribeToBackdrop();\\n            this._initMenu();\\n        }\\n    };\\n    /**\\n     * Closes the menu.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.closeMenu = function () {\\n        if (this._overlayRef) {\\n            this._overlayRef.detach();\\n            this._backdropSubscription.unsubscribe();\\n            this._resetMenu();\\n        }\\n    };\\n    /**\\n     * Removes the menu from the DOM.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.destroyMenu = function () {\\n        if (this._overlayRef) {\\n            this._overlayRef.dispose();\\n            this._overlayRef = null;\\n            this._cleanUpSubscriptions();\\n        }\\n    };\\n    /**\\n     * Focuses the menu trigger.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype.focus = function () {\\n        this._element.nativeElement.focus();\\n    };\\n    Object.defineProperty(MdMenuTrigger.prototype, \"dir\", {\\n        /**\\n         * The text direction of the containing app.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._dir && this._dir.value === \\'rtl\\' ? \\'rtl\\' : \\'ltr\\';\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * This method ensures that the menu closes when the overlay backdrop is clicked.\\n     * We do not use first() here because doing so would not catch clicks from within\\n     * the menu, and it would fail to unsubscribe properly. Instead, we unsubscribe\\n     * explicitly when the menu is closed or destroyed.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._subscribeToBackdrop = function () {\\n        var _this = this;\\n        if (this._overlayRef) {\\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\\n                _this.menu._emitCloseEvent();\\n            });\\n        }\\n    };\\n    /**\\n     * This method sets the menu state to open and focuses the first item if\\n     * the menu was opened via the keyboard.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._initMenu = function () {\\n        this._setIsMenuOpen(true);\\n        // Should only set focus if opened via the keyboard, so keyboard users can\\n        // can easily navigate menu items. According to spec, mouse users should not\\n        // see the focus style.\\n        if (!this._openedByMouse) {\\n            this.menu.focusFirstItem();\\n        }\\n    };\\n    /**\\n     * This method resets the menu when it\\'s closed, most importantly restoring\\n     * focus to the menu trigger if the menu was opened via the keyboard.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._resetMenu = function () {\\n        this._setIsMenuOpen(false);\\n        // Focus only needs to be reset to the host element if the menu was opened\\n        // by the keyboard and manually shifted to the first menu item.\\n        if (!this._openedByMouse) {\\n            this.focus();\\n        }\\n        this._openedByMouse = false;\\n    };\\n    /**\\n     * @param {?} isOpen\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._setIsMenuOpen = function (isOpen) {\\n        this._menuOpen = isOpen;\\n        this._menuOpen ? this.onMenuOpen.emit() : this.onMenuClose.emit();\\n    };\\n    /**\\n     *  This method checks that a valid instance of MdMenu has been passed into\\n     *  mdMenuTriggerFor. If not, an exception is thrown.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._checkMenu = function () {\\n        if (!this.menu) {\\n            throwMdMenuMissingError();\\n        }\\n    };\\n    /**\\n     *  This method creates the overlay from the provided menu\\'s template and saves its\\n     *  OverlayRef so that it can be attached to the DOM when openMenu is called.\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._createOverlay = function () {\\n        if (!this._overlayRef) {\\n            this._portal = new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"U\" /* TemplatePortal */](this.menu.templateRef, this._viewContainerRef);\\n            var /** @type {?} */ config = this._getOverlayConfig();\\n            this._subscribeToPositions(/** @type {?} */ (config.positionStrategy));\\n            this._overlayRef = this._overlay.create(config);\\n        }\\n        return this._overlayRef;\\n    };\\n    /**\\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\\n     * @return {?} OverlayState\\n     */\\n    MdMenuTrigger.prototype._getOverlayConfig = function () {\\n        var /** @type {?} */ overlayState = new OverlayState();\\n        overlayState.positionStrategy = this._getPosition()\\n            .withDirection(this.dir);\\n        overlayState.hasBackdrop = true;\\n        overlayState.backdropClass = \\'cdk-overlay-transparent-backdrop\\';\\n        overlayState.direction = this.dir;\\n        overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();\\n        return overlayState;\\n    };\\n    /**\\n     * Listens to changes in the position of the overlay and sets the correct classes\\n     * on the menu based on the new position. This ensures the animation origin is always\\n     * correct, even if a fallback position is used for the overlay.\\n     * @param {?} position\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._subscribeToPositions = function (position) {\\n        var _this = this;\\n        this._positionSubscription = position.onPositionChange.subscribe(function (change) {\\n            var /** @type {?} */ posX = change.connectionPair.originX === \\'start\\' ? \\'after\\' : \\'before\\';\\n            var /** @type {?} */ posY = change.connectionPair.originY === \\'top\\' ? \\'below\\' : \\'above\\';\\n            if (!_this.menu.overlapTrigger) {\\n                posY = posY === \\'below\\' ? \\'above\\' : \\'below\\';\\n            }\\n            _this.menu.setPositionClasses(posX, posY);\\n        });\\n    };\\n    /**\\n     * This method builds the position strategy for the overlay, so the menu is properly connected\\n     * to the trigger.\\n     * @return {?} ConnectedPositionStrategy\\n     */\\n    MdMenuTrigger.prototype._getPosition = function () {\\n        var _a = this.menu.xPosition === \\'before\\' ? [\\'end\\', \\'start\\'] : [\\'start\\', \\'end\\'], posX = _a[0], fallbackX = _a[1];\\n        var _b = this.menu.yPosition === \\'above\\' ? [\\'bottom\\', \\'top\\'] : [\\'top\\', \\'bottom\\'], overlayY = _b[0], fallbackOverlayY = _b[1];\\n        var /** @type {?} */ originY = overlayY;\\n        var /** @type {?} */ fallbackOriginY = fallbackOverlayY;\\n        if (!this.menu.overlapTrigger) {\\n            originY = overlayY === \\'top\\' ? \\'bottom\\' : \\'top\\';\\n            fallbackOriginY = fallbackOverlayY === \\'top\\' ? \\'bottom\\' : \\'top\\';\\n        }\\n        return this._overlay.position()\\n            .connectedTo(this._element, { originX: posX, originY: originY }, { overlayX: posX, overlayY: overlayY })\\n            .withFallbackPosition({ originX: fallbackX, originY: originY }, { overlayX: fallbackX, overlayY: overlayY })\\n            .withFallbackPosition({ originX: posX, originY: fallbackOriginY }, { overlayX: posX, overlayY: fallbackOverlayY })\\n            .withFallbackPosition({ originX: fallbackX, originY: fallbackOriginY }, { overlayX: fallbackX, overlayY: fallbackOverlayY });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._cleanUpSubscriptions = function () {\\n        if (this._backdropSubscription) {\\n            this._backdropSubscription.unsubscribe();\\n        }\\n        if (this._positionSubscription) {\\n            this._positionSubscription.unsubscribe();\\n        }\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdMenuTrigger.prototype._handleMousedown = function (event) {\\n        if (!__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_6\" /* isFakeMousedownFromScreenReader */](event)) {\\n            this._openedByMouse = true;\\n        }\\n    };\\n    return MdMenuTrigger;\\n}());\\nMdMenuTrigger.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \"[md-menu-trigger-for], [mat-menu-trigger-for],\\\\n             [mdMenuTriggerFor], [matMenuTriggerFor]\",\\n                host: {\\n                    \\'aria-haspopup\\': \\'true\\',\\n                    \\'(mousedown)\\': \\'_handleMousedown($event)\\',\\n                    \\'(click)\\': \\'toggleMenu()\\',\\n                },\\n                exportAs: \\'mdMenuTrigger\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMenuTrigger.ctorParameters = function () { return [\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdMenuTrigger.propDecorators = {\\n    \\'_deprecatedMdMenuTriggerFor\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'md-menu-trigger-for\\',] },],\\n    \\'_deprecatedMatMenuTriggerFor\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mat-menu-trigger-for\\',] },],\\n    \\'_matMenuTriggerFor\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matMenuTriggerFor\\',] },],\\n    \\'menu\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdMenuTriggerFor\\',] },],\\n    \\'onMenuOpen\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'onMenuClose\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdMenuModule = /*@__PURE__*/(function () {\\n    function MdMenuModule() {\\n    }\\n    return MdMenuModule;\\n}());\\nMdMenuModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    OverlayModule,\\n                    __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"],\\n                    MdRippleModule,\\n                    MdCommonModule,\\n                ],\\n                exports: [MdMenu, MdMenuItem, MdMenuTrigger, MdCommonModule],\\n                declarations: [MdMenu, MdMenuItem, MdMenuTrigger],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMenuModule.ctorParameters = function () { return []; };\\n/**\\n * Custom injector type specifically for instantiating components with a dialog.\\n */\\nvar DialogInjector = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _parentInjector\\n     * @param {?} _customTokens\\n     */\\n    function DialogInjector(_parentInjector, _customTokens) {\\n        this._parentInjector = _parentInjector;\\n        this._customTokens = _customTokens;\\n    }\\n    /**\\n     * @param {?} token\\n     * @param {?=} notFoundValue\\n     * @return {?}\\n     */\\n    DialogInjector.prototype.get = function (token, notFoundValue) {\\n        var /** @type {?} */ value = this._customTokens.get(token);\\n        if (typeof value !== \\'undefined\\') {\\n            return value;\\n        }\\n        return this._parentInjector.get(token, notFoundValue);\\n    };\\n    return DialogInjector;\\n}());\\n/**\\n * Configuration for opening a modal dialog with the MdDialog service.\\n */\\nvar MdDialogConfig = /*@__PURE__*/(function () {\\n    function MdDialogConfig() {\\n        /**\\n         * The ARIA role of the dialog element.\\n         */\\n        this.role = \\'dialog\\';\\n        /**\\n         * Custom class for the overlay pane.\\n         */\\n        this.panelClass = \\'\\';\\n        /**\\n         * Whether the dialog has a backdrop.\\n         */\\n        this.hasBackdrop = true;\\n        /**\\n         * Custom class for the backdrop,\\n         */\\n        this.backdropClass = \\'\\';\\n        /**\\n         * Whether the user can use escape or clicking outside to close a modal.\\n         */\\n        this.disableClose = false;\\n        /**\\n         * Width of the dialog.\\n         */\\n        this.width = \\'\\';\\n        /**\\n         * Height of the dialog.\\n         */\\n        this.height = \\'\\';\\n        /**\\n         * Data being injected into the child component.\\n         */\\n        this.data = null;\\n        /**\\n         * Layout direction for the dialog\\'s content.\\n         */\\n        this.direction = \\'ltr\\';\\n        // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.\\n    }\\n    return MdDialogConfig;\\n}());\\n/**\\n * Reference to a dialog opened via the MdDialog service.\\n */\\nvar MdDialogRef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlayRef\\n     * @param {?} _containerInstance\\n     */\\n    function MdDialogRef(_overlayRef, _containerInstance) {\\n        var _this = this;\\n        this._overlayRef = _overlayRef;\\n        this._containerInstance = _containerInstance;\\n        /**\\n         * Whether the user is allowed to close the dialog.\\n         */\\n        this.disableClose = this._containerInstance._config.disableClose;\\n        /**\\n         * Subject for notifying the user that the dialog has finished closing.\\n         */\\n        this._afterClosed = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_2\" /* filter */].call(_containerInstance._onAnimationStateChange, function (event) { return event.toState === \\'exit\\'; })\\n            .subscribe(function () { return _this._overlayRef.dispose(); }, undefined, function () {\\n            _this._afterClosed.next(_this._result);\\n            _this._afterClosed.complete();\\n            _this.componentInstance = null;\\n        });\\n    }\\n    /**\\n     * Close the dialog.\\n     * @param {?=} dialogResult Optional result to return to the dialog opener.\\n     * @return {?}\\n     */\\n    MdDialogRef.prototype.close = function (dialogResult) {\\n        this._result = dialogResult;\\n        this._containerInstance._state = \\'exit\\';\\n        this._overlayRef.detachBackdrop(); // Transition the backdrop in parallel with the dialog.\\n    };\\n    /**\\n     * Gets an observable that is notified when the dialog is finished closing.\\n     * @return {?}\\n     */\\n    MdDialogRef.prototype.afterClosed = function () {\\n        return this._afterClosed.asObservable();\\n    };\\n    /**\\n     * Updates the dialog\\'s position.\\n     * @param {?=} position New dialog position.\\n     * @return {?}\\n     */\\n    MdDialogRef.prototype.updatePosition = function (position) {\\n        var /** @type {?} */ strategy = this._getPositionStrategy();\\n        if (position && (position.left || position.right)) {\\n            position.left ? strategy.left(position.left) : strategy.right(position.right);\\n        }\\n        else {\\n            strategy.centerHorizontally();\\n        }\\n        if (position && (position.top || position.bottom)) {\\n            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);\\n        }\\n        else {\\n            strategy.centerVertically();\\n        }\\n        this._overlayRef.updatePosition();\\n        return this;\\n    };\\n    /**\\n     * Updates the dialog\\'s width and height.\\n     * @param {?=} width New width of the dialog.\\n     * @param {?=} height New height of the dialog.\\n     * @return {?}\\n     */\\n    MdDialogRef.prototype.updateSize = function (width, height) {\\n        if (width === void 0) { width = \\'auto\\'; }\\n        if (height === void 0) { height = \\'auto\\'; }\\n        this._getPositionStrategy().width(width).height(height);\\n        this._overlayRef.updatePosition();\\n        return this;\\n    };\\n    /**\\n     * Fetches the position strategy object from the overlay ref.\\n     * @return {?}\\n     */\\n    MdDialogRef.prototype._getPositionStrategy = function () {\\n        return (this._overlayRef.getState().positionStrategy);\\n    };\\n    return MdDialogRef;\\n}());\\n/**\\n * Throws an exception for the case when a ComponentPortal is\\n * attached to a DomPortalHost without an origin.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwMdDialogContentAlreadyAttachedError() {\\n    throw Error(\\'Attempting to attach dialog content after content is already attached\\');\\n}\\n/**\\n * Internal component that wraps user-provided dialog content.\\n * Animation is based on https://material.io/guidelines/motion/choreography.html.\\n * \\\\@docs-private\\n */\\nvar MdDialogContainer = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdDialogContainer, _super);\\n    /**\\n     * @param {?} _ngZone\\n     * @param {?} _elementRef\\n     * @param {?} _focusTrapFactory\\n     * @param {?} _document\\n     */\\n    function MdDialogContainer(_ngZone, _elementRef, _focusTrapFactory, _document) {\\n        var _this = _super.call(this) || this;\\n        _this._ngZone = _ngZone;\\n        _this._elementRef = _elementRef;\\n        _this._focusTrapFactory = _focusTrapFactory;\\n        /**\\n         * Element that was focused before the dialog was opened. Save this to restore upon close.\\n         */\\n        _this._elementFocusedBeforeDialogWasOpened = null;\\n        /**\\n         * State of the dialog animation.\\n         */\\n        _this._state = \\'enter\\';\\n        /**\\n         * Emits the current animation state whenever it changes.\\n         */\\n        _this._onAnimationStateChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * ID of the element that should be considered as the dialog\\'s label.\\n         */\\n        _this._ariaLabelledBy = null;\\n        _this._document = _document;\\n        return _this;\\n    }\\n    /**\\n     * Attach a ComponentPortal as content to this dialog container.\\n     * @template T\\n     * @param {?} portal Portal to be attached as the dialog content.\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype.attachComponentPortal = function (portal) {\\n        if (this._portalHost.hasAttached()) {\\n            throwMdDialogContentAlreadyAttachedError();\\n        }\\n        this._savePreviouslyFocusedElement();\\n        return this._portalHost.attachComponentPortal(portal);\\n    };\\n    /**\\n     * Attach a TemplatePortal as content to this dialog container.\\n     * @param {?} portal Portal to be attached as the dialog content.\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype.attachTemplatePortal = function (portal) {\\n        if (this._portalHost.hasAttached()) {\\n            throwMdDialogContentAlreadyAttachedError();\\n        }\\n        this._savePreviouslyFocusedElement();\\n        return this._portalHost.attachTemplatePortal(portal);\\n    };\\n    /**\\n     * Moves the focus inside the focus trap.\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype._trapFocus = function () {\\n        if (!this._focusTrap) {\\n            this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\\n        }\\n        // If were to attempt to focus immediately, then the content of the dialog would not yet be\\n        // ready in instances where change detection has to run first. To deal with this, we simply\\n        // wait for the microtask queue to be empty.\\n        this._focusTrap.focusInitialElementWhenReady();\\n    };\\n    /**\\n     * Restores focus to the element that was focused before the dialog opened.\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype._restoreFocus = function () {\\n        var /** @type {?} */ toFocus = this._elementFocusedBeforeDialogWasOpened;\\n        // We need the extra check, because IE can set the `activeElement` to null in some cases.\\n        if (toFocus && \\'focus\\' in toFocus) {\\n            toFocus.focus();\\n        }\\n        if (this._focusTrap) {\\n            this._focusTrap.destroy();\\n        }\\n    };\\n    /**\\n     * Saves a reference to the element that was focused before the dialog was opened.\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype._savePreviouslyFocusedElement = function () {\\n        if (this._document) {\\n            this._elementFocusedBeforeDialogWasOpened = (this._document.activeElement);\\n        }\\n    };\\n    /**\\n     * Callback, invoked whenever an animation on the host completes.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdDialogContainer.prototype._onAnimationDone = function (event) {\\n        this._onAnimationStateChange.emit(event);\\n        if (event.toState === \\'enter\\') {\\n            this._trapFocus();\\n        }\\n        else if (event.toState === \\'exit\\') {\\n            this._restoreFocus();\\n            this._onAnimationStateChange.complete();\\n        }\\n    };\\n    return MdDialogContainer;\\n}(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"c\" /* BasePortalHost */]));\\nMdDialogContainer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-dialog-container, mat-dialog-container\\',\\n                template: \"<ng-template cdkPortalHost></ng-template>\",\\n                styles: [\".mat-dialog-container{box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);display:block;padding:24px;border-radius:2px;box-sizing:border-box;overflow:auto;max-width:80vw;width:100%;height:100%}@media screen and (-ms-high-contrast:active){.mat-dialog-container{outline:solid 1px}}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:12px 0;display:flex;flex-wrap:wrap}.mat-dialog-actions:last-child{margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                animations: [\\n                    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'slideDialog\\', [\\n                        // Note: The `enter` animation doesn\\'t transition to something like `translate3d(0, 0, 0)\\n                        // scale(1)`, because for some reason specifying the transform explicitly, causes IE both\\n                        // to blur the dialog content and decimate the animation performance. Leaving it as `none`\\n                        // solves both issues.\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'enter\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'none\\', opacity: 1 })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'void\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translate3d(0, 25%, 0) scale(0.9)\\', opacity: 0 })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'exit\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'translate3d(0, 25%, 0)\\', opacity: 0 })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'* => *\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](\\'400ms cubic-bezier(0.25, 0.8, 0.25, 1)\\')),\\n                    ])\\n                ],\\n                host: {\\n                    \\'class\\': \\'mat-dialog-container\\',\\n                    \\'[attr.role]\\': \\'_config?.role\\',\\n                    \\'[attr.aria-labelledby]\\': \\'_ariaLabelledBy\\',\\n                    \\'[@slideDialog]\\': \\'_state\\',\\n                    \\'(@slideDialog.done)\\': \\'_onAnimationDone($event)\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogContainer.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"z\" /* FocusTrapFactory */], },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"DOCUMENT\"],] },] },\\n]; };\\nMdDialogContainer.propDecorators = {\\n    \\'_portalHost\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"O\" /* PortalHostDirective */],] },],\\n};\\nvar MD_DIALOG_DATA = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'MdDialogData\\');\\n/**\\n * Service to open Material Design modal dialogs.\\n */\\nvar MdDialog = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _overlay\\n     * @param {?} _injector\\n     * @param {?} _location\\n     * @param {?} _parentDialog\\n     */\\n    function MdDialog(_overlay, _injector, _location, _parentDialog) {\\n        var _this = this;\\n        this._overlay = _overlay;\\n        this._injector = _injector;\\n        this._location = _location;\\n        this._parentDialog = _parentDialog;\\n        this._openDialogsAtThisLevel = [];\\n        this._afterAllClosedAtThisLevel = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        this._afterOpenAtThisLevel = new __WEBPACK_IMPORTED_MODULE_5_rxjs_Subject__[\"Subject\"]();\\n        this._boundKeydown = this._handleKeydown.bind(this);\\n        /**\\n         * Gets an observable that is notified when a dialog has been opened.\\n         */\\n        this.afterOpen = this._afterOpen.asObservable();\\n        /**\\n         * Gets an observable that is notified when all open dialog have finished closing.\\n         */\\n        this.afterAllClosed = this._afterAllClosed.asObservable();\\n        // Close all of the dialogs when the user goes forwards/backwards in history or when the\\n        // location hash changes. Note that this usually doesn\\'t include clicking on links (unless\\n        // the user is using the `HashLocationStrategy`).\\n        if (!_parentDialog && _location) {\\n            _location.subscribe(function () { return _this.closeAll(); });\\n        }\\n    }\\n    Object.defineProperty(MdDialog.prototype, \"_openDialogs\", {\\n        /**\\n         * Keeps track of the currently-open dialogs.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._parentDialog ? this._parentDialog._openDialogs : this._openDialogsAtThisLevel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDialog.prototype, \"_afterOpen\", {\\n        /**\\n         * Subject for notifying the user that a dialog has opened.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._parentDialog ? this._parentDialog._afterOpen : this._afterOpenAtThisLevel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDialog.prototype, \"_afterAllClosed\", {\\n        /**\\n         * Subject for notifying the user that all open dialogs have finished closing.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._parentDialog ?\\n                this._parentDialog._afterAllClosed : this._afterAllClosedAtThisLevel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Opens a modal dialog containing the given component.\\n     * @template T\\n     * @param {?} componentOrTemplateRef Type of the component to load into the dialog,\\n     *     or a TemplateRef to instantiate as the dialog content.\\n     * @param {?=} config Extra configuration options.\\n     * @return {?} Reference to the newly-opened dialog.\\n     */\\n    MdDialog.prototype.open = function (componentOrTemplateRef, config) {\\n        var _this = this;\\n        config = _applyConfigDefaults$1(config);\\n        var /** @type {?} */ overlayRef = this._createOverlay(config);\\n        var /** @type {?} */ dialogContainer = this._attachDialogContainer(overlayRef, config);\\n        var /** @type {?} */ dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);\\n        if (!this._openDialogs.length) {\\n            document.addEventListener(\\'keydown\\', this._boundKeydown);\\n        }\\n        this._openDialogs.push(dialogRef);\\n        dialogRef.afterClosed().subscribe(function () { return _this._removeOpenDialog(dialogRef); });\\n        this._afterOpen.next(dialogRef);\\n        return dialogRef;\\n    };\\n    /**\\n     * Closes all of the currently-open dialogs.\\n     * @return {?}\\n     */\\n    MdDialog.prototype.closeAll = function () {\\n        var /** @type {?} */ i = this._openDialogs.length;\\n        while (i--) {\\n            // The `_openDialogs` property isn\\'t updated after close until the rxjs subscription\\n            // runs on the next microtask, in addition to modifying the array as we\\'re going\\n            // through it. We loop through all of them and call close without assuming that\\n            // they\\'ll be removed from the list instantaneously.\\n            this._openDialogs[i].close();\\n        }\\n    };\\n    /**\\n     * Creates the overlay into which the dialog will be loaded.\\n     * @param {?} config The dialog configuration.\\n     * @return {?} A promise resolving to the OverlayRef for the created overlay.\\n     */\\n    MdDialog.prototype._createOverlay = function (config) {\\n        var /** @type {?} */ overlayState = this._getOverlayState(config);\\n        return this._overlay.create(overlayState);\\n    };\\n    /**\\n     * Creates an overlay state from a dialog config.\\n     * @param {?} dialogConfig The dialog configuration.\\n     * @return {?} The overlay configuration.\\n     */\\n    MdDialog.prototype._getOverlayState = function (dialogConfig) {\\n        var /** @type {?} */ overlayState = new OverlayState();\\n        overlayState.panelClass = dialogConfig.panelClass;\\n        overlayState.hasBackdrop = dialogConfig.hasBackdrop;\\n        overlayState.scrollStrategy = this._overlay.scrollStrategies.block();\\n        overlayState.direction = dialogConfig.direction;\\n        if (dialogConfig.backdropClass) {\\n            overlayState.backdropClass = dialogConfig.backdropClass;\\n        }\\n        overlayState.positionStrategy = this._overlay.position().global();\\n        return overlayState;\\n    };\\n    /**\\n     * Attaches an MdDialogContainer to a dialog\\'s already-created overlay.\\n     * @param {?} overlay Reference to the dialog\\'s underlying overlay.\\n     * @param {?} config The dialog configuration.\\n     * @return {?} A promise resolving to a ComponentRef for the attached container.\\n     */\\n    MdDialog.prototype._attachDialogContainer = function (overlay, config) {\\n        var /** @type {?} */ containerPortal = new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"n\" /* ComponentPortal */](MdDialogContainer, config.viewContainerRef);\\n        var /** @type {?} */ containerRef = overlay.attach(containerPortal);\\n        containerRef.instance._config = config;\\n        return containerRef.instance;\\n    };\\n    /**\\n     * Attaches the user-provided component to the already-created MdDialogContainer.\\n     * @template T\\n     * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,\\n     *     or a TemplateRef to instantiate as the content.\\n     * @param {?} dialogContainer Reference to the wrapping MdDialogContainer.\\n     * @param {?} overlayRef Reference to the overlay in which the dialog resides.\\n     * @param {?} config The dialog configuration.\\n     * @return {?} A promise resolving to the MdDialogRef that should be returned to the user.\\n     */\\n    MdDialog.prototype._attachDialogContent = function (componentOrTemplateRef, dialogContainer, overlayRef, config) {\\n        // Create a reference to the dialog we\\'re creating in order to give the user a handle\\n        // to modify and close it.\\n        var /** @type {?} */ dialogRef = new MdDialogRef(overlayRef, dialogContainer);\\n        // When the dialog backdrop is clicked, we want to close it.\\n        if (config.hasBackdrop) {\\n            overlayRef.backdropClick().subscribe(function () {\\n                if (!dialogRef.disableClose) {\\n                    dialogRef.close();\\n                }\\n            });\\n        }\\n        if (componentOrTemplateRef instanceof __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"]) {\\n            dialogContainer.attachTemplatePortal(new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"U\" /* TemplatePortal */](componentOrTemplateRef, /** @type {?} */ ((null))));\\n        }\\n        else {\\n            var /** @type {?} */ injector = this._createInjector(config, dialogRef, dialogContainer);\\n            var /** @type {?} */ contentRef = dialogContainer.attachComponentPortal(new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"n\" /* ComponentPortal */](componentOrTemplateRef, undefined, injector));\\n            dialogRef.componentInstance = contentRef.instance;\\n        }\\n        dialogRef\\n            .updateSize(config.width, config.height)\\n            .updatePosition(config.position);\\n        return dialogRef;\\n    };\\n    /**\\n     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside\\n     * of a dialog to close itself and, optionally, to return a value.\\n     * @template T\\n     * @param {?} config Config object that is used to construct the dialog.\\n     * @param {?} dialogRef Reference to the dialog.\\n     * @param {?} dialogContainer\\n     * @return {?} The custom injector that can be used inside the dialog.\\n     */\\n    MdDialog.prototype._createInjector = function (config, dialogRef, dialogContainer) {\\n        var /** @type {?} */ userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\\n        var /** @type {?} */ injectionTokens = new WeakMap();\\n        injectionTokens.set(MdDialogRef, dialogRef);\\n        injectionTokens.set(MdDialogContainer, dialogContainer);\\n        injectionTokens.set(MD_DIALOG_DATA, config.data);\\n        return new DialogInjector(userInjector || this._injector, injectionTokens);\\n    };\\n    /**\\n     * Removes a dialog from the array of open dialogs.\\n     * @param {?} dialogRef Dialog to be removed.\\n     * @return {?}\\n     */\\n    MdDialog.prototype._removeOpenDialog = function (dialogRef) {\\n        var /** @type {?} */ index = this._openDialogs.indexOf(dialogRef);\\n        if (index > -1) {\\n            this._openDialogs.splice(index, 1);\\n            // no open dialogs are left, call next on afterAllClosed Subject\\n            if (!this._openDialogs.length) {\\n                this._afterAllClosed.next();\\n                document.removeEventListener(\\'keydown\\', this._boundKeydown);\\n            }\\n        }\\n    };\\n    /**\\n     * Handles global key presses while there are open dialogs. Closes the\\n     * top dialog when the user presses escape.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdDialog.prototype._handleKeydown = function (event) {\\n        var /** @type {?} */ topDialog = this._openDialogs[this._openDialogs.length - 1];\\n        var /** @type {?} */ canClose = topDialog ? !topDialog.disableClose : false;\\n        if (event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"v\" /* ESCAPE */] && canClose) {\\n            topDialog.close();\\n        }\\n    };\\n    return MdDialog;\\n}());\\nMdDialog.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialog.ctorParameters = function () { return [\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injector\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"Location\"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: MdDialog, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"] },] },\\n]; };\\n/**\\n * Applies default options to the dialog config.\\n * @param {?=} config Config to be modified.\\n * @return {?} The new configuration object.\\n */\\nfunction _applyConfigDefaults$1(config) {\\n    return extendObject(new MdDialogConfig(), config);\\n}\\n/**\\n * Counter used to generate unique IDs for dialog elements.\\n */\\nvar dialogElementUid = 0;\\n/**\\n * Button that will close the current dialog.\\n */\\nvar MdDialogClose = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} dialogRef\\n     */\\n    function MdDialogClose(dialogRef) {\\n        this.dialogRef = dialogRef;\\n        /**\\n         * Screenreader label for the button.\\n         */\\n        this.ariaLabel = \\'Close dialog\\';\\n    }\\n    Object.defineProperty(MdDialogClose.prototype, \"_matDialogClose\", {\\n        /**\\n         * Dialog close input for compatibility mode.\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this.dialogResult = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return MdDialogClose;\\n}());\\nMdDialogClose.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'button[md-dialog-close], button[mat-dialog-close],\\' +\\n                    \\'button[mdDialogClose], button[matDialogClose]\\',\\n                host: {\\n                    \\'(click)\\': \\'dialogRef.close(dialogResult)\\',\\n                    \\'[attr.aria-label]\\': \\'ariaLabel\\',\\n                    \\'type\\': \\'button\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogClose.ctorParameters = function () { return [\\n    { type: MdDialogRef, },\\n]; };\\nMdDialogClose.propDecorators = {\\n    \\'ariaLabel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'aria-label\\',] },],\\n    \\'dialogResult\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'md-dialog-close\\',] },],\\n    \\'_matDialogClose\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mat-dialog-close\\',] },],\\n};\\n/**\\n * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.\\n */\\nvar MdDialogTitle = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _container\\n     */\\n    function MdDialogTitle(_container) {\\n        this._container = _container;\\n        this.id = \"md-dialog-title-\" + dialogElementUid++;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdDialogTitle.prototype.ngOnInit = function () {\\n        var _this = this;\\n        if (this._container && !this._container._ariaLabelledBy) {\\n            Promise.resolve().then(function () { return _this._container._ariaLabelledBy = _this.id; });\\n        }\\n    };\\n    return MdDialogTitle;\\n}());\\nMdDialogTitle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-dialog-title], [mat-dialog-title], [mdDialogTitle], [matDialogTitle]\\',\\n                host: {\\n                    \\'class\\': \\'mat-dialog-title\\',\\n                    \\'[id]\\': \\'id\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogTitle.ctorParameters = function () { return [\\n    { type: MdDialogContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdDialogTitle.propDecorators = {\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Scrollable content container of a dialog.\\n */\\nvar MdDialogContent = /*@__PURE__*/(function () {\\n    function MdDialogContent() {\\n    }\\n    return MdDialogContent;\\n}());\\nMdDialogContent.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-dialog-content], md-dialog-content, [mat-dialog-content], mat-dialog-content,\\' +\\n                    \\'[mdDialogContent], [matDialogContent]\\',\\n                host: { \\'class\\': \\'mat-dialog-content\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogContent.ctorParameters = function () { return []; };\\n/**\\n * Container for the bottom action buttons in a dialog.\\n * Stays fixed to the bottom when scrolling.\\n */\\nvar MdDialogActions = /*@__PURE__*/(function () {\\n    function MdDialogActions() {\\n    }\\n    return MdDialogActions;\\n}());\\nMdDialogActions.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[md-dialog-actions], md-dialog-actions, [mat-dialog-actions], mat-dialog-actions,\\' +\\n                    \\'[mdDialogActions], [matDialogActions]\\',\\n                host: { \\'class\\': \\'mat-dialog-actions\\' }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogActions.ctorParameters = function () { return []; };\\nvar MdDialogModule = /*@__PURE__*/(function () {\\n    function MdDialogModule() {\\n    }\\n    return MdDialogModule;\\n}());\\nMdDialogModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"],\\n                    OverlayModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"P\" /* PortalModule */],\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"a\" /* A11yModule */],\\n                    MdCommonModule,\\n                ],\\n                exports: [\\n                    MdDialogContainer,\\n                    MdDialogClose,\\n                    MdDialogTitle,\\n                    MdDialogContent,\\n                    MdDialogActions,\\n                    MdCommonModule,\\n                ],\\n                declarations: [\\n                    MdDialogContainer,\\n                    MdDialogClose,\\n                    MdDialogTitle,\\n                    MdDialogActions,\\n                    MdDialogContent,\\n                ],\\n                providers: [\\n                    MdDialog,\\n                ],\\n                entryComponents: [MdDialogContainer],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDialogModule.ctorParameters = function () { return []; };\\nvar ActiveDescendantKeyManager = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ActiveDescendantKeyManager, _super);\\n    function ActiveDescendantKeyManager() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    /**\\n     * This method sets the active item to the item at the specified index.\\n     * It also adds active styles to the newly active item and removes active\\n     * styles from the previously active item.\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    ActiveDescendantKeyManager.prototype.setActiveItem = function (index) {\\n        var _this = this;\\n        Promise.resolve().then(function () {\\n            if (_this.activeItem) {\\n                _this.activeItem.setInactiveStyles();\\n            }\\n            _super.prototype.setActiveItem.call(_this, index);\\n            if (_this.activeItem) {\\n                _this.activeItem.setActiveStyles();\\n            }\\n        });\\n    };\\n    return ActiveDescendantKeyManager;\\n}(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"F\" /* ListKeyManager */]));\\n/**\\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\\n * the component definition.\\n */\\nvar _uniqueAutocompleteIdCounter = 0;\\nvar MdAutocomplete = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _changeDetectorRef\\n     */\\n    function MdAutocomplete(_changeDetectorRef) {\\n        this._changeDetectorRef = _changeDetectorRef;\\n        /**\\n         * Whether the autocomplete panel displays above or below its trigger.\\n         */\\n        this.positionY = \\'below\\';\\n        /**\\n         * Whether the autocomplete panel should be visible, depending on option length.\\n         */\\n        this.showPanel = false;\\n        /**\\n         * Function that maps an option\\'s control value to its display value in the trigger.\\n         */\\n        this.displayWith = null;\\n        /**\\n         * Unique ID to be used by autocomplete trigger\\'s \"aria-owns\" property.\\n         */\\n        this.id = \"md-autocomplete-\" + _uniqueAutocompleteIdCounter++;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdAutocomplete.prototype.ngAfterContentInit = function () {\\n        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();\\n    };\\n    /**\\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\\n     * above or below the fold, as they are not actually being focused when active.\\n     * @param {?} scrollTop\\n     * @return {?}\\n     */\\n    MdAutocomplete.prototype._setScrollTop = function (scrollTop) {\\n        if (this.panel) {\\n            this.panel.nativeElement.scrollTop = scrollTop;\\n        }\\n    };\\n    /**\\n     * Returns the panel\\'s scrollTop.\\n     * @return {?}\\n     */\\n    MdAutocomplete.prototype._getScrollTop = function () {\\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\\n    };\\n    /**\\n     * Panel should hide itself when the option list is empty.\\n     * @return {?}\\n     */\\n    MdAutocomplete.prototype._setVisibility = function () {\\n        var _this = this;\\n        Promise.resolve().then(function () {\\n            _this.showPanel = !!_this.options.length;\\n            _this._changeDetectorRef.markForCheck();\\n        });\\n    };\\n    /**\\n     * Sets a class on the panel based on its position (used to set y-offset).\\n     * @return {?}\\n     */\\n    MdAutocomplete.prototype._getClassList = function () {\\n        return {\\n            \\'mat-autocomplete-panel-below\\': this.positionY === \\'below\\',\\n            \\'mat-autocomplete-panel-above\\': this.positionY === \\'above\\',\\n            \\'mat-autocomplete-visible\\': this.showPanel,\\n            \\'mat-autocomplete-hidden\\': !this.showPanel\\n        };\\n    };\\n    return MdAutocomplete;\\n}());\\nMdAutocomplete.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-autocomplete, mat-autocomplete\\',\\n                template: \"<ng-template><div class=\\\\\"mat-autocomplete-panel\\\\\" role=\\\\\"listbox\\\\\" [id]=\\\\\"id\\\\\" [ngClass]=\\\\\"_getClassList()\\\\\" #panel><ng-content></ng-content></div></ng-template>\",\\n                styles: [\".mat-autocomplete-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative}.mat-autocomplete-panel.mat-autocomplete-panel-below{top:6px}.mat-autocomplete-panel.mat-autocomplete-panel-above{top:-24px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}\"],\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                exportAs: \\'mdAutocomplete\\',\\n                host: {\\n                    \\'class\\': \\'mat-autocomplete\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdAutocomplete.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n]; };\\nMdAutocomplete.propDecorators = {\\n    \\'template\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"],] },],\\n    \\'panel\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [\\'panel\\',] },],\\n    \\'options\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [MdOption,] },],\\n    \\'displayWith\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * The height of each autocomplete option.\\n */\\nvar AUTOCOMPLETE_OPTION_HEIGHT = 48;\\n/**\\n * The total height of the autocomplete panel.\\n */\\nvar AUTOCOMPLETE_PANEL_HEIGHT = 256;\\n/**\\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\\n * \\\\@docs-private\\n */\\nvar MD_AUTOCOMPLETE_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdAutocompleteTrigger; }),\\n    multi: true\\n};\\n/**\\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\\n * @return {?}\\n */\\nfunction getMdAutocompleteMissingPanelError() {\\n    return Error(\\'Attempting to open an undefined instance of `md-autocomplete`. \\' +\\n        \\'Make sure that the id passed to the `mdAutocomplete` is correct and that \\' +\\n        \\'you\\\\\\'re attempting to open it after the ngAfterContentInit hook.\\');\\n}\\nvar MdAutocompleteTrigger = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _element\\n     * @param {?} _overlay\\n     * @param {?} _viewContainerRef\\n     * @param {?} _zone\\n     * @param {?} _changeDetectorRef\\n     * @param {?} _dir\\n     * @param {?} _inputContainer\\n     * @param {?} _document\\n     */\\n    function MdAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, _dir, _inputContainer, _document) {\\n        this._element = _element;\\n        this._overlay = _overlay;\\n        this._viewContainerRef = _viewContainerRef;\\n        this._zone = _zone;\\n        this._changeDetectorRef = _changeDetectorRef;\\n        this._dir = _dir;\\n        this._inputContainer = _inputContainer;\\n        this._document = _document;\\n        this._panelOpen = false;\\n        /**\\n         * Whether or not the placeholder state is being overridden.\\n         */\\n        this._manuallyFloatingPlaceholder = false;\\n        /**\\n         * View -> model callback called when value changes\\n         */\\n        this._onChange = function () { };\\n        /**\\n         * View -> model callback called when autocomplete has been touched\\n         */\\n        this._onTouched = function () { };\\n    }\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"_matAutocomplete\", {\\n        /**\\n         * Property with mat- prefix for no-conflict mode.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.autocomplete;\\n        },\\n        /**\\n         * @param {?} autocomplete\\n         * @return {?}\\n         */\\n        set: function (autocomplete) {\\n            this.autocomplete = autocomplete;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.ngOnDestroy = function () {\\n        if (this._panelPositionSubscription) {\\n            this._panelPositionSubscription.unsubscribe();\\n        }\\n        this._destroyPanel();\\n    };\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"panelOpen\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._panelOpen && this.autocomplete.showPanel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Opens the autocomplete suggestion panel.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.openPanel = function () {\\n        if (!this.autocomplete) {\\n            throw getMdAutocompleteMissingPanelError();\\n        }\\n        if (!this._overlayRef) {\\n            this._createOverlay();\\n        }\\n        else {\\n            /** Update the panel width, in case the host width has changed */\\n            this._overlayRef.getState().width = this._getHostWidth();\\n            this._overlayRef.updateSize();\\n        }\\n        if (this._overlayRef && !this._overlayRef.hasAttached()) {\\n            this._overlayRef.attach(this._portal);\\n            this._closingActionsSubscription = this._subscribeToClosingActions();\\n        }\\n        this.autocomplete._setVisibility();\\n        this._floatPlaceholder();\\n        this._panelOpen = true;\\n    };\\n    /**\\n     * Closes the autocomplete suggestion panel.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.closePanel = function () {\\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\\n            this._overlayRef.detach();\\n            this._closingActionsSubscription.unsubscribe();\\n        }\\n        this._panelOpen = false;\\n        this._resetPlaceholder();\\n        // We need to trigger change detection manually, because\\n        // `fromEvent` doesn\\'t seem to do it at the proper time.\\n        // This ensures that the placeholder is reset when the\\n        // user clicks outside.\\n        this._changeDetectorRef.detectChanges();\\n    };\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"panelClosingActions\", {\\n        /**\\n         * A stream of actions that should close the autocomplete panel, including\\n         * when an option is selected, on blur, and when TAB is pressed.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return __WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge__[\"merge\"](this.optionSelections, this.autocomplete._keyManager.tabOut, this._outsideClickStream);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"optionSelections\", {\\n        /**\\n         * Stream of autocomplete option selections.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return __WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge__[\"merge\"].apply(void 0, this.autocomplete.options.map(function (option) { return option.onSelectionChange; }));\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"activeOption\", {\\n        /**\\n         * The currently active option, coerced to MdOption type.\\n         * @return {?}\\n         */\\n        get: function () {\\n            if (this.autocomplete && this.autocomplete._keyManager) {\\n                return (this.autocomplete._keyManager.activeItem);\\n            }\\n            return null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdAutocompleteTrigger.prototype, \"_outsideClickStream\", {\\n        /**\\n         * Stream of clicks outside of the autocomplete panel.\\n         * @return {?}\\n         */\\n        get: function () {\\n            var _this = this;\\n            if (!this._document) {\\n                return __WEBPACK_IMPORTED_MODULE_9_rxjs_observable_of__[\"of\"](null);\\n            }\\n            return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"R\" /* RxChain */].from(__WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge__[\"merge\"](__WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromEvent__[\"fromEvent\"](this._document, \\'click\\'), __WEBPACK_IMPORTED_MODULE_7_rxjs_observable_fromEvent__[\"fromEvent\"](this._document, \\'touchend\\'))).call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_2\" /* filter */], function (event) {\\n                var /** @type {?} */ clickTarget = (event.target);\\n                var /** @type {?} */ inputContainer = _this._inputContainer ?\\n                    _this._inputContainer._elementRef.nativeElement : null;\\n                return _this._panelOpen &&\\n                    clickTarget !== _this._element.nativeElement &&\\n                    (!inputContainer || !inputContainer.contains(clickTarget)) &&\\n                    (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));\\n            }).result();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the autocomplete\\'s value. Part of the ControlValueAccessor interface\\n     * required to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} value New value to be written to the model.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.writeValue = function (value) {\\n        var _this = this;\\n        Promise.resolve(null).then(function () { return _this._setTriggerValue(value); });\\n    };\\n    /**\\n     * Saves a callback function to be invoked when the autocomplete\\'s value\\n     * changes from user input. Part of the ControlValueAccessor interface\\n     * required to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} fn Callback to be triggered when the value changes.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.registerOnChange = function (fn) {\\n        this._onChange = fn;\\n    };\\n    /**\\n     * Saves a callback function to be invoked when the autocomplete is blurred\\n     * by the user. Part of the ControlValueAccessor interface required\\n     * to integrate with Angular\\'s core forms API.\\n     *\\n     * @param {?} fn Callback to be triggered when the component has been touched.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype.registerOnTouched = function (fn) {\\n        this._onTouched = fn;\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._handleKeydown = function (event) {\\n        var _this = this;\\n        if (event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"v\" /* ESCAPE */] && this.panelOpen) {\\n            this.closePanel();\\n        }\\n        else if (this.activeOption && event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"u\" /* ENTER */]) {\\n            this.activeOption._selectViaInteraction();\\n            event.preventDefault();\\n        }\\n        else {\\n            var /** @type {?} */ prevActiveItem_1 = this.autocomplete._keyManager.activeItem;\\n            var /** @type {?} */ isArrowKey_1 = event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"W\" /* UP_ARROW */] || event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"p\" /* DOWN_ARROW */];\\n            this.autocomplete._keyManager.onKeydown(event);\\n            if (isArrowKey_1) {\\n                this.openPanel();\\n            }\\n            Promise.resolve().then(function () {\\n                if (isArrowKey_1 || _this.autocomplete._keyManager.activeItem !== prevActiveItem_1) {\\n                    _this._scrollToOption();\\n                }\\n            });\\n        }\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._handleInput = function (event) {\\n        // We need to ensure that the input is focused, because IE will fire the `input`\\n        // event on focus/blur/load if the input has a placeholder. See:\\n        // https://connect.microsoft.com/IE/feedback/details/885747/\\n        if (document.activeElement === event.target) {\\n            this._onChange(((event.target)).value);\\n            this.openPanel();\\n        }\\n    };\\n    /**\\n     * In \"auto\" mode, the placeholder will animate down as soon as focus is lost.\\n     * This causes the value to jump when selecting an option with the mouse.\\n     * This method manually floats the placeholder until the panel can be closed.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._floatPlaceholder = function () {\\n        if (this._inputContainer && this._inputContainer.floatPlaceholder === \\'auto\\') {\\n            this._inputContainer.floatPlaceholder = \\'always\\';\\n            this._manuallyFloatingPlaceholder = true;\\n        }\\n    };\\n    /**\\n     * If the placeholder has been manually elevated, return it to its normal state.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._resetPlaceholder = function () {\\n        if (this._manuallyFloatingPlaceholder) {\\n            this._inputContainer.floatPlaceholder = \\'auto\\';\\n            this._manuallyFloatingPlaceholder = false;\\n        }\\n    };\\n    /**\\n     * Given that we are not actually focusing active options, we must manually adjust scroll\\n     * to reveal options below the fold. First, we find the offset of the option from the top\\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\\n     * the panel height + the option height, so the active option will be just visible at the\\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\\n     * not adjusted.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._scrollToOption = function () {\\n        var /** @type {?} */ optionOffset = this.autocomplete._keyManager.activeItemIndex ?\\n            this.autocomplete._keyManager.activeItemIndex * AUTOCOMPLETE_OPTION_HEIGHT : 0;\\n        var /** @type {?} */ panelTop = this.autocomplete._getScrollTop();\\n        if (optionOffset < panelTop) {\\n            // Scroll up to reveal selected option scrolled above the panel top\\n            this.autocomplete._setScrollTop(optionOffset);\\n        }\\n        else if (optionOffset + AUTOCOMPLETE_OPTION_HEIGHT > panelTop + AUTOCOMPLETE_PANEL_HEIGHT) {\\n            // Scroll down to reveal selected option scrolled below the panel bottom\\n            var /** @type {?} */ newScrollTop = Math.max(0, optionOffset - AUTOCOMPLETE_PANEL_HEIGHT + AUTOCOMPLETE_OPTION_HEIGHT);\\n            this.autocomplete._setScrollTop(newScrollTop);\\n        }\\n    };\\n    /**\\n     * This method listens to a stream of panel closing actions and resets the\\n     * stream every time the option list changes.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._subscribeToClosingActions = function () {\\n        var _this = this;\\n        // When the zone is stable initially, and when the option list changes...\\n        return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"R\" /* RxChain */].from(__WEBPACK_IMPORTED_MODULE_8_rxjs_observable_merge__[\"merge\"](__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_4\" /* first */].call(this._zone.onStable), this.autocomplete.options.changes))\\n            .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_10\" /* switchMap */], function () {\\n            _this._resetPanel();\\n            return _this.panelClosingActions;\\n        })\\n            .call(__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_4\" /* first */])\\n            .subscribe(function (event) { return _this._setValueAndClose(event); });\\n    };\\n    /**\\n     * Destroys the autocomplete suggestion panel.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._destroyPanel = function () {\\n        if (this._overlayRef) {\\n            this.closePanel();\\n            this._overlayRef.dispose();\\n            this._overlayRef = null;\\n        }\\n    };\\n    /**\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._setTriggerValue = function (value) {\\n        var /** @type {?} */ toDisplay = this.autocomplete.displayWith ? this.autocomplete.displayWith(value) : value;\\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\\n        // The display value can also be the number zero and shouldn\\'t fall back to an empty string.\\n        this._element.nativeElement.value = toDisplay != null ? toDisplay : \\'\\';\\n    };\\n    /**\\n     * This method closes the panel, and if a value is specified, also sets the associated\\n     * control to that value. It will also mark the control as dirty if this interaction\\n     * stemmed from the user.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._setValueAndClose = function (event) {\\n        if (event && event.source) {\\n            this._clearPreviousSelectedOption(event.source);\\n            this._setTriggerValue(event.source.value);\\n            this._onChange(event.source.value);\\n            this._element.nativeElement.focus();\\n        }\\n        this.closePanel();\\n    };\\n    /**\\n     * Clear any previous selected option and emit a selection change event for this option\\n     * @param {?} skip\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._clearPreviousSelectedOption = function (skip) {\\n        this.autocomplete.options.forEach(function (option) {\\n            if (option != skip && option.selected) {\\n                option.deselect();\\n            }\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._createOverlay = function () {\\n        this._portal = new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"U\" /* TemplatePortal */](this.autocomplete.template, this._viewContainerRef);\\n        this._overlayRef = this._overlay.create(this._getOverlayConfig());\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._getOverlayConfig = function () {\\n        var /** @type {?} */ overlayState = new OverlayState();\\n        overlayState.positionStrategy = this._getOverlayPosition();\\n        overlayState.width = this._getHostWidth();\\n        overlayState.direction = this._dir ? this._dir.value : \\'ltr\\';\\n        overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();\\n        return overlayState;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._getOverlayPosition = function () {\\n        this._positionStrategy = this._overlay.position().connectedTo(this._element, { originX: \\'start\\', originY: \\'bottom\\' }, { overlayX: \\'start\\', overlayY: \\'top\\' })\\n            .withFallbackPosition({ originX: \\'start\\', originY: \\'top\\' }, { overlayX: \\'start\\', overlayY: \\'bottom\\' });\\n        this._subscribeToPositionChanges(this._positionStrategy);\\n        return this._positionStrategy;\\n    };\\n    /**\\n     * This method subscribes to position changes in the autocomplete panel, so the panel\\'s\\n     * y-offset can be adjusted to match the new position.\\n     * @param {?} strategy\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._subscribeToPositionChanges = function (strategy) {\\n        var _this = this;\\n        this._panelPositionSubscription = strategy.onPositionChange.subscribe(function (change) {\\n            _this.autocomplete.positionY = change.connectionPair.originY === \\'top\\' ? \\'above\\' : \\'below\\';\\n        });\\n    };\\n    /**\\n     * Returns the width of the input element, so the panel width can match it.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._getHostWidth = function () {\\n        return this._element.nativeElement.getBoundingClientRect().width;\\n    };\\n    /**\\n     * Reset active item to -1 so arrow events will activate the correct options.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._resetActiveItem = function () {\\n        this.autocomplete._keyManager.setActiveItem(-1);\\n    };\\n    /**\\n     * Resets the active item and re-calculates alignment of the panel in case its size\\n     * has changed due to fewer or greater number of options.\\n     * @return {?}\\n     */\\n    MdAutocompleteTrigger.prototype._resetPanel = function () {\\n        this._resetActiveItem();\\n        this._positionStrategy.recalculateLastPosition();\\n        this.autocomplete._setVisibility();\\n    };\\n    return MdAutocompleteTrigger;\\n}());\\nMdAutocompleteTrigger.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'input[mdAutocomplete], input[matAutocomplete],\\' +\\n                    \\'textarea[mdAutocomplete], textarea[matAutocomplete]\\',\\n                host: {\\n                    \\'role\\': \\'combobox\\',\\n                    \\'autocomplete\\': \\'off\\',\\n                    \\'aria-autocomplete\\': \\'list\\',\\n                    \\'aria-multiline\\': \\'false\\',\\n                    \\'[attr.aria-activedescendant]\\': \\'activeOption?.id\\',\\n                    \\'[attr.aria-expanded]\\': \\'panelOpen.toString()\\',\\n                    \\'[attr.aria-owns]\\': \\'autocomplete?.id\\',\\n                    // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\\n                    // a little earlier. This avoids issues where IE delays the focusing of the input.\\n                    \\'(focusin)\\': \\'openPanel()\\',\\n                    \\'(input)\\': \\'_handleInput($event)\\',\\n                    \\'(blur)\\': \\'_onTouched()\\',\\n                    \\'(keydown)\\': \\'_handleKeydown($event)\\',\\n                },\\n                providers: [MD_AUTOCOMPLETE_VALUE_ACCESSOR]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdAutocompleteTrigger.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: MdInputContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Host\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"DOCUMENT\"],] },] },\\n]; };\\nMdAutocompleteTrigger.propDecorators = {\\n    \\'autocomplete\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdAutocomplete\\',] },],\\n    \\'_matAutocomplete\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matAutocomplete\\',] },],\\n};\\nvar MdAutocompleteModule = /*@__PURE__*/(function () {\\n    function MdAutocompleteModule() {\\n    }\\n    return MdAutocompleteModule;\\n}());\\nMdAutocompleteModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [MdOptionModule, OverlayModule, MdCommonModule, __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"]],\\n                exports: [MdAutocomplete, MdOptionModule, MdAutocompleteTrigger, MdCommonModule],\\n                declarations: [MdAutocomplete, MdAutocompleteTrigger],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdAutocompleteModule.ctorParameters = function () { return []; };\\n/**\\n * An internal class that represents the data corresponding to a single calendar cell.\\n * \\\\@docs-private\\n */\\nvar MdCalendarCell = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} value\\n     * @param {?} displayValue\\n     * @param {?} ariaLabel\\n     * @param {?} enabled\\n     */\\n    function MdCalendarCell(value, displayValue, ariaLabel, enabled) {\\n        this.value = value;\\n        this.displayValue = displayValue;\\n        this.ariaLabel = ariaLabel;\\n        this.enabled = enabled;\\n    }\\n    return MdCalendarCell;\\n}());\\n/**\\n * An internal component used to display calendar data in a table.\\n * \\\\@docs-private\\n */\\nvar MdCalendarBody = /*@__PURE__*/(function () {\\n    function MdCalendarBody() {\\n        /**\\n         * The number of columns in the table.\\n         */\\n        this.numCols = 7;\\n        /**\\n         * Whether to allow selection of disabled cells.\\n         */\\n        this.allowDisabledSelection = false;\\n        /**\\n         * The cell number of the active cell in the table.\\n         */\\n        this.activeCell = 0;\\n        /**\\n         * Emits when a new value is selected.\\n         */\\n        this.selectedValueChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    /**\\n     * @param {?} cell\\n     * @return {?}\\n     */\\n    MdCalendarBody.prototype._cellClicked = function (cell) {\\n        if (!this.allowDisabledSelection && !cell.enabled) {\\n            return;\\n        }\\n        this.selectedValueChange.emit(cell.value);\\n    };\\n    Object.defineProperty(MdCalendarBody.prototype, \"_firstRowOffset\", {\\n        /**\\n         * The number of blank cells to put at the beginning for the first row.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.rows && this.rows.length && this.rows[0].length ?\\n                this.numCols - this.rows[0].length : 0;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} rowIndex\\n     * @param {?} colIndex\\n     * @return {?}\\n     */\\n    MdCalendarBody.prototype._isActiveCell = function (rowIndex, colIndex) {\\n        var /** @type {?} */ cellNumber = rowIndex * this.numCols + colIndex;\\n        // Account for the fact that the first row may not have as many cells.\\n        if (rowIndex) {\\n            cellNumber -= this._firstRowOffset;\\n        }\\n        return cellNumber == this.activeCell;\\n    };\\n    return MdCalendarBody;\\n}());\\nMdCalendarBody.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'[md-calendar-body]\\',\\n                template: \"<tr *ngIf=\\\\\"_firstRowOffset < labelMinRequiredCells\\\\\" aria-hidden=\\\\\"true\\\\\"><td class=\\\\\"mat-calendar-body-label\\\\\" [attr.colspan]=\\\\\"numCols\\\\\">{{label}}</td></tr><tr *ngFor=\\\\\"let row of rows; let rowIndex = index\\\\\" role=\\\\\"row\\\\\"><td *ngIf=\\\\\"rowIndex === 0 && _firstRowOffset\\\\\" aria-hidden=\\\\\"true\\\\\" class=\\\\\"mat-calendar-body-label\\\\\" [attr.colspan]=\\\\\"_firstRowOffset\\\\\">{{_firstRowOffset >= labelMinRequiredCells ? label : \\'\\'}}</td><td *ngFor=\\\\\"let item of row; let colIndex = index\\\\\" role=\\\\\"gridcell\\\\\" class=\\\\\"mat-calendar-body-cell\\\\\" [tabindex]=\\\\\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\\\\\" [class.mat-calendar-body-disabled]=\\\\\"!item.enabled\\\\\" [class.mat-calendar-body-active]=\\\\\"_isActiveCell(rowIndex, colIndex)\\\\\" [attr.aria-label]=\\\\\"item.ariaLabel\\\\\" [attr.aria-disabled]=\\\\\"!item.enabled || null\\\\\" (click)=\\\\\"_cellClicked(item)\\\\\"><div class=\\\\\"mat-calendar-body-cell-content\\\\\" [class.mat-calendar-body-selected]=\\\\\"selectedValue === item.value\\\\\" [class.mat-calendar-body-today]=\\\\\"todayValue === item.value\\\\\">{{item.displayValue}}</div></td></tr>\",\\n                styles: [\".mat-calendar-body{min-width:224px}.mat-calendar-body-label{padding:7.14286% 0 7.14286% 7.14286%;height:0;line-height:0;transform:translateX(-6px);text-align:left}.mat-calendar-body-cell{position:relative;width:14.28571%;height:0;line-height:0;padding:7.14286% 0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;border-width:1px;border-style:solid;border-radius:50%}[dir=rtl] .mat-calendar-body-label{padding:0 7.14286% 0 0;transform:translateX(6px);text-align:right}\"],\\n                host: {\\n                    \\'class\\': \\'mat-calendar-body\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCalendarBody.ctorParameters = function () { return []; };\\nMdCalendarBody.propDecorators = {\\n    \\'label\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'rows\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'todayValue\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedValue\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'labelMinRequiredCells\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'numCols\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'allowDisabledSelection\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'activeCell\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedValueChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * \\\\@docs-private\\n * @param {?} provider\\n * @return {?}\\n */\\nfunction createMissingDateImplError(provider) {\\n    return Error(\"MdDatepicker: No provider found for \" + provider + \". You must import one of the following \" +\\n        \"modules at your application root: MdNativeDateModule, or provide a custom implementation.\");\\n}\\nvar DAYS_PER_WEEK = 7;\\n/**\\n * An internal component used to display a single month in the datepicker.\\n * \\\\@docs-private\\n */\\nvar MdMonthView = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dateAdapter\\n     * @param {?} _dateFormats\\n     */\\n    function MdMonthView(_dateAdapter, _dateFormats) {\\n        this._dateAdapter = _dateAdapter;\\n        this._dateFormats = _dateFormats;\\n        /**\\n         * Emits when a new date is selected.\\n         */\\n        this.selectedChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        if (!this._dateAdapter) {\\n            throw createMissingDateImplError(\\'DateAdapter\\');\\n        }\\n        if (!this._dateFormats) {\\n            throw createMissingDateImplError(\\'MD_DATE_FORMATS\\');\\n        }\\n        var firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();\\n        var narrowWeekdays = this._dateAdapter.getDayOfWeekNames(\\'narrow\\');\\n        var longWeekdays = this._dateAdapter.getDayOfWeekNames(\\'long\\');\\n        // Rotate the labels for days of the week based on the configured first day of the week.\\n        var weekdays = longWeekdays.map(function (long, i) {\\n            return { long: long, narrow: narrowWeekdays[i] };\\n        });\\n        this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));\\n        this._activeDate = this._dateAdapter.today();\\n    }\\n    Object.defineProperty(MdMonthView.prototype, \"activeDate\", {\\n        /**\\n         * The date to display in this month view (everything other than the month and year is ignored).\\n         * @return {?}\\n         */\\n        get: function () { return this._activeDate; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            var /** @type {?} */ oldActiveDate = this._activeDate;\\n            this._activeDate = value || this._dateAdapter.today();\\n            if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {\\n                this._init();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdMonthView.prototype, \"selected\", {\\n        /**\\n         * The currently selected date.\\n         * @return {?}\\n         */\\n        get: function () { return this._selected; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._selected = value;\\n            this._selectedDate = this._getDateInCurrentMonth(this.selected);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdMonthView.prototype.ngAfterContentInit = function () {\\n        this._init();\\n    };\\n    /**\\n     * Handles when a new date is selected.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdMonthView.prototype._dateSelected = function (date) {\\n        if (this._selectedDate == date) {\\n            return;\\n        }\\n        this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), date));\\n    };\\n    /**\\n     * Initializes this month view.\\n     * @return {?}\\n     */\\n    MdMonthView.prototype._init = function () {\\n        this._selectedDate = this._getDateInCurrentMonth(this.selected);\\n        this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());\\n        this._monthLabel =\\n            this._dateAdapter.getMonthNames(\\'short\\')[this._dateAdapter.getMonth(this.activeDate)]\\n                .toLocaleUpperCase();\\n        var /** @type {?} */ firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);\\n        this._firstWeekOffset =\\n            (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) -\\n                this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;\\n        this._createWeekCells();\\n    };\\n    /**\\n     * Creates MdCalendarCells for the dates in this month.\\n     * @return {?}\\n     */\\n    MdMonthView.prototype._createWeekCells = function () {\\n        var /** @type {?} */ daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);\\n        var /** @type {?} */ dateNames = this._dateAdapter.getDateNames();\\n        this._weeks = [[]];\\n        for (var /** @type {?} */ i = 0, /** @type {?} */ cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {\\n            if (cell == DAYS_PER_WEEK) {\\n                this._weeks.push([]);\\n                cell = 0;\\n            }\\n            var /** @type {?} */ date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);\\n            var /** @type {?} */ enabled = !this.dateFilter ||\\n                this.dateFilter(date);\\n            var /** @type {?} */ ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);\\n            this._weeks[this._weeks.length - 1]\\n                .push(new MdCalendarCell(i + 1, dateNames[i], ariaLabel, enabled));\\n        }\\n    };\\n    /**\\n     * Gets the date in this month that the given Date falls on.\\n     * Returns null if the given Date is in another month.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdMonthView.prototype._getDateInCurrentMonth = function (date) {\\n        return this._hasSameMonthAndYear(date, this.activeDate) ?\\n            this._dateAdapter.getDate(date) : null;\\n    };\\n    /**\\n     * Checks whether the 2 dates are non-null and fall within the same month of the same year.\\n     * @param {?} d1\\n     * @param {?} d2\\n     * @return {?}\\n     */\\n    MdMonthView.prototype._hasSameMonthAndYear = function (d1, d2) {\\n        return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&\\n            this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));\\n    };\\n    return MdMonthView;\\n}());\\nMdMonthView.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-month-view\\',\\n                template: \"<table class=\\\\\"mat-calendar-table\\\\\"><thead class=\\\\\"mat-calendar-table-header\\\\\"><tr><th *ngFor=\\\\\"let day of _weekdays\\\\\" [attr.aria-label]=\\\\\"day.long\\\\\">{{day.narrow}}</th></tr><tr><th class=\\\\\"mat-calendar-table-header-divider\\\\\" colspan=\\\\\"7\\\\\" aria-hidden=\\\\\"true\\\\\"></th></tr></thead><tbody md-calendar-body role=\\\\\"grid\\\\\" [label]=\\\\\"_monthLabel\\\\\" [rows]=\\\\\"_weeks\\\\\" [todayValue]=\\\\\"_todayDate\\\\\" [selectedValue]=\\\\\"_selectedDate\\\\\" [labelMinRequiredCells]=\\\\\"3\\\\\" [activeCell]=\\\\\"_dateAdapter.getDate(activeDate) - 1\\\\\" (selectedValueChange)=\\\\\"_dateSelected($event)\\\\\"></tbody></table>\",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMonthView.ctorParameters = function () { return [\\n    { type: DateAdapter, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_DATE_FORMATS,] },] },\\n]; };\\nMdMonthView.propDecorators = {\\n    \\'activeDate\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'dateFilter\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * An internal component used to display a single year in the datepicker.\\n * \\\\@docs-private\\n */\\nvar MdYearView = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dateAdapter\\n     * @param {?} _dateFormats\\n     */\\n    function MdYearView(_dateAdapter, _dateFormats) {\\n        this._dateAdapter = _dateAdapter;\\n        this._dateFormats = _dateFormats;\\n        /**\\n         * Emits when a new month is selected.\\n         */\\n        this.selectedChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        if (!this._dateAdapter) {\\n            throw createMissingDateImplError(\\'DateAdapter\\');\\n        }\\n        if (!this._dateFormats) {\\n            throw createMissingDateImplError(\\'MD_DATE_FORMATS\\');\\n        }\\n        this._activeDate = this._dateAdapter.today();\\n    }\\n    Object.defineProperty(MdYearView.prototype, \"activeDate\", {\\n        /**\\n         * The date to display in this year view (everything other than the year is ignored).\\n         * @return {?}\\n         */\\n        get: function () { return this._activeDate; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            var /** @type {?} */ oldActiveDate = this._activeDate;\\n            this._activeDate = value || this._dateAdapter.today();\\n            if (this._dateAdapter.getYear(oldActiveDate) != this._dateAdapter.getYear(this._activeDate)) {\\n                this._init();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdYearView.prototype, \"selected\", {\\n        /**\\n         * The currently selected date.\\n         * @return {?}\\n         */\\n        get: function () { return this._selected; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._selected = value;\\n            this._selectedMonth = this._getMonthInCurrentYear(this.selected);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdYearView.prototype.ngAfterContentInit = function () {\\n        this._init();\\n    };\\n    /**\\n     * Handles when a new month is selected.\\n     * @param {?} month\\n     * @return {?}\\n     */\\n    MdYearView.prototype._monthSelected = function (month) {\\n        this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, this._dateAdapter.getDate(this.activeDate)));\\n    };\\n    /**\\n     * Initializes this month view.\\n     * @return {?}\\n     */\\n    MdYearView.prototype._init = function () {\\n        var _this = this;\\n        this._selectedMonth = this._getMonthInCurrentYear(this.selected);\\n        this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());\\n        this._yearLabel = this._dateAdapter.getYearName(this.activeDate);\\n        var /** @type {?} */ monthNames = this._dateAdapter.getMonthNames(\\'short\\');\\n        // First row of months only contains 5 elements so we can fit the year label on the same row.\\n        this._months = [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 10, 11]].map(function (row) { return row.map(function (month) { return _this._createCellForMonth(month, monthNames[month]); }); });\\n    };\\n    /**\\n     * Gets the month in this year that the given Date falls on.\\n     * Returns null if the given Date is in another year.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdYearView.prototype._getMonthInCurrentYear = function (date) {\\n        return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ?\\n            this._dateAdapter.getMonth(date) : null;\\n    };\\n    /**\\n     * Creates an MdCalendarCell for the given month.\\n     * @param {?} month\\n     * @param {?} monthName\\n     * @return {?}\\n     */\\n    MdYearView.prototype._createCellForMonth = function (month, monthName) {\\n        var /** @type {?} */ ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);\\n        return new MdCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._isMonthEnabled(month));\\n    };\\n    /**\\n     * Whether the given month is enabled.\\n     * @param {?} month\\n     * @return {?}\\n     */\\n    MdYearView.prototype._isMonthEnabled = function (month) {\\n        if (!this.dateFilter) {\\n            return true;\\n        }\\n        var /** @type {?} */ firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\\n        // If any date in the month is enabled count the month as enabled.\\n        for (var /** @type {?} */ date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {\\n            if (this.dateFilter(date)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n    return MdYearView;\\n}());\\nMdYearView.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-year-view\\',\\n                template: \"<table class=\\\\\"mat-calendar-table\\\\\"><thead class=\\\\\"mat-calendar-table-header\\\\\"><tr><th class=\\\\\"mat-calendar-table-header-divider\\\\\" colspan=\\\\\"7\\\\\"></th></tr></thead><tbody md-calendar-body role=\\\\\"grid\\\\\" allowDisabledSelection=\\\\\"true\\\\\" [label]=\\\\\"_yearLabel\\\\\" [rows]=\\\\\"_months\\\\\" [todayValue]=\\\\\"_todayMonth\\\\\" [selectedValue]=\\\\\"_selectedMonth\\\\\" [labelMinRequiredCells]=\\\\\"2\\\\\" [activeCell]=\\\\\"_dateAdapter.getMonth(activeDate)\\\\\" (selectedValueChange)=\\\\\"_monthSelected($event)\\\\\"></tbody></table>\",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdYearView.ctorParameters = function () { return [\\n    { type: DateAdapter, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_DATE_FORMATS,] },] },\\n]; };\\nMdYearView.propDecorators = {\\n    \\'activeDate\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'dateFilter\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Datepicker data that requires internationalization.\\n */\\nvar MdDatepickerIntl = /*@__PURE__*/(function () {\\n    function MdDatepickerIntl() {\\n        /**\\n         * A label for the calendar popup (used by screen readers).\\n         */\\n        this.calendarLabel = \\'Calendar\\';\\n        /**\\n         * A label for the button used to open the calendar popup (used by screen readers).\\n         */\\n        this.openCalendarLabel = \\'Open calendar\\';\\n        /**\\n         * A label for the previous month button (used by screen readers).\\n         */\\n        this.prevMonthLabel = \\'Previous month\\';\\n        /**\\n         * A label for the next month button (used by screen readers).\\n         */\\n        this.nextMonthLabel = \\'Next month\\';\\n        /**\\n         * A label for the previous year button (used by screen readers).\\n         */\\n        this.prevYearLabel = \\'Previous year\\';\\n        /**\\n         * A label for the next year button (used by screen readers).\\n         */\\n        this.nextYearLabel = \\'Next year\\';\\n        /**\\n         * A label for the \\'switch to month view\\' button (used by screen readers).\\n         */\\n        this.switchToMonthViewLabel = \\'Change to month view\\';\\n        /**\\n         * A label for the \\'switch to year view\\' button (used by screen readers).\\n         */\\n        this.switchToYearViewLabel = \\'Change to year view\\';\\n    }\\n    return MdDatepickerIntl;\\n}());\\nMdDatepickerIntl.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepickerIntl.ctorParameters = function () { return []; };\\n/**\\n * A calendar that is used as part of the datepicker.\\n * \\\\@docs-private\\n */\\nvar MdCalendar = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _intl\\n     * @param {?} _ngZone\\n     * @param {?} _isCompatibilityMode\\n     * @param {?} _dateAdapter\\n     * @param {?} _dateFormats\\n     */\\n    function MdCalendar(_elementRef, _intl, _ngZone, _isCompatibilityMode, _dateAdapter, _dateFormats) {\\n        var _this = this;\\n        this._elementRef = _elementRef;\\n        this._intl = _intl;\\n        this._ngZone = _ngZone;\\n        this._isCompatibilityMode = _isCompatibilityMode;\\n        this._dateAdapter = _dateAdapter;\\n        this._dateFormats = _dateFormats;\\n        /**\\n         * Whether the calendar should be started in month or year view.\\n         */\\n        this.startView = \\'month\\';\\n        /**\\n         * Emits when the currently selected date changes.\\n         */\\n        this.selectedChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Date filter for the month and year views.\\n         */\\n        this._dateFilterForViews = function (date) {\\n            return !!date &&\\n                (!_this.dateFilter || _this.dateFilter(date)) &&\\n                (!_this.minDate || _this._dateAdapter.compareDate(date, _this.minDate) >= 0) &&\\n                (!_this.maxDate || _this._dateAdapter.compareDate(date, _this.maxDate) <= 0);\\n        };\\n        if (!this._dateAdapter) {\\n            throw createMissingDateImplError(\\'DateAdapter\\');\\n        }\\n        if (!this._dateFormats) {\\n            throw createMissingDateImplError(\\'MD_DATE_FORMATS\\');\\n        }\\n    }\\n    Object.defineProperty(MdCalendar.prototype, \"_activeDate\", {\\n        /**\\n         * The current active date. This determines which time period is shown and which date is\\n         * highlighted when using keyboard navigation.\\n         * @return {?}\\n         */\\n        get: function () { return this._clampedActiveDate; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCalendar.prototype, \"_periodButtonText\", {\\n        /**\\n         * The label for the current calendar view.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._monthView ?\\n                this._dateAdapter.format(this._activeDate, this._dateFormats.display.monthYearLabel)\\n                    .toLocaleUpperCase() :\\n                this._dateAdapter.getYearName(this._activeDate);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCalendar.prototype, \"_periodButtonLabel\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._monthView ? this._intl.switchToYearViewLabel : this._intl.switchToMonthViewLabel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCalendar.prototype, \"_prevButtonLabel\", {\\n        /**\\n         * The label for the the previous button.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._monthView ? this._intl.prevMonthLabel : this._intl.prevYearLabel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdCalendar.prototype, \"_nextButtonLabel\", {\\n        /**\\n         * The label for the the next button.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._monthView ? this._intl.nextMonthLabel : this._intl.nextYearLabel;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdCalendar.prototype.ngAfterContentInit = function () {\\n        this._activeDate = this.startAt || this._dateAdapter.today();\\n        this._focusActiveCell();\\n        this._monthView = this.startView != \\'year\\';\\n    };\\n    /**\\n     * Handles date selection in the month view.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._dateSelected = function (date) {\\n        if (!this._dateAdapter.sameDate(date, this.selected)) {\\n            this.selectedChange.emit(date);\\n        }\\n    };\\n    /**\\n     * Handles month selection in the year view.\\n     * @param {?} month\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._monthSelected = function (month) {\\n        this._activeDate = month;\\n        this._monthView = true;\\n    };\\n    /**\\n     * Handles user clicks on the period label.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._currentPeriodClicked = function () {\\n        this._monthView = !this._monthView;\\n    };\\n    /**\\n     * Handles user clicks on the previous button.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._previousClicked = function () {\\n        this._activeDate = this._monthView ?\\n            this._dateAdapter.addCalendarMonths(this._activeDate, -1) :\\n            this._dateAdapter.addCalendarYears(this._activeDate, -1);\\n    };\\n    /**\\n     * Handles user clicks on the next button.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._nextClicked = function () {\\n        this._activeDate = this._monthView ?\\n            this._dateAdapter.addCalendarMonths(this._activeDate, 1) :\\n            this._dateAdapter.addCalendarYears(this._activeDate, 1);\\n    };\\n    /**\\n     * Whether the previous period button is enabled.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._previousEnabled = function () {\\n        if (!this.minDate) {\\n            return true;\\n        }\\n        return !this.minDate || !this._isSameView(this._activeDate, this.minDate);\\n    };\\n    /**\\n     * Whether the next period button is enabled.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._nextEnabled = function () {\\n        return !this.maxDate || !this._isSameView(this._activeDate, this.maxDate);\\n    };\\n    /**\\n     * Handles keydown events on the calendar body.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._handleCalendarBodyKeydown = function (event) {\\n        // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\\n        // disabled ones from being selected. This may not be ideal, we should look into whether\\n        // navigation should skip over disabled dates, and if so, how to implement that efficiently.\\n        if (this._monthView) {\\n            this._handleCalendarBodyKeydownInMonthView(event);\\n        }\\n        else {\\n            this._handleCalendarBodyKeydownInYearView(event);\\n        }\\n    };\\n    /**\\n     * Focuses the active cell after the microtask queue is empty.\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._focusActiveCell = function () {\\n        var _this = this;\\n        this._ngZone.runOutsideAngular(function () { return __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_4\" /* first */].call(_this._ngZone.onStable).subscribe(function () {\\n            _this._elementRef.nativeElement.querySelector(\\'.mat-calendar-body-active\\').focus();\\n        }); });\\n    };\\n    /**\\n     * Whether the two dates represent the same view in the current view mode (month or year).\\n     * @param {?} date1\\n     * @param {?} date2\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._isSameView = function (date1, date2) {\\n        return this._monthView ?\\n            this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&\\n                this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2) :\\n            this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);\\n    };\\n    /**\\n     * Handles keydown events on the calendar body when calendar is in month view.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._handleCalendarBodyKeydownInMonthView = function (event) {\\n        switch (event.keyCode) {\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"C\" /* LEFT_ARROW */]:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Q\" /* RIGHT_ARROW */]:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"W\" /* UP_ARROW */]:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"p\" /* DOWN_ARROW */]:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"A\" /* HOME */]:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"t\" /* END */]:\\n                this._activeDate = this._dateAdapter.addCalendarDays(this._activeDate, (this._dateAdapter.getNumDaysInMonth(this._activeDate) -\\n                    this._dateAdapter.getDate(this._activeDate)));\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"K\" /* PAGE_UP */]:\\n                this._activeDate = event.altKey ?\\n                    this._dateAdapter.addCalendarYears(this._activeDate, -1) :\\n                    this._dateAdapter.addCalendarMonths(this._activeDate, -1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"J\" /* PAGE_DOWN */]:\\n                this._activeDate = event.altKey ?\\n                    this._dateAdapter.addCalendarYears(this._activeDate, 1) :\\n                    this._dateAdapter.addCalendarMonths(this._activeDate, 1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"u\" /* ENTER */]:\\n                if (this._dateFilterForViews(this._activeDate)) {\\n                    this._dateSelected(this._activeDate);\\n                    // Prevent unexpected default actions such as form submission.\\n                    event.preventDefault();\\n                }\\n                return;\\n            default:\\n                // Don\\'t prevent default or focus active cell on keys that we don\\'t explicitly handle.\\n                return;\\n        }\\n        this._focusActiveCell();\\n        // Prevent unexpected default actions such as form submission.\\n        event.preventDefault();\\n    };\\n    /**\\n     * Handles keydown events on the calendar body when calendar is in year view.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._handleCalendarBodyKeydownInYearView = function (event) {\\n        switch (event.keyCode) {\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"C\" /* LEFT_ARROW */]:\\n                this._activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Q\" /* RIGHT_ARROW */]:\\n                this._activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"W\" /* UP_ARROW */]:\\n                this._activeDate = this._prevMonthInSameCol(this._activeDate);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"p\" /* DOWN_ARROW */]:\\n                this._activeDate = this._nextMonthInSameCol(this._activeDate);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"A\" /* HOME */]:\\n                this._activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"t\" /* END */]:\\n                this._activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"K\" /* PAGE_UP */]:\\n                this._activeDate =\\n                    this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"J\" /* PAGE_DOWN */]:\\n                this._activeDate =\\n                    this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"u\" /* ENTER */]:\\n                this._monthSelected(this._activeDate);\\n                break;\\n            default:\\n                // Don\\'t prevent default or focus active cell on keys that we don\\'t explicitly handle.\\n                return;\\n        }\\n        this._focusActiveCell();\\n        // Prevent unexpected default actions such as form submission.\\n        event.preventDefault();\\n    };\\n    /**\\n     * Determine the date for the month that comes before the given month in the same column in the\\n     * calendar table.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._prevMonthInSameCol = function (date) {\\n        // Determine how many months to jump forward given that there are 2 empty slots at the beginning\\n        // of each year.\\n        var /** @type {?} */ increment = this._dateAdapter.getMonth(date) <= 4 ? -5 :\\n            (this._dateAdapter.getMonth(date) >= 7 ? -7 : -12);\\n        return this._dateAdapter.addCalendarMonths(date, increment);\\n    };\\n    /**\\n     * Determine the date for the month that comes after the given month in the same column in the\\n     * calendar table.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdCalendar.prototype._nextMonthInSameCol = function (date) {\\n        // Determine how many months to jump forward given that there are 2 empty slots at the beginning\\n        // of each year.\\n        var /** @type {?} */ increment = this._dateAdapter.getMonth(date) <= 4 ? 7 :\\n            (this._dateAdapter.getMonth(date) >= 7 ? 5 : 12);\\n        return this._dateAdapter.addCalendarMonths(date, increment);\\n    };\\n    return MdCalendar;\\n}());\\nMdCalendar.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-calendar\\',\\n                template: \"<div class=\\\\\"mat-calendar-header\\\\\"><div class=\\\\\"mat-calendar-controls\\\\\"><button *ngIf=\\\\\"!_isCompatibilityMode\\\\\" md-button class=\\\\\"mat-calendar-period-button\\\\\" (click)=\\\\\"_currentPeriodClicked()\\\\\" [attr.aria-label]=\\\\\"_periodButtonLabel\\\\\">{{_periodButtonText}}<div class=\\\\\"mat-calendar-arrow\\\\\" [class.mat-calendar-invert]=\\\\\"!_monthView\\\\\"></div></button> <button *ngIf=\\\\\"_isCompatibilityMode\\\\\" mat-button class=\\\\\"mat-calendar-period-button\\\\\" (click)=\\\\\"_currentPeriodClicked()\\\\\" [attr.aria-label]=\\\\\"_periodButtonLabel\\\\\">{{_periodButtonText}}<div class=\\\\\"mat-calendar-arrow\\\\\" [class.mat-calendar-invert]=\\\\\"!_monthView\\\\\"></div></button><div class=\\\\\"mat-calendar-spacer\\\\\"></div><button *ngIf=\\\\\"!_isCompatibilityMode\\\\\" md-icon-button class=\\\\\"mat-calendar-previous-button\\\\\" [disabled]=\\\\\"!_previousEnabled()\\\\\" (click)=\\\\\"_previousClicked()\\\\\" [attr.aria-label]=\\\\\"_prevButtonLabel\\\\\"></button> <button *ngIf=\\\\\"_isCompatibilityMode\\\\\" mat-icon-button class=\\\\\"mat-calendar-previous-button\\\\\" [disabled]=\\\\\"!_previousEnabled()\\\\\" (click)=\\\\\"_previousClicked()\\\\\" [attr.aria-label]=\\\\\"_prevButtonLabel\\\\\"></button> <button *ngIf=\\\\\"!_isCompatibilityMode\\\\\" md-icon-button class=\\\\\"mat-calendar-next-button\\\\\" [disabled]=\\\\\"!_nextEnabled()\\\\\" (click)=\\\\\"_nextClicked()\\\\\" [attr.aria-label]=\\\\\"_nextButtonLabel\\\\\"></button> <button *ngIf=\\\\\"_isCompatibilityMode\\\\\" mat-icon-button class=\\\\\"mat-calendar-next-button\\\\\" [disabled]=\\\\\"!_nextEnabled()\\\\\" (click)=\\\\\"_nextClicked()\\\\\" [attr.aria-label]=\\\\\"_nextButtonLabel\\\\\"></button></div></div><div class=\\\\\"mat-calendar-content\\\\\" (keydown)=\\\\\"_handleCalendarBodyKeydown($event)\\\\\" [ngSwitch]=\\\\\"_monthView\\\\\" cdkMonitorSubtreeFocus><md-month-view *ngSwitchCase=\\\\\"true\\\\\" [activeDate]=\\\\\"_activeDate\\\\\" [selected]=\\\\\"selected\\\\\" [dateFilter]=\\\\\"_dateFilterForViews\\\\\" (selectedChange)=\\\\\"_dateSelected($event)\\\\\"></md-month-view><md-year-view *ngSwitchDefault [activeDate]=\\\\\"_activeDate\\\\\" [selected]=\\\\\"selected\\\\\" [dateFilter]=\\\\\"_dateFilterForViews\\\\\" (selectedChange)=\\\\\"_monthSelected($event)\\\\\"></md-year-view></div>\",\\n                styles: [\".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:0}.mat-calendar-controls{display:flex;padding:5% calc(100% / 14 - 22px) 5% calc(100% / 14 - 22px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{content:\\'\\';position:absolute;top:0;left:0;bottom:0;right:0;margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:\\'\\';position:absolute;top:0;left:-8px;right:-8px;height:1px}\"],\\n                host: {\\n                    \\'class\\': \\'mat-calendar\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCalendar.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: MdDatepickerIntl, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MATERIAL_COMPATIBILITY_MODE,] },] },\\n    { type: DateAdapter, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_DATE_FORMATS,] },] },\\n]; };\\nMdCalendar.propDecorators = {\\n    \\'startAt\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'startView\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selected\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'minDate\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'maxDate\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'dateFilter\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Used to generate a unique ID for each datepicker instance.\\n */\\nvar datepickerUid = 0;\\n/**\\n * Component used as the content for the datepicker dialog and popup. We use this instead of using\\n * MdCalendar directly as the content so we can control the initial focus. This also gives us a\\n * place to put additional features of the popup that are not part of the calendar itself in the\\n * future. (e.g. confirmation buttons).\\n * \\\\@docs-private\\n */\\nvar MdDatepickerContent = /*@__PURE__*/(function () {\\n    function MdDatepickerContent() {\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    MdDatepickerContent.prototype.ngAfterContentInit = function () {\\n        this._calendar._focusActiveCell();\\n    };\\n    /**\\n     * Handles keydown event on datepicker content.\\n     * @param {?} event The event.\\n     * @return {?}\\n     */\\n    MdDatepickerContent.prototype._handleKeydown = function (event) {\\n        if (event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"v\" /* ESCAPE */]) {\\n            this.datepicker.close();\\n            event.preventDefault();\\n        }\\n    };\\n    return MdDatepickerContent;\\n}());\\nMdDatepickerContent.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-datepicker-content\\',\\n                template: \"<md-calendar cdkTrapFocus [id]=\\\\\"datepicker.id\\\\\" [startAt]=\\\\\"datepicker.startAt\\\\\" [startView]=\\\\\"datepicker.startView\\\\\" [minDate]=\\\\\"datepicker._minDate\\\\\" [maxDate]=\\\\\"datepicker._maxDate\\\\\" [dateFilter]=\\\\\"datepicker._dateFilter\\\\\" [selected]=\\\\\"datepicker._selected\\\\\" (selectedChange)=\\\\\"datepicker._selectAndClose($event)\\\\\"></md-calendar>\",\\n                styles: [\".mat-datepicker-content{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);display:block}.mat-calendar{width:296px}.mat-datepicker-content-touch{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{width:64vmin;height:80vmin;min-width:250px;min-height:312px;max-width:750px;max-height:788px}\"],\\n                host: {\\n                    \\'class\\': \\'mat-datepicker-content\\',\\n                    \\'[class.mat-datepicker-content-touch]\\': \\'datepicker.touchUi\\',\\n                    \\'(keydown)\\': \\'_handleKeydown($event)\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepickerContent.ctorParameters = function () { return []; };\\nMdDatepickerContent.propDecorators = {\\n    \\'_calendar\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [MdCalendar,] },],\\n};\\n/**\\n * Component responsible for managing the datepicker popup/dialog.\\n */\\nvar MdDatepicker = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _dialog\\n     * @param {?} _overlay\\n     * @param {?} _ngZone\\n     * @param {?} _viewContainerRef\\n     * @param {?} _dateAdapter\\n     * @param {?} _dir\\n     * @param {?} _document\\n     */\\n    function MdDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, _dateAdapter, _dir, _document) {\\n        this._dialog = _dialog;\\n        this._overlay = _overlay;\\n        this._ngZone = _ngZone;\\n        this._viewContainerRef = _viewContainerRef;\\n        this._dateAdapter = _dateAdapter;\\n        this._dir = _dir;\\n        this._document = _document;\\n        /**\\n         * The view that the calendar should start in.\\n         */\\n        this.startView = \\'month\\';\\n        /**\\n         * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\\n         * than a popup and elements have more padding to allow for bigger touch targets.\\n         */\\n        this.touchUi = false;\\n        /**\\n         * Emits new selected date when selected date changes.\\n         */\\n        this.selectedChanged = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Whether the calendar is open.\\n         */\\n        this.opened = false;\\n        /**\\n         * The id for the datepicker calendar.\\n         */\\n        this.id = \"md-datepicker-\" + datepickerUid++;\\n        /**\\n         * The currently selected date.\\n         */\\n        this._selected = null;\\n        /**\\n         * The element that was focused before the datepicker was opened.\\n         */\\n        this._focusedElementBeforeOpen = null;\\n        if (!this._dateAdapter) {\\n            throw createMissingDateImplError(\\'DateAdapter\\');\\n        }\\n    }\\n    Object.defineProperty(MdDatepicker.prototype, \"startAt\", {\\n        /**\\n         * The date to open the calendar to initially.\\n         * @return {?}\\n         */\\n        get: function () {\\n            // If an explicit startAt is set we start there, otherwise we start at whatever the currently\\n            // selected value is.\\n            return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);\\n        },\\n        /**\\n         * @param {?} date\\n         * @return {?}\\n         */\\n        set: function (date) { this._startAt = date; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepicker.prototype, \"_minDate\", {\\n        /**\\n         * The minimum selectable date.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._datepickerInput && this._datepickerInput.min;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepicker.prototype, \"_maxDate\", {\\n        /**\\n         * The maximum selectable date.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._datepickerInput && this._datepickerInput.max;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepicker.prototype, \"_dateFilter\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._datepickerInput && this._datepickerInput._dateFilter;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype.ngOnDestroy = function () {\\n        this.close();\\n        if (this._popupRef) {\\n            this._popupRef.dispose();\\n        }\\n        if (this._inputSubscription) {\\n            this._inputSubscription.unsubscribe();\\n        }\\n    };\\n    /**\\n     * Selects the given date and closes the currently open popup or dialog.\\n     * @param {?} date\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._selectAndClose = function (date) {\\n        var /** @type {?} */ oldValue = this._selected;\\n        this._selected = date;\\n        if (!this._dateAdapter.sameDate(oldValue, this._selected)) {\\n            this.selectedChanged.emit(date);\\n        }\\n        this.close();\\n    };\\n    /**\\n     * Register an input with this datepicker.\\n     * @param {?} input The datepicker input to register with this datepicker.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._registerInput = function (input) {\\n        var _this = this;\\n        if (this._datepickerInput) {\\n            throw Error(\\'An MdDatepicker can only be associated with a single input.\\');\\n        }\\n        this._datepickerInput = input;\\n        this._inputSubscription =\\n            this._datepickerInput._valueChange.subscribe(function (value) { return _this._selected = value; });\\n    };\\n    /**\\n     * Open the calendar.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype.open = function () {\\n        if (this.opened) {\\n            return;\\n        }\\n        if (!this._datepickerInput) {\\n            throw Error(\\'Attempted to open an MdDatepicker with no associated input.\\');\\n        }\\n        if (this._document) {\\n            this._focusedElementBeforeOpen = this._document.activeElement;\\n        }\\n        this.touchUi ? this._openAsDialog() : this._openAsPopup();\\n        this.opened = true;\\n    };\\n    /**\\n     * Close the calendar.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype.close = function () {\\n        if (!this.opened) {\\n            return;\\n        }\\n        if (this._popupRef && this._popupRef.hasAttached()) {\\n            this._popupRef.detach();\\n        }\\n        if (this._dialogRef) {\\n            this._dialogRef.close();\\n            this._dialogRef = null;\\n        }\\n        if (this._calendarPortal && this._calendarPortal.isAttached) {\\n            this._calendarPortal.detach();\\n        }\\n        if (this._focusedElementBeforeOpen && \\'focus\\' in this._focusedElementBeforeOpen) {\\n            this._focusedElementBeforeOpen.focus();\\n            this._focusedElementBeforeOpen = null;\\n        }\\n        this.opened = false;\\n    };\\n    /**\\n     * Open the calendar as a dialog.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._openAsDialog = function () {\\n        var _this = this;\\n        this._dialogRef = this._dialog.open(MdDatepickerContent, {\\n            viewContainerRef: this._viewContainerRef,\\n            direction: this._dir ? this._dir.value : \\'ltr\\'\\n        });\\n        this._dialogRef.afterClosed().subscribe(function () { return _this.close(); });\\n        this._dialogRef.componentInstance.datepicker = this;\\n    };\\n    /**\\n     * Open the calendar as a popup.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._openAsPopup = function () {\\n        var _this = this;\\n        if (!this._calendarPortal) {\\n            this._calendarPortal = new __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"n\" /* ComponentPortal */](MdDatepickerContent, this._viewContainerRef);\\n        }\\n        if (!this._popupRef) {\\n            this._createPopup();\\n        }\\n        if (!this._popupRef.hasAttached()) {\\n            var /** @type {?} */ componentRef = this._popupRef.attach(this._calendarPortal);\\n            componentRef.instance.datepicker = this;\\n            // Update the position once the calendar has rendered.\\n            __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"_4\" /* first */].call(this._ngZone.onStable).subscribe(function () { return _this._popupRef.updatePosition(); });\\n        }\\n        this._popupRef.backdropClick().subscribe(function () { return _this.close(); });\\n    };\\n    /**\\n     * Create the popup.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._createPopup = function () {\\n        var /** @type {?} */ overlayState = new OverlayState();\\n        overlayState.positionStrategy = this._createPopupPositionStrategy();\\n        overlayState.hasBackdrop = true;\\n        overlayState.backdropClass = \\'md-overlay-transparent-backdrop\\';\\n        overlayState.direction = this._dir ? this._dir.value : \\'ltr\\';\\n        overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();\\n        this._popupRef = this._overlay.create(overlayState);\\n    };\\n    /**\\n     * Create the popup PositionStrategy.\\n     * @return {?}\\n     */\\n    MdDatepicker.prototype._createPopupPositionStrategy = function () {\\n        return this._overlay.position()\\n            .connectedTo(this._datepickerInput.getPopupConnectionElementRef(), { originX: \\'start\\', originY: \\'bottom\\' }, { overlayX: \\'start\\', overlayY: \\'top\\' })\\n            .withFallbackPosition({ originX: \\'start\\', originY: \\'top\\' }, { overlayX: \\'start\\', overlayY: \\'bottom\\' })\\n            .withFallbackPosition({ originX: \\'end\\', originY: \\'bottom\\' }, { overlayX: \\'end\\', overlayY: \\'top\\' })\\n            .withFallbackPosition({ originX: \\'end\\', originY: \\'top\\' }, { overlayX: \\'end\\', overlayY: \\'bottom\\' });\\n    };\\n    return MdDatepicker;\\n}());\\nMdDatepicker.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-datepicker, mat-datepicker\\',\\n                template: \\'\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepicker.ctorParameters = function () { return [\\n    { type: MdDialog, },\\n    { type: Overlay, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n    { type: DateAdapter, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"r\" /* Directionality */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"DOCUMENT\"],] },] },\\n]; };\\nMdDatepicker.propDecorators = {\\n    \\'startAt\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'startView\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'touchUi\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'selectedChanged\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MD_DATEPICKER_VALUE_ACCESSOR = {\\n    provide: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NG_VALUE_ACCESSOR\"],\\n    useExisting: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdDatepickerInput; }),\\n    multi: true\\n};\\nvar MD_DATEPICKER_VALIDATORS = {\\n    provide: __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"NG_VALIDATORS\"],\\n    useExisting: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdDatepickerInput; }),\\n    multi: true\\n};\\n/**\\n * Directive used to connect an input to a MdDatepicker.\\n */\\nvar MdDatepickerInput = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _renderer\\n     * @param {?} _dateAdapter\\n     * @param {?} _dateFormats\\n     * @param {?} _mdInputContainer\\n     */\\n    function MdDatepickerInput(_elementRef, _renderer, _dateAdapter, _dateFormats, _mdInputContainer) {\\n        var _this = this;\\n        this._elementRef = _elementRef;\\n        this._renderer = _renderer;\\n        this._dateAdapter = _dateAdapter;\\n        this._dateFormats = _dateFormats;\\n        this._mdInputContainer = _mdInputContainer;\\n        /**\\n         * Emits when the value changes (either due to user input or programmatic change).\\n         */\\n        this._valueChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        this._onTouched = function () { };\\n        this._cvaOnChange = function () { };\\n        this._validatorOnChange = function () { };\\n        /**\\n         * The form control validator for the min date.\\n         */\\n        this._minValidator = function (control) {\\n            return (!_this.min || !control.value ||\\n                _this._dateAdapter.compareDate(_this.min, control.value) <= 0) ?\\n                null : { \\'mdDatepickerMin\\': { \\'min\\': _this.min, \\'actual\\': control.value } };\\n        };\\n        /**\\n         * The form control validator for the max date.\\n         */\\n        this._maxValidator = function (control) {\\n            return (!_this.max || !control.value ||\\n                _this._dateAdapter.compareDate(_this.max, control.value) >= 0) ?\\n                null : { \\'mdDatepickerMax\\': { \\'max\\': _this.max, \\'actual\\': control.value } };\\n        };\\n        /**\\n         * The form control validator for the date filter.\\n         */\\n        this._filterValidator = function (control) {\\n            return !_this._dateFilter || !control.value || _this._dateFilter(control.value) ?\\n                null : { \\'mdDatepickerFilter\\': true };\\n        };\\n        /**\\n         * The combined form control validator for this input.\\n         */\\n        this._validator = __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"Validators\"].compose([this._minValidator, this._maxValidator, this._filterValidator]);\\n        if (!this._dateAdapter) {\\n            throw createMissingDateImplError(\\'DateAdapter\\');\\n        }\\n        if (!this._dateFormats) {\\n            throw createMissingDateImplError(\\'MD_DATE_FORMATS\\');\\n        }\\n    }\\n    Object.defineProperty(MdDatepickerInput.prototype, \"mdDatepicker\", {\\n        /**\\n         * The datepicker that this input is associated with.\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            if (value) {\\n                this._datepicker = value;\\n                this._datepicker._registerInput(this);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"matDatepicker\", {\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this.mdDatepicker = value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"mdDatepickerFilter\", {\\n        /**\\n         * @param {?} filter\\n         * @return {?}\\n         */\\n        set: function (filter$$1) {\\n            this._dateFilter = filter$$1;\\n            this._validatorOnChange();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"matDatepickerFilter\", {\\n        /**\\n         * @param {?} filter\\n         * @return {?}\\n         */\\n        set: function (filter$$1) {\\n            this.mdDatepickerFilter = filter$$1;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"value\", {\\n        /**\\n         * The value of the input.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._dateAdapter.parse(this._elementRef.nativeElement.value, this._dateFormats.parse.dateInput);\\n        },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            var /** @type {?} */ date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);\\n            var /** @type {?} */ oldDate = this.value;\\n            this._renderer.setProperty(this._elementRef.nativeElement, \\'value\\', date ? this._dateAdapter.format(date, this._dateFormats.display.dateInput) : \\'\\');\\n            if (!this._dateAdapter.sameDate(oldDate, date)) {\\n                this._valueChange.emit(date);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"min\", {\\n        /**\\n         * The minimum valid date.\\n         * @return {?}\\n         */\\n        get: function () { return this._min; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._min = value;\\n            this._validatorOnChange();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdDatepickerInput.prototype, \"max\", {\\n        /**\\n         * The maximum valid date.\\n         * @return {?}\\n         */\\n        get: function () { return this._max; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) {\\n            this._max = value;\\n            this._validatorOnChange();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        if (this._datepicker) {\\n            this._datepickerSubscription =\\n                this._datepicker.selectedChanged.subscribe(function (selected) {\\n                    _this.value = selected;\\n                    _this._cvaOnChange(selected);\\n                });\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.ngOnDestroy = function () {\\n        if (this._datepickerSubscription) {\\n            this._datepickerSubscription.unsubscribe();\\n        }\\n    };\\n    /**\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.registerOnValidatorChange = function (fn) {\\n        this._validatorOnChange = fn;\\n    };\\n    /**\\n     * @param {?} c\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.validate = function (c) {\\n        return this._validator ? this._validator(c) : null;\\n    };\\n    /**\\n     * Gets the element that the datepicker popup should be connected to.\\n     * @return {?} The element to connect the popup to.\\n     */\\n    MdDatepickerInput.prototype.getPopupConnectionElementRef = function () {\\n        return this._mdInputContainer ? this._mdInputContainer.underlineRef : this._elementRef;\\n    };\\n    /**\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.writeValue = function (value) {\\n        this.value = value;\\n    };\\n    /**\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.registerOnChange = function (fn) {\\n        this._cvaOnChange = fn;\\n    };\\n    /**\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.registerOnTouched = function (fn) {\\n        this._onTouched = fn;\\n    };\\n    /**\\n     * @param {?} disabled\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype.setDisabledState = function (disabled) {\\n        this._renderer.setProperty(this._elementRef.nativeElement, \\'disabled\\', disabled);\\n    };\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype._onKeydown = function (event) {\\n        if (event.altKey && event.keyCode === __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"p\" /* DOWN_ARROW */]) {\\n            this._datepicker.open();\\n            event.preventDefault();\\n        }\\n    };\\n    /**\\n     * @param {?} value\\n     * @return {?}\\n     */\\n    MdDatepickerInput.prototype._onInput = function (value) {\\n        var /** @type {?} */ date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);\\n        this._cvaOnChange(date);\\n        this._valueChange.emit(date);\\n    };\\n    return MdDatepickerInput;\\n}());\\nMdDatepickerInput.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'input[mdDatepicker], input[matDatepicker]\\',\\n                providers: [MD_DATEPICKER_VALUE_ACCESSOR, MD_DATEPICKER_VALIDATORS],\\n                host: {\\n                    \\'[attr.aria-expanded]\\': \\'_datepicker?.opened || \"false\"\\',\\n                    \\'[attr.aria-haspopup]\\': \\'true\\',\\n                    \\'[attr.aria-owns]\\': \\'_datepicker?.id\\',\\n                    \\'[attr.min]\\': \\'min ? _dateAdapter.getISODateString(min) : null\\',\\n                    \\'[attr.max]\\': \\'max ? _dateAdapter.getISODateString(max) : null\\',\\n                    \\'(input)\\': \\'_onInput($event.target.value)\\',\\n                    \\'(blur)\\': \\'_onTouched()\\',\\n                    \\'(keydown)\\': \\'_onKeydown($event)\\',\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepickerInput.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: DateAdapter, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [MD_DATE_FORMATS,] },] },\\n    { type: MdInputContainer, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdDatepickerInput.propDecorators = {\\n    \\'mdDatepicker\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'matDatepicker\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'mdDatepickerFilter\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'matDatepickerFilter\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'value\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'min\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'max\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdDatepickerToggle = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _intl\\n     */\\n    function MdDatepickerToggle(_intl) {\\n        this._intl = _intl;\\n    }\\n    Object.defineProperty(MdDatepickerToggle.prototype, \"_datepicker\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.datepicker; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.datepicker = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdDatepickerToggle.prototype._open = function (event) {\\n        if (this.datepicker) {\\n            this.datepicker.open();\\n            event.stopPropagation();\\n        }\\n    };\\n    return MdDatepickerToggle;\\n}());\\nMdDatepickerToggle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'button[mdDatepickerToggle], button[matDatepickerToggle]\\',\\n                template: \\'\\',\\n                styles: [\".mat-datepicker-toggle{display:inline-block;background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iY3VycmVudENvbG9yIj48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE5IDNoLTFWMWgtMnYySDhWMUg2djJINWMtMS4xMSAwLTEuOTkuOS0xLjk5IDJMMyAxOWMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDVWOGgxNHYxMXpNNyAxMGg1djVIN3oiLz48L3N2Zz4=) no-repeat;background-size:contain;height:24px;width:24px;border:none;outline:0;vertical-align:middle}.mat-datepicker-toggle:not([disabled]){cursor:pointer}\"],\\n                host: {\\n                    \\'type\\': \\'button\\',\\n                    \\'class\\': \\'mat-datepicker-toggle\\',\\n                    \\'[attr.aria-label]\\': \\'_intl.openCalendarLabel\\',\\n                    \\'(click)\\': \\'_open($event)\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepickerToggle.ctorParameters = function () { return [\\n    { type: MdDatepickerIntl, },\\n]; };\\nMdDatepickerToggle.propDecorators = {\\n    \\'datepicker\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdDatepickerToggle\\',] },],\\n    \\'_datepicker\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'matDatepickerToggle\\',] },],\\n};\\nvar MdDatepickerModule = /*@__PURE__*/(function () {\\n    function MdDatepickerModule() {\\n    }\\n    return MdDatepickerModule;\\n}());\\nMdDatepickerModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"],\\n                    MdButtonModule,\\n                    MdDialogModule,\\n                    OverlayModule,\\n                    StyleModule,\\n                    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"a\" /* A11yModule */],\\n                ],\\n                exports: [\\n                    MdDatepicker,\\n                    MdDatepickerContent,\\n                    MdDatepickerInput,\\n                    MdDatepickerToggle,\\n                ],\\n                declarations: [\\n                    MdCalendar,\\n                    MdCalendarBody,\\n                    MdDatepicker,\\n                    MdDatepickerContent,\\n                    MdDatepickerInput,\\n                    MdDatepickerToggle,\\n                    MdMonthView,\\n                    MdYearView,\\n                ],\\n                providers: [\\n                    MdDatepickerIntl,\\n                ],\\n                entryComponents: [\\n                    MdDatepickerContent,\\n                ]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdDatepickerModule.ctorParameters = function () { return []; };\\n/**\\n * Unique ID counter\\n */\\nvar nextId$3 = 0;\\n/**\\n * Directive whose purpose is to manage the expanded state of CdkAccordionItem children.\\n */\\nvar CdkAccordion = /*@__PURE__*/(function () {\\n    function CdkAccordion() {\\n        /**\\n         * A readonly id value to use for unique selection coordination.\\n         */\\n        this.id = \"cdk-accordion-\" + nextId$3++;\\n        this._multi = false;\\n        this._hideToggle = false;\\n        /**\\n         * The display mode used for all expansion panels in the accordion. Currently two display\\n         * modes exist:\\n         *   default - a gutter-like spacing is placed around any expanded panel, placing the expanded\\n         *     panel at a different elevation from the reset of the accordion.\\n         *  flat - no spacing is placed around expanded panels, showing all panels at the same\\n         *     elevation.\\n         */\\n        this.displayMode = \\'default\\';\\n    }\\n    Object.defineProperty(CdkAccordion.prototype, \"multi\", {\\n        /**\\n         * Whether the accordion should allow multiple expanded accordion items simulateously.\\n         * @return {?}\\n         */\\n        get: function () { return this._multi; },\\n        /**\\n         * @param {?} multi\\n         * @return {?}\\n         */\\n        set: function (multi) { this._multi = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](multi); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(CdkAccordion.prototype, \"hideToggle\", {\\n        /**\\n         * Whether the expansion indicator should be hidden.\\n         * @return {?}\\n         */\\n        get: function () { return this._hideToggle; },\\n        /**\\n         * @param {?} show\\n         * @return {?}\\n         */\\n        set: function (show) { this._hideToggle = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](show); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return CdkAccordion;\\n}());\\nCdkAccordion.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdk-accordion]\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkAccordion.ctorParameters = function () { return []; };\\nCdkAccordion.propDecorators = {\\n    \\'multi\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'hideToggle\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'displayMode\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Directive for a Material Design Accordion.\\n */\\nvar MdAccordion = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdAccordion, _super);\\n    function MdAccordion() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    return MdAccordion;\\n}(CdkAccordion));\\nMdAccordion.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'mat-accordion, md-accordion\\',\\n                host: {\\n                    class: \\'mat-accordion\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdAccordion.ctorParameters = function () { return []; };\\n/**\\n * Used to generate unique ID for each expansion panel.\\n */\\nvar nextId$4 = 0;\\n/**\\n * An abstract class to be extended and decorated as a component.  Sets up all\\n * events and attributes needed to be managed by a CdkAccordion parent.\\n */\\nvar AccordionItem = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} accordion\\n     * @param {?} _expansionDispatcher\\n     */\\n    function AccordionItem(accordion, _expansionDispatcher) {\\n        var _this = this;\\n        this.accordion = accordion;\\n        this._expansionDispatcher = _expansionDispatcher;\\n        /**\\n         * Event emitted every time the MdAccordianChild is closed.\\n         */\\n        this.closed = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted every time the MdAccordianChild is opened.\\n         */\\n        this.opened = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Event emitted when the MdAccordianChild is destroyed.\\n         */\\n        this.destroyed = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * The unique MdAccordianChild id.\\n         */\\n        this.id = \"cdk-accordion-child-\" + nextId$4++;\\n        /**\\n         * Unregister function for _expansionDispatcher *\\n         */\\n        this._removeUniqueSelectionListener = function () { };\\n        this._removeUniqueSelectionListener =\\n            _expansionDispatcher.listen(function (id, accordionId) {\\n                if (_this.accordion && !_this.accordion.multi &&\\n                    _this.accordion.id === accordionId && _this.id !== id) {\\n                    _this.expanded = false;\\n                }\\n            });\\n    }\\n    Object.defineProperty(AccordionItem.prototype, \"expanded\", {\\n        /**\\n         * Whether the MdAccordianChild is expanded.\\n         * @return {?}\\n         */\\n        get: function () { return this._expanded; },\\n        /**\\n         * @param {?} expanded\\n         * @return {?}\\n         */\\n        set: function (expanded) {\\n            // Only emit events and update the internal value if the value changes.\\n            if (this._expanded !== expanded) {\\n                this._expanded = expanded;\\n                if (expanded) {\\n                    this.opened.emit();\\n                    /**\\n                     * In the unique selection dispatcher, the id parameter is the id of the CdkAccordonItem,\\n                     * the name value is the id of the accordion.\\n                     */\\n                    var accordionId = this.accordion ? this.accordion.id : this.id;\\n                    this._expansionDispatcher.notify(this.id, accordionId);\\n                }\\n                else {\\n                    this.closed.emit();\\n                }\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Emits an event for the accordion item being destroyed.\\n     * @return {?}\\n     */\\n    AccordionItem.prototype.ngOnDestroy = function () {\\n        this.destroyed.emit();\\n        this._removeUniqueSelectionListener();\\n    };\\n    /**\\n     * Toggles the expanded state of the accordion item.\\n     * @return {?}\\n     */\\n    AccordionItem.prototype.toggle = function () {\\n        this.expanded = !this.expanded;\\n    };\\n    /**\\n     * Sets the expanded state of the accordion item to false.\\n     * @return {?}\\n     */\\n    AccordionItem.prototype.close = function () {\\n        this.expanded = false;\\n    };\\n    /**\\n     * Sets the expanded state of the accordion item to true.\\n     * @return {?}\\n     */\\n    AccordionItem.prototype.open = function () {\\n        this.expanded = true;\\n    };\\n    return AccordionItem;\\n}());\\nAccordionItem.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nAccordionItem.ctorParameters = function () { return [\\n    { type: CdkAccordion, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: UniqueSelectionDispatcher, },\\n]; };\\nAccordionItem.propDecorators = {\\n    \\'closed\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'opened\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'destroyed\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n    \\'expanded\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Time and timing curve for expansion panel animations.\\n */\\nvar EXPANSION_PANEL_ANIMATION_TIMING = \\'225ms cubic-bezier(0.4,0.0,0.2,1)\\';\\n/**\\n * <md-expansion-panel> component.\\n *\\n * This component can be used as a single element to show expandable content, or as one of\\n * multiple children of an element with the CdkAccordion directive attached.\\n *\\n * Please refer to README.md for examples on how to use it.\\n */\\nvar MdExpansionPanel = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdExpansionPanel, _super);\\n    /**\\n     * @param {?} accordion\\n     * @param {?} _uniqueSelectionDispatcher\\n     */\\n    function MdExpansionPanel(accordion, _uniqueSelectionDispatcher) {\\n        var _this = _super.call(this, accordion, _uniqueSelectionDispatcher) || this;\\n        /**\\n         * Whether the toggle indicator should be hidden.\\n         */\\n        _this.hideToggle = false;\\n        _this.accordion = accordion;\\n        return _this;\\n    }\\n    /**\\n     * Whether the expansion indicator should be hidden.\\n     * @return {?}\\n     */\\n    MdExpansionPanel.prototype._getHideToggle = function () {\\n        if (this.accordion) {\\n            return this.accordion.hideToggle;\\n        }\\n        return this.hideToggle;\\n    };\\n    /**\\n     * Gets the panel\\'s display mode.\\n     * @return {?}\\n     */\\n    MdExpansionPanel.prototype._getDisplayMode = function () {\\n        if (!this.expanded) {\\n            return this._getExpandedState();\\n        }\\n        if (this.accordion) {\\n            return this.accordion.displayMode;\\n        }\\n        return this._getExpandedState();\\n    };\\n    /**\\n     * Gets the expanded state string.\\n     * @return {?}\\n     */\\n    MdExpansionPanel.prototype._getExpandedState = function () {\\n        return this.expanded ? \\'expanded\\' : \\'collapsed\\';\\n    };\\n    return MdExpansionPanel;\\n}(AccordionItem));\\nMdExpansionPanel.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ styles: [\".mat-expansion-panel{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);box-sizing:content-box;display:block}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.mat-expansion-panel-content{overflow:hidden}.mat-expansion-panel-body{padding:0 24px 16px}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button{margin-left:8px}\"],\\n                selector: \\'md-expansion-panel, mat-expansion-panel\\',\\n                template: \"<ng-content select=\\\\\"mat-expansion-panel-header, md-expansion-panel-header\\\\\"></ng-content><div [class.mat-expanded]=\\\\\"expanded\\\\\" class=\\\\\"mat-expansion-panel-content\\\\\" [@bodyExpansion]=\\\\\"_getExpandedState()\\\\\" [id]=\\\\\"id\\\\\"><div class=\\\\\"mat-expansion-panel-body\\\\\"><ng-content></ng-content></div><ng-content select=\\\\\"mat-action-row, md-action-row\\\\\"></ng-content></div>\",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'class\\': \\'mat-expansion-panel\\',\\n                    \\'[class.mat-expanded]\\': \\'expanded\\',\\n                    \\'[@displayMode]\\': \\'_getDisplayMode()\\',\\n                },\\n                providers: [\\n                    { provide: AccordionItem, useExisting: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"forwardRef\"](function () { return MdExpansionPanel; }) }\\n                ],\\n                animations: [\\n                    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'bodyExpansion\\', [\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'collapsed\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ height: \\'0px\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'expanded\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ height: \\'*\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'expanded <=> collapsed\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](EXPANSION_PANEL_ANIMATION_TIMING)),\\n                    ]),\\n                    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'displayMode\\', [\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'collapsed\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ margin: \\'0\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'default\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ margin: \\'16px 0\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'flat\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ margin: \\'0\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'flat <=> collapsed, default <=> collapsed, flat <=> default\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](EXPANSION_PANEL_ANIMATION_TIMING)),\\n                    ]),\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdExpansionPanel.ctorParameters = function () { return [\\n    { type: MdAccordion, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Host\"] },] },\\n    { type: UniqueSelectionDispatcher, },\\n]; };\\nMdExpansionPanel.propDecorators = {\\n    \\'hideToggle\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar MdExpansionPanelActionRow = /*@__PURE__*/(function () {\\n    function MdExpansionPanelActionRow() {\\n    }\\n    return MdExpansionPanelActionRow;\\n}());\\nMdExpansionPanelActionRow.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'mat-action-row, md-action-row\\',\\n                host: {\\n                    class: \\'mat-action-row\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdExpansionPanelActionRow.ctorParameters = function () { return []; };\\n/**\\n * <md-expansion-panel-header> component.\\n *\\n * This component corresponds to the header element of an <md-expansion-panel>.\\n *\\n * Please refer to README.md for examples on how to use it.\\n */\\nvar MdExpansionPanelHeader = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} panel\\n     */\\n    function MdExpansionPanelHeader(panel) {\\n        this.panel = panel;\\n    }\\n    /**\\n     * Toggles the expanded state of the panel.\\n     * @return {?}\\n     */\\n    MdExpansionPanelHeader.prototype._toggle = function () {\\n        this.panel.toggle();\\n    };\\n    /**\\n     * Gets whether the panel is expanded.\\n     * @return {?}\\n     */\\n    MdExpansionPanelHeader.prototype._isExpanded = function () {\\n        return this.panel.expanded;\\n    };\\n    /**\\n     * Gets the expanded state string of the panel.\\n     * @return {?}\\n     */\\n    MdExpansionPanelHeader.prototype._getExpandedState = function () {\\n        return this.panel._getExpandedState();\\n    };\\n    /**\\n     * Gets the panel id.\\n     * @return {?}\\n     */\\n    MdExpansionPanelHeader.prototype._getPanelId = function () {\\n        return this.panel.id;\\n    };\\n    /**\\n     * Gets whether the expand indicator is hidden.\\n     * @return {?}\\n     */\\n    MdExpansionPanelHeader.prototype._getHideToggle = function () {\\n        return this.panel.hideToggle;\\n    };\\n    /**\\n     * Handle keyup event calling to toggle() if appropriate.\\n     * @param {?} event\\n     * @return {?}\\n     */\\n    MdExpansionPanelHeader.prototype._keyup = function (event) {\\n        switch (event.keyCode) {\\n            // Toggle for space and enter keys.\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"S\" /* SPACE */]:\\n            case __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"u\" /* ENTER */]:\\n                event.preventDefault();\\n                this._toggle();\\n                break;\\n            default:\\n                return;\\n        }\\n    };\\n    return MdExpansionPanelHeader;\\n}());\\nMdExpansionPanelHeader.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-expansion-panel-header, mat-expansion-panel-header\\',\\n                styles: [\".mat-expansion-panel-header{cursor:pointer;display:flex;flex-direction:row;height:48px;line-height:48px;padding:0 24px}.mat-expansion-panel-header.mat-expanded{height:64px;line-height:64px}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:0}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-title{display:flex;flex-grow:1;font-size:15px;margin-right:16px}.mat-expansion-panel-header-description{display:flex;flex-grow:2;font-size:15px;margin-right:16px}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:\\'\\';display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}\"],\\n                template: \"<span class=\\\\\"mat-content\\\\\"><ng-content select=\\\\\"md-panel-title, mat-panel-title\\\\\"></ng-content><ng-content select=\\\\\"md-panel-description, mat-panel-description\\\\\"></ng-content><ng-content></ng-content></span><span [@indicatorRotate]=\\\\\"_getExpandedState()\\\\\" *ngIf=\\\\\"!_getHideToggle()\\\\\" class=\\\\\"mat-expansion-indicator\\\\\"></span>\",\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                host: {\\n                    \\'class\\': \\'mat-expansion-panel-header\\',\\n                    \\'role\\': \\'button\\',\\n                    \\'tabindex\\': \\'0\\',\\n                    \\'[attr.aria-controls]\\': \\'_getPanelId()\\',\\n                    \\'[attr.aria-expanded]\\': \\'_isExpanded()\\',\\n                    \\'[class.mat-expanded]\\': \\'_isExpanded()\\',\\n                    \\'(click)\\': \\'_toggle()\\',\\n                    \\'(keyup)\\': \\'_keyup($event)\\',\\n                    \\'[@expansionHeight]\\': \\'_getExpandedState()\\',\\n                },\\n                animations: [\\n                    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'indicatorRotate\\', [\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'collapsed\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'rotate(0deg)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'expanded\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ transform: \\'rotate(180deg)\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'expanded <=> collapsed\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](EXPANSION_PANEL_ANIMATION_TIMING)),\\n                    ]),\\n                    __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"trigger\"](\\'expansionHeight\\', [\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'collapsed\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ height: \\'48px\\', \\'line-height\\': \\'48px\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"state\"](\\'expanded\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"style\"]({ height: \\'64px\\', \\'line-height\\': \\'68px\\' })),\\n                        __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"transition\"](\\'expanded <=> collapsed\\', __WEBPACK_IMPORTED_MODULE_11__angular_animations__[\"animate\"](EXPANSION_PANEL_ANIMATION_TIMING)),\\n                    ]),\\n                ],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdExpansionPanelHeader.ctorParameters = function () { return [\\n    { type: MdExpansionPanel, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Host\"] },] },\\n]; };\\n/**\\n * <md-panel-description> directive.\\n *\\n * This direction is to be used inside of the MdExpansionPanelHeader component.\\n */\\nvar MdExpansionPanelDescription = /*@__PURE__*/(function () {\\n    function MdExpansionPanelDescription() {\\n    }\\n    return MdExpansionPanelDescription;\\n}());\\nMdExpansionPanelDescription.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-panel-description, mat-panel-description\\',\\n                host: {\\n                    class: \\'mat-expansion-panel-header-description\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdExpansionPanelDescription.ctorParameters = function () { return []; };\\n/**\\n * <md-panel-title> directive.\\n *\\n * This direction is to be used inside of the MdExpansionPanelHeader component.\\n */\\nvar MdExpansionPanelTitle = /*@__PURE__*/(function () {\\n    function MdExpansionPanelTitle() {\\n    }\\n    return MdExpansionPanelTitle;\\n}());\\nMdExpansionPanelTitle.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-panel-title, mat-panel-title\\',\\n                host: {\\n                    class: \\'mat-expansion-panel-header-title\\'\\n                }\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdExpansionPanelTitle.ctorParameters = function () { return []; };\\nvar MdExpansionModule = /*@__PURE__*/(function () {\\n    function MdExpansionModule() {\\n    }\\n    return MdExpansionModule;\\n}());\\nMdExpansionModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [CompatibilityModule, __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"]],\\n                exports: [\\n                    CdkAccordion,\\n                    MdAccordion,\\n                    MdExpansionPanel,\\n                    MdExpansionPanelActionRow,\\n                    MdExpansionPanelHeader,\\n                    MdExpansionPanelTitle,\\n                    MdExpansionPanelDescription\\n                ],\\n                declarations: [\\n                    CdkAccordion,\\n                    MdAccordion,\\n                    MdExpansionPanel,\\n                    MdExpansionPanelActionRow,\\n                    MdExpansionPanelHeader,\\n                    MdExpansionPanelTitle,\\n                    MdExpansionPanelDescription\\n                ],\\n                providers: [UNIQUE_SELECTION_DISPATCHER_PROVIDER]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdExpansionModule.ctorParameters = function () { return []; };\\n/**\\n * Workaround for https://github.com/angular/angular/issues/17849\\n */\\nvar _MdTable = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"l\" /* CdkTable */];\\n/**\\n * Wrapper for the CdkTable with Material design styles.\\n */\\nvar MdTable = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdTable, _super);\\n    function MdTable() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    return MdTable;\\n}(_MdTable));\\nMdTable.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-table, mat-table\\',\\n                template: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"f\" /* CDK_TABLE_TEMPLATE */],\\n                styles: [\".mat-table{display:block}.mat-header-row,.mat-row{display:flex;border-bottom-width:1px;border-bottom-style:solid;align-items:center;height:48px;padding:0 24px}.mat-cell,.mat-header-cell{flex:1}\"],\\n                host: {\\n                    \\'class\\': \\'mat-table\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTable.ctorParameters = function () { return []; };\\n/**\\n * Workaround for https://github.com/angular/angular/issues/17849\\n */\\nvar _MdHeaderCellBase = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"i\" /* CdkHeaderCell */];\\nvar _MdCell = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"g\" /* CdkCell */];\\n/**\\n * Header cell template container that adds the right classes and role.\\n */\\nvar MdHeaderCell = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdHeaderCell, _super);\\n    /**\\n     * @param {?} columnDef\\n     * @param {?} elementRef\\n     * @param {?} renderer\\n     */\\n    function MdHeaderCell(columnDef, elementRef, renderer) {\\n        var _this = _super.call(this, columnDef, elementRef, renderer) || this;\\n        renderer.addClass(elementRef.nativeElement, \"mat-column-\" + columnDef.name);\\n        return _this;\\n    }\\n    return MdHeaderCell;\\n}(_MdHeaderCellBase));\\nMdHeaderCell.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-header-cell, mat-header-cell\\',\\n                host: {\\n                    \\'class\\': \\'mat-header-cell\\',\\n                    \\'role\\': \\'columnheader\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdHeaderCell.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"h\" /* CdkColumnDef */], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\n/**\\n * Cell template container that adds the right classes and role.\\n */\\nvar MdCell = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdCell, _super);\\n    /**\\n     * @param {?} columnDef\\n     * @param {?} elementRef\\n     * @param {?} renderer\\n     */\\n    function MdCell(columnDef, elementRef, renderer) {\\n        var _this = _super.call(this, columnDef, elementRef, renderer) || this;\\n        renderer.addClass(elementRef.nativeElement, \"mat-column-\" + columnDef.name);\\n        return _this;\\n    }\\n    return MdCell;\\n}(_MdCell));\\nMdCell.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'md-cell, mat-cell\\',\\n                host: {\\n                    \\'class\\': \\'mat-cell\\',\\n                    \\'role\\': \\'gridcell\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdCell.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"h\" /* CdkColumnDef */], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\n/**\\n * Workaround for https://github.com/angular/angular/issues/17849\\n */\\nvar _MdHeaderRow = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"j\" /* CdkHeaderRow */];\\nvar _MdRow = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"k\" /* CdkRow */];\\n/**\\n * Header template container that contains the cell outlet. Adds the right class and role.\\n */\\nvar MdHeaderRow = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdHeaderRow, _super);\\n    function MdHeaderRow() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    return MdHeaderRow;\\n}(_MdHeaderRow));\\nMdHeaderRow.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{\\n                selector: \\'md-header-row, mat-header-row\\',\\n                template: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"e\" /* CDK_ROW_TEMPLATE */],\\n                host: {\\n                    \\'class\\': \\'mat-header-row\\',\\n                    \\'role\\': \\'row\\',\\n                },\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdHeaderRow.ctorParameters = function () { return []; };\\n/**\\n * Data row template container that contains the cell outlet. Adds the right class and role.\\n */\\nvar MdRow = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](MdRow, _super);\\n    function MdRow() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    return MdRow;\\n}(_MdRow));\\nMdRow.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{\\n                selector: \\'md-row, mat-row\\',\\n                template: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"e\" /* CDK_ROW_TEMPLATE */],\\n                host: {\\n                    \\'class\\': \\'mat-row\\',\\n                    \\'role\\': \\'row\\',\\n                },\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdRow.ctorParameters = function () { return []; };\\nvar MdTableModule = /*@__PURE__*/(function () {\\n    function MdTableModule() {\\n    }\\n    return MdTableModule;\\n}());\\nMdTableModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"m\" /* CdkTableModule */], __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"], MdCommonModule],\\n                exports: [MdTable, MdHeaderCell, MdCell, MdHeaderRow, MdRow],\\n                declarations: [MdTable, MdHeaderCell, MdCell, MdHeaderRow, MdRow],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdTableModule.ctorParameters = function () { return []; };\\n/**\\n * \\\\@docs-private\\n * @param {?} id\\n * @return {?}\\n */\\nfunction getMdSortDuplicateMdSortableIdError(id) {\\n    return Error(\"Cannot have two MdSortables with the same id (\" + id + \").\");\\n}\\n/**\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdSortHeaderNotContainedWithinMdSortError() {\\n    return Error(\"MdSortHeader must be placed within a parent element with the MdSort directive.\");\\n}\\n/**\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction getMdSortHeaderMissingIdError() {\\n    return Error(\"MdSortHeader must be provided with a unique id.\");\\n}\\n/**\\n * Container for MdSortables to manage the sort state and provide default sort parameters.\\n */\\nvar MdSort = /*@__PURE__*/(function () {\\n    function MdSort() {\\n        /**\\n         * Collection of all registered sortables that this directive manages.\\n         */\\n        this.sortables = new Map();\\n        /**\\n         * The direction to set when an MdSortable is initially sorted.\\n         * May be overriden by the MdSortable\\'s sort start.\\n         */\\n        this.start = \\'asc\\';\\n        /**\\n         * The sort direction of the currently active MdSortable.\\n         */\\n        this.direction = \\'\\';\\n        /**\\n         * Event emitted when the user changes either the active sort or sort direction.\\n         */\\n        this.mdSortChange = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(MdSort.prototype, \"disableClear\", {\\n        /**\\n         * Whether to disable the user from clearing the sort by finishing the sort direction cycle.\\n         * May be overriden by the MdSortable\\'s disable clear input.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableClear; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this._disableClear = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](v); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Register function to be used by the contained MdSortables. Adds the MdSortable to the\\n     * collection of MdSortables.\\n     * @param {?} sortable\\n     * @return {?}\\n     */\\n    MdSort.prototype.register = function (sortable) {\\n        if (!sortable.id) {\\n            throw getMdSortHeaderMissingIdError();\\n        }\\n        if (this.sortables.has(sortable.id)) {\\n            throw getMdSortDuplicateMdSortableIdError(sortable.id);\\n        }\\n        this.sortables.set(sortable.id, sortable);\\n    };\\n    /**\\n     * Unregister function to be used by the contained MdSortables. Removes the MdSortable from the\\n     * collection of contained MdSortables.\\n     * @param {?} sortable\\n     * @return {?}\\n     */\\n    MdSort.prototype.deregister = function (sortable) {\\n        this.sortables.delete(sortable.id);\\n    };\\n    /**\\n     * Sets the active sort id and determines the new sort direction.\\n     * @param {?} sortable\\n     * @return {?}\\n     */\\n    MdSort.prototype.sort = function (sortable) {\\n        if (this.active != sortable.id) {\\n            this.active = sortable.id;\\n            this.direction = sortable.start ? sortable.start : this.start;\\n        }\\n        else {\\n            this.direction = this.getNextSortDirection(sortable);\\n        }\\n        this.mdSortChange.next({ active: this.active, direction: this.direction });\\n    };\\n    /**\\n     * Returns the next sort direction of the active sortable, checking for potential overrides.\\n     * @param {?} sortable\\n     * @return {?}\\n     */\\n    MdSort.prototype.getNextSortDirection = function (sortable) {\\n        if (!sortable) {\\n            return \\'\\';\\n        }\\n        // Get the sort direction cycle with the potential sortable overrides.\\n        var /** @type {?} */ disableClear = sortable.disableClear != null ? sortable.disableClear : this.disableClear;\\n        var /** @type {?} */ sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);\\n        // Get and return the next direction in the cycle\\n        var /** @type {?} */ nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;\\n        if (nextDirectionIndex >= sortDirectionCycle.length) {\\n            nextDirectionIndex = 0;\\n        }\\n        return sortDirectionCycle[nextDirectionIndex];\\n    };\\n    return MdSort;\\n}());\\nMdSort.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[mdSort], [matSort]\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSort.ctorParameters = function () { return []; };\\nMdSort.propDecorators = {\\n    \\'active\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdSortActive\\',] },],\\n    \\'start\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdSortStart\\',] },],\\n    \\'direction\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdSortDirection\\',] },],\\n    \\'disableClear\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mdSortDisableClear\\',] },],\\n    \\'mdSortChange\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\n/**\\n * Returns the sort direction cycle to use given the provided parameters of order and clear.\\n * @param {?} start\\n * @param {?} disableClear\\n * @return {?}\\n */\\nfunction getSortDirectionCycle(start, disableClear) {\\n    var /** @type {?} */ sortOrder = [\\'asc\\', \\'desc\\'];\\n    if (start == \\'desc\\') {\\n        sortOrder.reverse();\\n    }\\n    if (!disableClear) {\\n        sortOrder.push(\\'\\');\\n    }\\n    return sortOrder;\\n}\\n/**\\n * To modify the labels and text displayed, create a new instance of MdSortHeaderIntl and\\n * include it in a custom provider.\\n */\\nvar MdSortHeaderIntl = /*@__PURE__*/(function () {\\n    function MdSortHeaderIntl() {\\n        this.sortButtonLabel = function (id) {\\n            return \"Change sorting for \" + id;\\n        };\\n        /**\\n         * A label to describe the current sort (visible only to screenreaders).\\n         */\\n        this.sortDescriptionLabel = function (id, direction) {\\n            return \"Sorted by \" + id + \" \" + (direction == \\'asc\\' ? \\'ascending\\' : \\'descending\\');\\n        };\\n    }\\n    return MdSortHeaderIntl;\\n}());\\nMdSortHeaderIntl.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSortHeaderIntl.ctorParameters = function () { return []; };\\n/**\\n * Applies sorting behavior (click to change sort) and styles to an element, including an\\n * arrow to display the current sort direction.\\n *\\n * Must be provided with an id and contained within a parent MdSort directive.\\n *\\n * If used on header cells in a CdkTable, it will automatically default its id from its containing\\n * column definition.\\n */\\nvar MdSortHeader = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _intl\\n     * @param {?} _changeDetectorRef\\n     * @param {?} _sort\\n     * @param {?} _cdkColumnDef\\n     */\\n    function MdSortHeader(_intl, _changeDetectorRef, _sort, _cdkColumnDef) {\\n        this._intl = _intl;\\n        this._changeDetectorRef = _changeDetectorRef;\\n        this._sort = _sort;\\n        this._cdkColumnDef = _cdkColumnDef;\\n        /**\\n         * Sets the position of the arrow that displays when sorted.\\n         */\\n        this.arrowPosition = \\'after\\';\\n        if (!_sort) {\\n            throw getMdSortHeaderNotContainedWithinMdSortError();\\n        }\\n        this.sortSubscription = _sort.mdSortChange.subscribe(function () { return _changeDetectorRef.markForCheck(); });\\n    }\\n    Object.defineProperty(MdSortHeader.prototype, \"disableClear\", {\\n        /**\\n         * Overrides the disable clear value of the containing MdSort for this MdSortable.\\n         * @return {?}\\n         */\\n        get: function () { return this._disableClear; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this._disableClear = __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"Z\" /* coerceBooleanProperty */](v); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdSortHeader.prototype, \"_id\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this.id; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.id = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdSortHeader.prototype.ngOnInit = function () {\\n        if (!this.id && this._cdkColumnDef) {\\n            this.id = this._cdkColumnDef.name;\\n        }\\n        this._sort.register(this);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    MdSortHeader.prototype.ngOnDestroy = function () {\\n        this._sort.deregister(this);\\n        this.sortSubscription.unsubscribe();\\n    };\\n    /**\\n     * Whether this MdSortHeader is currently sorted in either ascending or descending order.\\n     * @return {?}\\n     */\\n    MdSortHeader.prototype._isSorted = function () {\\n        return this._sort.active == this.id && this._sort.direction;\\n    };\\n    return MdSortHeader;\\n}());\\nMdSortHeader.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'[md-sort-header], [mat-sort-header]\\',\\n                template: \"<div class=\\\\\"mat-sort-header-container\\\\\" [class.mat-sort-header-position-before]=\\\\\"arrowPosition == \\'before\\'\\\\\"><button class=\\\\\"mat-sort-header-button\\\\\" type=\\\\\"button\\\\\" [attr.aria-label]=\\\\\"_intl.sortButtonLabel(id)\\\\\"><ng-content></ng-content></button><div *ngIf=\\\\\"_isSorted()\\\\\" class=\\\\\"mat-sort-header-arrow\\\\\" [class.mat-sort-header-asc]=\\\\\"_sort.direction == \\'asc\\'\\\\\" [class.mat-sort-header-desc]=\\\\\"_sort.direction == \\'desc\\'\\\\\"><div class=\\\\\"mat-sort-header-stem\\\\\"></div><div class=\\\\\"mat-sort-header-pointer-left\\\\\"></div><div class=\\\\\"mat-sort-header-pointer-right\\\\\"></div></div></div><span class=\\\\\"cdk-visually-hidden\\\\\" *ngIf=\\\\\"_isSorted()\\\\\">{{_intl.sortDescriptionLabel(id, _sort.direction)}}</span>\",\\n                styles: [\".mat-sort-header-container{display:flex;cursor:pointer}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-button{border:none;background:0 0;display:flex;align-items:center;padding:0;cursor:pointer;outline:0;font:inherit;color:currentColor}.mat-sort-header-arrow{display:none;height:10px;width:10px;position:relative;margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-asc{display:block;transform:rotate(45deg)}.mat-sort-header-desc{display:block;transform:rotate(225deg);top:2px}.mat-sort-header-stem{background:currentColor;transform:rotate(135deg);height:10px;width:2px;margin:auto}.mat-sort-header-pointer-left{background:currentColor;width:2px;height:8px;position:absolute;bottom:0;right:0}.mat-sort-header-pointer-right{background:currentColor;width:8px;height:2px;position:absolute;bottom:0;right:0}\"],\\n                host: {\\n                    \\'(click)\\': \\'_sort.sort(this)\\',\\n                    \\'[class.mat-sort-header-sorted]\\': \\'_isSorted()\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSortHeader.ctorParameters = function () { return [\\n    { type: MdSortHeaderIntl, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: MdSort, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n    { type: __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"h\" /* CdkColumnDef */], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] },] },\\n]; };\\nMdSortHeader.propDecorators = {\\n    \\'id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'md-sort-header\\',] },],\\n    \\'arrowPosition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'start\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'start\\',] },],\\n    \\'disableClear\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_id\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'mat-sort-header\\',] },],\\n};\\nvar MdSortModule = /*@__PURE__*/(function () {\\n    function MdSortModule() {\\n    }\\n    return MdSortModule;\\n}());\\nMdSortModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"]],\\n                exports: [MdSort, MdSortHeader],\\n                declarations: [MdSort, MdSortHeader],\\n                providers: [MdSortHeaderIntl]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdSortModule.ctorParameters = function () { return []; };\\n/**\\n * To modify the labels and text displayed, create a new instance of MdPaginatorIntl and\\n * include it in a custom provider\\n */\\nvar MdPaginatorIntl = /*@__PURE__*/(function () {\\n    function MdPaginatorIntl() {\\n        /**\\n         * A label for the page size selector.\\n         */\\n        this.itemsPerPageLabel = \\'Items per page:\\';\\n        /**\\n         * A label for the button that increments the current page.\\n         */\\n        this.nextPageLabel = \\'Next page\\';\\n        /**\\n         * A label for the button that decrements the current page.\\n         */\\n        this.previousPageLabel = \\'Previous page\\';\\n        /**\\n         * A label for the range of items within the current page and the length of the whole list.\\n         */\\n        this.getRangeLabel = function (page, pageSize, length) {\\n            if (length == 0 || pageSize == 0) {\\n                return \"0 of \" + length;\\n            }\\n            length = Math.max(length, 0);\\n            var startIndex = page * pageSize;\\n            // If the start index exceeds the list length, do not try and fix the end index to the end.\\n            var endIndex = startIndex < length ?\\n                Math.min(startIndex + pageSize, length) :\\n                startIndex + pageSize;\\n            return startIndex + 1 + \" - \" + endIndex + \" of \" + length;\\n        };\\n    }\\n    return MdPaginatorIntl;\\n}());\\nMdPaginatorIntl.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPaginatorIntl.ctorParameters = function () { return []; };\\n/**\\n * Change event object that is emitted when the user selects a\\n * different page size or navigates to another page.\\n */\\nvar PageEvent = /*@__PURE__*/(function () {\\n    function PageEvent() {\\n    }\\n    return PageEvent;\\n}());\\n/**\\n * Component to provide navigation between paged information. Displays the size of the current\\n * page, user-selectable options to change that size, what items are being shown, and\\n * navigational button to go to the previous or next page.\\n */\\nvar MdPaginator = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _intl\\n     */\\n    function MdPaginator(_intl) {\\n        this._intl = _intl;\\n        /**\\n         * The zero-based page index of the displayed list of items. Defaulted to 0.\\n         */\\n        this.pageIndex = 0;\\n        /**\\n         * The length of the total number of items that are being paginated. Defaulted to 0.\\n         */\\n        this.length = 0;\\n        this._pageSize = 50;\\n        this._pageSizeOptions = [];\\n        /**\\n         * Event emitted when the paginator changes the page size or page index.\\n         */\\n        this.page = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(MdPaginator.prototype, \"pageSize\", {\\n        /**\\n         * Number of items to display on a page. By default set to 50.\\n         * @return {?}\\n         */\\n        get: function () { return this._pageSize; },\\n        /**\\n         * @param {?} pageSize\\n         * @return {?}\\n         */\\n        set: function (pageSize) {\\n            this._pageSize = pageSize;\\n            this._updateDisplayedPageSizeOptions();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(MdPaginator.prototype, \"pageSizeOptions\", {\\n        /**\\n         * The set of provided page size options to display to the user.\\n         * @return {?}\\n         */\\n        get: function () { return this._pageSizeOptions; },\\n        /**\\n         * @param {?} pageSizeOptions\\n         * @return {?}\\n         */\\n        set: function (pageSizeOptions) {\\n            this._pageSizeOptions = pageSizeOptions;\\n            this._updateDisplayedPageSizeOptions();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    MdPaginator.prototype.ngOnInit = function () {\\n        this._initialized = true;\\n        this._updateDisplayedPageSizeOptions();\\n    };\\n    /**\\n     * Advances to the next page if it exists.\\n     * @return {?}\\n     */\\n    MdPaginator.prototype.nextPage = function () {\\n        if (!this.hasNextPage()) {\\n            return;\\n        }\\n        this.pageIndex++;\\n        this._emitPageEvent();\\n    };\\n    /**\\n     * Move back to the previous page if it exists.\\n     * @return {?}\\n     */\\n    MdPaginator.prototype.previousPage = function () {\\n        if (!this.hasPreviousPage()) {\\n            return;\\n        }\\n        this.pageIndex--;\\n        this._emitPageEvent();\\n    };\\n    /**\\n     * Whether there is a previous page.\\n     * @return {?}\\n     */\\n    MdPaginator.prototype.hasPreviousPage = function () {\\n        return this.pageIndex >= 1 && this.pageSize != 0;\\n    };\\n    /**\\n     * Whether there is a next page.\\n     * @return {?}\\n     */\\n    MdPaginator.prototype.hasNextPage = function () {\\n        var /** @type {?} */ numberOfPages = Math.ceil(this.length / this.pageSize) - 1;\\n        return this.pageIndex < numberOfPages && this.pageSize != 0;\\n    };\\n    /**\\n     * Changes the page size so that the first item displayed on the page will still be\\n     * displayed using the new page size.\\n     *\\n     * For example, if the page size is 10 and on the second page (items indexed 10-19) then\\n     * switching so that the page size is 5 will set the third page as the current page so\\n     * that the 10th item will still be displayed.\\n     * @param {?} pageSize\\n     * @return {?}\\n     */\\n    MdPaginator.prototype._changePageSize = function (pageSize) {\\n        // Current page needs to be updated to reflect the new page size. Navigate to the page\\n        // containing the previous page\\'s first item.\\n        var /** @type {?} */ startIndex = this.pageIndex * this.pageSize;\\n        this.pageIndex = Math.floor(startIndex / pageSize) || 0;\\n        this.pageSize = pageSize;\\n        this._emitPageEvent();\\n    };\\n    /**\\n     * Updates the list of page size options to display to the user. Includes making sure that\\n     * the page size is an option and that the list is sorted.\\n     * @return {?}\\n     */\\n    MdPaginator.prototype._updateDisplayedPageSizeOptions = function () {\\n        if (!this._initialized) {\\n            return;\\n        }\\n        this._displayedPageSizeOptions = this.pageSizeOptions.slice();\\n        if (this._displayedPageSizeOptions.indexOf(this.pageSize) == -1) {\\n            this._displayedPageSizeOptions.push(this.pageSize);\\n        }\\n        // Sort the numbers using a number-specific sort function.\\n        this._displayedPageSizeOptions.sort(function (a, b) { return a - b; });\\n    };\\n    /**\\n     * Emits an event notifying that a change of the paginator\\'s properties has been triggered.\\n     * @return {?}\\n     */\\n    MdPaginator.prototype._emitPageEvent = function () {\\n        this.page.next({\\n            pageIndex: this.pageIndex,\\n            pageSize: this.pageSize,\\n            length: this.length\\n        });\\n    };\\n    return MdPaginator;\\n}());\\nMdPaginator.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{ selector: \\'md-paginator, mat-paginator\\',\\n                template: \"<div class=\\\\\"mat-paginator-page-size\\\\\"><div class=\\\\\"mat-paginator-page-size-label\\\\\">{{_intl.itemsPerPageLabel}}</div><md-select *ngIf=\\\\\"_displayedPageSizeOptions.length > 1\\\\\" class=\\\\\"mat-paginator-page-size-select\\\\\" [ngModel]=\\\\\"pageSize\\\\\" [aria-label]=\\\\\"_intl.itemsPerPageLabel\\\\\" (change)=\\\\\"_changePageSize($event.value)\\\\\"><md-option *ngFor=\\\\\"let pageSizeOption of _displayedPageSizeOptions\\\\\" [value]=\\\\\"pageSizeOption\\\\\">{{pageSizeOption}}</md-option></md-select><div *ngIf=\\\\\"_displayedPageSizeOptions.length <= 1\\\\\">{{pageSize}}</div></div><div class=\\\\\"mat-paginator-range-label\\\\\">{{_intl.getRangeLabel(pageIndex, pageSize, length)}}</div><button md-icon-button class=\\\\\"mat-paginator-navigation-previous\\\\\" (click)=\\\\\"previousPage()\\\\\" [attr.aria-label]=\\\\\"_intl.previousPageLabel\\\\\" [mdTooltip]=\\\\\"_intl.previousPageLabel\\\\\" [mdTooltipPosition]=\\\\\"\\'above\\'\\\\\" [disabled]=\\\\\"!hasPreviousPage()\\\\\"><div class=\\\\\"mat-paginator-increment\\\\\"></div></button> <button md-icon-button class=\\\\\"mat-paginator-navigation-next\\\\\" (click)=\\\\\"nextPage()\\\\\" [attr.aria-label]=\\\\\"_intl.nextPageLabel\\\\\" [mdTooltip]=\\\\\"_intl.nextPageLabel\\\\\" [mdTooltipPosition]=\\\\\"\\'above\\'\\\\\" [disabled]=\\\\\"!hasNextPage()\\\\\"><div class=\\\\\"mat-paginator-decrement\\\\\"></div></button>\",\\n                styles: [\".mat-paginator{display:flex;align-items:center;justify-content:flex-end;min-height:56px;padding:0 8px}.mat-paginator-page-size{display:flex;align-items:center}.mat-paginator-page-size-label{margin:0 4px}.mat-paginator-page-size-select{margin:0 4px}.mat-paginator-page-size-select .mat-select-trigger{min-width:56px}.mat-paginator-range-label{margin:0 32px}.mat-paginator-increment-button+.mat-paginator-increment-button{margin:0 0 0 8px}[dir=rtl] .mat-paginator-increment-button+.mat-paginator-increment-button{margin:0 8px 0 0}.mat-paginator-decrement,.mat-paginator-increment{width:8px;height:8px}.mat-paginator-decrement,[dir=rtl] .mat-paginator-increment{transform:rotate(45deg)}.mat-paginator-increment,[dir=rtl] .mat-paginator-decrement{transform:rotate(225deg)}.mat-paginator-decrement{margin-left:12px}[dir=rtl] .mat-paginator-decrement{margin-right:12px}.mat-paginator-increment{margin-left:16px}[dir=rtl] .mat-paginator-increment{margin-right:16px}\"],\\n                host: {\\n                    \\'class\\': \\'mat-paginator\\',\\n                },\\n                providers: [\\n                    { provide: MATERIAL_COMPATIBILITY_MODE, useValue: false }\\n                ],\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPaginator.ctorParameters = function () { return [\\n    { type: MdPaginatorIntl, },\\n]; };\\nMdPaginator.propDecorators = {\\n    \\'pageIndex\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'length\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'pageSize\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'pageSizeOptions\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'page\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"] },],\\n};\\nvar MdPaginatorModule = /*@__PURE__*/(function () {\\n    function MdPaginatorModule() {\\n    }\\n    return MdPaginatorModule;\\n}());\\nMdPaginatorModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [\\n                    __WEBPACK_IMPORTED_MODULE_4__angular_common__[\"CommonModule\"],\\n                    __WEBPACK_IMPORTED_MODULE_10__angular_forms__[\"FormsModule\"],\\n                    MdButtonModule,\\n                    MdSelectModule,\\n                    MdTooltipModule,\\n                ],\\n                exports: [MdPaginator],\\n                declarations: [MdPaginator],\\n                providers: [MdPaginatorIntl],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdPaginatorModule.ctorParameters = function () { return []; };\\nvar MATERIAL_MODULES = [\\n    MdAutocompleteModule,\\n    MdButtonModule,\\n    MdButtonToggleModule,\\n    MdCardModule,\\n    MdChipsModule,\\n    MdCheckboxModule,\\n    MdDatepickerModule,\\n    MdTableModule,\\n    MdDialogModule,\\n    MdExpansionModule,\\n    MdGridListModule,\\n    MdIconModule,\\n    MdInputModule,\\n    MdListModule,\\n    MdMenuModule,\\n    MdPaginatorModule,\\n    MdProgressBarModule,\\n    MdProgressSpinnerModule,\\n    MdRadioModule,\\n    MdRippleModule,\\n    MdSelectModule,\\n    MdSidenavModule,\\n    MdSliderModule,\\n    MdSlideToggleModule,\\n    MdSnackBarModule,\\n    MdSortModule,\\n    MdTabsModule,\\n    MdToolbarModule,\\n    MdTooltipModule,\\n    OverlayModule,\\n    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"P\" /* PortalModule */],\\n    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"d\" /* BidiModule */],\\n    StyleModule,\\n    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"a\" /* A11yModule */],\\n    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"M\" /* PlatformModule */],\\n    MdCommonModule,\\n    __WEBPACK_IMPORTED_MODULE_2__angular_cdk__[\"I\" /* ObserveContentModule */]\\n];\\n/**\\n * @deprecated\\n */\\nvar MaterialModule = /*@__PURE__*/(function () {\\n    function MaterialModule() {\\n    }\\n    return MaterialModule;\\n}());\\nMaterialModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: MATERIAL_MODULES,\\n                exports: MATERIAL_MODULES,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nMaterialModule.ctorParameters = function () { return []; };\\n/**\\n * Generated bundle index. Do not edit.\\n */\\n\\n//# sourceMappingURL=material.es5.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9tYXRlcmlhbC9AYW5ndWxhci9tYXRlcmlhbC5lczUuanM/N2Q4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgQXBwbGljYXRpb25SZWYsIEF0dHJpYnV0ZSwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29udGVudENoaWxkLCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0LCBIb3N0QmluZGluZywgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0b3IsIElucHV0LCBOZ01vZHVsZSwgTmdab25lLCBPcHRpb25hbCwgT3V0cHV0LCBSZW5kZXJlcjIsIFNlY3VyaXR5Q29udGV4dCwgU2VsZiwgU2tpcFNlbGYsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQsIFZpZXdDb250YWluZXJSZWYsIFZpZXdFbmNhcHN1bGF0aW9uLCBmb3J3YXJkUmVmLCBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEExMXlNb2R1bGUsIEJBQ0tTUEFDRSwgQmFzZVBvcnRhbEhvc3QsIEJpZGlNb2R1bGUsIENES19ST1dfVEVNUExBVEUsIENES19UQUJMRV9URU1QTEFURSwgQ2RrQ2VsbCwgQ2RrQ29sdW1uRGVmLCBDZGtIZWFkZXJDZWxsLCBDZGtIZWFkZXJSb3csIENka1JvdywgQ2RrVGFibGUsIENka1RhYmxlTW9kdWxlLCBDb21wb25lbnRQb3J0YWwsIERFTEVURSwgRE9XTl9BUlJPVywgRGlyLCBEaXJlY3Rpb25hbGl0eSwgRG9tUG9ydGFsSG9zdCwgRU5ELCBFTlRFUiwgRVNDQVBFLCBGb2N1c1RyYXAsIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUsIEZvY3VzVHJhcERpcmVjdGl2ZSwgRm9jdXNUcmFwRmFjdG9yeSwgSE9NRSwgSW50ZXJhY3Rpdml0eUNoZWNrZXIsIExFRlRfQVJST1csIExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4sIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSLCBMaXN0S2V5TWFuYWdlciwgTGl2ZUFubm91bmNlciwgT2JzZXJ2ZUNvbnRlbnQsIE9ic2VydmVDb250ZW50TW9kdWxlLCBQQUdFX0RPV04sIFBBR0VfVVAsIFBsYXRmb3JtLCBQbGF0Zm9ybU1vZHVsZSwgUG9ydGFsLCBQb3J0YWxIb3N0RGlyZWN0aXZlLCBQb3J0YWxNb2R1bGUsIFJJR0hUX0FSUk9XLCBSeENoYWluLCBTUEFDRSwgVEFCLCBUZW1wbGF0ZVBvcnRhbCwgVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUsIFVQX0FSUk9XLCBhdWRpdFRpbWUsIGNhdGNoT3BlcmF0b3IsIGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSwgY29lcmNlTnVtYmVyUHJvcGVydHksIGRvT3BlcmF0b3IsIGZpbHRlciwgZmluYWxseU9wZXJhdG9yLCBmaXJzdCwgZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcywgaXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlciwgbWFwLCBzaGFyZSwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkayc7XG5pbXBvcnQgeyBET0NVTUVOVCwgRG9tU2FuaXRpemVyLCBIQU1NRVJfR0VTVFVSRV9DT05GSUcsIEhhbW1lckdlc3R1cmVDb25maWcgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSwgTG9jYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL21lcmdlJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IEZvcm1Hcm91cERpcmVjdGl2ZSwgRm9ybXNNb2R1bGUsIE5HX1ZBTElEQVRPUlMsIE5HX1ZBTFVFX0FDQ0VTU09SLCBOZ0NvbnRyb2wsIE5nRm9ybSwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGFuaW1hdGUsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgSHR0cCB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBfdGhyb3cgfSBmcm9tICdyeGpzL29ic2VydmFibGUvdGhyb3cnO1xuaW1wb3J0IHsgZm9ya0pvaW4gfSBmcm9tICdyeGpzL29ic2VydmFibGUvZm9ya0pvaW4nO1xudmFyIE1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSA9IG5ldyBJbmplY3Rpb25Ub2tlbignbWQtY29tcGF0aWJpbGl0eS1tb2RlJyk7XG4vKipcbiAqIFJldHVybnMgYW4gZXhjZXB0aW9uIHRvIGJlIHRocm93biBpZiB0aGUgY29uc3VtZXIgaGFzIHVzZWRcbiAqIGFuIGludmFsaWQgTWF0ZXJpYWwgcHJlZml4IG9uIGEgY29tcG9uZW50LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcGFyYW0gez99IHByZWZpeFxuICogQHBhcmFtIHs/fSBub2RlTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TWRDb21wYXRpYmlsaXR5SW52YWxpZFByZWZpeEVycm9yKHByZWZpeCwgbm9kZU5hbWUpIHtcbiAgICByZXR1cm4gRXJyb3IoXCJUaGUgXFxcIlwiICsgcHJlZml4ICsgXCItXFxcIiBwcmVmaXggY2Fubm90IGJlIHVzZWQgaW4gbmctbWF0ZXJpYWwgdjEgY29tcGF0aWJpbGl0eSBtb2RlLiBcIiArXG4gICAgICAgIChcIkl0IHdhcyB1c2VkIG9uIGFuIFxcXCJcIiArIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKyBcIlxcXCIgZWxlbWVudC5cIikpO1xufVxuLyoqXG4gKiBTZWxlY3RvciB0aGF0IG1hdGNoZXMgYWxsIGVsZW1lbnRzIHRoYXQgbWF5IGhhdmUgc3R5bGUgY29sbGlzaW9ucyB3aXRoIEFuZ3VsYXJKUyBNYXRlcmlhbC5cbiAqL1xudmFyIE1BVF9FTEVNRU5UU19TRUxFQ1RPUiA9IFwiXFxuICBbbWF0LWJ1dHRvbl0sXFxuICBbbWF0LWZhYl0sXFxuICBbbWF0LWljb24tYnV0dG9uXSxcXG4gIFttYXQtbWluaS1mYWJdLFxcbiAgW21hdC1yYWlzZWQtYnV0dG9uXSxcXG4gIFttYXRDYXJkU3VidGl0bGVdLFxcbiAgW21hdENhcmRUaXRsZV0sXFxuICBbbWF0RGlhbG9nQWN0aW9uc10sXFxuICBbbWF0RGlhbG9nQ2xvc2VdLFxcbiAgW21hdERpYWxvZ0NvbnRlbnRdLFxcbiAgW21hdERpYWxvZ1RpdGxlXSxcXG4gIFttYXRMaW5lXSxcXG4gIFttYXRUYWJMYWJlbF0sXFxuICBbbWF0VGFiTGlua10sXFxuICBbbWF0VGFiTmF2XSxcXG4gIFttYXRUb29sdGlwXSxcXG4gIG1hdC1hdXRvY29tcGxldGUsXFxuICBtYXQtYnV0dG9uLXRvZ2dsZSxcXG4gIG1hdC1idXR0b24tdG9nZ2xlLFxcbiAgbWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXAsXFxuICBtYXQtY2FyZCxcXG4gIG1hdC1jYXJkLWFjdGlvbnMsXFxuICBtYXQtY2FyZC1jb250ZW50LFxcbiAgbWF0LWNhcmQtZm9vdGVyLFxcbiAgbWF0LWNhcmQtaGVhZGVyLFxcbiAgbWF0LWNhcmQtc3VidGl0bGUsXFxuICBtYXQtY2FyZC10aXRsZSxcXG4gIG1hdC1jYXJkLXRpdGxlLWdyb3VwLFxcbiAgbWF0LWNlbGwsXFxuICBtYXQtY2hlY2tib3gsXFxuICBtYXQtY2hpcCxcXG4gIG1hdC1kaWFsb2ctYWN0aW9ucyxcXG4gIG1hdC1kaWFsb2ctY29udGFpbmVyLFxcbiAgbWF0LWRpYWxvZy1jb250ZW50LFxcbiAgbWF0LWRpdmlkZXIsXFxuICBtYXQtZXJyb3IsXFxuICBtYXQtZ3JpZC1saXN0LFxcbiAgbWF0LWdyaWQtdGlsZSxcXG4gIG1hdC1ncmlkLXRpbGUtZm9vdGVyLFxcbiAgbWF0LWdyaWQtdGlsZS1oZWFkZXIsXFxuICBtYXQtaGVhZGVyLWNlbGwsXFxuICBtYXQtaGludCxcXG4gIG1hdC1pY29uLFxcbiAgbWF0LWxpc3QsXFxuICBtYXQtbGlzdC1pdGVtLFxcbiAgbWF0LW1lbnUsXFxuICBtYXQtbmF2LWxpc3QsXFxuICBtYXQtb3B0aW9uLFxcbiAgbWF0LXBsYWNlaG9sZGVyLFxcbiAgbWF0LXByb2dyZXNzLWJhcixcXG4gIG1hdC1wc2V1ZG8tY2hlY2tib3gsXFxuICBtYXQtcmFkaW8tYnV0dG9uLFxcbiAgbWF0LXJhZGlvLWdyb3VwLFxcbiAgbWF0LXJvdyxcXG4gIG1hdC1zZWxlY3QsXFxuICBtYXQtc2lkZW5hdixcXG4gIG1hdC1zaWRlbmF2LWNvbnRhaW5lcixcXG4gIG1hdC1zbGlkZXIsXFxuICBtYXQtc3Bpbm5lcixcXG4gIG1hdC10YWIsXFxuICBtYXQtdGFibGUsXFxuICBtYXQtdGFiLWdyb3VwLFxcbiAgbWF0LXRvb2xiYXJcIjtcbi8qKlxuICogU2VsZWN0b3IgdGhhdCBtYXRjaGVzIGFsbCBlbGVtZW50cyB0aGF0IG1heSBoYXZlIHN0eWxlIGNvbGxpc2lvbnMgd2l0aCBBbmd1bGFySlMgTWF0ZXJpYWwuXG4gKi9cbnZhciBNRF9FTEVNRU5UU19TRUxFQ1RPUiA9IFwiXFxuICBbbWQtYnV0dG9uXSxcXG4gIFttZC1mYWJdLFxcbiAgW21kLWljb24tYnV0dG9uXSxcXG4gIFttZC1taW5pLWZhYl0sXFxuICBbbWQtcmFpc2VkLWJ1dHRvbl0sXFxuICBbbWRDYXJkU3VidGl0bGVdLFxcbiAgW21kQ2FyZFRpdGxlXSxcXG4gIFttZERpYWxvZ0FjdGlvbnNdLFxcbiAgW21kRGlhbG9nQ2xvc2VdLFxcbiAgW21kRGlhbG9nQ29udGVudF0sXFxuICBbbWREaWFsb2dUaXRsZV0sXFxuICBbbWRMaW5lXSxcXG4gIFttZFRhYkxhYmVsXSxcXG4gIFttZFRhYkxpbmtdLFxcbiAgW21kVGFiTmF2XSxcXG4gIFttZFRvb2x0aXBdLFxcbiAgbWQtYXV0b2NvbXBsZXRlLFxcbiAgbWQtYnV0dG9uLXRvZ2dsZSxcXG4gIG1kLWJ1dHRvbi10b2dnbGUsXFxuICBtZC1idXR0b24tdG9nZ2xlLWdyb3VwLFxcbiAgbWQtY2FyZCxcXG4gIG1kLWNhcmQtYWN0aW9ucyxcXG4gIG1kLWNhcmQtY29udGVudCxcXG4gIG1kLWNhcmQtZm9vdGVyLFxcbiAgbWQtY2FyZC1oZWFkZXIsXFxuICBtZC1jYXJkLXN1YnRpdGxlLFxcbiAgbWQtY2FyZC10aXRsZSxcXG4gIG1kLWNhcmQtdGl0bGUtZ3JvdXAsXFxuICBtZC1jZWxsLFxcbiAgbWQtY2hlY2tib3gsXFxuICBtZC1jaGlwLFxcbiAgbWQtZGlhbG9nLWFjdGlvbnMsXFxuICBtZC1kaWFsb2ctY29udGFpbmVyLFxcbiAgbWQtZGlhbG9nLWNvbnRlbnQsXFxuICBtZC1kaXZpZGVyLFxcbiAgbWQtZXJyb3IsXFxuICBtZC1ncmlkLWxpc3QsXFxuICBtZC1ncmlkLXRpbGUsXFxuICBtZC1ncmlkLXRpbGUtZm9vdGVyLFxcbiAgbWQtZ3JpZC10aWxlLWhlYWRlcixcXG4gIG1kLWhlYWRlci1jZWxsLFxcbiAgbWQtaGludCxcXG4gIG1kLWljb24sXFxuICBtZC1saXN0LFxcbiAgbWQtbGlzdC1pdGVtLFxcbiAgbWQtbWVudSxcXG4gIG1kLW5hdi1saXN0LFxcbiAgbWQtb3B0aW9uLFxcbiAgbWQtcGxhY2Vob2xkZXIsXFxuICBtZC1wcm9ncmVzcy1iYXIsXFxuICBtZC1wc2V1ZG8tY2hlY2tib3gsXFxuICBtZC1yYWRpby1idXR0b24sXFxuICBtZC1yYWRpby1ncm91cCxcXG4gIG1kLXJvdyxcXG4gIG1kLXNlbGVjdCxcXG4gIG1kLXNpZGVuYXYsXFxuICBtZC1zaWRlbmF2LWNvbnRhaW5lcixcXG4gIG1kLXNsaWRlcixcXG4gIG1kLXNwaW5uZXIsXFxuICBtZC10YWIsXFxuICBtZC10YWJsZSxcXG4gIG1kLXRhYi1ncm91cCxcXG4gIG1kLXRvb2xiYXJcIjtcbi8qKlxuICogRGlyZWN0aXZlIHRoYXQgZW5mb3JjZXMgdGhhdCB0aGUgYG1hdC1gIHByZWZpeCBjYW5ub3QgYmUgdXNlZC5cbiAqL1xudmFyIE1hdFByZWZpeFJlamVjdG9yID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc0NvbXBhdGliaWxpdHlNb2RlXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWF0UHJlZml4UmVqZWN0b3IoaXNDb21wYXRpYmlsaXR5TW9kZSwgZWxlbWVudFJlZikge1xuICAgICAgICBpZiAoIWlzQ29tcGF0aWJpbGl0eU1vZGUpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kQ29tcGF0aWJpbGl0eUludmFsaWRQcmVmaXhFcnJvcignbWF0JywgZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm5vZGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWF0UHJlZml4UmVqZWN0b3I7XG59KCkpO1xuTWF0UHJlZml4UmVqZWN0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6IE1BVF9FTEVNRU5UU19TRUxFQ1RPUiB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1hdFByZWZpeFJlamVjdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSxdIH0sXSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbl07IH07XG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IGVuZm9yY2VzIHRoYXQgdGhlIGBtZC1gIHByZWZpeCBjYW5ub3QgYmUgdXNlZC5cbiAqL1xudmFyIE1kUHJlZml4UmVqZWN0b3IgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlzQ29tcGF0aWJpbGl0eU1vZGVcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFByZWZpeFJlamVjdG9yKGlzQ29tcGF0aWJpbGl0eU1vZGUsIGVsZW1lbnRSZWYpIHtcbiAgICAgICAgaWYgKGlzQ29tcGF0aWJpbGl0eU1vZGUpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kQ29tcGF0aWJpbGl0eUludmFsaWRQcmVmaXhFcnJvcignbWQnLCBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQubm9kZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNZFByZWZpeFJlamVjdG9yO1xufSgpKTtcbk1kUHJlZml4UmVqZWN0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6IE1EX0VMRU1FTlRTX1NFTEVDVE9SIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRQcmVmaXhSZWplY3Rvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUsXSB9LF0gfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG5dOyB9O1xuLyoqXG4gKiBNb2R1bGUgdGhhdCBlbmZvcmNlcyB0aGUgZGVmYXVsdCBjb21wYXRpYmlsaXR5IG1vZGUgc2V0dGluZ3MuIFdoZW4gdGhpcyBtb2R1bGUgaXMgbG9hZGVkXG4gKiB3aXRob3V0IE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlIGFsc28gYmVpbmcgaW1wb3J0ZWQsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAqIHRoZXJlIGFyZSBhbnkgdXNlcyBvZiB0aGUgYG1hdC1gIHByZWZpeC5cbiAqL1xudmFyIENvbXBhdGliaWxpdHlNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wYXRpYmlsaXR5TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGF0aWJpbGl0eU1vZHVsZTtcbn0oKSk7XG5Db21wYXRpYmlsaXR5TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYXRQcmVmaXhSZWplY3RvciwgTWRQcmVmaXhSZWplY3Rvcl0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01hdFByZWZpeFJlamVjdG9yLCBNZFByZWZpeFJlamVjdG9yXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQ29tcGF0aWJpbGl0eU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBNb2R1bGUgdGhhdCBlbmZvcmNlcyBcIm5vLWNvbmZsaWN0XCIgY29tcGF0aWJpbGl0eSBtb2RlIHNldHRpbmdzLiBXaGVuIHRoaXMgbW9kdWxlIGlzIGxvYWRlZCxcbiAqIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSB1c2VzIG9mIHRoZSBgbWQtYCBwcmVmaXguXG4gKi9cbnZhciBOb0NvbmZsaWN0U3R5bGVDb21wYXRpYmlsaXR5TW9kZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGU7XG59KCkpO1xuTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSwgdXNlVmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Ob0NvbmZsaWN0U3R5bGVDb21wYXRpYmlsaXR5TW9kZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBJbmplY3Rpb24gdG9rZW4gdGhhdCBjb25maWd1cmVzIHdoZXRoZXIgdGhlIE1hdGVyaWFsIHNhbml0eSBjaGVja3MgYXJlIGVuYWJsZWQuXG4gKi9cbnZhciBNQVRFUklBTF9TQU5JVFlfQ0hFQ0tTID0gbmV3IEluamVjdGlvblRva2VuKCdtZC1zYW5pdHktY2hlY2tzJyk7XG4vKipcbiAqIE1vZHVsZSB0aGF0IGNhcHR1cmVzIGFueXRoaW5nIHRoYXQgc2hvdWxkIGJlIGxvYWRlZCBhbmQvb3IgcnVuIGZvciAqYWxsKiBBbmd1bGFyIE1hdGVyaWFsXG4gKiBjb21wb25lbnRzLiBUaGlzIGluY2x1ZGVzIEJpZGksIGNvbXBhdGliaWxpdHkgbW9kZSwgZXRjLlxuICpcbiAqIFRoaXMgbW9kdWxlIHNob3VsZCBiZSBpbXBvcnRlZCB0byBlYWNoIHRvcC1sZXZlbCBjb21wb25lbnQgbW9kdWxlIChlLmcuLCBNZFRhYnNNb2R1bGUpLlxuICovXG52YXIgTWRDb21tb25Nb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kb2N1bWVudFxuICAgICAqIEBwYXJhbSB7P30gX3Nhbml0eUNoZWNrc0VuYWJsZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZENvbW1vbk1vZHVsZShfZG9jdW1lbnQsIF9zYW5pdHlDaGVja3NFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gX2RvY3VtZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB3ZSd2ZSBkb25lIHRoZSBnbG9iYWwgc2FuaXR5IGNoZWNrcyAoZS5nLiBhIHRoZW1lIGlzIGxvYWRlZCwgdGhlcmUgaXMgYSBkb2N0eXBlKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hhc0RvbmVHbG9iYWxDaGVja3MgPSBmYWxzZTtcbiAgICAgICAgaWYgKF9zYW5pdHlDaGVja3NFbmFibGVkICYmICF0aGlzLl9oYXNEb25lR2xvYmFsQ2hlY2tzICYmIF9kb2N1bWVudCAmJiBpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tEb2N0eXBlKCk7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1RoZW1lKCk7XG4gICAgICAgICAgICB0aGlzLl9oYXNEb25lR2xvYmFsQ2hlY2tzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ29tbW9uTW9kdWxlLnByb3RvdHlwZS5fY2hlY2tEb2N0eXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RvY3VtZW50LmRvY3R5cGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ3VycmVudCBkb2N1bWVudCBkb2VzIG5vdCBoYXZlIGEgZG9jdHlwZS4gVGhpcyBtYXkgY2F1c2UgJyArXG4gICAgICAgICAgICAgICAgJ3NvbWUgQW5ndWxhciBNYXRlcmlhbCBjb21wb25lbnRzIG5vdCB0byBiZWhhdmUgYXMgZXhwZWN0ZWQuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDb21tb25Nb2R1bGUucHJvdG90eXBlLl9jaGVja1RoZW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGdldENvbXB1dGVkU3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlc3RFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtYXQtdGhlbWUtbG9hZGVkLW1hcmtlcicpO1xuICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXN0RWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0ZXN0RWxlbWVudCkuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBBbmd1bGFyIE1hdGVyaWFsIGNvcmUgdGhlbWUuIE1vc3QgTWF0ZXJpYWwgJyArXG4gICAgICAgICAgICAgICAgICAgICdjb21wb25lbnRzIG1heSBub3Qgd29yayBhcyBleHBlY3RlZC4gRm9yIG1vcmUgaW5mbyByZWZlciAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RvIHRoZSB0aGVtaW5nIGd1aWRlOiBodHRwczovL21hdGVyaWFsLmFuZ3VsYXIuaW8vZ3VpZGUvdGhlbWluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXN0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZENvbW1vbk1vZHVsZTtcbn0oKSk7XG5NZENvbW1vbk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbXBhdGliaWxpdHlNb2R1bGUsIEJpZGlNb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDb21wYXRpYmlsaXR5TW9kdWxlLCBCaWRpTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBNQVRFUklBTF9TQU5JVFlfQ0hFQ0tTLCB1c2VWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ29tbW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0RPQ1VNRU5ULF0gfSxdIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTUFURVJJQUxfU0FOSVRZX0NIRUNLUyxdIH0sXSB9LFxuXTsgfTtcbi8qKlxuICogU2hhcmVkIGRpcmVjdGl2ZSB0byBjb3VudCBsaW5lcyBpbnNpZGUgYSB0ZXh0IGFyZWEsIHN1Y2ggYXMgYSBsaXN0IGl0ZW0uXG4gKiBMaW5lIGVsZW1lbnRzIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBhIFxcQENvbnRlbnRDaGlsZHJlbihNZExpbmUpIHF1ZXJ5LCB0aGVuXG4gKiBjb3VudGVkIGJ5IGNoZWNraW5nIHRoZSBxdWVyeSBsaXN0J3MgbGVuZ3RoLlxuICovXG52YXIgTWRMaW5lID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaW5lKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRMaW5lO1xufSgpKTtcbk1kTGluZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWxpbmVdLCBbbWF0LWxpbmVdLCBbbWRMaW5lXSwgW21hdExpbmVdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtbGluZScgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZExpbmUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogSGVscGVyIHRoYXQgdGFrZXMgYSBxdWVyeSBsaXN0IG9mIGxpbmVzIGFuZCBzZXRzIHRoZSBjb3JyZWN0IGNsYXNzIG9uIHRoZSBob3N0LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZExpbmVTZXR0ZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9saW5lc1xuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kTGluZVNldHRlcihfbGluZXMsIF9yZW5kZXJlciwgX2VsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbGluZXMgPSBfbGluZXM7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3NldExpbmVDbGFzcyh0aGlzLl9saW5lcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLl9saW5lcy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fc2V0TGluZUNsYXNzKF90aGlzLl9saW5lcy5sZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb3VudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRMaW5lU2V0dGVyLnByb3RvdHlwZS5fc2V0TGluZUNsYXNzID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0Q2xhc3NlcygpO1xuICAgICAgICBpZiAoY291bnQgPT09IDIgfHwgY291bnQgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldENsYXNzKFwibWF0LVwiICsgY291bnQgKyBcIi1saW5lXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvdW50ID4gMykge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q2xhc3MoXCJtYXQtbXVsdGktbGluZVwiLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZExpbmVTZXR0ZXIucHJvdG90eXBlLl9yZXNldENsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldENsYXNzKCdtYXQtMi1saW5lJywgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZXRDbGFzcygnbWF0LTMtbGluZScsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0Q2xhc3MoJ21hdC1tdWx0aS1saW5lJywgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjbGFzc05hbWVcbiAgICAgKiBAcGFyYW0gez99IGlzQWRkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZExpbmVTZXR0ZXIucHJvdG90eXBlLl9zZXRDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGlzQWRkKSB7XG4gICAgICAgIGlmIChpc0FkZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWRMaW5lU2V0dGVyO1xufSgpKTtcbnZhciBNZExpbmVNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpbmVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZExpbmVNb2R1bGU7XG59KCkpO1xuTWRMaW5lTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZExpbmUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZExpbmVdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZExpbmVNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbnZhciBSaXBwbGVTdGF0ZSA9IHt9O1xuUmlwcGxlU3RhdGUuRkFESU5HX0lOID0gMDtcblJpcHBsZVN0YXRlLlZJU0lCTEUgPSAxO1xuUmlwcGxlU3RhdGUuRkFESU5HX09VVCA9IDI7XG5SaXBwbGVTdGF0ZS5ISURERU4gPSAzO1xuUmlwcGxlU3RhdGVbUmlwcGxlU3RhdGUuRkFESU5HX0lOXSA9IFwiRkFESU5HX0lOXCI7XG5SaXBwbGVTdGF0ZVtSaXBwbGVTdGF0ZS5WSVNJQkxFXSA9IFwiVklTSUJMRVwiO1xuUmlwcGxlU3RhdGVbUmlwcGxlU3RhdGUuRkFESU5HX09VVF0gPSBcIkZBRElOR19PVVRcIjtcblJpcHBsZVN0YXRlW1JpcHBsZVN0YXRlLkhJRERFTl0gPSBcIkhJRERFTlwiO1xuLyoqXG4gKiBSZWZlcmVuY2UgdG8gYSBwcmV2aW91c2x5IGxhdW5jaGVkIHJpcHBsZSBlbGVtZW50LlxuICovXG52YXIgUmlwcGxlUmVmID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbmZpZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJpcHBsZVJlZihfcmVuZGVyZXIsIGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IHN0YXRlIG9mIHRoZSByaXBwbGUgcmVmZXJlbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFJpcHBsZVN0YXRlLkhJRERFTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmFkZXMgb3V0IHRoZSByaXBwbGUgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJpcHBsZVJlZi5wcm90b3R5cGUuZmFkZU91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZmFkZU91dFJpcHBsZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBSaXBwbGVSZWY7XG59KCkpO1xuLyoqXG4gKiBGYWRlLWluIGR1cmF0aW9uIGZvciB0aGUgcmlwcGxlcy4gQ2FuIGJlIG1vZGlmaWVkIHdpdGggdGhlIHNwZWVkRmFjdG9yIG9wdGlvbi5cbiAqL1xudmFyIFJJUFBMRV9GQURFX0lOX0RVUkFUSU9OID0gNDUwO1xuLyoqXG4gKiBGYWRlLW91dCBkdXJhdGlvbiBmb3IgdGhlIHJpcHBsZXMgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIGNhbid0IGJlIG1vZGlmaWVkIGJ5IHRoZSBzcGVlZEZhY3Rvci5cbiAqL1xudmFyIFJJUFBMRV9GQURFX09VVF9EVVJBVElPTiA9IDQwMDtcbi8qKlxuICogSGVscGVyIHNlcnZpY2UgdGhhdCBwZXJmb3JtcyBET00gbWFuaXB1bGF0aW9ucy4gTm90IGludGVuZGVkIHRvIGJlIHVzZWQgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbiAqIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBhIHJlZmVyZW5jZSB0byB0aGUgcmlwcGxlIGRpcmVjdGl2ZSdzIGhvc3QgZWxlbWVudCBhbmQgYSBtYXAgb2YgRE9NXG4gKiBldmVudCBoYW5kbGVycyB0byBiZSBpbnN0YWxsZWQgb24gdGhlIGVsZW1lbnQgdGhhdCB0cmlnZ2VycyByaXBwbGUgYW5pbWF0aW9ucy5cbiAqIFRoaXMgd2lsbCBldmVudHVhbGx5IGJlY29tZSBhIGN1c3RvbSByZW5kZXJlciBvbmNlIEFuZ3VsYXIgc3VwcG9ydCBleGlzdHMuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFJpcHBsZVJlbmRlcmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBfcnVsZXJcbiAgICAgKiBAcGFyYW0gez99IHBsYXRmb3JtXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmlwcGxlUmVuZGVyZXIoZWxlbWVudFJlZiwgX25nWm9uZSwgX3J1bGVyLCBwbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9ydWxlciA9IF9ydWxlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBkb3duIG9yIG5vdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudHMgdG8gYmUgcmVnaXN0ZXJlZCBvbiB0aGUgdHJpZ2dlciBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBvZiBjdXJyZW50bHkgYWN0aXZlIHJpcHBsZSByZWZlcmVuY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWN0aXZlUmlwcGxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJpcHBsZSBjb25maWcgZm9yIGFsbCByaXBwbGVzIGNyZWF0ZWQgYnkgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yaXBwbGVDb25maWcgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgbW91c2UgcmlwcGxlcyBzaG91bGQgYmUgY3JlYXRlZCBvciBub3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJpcHBsZURpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8vIE9ubHkgZG8gYW55dGhpbmcgaWYgd2UncmUgb24gdGhlIGJyb3dzZXIuXG4gICAgICAgIGlmIChwbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAvLyBTcGVjaWZ5IGV2ZW50cyB3aGljaCBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgb24gdGhlIHRyaWdnZXIuXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnRzLnNldCgnbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMuc2V0KCdtb3VzZXVwJywgdGhpcy5vbk1vdXNldXAuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnRzLnNldCgnbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZUxlYXZlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCB1c2UgdGhlIGhvc3QgZWxlbWVudCBhcyB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLnNldFRyaWdnZXJFbGVtZW50KHRoaXMuX2NvbnRhaW5lckVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZhZGVzIGluIGEgcmlwcGxlIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0gez99IHBhZ2VYXG4gICAgICogQHBhcmFtIHs/fSBwYWdlWVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLmZhZGVJblJpcHBsZSA9IGZ1bmN0aW9uIChwYWdlWCwgcGFnZVksIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbmVyUmVjdCA9IHRoaXMuX2NvbnRhaW5lckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChjb25maWcuY2VudGVyZWQpIHtcbiAgICAgICAgICAgIHBhZ2VYID0gY29udGFpbmVyUmVjdC5sZWZ0ICsgY29udGFpbmVyUmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICBwYWdlWSA9IGNvbnRhaW5lclJlY3QudG9wICsgY29udGFpbmVyUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU3VidHJhY3Qgc2Nyb2xsIHZhbHVlcyBmcm9tIHRoZSBjb29yZGluYXRlcyBiZWNhdXNlIGNhbGN1bGF0aW9ucyBiZWxvd1xuICAgICAgICAgICAgLy8gYXJlIGFsd2F5cyByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2Nyb2xsUG9zaXRpb24gPSB0aGlzLl9ydWxlci5nZXRWaWV3cG9ydFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBwYWdlWCAtPSBzY3JvbGxQb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgcGFnZVkgLT0gc2Nyb2xsUG9zaXRpb24udG9wO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJhZGl1cyA9IGNvbmZpZy5yYWRpdXMgfHwgZGlzdGFuY2VUb0Z1cnRoZXN0Q29ybmVyKHBhZ2VYLCBwYWdlWSwgY29udGFpbmVyUmVjdCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uID0gUklQUExFX0ZBREVfSU5fRFVSQVRJT04gKiAoMSAvIChjb25maWcuc3BlZWRGYWN0b3IgfHwgMSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXRYID0gcGFnZVggLSBjb250YWluZXJSZWN0LmxlZnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldFkgPSBwYWdlWSAtIGNvbnRhaW5lclJlY3QudG9wO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaXBwbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcmlwcGxlLmNsYXNzTGlzdC5hZGQoJ21hdC1yaXBwbGUtZWxlbWVudCcpO1xuICAgICAgICByaXBwbGUuc3R5bGUubGVmdCA9IG9mZnNldFggLSByYWRpdXMgKyBcInB4XCI7XG4gICAgICAgIHJpcHBsZS5zdHlsZS50b3AgPSBvZmZzZXRZIC0gcmFkaXVzICsgXCJweFwiO1xuICAgICAgICByaXBwbGUuc3R5bGUuaGVpZ2h0ID0gcmFkaXVzICogMiArIFwicHhcIjtcbiAgICAgICAgcmlwcGxlLnN0eWxlLndpZHRoID0gcmFkaXVzICogMiArIFwicHhcIjtcbiAgICAgICAgLy8gSWYgdGhlIGNvbG9yIGlzIG5vdCBzZXQsIHRoZSBkZWZhdWx0IENTUyBjb2xvciB3aWxsIGJlIHVzZWQuXG4gICAgICAgIHJpcHBsZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb25maWcuY29sb3IgfHwgbnVsbDtcbiAgICAgICAgcmlwcGxlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uICsgXCJtc1wiO1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHJpcHBsZSk7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgdGhlIGJyb3dzZXIgZG9lcyBub3QgcmVjYWxjdWxhdGUgdGhlIHN0eWxlcyBvZiBkeW5hbWljYWxseSBjcmVhdGVkXG4gICAgICAgIC8vIHJpcHBsZSBlbGVtZW50cy4gVGhpcyBpcyBjcml0aWNhbCBiZWNhdXNlIHRoZW4gdGhlIGBzY2FsZWAgd291bGQgbm90IGFuaW1hdGUgcHJvcGVybHkuXG4gICAgICAgIGVuZm9yY2VTdHlsZVJlY2FsY3VsYXRpb24ocmlwcGxlKTtcbiAgICAgICAgcmlwcGxlLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgICAgIC8vIEV4cG9zZWQgcmVmZXJlbmNlIHRvIHRoZSByaXBwbGUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaXBwbGVSZWYgPSBuZXcgUmlwcGxlUmVmKHRoaXMsIHJpcHBsZSwgY29uZmlnKTtcbiAgICAgICAgcmlwcGxlUmVmLnN0YXRlID0gUmlwcGxlU3RhdGUuRkFESU5HX0lOO1xuICAgICAgICAvLyBBZGQgdGhlIHJpcHBsZSByZWZlcmVuY2UgdG8gdGhlIGxpc3Qgb2YgYWxsIGFjdGl2ZSByaXBwbGVzLlxuICAgICAgICB0aGlzLl9hY3RpdmVSaXBwbGVzLmFkZChyaXBwbGVSZWYpO1xuICAgICAgICAvLyBXYWl0IGZvciB0aGUgcmlwcGxlIGVsZW1lbnQgdG8gYmUgY29tcGxldGVseSBmYWRlZCBpbi5cbiAgICAgICAgLy8gT25jZSBpdCdzIGZhZGVkIGluLCB0aGUgcmlwcGxlIGNhbiBiZSBoaWRkZW4gaW1tZWRpYXRlbHkgaWYgdGhlIG1vdXNlIGlzIHJlbGVhc2VkLlxuICAgICAgICB0aGlzLnJ1blRpbWVvdXRPdXRzaWRlWm9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByaXBwbGVSZWYuc3RhdGUgPSBSaXBwbGVTdGF0ZS5WSVNJQkxFO1xuICAgICAgICAgICAgaWYgKCFjb25maWcucGVyc2lzdGVudCAmJiAhX3RoaXMuX2lzTW91c2Vkb3duKSB7XG4gICAgICAgICAgICAgICAgcmlwcGxlUmVmLmZhZGVPdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICByZXR1cm4gcmlwcGxlUmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmFkZXMgb3V0IGEgcmlwcGxlIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0gez99IHJpcHBsZVJlZlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLmZhZGVPdXRSaXBwbGUgPSBmdW5jdGlvbiAocmlwcGxlUmVmKSB7XG4gICAgICAgIC8vIEZvciByaXBwbGVzIHRoYXQgYXJlIG5vdCBhY3RpdmUgYW55bW9yZSwgZG9uJ3QgcmUtdW4gdGhlIGZhZGUtb3V0IGFuaW1hdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmVSaXBwbGVzLmRlbGV0ZShyaXBwbGVSZWYpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlwcGxlRWwgPSByaXBwbGVSZWYuZWxlbWVudDtcbiAgICAgICAgcmlwcGxlRWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gUklQUExFX0ZBREVfT1VUX0RVUkFUSU9OICsgXCJtc1wiO1xuICAgICAgICByaXBwbGVFbC5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICByaXBwbGVSZWYuc3RhdGUgPSBSaXBwbGVTdGF0ZS5GQURJTkdfT1VUO1xuICAgICAgICAvLyBPbmNlIHRoZSByaXBwbGUgZmFkZWQgb3V0LCB0aGUgcmlwcGxlIGNhbiBiZSBzYWZlbHkgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAgICAgIHRoaXMucnVuVGltZW91dE91dHNpZGVab25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJpcHBsZVJlZi5zdGF0ZSA9IFJpcHBsZVN0YXRlLkhJRERFTjsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgKChyaXBwbGVFbC5wYXJlbnROb2RlKSkucmVtb3ZlQ2hpbGQocmlwcGxlRWwpO1xuICAgICAgICB9LCBSSVBQTEVfRkFERV9PVVRfRFVSQVRJT04pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmFkZXMgb3V0IGFsbCBjdXJyZW50bHkgYWN0aXZlIHJpcHBsZXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUuZmFkZU91dEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmlwcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChyaXBwbGUpIHsgcmV0dXJuIHJpcHBsZS5mYWRlT3V0KCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdHJpZ2dlciBlbGVtZW50IGFuZCByZWdpc3RlcnMgdGhlIG1vdXNlIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJpcHBsZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRUcmlnZ2VyRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgcHJldmlvdXNseSByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgdHJpZ2dlciBlbGVtZW50LlxuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZm4sIHR5cGUpIHtcbiAgICAgICAgICAgICAgICAoKF90aGlzLl90cmlnZ2VyRWxlbWVudCkpLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBudWxsLCByZWdpc3RlciBhbGwgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGZuLCB0eXBlKSB7IHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyaWdnZXJFbGVtZW50ID0gZWxlbWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIGJlaW5nIGNhbGxlZCBvbiBtb3VzZWRvd24gZXZlbnQuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLm9uTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5yaXBwbGVEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNNb3VzZWRvd24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5mYWRlSW5SaXBwbGUoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZLCB0aGlzLnJpcHBsZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIGJlaW5nIGNhbGxlZCBvbiBtb3VzZXVwIGV2ZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLm9uTW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgLy8gRmFkZS1vdXQgYWxsIHJpcHBsZXMgdGhhdCBhcmUgY29tcGxldGVseSB2aXNpYmxlIGFuZCBub3QgcGVyc2lzdGVudC5cbiAgICAgICAgdGhpcy5fYWN0aXZlUmlwcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChyaXBwbGUpIHtcbiAgICAgICAgICAgIGlmICghcmlwcGxlLmNvbmZpZy5wZXJzaXN0ZW50ICYmIHJpcHBsZS5zdGF0ZSA9PT0gUmlwcGxlU3RhdGUuVklTSUJMRSkge1xuICAgICAgICAgICAgICAgIHJpcHBsZS5mYWRlT3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdGVuZXIgYmVpbmcgY2FsbGVkIG9uIG1vdXNlbGVhdmUgZXZlbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXNNb3VzZWRvd24pIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZXVwKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJ1bnMgYSB0aW1lb3V0IG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZSB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcGFyYW0gez89fSBkZWxheVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLnJ1blRpbWVvdXRPdXRzaWRlWm9uZSA9IGZ1bmN0aW9uIChmbiwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRUaW1lb3V0KGZuLCBkZWxheSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJpcHBsZVJlbmRlcmVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBlbmZvcmNlU3R5bGVSZWNhbGN1bGF0aW9uKGVsZW1lbnQpIHtcbiAgICAvLyBFbmZvcmNlIGEgc3R5bGUgcmVjYWxjdWxhdGlvbiBieSBjYWxsaW5nIGBnZXRDb21wdXRlZFN0eWxlYCBhbmQgYWNjZXNzaW5nIGFueSBwcm9wZXJ0eS5cbiAgICAvLyBDYWxsaW5nIGBnZXRQcm9wZXJ0eVZhbHVlYCBpcyBpbXBvcnRhbnQgdG8gbGV0IG9wdGltaXplcnMga25vdyB0aGF0IHRoaXMgaXMgbm90IGEgbm9vcC5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81ZDUyZmIwODFiMzU3MGM4MWUzYVxuICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ29wYWNpdHknKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgKHgsIHkpIHRvIHRoZSBmdXJ0aGVzdCBjb3JuZXIgb2YgYSByZWN0YW5nbGUuXG4gKiBAcGFyYW0gez99IHhcbiAqIEBwYXJhbSB7P30geVxuICogQHBhcmFtIHs/fSByZWN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkaXN0YW5jZVRvRnVydGhlc3RDb3JuZXIoeCwgeSwgcmVjdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpc3RYID0gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHJlY3QubGVmdCksIE1hdGguYWJzKHggLSByZWN0LnJpZ2h0KSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlzdFkgPSBNYXRoLm1heChNYXRoLmFicyh5IC0gcmVjdC50b3ApLCBNYXRoLmFicyh5IC0gcmVjdC5ib3R0b20pKTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGRpc3RYICogZGlzdFggKyBkaXN0WSAqIGRpc3RZKTtcbn1cbi8qKlxuICogVGltZSBpbiBtcyB0byB0aHJvdHRsZSB0aGUgc2Nyb2xsaW5nIGV2ZW50cyBieSBkZWZhdWx0LlxuICovXG52YXIgREVGQVVMVF9TQ1JPTExfVElNRSA9IDIwO1xuLyoqXG4gKiBTZXJ2aWNlIGNvbnRhaW5lZCBhbGwgcmVnaXN0ZXJlZCBTY3JvbGxhYmxlIHJlZmVyZW5jZXMgYW5kIGVtaXRzIGFuIGV2ZW50IHdoZW4gYW55IG9uZSBvZiB0aGVcbiAqIFNjcm9sbGFibGUgcmVmZXJlbmNlcyBlbWl0IGEgc2Nyb2xsZWQgZXZlbnQuXG4gKi9cbnZhciBTY3JvbGxEaXNwYXRjaGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBfcGxhdGZvcm1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTY3JvbGxEaXNwYXRjaGVyKF9uZ1pvbmUsIF9wbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IF9wbGF0Zm9ybTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGF0IGEgcmVnaXN0ZXJlZCBzY3JvbGxhYmxlIHJlZmVyZW5jZSBlbGVtZW50IGhhcyBiZWVuIHNjcm9sbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2Nyb2xsZWQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGdsb2JhbCBgc2Nyb2xsYCBhbmQgYHJlc2l6ZWAgc3Vic2NyaXB0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dsb2JhbFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgYW1vdW50IG9mIHN1YnNjcmlwdGlvbnMgdG8gYHNjcm9sbGVkYC4gVXNlZCBmb3IgY2xlYW5pbmcgdXAgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Njcm9sbGVkQ291bnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIG9mIGFsbCB0aGUgc2Nyb2xsYWJsZSByZWZlcmVuY2VzIHRoYXQgYXJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgc2VydmljZSBhbmQgdGhlaXJcbiAgICAgICAgICogc2Nyb2xsIGV2ZW50IHN1YnNjcmlwdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbGFibGVSZWZlcmVuY2VzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBTY3JvbGxhYmxlIHdpdGggdGhlIHNlcnZpY2UgYW5kIGxpc3RlbnMgZm9yIGl0cyBzY3JvbGxlZCBldmVudHMuIFdoZW4gdGhlXG4gICAgICogc2Nyb2xsYWJsZSBpcyBzY3JvbGxlZCwgdGhlIHNlcnZpY2UgZW1pdHMgdGhlIGV2ZW50IGluIGl0cyBzY3JvbGxlZCBvYnNlcnZhYmxlLlxuICAgICAqIEBwYXJhbSB7P30gc2Nyb2xsYWJsZSBTY3JvbGxhYmxlIGluc3RhbmNlIHRvIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChzY3JvbGxhYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcm9sbFN1YnNjcmlwdGlvbiA9IHNjcm9sbGFibGUuZWxlbWVudFNjcm9sbGVkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9ub3RpZnkoKTsgfSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuc2V0KHNjcm9sbGFibGUsIHNjcm9sbFN1YnNjcmlwdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXJlZ2lzdGVycyBhIFNjcm9sbGFibGUgcmVmZXJlbmNlIGFuZCB1bnN1YnNjcmliZXMgZnJvbSBpdHMgc2Nyb2xsIGV2ZW50IG9ic2VydmFibGUuXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxhYmxlIFNjcm9sbGFibGUgaW5zdGFuY2UgdG8gYmUgZGVyZWdpc3RlcmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2Nyb2xsRGlzcGF0Y2hlci5wcm90b3R5cGUuZGVyZWdpc3RlciA9IGZ1bmN0aW9uIChzY3JvbGxhYmxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcm9sbGFibGVSZWZlcmVuY2UgPSB0aGlzLnNjcm9sbGFibGVSZWZlcmVuY2VzLmdldChzY3JvbGxhYmxlKTtcbiAgICAgICAgaWYgKHNjcm9sbGFibGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIHNjcm9sbGFibGVSZWZlcmVuY2UudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuZGVsZXRlKHNjcm9sbGFibGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBldmVudCB3aGVuZXZlciBhbnkgb2YgdGhlIHJlZ2lzdGVyZWQgU2Nyb2xsYWJsZVxuICAgICAqIHJlZmVyZW5jZXMgKG9yIHdpbmRvdywgZG9jdW1lbnQsIG9yIGJvZHkpIGZpcmUgYSBzY3JvbGxlZCBldmVudC4gQ2FuIHByb3ZpZGUgYSB0aW1lIGluIG1zXG4gICAgICogdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgXCJ0aHJvdHRsZVwiIHRpbWUuXG4gICAgICogQHBhcmFtIHs/PX0gYXVkaXRUaW1lSW5Nc1xuICAgICAqIEBwYXJhbSB7Pz19IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5zY3JvbGxlZCA9IGZ1bmN0aW9uIChhdWRpdFRpbWVJbk1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXVkaXRUaW1lSW5NcyA9PT0gdm9pZCAwKSB7IGF1ZGl0VGltZUluTXMgPSBERUZBVUxUX1NDUk9MTF9USU1FOyB9XG4gICAgICAgIC8vIFNjcm9sbCBldmVudHMgY2FuIG9ubHkgaGFwcGVuIG9uIHRoZSBicm93c2VyLCBzbyBkbyBub3RoaW5nIGlmIHdlJ3JlIG5vdCBvbiB0aGUgYnJvd3Nlci5cbiAgICAgICAgaWYgKCF0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSAwbXMgZGVsYXksIHVzZSBhbiBvYnNlcnZhYmxlIHdpdGhvdXQgYXVkaXRUaW1lXG4gICAgICAgIC8vIHNpbmNlIGl0IGRvZXMgYWRkIGEgcGVyY2VwdGlibGUgZGVsYXkgaW4gcHJvY2Vzc2luZyBvdmVyaGVhZC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2JzZXJ2YWJsZSA9IGF1ZGl0VGltZUluTXMgPiAwID9cbiAgICAgICAgICAgIGF1ZGl0VGltZS5jYWxsKHRoaXMuX3Njcm9sbGVkLmFzT2JzZXJ2YWJsZSgpLCBhdWRpdFRpbWVJbk1zKSA6XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxlZC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsZWRDb3VudCsrO1xuICAgICAgICBpZiAoIXRoaXMuX2dsb2JhbFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uID0gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2UoZnJvbUV2ZW50KHdpbmRvdy5kb2N1bWVudCwgJ3Njcm9sbCcpLCBmcm9tRXZlbnQod2luZG93LCAncmVzaXplJykpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbm90aWZ5KCk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIG5lZWQgdG8gZG8gdGhlIHN1YnNjcmliaW5nIGZyb20gaGVyZSwgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byByZW1vdmVcbiAgICAgICAgLy8gdGhlIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMgb25jZSB0aGVyZSBhcmUgbm8gbW9yZSBzdWJzY3JpcHRpb25zLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3Njcm9sbGVkQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uICYmICFfdGhpcy5zY3JvbGxhYmxlUmVmZXJlbmNlcy5zaXplICYmICFfdGhpcy5fc2Nyb2xsZWRDb3VudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9nbG9iYWxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIFNjcm9sbGFibGVzIHRoYXQgY29udGFpbiB0aGUgcHJvdmlkZWQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNjcm9sbERpc3BhdGNoZXIucHJvdG90eXBlLmdldFNjcm9sbENvbnRhaW5lcnMgPSBmdW5jdGlvbiAoZWxlbWVudFJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY3JvbGxpbmdDb250YWluZXJzID0gW107XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoX3N1YnNjcmlwdGlvbiwgc2Nyb2xsYWJsZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNjcm9sbGFibGVDb250YWluc0VsZW1lbnQoc2Nyb2xsYWJsZSwgZWxlbWVudFJlZikpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxpbmdDb250YWluZXJzLnB1c2goc2Nyb2xsYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2Nyb2xsaW5nQ29udGFpbmVycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIHRoZSBwcm92aWRlZCBTY3JvbGxhYmxlLlxuICAgICAqIEBwYXJhbSB7P30gc2Nyb2xsYWJsZVxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2Nyb2xsRGlzcGF0Y2hlci5wcm90b3R5cGUuc2Nyb2xsYWJsZUNvbnRhaW5zRWxlbWVudCA9IGZ1bmN0aW9uIChzY3JvbGxhYmxlLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcm9sbGFibGVFbGVtZW50ID0gc2Nyb2xsYWJsZS5nZXRFbGVtZW50UmVmKCkubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gVHJhdmVyc2UgdGhyb3VnaCB0aGUgZWxlbWVudCBwYXJlbnRzIHVudGlsIHdlIHJlYWNoIG51bGwsIGNoZWNraW5nIGlmIGFueSBvZiB0aGUgZWxlbWVudHNcbiAgICAgICAgLy8gYXJlIHRoZSBzY3JvbGxhYmxlJ3MgZWxlbWVudC5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT0gc2Nyb2xsYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbm90aWZpY2F0aW9uIHRoYXQgYSBzY3JvbGwgZXZlbnQgaGFzIGJlZW4gZmlyZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5fbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxlZC5uZXh0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsRGlzcGF0Y2hlcjtcbn0oKSk7XG5TY3JvbGxEaXNwYXRjaGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5TY3JvbGxEaXNwYXRjaGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogUGxhdGZvcm0sIH0sXG5dOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHBhcmVudERpc3BhdGNoZXJcbiAqIEBwYXJhbSB7P30gbmdab25lXG4gKiBAcGFyYW0gez99IHBsYXRmb3JtXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudERpc3BhdGNoZXIsIG5nWm9uZSwgcGxhdGZvcm0pIHtcbiAgICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgU2Nyb2xsRGlzcGF0Y2hlcihuZ1pvbmUsIHBsYXRmb3JtKTtcbn1cbnZhciBTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgU2Nyb2xsRGlzcGF0Y2hlciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IFNjcm9sbERpc3BhdGNoZXIsXG4gICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIFNjcm9sbERpc3BhdGNoZXJdLCBOZ1pvbmUsIFBsYXRmb3JtXSxcbiAgICB1c2VGYWN0b3J5OiBTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUl9GQUNUT1JZXG59O1xuLyoqXG4gKiBTaW1wbGUgdXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgYm91bmRzIG9mIHRoZSBicm93c2VyIHZpZXdwb3J0LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBWaWV3cG9ydFJ1bGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxEaXNwYXRjaGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld3BvcnRSdWxlcihzY3JvbGxEaXNwYXRjaGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgcmVjdGFuZ2xlIG9uIGNoYW5nZXMuXG4gICAgICAgIHNjcm9sbERpc3BhdGNoZXIuc2Nyb2xsZWQoMCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NhY2hlVmlld3BvcnRHZW9tZXRyeSgpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIENsaWVudFJlY3QgZm9yIHRoZSB2aWV3cG9ydCdzIGJvdW5kcy5cbiAgICAgKiBAcGFyYW0gez89fSBkb2N1bWVudFJlY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdwb3J0UnVsZXIucHJvdG90eXBlLmdldFZpZXdwb3J0UmVjdCA9IGZ1bmN0aW9uIChkb2N1bWVudFJlY3QpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50UmVjdCA9PT0gdm9pZCAwKSB7IGRvY3VtZW50UmVjdCA9IHRoaXMuX2RvY3VtZW50UmVjdDsgfVxuICAgICAgICAvLyBDYWNoZSB0aGUgZG9jdW1lbnQgYm91bmRpbmcgcmVjdCBzbyB0aGF0IHdlIGRvbid0IHJlY29tcHV0ZSBpdCBmb3IgbXVsdGlwbGUgY2FsbHMuXG4gICAgICAgIGlmICghZG9jdW1lbnRSZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVZpZXdwb3J0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIGRvY3VtZW50UmVjdCA9IHRoaXMuX2RvY3VtZW50UmVjdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgdGhlIGRvY3VtZW50IGVsZW1lbnQncyBib3VuZGluZyByZWN0IHJhdGhlciB0aGFuIHRoZSB3aW5kb3cgc2Nyb2xsIHByb3BlcnRpZXNcbiAgICAgICAgLy8gKGUuZy4gcGFnZVlPZmZzZXQsIHNjcm9sbFkpIGR1ZSB0byBpbiBpc3N1ZSBpbiBDaHJvbWUgYW5kIElFIHdoZXJlIHdpbmRvdyBzY3JvbGxcbiAgICAgICAgLy8gcHJvcGVydGllcyBhbmQgY2xpZW50IGNvb3JkaW5hdGVzIChib3VuZGluZ0NsaWVudFJlY3QsIGNsaWVudFgvWSwgZXRjLikgYXJlIGluIGRpZmZlcmVudFxuICAgICAgICAvLyBjb25jZXB0dWFsIHZpZXdwb3J0cy4gVW5kZXIgbW9zdCBjaXJjdW1zdGFuY2VzIHRoZXNlIHZpZXdwb3J0cyBhcmUgZXF1aXZhbGVudCwgYnV0IHRoZXlcbiAgICAgICAgLy8gY2FuIGRpc2FncmVlIHdoZW4gdGhlIHBhZ2UgaXMgcGluY2gtem9vbWVkIChvbiBkZXZpY2VzIHRoYXQgc3VwcG9ydCB0b3VjaCkuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00ODkyMDYjYzRcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBkb2N1bWVudEVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgYm9keSBiZWNhdXNlLCBieSBkZWZhdWx0ICh3aXRob3V0IGEgY3NzIHJlc2V0KVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZ2l2ZSB0aGUgZG9jdW1lbnQgYm9keSBhbiA4cHggbWFyZ2luLCB3aGljaCBpcyBub3QgaW5jbHVkZWQgaW5cbiAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcm9sbFBvc2l0aW9uID0gdGhpcy5nZXRWaWV3cG9ydFNjcm9sbFBvc2l0aW9uKGRvY3VtZW50UmVjdCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogc2Nyb2xsUG9zaXRpb24udG9wLFxuICAgICAgICAgICAgbGVmdDogc2Nyb2xsUG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIGJvdHRvbTogc2Nyb2xsUG9zaXRpb24udG9wICsgaGVpZ2h0LFxuICAgICAgICAgICAgcmlnaHQ6IHNjcm9sbFBvc2l0aW9uLmxlZnQgKyB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgKHRvcCwgbGVmdCkgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gez89fSBkb2N1bWVudFJlY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdwb3J0UnVsZXIucHJvdG90eXBlLmdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24gPSBmdW5jdGlvbiAoZG9jdW1lbnRSZWN0KSB7XG4gICAgICAgIGlmIChkb2N1bWVudFJlY3QgPT09IHZvaWQgMCkgeyBkb2N1bWVudFJlY3QgPSB0aGlzLl9kb2N1bWVudFJlY3Q7IH1cbiAgICAgICAgLy8gQ2FjaGUgdGhlIGRvY3VtZW50IGJvdW5kaW5nIHJlY3Qgc28gdGhhdCB3ZSBkb24ndCByZWNvbXB1dGUgaXQgZm9yIG11bHRpcGxlIGNhbGxzLlxuICAgICAgICBpZiAoIWRvY3VtZW50UmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVWaWV3cG9ydEdlb21ldHJ5KCk7XG4gICAgICAgICAgICBkb2N1bWVudFJlY3QgPSB0aGlzLl9kb2N1bWVudFJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHRvcC1sZWZ0LWNvcm5lciBvZiB0aGUgdmlld3BvcnQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICAvLyBib2R5LCBub3JtYWxseSBqdXN0IChzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApLiBIb3dldmVyLCBDaHJvbWUgYW5kIEZpcmVmb3ggZGlzYWdyZWUgYWJvdXRcbiAgICAgICAgLy8gd2hldGhlciBgZG9jdW1lbnQuYm9keWAgb3IgYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudGAgaXMgdGhlIHNjcm9sbGVkIGVsZW1lbnQsIHNvIHJlYWRpbmdcbiAgICAgICAgLy8gYHNjcm9sbFRvcGAgYW5kIGBzY3JvbGxMZWZ0YCBpcyBpbmNvbnNpc3RlbnQuIEhvd2V2ZXIsIHVzaW5nIHRoZSBib3VuZGluZyByZWN0IG9mXG4gICAgICAgIC8vIGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRgIHdvcmtzIGNvbnNpc3RlbnRseSwgd2hlcmUgdGhlIGB0b3BgIGFuZCBgbGVmdGAgdmFsdWVzIHdpbGxcbiAgICAgICAgLy8gZXF1YWwgbmVnYXRpdmUgdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9wID0gLSgoZG9jdW1lbnRSZWN0KSkudG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IHdpbmRvdy5zY3JvbGxZIHx8XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlZnQgPSAtKChkb2N1bWVudFJlY3QpKS5sZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCB8fCB3aW5kb3cuc2Nyb2xsWCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgMDtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhY2hlcyB0aGUgbGF0ZXN0IGNsaWVudCByZWN0YW5nbGUgb2YgdGhlIGRvY3VtZW50IGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3cG9ydFJ1bGVyLnByb3RvdHlwZS5fY2FjaGVWaWV3cG9ydEdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kb2N1bWVudFJlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlld3BvcnRSdWxlcjtcbn0oKSk7XG5WaWV3cG9ydFJ1bGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5WaWV3cG9ydFJ1bGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogU2Nyb2xsRGlzcGF0Y2hlciwgfSxcbl07IH07XG4vKipcbiAqIEBwYXJhbSB7P30gcGFyZW50UnVsZXJcbiAqIEBwYXJhbSB7P30gc2Nyb2xsRGlzcGF0Y2hlclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gVklFV1BPUlRfUlVMRVJfUFJPVklERVJfRkFDVE9SWShwYXJlbnRSdWxlciwgc2Nyb2xsRGlzcGF0Y2hlcikge1xuICAgIHJldHVybiBwYXJlbnRSdWxlciB8fCBuZXcgVmlld3BvcnRSdWxlcihzY3JvbGxEaXNwYXRjaGVyKTtcbn1cbnZhciBWSUVXUE9SVF9SVUxFUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgVmlld3BvcnRSdWxlciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IFZpZXdwb3J0UnVsZXIsXG4gICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIFZpZXdwb3J0UnVsZXJdLCBTY3JvbGxEaXNwYXRjaGVyXSxcbiAgICB1c2VGYWN0b3J5OiBWSUVXUE9SVF9SVUxFUl9QUk9WSURFUl9GQUNUT1JZXG59O1xuLyoqXG4gKiBJbmplY3Rpb24gdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBnbG9iYWwgcmlwcGxlIG9wdGlvbnMuXG4gKi9cbnZhciBNRF9SSVBQTEVfR0xPQkFMX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ21kLXJpcHBsZS1nbG9iYWwtb3B0aW9ucycpO1xudmFyIE1kUmlwcGxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBuZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IHJ1bGVyXG4gICAgICogQHBhcmFtIHs/fSBwbGF0Zm9ybVxuICAgICAqIEBwYXJhbSB7P30gZ2xvYmFsT3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kUmlwcGxlKGVsZW1lbnRSZWYsIG5nWm9uZSwgcnVsZXIsIHBsYXRmb3JtLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQsIHRoZSByYWRpdXMgaW4gcGl4ZWxzIG9mIGZvcmVncm91bmQgcmlwcGxlcyB3aGVuIGZ1bGx5IGV4cGFuZGVkLiBJZiB1bnNldCwgdGhlIHJhZGl1c1xuICAgICAgICAgKiB3aWxsIGJlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIHJpcHBsZSB0byB0aGUgZnVydGhlc3QgY29ybmVyIG9mIHRoZSBob3N0IGVsZW1lbnQnc1xuICAgICAgICAgKiBib3VuZGluZyByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQsIHRoZSBub3JtYWwgZHVyYXRpb24gb2YgcmlwcGxlIGFuaW1hdGlvbnMgaXMgZGl2aWRlZCBieSB0aGlzIHZhbHVlLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgICogc2V0dGluZyBpdCB0byAwLjUgd2lsbCBjYXVzZSB0aGUgYW5pbWF0aW9ucyB0byB0YWtlIHR3aWNlIGFzIGxvbmcuXG4gICAgICAgICAqIEEgY2hhbmdlZCBzcGVlZEZhY3RvciB3aWxsIG5vdCBtb2RpZnkgdGhlIGZhZGUtb3V0IGR1cmF0aW9uIG9mIHRoZSByaXBwbGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zcGVlZEZhY3RvciA9IDE7XG4gICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyID0gbmV3IFJpcHBsZVJlbmRlcmVyKGVsZW1lbnRSZWYsIG5nWm9uZSwgcnVsZXIsIHBsYXRmb3JtKTtcbiAgICAgICAgdGhpcy5fZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnMgPyBnbG9iYWxPcHRpb25zIDoge307XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZVJlbmRlcmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSaXBwbGUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ3RyaWdnZXInXSAmJiB0aGlzLnRyaWdnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLnNldFRyaWdnZXJFbGVtZW50KHRoaXMudHJpZ2dlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlUmVuZGVyZXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSaXBwbGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTZXQgdGhlIHRyaWdnZXIgZWxlbWVudCB0byBudWxsIHRvIGNsZWFudXAgYWxsIGxpc3RlbmVycy5cbiAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIuc2V0VHJpZ2dlckVsZW1lbnQobnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMYXVuY2hlcyBhIG1hbnVhbCByaXBwbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gez99IHBhZ2VYXG4gICAgICogQHBhcmFtIHs/fSBwYWdlWVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSaXBwbGUucHJvdG90eXBlLmxhdW5jaCA9IGZ1bmN0aW9uIChwYWdlWCwgcGFnZVksIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gdGhpcy5yaXBwbGVDb25maWc7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpcHBsZVJlbmRlcmVyLmZhZGVJblJpcHBsZShwYWdlWCwgcGFnZVksIGNvbmZpZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGYWRlcyBvdXQgYWxsIGN1cnJlbnRseSBzaG93aW5nIHJpcHBsZSBlbGVtZW50cy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmlwcGxlLnByb3RvdHlwZS5mYWRlT3V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5mYWRlT3V0QWxsKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSaXBwbGUucHJvdG90eXBlLCBcInJpcHBsZUNvbmZpZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSaXBwbGUgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBkaXJlY3RpdmUncyBpbnB1dCB2YWx1ZXMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2VudGVyZWQ6IHRoaXMuY2VudGVyZWQsXG4gICAgICAgICAgICAgICAgc3BlZWRGYWN0b3I6IHRoaXMuc3BlZWRGYWN0b3IgKiAodGhpcy5fZ2xvYmFsT3B0aW9ucy5iYXNlU3BlZWRGYWN0b3IgfHwgMSksXG4gICAgICAgICAgICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmlwcGxlIHJlbmRlcmVyIHdpdGggdGhlIGxhdGVzdCByaXBwbGUgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmlwcGxlLnByb3RvdHlwZS5fdXBkYXRlUmlwcGxlUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLnJpcHBsZURpc2FibGVkID0gdGhpcy5fZ2xvYmFsT3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkO1xuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5yaXBwbGVDb25maWcgPSB0aGlzLnJpcHBsZUNvbmZpZztcbiAgICB9O1xuICAgIHJldHVybiBNZFJpcHBsZTtcbn0oKSk7XG5NZFJpcHBsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLXJpcHBsZV0sIFttYXQtcmlwcGxlXSwgW21kUmlwcGxlXSwgW21hdFJpcHBsZV0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRSaXBwbGUnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1yaXBwbGUnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1yaXBwbGUtdW5ib3VuZGVkXSc6ICd1bmJvdW5kZWQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFJpcHBsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgeyB0eXBlOiBWaWV3cG9ydFJ1bGVyLCB9LFxuICAgIHsgdHlwZTogUGxhdGZvcm0sIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTURfUklQUExFX0dMT0JBTF9PUFRJT05TLF0gfSxdIH0sXG5dOyB9O1xuTWRSaXBwbGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3RyaWdnZXInOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFJpcHBsZVRyaWdnZXInLF0gfSxdLFxuICAgICdjZW50ZXJlZCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kUmlwcGxlQ2VudGVyZWQnLF0gfSxdLFxuICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kUmlwcGxlRGlzYWJsZWQnLF0gfSxdLFxuICAgICdyYWRpdXMnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFJpcHBsZVJhZGl1cycsXSB9LF0sXG4gICAgJ3NwZWVkRmFjdG9yJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWRSaXBwbGVTcGVlZEZhY3RvcicsXSB9LF0sXG4gICAgJ2NvbG9yJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWRSaXBwbGVDb2xvcicsXSB9LF0sXG4gICAgJ3VuYm91bmRlZCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kUmlwcGxlVW5ib3VuZGVkJyxdIH0sXSxcbn07XG4vKipcbiAqIFNlbmRzIGFuIGV2ZW50IHdoZW4gdGhlIGRpcmVjdGl2ZSdzIGVsZW1lbnQgaXMgc2Nyb2xsZWQuIFJlZ2lzdGVycyBpdHNlbGYgd2l0aCB0aGVcbiAqIFNjcm9sbERpc3BhdGNoZXIgc2VydmljZSB0byBpbmNsdWRlIGl0c2VsZiBhcyBwYXJ0IG9mIGl0cyBjb2xsZWN0aW9uIG9mIHNjcm9sbGluZyBldmVudHMgdGhhdCBpdFxuICogY2FuIGJlIGxpc3RlbmVkIHRvIHRocm91Z2ggdGhlIHNlcnZpY2UuXG4gKi9cbnZhciBTY3JvbGxhYmxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX3Njcm9sbFxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2Nyb2xsYWJsZShfZWxlbWVudFJlZiwgX3Njcm9sbCwgX25nWm9uZSwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fc2Nyb2xsID0gX3Njcm9sbDtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRTY3JvbGxlZCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2Nyb2xsYWJsZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Njcm9sbExpc3RlbmVyID0gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVuZGVyZXIubGlzdGVuKF90aGlzLmdldEVsZW1lbnRSZWYoKS5uYXRpdmVFbGVtZW50LCAnc2Nyb2xsJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2VsZW1lbnRTY3JvbGxlZC5uZXh0KGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsLnJlZ2lzdGVyKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTY3JvbGxhYmxlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsLmRlcmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbExpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbiBhIHNjcm9sbCBldmVudCBpcyBmaXJlZCBvbiB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2Nyb2xsYWJsZS5wcm90b3R5cGUuZWxlbWVudFNjcm9sbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFNjcm9sbGVkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTY3JvbGxhYmxlLnByb3RvdHlwZS5nZXRFbGVtZW50UmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZjtcbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxhYmxlO1xufSgpKTtcblNjcm9sbGFibGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGstc2Nyb2xsYWJsZV0sIFtjZGtTY3JvbGxhYmxlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU2Nyb2xsYWJsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBTY3JvbGxEaXNwYXRjaGVyLCB9LFxuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuXTsgfTtcbi8qKlxuICogUmV0dXJucyBhbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhbiBhbHJlYWR5LWF0dGFjaGVkIHNjcm9sbCBzdHJhdGVneS5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE1kU2Nyb2xsU3RyYXRlZ3lBbHJlYWR5QXR0YWNoZWRFcnJvcigpIHtcbiAgICByZXR1cm4gRXJyb3IoXCJTY3JvbGwgc3RyYXRlZ3kgaGFzIGFscmVhZHkgYmVlbiBhdHRhY2hlZC5cIik7XG59XG4vKipcbiAqIFN0cmF0ZWd5IHRoYXQgd2lsbCBjbG9zZSB0aGUgb3ZlcmxheSBhcyBzb29uIGFzIHRoZSB1c2VyIHN0YXJ0cyBzY3JvbGxpbmcuXG4gKi9cbnZhciBDbG9zZVNjcm9sbFN0cmF0ZWd5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfc2Nyb2xsRGlzcGF0Y2hlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENsb3NlU2Nyb2xsU3RyYXRlZ3koX3Njcm9sbERpc3BhdGNoZXIpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsRGlzcGF0Y2hlciA9IF9zY3JvbGxEaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlSZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb3NlU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChvdmVybGF5UmVmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRNZFNjcm9sbFN0cmF0ZWd5QWxyZWFkeUF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gb3ZlcmxheVJlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvc2VTY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsU3Vic2NyaXB0aW9uID0gdGhpcy5fc2Nyb2xsRGlzcGF0Y2hlci5zY3JvbGxlZCgwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmRpc2FibGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb3NlU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENsb3NlU2Nyb2xsU3RyYXRlZ3k7XG59KCkpO1xuLyoqXG4gKiBTY3JvbGwgc3RyYXRlZ3kgdGhhdCBkb2Vzbid0IGRvIGFueXRoaW5nLlxuICovXG52YXIgTm9vcFNjcm9sbFN0cmF0ZWd5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9vcFNjcm9sbFN0cmF0ZWd5KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BTY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcFNjcm9sbFN0cmF0ZWd5LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcFNjcm9sbFN0cmF0ZWd5LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIE5vb3BTY3JvbGxTdHJhdGVneTtcbn0oKSk7XG4vKipcbiAqIFN0cmF0ZWd5IHRoYXQgd2lsbCBwcmV2ZW50IHRoZSB1c2VyIGZyb20gc2Nyb2xsaW5nIHdoaWxlIHRoZSBvdmVybGF5IGlzIHZpc2libGUuXG4gKi9cbnZhciBCbG9ja1Njcm9sbFN0cmF0ZWd5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfdmlld3BvcnRSdWxlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJsb2NrU2Nyb2xsU3RyYXRlZ3koX3ZpZXdwb3J0UnVsZXIpIHtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRSdWxlciA9IF92aWV3cG9ydFJ1bGVyO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0hUTUxTdHlsZXMgPSB7IHRvcDogJycsIGxlZnQ6ICcnIH07XG4gICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJsb2NrU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJsb2NrU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbkJlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3ZpZXdwb3J0UnVsZXIuZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHByZXZpb3VzIGlubGluZSBzdHlsZXMgaW4gY2FzZSB0aGUgdXNlciBoYWQgc2V0IHRoZW0uXG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0hUTUxTdHlsZXMubGVmdCA9IHJvb3Quc3R5bGUubGVmdCB8fCAnJztcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzSFRNTFN0eWxlcy50b3AgPSByb290LnN0eWxlLnRvcCB8fCAnJztcbiAgICAgICAgICAgIC8vIE5vdGU6IHdlJ3JlIHVzaW5nIHRoZSBgaHRtbGAgbm9kZSwgaW5zdGVhZCBvZiB0aGUgYGJvZHlgLCBiZWNhdXNlIHRoZSBgYm9keWAgbWF5XG4gICAgICAgICAgICAvLyBoYXZlIHRoZSB1c2VyIGFnZW50IG1hcmdpbiwgd2hlcmVhcyB0aGUgYGh0bWxgIGlzIGd1YXJhbnRlZWQgbm90IHRvIGhhdmUgb25lLlxuICAgICAgICAgICAgcm9vdC5zdHlsZS5sZWZ0ID0gLXRoaXMuX3ByZXZpb3VzU2Nyb2xsUG9zaXRpb24ubGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgIHJvb3Quc3R5bGUudG9wID0gLXRoaXMuX3ByZXZpb3VzU2Nyb2xsUG9zaXRpb24udG9wICsgXCJweFwiO1xuICAgICAgICAgICAgcm9vdC5jbGFzc0xpc3QuYWRkKCdjZGstZ2xvYmFsLXNjcm9sbGJsb2NrJyk7XG4gICAgICAgICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJsb2NrU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmxlZnQgPSB0aGlzLl9wcmV2aW91c0hUTUxTdHlsZXMubGVmdDtcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS50b3AgPSB0aGlzLl9wcmV2aW91c0hUTUxTdHlsZXMudG9wO1xuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2Nkay1nbG9iYWwtc2Nyb2xsYmxvY2snKTtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGwodGhpcy5fcHJldmlvdXNTY3JvbGxQb3NpdGlvbi5sZWZ0LCB0aGlzLl9wcmV2aW91c1Njcm9sbFBvc2l0aW9uLnRvcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmxvY2tTY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuX2NhbkJlRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU2luY2UgdGhlIHNjcm9sbCBzdHJhdGVnaWVzIGNhbid0IGJlIHNpbmdsZXRvbnMsIHdlIGhhdmUgdG8gdXNlIGEgZ2xvYmFsIENTUyBjbGFzc1xuICAgICAgICAvLyAoYGNkay1nbG9iYWwtc2Nyb2xsYmxvY2tgKSB0byBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCB0cnkgdG8gZGlzYWJsZSBnbG9iYWxcbiAgICAgICAgLy8gc2Nyb2xsaW5nIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnY2RrLWdsb2JhbC1zY3JvbGxibG9jaycpIHx8IHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0UnVsZXIuZ2V0Vmlld3BvcnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBib2R5LnNjcm9sbEhlaWdodCA+IHZpZXdwb3J0LmhlaWdodCB8fCBib2R5LnNjcm9sbFdpZHRoID4gdmlld3BvcnQud2lkdGg7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tTY3JvbGxTdHJhdGVneTtcbn0oKSk7XG4vKipcbiAqIFN0cmF0ZWd5IHRoYXQgd2lsbCB1cGRhdGUgdGhlIGVsZW1lbnQgcG9zaXRpb24gYXMgdGhlIHVzZXIgaXMgc2Nyb2xsaW5nLlxuICovXG52YXIgUmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfc2Nyb2xsRGlzcGF0Y2hlclxuICAgICAqIEBwYXJhbSB7Pz19IF9jb25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXBvc2l0aW9uU2Nyb2xsU3RyYXRlZ3koX3Njcm9sbERpc3BhdGNoZXIsIF9jb25maWcpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsRGlzcGF0Y2hlciA9IF9zY3JvbGxEaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICB0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlSZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKG92ZXJsYXlSZWYpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kU2Nyb2xsU3RyYXRlZ3lBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBvdmVybGF5UmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZXBvc2l0aW9uU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRocm90dGxlID0gdGhpcy5fY29uZmlnID8gdGhpcy5fY29uZmlnLnNjcm9sbFRocm90dGxlIDogMDtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuX3Njcm9sbERpc3BhdGNoZXIuc2Nyb2xsZWQodGhyb3R0bGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fb3ZlcmxheVJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZXBvc2l0aW9uU2Nyb2xsU3RyYXRlZ3k7XG59KCkpO1xuLyoqXG4gKiBPcHRpb25zIGZvciBob3cgYW4gb3ZlcmxheSB3aWxsIGhhbmRsZSBzY3JvbGxpbmcuXG4gKlxuICogVXNlcnMgY2FuIHByb3ZpZGUgYSBjdXN0b20gdmFsdWUgZm9yIGBTY3JvbGxTdHJhdGVneU9wdGlvbnNgIHRvIHJlcGxhY2UgdGhlIGRlZmF1bHRcbiAqIGJlaGF2aW9ycy4gVGhpcyBjbGFzcyBwcmltYXJpbHkgYWN0cyBhcyBhIGZhY3RvcnkgZm9yIFNjcm9sbFN0cmF0ZWd5IGluc3RhbmNlcy5cbiAqL1xudmFyIFNjcm9sbFN0cmF0ZWd5T3B0aW9ucyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3Njcm9sbERpc3BhdGNoZXJcbiAgICAgKiBAcGFyYW0gez99IF92aWV3cG9ydFJ1bGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2Nyb2xsU3RyYXRlZ3lPcHRpb25zKF9zY3JvbGxEaXNwYXRjaGVyLCBfdmlld3BvcnRSdWxlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zY3JvbGxEaXNwYXRjaGVyID0gX3Njcm9sbERpc3BhdGNoZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0UnVsZXIgPSBfdmlld3BvcnRSdWxlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvIG5vdGhpbmcgb24gc2Nyb2xsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub29wID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE5vb3BTY3JvbGxTdHJhdGVneSgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2UgdGhlIG92ZXJsYXkgYXMgc29vbiBhcyB0aGUgdXNlciBzY3JvbGxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBDbG9zZVNjcm9sbFN0cmF0ZWd5KF90aGlzLl9zY3JvbGxEaXNwYXRjaGVyKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJsb2NrIHNjcm9sbGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2sgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQmxvY2tTY3JvbGxTdHJhdGVneShfdGhpcy5fdmlld3BvcnRSdWxlcik7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIG92ZXJsYXkncyBwb3NpdGlvbiBvbiBzY3JvbGwuXG4gICAgICAgICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiB0byBiZSB1c2VkIGluc2lkZSB0aGUgc2Nyb2xsIHN0cmF0ZWd5LlxuICAgICAgICAgKiBBbGxvd3MgZGVib3VuY2luZyB0aGUgcmVwb3NpdGlvbiBjYWxscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVwb3NpdGlvbiA9IGZ1bmN0aW9uIChjb25maWcpIHsgcmV0dXJuIG5ldyBSZXBvc2l0aW9uU2Nyb2xsU3RyYXRlZ3koX3RoaXMuX3Njcm9sbERpc3BhdGNoZXIsIGNvbmZpZyk7IH07XG4gICAgfVxuICAgIHJldHVybiBTY3JvbGxTdHJhdGVneU9wdGlvbnM7XG59KCkpO1xuU2Nyb2xsU3RyYXRlZ3lPcHRpb25zLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5TY3JvbGxTdHJhdGVneU9wdGlvbnMuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBTY3JvbGxEaXNwYXRjaGVyLCB9LFxuICAgIHsgdHlwZTogVmlld3BvcnRSdWxlciwgfSxcbl07IH07XG52YXIgU2Nyb2xsRGlzcGF0Y2hNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxEaXNwYXRjaE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFNjcm9sbERpc3BhdGNoTW9kdWxlO1xufSgpKTtcblNjcm9sbERpc3BhdGNoTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbUGxhdGZvcm1Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtTY3JvbGxhYmxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtTY3JvbGxhYmxlXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUiwgU2Nyb2xsU3RyYXRlZ3lPcHRpb25zXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU2Nyb2xsRGlzcGF0Y2hNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbnZhciBNZFJpcHBsZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmlwcGxlTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRSaXBwbGVNb2R1bGU7XG59KCkpO1xuTWRSaXBwbGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNZENvbW1vbk1vZHVsZSwgUGxhdGZvcm1Nb2R1bGUsIFNjcm9sbERpc3BhdGNoTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRSaXBwbGUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFJpcHBsZV0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbVklFV1BPUlRfUlVMRVJfUFJPVklERVJdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFJpcHBsZU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBNaXhpbiB0byBhdWdtZW50IGEgZGlyZWN0aXZlIHdpdGggYSBgY29sb3JgIHByb3BlcnR5LlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gYmFzZVxuICogQHBhcmFtIHs/PX0gZGVmYXVsdENvbG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtaXhpbkNvbG9yKGJhc2UsIGRlZmF1bHRDb2xvcikge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsuLi4/fSBhcmdzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IHRoaXM7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGRlZmF1bHQgY29sb3IgdGhhdCBjYW4gYmUgc3BlY2lmaWVkIGZyb20gdGhlIG1peGluLlxuICAgICAgICAgICAgX3RoaXMuY29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2xvcjsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xvclBhbGV0dGUgPSB2YWx1ZSB8fCBkZWZhdWx0Q29sb3I7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yUGFsZXR0ZSAhPT0gdGhpcy5fY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwibWF0LVwiICsgdGhpcy5fY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvclBhbGV0dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJtYXQtXCIgKyBjb2xvclBhbGV0dGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gY29sb3JQYWxldHRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KGJhc2UpKTtcbn1cbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFBzZXVkb0NoZWNrYm94QmFzZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kUHNldWRvQ2hlY2tib3hCYXNlKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG4gICAgcmV0dXJuIE1kUHNldWRvQ2hlY2tib3hCYXNlO1xufSgpKTtcbnZhciBfTWRQc2V1ZG9DaGVja2JveEJhc2UgPSBtaXhpbkNvbG9yKE1kUHNldWRvQ2hlY2tib3hCYXNlLCAnYWNjZW50Jyk7XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IHNob3dzIGEgc2ltcGxpZmllZCBjaGVja2JveCB3aXRob3V0IGluY2x1ZGluZyBhbnkga2luZCBvZiBcInJlYWxcIiBjaGVja2JveC5cbiAqIE1lYW50IHRvIGJlIHVzZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgcHVyZWx5IGRlY29yYXRpdmUgYW5kIGEgbGFyZ2UgbnVtYmVyIG9mIHRoZW0gd2lsbCBiZVxuICogaW5jbHVkZWQsIHN1Y2ggYXMgZm9yIHRoZSBvcHRpb25zIGluIGEgbXVsdGktc2VsZWN0LiBVc2VzIG5vIFNWR3Mgb3IgY29tcGxleCBhbmltYXRpb25zLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGNvbXBvbmVudCB3aWxsIGJlIGNvbXBsZXRlbHkgaW52aXNpYmxlIHRvIHNjcmVlbi1yZWFkZXIgdXNlcnMuIFRoaXMgaXMgKm5vdCpcbiAqIGludGVyY2hhbmdlYWJsZSB3aXRoIDxtZC1jaGVja2JveD4gYW5kIHNob3VsZCAqbm90KiBiZSB1c2VkIGlmIHRoZSB1c2VyIHdvdWxkIGRpcmVjdGx5IGludGVyYWN0XG4gKiB3aXRoIHRoZSBjaGVja2JveC4gVGhlIHBzZXVkby1jaGVja2JveCBzaG91bGQgb25seSBiZSB1c2VkIGFzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZlxuICogbW9yZSBjb21wbGV4IGNvbXBvbmVudHMgdGhhdCBhcHByb3ByaWF0ZWx5IGhhbmRsZSBzZWxlY3RlZCAvIGNoZWNrZWQgc3RhdGUuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kUHNldWRvQ2hlY2tib3ggPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFBzZXVkb0NoZWNrYm94LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFBzZXVkb0NoZWNrYm94KGVsZW1lbnRSZWYsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlbmRlcmVyLCBlbGVtZW50UmVmKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheSBzdGF0ZSBvZiB0aGUgY2hlY2tib3guXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5zdGF0ZSA9ICd1bmNoZWNrZWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2hlY2tib3ggaXMgZGlzYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZFBzZXVkb0NoZWNrYm94O1xufShfTWRQc2V1ZG9DaGVja2JveEJhc2UpKTtcbk1kUHNldWRvQ2hlY2tib3guZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLXBzZXVkby1jaGVja2JveCwgbWF0LXBzZXVkby1jaGVja2JveCcsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXBzZXVkby1jaGVja2JveHt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JvcmRlcjoycHggc29saWQ7Ym9yZGVyLXJhZGl1czoycHg7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uOmJvcmRlci1jb2xvciA5MG1zIGN1YmljLWJlemllcigwLDAsLjIsLjEpLGJhY2tncm91bmQtY29sb3IgOTBtcyBjdWJpYy1iZXppZXIoMCwwLC4yLC4xKX0ubWF0LXBzZXVkby1jaGVja2JveDo6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7b3BhY2l0eTowO2NvbnRlbnQ6Jyc7Ym9yZGVyLWJvdHRvbToycHggc29saWQgY3VycmVudENvbG9yO3RyYW5zaXRpb246b3BhY2l0eSA5MG1zIGN1YmljLWJlemllcigwLDAsLjIsLjEpfS5tYXQtcHNldWRvLWNoZWNrYm94Lm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZCwubWF0LXBzZXVkby1jaGVja2JveC5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGV7Ym9yZGVyOm5vbmV9Lm1hdC1wc2V1ZG8tY2hlY2tib3gtZGlzYWJsZWR7Y3Vyc29yOmRlZmF1bHR9Lm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZTo6YWZ0ZXJ7dG9wOjlweDtsZWZ0OjJweDt3aWR0aDoxNnB4O29wYWNpdHk6MX0ubWF0LXBzZXVkby1jaGVja2JveC1jaGVja2VkOjphZnRlcnt0b3A6NXB4O2xlZnQ6M3B4O3dpZHRoOjEycHg7aGVpZ2h0OjVweDtib3JkZXItbGVmdDoycHggc29saWQgY3VycmVudENvbG9yO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTtvcGFjaXR5OjF9XCJdLFxuICAgICAgICAgICAgICAgIGlucHV0czogWydjb2xvciddLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtcHNldWRvLWNoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGVdJzogJ3N0YXRlID09PSBcImluZGV0ZXJtaW5hdGVcIicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXBzZXVkby1jaGVja2JveC1jaGVja2VkXSc6ICdzdGF0ZSA9PT0gXCJjaGVja2VkXCInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFBzZXVkb0NoZWNrYm94LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbl07IH07XG5NZFBzZXVkb0NoZWNrYm94LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdzdGF0ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xudmFyIE1kU2VsZWN0aW9uTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTZWxlY3Rpb25Nb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNlbGVjdGlvbk1vZHVsZTtcbn0oKSk7XG5NZFNlbGVjdGlvbk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kUHNldWRvQ2hlY2tib3hdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kUHNldWRvQ2hlY2tib3hdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU2VsZWN0aW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIE1peGluIHRvIGF1Z21lbnQgYSBkaXJlY3RpdmUgd2l0aCBhIGBkaXNhYmxlZGAgcHJvcGVydHkuXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBiYXNlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtaXhpbkRpc2FibGVkKGJhc2UpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoY2xhc3NfMiwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzIucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsYXNzXzI7XG4gICAgfShiYXNlKSk7XG59XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRPcHRncm91cEJhc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE9wdGdyb3VwQmFzZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kT3B0Z3JvdXBCYXNlO1xufSgpKTtcbnZhciBfTWRPcHRncm91cE1peGluQmFzZSA9IG1peGluRGlzYWJsZWQoTWRPcHRncm91cEJhc2UpO1xuLy8gQ291bnRlciBmb3IgdW5pcXVlIGdyb3VwIGlkcy5cbnZhciBfdW5pcXVlT3B0Z3JvdXBJZENvdW50ZXIgPSAwO1xuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBpcyB1c2VkIHRvIGdyb3VwIGluc3RhbmNlcyBvZiBgbWQtb3B0aW9uYC5cbiAqL1xudmFyIE1kT3B0Z3JvdXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZE9wdGdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kT3B0Z3JvdXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmlxdWUgaWQgZm9yIHRoZSB1bmRlcmx5aW5nIGxhYmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2xhYmVsSWQgPSBcIm1hdC1vcHRncm91cC1sYWJlbC1cIiArIF91bmlxdWVPcHRncm91cElkQ291bnRlcisrO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZE9wdGdyb3VwO1xufShfTWRPcHRncm91cE1peGluQmFzZSkpO1xuTWRPcHRncm91cC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLW9wdGdyb3VwLCBtYXQtb3B0Z3JvdXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxsYWJlbCBjbGFzcz1cXFwibWF0LW9wdGdyb3VwLWxhYmVsXFxcIiBbaWRdPVxcXCJfbGFiZWxJZFxcXCI+e3sgbGFiZWwgfX08L2xhYmVsPjxuZy1jb250ZW50IHNlbGVjdD1cXFwibWQtb3B0aW9uLCBtYXQtb3B0aW9uXFxcIj48L25nLWNvbnRlbnQ+XCIsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtb3B0Z3JvdXAnLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdncm91cCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LW9wdGdyb3VwLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdkaXNhYmxlZC50b1N0cmluZygpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtbGFiZWxsZWRieV0nOiAnX2xhYmVsSWQnLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRPcHRncm91cC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuTWRPcHRncm91cC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnbGFiZWwnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xuLyoqXG4gKiBPcHRpb24gSURzIG5lZWQgdG8gYmUgdW5pcXVlIGFjcm9zcyBjb21wb25lbnRzLCBzbyB0aGlzIGNvdW50ZXIgZXhpc3RzIG91dHNpZGUgb2ZcbiAqIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xudmFyIF91bmlxdWVJZENvdW50ZXIgPSAwO1xuLyoqXG4gKiBFdmVudCBvYmplY3QgZW1pdHRlZCBieSBNZE9wdGlvbiB3aGVuIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuXG4gKi9cbnZhciBNZE9wdGlvblNlbGVjdGlvbkNoYW5nZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlXG4gICAgICogQHBhcmFtIHs/PX0gaXNVc2VySW5wdXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZE9wdGlvblNlbGVjdGlvbkNoYW5nZShzb3VyY2UsIGlzVXNlcklucHV0KSB7XG4gICAgICAgIGlmIChpc1VzZXJJbnB1dCA9PT0gdm9pZCAwKSB7IGlzVXNlcklucHV0ID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuaXNVc2VySW5wdXQgPSBpc1VzZXJJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIE1kT3B0aW9uU2VsZWN0aW9uQ2hhbmdlO1xufSgpKTtcbi8qKlxuICogU2luZ2xlIG9wdGlvbiBpbnNpZGUgb2YgYSBgPG1kLXNlbGVjdD5gIGVsZW1lbnQuXG4gKi9cbnZhciBNZE9wdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGdyb3VwXG4gICAgICogQHBhcmFtIHs/fSBfaXNDb21wYXRpYmlsaXR5TW9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kT3B0aW9uKF9lbGVtZW50LCBncm91cCwgX2lzQ29tcGF0aWJpbGl0eU1vZGUpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XG4gICAgICAgIHRoaXMuX2lzQ29tcGF0aWJpbGl0eU1vZGUgPSBfaXNDb21wYXRpYmlsaXR5TW9kZTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBvcHRpb24gaXMgZGlzYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pZCA9IFwibWQtb3B0aW9uLVwiICsgX3VuaXF1ZUlkQ291bnRlcisrO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgd3JhcHBpbmcgY29tcG9uZW50IGlzIGluIG11bHRpcGxlIHNlbGVjdGlvbiBtb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBvcHRpb24gaXMgc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE9wdGlvbi5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgb3B0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kT3B0aW9uLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3B0aW9uIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE9wdGlvbi5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgb3B0aW9uIGlzIGRpc2FibGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmRpc2FibGVkKSB8fCB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kT3B0aW9uLnByb3RvdHlwZSwgXCJhY3RpdmVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG9wdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlIGFuZCByZWFkeSB0byBiZSBzZWxlY3RlZC5cbiAgICAgICAgICogQW4gYWN0aXZlIG9wdGlvbiBkaXNwbGF5cyBzdHlsZXMgYXMgaWYgaXQgaXMgZm9jdXNlZCwgYnV0IHRoZVxuICAgICAgICAgKiBmb2N1cyBpcyBhY3R1YWxseSByZXRhaW5lZCBzb21ld2hlcmUgZWxzZS4gVGhpcyBjb21lcyBpbiBoYW5keVxuICAgICAgICAgKiBmb3IgY29tcG9uZW50cyBsaWtlIGF1dG9jb21wbGV0ZSB3aGVyZSBmb2N1cyBtdXN0IHJlbWFpbiBvbiB0aGUgaW5wdXQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE9wdGlvbi5wcm90b3R5cGUsIFwidmlld1ZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5ZWQgdmFsdWUgb2YgdGhlIG9wdGlvbi4gSXQgaXMgbmVjZXNzYXJ5IHRvIHNob3cgdGhlIHNlbGVjdGVkIG9wdGlvbiBpbiB0aGVcbiAgICAgICAgICogc2VsZWN0J3MgdHJpZ2dlci5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETyhrYXJhKTogQWRkIGlucHV0IHByb3BlcnR5IGFsdGVybmF0aXZlIGZvciBub2RlIGVudnMuXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2dldEhvc3RFbGVtZW50KCkudGV4dENvbnRlbnQgfHwgJycpLnRyaW0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgb3B0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0U2VsZWN0aW9uQ2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyB0aGUgb3B0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbWl0U2VsZWN0aW9uQ2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgZm9jdXMgb250byB0aGlzIG9wdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ2V0SG9zdEVsZW1lbnQoKS5mb2N1cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyBkaXNwbGF5IHN0eWxlcyBvbiB0aGUgb3B0aW9uIHRvIG1ha2UgaXQgYXBwZWFyXG4gICAgICogYWN0aXZlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIHNvIGtleVxuICAgICAqIGV2ZW50cyB3aWxsIGRpc3BsYXkgdGhlIHByb3BlciBvcHRpb25zIGFzIGFjdGl2ZSBvbiBhcnJvdyBrZXkgZXZlbnRzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLnNldEFjdGl2ZVN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgZGlzcGxheSBzdHlsZXMgb24gdGhlIG9wdGlvbiB0aGF0IG1hZGUgaXQgYXBwZWFyXG4gICAgICogYWN0aXZlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIHNvIGtleVxuICAgICAqIGV2ZW50cyB3aWxsIGRpc3BsYXkgdGhlIHByb3BlciBvcHRpb25zIGFzIGFjdGl2ZSBvbiBhcnJvdyBrZXkgZXZlbnRzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLnNldEluYWN0aXZlU3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIG9wdGlvbiBpcyBzZWxlY3RlZCB3aGVuIGFjdGl2YXRlZCBmcm9tIHRoZSBrZXlib2FyZC5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE9wdGlvbi5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVOVEVSIHx8IGV2ZW50LmtleUNvZGUgPT09IFNQQUNFKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RWaWFJbnRlcmFjdGlvbigpO1xuICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZyBkb3duIGFuZCBmb3JtIHN1Ym1pdHMuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBvcHRpb24gd2hpbGUgaW5kaWNhdGluZyB0aGUgc2VsZWN0aW9uIGNhbWUgZnJvbSB0aGUgdXNlci4gVXNlZCB0b1xuICAgICAqIGRldGVybWluZSBpZiB0aGUgc2VsZWN0J3MgdmlldyAtPiBtb2RlbCBjYWxsYmFjayBzaG91bGQgYmUgaW52b2tlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5fc2VsZWN0VmlhSW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLm11bHRpcGxlID8gIXRoaXMuX3NlbGVjdGVkIDogdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29ycmVjdCB0YWJpbmRleCBmb3IgdGhlIG9wdGlvbiBkZXBlbmRpbmcgb24gZGlzYWJsZWQgc3RhdGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE9wdGlvbi5wcm90b3R5cGUuX2dldFRhYkluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/ICctMScgOiAnMCc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBob3N0IERPTSBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLl9nZXRIb3N0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIHRoZSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Pz19IGlzVXNlcklucHV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE9wdGlvbi5wcm90b3R5cGUuX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChpc1VzZXJJbnB1dCkge1xuICAgICAgICBpZiAoaXNVc2VySW5wdXQgPT09IHZvaWQgMCkgeyBpc1VzZXJJbnB1dCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuZW1pdChuZXcgTWRPcHRpb25TZWxlY3Rpb25DaGFuZ2UodGhpcywgaXNVc2VySW5wdXQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNZE9wdGlvbjtcbn0oKSk7XG5NZE9wdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLW9wdGlvbiwgbWF0LW9wdGlvbicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIudGFiaW5kZXhdJzogJ19nZXRUYWJJbmRleCgpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2VsZWN0ZWRdJzogJ3NlbGVjdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtb3B0aW9uLW11bHRpcGxlXSc6ICdtdWx0aXBsZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWFjdGl2ZV0nOiAnYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tpZF0nOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1zZWxlY3RlZF0nOiAnc2VsZWN0ZWQudG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdkaXNhYmxlZC50b1N0cmluZygpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtb3B0aW9uLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19zZWxlY3RWaWFJbnRlcmFjdGlvbigpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duKSc6ICdfaGFuZGxlS2V5ZG93bigkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1vcHRpb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHNwYW4gW25nU3dpdGNoXT1cXFwiX2lzQ29tcGF0aWJpbGl0eU1vZGVcXFwiICpuZ0lmPVxcXCJtdWx0aXBsZVxcXCI+PG1hdC1wc2V1ZG8tY2hlY2tib3ggY2xhc3M9XFxcIm1hdC1vcHRpb24tcHNldWRvLWNoZWNrYm94XFxcIiAqbmdTd2l0Y2hDYXNlPVxcXCJ0cnVlXFxcIiBbc3RhdGVdPVxcXCJzZWxlY3RlZCA/ICdjaGVja2VkJyA6ICcnXFxcIiBjb2xvcj1cXFwicHJpbWFyeVxcXCI+PC9tYXQtcHNldWRvLWNoZWNrYm94PjxtZC1wc2V1ZG8tY2hlY2tib3ggY2xhc3M9XFxcIm1hdC1vcHRpb24tcHNldWRvLWNoZWNrYm94XFxcIiAqbmdTd2l0Y2hEZWZhdWx0IFtzdGF0ZV09XFxcInNlbGVjdGVkID8gJ2NoZWNrZWQnIDogJydcXFwiIGNvbG9yPVxcXCJwcmltYXJ5XFxcIj48L21kLXBzZXVkby1jaGVja2JveD48L3NwYW4+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjxkaXYgY2xhc3M9XFxcIm1hdC1vcHRpb24tcmlwcGxlXFxcIiAqbmdJZj1cXFwiIWRpc2FibGVkXFxcIiBtZC1yaXBwbGUgW21kUmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kT3B0aW9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IE1kT3B0Z3JvdXAsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSxdIH0sXSB9LFxuXTsgfTtcbk1kT3B0aW9uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ29uU2VsZWN0aW9uQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG52YXIgTWRPcHRpb25Nb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE9wdGlvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kT3B0aW9uTW9kdWxlO1xufSgpKTtcbk1kT3B0aW9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWRSaXBwbGVNb2R1bGUsIENvbW1vbk1vZHVsZSwgTWRTZWxlY3Rpb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZE9wdGlvbiwgTWRPcHRncm91cF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRPcHRpb24sIE1kT3B0Z3JvdXBdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kT3B0aW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIE92ZXJsYXlTdGF0ZSBpcyBhIGJhZyBvZiB2YWx1ZXMgZm9yIGVpdGhlciB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uIG9yIGN1cnJlbnQgc3RhdGUgb2YgYW5cbiAqIG92ZXJsYXkuXG4gKi9cbnZhciBPdmVybGF5U3RhdGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5U3RhdGUoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXN0b20gY2xhc3MgdG8gYWRkIHRvIHRoZSBvdmVybGF5IHBhbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhbmVsQ2xhc3MgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIG92ZXJsYXkgaGFzIGEgYmFja2Ryb3AuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0JhY2tkcm9wID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXN0b20gY2xhc3MgdG8gYWRkIHRvIHRoZSBiYWNrZHJvcFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYWNrZHJvcENsYXNzID0gJ2Nkay1vdmVybGF5LWRhcmstYmFja2Ryb3AnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpcmVjdGlvbiBvZiB0aGUgdGV4dCBpbiB0aGUgb3ZlcmxheSBwYW5lbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ2x0cic7XG4gICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiBjb25maWd1cmF0aW9uIHN0aWxsIHRvIGFkZFxuICAgICAgICAvLyAtIGZvY3VzIHRyYXBcbiAgICAgICAgLy8gLSBkaXNhYmxlIHBvaW50ZXIgZXZlbnRzXG4gICAgICAgIC8vIC0gei1pbmRleFxuICAgIH1cbiAgICByZXR1cm4gT3ZlcmxheVN0YXRlO1xufSgpKTtcbi8qKlxuICogUmVmZXJlbmNlIHRvIGFuIG92ZXJsYXkgdGhhdCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggdGhlIE92ZXJsYXkgc2VydmljZS5cbiAqIFVzZWQgdG8gbWFuaXB1bGF0ZSBvciBkaXNwb3NlIG9mIHNhaWQgb3ZlcmxheS5cbiAqL1xudmFyIE92ZXJsYXlSZWYgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9wb3J0YWxIb3N0XG4gICAgICogQHBhcmFtIHs/fSBfcGFuZVxuICAgICAqIEBwYXJhbSB7P30gX3N0YXRlXG4gICAgICogQHBhcmFtIHs/fSBfc2Nyb2xsU3RyYXRlZ3lcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPdmVybGF5UmVmKF9wb3J0YWxIb3N0LCBfcGFuZSwgX3N0YXRlLCBfc2Nyb2xsU3RyYXRlZ3ksIF9uZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5fcG9ydGFsSG9zdCA9IF9wb3J0YWxIb3N0O1xuICAgICAgICB0aGlzLl9wYW5lID0gX3BhbmU7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gX3N0YXRlO1xuICAgICAgICB0aGlzLl9zY3JvbGxTdHJhdGVneSA9IF9zY3JvbGxTdHJhdGVneTtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BDbGljayA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5fZGV0YWNobWVudHMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICBfc2Nyb2xsU3RyYXRlZ3kuYXR0YWNoKHRoaXMpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3ZlcmxheVJlZi5wcm90b3R5cGUsIFwib3ZlcmxheUVsZW1lbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG92ZXJsYXkncyBIVE1MIGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhbmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBvdmVybGF5IHRvIGEgcG9ydGFsIGluc3RhbmNlIGFuZCBhZGRzIHRoZSBiYWNrZHJvcC5cbiAgICAgKiBAcGFyYW0gez99IHBvcnRhbCBQb3J0YWwgaW5zdGFuY2UgdG8gd2hpY2ggdG8gYXR0YWNoIHRoZSBvdmVybGF5LlxuICAgICAqIEByZXR1cm4gez99IFRoZSBwb3J0YWwgYXR0YWNobWVudCByZXN1bHQuXG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRhY2hSZXN1bHQgPSB0aGlzLl9wb3J0YWxIb3N0LmF0dGFjaChwb3J0YWwpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHBhbmUgZWxlbWVudCB3aXRoIHRoZSBnaXZlbiBzdGF0ZSBjb25maWd1cmF0aW9uLlxuICAgICAgICB0aGlzLl91cGRhdGVTdGFja2luZ09yZGVyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5LmVuYWJsZSgpO1xuICAgICAgICAvLyBFbmFibGUgcG9pbnRlciBldmVudHMgZm9yIHRoZSBvdmVybGF5IHBhbmUgZWxlbWVudC5cbiAgICAgICAgdGhpcy5fdG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmhhc0JhY2tkcm9wKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hCYWNrZHJvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5wYW5lbENsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lLmNsYXNzTGlzdC5hZGQodGhpcy5fc3RhdGUucGFuZWxDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBlbWl0IHRoZSBgYXR0YWNobWVudHNgIGV2ZW50IG9uY2UgYWxsIG90aGVyIHNldHVwIGlzIGRvbmUuXG4gICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGF0dGFjaFJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaGVzIGFuIG92ZXJsYXkgZnJvbSBhIHBvcnRhbC5cbiAgICAgKiBAcmV0dXJuIHs/fSBSZXNvbHZlcyB3aGVuIHRoZSBvdmVybGF5IGhhcyBiZWVuIGRldGFjaGVkLlxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXRhY2hCYWNrZHJvcCgpO1xuICAgICAgICAvLyBXaGVuIHRoZSBvdmVybGF5IGlzIGRldGFjaGVkLCB0aGUgcGFuZSBlbGVtZW50IHNob3VsZCBkaXNhYmxlIHBvaW50ZXIgZXZlbnRzLlxuICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIG90aGVyd2lzZSB0aGUgcGFuZSBlbGVtZW50IHdpbGwgY292ZXIgdGhlIHBhZ2UgYW5kIGRpc2FibGVcbiAgICAgICAgLy8gcG9pbnRlciBldmVudHMgdGhlcmVmb3JlLiBEZXBlbmRzIG9uIHRoZSBwb3NpdGlvbiBzdHJhdGVneSBhbmQgdGhlIGFwcGxpZWQgcGFuZSBib3VuZGFyaWVzLlxuICAgICAgICB0aGlzLl90b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kuZGlzYWJsZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhY2htZW50UmVzdWx0ID0gdGhpcy5fcG9ydGFsSG9zdC5kZXRhY2goKTtcbiAgICAgICAgLy8gT25seSBlbWl0IGFmdGVyIGV2ZXJ5dGhpbmcgaXMgZGV0YWNoZWQuXG4gICAgICAgIHRoaXMuX2RldGFjaG1lbnRzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGRldGFjaG1lbnRSZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgdGhlIG92ZXJsYXkgZnJvbSB0aGUgRE9NLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnBvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnBvc2l0aW9uU3RyYXRlZ3kuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxTdHJhdGVneSkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0YWNoQmFja2Ryb3AoKTtcbiAgICAgICAgdGhpcy5fcG9ydGFsSG9zdC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaG1lbnRzLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wQ2xpY2suY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5fZGV0YWNobWVudHMubmV4dCgpO1xuICAgICAgICB0aGlzLl9kZXRhY2htZW50cy5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIG92ZXJsYXkgaGFzIGJlZW4gYXR0YWNoZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5oYXNBdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbEhvc3QuaGFzQXR0YWNoZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdoZW4gdGhlIGJhY2tkcm9wIGhhcyBiZWVuIGNsaWNrZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5iYWNrZHJvcENsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2Ryb3BDbGljay5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdoZW4gdGhlIG92ZXJsYXkgaGFzIGJlZW4gYXR0YWNoZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5hdHRhY2htZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFjaG1lbnRzLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbiB0aGUgb3ZlcmxheSBoYXMgYmVlbiBkZXRhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmRldGFjaG1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGV0YWNobWVudHMuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRlIGNvbmZpZyBvZiB0aGUgb3ZlcmxheS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheSBiYXNlZCBvbiB0aGUgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnBvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnBvc2l0aW9uU3RyYXRlZ3kuYXBwbHkodGhpcy5fcGFuZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBvdmVybGF5IHBhbmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUudXBkYXRlRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wYW5lLnNldEF0dHJpYnV0ZSgnZGlyJywgLyoqIEB0eXBlIHs/fSAqLyAoKHRoaXMuX3N0YXRlLmRpcmVjdGlvbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhlIG92ZXJsYXkgYmFzZWQgb24gdGhlIG92ZXJsYXkgY29uZmlnLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLndpZHRoIHx8IHRoaXMuX3N0YXRlLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lLnN0eWxlLndpZHRoID0gZm9ybWF0Q3NzVW5pdCh0aGlzLl9zdGF0ZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmhlaWdodCB8fCB0aGlzLl9zdGF0ZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3BhbmUuc3R5bGUuaGVpZ2h0ID0gZm9ybWF0Q3NzVW5pdCh0aGlzLl9zdGF0ZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5taW5XaWR0aCB8fCB0aGlzLl9zdGF0ZS5taW5XaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGFuZS5zdHlsZS5taW5XaWR0aCA9IGZvcm1hdENzc1VuaXQodGhpcy5fc3RhdGUubWluV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5taW5IZWlnaHQgfHwgdGhpcy5fc3RhdGUubWluSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lLnN0eWxlLm1pbkhlaWdodCA9IGZvcm1hdENzc1VuaXQodGhpcy5fc3RhdGUubWluSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgcG9pbnRlciBldmVudHMgZm9yIHRoZSBvdmVybGF5IHBhbmUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IGVuYWJsZVBvaW50ZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLl90b2dnbGVQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKGVuYWJsZVBvaW50ZXIpIHtcbiAgICAgICAgdGhpcy5fcGFuZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gZW5hYmxlUG9pbnRlciA/ICdhdXRvJyA6ICdub25lJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgYmFja2Ryb3AgZm9yIHRoaXMgb3ZlcmxheS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLl9hdHRhY2hCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjZGstb3ZlcmxheS1iYWNrZHJvcCcpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuYmFja2Ryb3BDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BFbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5fc3RhdGUuYmFja2Ryb3BDbGFzcyk7XG4gICAgICAgIH0gLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAoKFxuICAgICAgICAvLyBJbnNlcnQgdGhlIGJhY2tkcm9wIGJlZm9yZSB0aGUgcGFuZSBpbiB0aGUgRE9NIG9yZGVyLFxuICAgICAgICAvLyBpbiBvcmRlciB0byBoYW5kbGUgc3RhY2tlZCBvdmVybGF5cyBwcm9wZXJseS5cbiAgICAgICAgdGhpcy5fcGFuZS5wYXJlbnRFbGVtZW50KSkuaW5zZXJ0QmVmb3JlKHRoaXMuX2JhY2tkcm9wRWxlbWVudCwgdGhpcy5fcGFuZSk7XG4gICAgICAgIC8vIEZvcndhcmQgYmFja2Ryb3AgY2xpY2tzIHN1Y2ggdGhhdCB0aGUgY29uc3VtZXIgb2YgdGhlIG92ZXJsYXkgY2FuIHBlcmZvcm0gd2hhdGV2ZXJcbiAgICAgICAgLy8gYWN0aW9uIGRlc2lyZWQgd2hlbiBzdWNoIGEgY2xpY2sgb2NjdXJzICh1c3VhbGx5IGNsb3NpbmcgdGhlIG92ZXJsYXkpLlxuICAgICAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYmFja2Ryb3BDbGljay5uZXh0KG51bGwpOyB9KTtcbiAgICAgICAgLy8gQWRkIGNsYXNzIHRvIGZhZGUtaW4gdGhlIGJhY2tkcm9wIGFmdGVyIG9uZSBmcmFtZS5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fYmFja2Ryb3BFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2JhY2tkcm9wRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjZGstb3ZlcmxheS1iYWNrZHJvcC1zaG93aW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc3RhY2tpbmcgb3JkZXIgb2YgdGhlIGVsZW1lbnQsIG1vdmluZyBpdCB0byB0aGUgdG9wIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBUaGlzIGlzIHJlcXVpcmVkIGluIGNhc2VzIHdoZXJlIG9uZSBvdmVybGF5IHdhcyBkZXRhY2hlZCwgd2hpbGUgYW5vdGhlciBvbmUsXG4gICAgICogdGhhdCBzaG91bGQgYmUgYmVoaW5kIGl0LCB3YXMgZGVzdHJveWVkLiBUaGUgbmV4dCB0aW1lIGJvdGggb2YgdGhlbSBhcmUgb3BlbmVkLFxuICAgICAqIHRoZSBzdGFja2luZyB3aWxsIGJlIHdyb25nLCBiZWNhdXNlIHRoZSBkZXRhY2hlZCBlbGVtZW50J3MgcGFuZSB3aWxsIHN0aWxsIGJlXG4gICAgICogaW4gaXRzIG9yaWdpbmFsIERPTSBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLl91cGRhdGVTdGFja2luZ09yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcGFuZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgKCh0aGlzLl9wYW5lLnBhcmVudE5vZGUpKS5hcHBlbmRDaGlsZCh0aGlzLl9wYW5lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgdGhlIGJhY2tkcm9wIChpZiBhbnkpIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3ZlcmxheS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmRldGFjaEJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYWNrZHJvcFRvRGV0YWNoID0gdGhpcy5fYmFja2Ryb3BFbGVtZW50O1xuICAgICAgICBpZiAoYmFja2Ryb3BUb0RldGFjaCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluaXNoRGV0YWNoXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgbWF5IG5vdCBiZSBhdHRhY2hlZCB0byBhbnl0aGluZyBpbiBjZXJ0YWluIGNhc2VzIChlLmcuIHVuaXQgdGVzdHMpLlxuICAgICAgICAgICAgICAgIGlmIChiYWNrZHJvcFRvRGV0YWNoICYmIGJhY2tkcm9wVG9EZXRhY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcFRvRGV0YWNoLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFja2Ryb3BUb0RldGFjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgYSBuZXcgcG9ydGFsIGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoaXMgb3ZlcmxheSBzaW5jZSB3ZSBzdGFydGVkXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIGJhY2tkcm9wLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCBvbmx5IGNsZWFyIHRoZSBiYWNrZHJvcCByZWZlcmVuY2UgaWYgaXRcbiAgICAgICAgICAgICAgICAvLyBpcyBzdGlsbCB0aGUgc2FtZSBpbnN0YW5jZSB0aGF0IHdlIHN0YXJ0ZWQgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fYmFja2Ryb3BFbGVtZW50ID09IGJhY2tkcm9wVG9EZXRhY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2JhY2tkcm9wRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJhY2tkcm9wVG9EZXRhY2guY2xhc3NMaXN0LnJlbW92ZSgnY2RrLW92ZXJsYXktYmFja2Ryb3Atc2hvd2luZycpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmJhY2tkcm9wQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBiYWNrZHJvcFRvRGV0YWNoLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fc3RhdGUuYmFja2Ryb3BDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYWNrZHJvcFRvRGV0YWNoLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmaW5pc2hEZXRhY2hfMSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYmFja2Ryb3AgZG9lc24ndCBoYXZlIGEgdHJhbnNpdGlvbiwgdGhlIGB0cmFuc2l0aW9uZW5kYCBldmVudCB3b24ndCBmaXJlLlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIG1ha2UgaXQgdW5jbGlja2FibGUgYW5kIHdlIHRyeSB0byByZW1vdmUgaXQgYWZ0ZXIgYSBkZWxheS5cbiAgICAgICAgICAgIGJhY2tkcm9wVG9EZXRhY2guc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIC8vIFJ1biB0aGlzIG91dHNpZGUgdGhlIEFuZ3VsYXIgem9uZSBiZWNhdXNlIHRoZXJlJ3Mgbm90aGluZyB0aGF0IEFuZ3VsYXIgY2FyZXMgYWJvdXQuXG4gICAgICAgICAgICAvLyBJZiBpdCB3ZXJlIHRvIHJ1biBpbnNpZGUgdGhlIEFuZ3VsYXIgem9uZSwgZXZlcnkgdGVzdCB0aGF0IHVzZWQgT3ZlcmxheSB3b3VsZCBoYXZlIHRvIGJlXG4gICAgICAgICAgICAvLyBlaXRoZXIgYXN5bmMgb3IgZmFrZUFzeW5jLlxuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZpbmlzaERldGFjaF8xLCA1MDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPdmVybGF5UmVmO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZm9ybWF0Q3NzVW5pdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gKHZhbHVlKSA6IHZhbHVlICsgXCJweFwiO1xufVxuLyoqIEhvcml6b250YWwgZGltZW5zaW9uIG9mIGEgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgcGVyaW1ldGVyIG9mIHRoZSBvcmlnaW4gb3Igb3ZlcmxheSBlbGVtZW50LiAqL1xuLyoqXG4gKiBUaGUgcG9pbnRzIG9mIHRoZSBvcmlnaW4gZWxlbWVudCBhbmQgdGhlIG92ZXJsYXkgZWxlbWVudCB0byBjb25uZWN0LlxuICovXG52YXIgQ29ubmVjdGlvblBvc2l0aW9uUGFpciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luXG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvblBvc2l0aW9uUGFpcihvcmlnaW4sIG92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gb3JpZ2luLm9yaWdpblg7XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IG9yaWdpbi5vcmlnaW5ZO1xuICAgICAgICB0aGlzLm92ZXJsYXlYID0gb3ZlcmxheS5vdmVybGF5WDtcbiAgICAgICAgdGhpcy5vdmVybGF5WSA9IG92ZXJsYXkub3ZlcmxheVk7XG4gICAgfVxuICAgIHJldHVybiBDb25uZWN0aW9uUG9zaXRpb25QYWlyO1xufSgpKTtcbi8qKlxuICogU2V0IG9mIHByb3BlcnRpZXMgcmVnYXJkaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3JpZ2luIGFuZCBvdmVybGF5IHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydFxuICogd2l0aCByZXNwZWN0IHRvIHRoZSBjb250YWluaW5nIFNjcm9sbGFibGUgZWxlbWVudHMuXG4gKlxuICogVGhlIG92ZXJsYXkgYW5kIG9yaWdpbiBhcmUgY2xpcHBlZCBpZiBhbnkgcGFydCBvZiB0aGVpciBib3VuZGluZyBjbGllbnQgcmVjdGFuZ2xlIGV4Y2VlZHMgdGhlXG4gKiBib3VuZHMgb2YgYW55IG9uZSBvZiB0aGUgc3RyYXRlZ3kncyBTY3JvbGxhYmxlJ3MgYm91bmRpbmcgY2xpZW50IHJlY3RhbmdsZS5cbiAqXG4gKiBUaGUgb3ZlcmxheSBhbmQgb3JpZ2luIGFyZSBvdXRzaWRlIHZpZXcgaWYgdGhlcmUgaXMgbm8gb3ZlcmxhcCBiZXR3ZWVuIHRoZWlyIGJvdW5kaW5nIGNsaWVudFxuICogcmVjdGFuZ2xlIGFuZCBhbnkgb25lIG9mIHRoZSBzdHJhdGVneSdzIFNjcm9sbGFibGUncyBib3VuZGluZyBjbGllbnQgcmVjdGFuZ2xlLlxuICpcbiAqICAgICAgIC0tLS0tLS0tLS0tICAgICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLVxuICogICAgICAgfCBvdXRzaWRlIHwgICAgICAgICAgICAgICAgICAgIHwgY2xpcHBlZCB8XG4gKiAgICAgICB8ICB2aWV3ICAgfCAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICAgICAgIHwgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICB8ICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgLS0tLS0tLS0tLSAgICAgICAgICAgICAgIHwgICAgIC0tLS0tLS0tLS0tICAgICAgICB8XG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8ICAgICAgU2Nyb2xsYWJsZSAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgfCAgICAgIFNjcm9sbGFibGUgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbnZhciBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMoKSB7XG4gICAgfVxuICAgIHJldHVybiBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXM7XG59KCkpO1xuLyoqXG4gKiBUaGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgYnkgdGhlIHN0cmF0ZWd5IHdoZW4gYSBmYWxsYmFjayBwb3NpdGlvbiBpcyB1c2VkLlxuICovXG52YXIgQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb25uZWN0aW9uUGFpclxuICAgICAqIEBwYXJhbSB7P30gc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlKGNvbm5lY3Rpb25QYWlyLCBzY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUGFpciA9IGNvbm5lY3Rpb25QYWlyO1xuICAgICAgICB0aGlzLnNjcm9sbGFibGVWaWV3UHJvcGVydGllcyA9IHNjcm9sbGFibGVWaWV3UHJvcGVydGllcztcbiAgICB9XG4gICAgcmV0dXJuIENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZTtcbn0oKSk7XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIsIH0sXG4gICAgeyB0eXBlOiBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbi8qKlxuICogQSBzdHJhdGVneSBmb3IgcG9zaXRpb25pbmcgb3ZlcmxheXMuIFVzaW5nIHRoaXMgc3RyYXRlZ3ksIGFuIG92ZXJsYXkgaXMgZ2l2ZW4gYW5cbiAqIGltcGxpY2l0IHBvc2l0aW9uIHJlbGF0aXZlIHNvbWUgb3JpZ2luIGVsZW1lbnQuIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBkZWZpbmVkIGluIHRlcm1zIG9mXG4gKiBhIHBvaW50IG9uIHRoZSBvcmlnaW4gZWxlbWVudCB0aGF0IGlzIGNvbm5lY3RlZCB0byBhIHBvaW50IG9uIHRoZSBvdmVybGF5IGVsZW1lbnQuIEZvciBleGFtcGxlLFxuICogYSBiYXNpYyBkcm9wZG93biBpcyBjb25uZWN0aW5nIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIG9yaWdpbiB0byB0aGUgdG9wLWxlZnQgY29ybmVyXG4gKiBvZiB0aGUgb3ZlcmxheS5cbiAqL1xudmFyIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb25uZWN0ZWRUb1xuICAgICAqIEBwYXJhbSB7P30gX29yaWdpblBvc1xuICAgICAqIEBwYXJhbSB7P30gX292ZXJsYXlQb3NcbiAgICAgKiBAcGFyYW0gez99IF92aWV3cG9ydFJ1bGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneShfY29ubmVjdGVkVG8sIF9vcmlnaW5Qb3MsIF9vdmVybGF5UG9zLCBfdmlld3BvcnRSdWxlcikge1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWRUbyA9IF9jb25uZWN0ZWRUbztcbiAgICAgICAgdGhpcy5fb3JpZ2luUG9zID0gX29yaWdpblBvcztcbiAgICAgICAgdGhpcy5fb3ZlcmxheVBvcyA9IF9vdmVybGF5UG9zO1xuICAgICAgICB0aGlzLl92aWV3cG9ydFJ1bGVyID0gX3ZpZXdwb3J0UnVsZXI7XG4gICAgICAgIHRoaXMuX2RpciA9ICdsdHInO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9mZnNldCBpbiBwaXhlbHMgZm9yIHRoZSBvdmVybGF5IGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHgtYXhpc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb2Zmc2V0WCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIG92ZXJsYXkgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgeS1heGlzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vZmZzZXRZID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBTY3JvbGxhYmxlIGNvbnRhaW5lcnMgdXNlZCB0byBjaGVjayBzY3JvbGxhYmxlIHZpZXcgcHJvcGVydGllcyBvbiBwb3NpdGlvbiBjaGFuZ2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbGFibGVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcmRlcmVkIGxpc3Qgb2YgcHJlZmVycmVkIHBvc2l0aW9ucywgZnJvbSBtb3N0IHRvIGxlYXN0IGRlc2lyYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9vblBvc2l0aW9uQ2hhbmdlID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gdGhpcy5fY29ubmVjdGVkVG8ubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy53aXRoRmFsbGJhY2tQb3NpdGlvbihfb3JpZ2luUG9zLCBfb3ZlcmxheVBvcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZSwgXCJfaXNSdGxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgd2UncmUgZGVhbGluZyB3aXRoIGFuIFJUTCBjb250ZXh0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXIgPT09ICdydGwnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUsIFwib25Qb3NpdGlvbkNoYW5nZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBjb25uZWN0aW9uIHBvaW50IGNoYW5nZXMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vblBvc2l0aW9uQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUsIFwicG9zaXRpb25zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9yZGVyZWQgbGlzdCBvZiBwcmVmZXJyZWQgcG9zaXRpb25zLCBmcm9tIG1vc3QgdG8gbGVhc3QgZGVzaXJhYmxlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUbyBiZSB1c2VkIHRvIGZvciBhbnkgY2xlYW51cCBhZnRlciB0aGUgZWxlbWVudCBnZXRzIGRlc3Ryb3llZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgZWxlbWVudCwgdXNpbmcgd2hpY2hldmVyIHByZWZlcnJlZCBwb3NpdGlvbiByZWxhdGl2ZVxuICAgICAqIHRvIHRoZSBvcmlnaW4gZml0cyBvbi1zY3JlZW4uXG4gICAgICogXFxAZG9jcy1wcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgRWxlbWVudCB0byB3aGljaCB0byBhcHBseSB0aGUgQ1NTIHN0eWxlcy5cbiAgICAgKiBAcmV0dXJuIHs/fSBSZXNvbHZlcyB3aGVuIHRoZSBzdHlsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvLyBDYWNoZSB0aGUgb3ZlcmxheSBwYW5lIGVsZW1lbnQgaW4gY2FzZSByZS1jYWxjdWxhdGluZyBwb3NpdGlvbiBpcyBuZWNlc3NhcnlcbiAgICAgICAgdGhpcy5fcGFuZSA9IGVsZW1lbnQ7XG4gICAgICAgIC8vIFdlIG5lZWQgdGhlIGJvdW5kaW5nIHJlY3RzIGZvciB0aGUgb3JpZ2luIGFuZCB0aGUgb3ZlcmxheSB0byBkZXRlcm1pbmUgaG93IHRvIHBvc2l0aW9uXG4gICAgICAgIC8vIHRoZSBvdmVybGF5IHJlbGF0aXZlIHRvIHRoZSBvcmlnaW4uXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpblJlY3QgPSB0aGlzLl9vcmlnaW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gV2UgdXNlIHRoZSB2aWV3cG9ydCByZWN0IHRvIGRldGVybWluZSB3aGV0aGVyIGEgcG9zaXRpb24gd291bGQgZ28gb2ZmLXNjcmVlbi5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld3BvcnRSZWN0ID0gdGhpcy5fdmlld3BvcnRSdWxlci5nZXRWaWV3cG9ydFJlY3QoKTtcbiAgICAgICAgLy8gRmFsbGJhY2sgcG9pbnQgaWYgbm9uZSBvZiB0aGUgZmFsbGJhY2tzIGZpdCBpbnRvIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmFsbGJhY2tQb2ludDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmFsbGJhY2tQb3NpdGlvbjtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBwbGFjZSB0aGUgb3ZlcmxheSBpbiB0aGUgZmlyc3Qgb2YgdGhlIHByZWZlcnJlZCBwb3NpdGlvbnMgc3VjaCB0aGF0IHRoZVxuICAgICAgICAvLyBvdmVybGF5IGZpdHMgb24tc2NyZWVuLlxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IF9hW19pXTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgKHgsIHkpIHBvaW50IG9mIGNvbm5lY3Rpb24gb24gdGhlIG9yaWdpbiwgYW5kIHRoZW4gdXNlIHRoYXQgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgLy8gKHRvcCwgbGVmdCkgY29vcmRpbmF0ZSBmb3IgdGhlIG92ZXJsYXkgYXQgYHBvc2AuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5Qb2ludCA9IHRoaXMuX2dldE9yaWdpbkNvbm5lY3Rpb25Qb2ludChvcmlnaW5SZWN0LCBwb3MpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3ZlcmxheVBvaW50ID0gdGhpcy5fZ2V0T3ZlcmxheVBvaW50KG9yaWdpblBvaW50LCBvdmVybGF5UmVjdCwgdmlld3BvcnRSZWN0LCBwb3MpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG92ZXJsYXkgaW4gdGhlIGNhbGN1bGF0ZWQgcG9zaXRpb24gZml0cyBvbi1zY3JlZW4sIHB1dCBpdCB0aGVyZSBhbmQgd2UncmUgZG9uZS5cbiAgICAgICAgICAgIGlmIChvdmVybGF5UG9pbnQuZml0c0luVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50UG9zaXRpb24oZWxlbWVudCwgb3ZlcmxheVJlY3QsIG92ZXJsYXlQb2ludCwgcG9zKTtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGNvbm5lY3RlZCBwb3NpdGlvbiBpbiBjYXNlIHRoZSBwb3NpdGlvbiBuZWVkcyB0byBiZSByZS1jYWxjdWxhdGVkLlxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RDb25uZWN0ZWRQb3NpdGlvbiA9IHBvcztcbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgdGhhdCB0aGUgcG9zaXRpb24gaGFzIGJlZW4gY2hhbmdlZCBhbG9uZyB3aXRoIGl0cyBjaGFuZ2UgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMgPSB0aGlzLmdldFNjcm9sbGFibGVWaWV3UHJvcGVydGllcyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3NpdGlvbkNoYW5nZSA9IG5ldyBDb25uZWN0ZWRPdmVybGF5UG9zaXRpb25DaGFuZ2UocG9zLCBzY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uUG9zaXRpb25DaGFuZ2UubmV4dChwb3NpdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZhbGxiYWNrUG9pbnQgfHwgZmFsbGJhY2tQb2ludC52aXNpYmxlQXJlYSA8IG92ZXJsYXlQb2ludC52aXNpYmxlQXJlYSkge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrUG9pbnQgPSBvdmVybGF5UG9pbnQ7XG4gICAgICAgICAgICAgICAgZmFsbGJhY2tQb3NpdGlvbiA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBwcmVmZXJyZWQgcG9zaXRpb25zIHdlcmUgaW4gdGhlIHZpZXdwb3J0LCB0YWtlIHRoZSBvbmVcbiAgICAgICAgLy8gd2l0aCB0aGUgbGFyZ2VzdCB2aXNpYmxlIGFyZWEuXG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRQb3NpdGlvbihlbGVtZW50LCBvdmVybGF5UmVjdCwgLyoqIEB0eXBlIHs/fSAqLyAoKGZhbGxiYWNrUG9pbnQpKSwgLyoqIEB0eXBlIHs/fSAqLyAoKGZhbGxiYWNrUG9zaXRpb24pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHJlLWFsaWducyB0aGUgb3ZlcmxheSBlbGVtZW50IHdpdGggdGhlIHRyaWdnZXIgaW4gaXRzIGxhc3QgY2FsY3VsYXRlZCBwb3NpdGlvbixcbiAgICAgKiBldmVuIGlmIGEgcG9zaXRpb24gaGlnaGVyIGluIHRoZSBcInByZWZlcnJlZCBwb3NpdGlvbnNcIiBsaXN0IHdvdWxkIG5vdyBmaXQuIFRoaXNcbiAgICAgKiBhbGxvd3Mgb25lIHRvIHJlLWFsaWduIHRoZSBwYW5lbCB3aXRob3V0IGNoYW5naW5nIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcGFuZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5yZWNhbGN1bGF0ZUxhc3RQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luUmVjdCA9IHRoaXMuX29yaWdpbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3ZlcmxheVJlY3QgPSB0aGlzLl9wYW5lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3cG9ydFJlY3QgPSB0aGlzLl92aWV3cG9ydFJ1bGVyLmdldFZpZXdwb3J0UmVjdCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0UG9zaXRpb24gPSB0aGlzLl9sYXN0Q29ubmVjdGVkUG9zaXRpb24gfHwgdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zWzBdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5Qb2ludCA9IHRoaXMuX2dldE9yaWdpbkNvbm5lY3Rpb25Qb2ludChvcmlnaW5SZWN0LCBsYXN0UG9zaXRpb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5UG9pbnQgPSB0aGlzLl9nZXRPdmVybGF5UG9pbnQob3JpZ2luUG9pbnQsIG92ZXJsYXlSZWN0LCB2aWV3cG9ydFJlY3QsIGxhc3RQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRQb3NpdGlvbih0aGlzLl9wYW5lLCBvdmVybGF5UmVjdCwgb3ZlcmxheVBvaW50LCBsYXN0UG9zaXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBvZiBTY3JvbGxhYmxlIGNvbnRhaW5lcnMgdGhhdCBob3N0IHRoZSBvcmlnaW4gZWxlbWVudCBzbyB0aGF0XG4gICAgICogb24gcmVwb3NpdGlvbiB3ZSBjYW4gZXZhbHVhdGUgaWYgaXQgb3IgdGhlIG92ZXJsYXkgaGFzIGJlZW4gY2xpcHBlZCBvciBvdXRzaWRlIHZpZXcuIEV2ZXJ5XG4gICAgICogU2Nyb2xsYWJsZSBtdXN0IGJlIGFuIGFuY2VzdG9yIGVsZW1lbnQgb2YgdGhlIHN0cmF0ZWd5J3Mgb3JpZ2luIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxhYmxlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUud2l0aFNjcm9sbGFibGVDb250YWluZXJzID0gZnVuY3Rpb24gKHNjcm9sbGFibGVzKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZXMgPSBzY3JvbGxhYmxlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgcHJlZmVycmVkIGZhbGxiYWNrIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luUG9zXG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5UG9zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS53aXRoRmFsbGJhY2tQb3NpdGlvbiA9IGZ1bmN0aW9uIChvcmlnaW5Qb3MsIG92ZXJsYXlQb3MpIHtcbiAgICAgICAgdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zLnB1c2gobmV3IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIob3JpZ2luUG9zLCBvdmVybGF5UG9zKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGF5b3V0IGRpcmVjdGlvbiBzbyB0aGUgb3ZlcmxheSdzIHBvc2l0aW9uIGNhbiBiZSBhZGp1c3RlZCB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0gez99IGRpciBOZXcgbGF5b3V0IGRpcmVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLndpdGhEaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIHRoaXMuX2RpciA9IGRpcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIG9mZnNldCBmb3IgdGhlIG92ZXJsYXkncyBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB4LWF4aXNcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldCBOZXcgb2Zmc2V0IGluIHRoZSBYIGF4aXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS53aXRoT2Zmc2V0WCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WCA9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIG9mZnNldCBmb3IgdGhlIG92ZXJsYXkncyBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB5LWF4aXNcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldCBOZXcgb2Zmc2V0IGluIHRoZSBZIGF4aXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS53aXRoT2Zmc2V0WSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBob3Jpem9udGFsICh4KSBcInN0YXJ0XCIgZGltZW5zaW9uIGJhc2VkIG9uIHdoZXRoZXIgdGhlIG92ZXJsYXkgaXMgaW4gYW4gUlRMIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHs/fSByZWN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fZ2V0U3RhcnRYID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUnRsID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhvcml6b250YWwgKHgpIFwiZW5kXCIgZGltZW5zaW9uIGJhc2VkIG9uIHdoZXRoZXIgdGhlIG92ZXJsYXkgaXMgaW4gYW4gUlRMIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHs/fSByZWN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fZ2V0RW5kWCA9IGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1J0bCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSAoeCwgeSkgY29vcmRpbmF0ZSBvZiBhIGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIG9yaWdpbiBiYXNlZCBvbiBhIHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luUmVjdFxuICAgICAqIEBwYXJhbSB7P30gcG9zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fZ2V0T3JpZ2luQ29ubmVjdGlvblBvaW50ID0gZnVuY3Rpb24gKG9yaWdpblJlY3QsIHBvcykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5TdGFydFggPSB0aGlzLl9nZXRTdGFydFgob3JpZ2luUmVjdCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpbkVuZFggPSB0aGlzLl9nZXRFbmRYKG9yaWdpblJlY3QpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4O1xuICAgICAgICBpZiAocG9zLm9yaWdpblggPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHggPSBvcmlnaW5TdGFydFggKyAob3JpZ2luUmVjdC53aWR0aCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCA9IHBvcy5vcmlnaW5YID09ICdzdGFydCcgPyBvcmlnaW5TdGFydFggOiBvcmlnaW5FbmRYO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHk7XG4gICAgICAgIGlmIChwb3Mub3JpZ2luWSA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgeSA9IG9yaWdpblJlY3QudG9wICsgKG9yaWdpblJlY3QuaGVpZ2h0IC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ID0gcG9zLm9yaWdpblkgPT0gJ3RvcCcgPyBvcmlnaW5SZWN0LnRvcCA6IG9yaWdpblJlY3QuYm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlICh4LCB5KSBjb29yZGluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIG92ZXJsYXkgZ2l2ZW4gYSBnaXZlbiBwb3NpdGlvbiBhbmRcbiAgICAgKiBvcmlnaW4gcG9pbnQgdG8gd2hpY2ggdGhlIG92ZXJsYXkgc2hvdWxkIGJlIGNvbm5lY3RlZCwgYXMgd2VsbCBhcyBob3cgbXVjaCBvZiB0aGUgZWxlbWVudFxuICAgICAqIHdvdWxkIGJlIGluc2lkZSB0aGUgdmlld3BvcnQgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gez99IG9yaWdpblBvaW50XG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5UmVjdFxuICAgICAqIEBwYXJhbSB7P30gdmlld3BvcnRSZWN0XG4gICAgICogQHBhcmFtIHs/fSBwb3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRPdmVybGF5UG9pbnQgPSBmdW5jdGlvbiAob3JpZ2luUG9pbnQsIG92ZXJsYXlSZWN0LCB2aWV3cG9ydFJlY3QsIHBvcykge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIChvdmVybGF5U3RhcnRYLCBvdmVybGF5U3RhcnRZKSwgdGhlIHN0YXJ0IG9mIHRoZSBwb3RlbnRpYWwgb3ZlcmxheSBwb3NpdGlvblxuICAgICAgICAvLyByZWxhdGl2ZSB0byB0aGUgb3JpZ2luIHBvaW50LlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5U3RhcnRYO1xuICAgICAgICBpZiAocG9zLm92ZXJsYXlYID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBvdmVybGF5U3RhcnRYID0gLW92ZXJsYXlSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3Mub3ZlcmxheVggPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFggPSB0aGlzLl9pc1J0bCA/IC1vdmVybGF5UmVjdC53aWR0aCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdmVybGF5U3RhcnRYID0gdGhpcy5faXNSdGwgPyAwIDogLW92ZXJsYXlSZWN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlTdGFydFk7XG4gICAgICAgIGlmIChwb3Mub3ZlcmxheVkgPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFkgPSAtb3ZlcmxheVJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFkgPSBwb3Mub3ZlcmxheVkgPT0gJ3RvcCcgPyAwIDogLW92ZXJsYXlSZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgKHgsIHkpIGNvb3JkaW5hdGVzIG9mIHRoZSBvdmVybGF5LlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4ID0gb3JpZ2luUG9pbnQueCArIG92ZXJsYXlTdGFydFggKyB0aGlzLl9vZmZzZXRYO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB5ID0gb3JpZ2luUG9pbnQueSArIG92ZXJsYXlTdGFydFkgKyB0aGlzLl9vZmZzZXRZO1xuICAgICAgICAvLyBIb3cgbXVjaCB0aGUgb3ZlcmxheSB3b3VsZCBvdmVyZmxvdyBhdCB0aGlzIHBvc2l0aW9uLCBvbiBlYWNoIHNpZGUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlZnRPdmVyZmxvdyA9IDAgLSB4O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaWdodE92ZXJmbG93ID0gKHggKyBvdmVybGF5UmVjdC53aWR0aCkgLSB2aWV3cG9ydFJlY3Qud2lkdGg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvcE92ZXJmbG93ID0gMCAtIHk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdHRvbU92ZXJmbG93ID0gKHkgKyBvdmVybGF5UmVjdC5oZWlnaHQpIC0gdmlld3BvcnRSZWN0LmhlaWdodDtcbiAgICAgICAgLy8gVmlzaWJsZSBwYXJ0cyBvZiB0aGUgZWxlbWVudCBvbiBlYWNoIGF4aXMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2libGVXaWR0aCA9IHRoaXMuX3N1YnRyYWN0T3ZlcmZsb3dzKG92ZXJsYXlSZWN0LndpZHRoLCBsZWZ0T3ZlcmZsb3csIHJpZ2h0T3ZlcmZsb3cpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpYmxlSGVpZ2h0ID0gdGhpcy5fc3VidHJhY3RPdmVyZmxvd3Mob3ZlcmxheVJlY3QuaGVpZ2h0LCB0b3BPdmVyZmxvdywgYm90dG9tT3ZlcmZsb3cpO1xuICAgICAgICAvLyBUaGUgYXJlYSBvZiB0aGUgZWxlbWVudCB0aGF0J3Mgd2l0aGluIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaWJsZUFyZWEgPSB2aXNpYmxlV2lkdGggKiB2aXNpYmxlSGVpZ2h0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaXRzSW5WaWV3cG9ydCA9IChvdmVybGF5UmVjdC53aWR0aCAqIG92ZXJsYXlSZWN0LmhlaWdodCkgPT09IHZpc2libGVBcmVhO1xuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCBmaXRzSW5WaWV3cG9ydDogZml0c0luVmlld3BvcnQsIHZpc2libGVBcmVhOiB2aXNpYmxlQXJlYSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldyBwcm9wZXJ0aWVzIG9mIHRoZSB0cmlnZ2VyIGFuZCBvdmVybGF5LCBpbmNsdWRpbmcgd2hldGhlciB0aGV5IGFyZSBjbGlwcGVkXG4gICAgICogb3IgY29tcGxldGVseSBvdXRzaWRlIHRoZSB2aWV3IG9mIGFueSBvZiB0aGUgc3RyYXRlZ3kncyBzY3JvbGxhYmxlcy5cbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmdldFNjcm9sbGFibGVWaWV3UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvdmVybGF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpbkJvdW5kcyA9IHRoaXMuX2dldEVsZW1lbnRCb3VuZHModGhpcy5fb3JpZ2luKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3ZlcmxheUJvdW5kcyA9IHRoaXMuX2dldEVsZW1lbnRCb3VuZHMob3ZlcmxheSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcm9sbENvbnRhaW5lckJvdW5kcyA9IHRoaXMuc2Nyb2xsYWJsZXMubWFwKGZ1bmN0aW9uIChzY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2dldEVsZW1lbnRCb3VuZHMoc2Nyb2xsYWJsZS5nZXRFbGVtZW50UmVmKCkubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNPcmlnaW5DbGlwcGVkOiB0aGlzLmlzRWxlbWVudENsaXBwZWQob3JpZ2luQm91bmRzLCBzY3JvbGxDb250YWluZXJCb3VuZHMpLFxuICAgICAgICAgICAgaXNPcmlnaW5PdXRzaWRlVmlldzogdGhpcy5pc0VsZW1lbnRPdXRzaWRlVmlldyhvcmlnaW5Cb3VuZHMsIHNjcm9sbENvbnRhaW5lckJvdW5kcyksXG4gICAgICAgICAgICBpc092ZXJsYXlDbGlwcGVkOiB0aGlzLmlzRWxlbWVudENsaXBwZWQob3ZlcmxheUJvdW5kcywgc2Nyb2xsQ29udGFpbmVyQm91bmRzKSxcbiAgICAgICAgICAgIGlzT3ZlcmxheU91dHNpZGVWaWV3OiB0aGlzLmlzRWxlbWVudE91dHNpZGVWaWV3KG92ZXJsYXlCb3VuZHMsIHNjcm9sbENvbnRhaW5lckJvdW5kcyksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGNvbXBsZXRlbHkgb3V0IG9mIHRoZSB2aWV3IG9mIGFueSBvZiB0aGUgY29udGFpbmVycy5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRCb3VuZHNcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lcnNCb3VuZHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmlzRWxlbWVudE91dHNpZGVWaWV3ID0gZnVuY3Rpb24gKGVsZW1lbnRCb3VuZHMsIGNvbnRhaW5lcnNCb3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcnNCb3VuZHMuc29tZShmdW5jdGlvbiAoY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRzaWRlQWJvdmUgPSBlbGVtZW50Qm91bmRzLmJvdHRvbSA8IGNvbnRhaW5lckJvdW5kcy50b3A7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRzaWRlQmVsb3cgPSBlbGVtZW50Qm91bmRzLnRvcCA+IGNvbnRhaW5lckJvdW5kcy5ib3R0b207XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRzaWRlTGVmdCA9IGVsZW1lbnRCb3VuZHMucmlnaHQgPCBjb250YWluZXJCb3VuZHMubGVmdDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHNpZGVSaWdodCA9IGVsZW1lbnRCb3VuZHMubGVmdCA+IGNvbnRhaW5lckJvdW5kcy5yaWdodDtcbiAgICAgICAgICAgIHJldHVybiBvdXRzaWRlQWJvdmUgfHwgb3V0c2lkZUJlbG93IHx8IG91dHNpZGVMZWZ0IHx8IG91dHNpZGVSaWdodDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGNsaXBwZWQgYnkgYW55IG9mIHRoZSBjb250YWluZXJzLlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudEJvdW5kc1xuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyc0JvdW5kc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuaXNFbGVtZW50Q2xpcHBlZCA9IGZ1bmN0aW9uIChlbGVtZW50Qm91bmRzLCBjb250YWluZXJzQm91bmRzKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXJzQm91bmRzLnNvbWUoZnVuY3Rpb24gKGNvbnRhaW5lckJvdW5kcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xpcHBlZEFib3ZlID0gZWxlbWVudEJvdW5kcy50b3AgPCBjb250YWluZXJCb3VuZHMudG9wO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xpcHBlZEJlbG93ID0gZWxlbWVudEJvdW5kcy5ib3R0b20gPiBjb250YWluZXJCb3VuZHMuYm90dG9tO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xpcHBlZExlZnQgPSBlbGVtZW50Qm91bmRzLmxlZnQgPCBjb250YWluZXJCb3VuZHMubGVmdDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsaXBwZWRSaWdodCA9IGVsZW1lbnRCb3VuZHMucmlnaHQgPiBjb250YWluZXJCb3VuZHMucmlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gY2xpcHBlZEFib3ZlIHx8IGNsaXBwZWRCZWxvdyB8fCBjbGlwcGVkTGVmdCB8fCBjbGlwcGVkUmlnaHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGh5c2ljYWxseSBwb3NpdGlvbnMgdGhlIG92ZXJsYXkgZWxlbWVudCB0byB0aGUgZ2l2ZW4gY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlSZWN0XG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5UG9pbnRcbiAgICAgKiBAcGFyYW0gez99IHBvc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuX3NldEVsZW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBvdmVybGF5UmVjdCwgb3ZlcmxheVBvaW50LCBwb3MpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBzZXQgZWl0aGVyIGB0b3BgIG9yIGBib3R0b21gIGJhc2VkIG9uIHdoZXRoZXIgdGhlIG92ZXJsYXkgd2FudHMgdG8gYXBwZWFyIGFib3ZlXG4gICAgICAgIC8vIG9yIGJlbG93IHRoZSBvcmlnaW4gYW5kIHRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIGVsZW1lbnQgd2lsbCBleHBhbmQuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZlcnRpY2FsU3R5bGVQcm9wZXJ0eSA9IHBvcy5vdmVybGF5WSA9PT0gJ2JvdHRvbScgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAvLyBXaGVuIHVzaW5nIGBib3R0b21gLCB3ZSBhZGp1c3QgdGhlIHkgcG9zaXRpb24gc3VjaCB0aGF0IGl0IGlzIHRoZSBkaXN0YW5jZVxuICAgICAgICAvLyBmcm9tIHRoZSBib3R0b20gb2YgdGhlIHZpZXdwb3J0IHJhdGhlciB0aGFuIHRoZSB0b3AuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHkgPSB2ZXJ0aWNhbFN0eWxlUHJvcGVydHkgPT09ICd0b3AnID9cbiAgICAgICAgICAgIG92ZXJsYXlQb2ludC55IDpcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgLSAob3ZlcmxheVBvaW50LnkgKyBvdmVybGF5UmVjdC5oZWlnaHQpO1xuICAgICAgICAvLyBXZSB3YW50IHRvIHNldCBlaXRoZXIgYGxlZnRgIG9yIGByaWdodGAgYmFzZWQgb24gd2hldGhlciB0aGUgb3ZlcmxheSB3YW50cyB0byBhcHBlYXIgXCJiZWZvcmVcIlxuICAgICAgICAvLyBvciBcImFmdGVyXCIgdGhlIG9yaWdpbiwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgZGlyZWN0aW9uIGluIHdoaWNoIHRoZSBlbGVtZW50IHdpbGwgZXhwYW5kLlxuICAgICAgICAvLyBGb3IgdGhlIGhvcml6b250YWwgYXhpcywgdGhlIG1lYW5pbmcgb2YgXCJiZWZvcmVcIiBhbmQgXCJhZnRlclwiIGNoYW5nZSBiYXNlZCBvbiB3aGV0aGVyIHRoZVxuICAgICAgICAvLyBwYWdlIGlzIGluIFJUTCBvciBMVFIuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvcml6b250YWxTdHlsZVByb3BlcnR5O1xuICAgICAgICBpZiAodGhpcy5fZGlyID09PSAncnRsJykge1xuICAgICAgICAgICAgaG9yaXpvbnRhbFN0eWxlUHJvcGVydHkgPSBwb3Mub3ZlcmxheVggPT09ICdlbmQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvcml6b250YWxTdHlsZVByb3BlcnR5ID0gcG9zLm92ZXJsYXlYID09PSAnZW5kJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB3ZSdyZSBzZXR0aW5nIGByaWdodGAsIHdlIGFkanVzdCB0aGUgeCBwb3NpdGlvbiBzdWNoIHRoYXQgaXQgaXMgdGhlIGRpc3RhbmNlXG4gICAgICAgIC8vIGZyb20gdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IHJhdGhlciB0aGFuIHRoZSBsZWZ0IGVkZ2UuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHggPSBob3Jpem9udGFsU3R5bGVQcm9wZXJ0eSA9PT0gJ2xlZnQnID9cbiAgICAgICAgICAgIG92ZXJsYXlQb2ludC54IDpcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIChvdmVybGF5UG9pbnQueCArIG92ZXJsYXlSZWN0LndpZHRoKTtcbiAgICAgICAgLy8gUmVzZXQgYW55IGV4aXN0aW5nIHN0eWxlcy4gVGhpcyBpcyBuZWNlc3NhcnkgaW4gY2FzZSB0aGUgcHJlZmVycmVkIHBvc2l0aW9uIGhhc1xuICAgICAgICAvLyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGBhcHBseWAuXG4gICAgICAgIFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gZWxlbWVudC5zdHlsZVtwXSA9IG51bGw7IH0pO1xuICAgICAgICBlbGVtZW50LnN0eWxlW3ZlcnRpY2FsU3R5bGVQcm9wZXJ0eV0gPSB5ICsgXCJweFwiO1xuICAgICAgICBlbGVtZW50LnN0eWxlW2hvcml6b250YWxTdHlsZVByb3BlcnR5XSA9IHggKyBcInB4XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBwb3NpdGlvbnMgb2YgdGhlIHByb3ZpZGVkIGVsZW1lbnQgd2l0aCByZXNwZWN0IHRvIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRFbGVtZW50Qm91bmRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm91bmRpbmdDbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogYm91bmRpbmdDbGllbnRSZWN0LnRvcCxcbiAgICAgICAgICAgIHJpZ2h0OiBib3VuZGluZ0NsaWVudFJlY3QubGVmdCArIGJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgIGJvdHRvbTogYm91bmRpbmdDbGllbnRSZWN0LnRvcCArIGJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiBib3VuZGluZ0NsaWVudFJlY3QubGVmdFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHRoZSBhbW91bnQgdGhhdCBhbiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIG9uIGFuIGF4aXMgZnJvbSBpdCdzIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0gez99IGxlbmd0aFxuICAgICAqIEBwYXJhbSB7Li4uP30gb3ZlcmZsb3dzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fc3VidHJhY3RPdmVyZmxvd3MgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBvdmVyZmxvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG92ZXJmbG93c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcmZsb3dzLnJlZHVjZShmdW5jdGlvbiAoY3VycmVudFZhbHVlLCBjdXJyZW50T3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUgLSBNYXRoLm1heChjdXJyZW50T3ZlcmZsb3csIDApO1xuICAgICAgICB9LCBsZW5ndGgpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG59KCkpO1xuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBwb3NpdGlvbmluZyBvdmVybGF5cy4gVXNpbmcgdGhpcyBzdHJhdGVneSwgYW4gb3ZlcmxheSBpcyBnaXZlbiBhblxuICogZXhwbGljaXQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJyb3dzZXIncyB2aWV3cG9ydC4gV2UgdXNlIGZsZXhib3gsIGluc3RlYWQgb2ZcbiAqIHRyYW5zZm9ybXMsIGluIG9yZGVyIHRvIGF2b2lkIGlzc3VlcyB3aXRoIHN1YnBpeGVsIHJlbmRlcmluZyB3aGljaCBjYW4gY2F1c2UgdGhlXG4gKiBlbGVtZW50IHRvIGJlY29tZSBibHVycnkuXG4gKi9cbnZhciBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2xvYmFsUG9zaXRpb25TdHJhdGVneSgpIHtcbiAgICAgICAgdGhpcy5fY3NzUG9zaXRpb24gPSAnc3RhdGljJztcbiAgICAgICAgdGhpcy5fdG9wT2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX2JvdHRvbU9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl9sZWZ0T2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX3JpZ2h0T2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXMgPSAnJztcbiAgICAgICAgdGhpcy5fanVzdGlmeUNvbnRlbnQgPSAnJztcbiAgICAgICAgdGhpcy5fd2lkdGggPSAnJztcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gJyc7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkuIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgdmVydGljYWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHs/PX0gdmFsdWUgTmV3IHRvcCBvZmZzZXQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS50b3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAnJzsgfVxuICAgICAgICB0aGlzLl9ib3R0b21PZmZzZXQgPSAnJztcbiAgICAgICAgdGhpcy5fdG9wT2Zmc2V0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXMgPSAnZmxleC1zdGFydCc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheS4gQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCBob3Jpem9udGFsIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlIE5ldyBsZWZ0IG9mZnNldC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmxlZnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAnJzsgfVxuICAgICAgICB0aGlzLl9yaWdodE9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl9sZWZ0T2Zmc2V0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2p1c3RpZnlDb250ZW50ID0gJ2ZsZXgtc3RhcnQnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheS4gQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCB2ZXJ0aWNhbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZSBOZXcgYm90dG9tIG9mZnNldC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmJvdHRvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9ICcnOyB9XG4gICAgICAgIHRoaXMuX3RvcE9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl9ib3R0b21PZmZzZXQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fYWxpZ25JdGVtcyA9ICdmbGV4LWVuZCc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmlnaHQgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkuIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZSBOZXcgcmlnaHQgb2Zmc2V0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUucmlnaHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAnJzsgfVxuICAgICAgICB0aGlzLl9sZWZ0T2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX3JpZ2h0T2Zmc2V0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2p1c3RpZnlDb250ZW50ID0gJ2ZsZXgtZW5kJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvdmVybGF5IHdpZHRoIGFuZCBjbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IHdpZHRoLlxuICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlIE5ldyB3aWR0aCBmb3IgdGhlIG92ZXJsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gJyc7IH1cbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgLy8gV2hlbiB0aGUgd2lkdGggaXMgMTAwJSwgd2Ugc2hvdWxkIHJlc2V0IHRoZSBgbGVmdGAgYW5kIHRoZSBvZmZzZXQsXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIGZsdXNoIGFnYWluc3QgdGhlIHZpZXdwb3J0IGVkZ2UuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJzEwMCUnKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQoJzBweCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3ZlcmxheSBoZWlnaHQgYW5kIGNsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlIE5ldyBoZWlnaHQgZm9yIHRoZSBvdmVybGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAnJzsgfVxuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgLy8gV2hlbiB0aGUgaGVpZ2h0IGlzIDEwMCUsIHdlIHNob3VsZCByZXNldCB0aGUgYHRvcGAgYW5kIHRoZSBvZmZzZXQsXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIGZsdXNoIGFnYWluc3QgdGhlIHZpZXdwb3J0IGVkZ2UuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJzEwMCUnKSB7XG4gICAgICAgICAgICB0aGlzLnRvcCgnMHB4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIHRoZSBvdmVybGF5IGhvcml6b250YWxseSB3aXRoIGFuIG9wdGlvbmFsIG9mZnNldC5cbiAgICAgKiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IGhvcml6b250YWwgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez89fSBvZmZzZXQgT3ZlcmxheSBvZmZzZXQgZnJvbSB0aGUgaG9yaXpvbnRhbCBjZW50ZXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5jZW50ZXJIb3Jpem9udGFsbHkgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAnJzsgfVxuICAgICAgICB0aGlzLmxlZnQob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fanVzdGlmeUNvbnRlbnQgPSAnY2VudGVyJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIHRoZSBvdmVybGF5IHZlcnRpY2FsbHkgd2l0aCBhbiBvcHRpb25hbCBvZmZzZXQuXG4gICAgICogQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCB2ZXJ0aWNhbCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Pz19IG9mZnNldCBPdmVybGF5IG9mZnNldCBmcm9tIHRoZSB2ZXJ0aWNhbCBjZW50ZXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5jZW50ZXJWZXJ0aWNhbGx5ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gJyc7IH1cbiAgICAgICAgdGhpcy50b3Aob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYWxpZ25JdGVtcyA9ICdjZW50ZXInO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgZWxlbWVudC5cbiAgICAgKiBcXEBkb2NzLXByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBFbGVtZW50IHRvIHdoaWNoIHRvIGFwcGx5IHRoZSBDU1MuXG4gICAgICogQHJldHVybiB7P30gUmVzb2x2ZWQgd2hlbiB0aGUgc3R5bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93cmFwcGVyICYmIGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdjZGstZ2xvYmFsLW92ZXJsYXktd3JhcHBlcicpO1xuICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl93cmFwcGVyLCBlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gZWxlbWVudC5zdHlsZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50U3R5bGVzID0gKChlbGVtZW50LnBhcmVudE5vZGUpKS5zdHlsZTtcbiAgICAgICAgc3R5bGVzLnBvc2l0aW9uID0gdGhpcy5fY3NzUG9zaXRpb247XG4gICAgICAgIHN0eWxlcy5tYXJnaW5Ub3AgPSB0aGlzLl90b3BPZmZzZXQ7XG4gICAgICAgIHN0eWxlcy5tYXJnaW5MZWZ0ID0gdGhpcy5fbGVmdE9mZnNldDtcbiAgICAgICAgc3R5bGVzLm1hcmdpbkJvdHRvbSA9IHRoaXMuX2JvdHRvbU9mZnNldDtcbiAgICAgICAgc3R5bGVzLm1hcmdpblJpZ2h0ID0gdGhpcy5fcmlnaHRPZmZzZXQ7XG4gICAgICAgIHN0eWxlcy53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICBzdHlsZXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICBwYXJlbnRTdHlsZXMuanVzdGlmeUNvbnRlbnQgPSB0aGlzLl9qdXN0aWZ5Q29udGVudDtcbiAgICAgICAgcGFyZW50U3R5bGVzLmFsaWduSXRlbXMgPSB0aGlzLl9hbGlnbkl0ZW1zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgd3JhcHBlciBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93cmFwcGVyICYmIHRoaXMuX3dyYXBwZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3dyYXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5O1xufSgpKTtcbi8qKlxuICogQnVpbGRlciBmb3Igb3ZlcmxheSBwb3NpdGlvbiBzdHJhdGVneS5cbiAqL1xudmFyIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF92aWV3cG9ydFJ1bGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gT3ZlcmxheVBvc2l0aW9uQnVpbGRlcihfdmlld3BvcnRSdWxlcikge1xuICAgICAgICB0aGlzLl92aWV3cG9ydFJ1bGVyID0gX3ZpZXdwb3J0UnVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBnbG9iYWwgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UG9zaXRpb25CdWlsZGVyLnByb3RvdHlwZS5nbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2xvYmFsUG9zaXRpb25TdHJhdGVneSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlbGF0aXZlIHBvc2l0aW9uIHN0cmF0ZWd5LlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luUG9zXG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5UG9zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5UG9zaXRpb25CdWlsZGVyLnByb3RvdHlwZS5jb25uZWN0ZWRUbyA9IGZ1bmN0aW9uIChlbGVtZW50UmVmLCBvcmlnaW5Qb3MsIG92ZXJsYXlQb3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KGVsZW1lbnRSZWYsIG9yaWdpblBvcywgb3ZlcmxheVBvcywgdGhpcy5fdmlld3BvcnRSdWxlcik7XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcmxheVBvc2l0aW9uQnVpbGRlcjtcbn0oKSk7XG5PdmVybGF5UG9zaXRpb25CdWlsZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5PdmVybGF5UG9zaXRpb25CdWlsZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVmlld3BvcnRSdWxlciwgfSxcbl07IH07XG4vKipcbiAqIFRoZSBPdmVybGF5Q29udGFpbmVyIGlzIHRoZSBjb250YWluZXIgaW4gd2hpY2ggYWxsIG92ZXJsYXlzIHdpbGwgbG9hZC5cbiAqIEl0IHNob3VsZCBiZSBwcm92aWRlZCBpbiB0aGUgcm9vdCBjb21wb25lbnQgdG8gZW5zdXJlIGl0IGlzIHByb3Blcmx5IHNoYXJlZC5cbiAqL1xudmFyIE92ZXJsYXlDb250YWluZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5Q29udGFpbmVyKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3ZlcmxheUNvbnRhaW5lci5wcm90b3R5cGUsIFwidGhlbWVDbGFzc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYXNlIHRoZW1lIHRvIGJlIGFwcGxpZWQgdG8gYWxsIG92ZXJsYXktYmFzZWQgY29tcG9uZW50cy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdGhlbWVDbGFzczsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl90aGVtZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90aGVtZUNsYXNzID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIG92ZXJsYXkgY29udGFpbmVyIGVsZW1lbnQuICBJdCB3aWxsIGxhemlseVxuICAgICAqIGNyZWF0ZSB0aGUgZWxlbWVudCB0aGUgZmlyc3QgdGltZSAgaXQgaXMgY2FsbGVkIHRvIGZhY2lsaXRhdGUgdXNpbmdcbiAgICAgKiB0aGUgY29udGFpbmVyIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgICAgKiBAcmV0dXJuIHs/fSB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKi9cbiAgICBPdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5nZXRDb250YWluZXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXJFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBvdmVybGF5IGNvbnRhaW5lciBlbGVtZW50LCB3aGljaCBpcyBzaW1wbHkgYSBkaXZcbiAgICAgKiB3aXRoIHRoZSAnY2RrLW92ZXJsYXktY29udGFpbmVyJyBjbGFzcyBvbiB0aGUgZG9jdW1lbnQgYm9keS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE92ZXJsYXlDb250YWluZXIucHJvdG90eXBlLl9jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnY2RrLW92ZXJsYXktY29udGFpbmVyJyk7XG4gICAgICAgIGlmICh0aGlzLl90aGVtZUNsYXNzKSB7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLl90aGVtZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQgPSBjb250YWluZXI7XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcmxheUNvbnRhaW5lcjtcbn0oKSk7XG5PdmVybGF5Q29udGFpbmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5PdmVybGF5Q29udGFpbmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEBwYXJhbSB7P30gcGFyZW50Q29udGFpbmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudENvbnRhaW5lcikge1xuICAgIHJldHVybiBwYXJlbnRDb250YWluZXIgfHwgbmV3IE92ZXJsYXlDb250YWluZXIoKTtcbn1cbnZhciBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIE92ZXJsYXlDb250YWluZXIgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBPdmVybGF5Q29udGFpbmVyLFxuICAgIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBPdmVybGF5Q29udGFpbmVyXV0sXG4gICAgdXNlRmFjdG9yeTogT1ZFUkxBWV9DT05UQUlORVJfUFJPVklERVJfRkFDVE9SWVxufTtcbi8qKlxuICogTmV4dCBvdmVybGF5IHVuaXF1ZSBJRC5cbiAqL1xudmFyIG5leHRVbmlxdWVJZCA9IDA7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0YXRlIGZvciBuZXdseSBjcmVhdGVkIG92ZXJsYXlzLlxuICovXG52YXIgZGVmYXVsdFN0YXRlID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuLyoqXG4gKiBTZXJ2aWNlIHRvIGNyZWF0ZSBPdmVybGF5cy4gT3ZlcmxheXMgYXJlIGR5bmFtaWNhbGx5IGFkZGVkIHBpZWNlcyBvZiBmbG9hdGluZyBVSSwgbWVhbnQgdG8gYmVcbiAqIHVzZWQgYXMgYSBsb3ctbGV2ZWwgYnVpbGRpbmcgYnVpbGRpbmcgYmxvY2sgZm9yIG90aGVyIGNvbXBvbmVudHMuIERpYWxvZ3MsIHRvb2x0aXBzLCBtZW51cyxcbiAqIHNlbGVjdHMsIGV0Yy4gY2FuIGFsbCBiZSBidWlsdCB1c2luZyBvdmVybGF5cy4gVGhlIHNlcnZpY2Ugc2hvdWxkIHByaW1hcmlseSBiZSB1c2VkIGJ5IGF1dGhvcnNcbiAqIG9mIHJlLXVzYWJsZSBjb21wb25lbnRzIHJhdGhlciB0aGFuIGRldmVsb3BlcnMgYnVpbGRpbmcgZW5kLXVzZXIgYXBwbGljYXRpb25zLlxuICpcbiAqIEFuIG92ZXJsYXkgKmlzKiBhIFBvcnRhbEhvc3QsIHNvIGFueSBraW5kIG9mIFBvcnRhbCBjYW4gYmUgbG9hZGVkIGludG8gb25lLlxuICovXG52YXIgT3ZlcmxheSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2Nyb2xsU3RyYXRlZ2llc1xuICAgICAqIEBwYXJhbSB7P30gX292ZXJsYXlDb250YWluZXJcbiAgICAgKiBAcGFyYW0gez99IF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IF9wb3NpdGlvbkJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gez99IF9hcHBSZWZcbiAgICAgKiBAcGFyYW0gez99IF9pbmplY3RvclxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE92ZXJsYXkoc2Nyb2xsU3RyYXRlZ2llcywgX292ZXJsYXlDb250YWluZXIsIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF9wb3NpdGlvbkJ1aWxkZXIsIF9hcHBSZWYsIF9pbmplY3RvciwgX25nWm9uZSkge1xuICAgICAgICB0aGlzLnNjcm9sbFN0cmF0ZWdpZXMgPSBzY3JvbGxTdHJhdGVnaWVzO1xuICAgICAgICB0aGlzLl9vdmVybGF5Q29udGFpbmVyID0gX292ZXJsYXlDb250YWluZXI7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQnVpbGRlciA9IF9wb3NpdGlvbkJ1aWxkZXI7XG4gICAgICAgIHRoaXMuX2FwcFJlZiA9IF9hcHBSZWY7XG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHs/PX0gc3RhdGUgU3RhdGUgdG8gYXBwbHkgdG8gdGhlIG92ZXJsYXkuXG4gICAgICogQHJldHVybiB7P30gUmVmZXJlbmNlIHRvIHRoZSBjcmVhdGVkIG92ZXJsYXkuXG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHN0YXRlJCQxKSB7XG4gICAgICAgIGlmIChzdGF0ZSQkMSA9PT0gdm9pZCAwKSB7IHN0YXRlJCQxID0gZGVmYXVsdFN0YXRlOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVPdmVybGF5UmVmKHRoaXMuX2NyZWF0ZVBhbmVFbGVtZW50KCksIHN0YXRlJCQxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwb3NpdGlvbiBidWlsZGVyIHRoYXQgY2FuIGJlIHVzZWQsIHZpYSBmbHVlbnQgQVBJLFxuICAgICAqIHRvIGNvbnN0cnVjdCBhbmQgY29uZmlndXJlIGEgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uQnVpbGRlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIERPTSBlbGVtZW50IGZvciBhbiBvdmVybGF5IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBvdmVybGF5IGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJuIHs/fSBOZXdseS1jcmVhdGVkIHBhbmUgZWxlbWVudFxuICAgICAqL1xuICAgIE92ZXJsYXkucHJvdG90eXBlLl9jcmVhdGVQYW5lRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFuZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwYW5lLmlkID0gXCJjZGstb3ZlcmxheS1cIiArIG5leHRVbmlxdWVJZCsrO1xuICAgICAgICBwYW5lLmNsYXNzTGlzdC5hZGQoJ2Nkay1vdmVybGF5LXBhbmUnKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheUNvbnRhaW5lci5nZXRDb250YWluZXJFbGVtZW50KCkuYXBwZW5kQ2hpbGQocGFuZSk7XG4gICAgICAgIHJldHVybiBwYW5lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRG9tUG9ydGFsSG9zdCBpbnRvIHdoaWNoIHRoZSBvdmVybGF5IGNvbnRlbnQgY2FuIGJlIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gez99IHBhbmUgVGhlIERPTSBlbGVtZW50IHRvIHR1cm4gaW50byBhIHBvcnRhbCBob3N0LlxuICAgICAqIEByZXR1cm4gez99IEEgcG9ydGFsIGhvc3QgZm9yIHRoZSBnaXZlbiBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBPdmVybGF5LnByb3RvdHlwZS5fY3JlYXRlUG9ydGFsSG9zdCA9IGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9tUG9ydGFsSG9zdChwYW5lLCB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIHRoaXMuX2FwcFJlZiwgdGhpcy5faW5qZWN0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPdmVybGF5UmVmIGZvciBhbiBvdmVybGF5IGluIHRoZSBnaXZlbiBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IHBhbmUgRE9NIGVsZW1lbnQgZm9yIHRoZSBvdmVybGF5XG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXlSZWYgPSBmdW5jdGlvbiAocGFuZSwgc3RhdGUkJDEpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2Nyb2xsU3RyYXRlZ3kgPSBzdGF0ZSQkMS5zY3JvbGxTdHJhdGVneSB8fCB0aGlzLnNjcm9sbFN0cmF0ZWdpZXMubm9vcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3J0YWxIb3N0ID0gdGhpcy5fY3JlYXRlUG9ydGFsSG9zdChwYW5lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBPdmVybGF5UmVmKHBvcnRhbEhvc3QsIHBhbmUsIHN0YXRlJCQxLCBzY3JvbGxTdHJhdGVneSwgdGhpcy5fbmdab25lKTtcbiAgICB9O1xuICAgIHJldHVybiBPdmVybGF5O1xufSgpKTtcbk92ZXJsYXkuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk92ZXJsYXkuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBTY3JvbGxTdHJhdGVneU9wdGlvbnMsIH0sXG4gICAgeyB0eXBlOiBPdmVybGF5Q29udGFpbmVyLCB9LFxuICAgIHsgdHlwZTogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCB9LFxuICAgIHsgdHlwZTogT3ZlcmxheVBvc2l0aW9uQnVpbGRlciwgfSxcbiAgICB7IHR5cGU6IEFwcGxpY2F0aW9uUmVmLCB9LFxuICAgIHsgdHlwZTogSW5qZWN0b3IsIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG5dOyB9O1xuLyoqXG4gKiBEZWZhdWx0IHNldCBvZiBwb3NpdGlvbnMgZm9yIHRoZSBvdmVybGF5LiBGb2xsb3dzIHRoZSBiZWhhdmlvciBvZiBhIGRyb3Bkb3duLlxuICovXG52YXIgZGVmYXVsdFBvc2l0aW9uTGlzdCA9IFtcbiAgICBuZXcgQ29ubmVjdGlvblBvc2l0aW9uUGFpcih7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nIH0sIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAndG9wJyB9KSxcbiAgICBuZXcgQ29ubmVjdGlvblBvc2l0aW9uUGFpcih7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICd0b3AnIH0sIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnYm90dG9tJyB9KSxcbl07XG4vKipcbiAqIERpcmVjdGl2ZSBhcHBsaWVkIHRvIGFuIGVsZW1lbnQgdG8gbWFrZSBpdCB1c2FibGUgYXMgYW4gb3JpZ2luIGZvciBhbiBPdmVybGF5IHVzaW5nIGFcbiAqIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kuXG4gKi9cbnZhciBPdmVybGF5T3JpZ2luID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gT3ZlcmxheU9yaWdpbihlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgfVxuICAgIHJldHVybiBPdmVybGF5T3JpZ2luO1xufSgpKTtcbk92ZXJsYXlPcmlnaW4uZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGstb3ZlcmxheS1vcmlnaW5dLCBbb3ZlcmxheS1vcmlnaW5dLCBbY2RrT3ZlcmxheU9yaWdpbl0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnY2RrT3ZlcmxheU9yaWdpbicsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk92ZXJsYXlPcmlnaW4uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHRvIGZhY2lsaXRhdGUgZGVjbGFyYXRpdmUgY3JlYXRpb24gb2YgYW4gT3ZlcmxheSB1c2luZyBhIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kuXG4gKi9cbnZhciBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfb3ZlcmxheVxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVJlZlxuICAgICAqIEBwYXJhbSB7P30gdmlld0NvbnRhaW5lclJlZlxuICAgICAqIEBwYXJhbSB7P30gX2RpclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUoX292ZXJsYXksIF9yZW5kZXJlciwgdGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYsIF9kaXIpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheSA9IF9vdmVybGF5O1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgdGhpcy5faGFzQmFja2Ryb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WCA9IDA7XG4gICAgICAgIHRoaXMuX29mZnNldFkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RyYXRlZ3kgdG8gYmUgdXNlZCB3aGVuIGhhbmRsaW5nIHNjcm9sbCBldmVudHMgd2hpbGUgdGhlIG92ZXJsYXkgaXMgb3Blbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgb3ZlcmxheSBpcyBvcGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGJhY2tkcm9wIGlzIGNsaWNrZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhY2tkcm9wQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3ZlcmxheSBoYXMgYmVlbiBhdHRhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXR0YWNoID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBvdmVybGF5IGhhcyBiZWVuIGRldGFjaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXRhY2ggPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldFhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9mZnNldCBpbiBwaXhlbHMgZm9yIHRoZSBvdmVybGF5IGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHgtYXhpc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0WFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob2Zmc2V0WCkge1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbi53aXRoT2Zmc2V0WChvZmZzZXRYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldFlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9mZnNldCBpbiBwaXhlbHMgZm9yIHRoZSBvdmVybGF5IGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHktYXhpc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0WVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob2Zmc2V0WSkge1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbi53aXRoT2Zmc2V0WShvZmZzZXRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcImhhc0JhY2tkcm9wXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IHNob3VsZCBhdHRhY2ggYSBiYWNrZHJvcC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0JhY2tkcm9wO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc0JhY2tkcm9wID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcIm92ZXJsYXlSZWZcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFzc29jaWF0ZWQgb3ZlcmxheSByZWZlcmVuY2UuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5UmVmO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlbGVtZW50J3MgbGF5b3V0IGRpcmVjdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpciA/IHRoaXMuX2Rpci52YWx1ZSA6ICdsdHInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95T3ZlcmxheSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzWydvcGVuJ10pIHtcbiAgICAgICAgICAgIHRoaXMub3BlbiA/IHRoaXMuX2F0dGFjaE92ZXJsYXkoKSA6IHRoaXMuX2RldGFjaE92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvdmVybGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvc2l0aW9ucyB8fCAhdGhpcy5wb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IGRlZmF1bHRQb3NpdGlvbkxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKHRoaXMuX2J1aWxkQ29uZmlnKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBvdmVybGF5IGNvbmZpZyBiYXNlZCBvbiB0aGUgZGlyZWN0aXZlJ3MgaW5wdXRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fYnVpbGRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlDb25maWcgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIGlmICh0aGlzLndpZHRoIHx8IHRoaXMud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIG92ZXJsYXlDb25maWcud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCB8fCB0aGlzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgb3ZlcmxheUNvbmZpZy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW5XaWR0aCB8fCB0aGlzLm1pbldpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBvdmVybGF5Q29uZmlnLm1pbldpZHRoID0gdGhpcy5taW5XaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW5IZWlnaHQgfHwgdGhpcy5taW5IZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIG92ZXJsYXlDb25maWcubWluSGVpZ2h0ID0gdGhpcy5taW5IZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgb3ZlcmxheUNvbmZpZy5oYXNCYWNrZHJvcCA9IHRoaXMuaGFzQmFja2Ryb3A7XG4gICAgICAgIGlmICh0aGlzLmJhY2tkcm9wQ2xhc3MpIHtcbiAgICAgICAgICAgIG92ZXJsYXlDb25maWcuYmFja2Ryb3BDbGFzcyA9IHRoaXMuYmFja2Ryb3BDbGFzcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9ICh0aGlzLl9jcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCkpO1xuICAgICAgICBvdmVybGF5Q29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9wb3NpdGlvbjtcbiAgICAgICAgb3ZlcmxheUNvbmZpZy5zY3JvbGxTdHJhdGVneSA9IHRoaXMuc2Nyb2xsU3RyYXRlZ3k7XG4gICAgICAgIHJldHVybiBvdmVybGF5Q29uZmlnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgb2YgdGhlIG92ZXJsYXkgdG8gYmUgc2V0IG9uIHRoZSBvdmVybGF5IGNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2NyZWF0ZVBvc2l0aW9uU3RyYXRlZ3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvcyA9IHRoaXMucG9zaXRpb25zWzBdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5Qb2ludCA9IHsgb3JpZ2luWDogcG9zLm9yaWdpblgsIG9yaWdpblk6IHBvcy5vcmlnaW5ZIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlQb2ludCA9IHsgb3ZlcmxheVg6IHBvcy5vdmVybGF5WCwgb3ZlcmxheVk6IHBvcy5vdmVybGF5WSB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJhdGVneSA9IHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxuICAgICAgICAgICAgLmNvbm5lY3RlZFRvKHRoaXMub3JpZ2luLmVsZW1lbnRSZWYsIG9yaWdpblBvaW50LCBvdmVybGF5UG9pbnQpXG4gICAgICAgICAgICAud2l0aE9mZnNldFgodGhpcy5vZmZzZXRYKVxuICAgICAgICAgICAgLndpdGhPZmZzZXRZKHRoaXMub2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuX2hhbmRsZVBvc2l0aW9uQ2hhbmdlcyhzdHJhdGVneSk7XG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RyYXRlZ3lcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLl9oYW5kbGVQb3NpdGlvbkNoYW5nZXMgPSBmdW5jdGlvbiAoc3RyYXRlZ3kpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMTsgaSA8IHRoaXMucG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHJhdGVneS53aXRoRmFsbGJhY2tQb3NpdGlvbih7IG9yaWdpblg6IHRoaXMucG9zaXRpb25zW2ldLm9yaWdpblgsIG9yaWdpblk6IHRoaXMucG9zaXRpb25zW2ldLm9yaWdpblkgfSwgeyBvdmVybGF5WDogdGhpcy5wb3NpdGlvbnNbaV0ub3ZlcmxheVgsIG92ZXJsYXlZOiB0aGlzLnBvc2l0aW9uc1tpXS5vdmVybGF5WSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbiA9XG4gICAgICAgICAgICBzdHJhdGVneS5vblBvc2l0aW9uQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAocG9zKSB7IHJldHVybiBfdGhpcy5wb3NpdGlvbkNoYW5nZS5lbWl0KHBvcyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdGhlIG92ZXJsYXkgYW5kIHN1YnNjcmliZXMgdG8gYmFja2Ryb3AgY2xpY2tzIGlmIGJhY2tkcm9wIGV4aXN0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2F0dGFjaE92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uLndpdGhEaXJlY3Rpb24odGhpcy5kaXIpO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmdldFN0YXRlKCkuZGlyZWN0aW9uID0gdGhpcy5kaXI7XG4gICAgICAgIHRoaXMuX2luaXRFc2NhcGVMaXN0ZW5lcigpO1xuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5hdHRhY2godGhpcy5fdGVtcGxhdGVQb3J0YWwpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2guZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0JhY2tkcm9wKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbiA9IHRoaXMuX292ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYmFja2Ryb3BDbGljay5lbWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgdGhlIG92ZXJsYXkgYW5kIHVuc3Vic2NyaWJlcyB0byBiYWNrZHJvcCBjbGlja3MgaWYgYmFja2Ryb3AgZXhpc3RzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fZGV0YWNoT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgICAgICB0aGlzLmRldGFjaC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lc2NhcGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fZXNjYXBlTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIG92ZXJsYXkgY3JlYXRlZCBieSB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLl9kZXN0cm95T3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2VzY2FwZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lc2NhcGVMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBldmVudCBsaXN0ZW5lciB0aGF0IGNsb3NlcyB0aGUgb3ZlcmxheSB3aGVuIHByZXNzaW5nIEVzY2FwZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLl9pbml0RXNjYXBlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2VzY2FwZUxpc3RlbmVyID0gdGhpcy5fcmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2RldGFjaE92ZXJsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZTtcbn0oKSk7XG5Db25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrLWNvbm5lY3RlZC1vdmVybGF5XSwgW2Nvbm5lY3RlZC1vdmVybGF5XSwgW2Nka0Nvbm5lY3RlZE92ZXJsYXldJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2Nka0Nvbm5lY3RlZE92ZXJsYXknXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBPdmVybGF5LCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIH0sXG4gICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIHsgdHlwZTogRGlyZWN0aW9uYWxpdHksIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbkNvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ29yaWdpbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAncG9zaXRpb25zJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdvZmZzZXRYJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdvZmZzZXRZJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd3aWR0aCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaGVpZ2h0JzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtaW5XaWR0aCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbWluSGVpZ2h0JzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdiYWNrZHJvcENsYXNzJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzY3JvbGxTdHJhdGVneSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnb3Blbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaGFzQmFja2Ryb3AnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2JhY2tkcm9wQ2xpY2snOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdwb3NpdGlvbkNoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2F0dGFjaCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2RldGFjaCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBUaGUgRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIgaXMgdGhlIGFsdGVybmF0aXZlIHRvIE92ZXJsYXlDb250YWluZXJcbiAqIHRoYXQgc3VwcG9ydHMgY29ycmVjdCBkaXNwbGF5aW5nIG9mIG92ZXJsYXkgZWxlbWVudHMgaW4gRnVsbHNjcmVlbiBtb2RlXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9yZXF1ZXN0RnVsbFNjcmVlblxuICogSXQgc2hvdWxkIGJlIHByb3ZpZGVkIGluIHRoZSByb290IGNvbXBvbmVudCB0aGF0IHdheTpcbiAqIHByb3ZpZGVyczogW1xuICogICB7cHJvdmlkZTogT3ZlcmxheUNvbnRhaW5lciwgdXNlQ2xhc3M6IEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyfVxuICogXSxcbiAqL1xudmFyIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lci5wcm90b3R5cGUuX2NyZWF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY3JlYXRlQ29udGFpbmVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEZvckZ1bGxzY3JlZW5DaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5fYWRkRnVsbHNjcmVlbkNoYW5nZUxpc3RlbmVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hZGp1c3RQYXJlbnRGb3JGdWxsc2NyZWVuQ2hhbmdlKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lci5wcm90b3R5cGUuX2FkanVzdFBhcmVudEZvckZ1bGxzY3JlZW5DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1bGxzY3JlZW5FbGVtZW50ID0gdGhpcy5nZXRGdWxsc2NyZWVuRWxlbWVudCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnQgPSBmdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyRWxlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lci5wcm90b3R5cGUuX2FkZEZ1bGxzY3JlZW5DaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChkb2N1bWVudCkpLm1vekZ1bGxTY3JlZW5FbmFibGVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoZG9jdW1lbnQpKS5tc0Z1bGxzY3JlZW5FbmFibGVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCBmbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHBhZ2UgaXMgcHV0IGludG8gZnVsbHNjcmVlbiBtb2RlLCBhIHNwZWNpZmljIGVsZW1lbnQgaXMgc3BlY2lmaWVkLlxuICAgICAqIE9ubHkgdGhhdCBlbGVtZW50IGFuZCBpdHMgY2hpbGRyZW4gYXJlIHZpc2libGUgd2hlbiBpbiBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lci5wcm90b3R5cGUuZ2V0RnVsbHNjcmVlbkVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgICAgICgoZG9jdW1lbnQpKS5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgKChkb2N1bWVudCkpLm1zRnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgICAgIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXI7XG59KE92ZXJsYXlDb250YWluZXIpKTtcbkZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5GdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIE9WRVJMQVlfUFJPVklERVJTID0gW1xuICAgIE92ZXJsYXksXG4gICAgT3ZlcmxheVBvc2l0aW9uQnVpbGRlcixcbiAgICBWSUVXUE9SVF9SVUxFUl9QUk9WSURFUixcbiAgICBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUixcbl07XG52YXIgT3ZlcmxheU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBPdmVybGF5TW9kdWxlO1xufSgpKTtcbk92ZXJsYXlNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtQb3J0YWxNb2R1bGUsIFNjcm9sbERpc3BhdGNoTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSwgT3ZlcmxheU9yaWdpbiwgU2Nyb2xsRGlzcGF0Y2hNb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0Nvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUsIE92ZXJsYXlPcmlnaW5dLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW09WRVJMQVlfUFJPVklERVJTXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuT3ZlcmxheU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIEdlc3R1cmVDb25maWcgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhHZXN0dXJlQ29uZmlnLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdlc3R1cmVDb25maWcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9oYW1tZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/ICgod2luZG93KSkuSGFtbWVyIDogbnVsbDtcbiAgICAgICAgLyogTGlzdCBvZiBuZXcgZXZlbnQgbmFtZXMgdG8gYWRkIHRvIHRoZSBnZXN0dXJlIHN1cHBvcnQgbGlzdCAqL1xuICAgICAgICBfdGhpcy5ldmVudHMgPSBfdGhpcy5faGFtbWVyID8gW1xuICAgICAgICAgICAgJ2xvbmdwcmVzcycsXG4gICAgICAgICAgICAnc2xpZGUnLFxuICAgICAgICAgICAgJ3NsaWRlc3RhcnQnLFxuICAgICAgICAgICAgJ3NsaWRlZW5kJyxcbiAgICAgICAgICAgICdzbGlkZXJpZ2h0JyxcbiAgICAgICAgICAgICdzbGlkZWxlZnQnXG4gICAgICAgIF0gOiBbXTtcbiAgICAgICAgaWYgKCFfdGhpcy5faGFtbWVyICYmIGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmaW5kIEhhbW1lckpTLiBDZXJ0YWluIEFuZ3VsYXIgTWF0ZXJpYWwgJyArXG4gICAgICAgICAgICAgICAgJ2NvbXBvbmVudHMgbWF5IG5vdCB3b3JrIGNvcnJlY3RseS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBIYW1tZXIgaW5zdGFuY2UgbWFudWFsbHkgdG8gYWRkIGN1c3RvbSByZWNvZ25pemVycyB0aGF0IG1hdGNoIHRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYy5cbiAgICAgKlxuICAgICAqIE91ciBnZXN0dXJlIG5hbWVzIGNvbWUgZnJvbSB0aGUgTWF0ZXJpYWwgRGVzaWduIGdlc3R1cmVzIHNwZWM6XG4gICAgICogaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9wYXR0ZXJucy9nZXN0dXJlcy5odG1sI2dlc3R1cmVzLXRvdWNoLW1lY2hhbmljc1xuICAgICAqXG4gICAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZhdWx0IHJlY29nbml6ZXJzIGNhbiBiZSBmb3VuZCBpbiBIYW1tZXIgZG9jczpcbiAgICAgKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlY29nbml6ZXItcGFuL1xuICAgICAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vcmVjb2duaXplci1wcmVzcy9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBFbGVtZW50IHRvIHdoaWNoIHRvIGFzc2lnbiB0aGUgbmV3IEhhbW1lckpTIGdlc3R1cmVzLlxuICAgICAqIEByZXR1cm4gez99IE5ld2x5LWNyZWF0ZWQgSGFtbWVySlMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgR2VzdHVyZUNvbmZpZy5wcm90b3R5cGUuYnVpbGRIYW1tZXIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYyA9IG5ldyB0aGlzLl9oYW1tZXIoZWxlbWVudCk7XG4gICAgICAgIC8vIERlZmF1bHQgSGFtbWVyIFJlY29nbml6ZXJzLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYW4gPSBuZXcgdGhpcy5faGFtbWVyLlBhbigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzd2lwZSA9IG5ldyB0aGlzLl9oYW1tZXIuU3dpcGUoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlc3MgPSBuZXcgdGhpcy5faGFtbWVyLlByZXNzKCk7XG4gICAgICAgIC8vIE5vdGljZSB0aGF0IGEgSGFtbWVySlMgcmVjb2duaXplciBjYW4gb25seSBkZXBlbmQgb24gb25lIG90aGVyIHJlY29nbml6ZXIgb25jZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBwcmV2aW91cyBgcmVjb2duaXplV2l0aGAgd2lsbCBiZSBkcm9wcGVkLlxuICAgICAgICAvLyBUT0RPOiBDb25maXJtIHRocmVzaG9sZCBudW1iZXJzIHdpdGggTWF0ZXJpYWwgRGVzaWduIFVYIFRlYW1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2xpZGUgPSB0aGlzLl9jcmVhdGVSZWNvZ25pemVyKHBhbiwgeyBldmVudDogJ3NsaWRlJywgdGhyZXNob2xkOiAwIH0sIHN3aXBlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9uZ3ByZXNzID0gdGhpcy5fY3JlYXRlUmVjb2duaXplcihwcmVzcywgeyBldmVudDogJ2xvbmdwcmVzcycsIHRpbWU6IDUwMCB9KTtcbiAgICAgICAgLy8gT3ZlcndyaXRlIHRoZSBkZWZhdWx0IGBwYW5gIGV2ZW50IHRvIHVzZSB0aGUgc3dpcGUgZXZlbnQuXG4gICAgICAgIHBhbi5yZWNvZ25pemVXaXRoKHN3aXBlKTtcbiAgICAgICAgLy8gQWRkIGN1c3RvbWl6ZWQgZ2VzdHVyZXMgdG8gSGFtbWVyIG1hbmFnZXJcbiAgICAgICAgbWMuYWRkKFtzd2lwZSwgcHJlc3MsIHBhbiwgc2xpZGUsIGxvbmdwcmVzc10pO1xuICAgICAgICByZXR1cm4gKG1jKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmVjb2duaXplciwgd2l0aG91dCBhZmZlY3RpbmcgdGhlIGRlZmF1bHQgcmVjb2duaXplcnMgb2YgSGFtbWVySlNcbiAgICAgKiBAcGFyYW0gez99IGJhc2VcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gey4uLj99IGluaGVyaXRhbmNlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgR2VzdHVyZUNvbmZpZy5wcm90b3R5cGUuX2NyZWF0ZVJlY29nbml6ZXIgPSBmdW5jdGlvbiAoYmFzZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaW5oZXJpdGFuY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpbmhlcml0YW5jZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb2duaXplciA9IG5ldyAoKGJhc2UuY29uc3RydWN0b3IpKShvcHRpb25zKTtcbiAgICAgICAgaW5oZXJpdGFuY2VzLnB1c2goYmFzZSk7XG4gICAgICAgIGluaGVyaXRhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbSk7IH0pO1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9O1xuICAgIHJldHVybiBHZXN0dXJlQ29uZmlnO1xufShIYW1tZXJHZXN0dXJlQ29uZmlnKSk7XG5HZXN0dXJlQ29uZmlnLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5HZXN0dXJlQ29uZmlnLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIENsYXNzIHRvIGJlIHVzZWQgdG8gcG93ZXIgc2VsZWN0aW5nIG9uZSBvciBtb3JlIG9wdGlvbnMgZnJvbSBhIGxpc3QuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFNlbGVjdGlvbk1vZGVsID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX2lzTXVsdGlcbiAgICAgKiBAcGFyYW0gez89fSBpbml0aWFsbHlTZWxlY3RlZFZhbHVlc1xuICAgICAqIEBwYXJhbSB7Pz19IF9lbWl0Q2hhbmdlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlbGVjdGlvbk1vZGVsKF9pc011bHRpLCBpbml0aWFsbHlTZWxlY3RlZFZhbHVlcywgX2VtaXRDaGFuZ2VzKSB7XG4gICAgICAgIGlmIChfaXNNdWx0aSA9PT0gdm9pZCAwKSB7IF9pc011bHRpID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKF9lbWl0Q2hhbmdlcyA9PT0gdm9pZCAwKSB7IF9lbWl0Q2hhbmdlcyA9IHRydWU7IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faXNNdWx0aSA9IF9pc011bHRpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlcyA9IF9lbWl0Q2hhbmdlcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnRseS1zZWxlY3RlZCB2YWx1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24gPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgZGVzZWxlY3RlZCBvcHRpb25zIHRoYXQgaGF2ZW4ndCBiZWVuIGVtaXR0ZWQgYnkgdGhlIGNoYW5nZSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBzZWxlY3RlZCBvcHRpb24gdGhhdCBoYXZlbid0IGJlZW4gZW1pdHRlZCBieSB0aGUgY2hhbmdlIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRUb0VtaXQgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5fZW1pdENoYW5nZXMgPyBuZXcgU3ViamVjdCgpIDogbnVsbDtcbiAgICAgICAgaWYgKGluaXRpYWxseVNlbGVjdGVkVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoX2lzTXVsdGkpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsbHlTZWxlY3RlZFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMuX21hcmtTZWxlY3RlZCh2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya1NlbGVjdGVkKGluaXRpYWxseVNlbGVjdGVkVmFsdWVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBhcnJheSBpbiBvcmRlciB0byBhdm9pZCBmaXJpbmcgdGhlIGNoYW5nZSBldmVudCBmb3IgcHJlc2VsZWN0ZWQgdmFsdWVzLlxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRUb0VtaXQubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdGVkIHZhbHVlKHMpLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBBcnJheS5mcm9tKHRoaXMuX3NlbGVjdGlvbi52YWx1ZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tYXJrU2VsZWN0ZWQodmFsdWUpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyBhIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdW5tYXJrU2VsZWN0ZWQodmFsdWUpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYSB2YWx1ZSBiZXR3ZWVuIHNlbGVjdGVkIGFuZCBkZXNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pc1NlbGVjdGVkKHZhbHVlKSA/IHRoaXMuZGVzZWxlY3QodmFsdWUpIDogdGhpcy5zZWxlY3QodmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBvZiB0aGUgc2VsZWN0ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91bm1hcmtBbGwoKTtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWx1ZSBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLmhhcyh2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1vZGVsIGRvZXMgbm90IGhhdmUgYSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLnNpemUgPT09IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1vZGVsIGhhcyBhIHZhbHVlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNFbXB0eSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIHNlbGVjdGVkIHZhbHVlcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gez89fSBwcmVkaWNhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICBpZiAodGhpcy5faXNNdWx0aSAmJiB0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQuc29ydChwcmVkaWNhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIGNoYW5nZSBldmVudCBhbmQgY2xlYXJzIHRoZSByZWNvcmRzIG9mIHNlbGVjdGVkIGFuZCBkZXNlbGVjdGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRUb0VtaXQubGVuZ3RoIHx8IHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudERhdGEgPSBuZXcgU2VsZWN0aW9uQ2hhbmdlKHRoaXMuX3NlbGVjdGVkVG9FbWl0LCB0aGlzLl9kZXNlbGVjdGVkVG9FbWl0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZS5uZXh0KGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZXNlbGVjdGVkVG9FbWl0ID0gW107XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFRvRW1pdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuX21hcmtTZWxlY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNNdWx0aSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubWFya0FsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFRvRW1pdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVzZWxlY3RzIGEgdmFsdWUuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLl91bm1hcmtTZWxlY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXNlbGVjdGVkVG9FbWl0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgb3V0IHRoZSBzZWxlY3RlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuX3VubWFya0FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5fdW5tYXJrU2VsZWN0ZWQodmFsdWUpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdGlvbk1vZGVsO1xufSgpKTtcbi8qKlxuICogRGVzY3JpYmVzIGFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdmFsdWUgb2YgYSBNZFNlbGVjdGlvbk1vZGVsIGhhcyBjaGFuZ2VkLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBTZWxlY3Rpb25DaGFuZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBhZGRlZFxuICAgICAqIEBwYXJhbSB7Pz19IHJlbW92ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25DaGFuZ2UoYWRkZWQsIHJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy5hZGRlZCA9IGFkZGVkO1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cbiAgICByZXR1cm4gU2VsZWN0aW9uQ2hhbmdlO1xufSgpKTtcbi8qKlxuICogQ2xhc3MgdG8gY29vcmRpbmF0ZSB1bmlxdWUgc2VsZWN0aW9uIGJhc2VkIG9uIG5hbWUuXG4gKiBJbnRlbmRlZCB0byBiZSBjb25zdW1lZCBhcyBhbiBBbmd1bGFyIHNlcnZpY2UuXG4gKiBUaGlzIHNlcnZpY2UgaXMgbmVlZGVkIGJlY2F1c2UgbmF0aXZlIHJhZGlvIGNoYW5nZSBldmVudHMgYXJlIG9ubHkgZmlyZWQgb24gdGhlIGl0ZW0gY3VycmVudGx5XG4gKiBiZWluZyBzZWxlY3RlZCwgYW5kIHdlIHN0aWxsIG5lZWQgdG8gdW5jaGVjayB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLlxuICpcbiAqIFRoaXMgc2VydmljZSBkb2VzIG5vdCAqc3RvcmUqIGFueSBJRHMgYW5kIG5hbWVzIGJlY2F1c2UgdGhleSBtYXkgY2hhbmdlIGF0IGFueSB0aW1lLCBzbyBpdCBpc1xuICogbGVzcyBlcnJvci1wcm9uZSBpZiB0aGV5IGFyZSBzaW1wbHkgcGFzc2VkIHRocm91Z2ggd2hlbiB0aGUgZXZlbnRzIG9jY3VyLlxuICovXG52YXIgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIoKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgb3RoZXIgaXRlbXMgdGhhdCBzZWxlY3Rpb24gZm9yIHRoZSBnaXZlbiBuYW1lIGhhcyBiZWVuIHNldC5cbiAgICAgKiBAcGFyYW0gez99IGlkIElEIG9mIHRoZSBpdGVtLlxuICAgICAqIEBwYXJhbSB7P30gbmFtZSBOYW1lIG9mIHRoZSBpdGVtLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGlkLCBuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9saXN0ZW5lcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBsaXN0ZW5lcihpZCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgZnV0dXJlIGNoYW5nZXMgdG8gaXRlbSBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIHs/fSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4gez99IEZ1bmN0aW9uIHVzZWQgdG8gZGVyZWdpc3RlciBsaXN0ZW5lclxuICAgICAqXG4gICAgICovXG4gICAgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9saXN0ZW5lcnMgPSBfdGhpcy5fbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAocmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lciAhPT0gcmVnaXN0ZXJlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXI7XG59KCkpO1xuVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHBhcmVudERpc3BhdGNoZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIFVOSVFVRV9TRUxFQ1RJT05fRElTUEFUQ0hFUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudERpc3BhdGNoZXIpIHtcbiAgICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcigpO1xufVxudmFyIFVOSVFVRV9TRUxFQ1RJT05fRElTUEFUQ0hFUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgZGlzcGF0Y2hlciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIsXG4gICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXJdXSxcbiAgICB1c2VGYWN0b3J5OiBVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWVxufTtcbi8vIFRoaXMgaXMgdGhlIHZhbHVlIHVzZWQgYnkgQW5ndWxhckpTIE1hdGVyaWFsLiBUaHJvdWdoIHRyaWFsIGFuZCBlcnJvciAob24gaVBob25lIDZTKSB0aGV5IGZvdW5kXG4vLyB0aGF0IGEgdmFsdWUgb2YgYXJvdW5kIDY1MG1zIHNlZW1zIGFwcHJvcHJpYXRlLlxudmFyIFRPVUNIX0JVRkZFUl9NUyA9IDY1MDtcbi8qKlxuICogTW9uaXRvcnMgbW91c2UgYW5kIGtleWJvYXJkIGV2ZW50cyB0byBkZXRlcm1pbmUgdGhlIGNhdXNlIG9mIGZvY3VzIGV2ZW50cy5cbiAqL1xudmFyIEZvY3VzT3JpZ2luTW9uaXRvciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqIEBwYXJhbSB7P30gX3BsYXRmb3JtXG4gICAgICovXG4gICAgZnVuY3Rpb24gRm9jdXNPcmlnaW5Nb25pdG9yKF9uZ1pvbmUsIF9wbGF0Zm9ybSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IF9wbGF0Zm9ybTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmb2N1cyBvcmlnaW4gdGhhdCB0aGUgbmV4dCBmb2N1cyBldmVudCBpcyBhIHJlc3VsdCBvZi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29yaWdpbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB3aW5kb3cgaGFzIGp1c3QgYmVlbiBmb2N1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fd2luZG93Rm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2VhayBtYXAgb2YgZWxlbWVudHMgYmVpbmcgbW9uaXRvcmVkIHRvIHRoZWlyIGluZm8uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lbGVtZW50SW5mbyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcmVnaXN0ZXJEb2N1bWVudEV2ZW50cygpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9uaXRvcnMgZm9jdXMgb24gYW4gZWxlbWVudCBhbmQgYXBwbGllcyBhcHByb3ByaWF0ZSBDU1MgY2xhc3Nlcy5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gbW9uaXRvclxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXIgVGhlIHJlbmRlcmVyIHRvIHVzZSB0byBhcHBseSBDU1MgY2xhc3NlcyB0byB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IGNoZWNrQ2hpbGRyZW4gV2hldGhlciB0byBjb3VudCB0aGUgZWxlbWVudCBhcyBmb2N1c2VkIHdoZW4gaXRzIGNoaWxkcmVuIGFyZSBmb2N1c2VkLlxuICAgICAqIEByZXR1cm4gez99IEFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyB3aGVuIHRoZSBmb2N1cyBzdGF0ZSBvZiB0aGUgZWxlbWVudCBjaGFuZ2VzLlxuICAgICAqICAgICBXaGVuIHRoZSBlbGVtZW50IGlzIGJsdXJyZWQsIG51bGwgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUubW9uaXRvciA9IGZ1bmN0aW9uIChlbGVtZW50LCByZW5kZXJlciwgY2hlY2tDaGlsZHJlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHdlJ3JlIG5vdCBvbiB0aGUgYnJvd3NlciBwbGF0Zm9ybS5cbiAgICAgICAgaWYgKCF0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBvZihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBhbHJlYWR5IG1vbml0b3JpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICBpZiAodGhpcy5fZWxlbWVudEluZm8uaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmZvXzEgPSB0aGlzLl9lbGVtZW50SW5mby5nZXQoZWxlbWVudCk7IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICgoaW5mb18xKSkuY2hlY2tDaGlsZHJlbiA9IGNoZWNrQ2hpbGRyZW47XG4gICAgICAgICAgICByZXR1cm4gKChpbmZvXzEpKS5zdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBtb25pdG9yZWQgZWxlbWVudCBpbmZvLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmZvID0ge1xuICAgICAgICAgICAgdW5saXN0ZW46IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgICAgIGNoZWNrQ2hpbGRyZW46IGNoZWNrQ2hpbGRyZW4sXG4gICAgICAgICAgICByZW5kZXJlcjogcmVuZGVyZXIsXG4gICAgICAgICAgICBzdWJqZWN0OiBuZXcgU3ViamVjdCgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VsZW1lbnRJbmZvLnNldChlbGVtZW50LCBpbmZvKTtcbiAgICAgICAgLy8gU3RhcnQgbGlzdGVuaW5nLiBXZSBuZWVkIHRvIGxpc3RlbiBpbiBjYXB0dXJlIHBoYXNlIHNpbmNlIGZvY3VzIGV2ZW50cyBkb24ndCBidWJibGUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvY3VzTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLl9vbkZvY3VzKGV2ZW50LCBlbGVtZW50KTsgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmx1ckxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5fb25CbHVyKGV2ZW50LCBlbGVtZW50KTsgfTtcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmb2N1c0xpc3RlbmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGJsdXJMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDcmVhdGUgYW4gdW5saXN0ZW4gZnVuY3Rpb24gZm9yIGxhdGVyLlxuICAgICAgICBpbmZvLnVubGlzdGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGZvY3VzTGlzdGVuZXIsIHRydWUpO1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgYmx1ckxpc3RlbmVyLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGluZm8uc3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3BzIG1vbml0b3JpbmcgYW4gZWxlbWVudCBhbmQgcmVtb3ZlcyBhbGwgZm9jdXMgY2xhc3Nlcy5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gc3RvcCBtb25pdG9yaW5nLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNPcmlnaW5Nb25pdG9yLnByb3RvdHlwZS5zdG9wTW9uaXRvcmluZyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRJbmZvID0gdGhpcy5fZWxlbWVudEluZm8uZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudEluZm8pIHtcbiAgICAgICAgICAgIGVsZW1lbnRJbmZvLnVubGlzdGVuKCk7XG4gICAgICAgICAgICBlbGVtZW50SW5mby5zdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRDbGFzc2VzKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudEluZm8uZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBlbGVtZW50IHZpYSB0aGUgc3BlY2lmaWVkIGZvY3VzIG9yaWdpbi5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gZm9jdXMuXG4gICAgICogQHBhcmFtIHs/fSBvcmlnaW4gVGhlIGZvY3VzIG9yaWdpbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuZm9jdXNWaWEgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX3NldE9yaWdpbkZvckN1cnJlbnRFdmVudFF1ZXVlKG9yaWdpbik7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGRvY3VtZW50IGFuZCB3aW5kb3cuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c09yaWdpbk1vbml0b3IucHJvdG90eXBlLl9yZWdpc3RlckRvY3VtZW50RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHdlJ3JlIG5vdCBvbiB0aGUgYnJvd3NlciBwbGF0Zm9ybS5cbiAgICAgICAgaWYgKCF0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiB3ZSBsaXN0ZW4gdG8gZXZlbnRzIGluIHRoZSBjYXB0dXJlIHBoYXNlIHNvIHdlIGNhbiBkZXRlY3QgdGhlbSBldmVuIGlmIHRoZSB1c2VyIHN0b3BzXG4gICAgICAgIC8vIHByb3BhZ2F0aW9uLlxuICAgICAgICAvLyBPbiBrZXlkb3duIHJlY29yZCB0aGUgb3JpZ2luIGFuZCBjbGVhciBhbnkgdG91Y2ggZXZlbnQgdGhhdCBtYXkgYmUgaW4gcHJvZ3Jlc3MuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbGFzdFRvdWNoVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLl9zZXRPcmlnaW5Gb3JDdXJyZW50RXZlbnRRdWV1ZSgna2V5Ym9hcmQnKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIC8vIE9uIG1vdXNlZG93biByZWNvcmQgdGhlIG9yaWdpbiBvbmx5IGlmIHRoZXJlIGlzIG5vdCB0b3VjaCB0YXJnZXQsIHNpbmNlIGEgbW91c2Vkb3duIGNhblxuICAgICAgICAvLyBoYXBwZW4gYXMgYSByZXN1bHQgb2YgYSB0b3VjaCBldmVudC5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fbGFzdFRvdWNoVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldE9yaWdpbkZvckN1cnJlbnRFdmVudFF1ZXVlKCdtb3VzZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgdG91Y2hzdGFydCBldmVudCBmaXJlcyB0aGUgZm9jdXMgZXZlbnQgaXMgbm90IHlldCBpbiB0aGUgZXZlbnQgcXVldWUuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gd2UgY2FuJ3QgcmVseSBvbiB0aGUgdHJpY2sgdXNlZCBhYm92ZSAoc2V0dGluZyB0aW1lb3V0IG9mIDBtcykuIEluc3RlYWQgd2Ugd2FpdCA2NTBtcyB0b1xuICAgICAgICAvLyBzZWUgaWYgYSBmb2N1cyBoYXBwZW5zLlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3RvdWNoVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl90b3VjaFRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2xhc3RUb3VjaFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIF90aGlzLl90b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9sYXN0VG91Y2hUYXJnZXQgPSBudWxsOyB9LCBUT1VDSF9CVUZGRVJfTVMpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgLy8gTWFrZSBhIG5vdGUgb2Ygd2hlbiB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXMsIHNvIHdlIGNhbiByZXN0b3JlIHRoZSBvcmlnaW4gaW5mbyBmb3IgdGhlXG4gICAgICAgIC8vIGZvY3VzZWQgZWxlbWVudC5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3dpbmRvd0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fd2luZG93Rm9jdXNlZCA9IGZhbHNlOyB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmb2N1cyBjbGFzc2VzIG9uIHRoZSBlbGVtZW50IGJhc2VkIG9uIHRoZSBnaXZlbiBmb2N1cyBvcmlnaW4uXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHVwZGF0ZSB0aGUgY2xhc3NlcyBvbi5cbiAgICAgKiBAcGFyYW0gez89fSBvcmlnaW4gVGhlIGZvY3VzIG9yaWdpbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuX3NldENsYXNzZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3JpZ2luKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRJbmZvID0gdGhpcy5fZWxlbWVudEluZm8uZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudEluZm8pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgc2hvdWxkU2V0KSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0ID8gZWxlbWVudEluZm8ucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSA6XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJbmZvLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoJ2Nkay1mb2N1c2VkJywgISFvcmlnaW4pO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoJ2Nkay10b3VjaC1mb2N1c2VkJywgb3JpZ2luID09PSAndG91Y2gnKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKCdjZGsta2V5Ym9hcmQtZm9jdXNlZCcsIG9yaWdpbiA9PT0gJ2tleWJvYXJkJyk7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcygnY2RrLW1vdXNlLWZvY3VzZWQnLCBvcmlnaW4gPT09ICdtb3VzZScpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoJ2Nkay1wcm9ncmFtLWZvY3VzZWQnLCBvcmlnaW4gPT09ICdwcm9ncmFtJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG9yaWdpbiBhbmQgc2NoZWR1bGVzIGFuIGFzeW5jIGZ1bmN0aW9uIHRvIGNsZWFyIGl0IGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IHF1ZXVlLlxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luIFRoZSBvcmlnaW4gdG8gc2V0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNPcmlnaW5Nb25pdG9yLnByb3RvdHlwZS5fc2V0T3JpZ2luRm9yQ3VycmVudEV2ZW50UXVldWUgPSBmdW5jdGlvbiAob3JpZ2luKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX29yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb3JpZ2luID0gbnVsbDsgfSwgMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gZm9jdXMgZXZlbnQgd2FzIGNhdXNlZCBieSBhIHRvdWNoc3RhcnQgZXZlbnQuXG4gICAgICogQHBhcmFtIHs/fSBldmVudCBUaGUgZm9jdXMgZXZlbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7P30gV2hldGhlciB0aGUgZXZlbnQgd2FzIGNhdXNlZCBieSBhIHRvdWNoLlxuICAgICAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuX3dhc0NhdXNlZEJ5VG91Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gTm90ZShtbWFsZXJiYSk6IFRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IHF1aXRlIHBlcmZlY3QsIHRoZXJlIGlzIGEgc21hbGwgZWRnZSBjYXNlLlxuICAgICAgICAvLyBDb25zaWRlciB0aGUgZm9sbG93aW5nIGRvbSBzdHJ1Y3R1cmU6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDxkaXYgI3BhcmVudCB0YWJpbmRleD1cIjBcIiBjZGtGb2N1c0NsYXNzZXM+XG4gICAgICAgIC8vICAgPGRpdiAjY2hpbGQgKGNsaWNrKT1cIiNwYXJlbnQuZm9jdXMoKVwiPjwvZGl2PlxuICAgICAgICAvLyA8L2Rpdj5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdG91Y2hlcyB0aGUgI2NoaWxkIGVsZW1lbnQgYW5kIHRoZSAjcGFyZW50IGlzIHByb2dyYW1tYXRpY2FsbHkgZm9jdXNlZCBhcyBhXG4gICAgICAgIC8vIHJlc3VsdCwgdGhpcyBjb2RlIHdpbGwgc3RpbGwgY29uc2lkZXIgaXQgdG8gaGF2ZSBiZWVuIGNhdXNlZCBieSB0aGUgdG91Y2ggZXZlbnQgYW5kIHdpbGxcbiAgICAgICAgLy8gYXBwbHkgdGhlIGNkay10b3VjaC1mb2N1c2VkIGNsYXNzIHJhdGhlciB0aGFuIHRoZSBjZGstcHJvZ3JhbS1mb2N1c2VkIGNsYXNzLiBUaGlzIGlzIGFcbiAgICAgICAgLy8gcmVsYXRpdmVseSBzbWFsbCBlZGdlLWNhc2UgdGhhdCBjYW4gYmUgd29ya2VkIGFyb3VuZCBieSB1c2luZ1xuICAgICAgICAvLyBmb2N1c1ZpYShwYXJlbnRFbCwgcmVuZGVyZXIsICAncHJvZ3JhbScpIHRvIGZvY3VzIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgd2UgZGVjaWRlIHRoYXQgd2UgYWJzb2x1dGVseSBtdXN0IGhhbmRsZSB0aGlzIGNhc2UgY29ycmVjdGx5LCB3ZSBjYW4gZG8gc28gYnkgbGlzdGVuaW5nXG4gICAgICAgIC8vIGZvciB0aGUgZmlyc3QgZm9jdXMgZXZlbnQgYWZ0ZXIgdGhlIHRvdWNoc3RhcnQsIGFuZCB0aGVuIHRoZSBmaXJzdCBibHVyIGV2ZW50IGFmdGVyIHRoYXRcbiAgICAgICAgLy8gZm9jdXMgZXZlbnQuIFdoZW4gdGhhdCBibHVyIGV2ZW50IGZpcmVzIHdlIGtub3cgdGhhdCB3aGF0ZXZlciBmb2xsb3dzIGlzIG5vdCBhIHJlc3VsdCBvZiB0aGVcbiAgICAgICAgLy8gdG91Y2hzdGFydC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9jdXNUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0VG91Y2hUYXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIGZvY3VzVGFyZ2V0IGluc3RhbmNlb2YgTm9kZSAmJlxuICAgICAgICAgICAgKGZvY3VzVGFyZ2V0ID09PSB0aGlzLl9sYXN0VG91Y2hUYXJnZXQgfHwgZm9jdXNUYXJnZXQuY29udGFpbnModGhpcy5fbGFzdFRvdWNoVGFyZ2V0KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGZvY3VzIGV2ZW50cyBvbiBhIHJlZ2lzdGVyZWQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50IFRoZSBmb2N1cyBldmVudC5cbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgVGhlIG1vbml0b3JlZCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNPcmlnaW5Nb25pdG9yLnByb3RvdHlwZS5fb25Gb2N1cyA9IGZ1bmN0aW9uIChldmVudCwgZWxlbWVudCkge1xuICAgICAgICAvLyBOT1RFKG1tYWxlcmJhKTogV2UgY3VycmVudGx5IHNldCB0aGUgY2xhc3NlcyBiYXNlZCBvbiB0aGUgZm9jdXMgb3JpZ2luIG9mIHRoZSBtb3N0IHJlY2VudFxuICAgICAgICAvLyBmb2N1cyBldmVudCBhZmZlY3RpbmcgdGhlIG1vbml0b3JlZCBlbGVtZW50LiBJZiB3ZSB3YW50IHRvIHVzZSB0aGUgb3JpZ2luIG9mIHRoZSBmaXJzdCBldmVudFxuICAgICAgICAvLyBpbnN0ZWFkIHdlIHNob3VsZCBjaGVjayBmb3IgdGhlIGNkay1mb2N1c2VkIGNsYXNzIGhlcmUgYW5kIHJldHVybiBpZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhc1xuICAgICAgICAvLyBpdC4gKFRoaXMgb25seSBtYXR0ZXJzIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgaW5jbHVkZXNDaGlsZHJlbiA9IHRydWUpLlxuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGNvdW50aW5nIGNoaWxkLWVsZW1lbnQtZm9jdXMgYXMgZm9jdXNlZCwgbWFrZSBzdXJlIHRoYXQgdGhlIGV2ZW50IHRhcmdldCBpcyB0aGVcbiAgICAgICAgLy8gbW9uaXRvcmVkIGVsZW1lbnQgaXRzZWxmLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50SW5mbyA9IHRoaXMuX2VsZW1lbnRJbmZvLmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKCFlbGVtZW50SW5mbyB8fCAoIWVsZW1lbnRJbmZvLmNoZWNrQ2hpbGRyZW4gJiYgZWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGRldGVjdCBhIGNhdXNlIGZvciB0aGUgZm9jdXMgZXZlbnQsIGl0J3MgZHVlIHRvIG9uZSBvZiB0aHJlZSByZWFzb25zOlxuICAgICAgICAvLyAxKSBUaGUgd2luZG93IGhhcyBqdXN0IHJlZ2FpbmVkIGZvY3VzLCBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gcmVzdG9yZSB0aGUgZm9jdXNlZCBzdGF0ZSBvZlxuICAgICAgICAvLyAgICB0aGUgZWxlbWVudCBmcm9tIGJlZm9yZSB0aGUgd2luZG93IGJsdXJyZWQuXG4gICAgICAgIC8vIDIpIEl0IHdhcyBjYXVzZWQgYnkgYSB0b3VjaCBldmVudCwgaW4gd2hpY2ggY2FzZSB3ZSBtYXJrIHRoZSBvcmlnaW4gYXMgJ3RvdWNoJy5cbiAgICAgICAgLy8gMykgVGhlIGVsZW1lbnQgd2FzIHByb2dyYW1tYXRpY2FsbHkgZm9jdXNlZCwgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgbWFyayB0aGUgb3JpZ2luIGFzXG4gICAgICAgIC8vICAgICdwcm9ncmFtJy5cbiAgICAgICAgaWYgKCF0aGlzLl9vcmlnaW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl93aW5kb3dGb2N1c2VkICYmIHRoaXMuX2xhc3RGb2N1c09yaWdpbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbiA9IHRoaXMuX2xhc3RGb2N1c09yaWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3dhc0NhdXNlZEJ5VG91Y2goZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luID0gJ3RvdWNoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbiA9ICdwcm9ncmFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRDbGFzc2VzKGVsZW1lbnQsIHRoaXMuX29yaWdpbik7XG4gICAgICAgIGVsZW1lbnRJbmZvLnN1YmplY3QubmV4dCh0aGlzLl9vcmlnaW4pO1xuICAgICAgICB0aGlzLl9sYXN0Rm9jdXNPcmlnaW4gPSB0aGlzLl9vcmlnaW47XG4gICAgICAgIHRoaXMuX29yaWdpbiA9IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGJsdXIgZXZlbnRzIG9uIGEgcmVnaXN0ZXJlZCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnQgVGhlIGJsdXIgZXZlbnQuXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50IFRoZSBtb25pdG9yZWQgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uIChldmVudCwgZWxlbWVudCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgY291bnRpbmcgY2hpbGQtZWxlbWVudC1mb2N1cyBhcyBmb2N1c2VkLCBtYWtlIHN1cmUgdGhhdCB3ZSBhcmVuJ3QganVzdCBibHVycmluZyBpblxuICAgICAgICAvLyBvcmRlciB0byBmb2N1cyBhbm90aGVyIGNoaWxkIG9mIHRoZSBtb25pdG9yZWQgZWxlbWVudC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudEluZm8gPSB0aGlzLl9lbGVtZW50SW5mby5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmICghZWxlbWVudEluZm8gfHwgKGVsZW1lbnRJbmZvLmNoZWNrQ2hpbGRyZW4gJiYgZXZlbnQucmVsYXRlZFRhcmdldCBpbnN0YW5jZW9mIE5vZGUgJiZcbiAgICAgICAgICAgIGVsZW1lbnQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q2xhc3NlcyhlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudEluZm8uc3ViamVjdC5uZXh0KG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvY3VzT3JpZ2luTW9uaXRvcjtcbn0oKSk7XG5Gb2N1c09yaWdpbk1vbml0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkZvY3VzT3JpZ2luTW9uaXRvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCB9LFxuXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHRoYXQgZGV0ZXJtaW5lcyBob3cgYSBwYXJ0aWN1bGFyIGVsZW1lbnQgd2FzIGZvY3VzZWQgKHZpYSBrZXlib2FyZCwgbW91c2UsIHRvdWNoLCBvclxuICogcHJvZ3JhbW1hdGljYWxseSkgYW5kIGFkZHMgY29ycmVzcG9uZGluZyBjbGFzc2VzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gdmFyaWFudHMgb2YgdGhpcyBkaXJlY3RpdmU6XG4gKiAxKSBjZGtNb25pdG9yRWxlbWVudEZvY3VzOiBkb2VzIG5vdCBjb25zaWRlciBhbiBlbGVtZW50IHRvIGJlIGZvY3VzZWQgaWYgb25lIG9mIGl0cyBjaGlsZHJlbiBpc1xuICogICAgZm9jdXNlZC5cbiAqIDIpIGNka01vbml0b3JTdWJ0cmVlRm9jdXM6IGNvbnNpZGVycyBhbiBlbGVtZW50IGZvY3VzZWQgaWYgaXQgb3IgYW55IG9mIGl0cyBjaGlsZHJlbiBhcmUgZm9jdXNlZC5cbiAqL1xudmFyIENka01vbml0b3JGb2N1cyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c09yaWdpbk1vbml0b3JcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2RrTW9uaXRvckZvY3VzKF9lbGVtZW50UmVmLCBfZm9jdXNPcmlnaW5Nb25pdG9yLCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvciA9IF9mb2N1c09yaWdpbk1vbml0b3I7XG4gICAgICAgIHRoaXMuY2RrRm9jdXNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21vbml0b3JTdWJzY3JpcHRpb24gPSB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3IubW9uaXRvcih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHJlbmRlcmVyLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdjZGtNb25pdG9yU3VidHJlZUZvY3VzJykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChvcmlnaW4pIHsgcmV0dXJuIF90aGlzLmNka0ZvY3VzQ2hhbmdlLmVtaXQob3JpZ2luKTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2RrTW9uaXRvckZvY3VzLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLnN0b3BNb25pdG9yaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX21vbml0b3JTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBDZGtNb25pdG9yRm9jdXM7XG59KCkpO1xuQ2RrTW9uaXRvckZvY3VzLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrTW9uaXRvckVsZW1lbnRGb2N1c10sIFtjZGtNb25pdG9yU3VidHJlZUZvY3VzXScsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNka01vbml0b3JGb2N1cy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c09yaWdpbk1vbml0b3IsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG5dOyB9O1xuQ2RrTW9uaXRvckZvY3VzLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdjZGtGb2N1c0NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBAcGFyYW0gez99IHBhcmVudERpc3BhdGNoZXJcbiAqIEBwYXJhbSB7P30gbmdab25lXG4gKiBAcGFyYW0gez99IHBsYXRmb3JtXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBGT0NVU19PUklHSU5fTU9OSVRPUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudERpc3BhdGNoZXIsIG5nWm9uZSwgcGxhdGZvcm0pIHtcbiAgICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgRm9jdXNPcmlnaW5Nb25pdG9yKG5nWm9uZSwgcGxhdGZvcm0pO1xufVxudmFyIEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSID0ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBGb2N1c09yaWdpbk1vbml0b3IgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBGb2N1c09yaWdpbk1vbml0b3IsXG4gICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIEZvY3VzT3JpZ2luTW9uaXRvcl0sIE5nWm9uZSwgUGxhdGZvcm1dLFxuICAgIHVzZUZhY3Rvcnk6IEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSX0ZBQ1RPUllcbn07XG4vKipcbiAqIEFwcGxpZXMgYSBDU1MgdHJhbnNmb3JtIHRvIGFuIGVsZW1lbnQsIGluY2x1ZGluZyBicm93c2VyLXByZWZpeGVkIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gdHJhbnNmb3JtVmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q3NzVHJhbnNmb3JtKGVsZW1lbnQsIHRyYW5zZm9ybVZhbHVlKSB7XG4gICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdHJpbSB0aGUgcmVzdWx0LCBiZWNhdXNlIHRoZSBicm93c2VyIHdpbGwgaWdub3JlIHRoZSBzZXQgb3BlcmF0aW9uXG4gICAgLy8gaWYgdGhlIHN0cmluZyBjb250YWlucyBvbmx5IHdoaXRlc3BhY2UuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0cmFuc2Zvcm1WYWx1ZS50cmltKCk7XG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZTtcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHZhbHVlO1xufVxudmFyIFN0eWxlTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBTdHlsZU1vZHVsZTtcbn0oKSk7XG5TdHlsZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1BsYXRmb3JtTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtDZGtNb25pdG9yRm9jdXNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDZGtNb25pdG9yRm9jdXNdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0ZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU3R5bGVNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBBbmltYXRpb25DdXJ2ZXMgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25DdXJ2ZXMoKSB7XG4gICAgfVxuICAgIHJldHVybiBBbmltYXRpb25DdXJ2ZXM7XG59KCkpO1xuQW5pbWF0aW9uQ3VydmVzLlNUQU5EQVJEX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDAuMiwxKSc7XG5BbmltYXRpb25DdXJ2ZXMuREVDRUxFUkFUSU9OX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjAsMC4wLDAuMiwxKSc7XG5BbmltYXRpb25DdXJ2ZXMuQUNDRUxFUkFUSU9OX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDEsMSknO1xuQW5pbWF0aW9uQ3VydmVzLlNIQVJQX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDAuNiwxKSc7XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgQW5pbWF0aW9uRHVyYXRpb25zID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uRHVyYXRpb25zKCkge1xuICAgIH1cbiAgICByZXR1cm4gQW5pbWF0aW9uRHVyYXRpb25zO1xufSgpKTtcbkFuaW1hdGlvbkR1cmF0aW9ucy5DT01QTEVYID0gJzM3NW1zJztcbkFuaW1hdGlvbkR1cmF0aW9ucy5FTlRFUklORyA9ICcyMjVtcyc7XG5BbmltYXRpb25EdXJhdGlvbnMuRVhJVElORyA9ICcxOTVtcyc7XG4vKipcbiAqIEFkYXB0cyB0eXBlIGBEYCB0byBiZSB1c2FibGUgYXMgYSBkYXRlIGJ5IGNkay1iYXNlZCBjb21wb25lbnRzIHRoYXQgd29yayB3aXRoIGRhdGVzLlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBEYXRlQWRhcHRlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGVBZGFwdGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB5ZWFyIGNvbXBvbmVudCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGRhdGUgVGhlIGRhdGUgdG8gZXh0cmFjdCB0aGUgeWVhciBmcm9tLlxuICAgICAqIEByZXR1cm4gez99IFRoZSB5ZWFyIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0WWVhciA9IGZ1bmN0aW9uIChkYXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbW9udGggY29tcG9uZW50IG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSB0byBleHRyYWN0IHRoZSBtb250aCBmcm9tLlxuICAgICAqIEByZXR1cm4gez99IFRoZSBtb250aCBjb21wb25lbnQgKDAtaW5kZXhlZCwgMCA9IEphbnVhcnkpLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXRNb250aCA9IGZ1bmN0aW9uIChkYXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0ZSBvZiB0aGUgbW9udGggY29tcG9uZW50IG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSB0byBleHRyYWN0IHRoZSBkYXRlIG9mIHRoZSBtb250aCBmcm9tLlxuICAgICAqIEByZXR1cm4gez99IFRoZSBtb250aCBjb21wb25lbnQgKDEtaW5kZXhlZCwgMSA9IGZpcnN0IG9mIG1vbnRoKS5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF5IG9mIHRoZSB3ZWVrIGNvbXBvbmVudCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGRhdGUgVGhlIGRhdGUgdG8gZXh0cmFjdCB0aGUgZGF5IG9mIHRoZSB3ZWVrIGZyb20uXG4gICAgICogQHJldHVybiB7P30gVGhlIG1vbnRoIGNvbXBvbmVudCAoMC1pbmRleGVkLCAwID0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF5T2ZXZWVrID0gZnVuY3Rpb24gKGRhdGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBuYW1lcyBmb3IgdGhlIG1vbnRocy5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlIFRoZSBuYW1pbmcgc3R5bGUgKGUuZy4gbG9uZyA9ICdKYW51YXJ5Jywgc2hvcnQgPSAnSmFuJywgbmFycm93ID0gJ0onKS5cbiAgICAgKiBAcmV0dXJuIHs/fSBBbiBvcmRlcmVkIGxpc3Qgb2YgYWxsIG1vbnRoIG5hbWVzLCBzdGFydGluZyB3aXRoIEphbnVhcnkuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldE1vbnRoTmFtZXMgPSBmdW5jdGlvbiAoc3R5bGUkJDEpIHsgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBuYW1lcyBmb3IgdGhlIGRhdGVzIG9mIHRoZSBtb250aC5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJuIHs/fSBBbiBvcmRlcmVkIGxpc3Qgb2YgYWxsIGRhdGUgb2YgdGhlIG1vbnRoIG5hbWVzLCBzdGFydGluZyB3aXRoICcxJy5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0ZU5hbWVzID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIG5hbWVzIGZvciB0aGUgZGF5cyBvZiB0aGUgd2Vlay5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlIFRoZSBuYW1pbmcgc3R5bGUgKGUuZy4gbG9uZyA9ICdTdW5kYXknLCBzaG9ydCA9ICdTdW4nLCBuYXJyb3cgPSAnUycpLlxuICAgICAqIEByZXR1cm4gez99IEFuIG9yZGVyZWQgbGlzdCBvZiBhbGwgd2Vla2RheSBuYW1lcywgc3RhcnRpbmcgd2l0aCBTdW5kYXkuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldERheU9mV2Vla05hbWVzID0gZnVuY3Rpb24gKHN0eWxlJCQxKSB7IH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBmb3IgdGhlIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBkYXRlIFRoZSBkYXRlIHRvIGdldCB0aGUgeWVhciBuYW1lIGZvci5cbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgbmFtZSBvZiB0aGUgZ2l2ZW4geWVhciAoZS5nLiAnMjAxNycpLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXRZZWFyTmFtZSA9IGZ1bmN0aW9uIChkYXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAtaW5kZXhlZCwgMCA9IFN1bmRheSkuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldEZpcnN0RGF5T2ZXZWVrID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGRhdGUgVGhlIGRhdGUgd2hvc2UgbW9udGggc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7P30gVGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0TnVtRGF5c0luTW9udGggPSBmdW5jdGlvbiAoZGF0ZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGRhdGUgVGhlIGRhdGUgdG8gY2xvbmVcbiAgICAgKiBAcmV0dXJuIHs/fSBBIG5ldyBkYXRlIGVxdWFsIHRvIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChkYXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRhdGUgd2l0aCB0aGUgZ2l2ZW4geWVhciwgbW9udGgsIGFuZCBkYXRlLiBEb2VzIG5vdCBhbGxvdyBvdmVyL3VuZGVyLWZsb3cgb2YgdGhlXG4gICAgICogbW9udGggYW5kIGRhdGUuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB5ZWFyIFRoZSBmdWxsIHllYXIgb2YgdGhlIGRhdGUuIChlLmcuIDg5IG1lYW5zIHRoZSB5ZWFyIDg5LCBub3QgdGhlIHllYXIgMTk4OSkuXG4gICAgICogQHBhcmFtIHs/fSBtb250aCBUaGUgbW9udGggb2YgdGhlIGRhdGUgKDAtaW5kZXhlZCwgMCA9IEphbnVhcnkpLiBNdXN0IGJlIGFuIGludGVnZXIgMCAtIDExLlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSBvZiBtb250aCBvZiB0aGUgZGF0ZS4gTXVzdCBiZSBhbiBpbnRlZ2VyIDEgLSBsZW5ndGggb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAqIEByZXR1cm4gez99IFRoZSBuZXcgZGF0ZSwgb3IgbnVsbCBpZiBpbnZhbGlkLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVEYXRlID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkYXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0b2RheSdzIGRhdGUuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybiB7P30gVG9kYXkncyBkYXRlLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBkYXRlIGZyb20gYSB2YWx1ZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcGFyYW0gez99IHBhcnNlRm9ybWF0IFRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIHZhbHVlIGJlaW5nIHBhcnNlZFxuICAgICAqICAgICAodHlwZSBpcyBpbXBsZW1lbnRhdGlvbi1kZXBlbmRlbnQpLlxuICAgICAqIEByZXR1cm4gez99IFRoZSBwYXJzZWQgZGF0ZSwgb3IgbnVsbCBpZiBkYXRlIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHZhbHVlLCBwYXJzZUZvcm1hdCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSBkYXRlIGFzIGEgc3RyaW5nLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHBhcmFtIHs/fSBkaXNwbGF5Rm9ybWF0IFRoZSBmb3JtYXQgdG8gdXNlIHRvIGRpc3BsYXkgdGhlIGRhdGUgYXMgYSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7P30gVGhlIHBhcnNlZCBkYXRlLCBvciBudWxsIGlmIGRhdGUgY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGRpc3BsYXlGb3JtYXQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBudW1iZXIgb2YgeWVhcnMgdG8gdGhlIGRhdGUuIFllYXJzIGFyZSBjb3VudGVkIGFzIGlmIGZsaXBwaW5nIDEyIHBhZ2VzIG9uIHRoZVxuICAgICAqIGNhbGVuZGFyIGZvciBlYWNoIHllYXIgYW5kIHRoZW4gZmluZGluZyB0aGUgY2xvc2VzdCBkYXRlIGluIHRoZSBuZXcgbW9udGguIEZvciBleGFtcGxlIHdoZW5cbiAgICAgKiBhZGRpbmcgMSB5ZWFyIHRvIEZlYiAyOSwgMjAxNiwgdGhlIHJlc3VsdGluZyBkYXRlIHdpbGwgYmUgRmViIDI4LCAyMDE3LlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSB0byBhZGQgeWVhcnMgdG8uXG4gICAgICogQHBhcmFtIHs/fSB5ZWFycyBUaGUgbnVtYmVyIG9mIHllYXJzIHRvIGFkZCAobWF5IGJlIG5lZ2F0aXZlKS5cbiAgICAgKiBAcmV0dXJuIHs/fSBBIG5ldyBkYXRlIGVxdWFsIHRvIHRoZSBnaXZlbiBvbmUgd2l0aCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB5ZWFycyBhZGRlZC5cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuYWRkQ2FsZW5kYXJZZWFycyA9IGZ1bmN0aW9uIChkYXRlLCB5ZWFycykgeyB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIG51bWJlciBvZiBtb250aHMgdG8gdGhlIGRhdGUuIE1vbnRocyBhcmUgY291bnRlZCBhcyBpZiBmbGlwcGluZyBhIHBhZ2Ugb24gdGhlXG4gICAgICogY2FsZW5kYXIgZm9yIGVhY2ggbW9udGggYW5kIHRoZW4gZmluZGluZyB0aGUgY2xvc2VzdCBkYXRlIGluIHRoZSBuZXcgbW9udGguIEZvciBleGFtcGxlIHdoZW5cbiAgICAgKiBhZGRpbmcgMSBtb250aCB0byBKYW4gMzEsIDIwMTcsIHRoZSByZXN1bHRpbmcgZGF0ZSB3aWxsIGJlIEZlYiAyOCwgMjAxNy5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGRhdGUgVGhlIGRhdGUgdG8gYWRkIG1vbnRocyB0by5cbiAgICAgKiBAcGFyYW0gez99IG1vbnRocyBUaGUgbnVtYmVyIG9mIG1vbnRocyB0byBhZGQgKG1heSBiZSBuZWdhdGl2ZSkuXG4gICAgICogQHJldHVybiB7P30gQSBuZXcgZGF0ZSBlcXVhbCB0byB0aGUgZ2l2ZW4gb25lIHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbW9udGhzIGFkZGVkLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5hZGRDYWxlbmRhck1vbnRocyA9IGZ1bmN0aW9uIChkYXRlLCBtb250aHMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBudW1iZXIgb2YgZGF5cyB0byB0aGUgZGF0ZS4gRGF5cyBhcmUgY291bnRlZCBhcyBpZiBtb3Zpbmcgb25lIGNlbGwgb24gdGhlXG4gICAgICogY2FsZW5kYXIgZm9yIGVhY2ggZGF5LlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSB0byBhZGQgZGF5cyB0by5cbiAgICAgKiBAcGFyYW0gez99IGRheXMgVGhlIG51bWJlciBvZiBkYXlzIHRvIGFkZCAobWF5IGJlIG5lZ2F0aXZlKS5cbiAgICAgKiBAcmV0dXJuIHs/fSBBIG5ldyBkYXRlIGVxdWFsIHRvIHRoZSBnaXZlbiBvbmUgd2l0aCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkYXlzIGFkZGVkLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5hZGRDYWxlbmRhckRheXMgPSBmdW5jdGlvbiAoZGF0ZSwgZGF5cykgeyB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFJGQyAzMzM5IGNvbXBhdGlibGUgZGF0ZSBzdHJpbmcgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5KSAgZm9yIHRoZSBnaXZlblxuICAgICAqIGRhdGUuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBkYXRlIFRoZSBkYXRlIHRvIGdldCB0aGUgSVNPIGRhdGUgc3RyaW5nIGZvci5cbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgSVNPIGRhdGUgc3RyaW5nIGRhdGUgc3RyaW5nLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXRJU09EYXRlU3RyaW5nID0gZnVuY3Rpb24gKGRhdGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsb2NhbGUgdXNlZCBmb3IgYWxsIGRhdGVzLlxuICAgICAqIEBwYXJhbSB7P30gbG9jYWxlIFRoZSBuZXcgbG9jYWxlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLnNldExvY2FsZSA9IGZ1bmN0aW9uIChsb2NhbGUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0d28gZGF0ZXMuXG4gICAgICogQHBhcmFtIHs/fSBmaXJzdCBUaGUgZmlyc3QgZGF0ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7P30gc2Vjb25kIFRoZSBzZWNvbmQgZGF0ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm4gez99IDAgaWYgdGhlIGRhdGVzIGFyZSBlcXVhbCwgYSBudW1iZXIgbGVzcyB0aGFuIDAgaWYgdGhlIGZpcnN0IGRhdGUgaXMgZWFybGllcixcbiAgICAgKiAgICAgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAgaWYgdGhlIGZpcnN0IGRhdGUgaXMgbGF0ZXIuXG4gICAgICovXG4gICAgRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmNvbXBhcmVEYXRlID0gZnVuY3Rpb24gKGZpcnN0JCQxLCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0WWVhcihmaXJzdCQkMSkgLSB0aGlzLmdldFllYXIoc2Vjb25kKSB8fFxuICAgICAgICAgICAgdGhpcy5nZXRNb250aChmaXJzdCQkMSkgLSB0aGlzLmdldE1vbnRoKHNlY29uZCkgfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0RGF0ZShmaXJzdCQkMSkgLSB0aGlzLmdldERhdGUoc2Vjb25kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0d28gZGF0ZXMgYXJlIGVxdWFsLlxuICAgICAqIEBwYXJhbSB7P30gZmlyc3QgVGhlIGZpcnN0IGRhdGUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHs/fSBzZWNvbmQgVGhlIHNlY29uZCBkYXRlIHRvIGNoZWNrLlxuICAgICAqICAgICBOdWxsIGRhdGVzIGFyZSBjb25zaWRlcmVkIGVxdWFsIHRvIG90aGVyIG51bGwgZGF0ZXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRlQWRhcHRlci5wcm90b3R5cGUuc2FtZURhdGUgPSBmdW5jdGlvbiAoZmlyc3QkJDEsIHNlY29uZCkge1xuICAgICAgICByZXR1cm4gZmlyc3QkJDEgJiYgc2Vjb25kID8gIXRoaXMuY29tcGFyZURhdGUoZmlyc3QkJDEsIHNlY29uZCkgOiBmaXJzdCQkMSA9PSBzZWNvbmQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGFtcCB0aGUgZ2l2ZW4gZGF0ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4IGRhdGVzLlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZSBUaGUgZGF0ZSB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0gez89fSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdG8gYWxsb3cuIElmIG51bGwgb3Igb21pdHRlZCBubyBtaW4gaXMgZW5mb3JjZWQuXG4gICAgICogQHBhcmFtIHs/PX0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlIHRvIGFsbG93LiBJZiBudWxsIG9yIG9taXR0ZWQgbm8gbWF4IGlzIGVuZm9yY2VkLlxuICAgICAqIEByZXR1cm4gez99IGBtaW5gIGlmIGBkYXRlYCBpcyBsZXNzIHRoYW4gYG1pbmAsIGBtYXhgIGlmIGRhdGUgaXMgZ3JlYXRlciB0aGFuIGBtYXhgLFxuICAgICAqICAgICBvdGhlcndpc2UgYGRhdGVgLlxuICAgICAqL1xuICAgIERhdGVBZGFwdGVyLnByb3RvdHlwZS5jbGFtcERhdGUgPSBmdW5jdGlvbiAoZGF0ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKG1pbiAmJiB0aGlzLmNvbXBhcmVEYXRlKGRhdGUsIG1pbikgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggJiYgdGhpcy5jb21wYXJlRGF0ZShkYXRlLCBtYXgpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlQWRhcHRlcjtcbn0oKSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEludGwgQVBJLlxuICovXG52YXIgU1VQUE9SVFNfSU5UTF9BUEkgPSB0eXBlb2YgSW50bCAhPSAndW5kZWZpbmVkJztcbi8qKlxuICogVGhlIGRlZmF1bHQgbW9udGggbmFtZXMgdG8gdXNlIGlmIEludGwgQVBJIGlzIG5vdCBhdmFpbGFibGUuXG4gKi9cbnZhciBERUZBVUxUX01PTlRIX05BTUVTID0ge1xuICAgICdsb25nJzogW1xuICAgICAgICAnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLFxuICAgICAgICAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlcidcbiAgICBdLFxuICAgICdzaG9ydCc6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgICAnbmFycm93JzogWydKJywgJ0YnLCAnTScsICdBJywgJ00nLCAnSicsICdKJywgJ0EnLCAnUycsICdPJywgJ04nLCAnRCddXG59O1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBkYXRlIG5hbWVzIHRvIHVzZSBpZiBJbnRsIEFQSSBpcyBub3QgYXZhaWxhYmxlLlxuICovXG52YXIgREVGQVVMVF9EQVRFX05BTUVTID0gcmFuZ2UoMzEsIGZ1bmN0aW9uIChpKSB7IHJldHVybiBTdHJpbmcoaSArIDEpOyB9KTtcbi8qKlxuICogVGhlIGRlZmF1bHQgZGF5IG9mIHRoZSB3ZWVrIG5hbWVzIHRvIHVzZSBpZiBJbnRsIEFQSSBpcyBub3QgYXZhaWxhYmxlLlxuICovXG52YXIgREVGQVVMVF9EQVlfT0ZfV0VFS19OQU1FUyA9IHtcbiAgICAnbG9uZyc6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICAnc2hvcnQnOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAgICduYXJyb3cnOiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXVxufTtcbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBhbmQgZmlsbHMgaXQgd2l0aCB2YWx1ZXMuXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBsZW5ndGhcbiAqIEBwYXJhbSB7P30gdmFsdWVGdW5jdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmFuZ2UobGVuZ3RoLCB2YWx1ZUZ1bmN0aW9uKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVzQXJyYXkgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZXNBcnJheVtpXSA9IHZhbHVlRnVuY3Rpb24oaSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXNBcnJheTtcbn1cbi8qKlxuICogQWRhcHRzIHRoZSBuYXRpdmUgSlMgRGF0ZSBmb3IgdXNlIHdpdGggY2RrLWJhc2VkIGNvbXBvbmVudHMgdGhhdCB3b3JrIHdpdGggZGF0ZXMuXG4gKi9cbnZhciBOYXRpdmVEYXRlQWRhcHRlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE5hdGl2ZURhdGVBZGFwdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5hdGl2ZURhdGVBZGFwdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldFllYXIgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0TW9udGggPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldERhdGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldERheU9mV2VlayA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldERheSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldE1vbnRoTmFtZXMgPSBmdW5jdGlvbiAoc3R5bGUkJDEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKFNVUFBPUlRTX0lOVExfQVBJKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdGZfMSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7IG1vbnRoOiBzdHlsZSQkMSB9KTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZSgxMiwgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIF90aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkdGZfMS5mb3JtYXQobmV3IERhdGUoMjAxNywgaSwgMSkpKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERFRkFVTFRfTU9OVEhfTkFNRVNbc3R5bGUkJDFdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0ZU5hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR0Zl8yID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIHsgZGF5OiAnbnVtZXJpYycgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UoMzEsIGZ1bmN0aW9uIChpKSB7IHJldHVybiBfdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoZHRmXzIuZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDAsIGkgKyAxKSkpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gREVGQVVMVF9EQVRFX05BTUVTO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldERheU9mV2Vla05hbWVzID0gZnVuY3Rpb24gKHN0eWxlJCQxKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHRmXzMgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwgeyB3ZWVrZGF5OiBzdHlsZSQkMSB9KTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZSg3LCBmdW5jdGlvbiAoaSkgeyByZXR1cm4gX3RoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKGR0Zl8zLmZvcm1hdChuZXcgRGF0ZSgyMDE3LCAwLCBpICsgMSkpKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERFRkFVTFRfREFZX09GX1dFRUtfTkFNRVNbc3R5bGUkJDFdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0WWVhck5hbWUgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7IHllYXI6ICdudW1lcmljJyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkdGYuZm9ybWF0KGRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuZ2V0WWVhcihkYXRlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5nZXRGaXJzdERheU9mV2VlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgdGVsbCB1c2luZyBuYXRpdmUgSlMgRGF0ZSB3aGF0IHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgaXMsIHdlIGRlZmF1bHQgdG8gU3VuZGF5LlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmdldE51bURheXNJbk1vbnRoID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0ZSh0aGlzLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93KHRoaXMuZ2V0WWVhcihkYXRlKSwgdGhpcy5nZXRNb250aChkYXRlKSArIDEsIDApKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGF0ZSh0aGlzLmdldFllYXIoZGF0ZSksIHRoaXMuZ2V0TW9udGgoZGF0ZSksIHRoaXMuZ2V0RGF0ZShkYXRlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHllYXJcbiAgICAgKiBAcGFyYW0gez99IG1vbnRoXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlRGF0ZSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCwgZGF0ZSkge1xuICAgICAgICAvLyBDaGVjayBmb3IgaW52YWxpZCBtb250aCBhbmQgZGF0ZSAoZXhjZXB0IHVwcGVyIGJvdW5kIG9uIGRhdGUgd2hpY2ggd2UgaGF2ZSB0byBjaGVjayBhZnRlclxuICAgICAgICAvLyBjcmVhdGluZyB0aGUgRGF0ZSkuXG4gICAgICAgIGlmIChtb250aCA8IDAgfHwgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIG1vbnRoIGluZGV4IFxcXCJcIiArIG1vbnRoICsgXCJcXFwiLiBNb250aCBpbmRleCBoYXMgdG8gYmUgYmV0d2VlbiAwIGFuZCAxMS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGUgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgZGF0ZSBcXFwiXCIgKyBkYXRlICsgXCJcXFwiLiBEYXRlIGhhcyB0byBiZSBncmVhdGVyIHRoYW4gMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyh5ZWFyLCBtb250aCwgZGF0ZSk7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGRhdGUgd2Fzbid0IGFib3ZlIHRoZSB1cHBlciBib3VuZCBmb3IgdGhlIG1vbnRoLCBjYXVzaW5nIHRoZSBtb250aCB0byBvdmVyZmxvd1xuICAgICAgICBpZiAocmVzdWx0LmdldE1vbnRoKCkgIT0gbW9udGgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBkYXRlIFxcXCJcIiArIGRhdGUgKyBcIlxcXCIgZm9yIG1vbnRoIHdpdGggaW5kZXggXFxcIlwiICsgbW9udGggKyBcIlxcXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBubyB3YXkgdXNpbmcgdGhlIG5hdGl2ZSBKUyBEYXRlIHRvIHNldCB0aGUgcGFyc2UgZm9ybWF0IG9yIGxvY2FsZSwgc28gd2UgaWdub3JlIHRoZXNlXG4gICAgICAgIC8vIHBhcmFtZXRlcnMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWVzdGFtcCA9IHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDogRGF0ZS5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBpc05hTih0aW1lc3RhbXApID8gbnVsbCA6IG5ldyBEYXRlKHRpbWVzdGFtcCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcGFyYW0gez99IGRpc3BsYXlGb3JtYXRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgZGlzcGxheUZvcm1hdCkge1xuICAgICAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCBkaXNwbGF5Rm9ybWF0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkdGYuZm9ybWF0KGRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoZGF0ZS50b0RhdGVTdHJpbmcoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcGFyYW0gez99IHllYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuYWRkQ2FsZW5kYXJZZWFycyA9IGZ1bmN0aW9uIChkYXRlLCB5ZWFycykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRDYWxlbmRhck1vbnRocyhkYXRlLCB5ZWFycyAqIDEyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEBwYXJhbSB7P30gbW9udGhzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuYWRkQ2FsZW5kYXJNb250aHMgPSBmdW5jdGlvbiAoZGF0ZSwgbW9udGhzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld0RhdGUgPSB0aGlzLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93KHRoaXMuZ2V0WWVhcihkYXRlKSwgdGhpcy5nZXRNb250aChkYXRlKSArIG1vbnRocywgdGhpcy5nZXREYXRlKGRhdGUpKTtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0byB3aW5kIHVwIGluIHRoZSB3cm9uZyBtb250aCBpZiB0aGUgb3JpZ2luYWwgbW9udGggaGFzIG1vcmUgZGF5cyB0aGFuIHRoZSBuZXdcbiAgICAgICAgLy8gbW9udGguIEluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIGdvIHRvIHRoZSBsYXN0IGRheSBvZiB0aGUgZGVzaXJlZCBtb250aC5cbiAgICAgICAgLy8gTm90ZTogdGhlIGFkZGl0aW9uYWwgKyAxMiAlIDEyIGVuc3VyZXMgd2UgZW5kIHVwIHdpdGggYSBwb3NpdGl2ZSBudW1iZXIsIHNpbmNlIEpTICUgZG9lc24ndFxuICAgICAgICAvLyBndWFyYW50ZWUgdGhpcy5cbiAgICAgICAgaWYgKHRoaXMuZ2V0TW9udGgobmV3RGF0ZSkgIT0gKCh0aGlzLmdldE1vbnRoKGRhdGUpICsgbW9udGhzKSAlIDEyICsgMTIpICUgMTIpIHtcbiAgICAgICAgICAgIG5ld0RhdGUgPSB0aGlzLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93KHRoaXMuZ2V0WWVhcihuZXdEYXRlKSwgdGhpcy5nZXRNb250aChuZXdEYXRlKSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcGFyYW0gez99IGRheXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5hZGRDYWxlbmRhckRheXMgPSBmdW5jdGlvbiAoZGF0ZSwgZGF5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyh0aGlzLmdldFllYXIoZGF0ZSksIHRoaXMuZ2V0TW9udGgoZGF0ZSksIHRoaXMuZ2V0RGF0ZShkYXRlKSArIGRheXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuZ2V0SVNPRGF0ZVN0cmluZyA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICB0aGlzLl8yZGlnaXQoZGF0ZS5nZXRVVENNb250aCgpICsgMSksXG4gICAgICAgICAgICB0aGlzLl8yZGlnaXQoZGF0ZS5nZXRVVENEYXRlKCkpXG4gICAgICAgIF0uam9pbignLScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRhdGUgYnV0IGFsbG93cyB0aGUgbW9udGggYW5kIGRhdGUgdG8gb3ZlcmZsb3cuXG4gICAgICogQHBhcmFtIHs/fSB5ZWFyXG4gICAgICogQHBhcmFtIHs/fSBtb250aFxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmF0aXZlRGF0ZUFkYXB0ZXIucHJvdG90eXBlLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkYXRlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXRlKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjb3JyZWN0IGZvciB0aGUgZmFjdCB0aGF0IEpTIG5hdGl2ZSBEYXRlIHRyZWF0cyB5ZWFycyBpbiByYW5nZSBbMCwgOTldIGFzXG4gICAgICAgIC8vIGFiYnJldmlhdGlvbnMgZm9yIDE5eHguXG4gICAgICAgIGlmICh5ZWFyID49IDAgJiYgeWVhciA8IDEwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHRoaXMuZ2V0WWVhcihyZXN1bHQpIC0gMTkwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhZHMgYSBudW1iZXIgdG8gbWFrZSBpdCB0d28gZGlnaXRzLlxuICAgICAqIEBwYXJhbSB7P30gbiBUaGUgbnVtYmVyIHRvIHBhZC5cbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgcGFkZGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBOYXRpdmVEYXRlQWRhcHRlci5wcm90b3R5cGUuXzJkaWdpdCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiAoJzAwJyArIG4pLnNsaWNlKC0yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0cmlwIG91dCB1bmljb2RlIExUUiBhbmQgUlRMIGNoYXJhY3RlcnMuIEVkZ2UgYW5kIElFIGluc2VydCB0aGVzZSBpbnRvIGZvcm1hdHRlZCBkYXRlcyB3aGlsZVxuICAgICAqIG90aGVyIGJyb3dzZXJzIGRvIG5vdC4gV2UgcmVtb3ZlIHRoZW0gdG8gbWFrZSBvdXRwdXQgY29uc2lzdGVudCBhbmQgYmVjYXVzZSB0aGV5IGludGVyZmVyZSB3aXRoXG4gICAgICogZGF0ZSBwYXJzaW5nLlxuICAgICAqIEBwYXJhbSB7P30gc3RyIFRoZSBzdHJpbmcgdG8gc3RyaXAgZGlyZWN0aW9uIGNoYXJhY3RlcnMgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgc3RyaXBwZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIE5hdGl2ZURhdGVBZGFwdGVyLnByb3RvdHlwZS5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdTIwMGVcXHUyMDBmXS9nLCAnJyk7XG4gICAgfTtcbiAgICByZXR1cm4gTmF0aXZlRGF0ZUFkYXB0ZXI7XG59KERhdGVBZGFwdGVyKSk7XG52YXIgTURfREFURV9GT1JNQVRTID0gbmV3IEluamVjdGlvblRva2VuKCdtZC1kYXRlLWZvcm1hdHMnKTtcbnZhciBNRF9OQVRJVkVfREFURV9GT1JNQVRTID0ge1xuICAgIHBhcnNlOiB7XG4gICAgICAgIGRhdGVJbnB1dDogbnVsbCxcbiAgICB9LFxuICAgIGRpc3BsYXk6IHtcbiAgICAgICAgZGF0ZUlucHV0OiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycgfSxcbiAgICAgICAgbW9udGhZZWFyTGFiZWw6IHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ3Nob3J0JyB9LFxuICAgICAgICBkYXRlQTExeUxhYmVsOiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfSxcbiAgICAgICAgbW9udGhZZWFyQTExeUxhYmVsOiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9LFxuICAgIH1cbn07XG52YXIgTmF0aXZlRGF0ZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hdGl2ZURhdGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBOYXRpdmVEYXRlTW9kdWxlO1xufSgpKTtcbk5hdGl2ZURhdGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogRGF0ZUFkYXB0ZXIsIHVzZUNsYXNzOiBOYXRpdmVEYXRlQWRhcHRlciB9XSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTmF0aXZlRGF0ZU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIE1kTmF0aXZlRGF0ZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTmF0aXZlRGF0ZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTmF0aXZlRGF0ZU1vZHVsZTtcbn0oKSk7XG5NZE5hdGl2ZURhdGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtOYXRpdmVEYXRlTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE1EX0RBVEVfRk9STUFUUywgdXNlVmFsdWU6IE1EX05BVElWRV9EQVRFX0ZPUk1BVFMgfV0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTmF0aXZlRGF0ZU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBJbmplY3Rpb25Ub2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGdsb2JhbCBwbGFjZWhvbGRlciBvcHRpb25zLlxuICovXG52YXIgTURfUExBQ0VIT0xERVJfR0xPQkFMX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ21kLXBsYWNlaG9sZGVyLWdsb2JhbC1vcHRpb25zJyk7XG4vKipcbiAqIEluamVjdGlvbiB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGdsb2JhbCBlcnJvciBvcHRpb25zLlxuICovXG52YXIgTURfRVJST1JfR0xPQkFMX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ21kLWVycm9yLWdsb2JhbC1vcHRpb25zJyk7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBjb250cm9sIGlzIGludmFsaWQgYW5kIGlzIGVpdGhlciB0b3VjaGVkIG9yIGlzIGEgcGFydCBvZiBhIHN1Ym1pdHRlZCBmb3JtLlxuICogQHBhcmFtIHs/fSBjb250cm9sXG4gKiBAcGFyYW0gez99IGZvcm1cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvclN0YXRlTWF0Y2hlcihjb250cm9sLCBmb3JtKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNTdWJtaXR0ZWQgPSBmb3JtICYmIGZvcm0uc3VibWl0dGVkO1xuICAgIHJldHVybiAhIShjb250cm9sLmludmFsaWQgJiYgKGNvbnRyb2wudG91Y2hlZCB8fCBpc1N1Ym1pdHRlZCkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgY29udHJvbCBpcyBpbnZhbGlkIGFuZCBpcyBlaXRoZXIgZGlydHkgb3IgaXMgYSBwYXJ0IG9mIGEgc3VibWl0dGVkIGZvcm0uXG4gKiBAcGFyYW0gez99IGNvbnRyb2xcbiAqIEBwYXJhbSB7P30gZm9ybVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc2hvd09uRGlydHlFcnJvclN0YXRlTWF0Y2hlcihjb250cm9sLCBmb3JtKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNTdWJtaXR0ZWQgPSBmb3JtICYmIGZvcm0uc3VibWl0dGVkO1xuICAgIHJldHVybiAhIShjb250cm9sLmludmFsaWQgJiYgKGNvbnRyb2wuZGlydHkgfHwgaXNTdWJtaXR0ZWQpKTtcbn1cbnZhciBNZENvcmVNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENvcmVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENvcmVNb2R1bGU7XG59KCkpO1xuTWRDb3JlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kTGluZU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgQmlkaU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRSaXBwbGVNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE9ic2VydmVDb250ZW50TW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBQb3J0YWxNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIEExMXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kT3B0aW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZFNlbGVjdGlvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRMaW5lTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBCaWRpTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZFJpcHBsZU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgT2JzZXJ2ZUNvbnRlbnRNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFBvcnRhbE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgQTExeU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRPcHRpb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kU2VsZWN0aW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ29yZU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQnV0dG9uVG9nZ2xlR3JvdXBCYXNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGVHcm91cEJhc2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEJ1dHRvblRvZ2dsZUdyb3VwQmFzZTtcbn0oKSk7XG52YXIgX01kQnV0dG9uVG9nZ2xlR3JvdXBNaXhpbkJhc2UgPSBtaXhpbkRpc2FibGVkKE1kQnV0dG9uVG9nZ2xlR3JvdXBCYXNlKTtcbi8qKlxuICogUHJvdmlkZXIgRXhwcmVzc2lvbiB0aGF0IGFsbG93cyBtZC1idXR0b24tdG9nZ2xlLWdyb3VwIHRvIHJlZ2lzdGVyIGFzIGEgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gKiBUaGlzIGFsbG93cyBpdCB0byBzdXBwb3J0IFsobmdNb2RlbCldLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNRF9CVVRUT05fVE9HR0xFX0dST1VQX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlR3JvdXA7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIF91bmlxdWVJZENvdW50ZXIkMSA9IDA7XG4vKipcbiAqIENoYW5nZSBldmVudCBvYmplY3QgZW1pdHRlZCBieSBNZEJ1dHRvblRvZ2dsZS5cbiAqL1xudmFyIE1kQnV0dG9uVG9nZ2xlQ2hhbmdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGVDaGFuZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEJ1dHRvblRvZ2dsZUNoYW5nZTtcbn0oKSk7XG4vKipcbiAqIEV4Y2x1c2l2ZSBzZWxlY3Rpb24gYnV0dG9uIHRvZ2dsZSBncm91cCB0aGF0IGJlaGF2ZXMgbGlrZSBhIHJhZGlvLWJ1dHRvbiBncm91cC5cbiAqL1xudmFyIE1kQnV0dG9uVG9nZ2xlR3JvdXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZEJ1dHRvblRvZ2dsZUdyb3VwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uVG9nZ2xlR3JvdXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFsdWUgZm9yIHRoZSBidXR0b24gdG9nZ2xlIGdyb3VwLiBTaG91bGQgbWF0Y2ggY3VycmVudGx5IHNlbGVjdGVkIGJ1dHRvbiB0b2dnbGUuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEhUTUwgbmFtZSBhdHRyaWJ1dGUgYXBwbGllZCB0byB0b2dnbGVzIGluIHRoaXMgZ3JvdXAuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fbmFtZSA9IFwibWQtYnV0dG9uLXRvZ2dsZS1ncm91cC1cIiArIF91bmlxdWVJZENvdW50ZXIkMSsrO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYnV0dG9uIHRvZ2dsZSBncm91cCBzaG91bGQgYmUgdmVydGljYWwuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgYnV0dG9uIHRvZ2dsZSwgc2hvdWxkIG1hdGNoIHRoZSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBidXR0b24gdG9nZ2xlIGdyb3VwIGlzIGluaXRpYWxpemVkIG9yIG5vdC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWV0aG9kIHRvIGJlIGNhbGxlZCBpbiBvcmRlciB0byB1cGRhdGUgbmdNb2RlbC5cbiAgICAgICAgICogTm93IGBuZ01vZGVsYCBiaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbXVsdGlwbGUgc2VsZWN0aW9uIG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9uVG91Y2ggZnVuY3Rpb24gcmVnaXN0ZXJlZCB2aWEgcmVnaXN0ZXJPblRvdWNoIChDb250cm9sVmFsdWVBY2Nlc3NvcikuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGdyb3VwJ3MgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgbmFtZWAgYXR0cmlidXRlIGZvciB0aGUgdW5kZXJseWluZyBgaW5wdXRgIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJ1dHRvblRvZ2dsZU5hbWVzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB0b2dnbGUgZ3JvdXAgaXMgdmVydGljYWwuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJ0aWNhbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92ZXJ0aWNhbCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZSBvZiB0aGUgdG9nZ2xlIGdyb3VwLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5ld1ZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlICE9IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZEJ1dHRvblRvZ2dsZUZyb21WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgZW1pdCBhIGNoYW5nZSBldmVudCBpZiB0aGUgdmlldyBpcyBjb21wbGV0ZWx5IGluaXRpYWxpemVkLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gZW1pdCBhIGNoYW5nZSBldmVudCBmb3IgdGhlIGluaXRpYWwgdmFsdWVzLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRvZ2dsZSBncm91cCBpcyBzZWxlY3RlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBzZWxlY3RlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gc2VsZWN0ZWQgPyBzZWxlY3RlZC52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgIXNlbGVjdGVkLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5fdXBkYXRlQnV0dG9uVG9nZ2xlTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9idXR0b25Ub2dnbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9idXR0b25Ub2dnbGVzLmZvckVhY2goZnVuY3Rpb24gKHRvZ2dsZSkge1xuICAgICAgICAgICAgICAgIHRvZ2dsZS5uYW1lID0gX3RoaXMuX25hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5fdXBkYXRlU2VsZWN0ZWRCdXR0b25Ub2dnbGVGcm9tVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzQWxyZWFkeVNlbGVjdGVkID0gdGhpcy5fc2VsZWN0ZWQgIT0gbnVsbCAmJiB0aGlzLl9zZWxlY3RlZC52YWx1ZSA9PSB0aGlzLl92YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2J1dHRvblRvZ2dsZXMgIT0gbnVsbCAmJiAhaXNBbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoaW5nQnV0dG9uVG9nZ2xlID0gdGhpcy5fYnV0dG9uVG9nZ2xlcy5maWx0ZXIoZnVuY3Rpb24gKGJ1dHRvblRvZ2dsZSkgeyByZXR1cm4gYnV0dG9uVG9nZ2xlLnZhbHVlID09IF90aGlzLl92YWx1ZTsgfSlbMF07XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdCdXR0b25Ub2dnbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gbWF0Y2hpbmdCdXR0b25Ub2dnbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9idXR0b25Ub2dnbGVzLmZvckVhY2goZnVuY3Rpb24gKGJ1dHRvblRvZ2dsZSkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25Ub2dnbGUuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBjaGFuZ2UgZXZlbnQgd2l0aCBjdXJyZW50IHNlbGVjdGlvbiBhbmQgZ3JvdXAgdmFsdWUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudCA9IG5ldyBNZEJ1dHRvblRvZ2dsZUNoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgZXZlbnQudmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbihldmVudC52YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW9kZWwgdmFsdWUuIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZSBWYWx1ZSB0byBiZSBzZXQgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBmbiBPbiBjaGFuZ2UgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgY29udHJvbCBoYXMgYmVlbiB0b3VjaGVkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBmbiBPbiB0b3VjaCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZCBXaGV0aGVyIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH07XG4gICAgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlR3JvdXA7XG59KF9NZEJ1dHRvblRvZ2dsZUdyb3VwTWl4aW5CYXNlKSk7XG5NZEJ1dHRvblRvZ2dsZUdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1idXR0b24tdG9nZ2xlLWdyb3VwOm5vdChbbXVsdGlwbGVdKSwgbWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXA6bm90KFttdWx0aXBsZV0pJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9CVVRUT05fVE9HR0xFX0dST1VQX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3JhZGlvZ3JvdXAnLFxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXAnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1idXR0b24tdG9nZ2xlLXZlcnRpY2FsXSc6ICd2ZXJ0aWNhbCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRCdXR0b25Ub2dnbGVHcm91cCcsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQnV0dG9uVG9nZ2xlR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbk1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ19idXR0b25Ub2dnbGVzJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZEJ1dHRvblRvZ2dsZTsgfSksXSB9LF0sXG4gICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3ZlcnRpY2FsJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc2VsZWN0ZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBNdWx0aXBsZSBzZWxlY3Rpb24gYnV0dG9uLXRvZ2dsZSBncm91cC4gYG5nTW9kZWxgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBtb2RlLlxuICovXG52YXIgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGJ1dHRvbiB0b2dnbGUgZ3JvdXAgc2hvdWxkIGJlIHZlcnRpY2FsLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3ZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZS5wcm90b3R5cGUsIFwidmVydGljYWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdG9nZ2xlIGdyb3VwIGlzIHZlcnRpY2FsLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVydGljYWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmVydGljYWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlO1xufShfTWRCdXR0b25Ub2dnbGVHcm91cE1peGluQmFzZSkpO1xuTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1idXR0b24tdG9nZ2xlLWdyb3VwW211bHRpcGxlXSwgbWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXBbbXVsdGlwbGVdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21kQnV0dG9uVG9nZ2xlR3JvdXAnLFxuICAgICAgICAgICAgICAgIGlucHV0czogWydkaXNhYmxlZCddLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1idXR0b24tdG9nZ2xlLWdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYnV0dG9uLXRvZ2dsZS12ZXJ0aWNhbF0nOiAndmVydGljYWwnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbk1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAndmVydGljYWwnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xuLyoqXG4gKiBTaW5nbGUgYnV0dG9uIGluc2lkZSBvZiBhIHRvZ2dsZSBncm91cC5cbiAqL1xudmFyIE1kQnV0dG9uVG9nZ2xlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2dnbGVHcm91cFxuICAgICAqIEBwYXJhbSB7P30gdG9nZ2xlR3JvdXBNdWx0aXBsZVxuICAgICAqIEBwYXJhbSB7P30gX2J1dHRvblRvZ2dsZURpc3BhdGNoZXJcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c09yaWdpbk1vbml0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZEJ1dHRvblRvZ2dsZSh0b2dnbGVHcm91cCwgdG9nZ2xlR3JvdXBNdWx0aXBsZSwgX2J1dHRvblRvZ2dsZURpc3BhdGNoZXIsIF9yZW5kZXJlciwgX2VsZW1lbnRSZWYsIF9mb2N1c09yaWdpbk1vbml0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYnV0dG9uVG9nZ2xlRGlzcGF0Y2hlciA9IF9idXR0b25Ub2dnbGVEaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3IgPSBfZm9jdXNPcmlnaW5Nb25pdG9yO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyBidXR0b24gdG9nZ2xlIGlzIGNoZWNrZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGJ1dHRvbiB0b2dnbGUgaXMgZGlzYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgYXNzaWduZWQgdG8gdGhpcyBidXR0b24gdG9nZ2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGJ1dHRvbiB0b2dnbGUgaXMgYSBzaW5nbGUgc2VsZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXNTaW5nbGVTZWxlY3RvciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciBmdW5jdGlvbiBmb3IgX2J1dHRvblRvZ2dsZURpc3BhdGNoZXIgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVtb3ZlVW5pcXVlU2VsZWN0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGdyb3VwIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVHcm91cCA9IHRvZ2dsZUdyb3VwO1xuICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUgPSB0b2dnbGVHcm91cE11bHRpcGxlO1xuICAgICAgICBpZiAodGhpcy5idXR0b25Ub2dnbGVHcm91cCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVW5pcXVlU2VsZWN0aW9uTGlzdGVuZXIgPVxuICAgICAgICAgICAgICAgIF9idXR0b25Ub2dnbGVEaXNwYXRjaGVyLmxpc3RlbihmdW5jdGlvbiAoaWQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkICE9IF90aGlzLmlkICYmIG5hbWUgPT0gX3RoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ3JhZGlvJztcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAubmFtZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2luZ2xlU2VsZWN0b3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGVyZSBpcyBubyBncm91cCBhdCBhbGwsIHRyZWF0IHRoZSBidXR0b24gdG9nZ2xlIGFzIGEgY2hlY2tib3ggc28gaXQgY2FuIGJlXG4gICAgICAgICAgICAvLyB0b2dnbGVkIG9uIG9yIG9mZi5cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICAgICAgdGhpcy5faXNTaW5nbGVTZWxlY3RvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmlxdWUgSUQgZm9yIHRoZSB1bmRlcmx5aW5nIGBpbnB1dGAgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWQgKyBcIi1pbnB1dFwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImNoZWNrZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYnV0dG9uIGlzIGNoZWNrZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZXdDaGVja2VkU3RhdGVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0NoZWNrZWRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2luZ2xlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbGwgYnV0dG9uIHRvZ2dsZXMgd2l0aCB0aGUgc2FtZSBuYW1lIChpbiB0aGUgc2FtZSBncm91cCkgdG8gdW4tY2hlY2suXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1dHRvblRvZ2dsZURpc3BhdGNoZXIubm90aWZ5KHRoaXMuaWQsIHRoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hlY2tlZCA9IG5ld0NoZWNrZWRTdGF0ZTtcbiAgICAgICAgICAgIGlmIChuZXdDaGVja2VkU3RhdGUgJiYgdGhpcy5faXNTaW5nbGVTZWxlY3RvciAmJiB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLnZhbHVlICE9IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLnNlbGVjdGVkID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZEJ1dHRvblRvZ2dsZUdyb3VwIHJlYWRzIHRoaXMgdG8gYXNzaWduIGl0cyBvd24gdmFsdWUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idXR0b25Ub2dnbGVHcm91cCAhPSBudWxsICYmIHRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYnV0dG9uIGlzIGRpc2FibGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQgfHwgKHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAgIT0gbnVsbCAmJiB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLmRpc2FibGVkKSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUgIT0gbnVsbCAmJiB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUuZGlzYWJsZWQpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBcIm1kLWJ1dHRvbi10b2dnbGUtXCIgKyBfdW5pcXVlSWRDb3VudGVyJDErKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idXR0b25Ub2dnbGVHcm91cCAmJiB0aGlzLl92YWx1ZSA9PSB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3IubW9uaXRvcih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuX3JlbmRlcmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGJ1dHRvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgYnV0dG9uIHRvZ2dsZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZS5fdG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBidXR0b24gdG9nZ2xlIGR1ZSB0byBhbiBpbnRlcmFjdGlvbiB3aXRoIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUuX29uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NpbmdsZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAvLyBQcm9wYWdhdGUgdGhlIGNoYW5nZSBvbmUtd2F5IHZpYSB0aGUgZ3JvdXAsIHdoaWNoIHdpbGwgaW4gdHVybiBtYXJrIHRoaXNcbiAgICAgICAgICAgIC8vIGJ1dHRvbiB0b2dnbGUgYXMgY2hlY2tlZC5cbiAgICAgICAgICAgIHRoaXMuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLnNlbGVjdGVkID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAub25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWl0IGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlIG5hdGl2ZSBpbnB1dCBkb2VzLlxuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZS5fb25JbnB1dENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBmb3IgY2xpY2sgZXZlbnRzIG9uIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0IGVsZW1lbnQuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIGxhYmVsIGVsZW1lbnQsIGEgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZGlzcGF0Y2hlZCBvbiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBlbGVtZW50LiBTaW5jZSB3ZSBhcmUgdXNpbmcgYSBsYWJlbCBlbGVtZW50IGFzIG91clxuICAgICAgICAvLyByb290IGNvbnRhaW5lciwgdGhlIGNsaWNrIGV2ZW50IG9uIHRoZSBgc2xpZGUtdG9nZ2xlYCB3aWxsIGJlIGV4ZWN1dGVkIHR3aWNlLlxuICAgICAgICAvLyBUaGUgcmVhbCBjbGljayBldmVudCB3aWxsIGJ1YmJsZSB1cCwgYW5kIHRoZSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgYWxzbyB0cmllcyB0byBidWJibGUgdXAuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBsZWFkIHRvIG11bHRpcGxlIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgLy8gUHJldmVudGluZyBidWJibGluZyBmb3IgdGhlIHNlY29uZCBldmVudCB3aWxsIHNvbHZlIHRoYXQgaXNzdWUuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggY2hhbmdlIGV2ZW50IHdpdGggY3VycmVudCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudCA9IG5ldyBNZEJ1dHRvblRvZ2dsZUNoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLmNoYW5nZS5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVVbmlxdWVTZWxlY3Rpb25MaXN0ZW5lcigpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlO1xufSgpKTtcbk1kQnV0dG9uVG9nZ2xlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtYnV0dG9uLXRvZ2dsZSwgbWF0LWJ1dHRvbi10b2dnbGUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxsYWJlbCBbYXR0ci5mb3JdPVxcXCJpbnB1dElkXFxcIiBjbGFzcz1cXFwibWF0LWJ1dHRvbi10b2dnbGUtbGFiZWxcXFwiPjxpbnB1dCAjaW5wdXQgY2xhc3M9XFxcIm1hdC1idXR0b24tdG9nZ2xlLWlucHV0IGNkay12aXN1YWxseS1oaWRkZW5cXFwiIFt0eXBlXT1cXFwiX3R5cGVcXFwiIFtpZF09XFxcImlucHV0SWRcXFwiIFtjaGVja2VkXT1cXFwiY2hlY2tlZFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWQgfHwgbnVsbFxcXCIgW25hbWVdPVxcXCJuYW1lXFxcIiAoY2hhbmdlKT1cXFwiX29uSW5wdXRDaGFuZ2UoJGV2ZW50KVxcXCIgKGNsaWNrKT1cXFwiX29uSW5wdXRDbGljaygkZXZlbnQpXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50XFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+PC9sYWJlbD48ZGl2IGNsYXNzPVxcXCJtYXQtYnV0dG9uLXRvZ2dsZS1mb2N1cy1vdmVybGF5XFxcIj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtYnV0dG9uLXRvZ2dsZS1ncm91cCwubWF0LWJ1dHRvbi10b2dnbGUtc3RhbmRhbG9uZXtib3gtc2hhZG93OjAgM3B4IDFweCAtMnB4IHJnYmEoMCwwLDAsLjIpLDAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCA1cHggMCByZ2JhKDAsMCwwLC4xMik7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7Ym9yZGVyLXJhZGl1czoycHg7Y3Vyc29yOnBvaW50ZXI7d2hpdGUtc3BhY2U6bm93cmFwfS5tYXQtYnV0dG9uLXRvZ2dsZS12ZXJ0aWNhbHtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Lm1hdC1idXR0b24tdG9nZ2xlLXZlcnRpY2FsIC5tYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50e2Rpc3BsYXk6YmxvY2t9Lm1hdC1idXR0b24tdG9nZ2xlLWRpc2FibGVkIC5tYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50e2N1cnNvcjpkZWZhdWx0fS5tYXQtYnV0dG9uLXRvZ2dsZXt3aGl0ZS1zcGFjZTpub3dyYXA7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC1idXR0b24tdG9nZ2xlLmNkay1rZXlib2FyZC1mb2N1c2VkIC5tYXQtYnV0dG9uLXRvZ2dsZS1mb2N1cy1vdmVybGF5e29wYWNpdHk6MX0ubWF0LWJ1dHRvbi10b2dnbGUtbGFiZWwtY29udGVudHstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGluZS1oZWlnaHQ6MzZweDtwYWRkaW5nOjAgMTZweDtjdXJzb3I6cG9pbnRlcn0ubWF0LWJ1dHRvbi10b2dnbGUtbGFiZWwtY29udGVudD4qe3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWF0LWJ1dHRvbi10b2dnbGUtZm9jdXMtb3ZlcmxheXtib3JkZXItcmFkaXVzOmluaGVyaXQ7cG9pbnRlci1ldmVudHM6bm9uZTtvcGFjaXR5OjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjB9XCJdLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1idXR0b24tdG9nZ2xlLXN0YW5kYWxvbmVdJzogJyFidXR0b25Ub2dnbGVHcm91cCAmJiAhYnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZScsXG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtYnV0dG9uLXRvZ2dsZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQnV0dG9uVG9nZ2xlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTWRCdXR0b25Ub2dnbGVHcm91cCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlciwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c09yaWdpbk1vbml0b3IsIH0sXG5dOyB9O1xuTWRCdXR0b25Ub2dnbGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ19pbnB1dEVsZW1lbnQnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnaW5wdXQnLF0gfSxdLFxuICAgICdpZCc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nIH0sIHsgdHlwZTogSW5wdXQgfSxdLFxuICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdjaGVja2VkJzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubWF0LWJ1dHRvbi10b2dnbGUtY2hlY2tlZCcsXSB9LCB7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2Rpc2FibGVkJzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubWF0LWJ1dHRvbi10b2dnbGUtZGlzYWJsZWQnLF0gfSwgeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xudmFyIE1kQnV0dG9uVG9nZ2xlTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEJ1dHRvblRvZ2dsZU1vZHVsZTtcbn0oKSk7XG5NZEJ1dHRvblRvZ2dsZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0Zvcm1zTW9kdWxlLCBNZENvbW1vbk1vZHVsZSwgU3R5bGVNb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRCdXR0b25Ub2dnbGVHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICBNZEJ1dHRvblRvZ2dsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZEJ1dHRvblRvZ2dsZUdyb3VwLCBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUsIE1kQnV0dG9uVG9nZ2xlXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVJdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQnV0dG9uVG9nZ2xlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIERlZmF1bHQgY29sb3IgcGFsZXR0ZSBmb3Igcm91bmQgYnV0dG9ucyAobWQtZmFiIGFuZCBtZC1taW5pLWZhYilcbiAqL1xudmFyIERFRkFVTFRfUk9VTkRfQlVUVE9OX0NPTE9SID0gJ2FjY2VudCc7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEJ1dHRvbkNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRCdXR0b25Dc3NNYXRTdHlsZXI7XG59KCkpO1xuTWRCdXR0b25Dc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvblttZC1idXR0b25dLCBidXR0b25bbWF0LWJ1dHRvbl0sIGFbbWQtYnV0dG9uXSwgYVttYXQtYnV0dG9uXScsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWJ1dHRvbicgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEJ1dHRvbkNzc01hdFN0eWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFJhaXNlZEJ1dHRvbkNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyO1xufSgpKTtcbk1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbWQtcmFpc2VkLWJ1dHRvbl0sIGJ1dHRvblttYXQtcmFpc2VkLWJ1dHRvbl0sICcgK1xuICAgICAgICAgICAgICAgICAgICAnYVttZC1yYWlzZWQtYnV0dG9uXSwgYVttYXQtcmFpc2VkLWJ1dHRvbl0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21hdC1yYWlzZWQtYnV0dG9uJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXI7XG59KCkpO1xuTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbWQtaWNvbi1idXR0b25dLCBidXR0b25bbWF0LWljb24tYnV0dG9uXSwgYVttZC1pY29uLWJ1dHRvbl0sIGFbbWF0LWljb24tYnV0dG9uXScsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWljb24tYnV0dG9uJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRGYWIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGJ1dHRvblxuICAgICAqIEBwYXJhbSB7P30gYW5jaG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRGYWIoYnV0dG9uLCBhbmNob3IpIHtcbiAgICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IGNvbG9yIHBhbGV0dGUgZm9yIHRoZSBtZC1mYWIgY29tcG9uZW50cy5cbiAgICAgICAgKGJ1dHRvbiB8fCBhbmNob3IpLmNvbG9yID0gREVGQVVMVF9ST1VORF9CVVRUT05fQ09MT1I7XG4gICAgfVxuICAgIHJldHVybiBNZEZhYjtcbn0oKSk7XG5NZEZhYi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYnV0dG9uW21kLWZhYl0sIGJ1dHRvblttYXQtZmFiXSwgYVttZC1mYWJdLCBhW21hdC1mYWJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtZmFiJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kRmFiLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTWRCdXR0b24sIGRlY29yYXRvcnM6IFt7IHR5cGU6IFNlbGYgfSwgeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW2ZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRCdXR0b247IH0pLF0gfSxdIH0sXG4gICAgeyB0eXBlOiBNZEFuY2hvciwgZGVjb3JhdG9yczogW3sgdHlwZTogU2VsZiB9LCB7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZEFuY2hvcjsgfSksXSB9LF0gfSxcbl07IH07XG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IHRhcmdldHMgbWluaS1mYWIgYnV0dG9ucyBhbmQgYW5jaG9ycy4gSXQncyB1c2VkIHRvIGFwcGx5IHRoZSBgbWF0LWAgY2xhc3NcbiAqIHRvIGFsbCBtaW5pLWZhYiBidXR0b25zIGFuZCBhbHNvIGlzIHJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIHRoZSBkZWZhdWx0IGNvbG9yIHBhbGV0dGUuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTWluaUZhYiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYnV0dG9uXG4gICAgICogQHBhcmFtIHs/fSBhbmNob3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZE1pbmlGYWIoYnV0dG9uLCBhbmNob3IpIHtcbiAgICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IGNvbG9yIHBhbGV0dGUgZm9yIHRoZSBtZC1taW5pLWZhYiBjb21wb25lbnRzLlxuICAgICAgICAoYnV0dG9uIHx8IGFuY2hvcikuY29sb3IgPSBERUZBVUxUX1JPVU5EX0JVVFRPTl9DT0xPUjtcbiAgICB9XG4gICAgcmV0dXJuIE1kTWluaUZhYjtcbn0oKSk7XG5NZE1pbmlGYWIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvblttZC1taW5pLWZhYl0sIGJ1dHRvblttYXQtbWluaS1mYWJdLCBhW21kLW1pbmktZmFiXSwgYVttYXQtbWluaS1mYWJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtbWluaS1mYWInIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRNaW5pRmFiLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTWRCdXR0b24sIGRlY29yYXRvcnM6IFt7IHR5cGU6IFNlbGYgfSwgeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW2ZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRCdXR0b247IH0pLF0gfSxdIH0sXG4gICAgeyB0eXBlOiBNZEFuY2hvciwgZGVjb3JhdG9yczogW3sgdHlwZTogU2VsZiB9LCB7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZEFuY2hvcjsgfSksXSB9LF0gfSxcbl07IH07XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRCdXR0b25CYXNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRCdXR0b25CYXNlKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG4gICAgcmV0dXJuIE1kQnV0dG9uQmFzZTtcbn0oKSk7XG52YXIgX01kQnV0dG9uTWl4aW5CYXNlID0gbWl4aW5Db2xvcihtaXhpbkRpc2FibGVkKE1kQnV0dG9uQmFzZSkpO1xuLyoqXG4gKiBNYXRlcmlhbCBkZXNpZ24gYnV0dG9uLlxuICovXG52YXIgTWRCdXR0b24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZEJ1dHRvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfcGxhdGZvcm1cbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c09yaWdpbk1vbml0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZEJ1dHRvbihyZW5kZXJlciwgZWxlbWVudFJlZiwgX3BsYXRmb3JtLCBfZm9jdXNPcmlnaW5Nb25pdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlbmRlcmVyLCBlbGVtZW50UmVmKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIF90aGlzLl9mb2N1c09yaWdpbk1vbml0b3IgPSBfZm9jdXNPcmlnaW5Nb25pdG9yO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYnV0dG9uIGlzIHJvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2lzUm91bmRCdXR0b24gPSBfdGhpcy5faGFzQXR0cmlidXRlV2l0aFByZWZpeCgnZmFiJywgJ21pbmktZmFiJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBidXR0b24gaXMgaWNvbiBidXR0b24uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5faXNJY29uQnV0dG9uID0gX3RoaXMuX2hhc0F0dHJpYnV0ZVdpdGhQcmVmaXgoJ2ljb24tYnV0dG9uJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IG9uIGNsaWNrIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9kaXNhYmxlUmlwcGxlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9mb2N1c09yaWdpbk1vbml0b3IubW9uaXRvcihfdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBfdGhpcy5fcmVuZGVyZXIsIHRydWUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvbi5wcm90b3R5cGUsIFwiZGlzYWJsZVJpcHBsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IGZvciB0aGlzIGJ1dHRvbiBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLl9kaXNhYmxlUmlwcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHYpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQnV0dG9uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLnN0b3BNb25pdG9yaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBidXR0b24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2dldEhvc3RFbGVtZW50KCkuZm9jdXMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9nZXRIb3N0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9pc1JpcHBsZURpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlUmlwcGxlIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGJ1dHRvbiBoYXMgb25lIG9mIHRoZSBnaXZlbiBhdHRyaWJ1dGVzXG4gICAgICogd2l0aCBlaXRoZXIgYW4gJ21kLScgb3IgJ21hdC0nIHByZWZpeC5cbiAgICAgKiBAcGFyYW0gey4uLj99IHVucHJlZml4ZWRBdHRyaWJ1dGVOYW1lc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9oYXNBdHRyaWJ1dGVXaXRoUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdW5wcmVmaXhlZEF0dHJpYnV0ZU5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB1bnByZWZpeGVkQXR0cmlidXRlTmFtZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3Qgb24gdGhlIGJyb3dzZXIsIHNheSB0aGF0IHRoZXJlIGFyZSBub25lIG9mIHRoZSBhdHRyaWJ1dGVzIHByZXNlbnQuXG4gICAgICAgIC8vIFNpbmNlIHRoZXNlIG9ubHkgYWZmZWN0IGhvdyB0aGUgcmlwcGxlIGRpc3BsYXlzIChhbmQgcmlwcGxlcyBvbmx5IGhhcHBlbiBvbiB0aGUgY2xpZW50KSxcbiAgICAgICAgLy8gZGV0ZWN0aW5nIHRoZXNlIGF0dHJpYnV0ZXMgaXNuJ3QgbmVjZXNzYXJ5IHdoZW4gbm90IG9uIHRoZSBicm93c2VyLlxuICAgICAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bnByZWZpeGVkQXR0cmlidXRlTmFtZXMuc29tZShmdW5jdGlvbiAoc3VmZml4KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IF90aGlzLl9nZXRIb3N0RWxlbWVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSgnbWQtJyArIHN1ZmZpeCkgfHwgZWwuaGFzQXR0cmlidXRlKCdtYXQtJyArIHN1ZmZpeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1kQnV0dG9uO1xufShfTWRCdXR0b25NaXhpbkJhc2UpKTtcbk1kQnV0dG9uLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnYnV0dG9uW21kLWJ1dHRvbl0sIGJ1dHRvblttZC1yYWlzZWQtYnV0dG9uXSwgYnV0dG9uW21kLWljb24tYnV0dG9uXSwnICtcbiAgICAgICAgICAgICAgICAgICAgJ2J1dHRvblttZC1mYWJdLCBidXR0b25bbWQtbWluaS1mYWJdLCcgK1xuICAgICAgICAgICAgICAgICAgICAnYnV0dG9uW21hdC1idXR0b25dLCBidXR0b25bbWF0LXJhaXNlZC1idXR0b25dLCBidXR0b25bbWF0LWljb24tYnV0dG9uXSwnICtcbiAgICAgICAgICAgICAgICAgICAgJ2J1dHRvblttYXQtZmFiXSwgYnV0dG9uW21hdC1taW5pLWZhYl0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1tkaXNhYmxlZF0nOiAnZGlzYWJsZWQgfHwgbnVsbCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8c3BhbiBjbGFzcz1cXFwibWF0LWJ1dHRvbi13cmFwcGVyXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPjxkaXYgbWQtcmlwcGxlIGNsYXNzPVxcXCJtYXQtYnV0dG9uLXJpcHBsZVxcXCIgW2NsYXNzLm1hdC1idXR0b24tcmlwcGxlLXJvdW5kXT1cXFwiX2lzUm91bmRCdXR0b24gfHwgX2lzSWNvbkJ1dHRvblxcXCIgW21kUmlwcGxlRGlzYWJsZWRdPVxcXCJfaXNSaXBwbGVEaXNhYmxlZCgpXFxcIiBbbWRSaXBwbGVDZW50ZXJlZF09XFxcIl9pc0ljb25CdXR0b25cXFwiIFttZFJpcHBsZVRyaWdnZXJdPVxcXCJfZ2V0SG9zdEVsZW1lbnQoKVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5XFxcIj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtYnV0dG9uLC5tYXQtZmFiLC5tYXQtaWNvbi1idXR0b24sLm1hdC1taW5pLWZhYiwubWF0LXJhaXNlZC1idXR0b257Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtjdXJzb3I6cG9pbnRlcjtvdXRsaW5lOjA7Ym9yZGVyOm5vbmU7LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O2Rpc3BsYXk6aW5saW5lLWJsb2NrO3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LWRlY29yYXRpb246bm9uZTt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZTt0ZXh0LWFsaWduOmNlbnRlcjttYXJnaW46MDttaW4td2lkdGg6ODhweDtsaW5lLWhlaWdodDozNnB4O3BhZGRpbmc6MCAxNnB4O2JvcmRlci1yYWRpdXM6MnB4fVtkaXNhYmxlZF0ubWF0LWJ1dHRvbixbZGlzYWJsZWRdLm1hdC1mYWIsW2Rpc2FibGVkXS5tYXQtaWNvbi1idXR0b24sW2Rpc2FibGVkXS5tYXQtbWluaS1mYWIsW2Rpc2FibGVkXS5tYXQtcmFpc2VkLWJ1dHRvbntjdXJzb3I6ZGVmYXVsdH0uY2RrLWtleWJvYXJkLWZvY3VzZWQubWF0LWJ1dHRvbiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5jZGsta2V5Ym9hcmQtZm9jdXNlZC5tYXQtZmFiIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLmNkay1rZXlib2FyZC1mb2N1c2VkLm1hdC1pY29uLWJ1dHRvbiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5jZGsta2V5Ym9hcmQtZm9jdXNlZC5tYXQtbWluaS1mYWIgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwuY2RrLWtleWJvYXJkLWZvY3VzZWQubWF0LXJhaXNlZC1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXtvcGFjaXR5OjF9Lm1hdC1idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsLm1hdC1mYWI6Oi1tb3otZm9jdXMtaW5uZXIsLm1hdC1pY29uLWJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lciwubWF0LW1pbmktZmFiOjotbW96LWZvY3VzLWlubmVyLC5tYXQtcmFpc2VkLWJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH0ubWF0LWZhYiwubWF0LW1pbmktZmFiLC5tYXQtcmFpc2VkLWJ1dHRvbntib3gtc2hhZG93OjAgM3B4IDFweCAtMnB4IHJnYmEoMCwwLDAsLjIpLDAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCA1cHggMCByZ2JhKDAsMCwwLC4xMik7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2l0aW9uOmJhY2tncm91bmQgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJveC1zaGFkb3cgMjgwbXMgY3ViaWMtYmV6aWVyKC40LDAsLjIsMSl9Lm1hdC1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZSwubWF0LW1pbmktZmFiOm5vdChbZGlzYWJsZWRdKTphY3RpdmUsLm1hdC1yYWlzZWQtYnV0dG9uOm5vdChbZGlzYWJsZWRdKTphY3RpdmV7Ym94LXNoYWRvdzowIDVweCA1cHggLTNweCByZ2JhKDAsMCwwLC4yKSwwIDhweCAxMHB4IDFweCByZ2JhKDAsMCwwLC4xNCksMCAzcHggMTRweCAycHggcmdiYSgwLDAsMCwuMTIpfVtkaXNhYmxlZF0ubWF0LWZhYixbZGlzYWJsZWRdLm1hdC1taW5pLWZhYixbZGlzYWJsZWRdLm1hdC1yYWlzZWQtYnV0dG9ue2JveC1zaGFkb3c6bm9uZX0ubWF0LWJ1dHRvbiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtaWNvbi1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXt0cmFuc2l0aW9uOm5vbmU7b3BhY2l0eTowfS5tYXQtYnV0dG9uOmhvdmVyIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7b3BhY2l0eToxfS5tYXQtZmFie2JveC1zaGFkb3c6MCAzcHggNXB4IC0xcHggcmdiYSgwLDAsMCwuMiksMCA2cHggMTBweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCAxOHB4IDAgcmdiYSgwLDAsMCwuMTIpO21pbi13aWR0aDowO2JvcmRlci1yYWRpdXM6NTAlO3dpZHRoOjU2cHg7aGVpZ2h0OjU2cHg7cGFkZGluZzowO2ZsZXgtc2hyaW5rOjB9Lm1hdC1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZXtib3gtc2hhZG93OjAgN3B4IDhweCAtNHB4IHJnYmEoMCwwLDAsLjIpLDAgMTJweCAxN3B4IDJweCByZ2JhKDAsMCwwLC4xNCksMCA1cHggMjJweCA0cHggcmdiYSgwLDAsMCwuMTIpfS5tYXQtZmFiIC5tYXQtaWNvbiwubWF0LWZhYiBpe3BhZGRpbmc6MTZweCAwO2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1taW5pLWZhYntib3gtc2hhZG93OjAgM3B4IDVweCAtMXB4IHJnYmEoMCwwLDAsLjIpLDAgNnB4IDEwcHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggMThweCAwIHJnYmEoMCwwLDAsLjEyKTttaW4td2lkdGg6MDtib3JkZXItcmFkaXVzOjUwJTt3aWR0aDo0MHB4O2hlaWdodDo0MHB4O3BhZGRpbmc6MDtmbGV4LXNocmluazowfS5tYXQtbWluaS1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZXtib3gtc2hhZG93OjAgN3B4IDhweCAtNHB4IHJnYmEoMCwwLDAsLjIpLDAgMTJweCAxN3B4IDJweCByZ2JhKDAsMCwwLC4xNCksMCA1cHggMjJweCA0cHggcmdiYSgwLDAsMCwuMTIpfS5tYXQtbWluaS1mYWIgLm1hdC1pY29uLC5tYXQtbWluaS1mYWIgaXtwYWRkaW5nOjhweCAwO2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1pY29uLWJ1dHRvbntwYWRkaW5nOjA7bWluLXdpZHRoOjA7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDtmbGV4LXNocmluazowO2xpbmUtaGVpZ2h0OjQwcHg7Ym9yZGVyLXJhZGl1czo1MCV9Lm1hdC1pY29uLWJ1dHRvbiAubWF0LWljb24sLm1hdC1pY29uLWJ1dHRvbiBpe2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1idXR0b24sLm1hdC1pY29uLWJ1dHRvbiwubWF0LXJhaXNlZC1idXR0b257Y29sb3I6Y3VycmVudENvbG9yfS5tYXQtYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+KiwubWF0LWljb24tYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+KiwubWF0LXJhaXNlZC1idXR0b24gLm1hdC1idXR0b24td3JhcHBlcj4qe3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uLXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MDtwb2ludGVyLWV2ZW50czpub25lfS5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC4xMik7Ym9yZGVyLXJhZGl1czppbmhlcml0O29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjJzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSksYmFja2dyb3VuZC1jb2xvciAuMnMgY3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5e2JhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsMjU1LDI1NSwuNSl9fS5tYXQtYnV0dG9uLXJpcHBsZS1yb3VuZHtib3JkZXItcmFkaXVzOjUwJTt6LWluZGV4OjF9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC1idXR0b24sLm1hdC1mYWIsLm1hdC1pY29uLWJ1dHRvbiwubWF0LW1pbmktZmFiLC5tYXQtcmFpc2VkLWJ1dHRvbntvdXRsaW5lOnNvbGlkIDFweH19XCJdLFxuICAgICAgICAgICAgICAgIGlucHV0czogWydkaXNhYmxlZCcsICdjb2xvciddLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQnV0dG9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCB9LFxuICAgIHsgdHlwZTogRm9jdXNPcmlnaW5Nb25pdG9yLCB9LFxuXTsgfTtcbk1kQnV0dG9uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdkaXNhYmxlUmlwcGxlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbi8qKlxuICogUmFpc2VkIE1hdGVyaWFsIGRlc2lnbiBidXR0b24uXG4gKi9cbnZhciBNZEFuY2hvciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kQW5jaG9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1cbiAgICAgKiBAcGFyYW0gez99IGZvY3VzT3JpZ2luTW9uaXRvclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZEFuY2hvcihwbGF0Zm9ybSwgZm9jdXNPcmlnaW5Nb25pdG9yLCBlbGVtZW50UmVmLCByZW5kZXJlcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcmVuZGVyZXIsIGVsZW1lbnRSZWYsIHBsYXRmb3JtLCBmb2N1c09yaWdpbk1vbml0b3IpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEFuY2hvci5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAZG9jcy1wcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gLTEgOiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEFuY2hvci5wcm90b3R5cGUuX2hhbHREaXNhYmxlZEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBBIGRpc2FibGVkIGJ1dHRvbiBzaG91bGRuJ3QgYXBwbHkgYW55IGFjdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kQW5jaG9yO1xufShNZEJ1dHRvbikpO1xuTWRBbmNob3IuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6IFwiYVttZC1idXR0b25dLCBhW21kLXJhaXNlZC1idXR0b25dLCBhW21kLWljb24tYnV0dG9uXSwgYVttZC1mYWJdLCBhW21kLW1pbmktZmFiXSxcXG4gICAgICAgICAgICAgYVttYXQtYnV0dG9uXSwgYVttYXQtcmFpc2VkLWJ1dHRvbl0sIGFbbWF0LWljb24tYnV0dG9uXSwgYVttYXQtZmFiXSwgYVttYXQtbWluaS1mYWJdXCIsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuZGlzYWJsZWRdJzogJ2Rpc2FibGVkIHx8IG51bGwnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQudG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19oYWx0RGlzYWJsZWRFdmVudHMoJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnZGlzYWJsZWQnLCAnY29sb3InXSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8c3BhbiBjbGFzcz1cXFwibWF0LWJ1dHRvbi13cmFwcGVyXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPjxkaXYgbWQtcmlwcGxlIGNsYXNzPVxcXCJtYXQtYnV0dG9uLXJpcHBsZVxcXCIgW2NsYXNzLm1hdC1idXR0b24tcmlwcGxlLXJvdW5kXT1cXFwiX2lzUm91bmRCdXR0b24gfHwgX2lzSWNvbkJ1dHRvblxcXCIgW21kUmlwcGxlRGlzYWJsZWRdPVxcXCJfaXNSaXBwbGVEaXNhYmxlZCgpXFxcIiBbbWRSaXBwbGVDZW50ZXJlZF09XFxcIl9pc0ljb25CdXR0b25cXFwiIFttZFJpcHBsZVRyaWdnZXJdPVxcXCJfZ2V0SG9zdEVsZW1lbnQoKVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5XFxcIj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtYnV0dG9uLC5tYXQtZmFiLC5tYXQtaWNvbi1idXR0b24sLm1hdC1taW5pLWZhYiwubWF0LXJhaXNlZC1idXR0b257Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtjdXJzb3I6cG9pbnRlcjtvdXRsaW5lOjA7Ym9yZGVyOm5vbmU7LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O2Rpc3BsYXk6aW5saW5lLWJsb2NrO3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LWRlY29yYXRpb246bm9uZTt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZTt0ZXh0LWFsaWduOmNlbnRlcjttYXJnaW46MDttaW4td2lkdGg6ODhweDtsaW5lLWhlaWdodDozNnB4O3BhZGRpbmc6MCAxNnB4O2JvcmRlci1yYWRpdXM6MnB4fVtkaXNhYmxlZF0ubWF0LWJ1dHRvbixbZGlzYWJsZWRdLm1hdC1mYWIsW2Rpc2FibGVkXS5tYXQtaWNvbi1idXR0b24sW2Rpc2FibGVkXS5tYXQtbWluaS1mYWIsW2Rpc2FibGVkXS5tYXQtcmFpc2VkLWJ1dHRvbntjdXJzb3I6ZGVmYXVsdH0uY2RrLWtleWJvYXJkLWZvY3VzZWQubWF0LWJ1dHRvbiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5jZGsta2V5Ym9hcmQtZm9jdXNlZC5tYXQtZmFiIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLmNkay1rZXlib2FyZC1mb2N1c2VkLm1hdC1pY29uLWJ1dHRvbiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5jZGsta2V5Ym9hcmQtZm9jdXNlZC5tYXQtbWluaS1mYWIgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwuY2RrLWtleWJvYXJkLWZvY3VzZWQubWF0LXJhaXNlZC1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXtvcGFjaXR5OjF9Lm1hdC1idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsLm1hdC1mYWI6Oi1tb3otZm9jdXMtaW5uZXIsLm1hdC1pY29uLWJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lciwubWF0LW1pbmktZmFiOjotbW96LWZvY3VzLWlubmVyLC5tYXQtcmFpc2VkLWJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH0ubWF0LWZhYiwubWF0LW1pbmktZmFiLC5tYXQtcmFpc2VkLWJ1dHRvbntib3gtc2hhZG93OjAgM3B4IDFweCAtMnB4IHJnYmEoMCwwLDAsLjIpLDAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCA1cHggMCByZ2JhKDAsMCwwLC4xMik7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2l0aW9uOmJhY2tncm91bmQgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJveC1zaGFkb3cgMjgwbXMgY3ViaWMtYmV6aWVyKC40LDAsLjIsMSl9Lm1hdC1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZSwubWF0LW1pbmktZmFiOm5vdChbZGlzYWJsZWRdKTphY3RpdmUsLm1hdC1yYWlzZWQtYnV0dG9uOm5vdChbZGlzYWJsZWRdKTphY3RpdmV7Ym94LXNoYWRvdzowIDVweCA1cHggLTNweCByZ2JhKDAsMCwwLC4yKSwwIDhweCAxMHB4IDFweCByZ2JhKDAsMCwwLC4xNCksMCAzcHggMTRweCAycHggcmdiYSgwLDAsMCwuMTIpfVtkaXNhYmxlZF0ubWF0LWZhYixbZGlzYWJsZWRdLm1hdC1taW5pLWZhYixbZGlzYWJsZWRdLm1hdC1yYWlzZWQtYnV0dG9ue2JveC1zaGFkb3c6bm9uZX0ubWF0LWJ1dHRvbiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtaWNvbi1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXt0cmFuc2l0aW9uOm5vbmU7b3BhY2l0eTowfS5tYXQtYnV0dG9uOmhvdmVyIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7b3BhY2l0eToxfS5tYXQtZmFie2JveC1zaGFkb3c6MCAzcHggNXB4IC0xcHggcmdiYSgwLDAsMCwuMiksMCA2cHggMTBweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCAxOHB4IDAgcmdiYSgwLDAsMCwuMTIpO21pbi13aWR0aDowO2JvcmRlci1yYWRpdXM6NTAlO3dpZHRoOjU2cHg7aGVpZ2h0OjU2cHg7cGFkZGluZzowO2ZsZXgtc2hyaW5rOjB9Lm1hdC1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZXtib3gtc2hhZG93OjAgN3B4IDhweCAtNHB4IHJnYmEoMCwwLDAsLjIpLDAgMTJweCAxN3B4IDJweCByZ2JhKDAsMCwwLC4xNCksMCA1cHggMjJweCA0cHggcmdiYSgwLDAsMCwuMTIpfS5tYXQtZmFiIC5tYXQtaWNvbiwubWF0LWZhYiBpe3BhZGRpbmc6MTZweCAwO2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1taW5pLWZhYntib3gtc2hhZG93OjAgM3B4IDVweCAtMXB4IHJnYmEoMCwwLDAsLjIpLDAgNnB4IDEwcHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggMThweCAwIHJnYmEoMCwwLDAsLjEyKTttaW4td2lkdGg6MDtib3JkZXItcmFkaXVzOjUwJTt3aWR0aDo0MHB4O2hlaWdodDo0MHB4O3BhZGRpbmc6MDtmbGV4LXNocmluazowfS5tYXQtbWluaS1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZXtib3gtc2hhZG93OjAgN3B4IDhweCAtNHB4IHJnYmEoMCwwLDAsLjIpLDAgMTJweCAxN3B4IDJweCByZ2JhKDAsMCwwLC4xNCksMCA1cHggMjJweCA0cHggcmdiYSgwLDAsMCwuMTIpfS5tYXQtbWluaS1mYWIgLm1hdC1pY29uLC5tYXQtbWluaS1mYWIgaXtwYWRkaW5nOjhweCAwO2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1pY29uLWJ1dHRvbntwYWRkaW5nOjA7bWluLXdpZHRoOjA7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDtmbGV4LXNocmluazowO2xpbmUtaGVpZ2h0OjQwcHg7Ym9yZGVyLXJhZGl1czo1MCV9Lm1hdC1pY29uLWJ1dHRvbiAubWF0LWljb24sLm1hdC1pY29uLWJ1dHRvbiBpe2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1idXR0b24sLm1hdC1pY29uLWJ1dHRvbiwubWF0LXJhaXNlZC1idXR0b257Y29sb3I6Y3VycmVudENvbG9yfS5tYXQtYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+KiwubWF0LWljb24tYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+KiwubWF0LXJhaXNlZC1idXR0b24gLm1hdC1idXR0b24td3JhcHBlcj4qe3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uLXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MDtwb2ludGVyLWV2ZW50czpub25lfS5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC4xMik7Ym9yZGVyLXJhZGl1czppbmhlcml0O29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjJzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSksYmFja2dyb3VuZC1jb2xvciAuMnMgY3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5e2JhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsMjU1LDI1NSwuNSl9fS5tYXQtYnV0dG9uLXJpcHBsZS1yb3VuZHtib3JkZXItcmFkaXVzOjUwJTt6LWluZGV4OjF9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC1idXR0b24sLm1hdC1mYWIsLm1hdC1pY29uLWJ1dHRvbiwubWF0LW1pbmktZmFiLC5tYXQtcmFpc2VkLWJ1dHRvbntvdXRsaW5lOnNvbGlkIDFweH19XCJdLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRBbmNob3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBQbGF0Zm9ybSwgfSxcbiAgICB7IHR5cGU6IEZvY3VzT3JpZ2luTW9uaXRvciwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG5dOyB9O1xuTWRBbmNob3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3RhYkluZGV4JzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsndGFiSW5kZXgnLF0gfSxdLFxufTtcbnZhciBNZEJ1dHRvbk1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRCdXR0b25Nb2R1bGU7XG59KCkpO1xuTWRCdXR0b25Nb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZFJpcHBsZU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFN0eWxlTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBNZEJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgTWRBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgIE1kTWluaUZhYixcbiAgICAgICAgICAgICAgICAgICAgTWRGYWIsXG4gICAgICAgICAgICAgICAgICAgIE1kQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZEJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBNZEJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgTWRBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgIE1kTWluaUZhYixcbiAgICAgICAgICAgICAgICAgICAgTWRGYWIsXG4gICAgICAgICAgICAgICAgICAgIE1kQnV0dG9uQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZFJhaXNlZEJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQnV0dG9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIE1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBpbnRlZ2VyIHVzZWQgdG8gYXV0by1nZW5lcmF0ZSB1bmlxdWUgaWRzIGZvciBjaGVja2JveCBjb21wb25lbnRzLlxuICovXG52YXIgbmV4dElkID0gMDtcbi8qKlxuICogUHJvdmlkZXIgRXhwcmVzc2lvbiB0aGF0IGFsbG93cyBtZC1jaGVja2JveCB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICogVGhpcyBhbGxvd3MgaXQgdG8gc3VwcG9ydCBbKG5nTW9kZWwpXS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTURfQ0hFQ0tCT1hfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZENoZWNrYm94OyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBUcmFuc2l0aW9uQ2hlY2tTdGF0ZSA9IHt9O1xuVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5pdCA9IDA7XG5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkID0gMTtcblRyYW5zaXRpb25DaGVja1N0YXRlLlVuY2hlY2tlZCA9IDI7XG5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5JbmRldGVybWluYXRlID0gMztcblRyYW5zaXRpb25DaGVja1N0YXRlW1RyYW5zaXRpb25DaGVja1N0YXRlLkluaXRdID0gXCJJbml0XCI7XG5UcmFuc2l0aW9uQ2hlY2tTdGF0ZVtUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkXSA9IFwiQ2hlY2tlZFwiO1xuVHJhbnNpdGlvbkNoZWNrU3RhdGVbVHJhbnNpdGlvbkNoZWNrU3RhdGUuVW5jaGVja2VkXSA9IFwiVW5jaGVja2VkXCI7XG5UcmFuc2l0aW9uQ2hlY2tTdGF0ZVtUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5JbmRldGVybWluYXRlXSA9IFwiSW5kZXRlcm1pbmF0ZVwiO1xuLyoqXG4gKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWRDaGVja2JveC5cbiAqL1xudmFyIE1kQ2hlY2tib3hDaGFuZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENoZWNrYm94Q2hhbmdlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDaGVja2JveENoYW5nZTtcbn0oKSk7XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDaGVja2JveEJhc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZENoZWNrYm94QmFzZShfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgfVxuICAgIHJldHVybiBNZENoZWNrYm94QmFzZTtcbn0oKSk7XG52YXIgX01kQ2hlY2tib3hNaXhpbkJhc2UgPSBtaXhpbkNvbG9yKG1peGluRGlzYWJsZWQoTWRDaGVja2JveEJhc2UpLCAnYWNjZW50Jyk7XG4vKipcbiAqIEEgbWF0ZXJpYWwgZGVzaWduIGNoZWNrYm94IGNvbXBvbmVudC4gU3VwcG9ydHMgYWxsIG9mIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIEhUTUw1IGNoZWNrYm94LFxuICogYW5kIGV4cG9zZXMgYSBzaW1pbGFyIEFQSS4gQSBNZENoZWNrYm94IGNhbiBiZSBlaXRoZXIgY2hlY2tlZCwgdW5jaGVja2VkLCBpbmRldGVybWluYXRlLCBvclxuICogZGlzYWJsZWQuIE5vdGUgdGhhdCBhbGwgYWRkaXRpb25hbCBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXMgYXJlIHRha2VuIGNhcmUgb2YgYnkgdGhlIGNvbXBvbmVudCxcbiAqIHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gcHJvdmlkZSB0aGVtIHlvdXJzZWxmLiBIb3dldmVyLCBpZiB5b3Ugd2FudCB0byBvbWl0IGEgbGFiZWwgYW5kIHN0aWxsXG4gKiBoYXZlIHRoZSBjaGVja2JveCBiZSBhY2Nlc3NpYmxlLCB5b3UgbWF5IHN1cHBseSBhbiBbYXJpYS1sYWJlbF0gaW5wdXQuXG4gKiBTZWU6IGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvY29tcG9uZW50cy9zZWxlY3Rpb24tY29udHJvbHMuaHRtbFxuICovXG52YXIgTWRDaGVja2JveCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kQ2hlY2tib3gsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX2NoYW5nZURldGVjdG9yUmVmXG4gICAgICogQHBhcmFtIHs/fSBfZm9jdXNPcmlnaW5Nb25pdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRDaGVja2JveChyZW5kZXJlciwgZWxlbWVudFJlZiwgX2NoYW5nZURldGVjdG9yUmVmLCBfZm9jdXNPcmlnaW5Nb25pdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlbmRlcmVyLCBlbGVtZW50UmVmKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYgPSBfY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIF90aGlzLl9mb2N1c09yaWdpbk1vbml0b3IgPSBfZm9jdXNPcmlnaW5Nb25pdG9yO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNoZWQgdG8gdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIG9mIHRoZSBob3N0IGVsZW1lbnQuIEluIG1vc3QgY2FzZXMsIGFyaWFsLWxhYmVsbGVkYnkgd2lsbFxuICAgICAgICAgKiB0YWtlIHByZWNlZGVuY2Ugc28gdGhpcyBtYXkgYmUgb21pdHRlZC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmFyaWFMYWJlbCA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlcnMgY2FuIHNwZWNpZnkgdGhlIGBhcmlhLWxhYmVsbGVkYnlgIGF0dHJpYnV0ZSB3aGljaCB3aWxsIGJlIGZvcndhcmRlZCB0byB0aGUgaW5wdXQgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYXJpYUxhYmVsbGVkYnkgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB1bmlxdWUgaWQgZm9yIHRoZSBjaGVja2JveC4gSWYgb25lIGlzIG5vdCBzdXBwbGllZCwgaXQgaXMgYXV0by1nZW5lcmF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pZCA9IFwibWQtY2hlY2tib3gtXCIgKyArK25leHRJZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBhcHBlYXIgYWZ0ZXIgb3IgYmVmb3JlIHRoZSBjaGVja2JveC4gRGVmYXVsdHMgdG8gJ2FmdGVyJ1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubGFiZWxQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWJpbmRleCB2YWx1ZSB0aGF0IGlzIHBhc3NlZCB0byB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudGFiSW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSB2YWx1ZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGlucHV0IGVsZW1lbnQgaWYgcHJlc2VudFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubmFtZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNoZWNrYm94J3MgYGNoZWNrZWRgIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNoZWNrYm94J3MgYGluZGV0ZXJtaW5hdGVgIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pbmRldGVybWluYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gdGhlIGNoZWNrYm94IGlzIGJsdXJyZWQuIE5lZWRlZCB0byBwcm9wZXJseSBpbXBsZW1lbnQgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICAgICAqIFxcQGRvY3MtcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBfdGhpcy5fY3VycmVudEFuaW1hdGlvbkNsYXNzID0gJyc7XG4gICAgICAgIF90aGlzLl9jdXJyZW50Q2hlY2tTdGF0ZSA9IFRyYW5zaXRpb25DaGVja1N0YXRlLkluaXQ7XG4gICAgICAgIF90aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoZWNrYm94LnByb3RvdHlwZSwgXCJkaXNhYmxlUmlwcGxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHJpcHBsZSBlZmZlY3QgZm9yIHRoaXMgY2hlY2tib3ggaXMgZGlzYWJsZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVSaXBwbGU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlUmlwcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImlucHV0SWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogSUQgb2YgdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IGluc2lkZSBgPG1kLWNoZWNrYm94PmBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXQtXCIgKyB0aGlzLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2hlY2tib3ggaXMgcmVxdWlyZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlcXVpcmVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fcmVxdWlyZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwiYWxpZ25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGNoZWNrYm94IHNob3VsZCBhcHBlYXIgYmVmb3JlIG9yIGFmdGVyIHRoZSBsYWJlbC5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gYWxpZ24gcmVmZXJzIHRvIHRoZSBjaGVja2JveCByZWxhdGl2ZSB0byB0aGUgbGFiZWwsIHdoaWxlIGxhYmVsUG9zaXRpb24gcmVmZXJzIHRvIHRoZVxuICAgICAgICAgICAgLy8gbGFiZWwgcmVsYXRpdmUgdG8gdGhlIGNoZWNrYm94LiBBcyBzdWNoLCB0aGV5IGFyZSBpbnZlcnRlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsUG9zaXRpb24gPT0gJ2FmdGVyJyA/ICdzdGFydCcgOiAnZW5kJztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5sYWJlbFBvc2l0aW9uID0gKHYgPT0gJ3N0YXJ0JykgPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9mb2N1c09yaWdpbk1vbml0b3JcbiAgICAgICAgICAgIC5tb25pdG9yKHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LCB0aGlzLl9yZW5kZXJlciwgZmFsc2UpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChmb2N1c09yaWdpbikgeyByZXR1cm4gX3RoaXMuX29uSW5wdXRGb2N1c0NoYW5nZShmb2N1c09yaWdpbik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLnN0b3BNb25pdG9yaW5nKHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoZWNrYm94LnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGNoZWNrZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGVja2VkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjaGVja2VkKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlZCAhPSB0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImluZGV0ZXJtaW5hdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2hlY2tib3ggaXMgaW5kZXRlcm1pbmF0ZS4gVGhpcyBpcyBhbHNvIGtub3duIGFzIFwibWl4ZWRcIiBtb2RlIGFuZCBjYW4gYmUgdXNlZCB0b1xuICAgICAgICAgKiByZXByZXNlbnQgYSBjaGVja2JveCB3aXRoIHRocmVlIHN0YXRlcywgZS5nLiBhIGNoZWNrYm94IHRoYXQgcmVwcmVzZW50cyBhIG5lc3RlZCBsaXN0IG9mXG4gICAgICAgICAqIGNoZWNrYWJsZSBpdGVtcy4gTm90ZSB0aGF0IHdoZW5ldmVyIGNoZWNrYm94IGlzIG1hbnVhbGx5IGNsaWNrZWQsIGluZGV0ZXJtaW5hdGUgaXMgaW1tZWRpYXRlbHlcbiAgICAgICAgICogc2V0IHRvIGZhbHNlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXRlcm1pbmF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhbmdlZCA9IGluZGV0ZXJtaW5hdGUgIT0gdGhpcy5faW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uQ2hlY2tTdGF0ZShUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5JbmRldGVybWluYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25DaGVja1N0YXRlKHRoaXMuY2hlY2tlZCA/IFRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQgOiBUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5VbmNoZWNrZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2UuZW1pdCh0aGlzLl9pbmRldGVybWluYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5faXNSaXBwbGVEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZVJpcHBsZSB8fCB0aGlzLmRpc2FibGVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIGJlaW5nIGNhbGxlZCB3aGVuZXZlciB0aGUgbGFiZWwgdGV4dCBjaGFuZ2VzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX29uTGFiZWxUZXh0Q2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBnZXR0aW5nIGNhbGxlZCB3aGVuZXZlciB0aGUgbGFiZWwgb2YgdGhlIGNoZWNrYm94IGNoYW5nZXMuXG4gICAgICAgIC8vIFNpbmNlIHRoZSBjaGVja2JveCB1c2VzIHRoZSBPblB1c2ggc3RyYXRlZ3kgd2UgbmVlZCB0byBub3RpZnkgaXQgYWJvdXQgdGhlIGNoYW5nZVxuICAgICAgICAvLyB0aGF0IGhhcyBiZWVuIHJlY29nbml6ZWQgYnkgdGhlIGNka09ic2VydmVDb250ZW50IGRpcmVjdGl2ZS5cbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtb2RlbCB2YWx1ZS4gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlIFZhbHVlIHRvIGJlIHNldCB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBjaGFuZ2UuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb250cm9sIGhhcyBiZWVuIHRvdWNoZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjaGVja2JveCBpcyB0b3VjaGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNoZWNrYm94J3MgZGlzYWJsZWQgc3RhdGUuIEltcGxlbWVudGVkIGFzIGEgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWQgV2hldGhlciB0aGUgY2hlY2tib3ggc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmV3U3RhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl90cmFuc2l0aW9uQ2hlY2tTdGF0ZSA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRTdGF0ZSA9IHRoaXMuX2N1cnJlbnRDaGVja1N0YXRlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50UmVmID0gdGhpcy5fZWxlbWVudFJlZjtcbiAgICAgICAgaWYgKG9sZFN0YXRlID09PSBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50QW5pbWF0aW9uQ2xhc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLl9jdXJyZW50QW5pbWF0aW9uQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcyA9IHRoaXMuX2dldEFuaW1hdGlvbkNsYXNzRm9yQ2hlY2tTdGF0ZVRyYW5zaXRpb24ob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5fY3VycmVudENoZWNrU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSBuZXcgTWRDaGVja2JveENoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC5jaGVja2VkID0gdGhpcy5jaGVja2VkO1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuKHRoaXMuY2hlY2tlZCk7XG4gICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBmb2N1cyBjaGFuZ2VzIGZvciB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IGZvY3VzT3JpZ2luXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fb25JbnB1dEZvY3VzQ2hhbmdlID0gZnVuY3Rpb24gKGZvY3VzT3JpZ2luKSB7XG4gICAgICAgIGlmICghdGhpcy5fZm9jdXNSaXBwbGUgJiYgZm9jdXNPcmlnaW4gPT09ICdrZXlib2FyZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzUmlwcGxlID0gdGhpcy5fcmlwcGxlLmxhdW5jaCgwLCAwLCB7IHBlcnNpc3RlbnQ6IHRydWUsIGNlbnRlcmVkOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFmb2N1c09yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRm9jdXNSaXBwbGUoKTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGBjaGVja2VkYCBzdGF0ZSBvZiB0aGUgY2hlY2tib3guXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIGZvciBjaGVja2JveCBpbnB1dCBlbGVtZW50LlxuICAgICAqIFRvZ2dsZXMgY2hlY2tlZCBzdGF0ZSBpZiBlbGVtZW50IGlzIG5vdCBkaXNhYmxlZC5cbiAgICAgKiBEbyBub3QgdG9nZ2xlIG9uIChjaGFuZ2UpIGV2ZW50IHNpbmNlIElFIGRvZXNuJ3QgZmlyZSBjaGFuZ2UgZXZlbnQgd2hlblxuICAgICAqICAgaW5kZXRlcm1pbmF0ZSBjaGVja2JveCBpcyBjbGlja2VkLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9vbklucHV0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gV2UgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIGZvciBjbGljayBldmVudHMgb24gdGhlIHZpc3VhbCBoaWRkZW4gaW5wdXQgZWxlbWVudC5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgbGFiZWwgZWxlbWVudCwgYSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBkaXNwYXRjaGVkIG9uIHRoZSBhc3NvY2lhdGVkIGlucHV0IGVsZW1lbnQuIFNpbmNlIHdlIGFyZSB1c2luZyBhIGxhYmVsIGVsZW1lbnQgYXMgb3VyXG4gICAgICAgIC8vIHJvb3QgY29udGFpbmVyLCB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIGBjaGVja2JveGAgd2lsbCBiZSBleGVjdXRlZCB0d2ljZS5cbiAgICAgICAgLy8gVGhlIHJlYWwgY2xpY2sgZXZlbnQgd2lsbCBidWJibGUgdXAsIGFuZCB0aGUgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IGFsc28gdHJpZXMgdG8gYnViYmxlIHVwLlxuICAgICAgICAvLyBUaGlzIHdpbGwgbGVhZCB0byBtdWx0aXBsZSBjbGljayBldmVudHMuXG4gICAgICAgIC8vIFByZXZlbnRpbmcgYnViYmxpbmcgZm9yIHRoZSBzZWNvbmQgZXZlbnQgd2lsbCBzb2x2ZSB0aGF0IGlzc3VlLlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRm9jdXNSaXBwbGUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHVzZXIgbWFudWFsbHkgY2xpY2sgb24gdGhlIGNoZWNrYm94LCBgaW5kZXRlcm1pbmF0ZWAgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5kZXRlcm1pbmF0ZUNoYW5nZS5lbWl0KF90aGlzLl9pbmRldGVybWluYXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uQ2hlY2tTdGF0ZSh0aGlzLl9jaGVja2VkID8gVHJhbnNpdGlvbkNoZWNrU3RhdGUuQ2hlY2tlZCA6IFRyYW5zaXRpb25DaGVja1N0YXRlLlVuY2hlY2tlZCk7XG4gICAgICAgICAgICAvLyBFbWl0IG91ciBjdXN0b20gY2hhbmdlIGV2ZW50IGlmIHRoZSBuYXRpdmUgaW5wdXQgZW1pdHRlZCBvbmUuXG4gICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gb25seSBlbWl0IGl0LCBpZiB0aGUgbmF0aXZlIGlucHV0IHRyaWdnZXJlZCBvbmUsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCwgd2hlbiB0aGUgYGNoZWNrZWRgIHZhcmlhYmxlIGNoYW5nZXMgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgY2hlY2tib3guXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLmZvY3VzVmlhKHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LCAna2V5Ym9hcmQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9vbkludGVyYWN0aW9uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBvbiB0aGUgY2hhbmdlIGV2ZW50LlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGNoYW5nZSBldmVudCwgZnJvbSB0aGUgaW5wdXQgZWxlbWVudCwgd2lsbCBidWJibGUgdXAgYW5kXG4gICAgICAgIC8vIGVtaXQgaXRzIGV2ZW50IG9iamVjdCB0byB0aGUgYGNoYW5nZWAgb3V0cHV0LlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2xkU3RhdGVcbiAgICAgKiBAcGFyYW0gez99IG5ld1N0YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fZ2V0QW5pbWF0aW9uQ2xhc3NGb3JDaGVja1N0YXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbVN1ZmZpeCA9ICcnO1xuICAgICAgICBzd2l0Y2ggKG9sZFN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFRyYW5zaXRpb25DaGVja1N0YXRlLkluaXQ6XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGVkZ2UgY2FzZSB3aGVyZSB1c2VyIGludGVyYWN0cyB3aXRoIGNoZWNrYm94IHRoYXQgZG9lcyBub3QgaGF2ZSBbKG5nTW9kZWwpXSBvclxuICAgICAgICAgICAgICAgIC8vIFtjaGVja2VkXSBib3VuZCB0byBpdC5cbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IFRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbVN1ZmZpeCA9ICd1bmNoZWNrZWQtY2hlY2tlZCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1N0YXRlID09IFRyYW5zaXRpb25DaGVja1N0YXRlLkluZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbVN1ZmZpeCA9ICd1bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5VbmNoZWNrZWQ6XG4gICAgICAgICAgICAgICAgYW5pbVN1ZmZpeCA9IG5ld1N0YXRlID09PSBUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkID9cbiAgICAgICAgICAgICAgICAgICAgJ3VuY2hlY2tlZC1jaGVja2VkJyA6ICd1bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQ6XG4gICAgICAgICAgICAgICAgYW5pbVN1ZmZpeCA9IG5ld1N0YXRlID09PSBUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5VbmNoZWNrZWQgP1xuICAgICAgICAgICAgICAgICAgICAnY2hlY2tlZC11bmNoZWNrZWQnIDogJ2NoZWNrZWQtaW5kZXRlcm1pbmF0ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRyYW5zaXRpb25DaGVja1N0YXRlLkluZGV0ZXJtaW5hdGU6XG4gICAgICAgICAgICAgICAgYW5pbVN1ZmZpeCA9IG5ld1N0YXRlID09PSBUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkID9cbiAgICAgICAgICAgICAgICAgICAgJ2luZGV0ZXJtaW5hdGUtY2hlY2tlZCcgOiAnaW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm1hdC1jaGVja2JveC1hbmltLVwiICsgYW5pbVN1ZmZpeDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZhZGVzIG91dCB0aGUgZm9jdXMgc3RhdGUgcmlwcGxlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX3JlbW92ZUZvY3VzUmlwcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZm9jdXNSaXBwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzUmlwcGxlLmZhZGVPdXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzUmlwcGxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kQ2hlY2tib3g7XG59KF9NZENoZWNrYm94TWl4aW5CYXNlKSk7XG5NZENoZWNrYm94LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtY2hlY2tib3gsIG1hdC1jaGVja2JveCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGxhYmVsIFthdHRyLmZvcl09XFxcImlucHV0SWRcXFwiIGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtbGF5b3V0XFxcIiAjbGFiZWw+PGRpdiBjbGFzcz1cXFwibWF0LWNoZWNrYm94LWlubmVyLWNvbnRhaW5lclxcXCIgW2NsYXNzLm1hdC1jaGVja2JveC1pbm5lci1jb250YWluZXItbm8tc2lkZS1tYXJnaW5dPVxcXCIhY2hlY2tib3hMYWJlbC50ZXh0Q29udGVudC50cmltKClcXFwiPjxpbnB1dCAjaW5wdXQgY2xhc3M9XFxcIm1hdC1jaGVja2JveC1pbnB1dCBjZGstdmlzdWFsbHktaGlkZGVuXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgW2lkXT1cXFwiaW5wdXRJZFxcXCIgW3JlcXVpcmVkXT1cXFwicmVxdWlyZWRcXFwiIFtjaGVja2VkXT1cXFwiY2hlY2tlZFxcXCIgW3ZhbHVlXT1cXFwidmFsdWVcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbbmFtZV09XFxcIm5hbWVcXFwiIFt0YWJJbmRleF09XFxcInRhYkluZGV4XFxcIiBbaW5kZXRlcm1pbmF0ZV09XFxcImluZGV0ZXJtaW5hdGVcXFwiIFthdHRyLmFyaWEtbGFiZWxdPVxcXCJhcmlhTGFiZWxcXFwiIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XFxcImFyaWFMYWJlbGxlZGJ5XFxcIiAoY2hhbmdlKT1cXFwiX29uSW50ZXJhY3Rpb25FdmVudCgkZXZlbnQpXFxcIiAoY2xpY2spPVxcXCJfb25JbnB1dENsaWNrKCRldmVudClcXFwiPjxkaXYgbWQtcmlwcGxlIGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtcmlwcGxlXFxcIiBbbWRSaXBwbGVUcmlnZ2VyXT1cXFwibGFiZWxcXFwiIFttZFJpcHBsZURpc2FibGVkXT1cXFwiX2lzUmlwcGxlRGlzYWJsZWQoKVxcXCIgW21kUmlwcGxlQ2VudGVyZWRdPVxcXCJ0cnVlXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtZnJhbWVcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1jaGVja2JveC1iYWNrZ3JvdW5kXFxcIj48c3ZnIHZlcnNpb249XFxcIjEuMVxcXCIgY2xhc3M9XFxcIm1hdC1jaGVja2JveC1jaGVja21hcmtcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIj48cGF0aCBjbGFzcz1cXFwibWF0LWNoZWNrYm94LWNoZWNrbWFyay1wYXRoXFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIndoaXRlXFxcIiBkPVxcXCJNNC4xLDEyLjcgOSwxNy42IDIwLjMsNi4zXFxcIi8+PC9zdmc+PGRpdiBjbGFzcz1cXFwibWF0LWNoZWNrYm94LW1peGVkbWFya1xcXCI+PC9kaXY+PC9kaXY+PC9kaXY+PHNwYW4gY2xhc3M9XFxcIm1hdC1jaGVja2JveC1sYWJlbFxcXCIgI2NoZWNrYm94TGFiZWwgKGNka09ic2VydmVDb250ZW50KT1cXFwiX29uTGFiZWxUZXh0Q2hhbmdlKClcXFwiPjxzcGFuIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmVcXFwiPiZuYnNwOzwvc3Bhbj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPjwvbGFiZWw+XCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCJAa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1mYWRlLWluLWJhY2tncm91bmR7MCV7b3BhY2l0eTowfTUwJXtvcGFjaXR5OjF9fUBrZXlmcmFtZXMgbWF0LWNoZWNrYm94LWZhZGUtb3V0LWJhY2tncm91bmR7MCUsNTAle29wYWNpdHk6MX0xMDAle29wYWNpdHk6MH19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtdW5jaGVja2VkLWNoZWNrZWQtY2hlY2ttYXJrLXBhdGh7MCUsNTAle3N0cm9rZS1kYXNob2Zmc2V0OjIyLjkxMDI2fTUwJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLDAsLjIsLjEpfTEwMCV7c3Ryb2tlLWRhc2hvZmZzZXQ6MH19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUtbWl4ZWRtYXJrezAlLDY4LjIle3RyYW5zZm9ybTpzY2FsZVgoMCl9NjguMiV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMCwwLDAsMSl9MTAwJXt0cmFuc2Zvcm06c2NhbGVYKDEpfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1jaGVja2VkLXVuY2hlY2tlZC1jaGVja21hcmstcGF0aHtmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC40LDAsMSwxKTtzdHJva2UtZGFzaG9mZnNldDowfXRve3N0cm9rZS1kYXNob2Zmc2V0Oi0yMi45MTAyNn19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtY2hlY2tlZC1pbmRldGVybWluYXRlLWNoZWNrbWFya3tmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAsMCwuMiwuMSk7b3BhY2l0eToxO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97b3BhY2l0eTowO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1pbmRldGVybWluYXRlLWNoZWNrZWQtY2hlY2ttYXJre2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjE0LDAsMCwxKTtvcGFjaXR5OjA7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9dG97b3BhY2l0eToxO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtY2hlY2tlZC1pbmRldGVybWluYXRlLW1peGVkbWFya3tmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAsMCwuMiwuMSk7b3BhY2l0eTowO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX10b3tvcGFjaXR5OjE7dHJhbnNmb3JtOnJvdGF0ZSgwKX19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZS1jaGVja2VkLW1peGVkbWFya3tmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4xNCwwLDAsMSk7b3BhY2l0eToxO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97b3BhY2l0eTowO3RyYW5zZm9ybTpyb3RhdGUoMzE1ZGVnKX19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQtbWl4ZWRtYXJrezAle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO29wYWNpdHk6MTt0cmFuc2Zvcm06c2NhbGVYKDEpfTEwMCUsMzIuOCV7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZVgoMCl9fS5tYXQtY2hlY2tib3gtYmFja2dyb3VuZCwubWF0LWNoZWNrYm94LWNoZWNrbWFyaywubWF0LWNoZWNrYm94LWZyYW1le2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5tYXQtY2hlY2tib3gtY2hlY2ttYXJrLC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre3dpZHRoOmNhbGMoMTAwJSAtIDRweCl9Lm1hdC1jaGVja2JveC1iYWNrZ3JvdW5kLC5tYXQtY2hlY2tib3gtZnJhbWV7Ym9yZGVyLXJhZGl1czoycHg7Ym94LXNpemluZzpib3JkZXItYm94O3BvaW50ZXItZXZlbnRzOm5vbmV9Lm1hdC1jaGVja2JveHt0cmFuc2l0aW9uOmJhY2tncm91bmQgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJveC1zaGFkb3cgMjgwbXMgY3ViaWMtYmV6aWVyKC40LDAsLjIsMSk7Y3Vyc29yOnBvaW50ZXJ9Lm1hdC1jaGVja2JveC1sYXlvdXR7Y3Vyc29yOmluaGVyaXQ7YWxpZ24taXRlbXM6YmFzZWxpbmU7dmVydGljYWwtYWxpZ246bWlkZGxlO2Rpc3BsYXk6aW5saW5lLWZsZXh9Lm1hdC1jaGVja2JveC1pbm5lci1jb250YWluZXJ7ZGlzcGxheTppbmxpbmUtYmxvY2s7aGVpZ2h0OjIwcHg7bGluZS1oZWlnaHQ6MDttYXJnaW46YXV0bzttYXJnaW4tcmlnaHQ6OHB4O29yZGVyOjA7cG9zaXRpb246cmVsYXRpdmU7dmVydGljYWwtYWxpZ246bWlkZGxlO3doaXRlLXNwYWNlOm5vd3JhcDt3aWR0aDoyMHB4O2ZsZXgtc2hyaW5rOjB9W2Rpcj1ydGxdIC5tYXQtY2hlY2tib3gtaW5uZXItY29udGFpbmVye21hcmdpbi1sZWZ0OjhweDttYXJnaW4tcmlnaHQ6YXV0b30ubWF0LWNoZWNrYm94LWlubmVyLWNvbnRhaW5lci1uby1zaWRlLW1hcmdpbnttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5tYXQtY2hlY2tib3gtZnJhbWV7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDt0cmFuc2l0aW9uOmJvcmRlci1jb2xvciA5MG1zIGN1YmljLWJlemllcigwLDAsLjIsLjEpO2JvcmRlci13aWR0aDoycHg7Ym9yZGVyLXN0eWxlOnNvbGlkfS5tYXQtY2hlY2tib3gtYmFja2dyb3VuZHthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTppbmxpbmUtZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciA5MG1zIGN1YmljLWJlemllcigwLDAsLjIsLjEpLG9wYWNpdHkgOTBtcyBjdWJpYy1iZXppZXIoMCwwLC4yLC4xKX0ubWF0LWNoZWNrYm94LWNoZWNrbWFya3t3aWR0aDoxMDAlfS5tYXQtY2hlY2tib3gtY2hlY2ttYXJrLXBhdGh7c3Ryb2tlLWRhc2hvZmZzZXQ6MjIuOTEwMjY7c3Ryb2tlLWRhc2hhcnJheToyMi45MTAyNjtzdHJva2Utd2lkdGg6Mi42NjY2N3B4fS5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre2hlaWdodDoycHg7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZVgoMCkgcm90YXRlKDApfS5tYXQtY2hlY2tib3gtbGFiZWwtYmVmb3JlIC5tYXQtY2hlY2tib3gtaW5uZXItY29udGFpbmVye29yZGVyOjE7bWFyZ2luLWxlZnQ6OHB4O21hcmdpbi1yaWdodDphdXRvfVtkaXI9cnRsXSAubWF0LWNoZWNrYm94LWxhYmVsLWJlZm9yZSAubWF0LWNoZWNrYm94LWlubmVyLWNvbnRhaW5lcnttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDo4cHh9Lm1hdC1jaGVja2JveC1jaGVja2VkIC5tYXQtY2hlY2tib3gtY2hlY2ttYXJre29wYWNpdHk6MX0ubWF0LWNoZWNrYm94LWNoZWNrZWQgLm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aHtzdHJva2UtZGFzaG9mZnNldDowfS5tYXQtY2hlY2tib3gtY2hlY2tlZCAubWF0LWNoZWNrYm94LW1peGVkbWFya3t0cmFuc2Zvcm06c2NhbGVYKDEpIHJvdGF0ZSgtNDVkZWcpfS5tYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZSAubWF0LWNoZWNrYm94LWNoZWNrbWFya3tvcGFjaXR5OjA7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9Lm1hdC1jaGVja2JveC1pbmRldGVybWluYXRlIC5tYXQtY2hlY2tib3gtY2hlY2ttYXJrLXBhdGh7c3Ryb2tlLWRhc2hvZmZzZXQ6MH0ubWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1taXhlZG1hcmt7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZVgoMSkgcm90YXRlKDApfS5tYXQtY2hlY2tib3gtdW5jaGVja2VkIC5tYXQtY2hlY2tib3gtYmFja2dyb3VuZHtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS5tYXQtY2hlY2tib3gtZGlzYWJsZWR7Y3Vyc29yOmRlZmF1bHR9Lm1hdC1jaGVja2JveC1hbmltLXVuY2hlY2tlZC1jaGVja2VkIC5tYXQtY2hlY2tib3gtYmFja2dyb3VuZHthbmltYXRpb246MTgwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1mYWRlLWluLWJhY2tncm91bmR9Lm1hdC1jaGVja2JveC1hbmltLXVuY2hlY2tlZC1jaGVja2VkIC5tYXQtY2hlY2tib3gtY2hlY2ttYXJrLXBhdGh7YW5pbWF0aW9uOjE4MG1zIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtdW5jaGVja2VkLWNoZWNrZWQtY2hlY2ttYXJrLXBhdGh9Lm1hdC1jaGVja2JveC1hbmltLXVuY2hlY2tlZC1pbmRldGVybWluYXRlIC5tYXQtY2hlY2tib3gtYmFja2dyb3VuZHthbmltYXRpb246MTgwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1mYWRlLWluLWJhY2tncm91bmR9Lm1hdC1jaGVja2JveC1hbmltLXVuY2hlY2tlZC1pbmRldGVybWluYXRlIC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre2FuaW1hdGlvbjo5MG1zIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUtbWl4ZWRtYXJrfS5tYXQtY2hlY2tib3gtYW5pbS1jaGVja2VkLXVuY2hlY2tlZCAubWF0LWNoZWNrYm94LWJhY2tncm91bmR7YW5pbWF0aW9uOjE4MG1zIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtZmFkZS1vdXQtYmFja2dyb3VuZH0ubWF0LWNoZWNrYm94LWFuaW0tY2hlY2tlZC11bmNoZWNrZWQgLm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aHthbmltYXRpb246OTBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWNoZWNrZWQtdW5jaGVja2VkLWNoZWNrbWFyay1wYXRofS5tYXQtY2hlY2tib3gtYW5pbS1jaGVja2VkLWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1jaGVja21hcmt7YW5pbWF0aW9uOjkwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1jaGVja2VkLWluZGV0ZXJtaW5hdGUtY2hlY2ttYXJrfS5tYXQtY2hlY2tib3gtYW5pbS1jaGVja2VkLWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1taXhlZG1hcmt7YW5pbWF0aW9uOjkwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1jaGVja2VkLWluZGV0ZXJtaW5hdGUtbWl4ZWRtYXJrfS5tYXQtY2hlY2tib3gtYW5pbS1pbmRldGVybWluYXRlLWNoZWNrZWQgLm1hdC1jaGVja2JveC1jaGVja21hcmt7YW5pbWF0aW9uOi41cyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUtY2hlY2tlZC1jaGVja21hcmt9Lm1hdC1jaGVja2JveC1hbmltLWluZGV0ZXJtaW5hdGUtY2hlY2tlZCAubWF0LWNoZWNrYm94LW1peGVkbWFya3thbmltYXRpb246LjVzIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZS1jaGVja2VkLW1peGVkbWFya30ubWF0LWNoZWNrYm94LWFuaW0taW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQgLm1hdC1jaGVja2JveC1iYWNrZ3JvdW5ke2FuaW1hdGlvbjoxODBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWZhZGUtb3V0LWJhY2tncm91bmR9Lm1hdC1jaGVja2JveC1hbmltLWluZGV0ZXJtaW5hdGUtdW5jaGVja2VkIC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre2FuaW1hdGlvbjouM3MgbGluZWFyIDBzIG1hdC1jaGVja2JveC1pbmRldGVybWluYXRlLXVuY2hlY2tlZC1taXhlZG1hcmt9Lm1hdC1jaGVja2JveC1pbnB1dHtib3R0b206MDtsZWZ0OjUwJX0ubWF0LWNoZWNrYm94LXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xNXB4O3RvcDotMTVweDtyaWdodDotMTVweDtib3R0b206LTE1cHg7Ym9yZGVyLXJhZGl1czo1MCU7ei1pbmRleDoxO3BvaW50ZXItZXZlbnRzOm5vbmV9XCJdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1jaGVja2JveCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGVdJzogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGVja2JveC1jaGVja2VkXSc6ICdjaGVja2VkJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2hlY2tib3gtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2hlY2tib3gtbGFiZWwtYmVmb3JlXSc6ICdsYWJlbFBvc2l0aW9uID09IFwiYmVmb3JlXCInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfQ0hFQ0tCT1hfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2Rpc2FibGVkJywgJ2NvbG9yJ10sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENoZWNrYm94LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmLCB9LFxuICAgIHsgdHlwZTogRm9jdXNPcmlnaW5Nb25pdG9yLCB9LFxuXTsgfTtcbk1kQ2hlY2tib3gucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2FyaWFMYWJlbCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2FyaWEtbGFiZWwnLF0gfSxdLFxuICAgICdhcmlhTGFiZWxsZWRieSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2FyaWEtbGFiZWxsZWRieScsXSB9LF0sXG4gICAgJ2lkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdkaXNhYmxlUmlwcGxlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdyZXF1aXJlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnYWxpZ24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2xhYmVsUG9zaXRpb24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3RhYkluZGV4JzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdjaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdpbmRldGVybWluYXRlQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ19pbnB1dEVsZW1lbnQnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnaW5wdXQnLF0gfSxdLFxuICAgICdfcmlwcGxlJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbTWRSaXBwbGUsXSB9LF0sXG4gICAgJ2NoZWNrZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2luZGV0ZXJtaW5hdGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xudmFyIE1kQ2hlY2tib3hNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENoZWNrYm94TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDaGVja2JveE1vZHVsZTtcbn0oKSk7XG5NZENoZWNrYm94TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNZFJpcHBsZU1vZHVsZSwgTWRDb21tb25Nb2R1bGUsIE9ic2VydmVDb250ZW50TW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRDaGVja2JveCwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kQ2hlY2tib3hdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0ZvY3VzT3JpZ2luTW9uaXRvcl1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDaGVja2JveE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBQcm92aWRlciBFeHByZXNzaW9uIHRoYXQgYWxsb3dzIG1kLXJhZGlvLWdyb3VwIHRvIHJlZ2lzdGVyIGFzIGEgQ29udHJvbFZhbHVlQWNjZXNzb3IuIFRoaXNcbiAqIGFsbG93cyBpdCB0byBzdXBwb3J0IFsobmdNb2RlbCldIGFuZCBuZ0NvbnRyb2wuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1EX1JBRElPX0dST1VQX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRSYWRpb0dyb3VwOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBfdW5pcXVlSWRDb3VudGVyJDIgPSAwO1xuLyoqXG4gKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWRSYWRpbyBhbmQgTWRSYWRpb0dyb3VwLlxuICovXG52YXIgTWRSYWRpb0NoYW5nZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmFkaW9DaGFuZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFJhZGlvQ2hhbmdlO1xufSgpKTtcbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFJhZGlvR3JvdXBCYXNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRSYWRpb0dyb3VwQmFzZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kUmFkaW9Hcm91cEJhc2U7XG59KCkpO1xudmFyIF9NZFJhZGlvR3JvdXBNaXhpbkJhc2UgPSBtaXhpbkRpc2FibGVkKE1kUmFkaW9Hcm91cEJhc2UpO1xuLyoqXG4gKiBBIGdyb3VwIG9mIHJhZGlvIGJ1dHRvbnMuIE1heSBjb250YWluIG9uZSBvciBtb3JlIGA8bWQtcmFkaW8tYnV0dG9uPmAgZWxlbWVudHMuXG4gKi9cbnZhciBNZFJhZGlvR3JvdXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFJhZGlvR3JvdXAsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfY2hhbmdlRGV0ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFJhZGlvR3JvdXAoX2NoYW5nZURldGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jaGFuZ2VEZXRlY3RvciA9IF9jaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdGVkIHZhbHVlIGZvciBncm91cC4gU2hvdWxkIGVxdWFsIHRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0ZWQgcmFkaW8gYnV0dG9uIGlmIHRoZXJlICppcypcbiAgICAgICAgICogYSBjb3JyZXNwb25kaW5nIHJhZGlvIGJ1dHRvbiB3aXRoIGEgbWF0Y2hpbmcgdmFsdWUuIElmIHRoZXJlIGlzICpub3QqIHN1Y2ggYSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAqIHJhZGlvIGJ1dHRvbiwgdGhpcyB2YWx1ZSBwZXJzaXN0cyB0byBiZSBhcHBsaWVkIGluIGNhc2UgYSBuZXcgcmFkaW8gYnV0dG9uIGlzIGFkZGVkIHdpdGggYVxuICAgICAgICAgKiBtYXRjaGluZyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSFRNTCBuYW1lIGF0dHJpYnV0ZSBhcHBsaWVkIHRvIHJhZGlvIGJ1dHRvbnMgaW4gdGhpcyBncm91cC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9uYW1lID0gXCJtZC1yYWRpby1ncm91cC1cIiArIF91bmlxdWVJZENvdW50ZXIkMisrO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCByYWRpbyBidXR0b24uIFNob3VsZCBtYXRjaCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBgdmFsdWVgIGhhcyBiZWVuIHNldCB0byBpdHMgaW5pdGlhbCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBsYWJlbHMgc2hvdWxkIGFwcGVhciBhZnRlciBvciBiZWZvcmUgdGhlIHJhZGlvLWJ1dHRvbnMuIERlZmF1bHRzIHRvICdhZnRlcidcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9sYWJlbFBvc2l0aW9uID0gJ2FmdGVyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHJhZGlvIGdyb3VwIGlzIGRpc2FibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWV0aG9kIHRvIGJlIGNhbGxlZCBpbiBvcmRlciB0byB1cGRhdGUgbmdNb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvblRvdWNoIGZ1bmN0aW9uIHJlZ2lzdGVyZWQgdmlhIHJlZ2lzdGVyT25Ub3VjaCAoQ29udHJvbFZhbHVlQWNjZXNzb3IpLlxuICAgICAgICAgKiBcXEBkb2NzLXByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgZ3JvdXAgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgICogQ2hhbmdlIGV2ZW50cyBhcmUgb25seSBlbWl0dGVkIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgZHVlIHRvIHVzZXIgaW50ZXJhY3Rpb24gd2l0aFxuICAgICAgICAgKiBhIHJhZGlvIGJ1dHRvbiAodGhlIHNhbWUgYmVoYXZpb3IgYXMgYDxpbnB1dCB0eXBlLVwicmFkaW9cIj5gKS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhlIHJhZGlvIGJ1dHRvbiBncm91cC4gQWxsIHJhZGlvIGJ1dHRvbnMgaW5zaWRlIHRoaXMgZ3JvdXAgd2lsbCB1c2UgdGhpcyBuYW1lLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uYW1lOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJhZGlvQnV0dG9uTmFtZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwiYWxpZ25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxpZ25tZW50IG9mIHRoZSByYWRpby1idXR0b25zIHJlbGF0aXZlIHRvIHRoZWlyIGxhYmVscy4gQ2FuIGJlICdiZWZvcmUnIG9yICdhZnRlcicuXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGFsaWduIHJlZmVycyB0byB0aGUgY2hlY2tib3ggcmVsYXRpdmUgdG8gdGhlIGxhYmVsLCB3aGlsZSBsYWJlbFBvc2l0aW9uIHJlZmVycyB0byB0aGVcbiAgICAgICAgICAgIC8vIGxhYmVsIHJlbGF0aXZlIHRvIHRoZSBjaGVja2JveC4gQXMgc3VjaCwgdGhleSBhcmUgaW52ZXJ0ZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09ICdhZnRlcicgPyAnc3RhcnQnIDogJ2VuZCc7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxQb3NpdGlvbiA9ICh2ID09ICdzdGFydCcpID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJsYWJlbFBvc2l0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGxhYmVscyBzaG91bGQgYXBwZWFyIGFmdGVyIG9yIGJlZm9yZSB0aGUgcmFkaW8tYnV0dG9ucy4gRGVmYXVsdHMgdG8gJ2FmdGVyJ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWxQb3NpdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxQb3NpdGlvbiA9ICh2ID09ICdiZWZvcmUnKSA/ICdiZWZvcmUnIDogJ2FmdGVyJztcbiAgICAgICAgICAgIHRoaXMuX21hcmtSYWRpb3NGb3JDaGVjaygpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZSBvZiB0aGUgcmFkaW8gYnV0dG9uLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmV3VmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgIT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhpcyBiZWZvcmUgcHJvY2VlZGluZyB0byBlbnN1cmUgbm8gY2lyY3VsYXIgbG9vcCBvY2N1cnMgd2l0aCBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZFJhZGlvRnJvbVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tTZWxlY3RlZFJhZGlvQnV0dG9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5fY2hlY2tTZWxlY3RlZFJhZGlvQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWQgJiYgIXRoaXMuX3NlbGVjdGVkLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByYWRpbyBidXR0b24gaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBzZWxlY3RlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gc2VsZWN0ZWQgPyBzZWxlY3RlZC52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1NlbGVjdGVkUmFkaW9CdXR0b24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgcmFkaW8gZ3JvdXAgaXMgZGlhYmxlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fbWFya1JhZGlvc0ZvckNoZWNrKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgcHJvcGVydGllcyBvbmNlIGNvbnRlbnQgY2hpbGRyZW4gYXJlIGF2YWlsYWJsZS5cbiAgICAgKiBUaGlzIGFsbG93cyB1cyB0byBwcm9wYWdhdGUgcmVsZXZhbnQgYXR0cmlidXRlcyB0byBhc3NvY2lhdGVkIGJ1dHRvbnMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTWFyayB0aGlzIGNvbXBvbmVudCBhcyBpbml0aWFsaXplZCBpbiBBZnRlckNvbnRlbnRJbml0IGJlY2F1c2UgdGhlIGluaXRpYWwgdmFsdWUgY2FuXG4gICAgICAgIC8vIHBvc3NpYmx5IGJlIHNldCBieSBOZ01vZGVsIG9uIE1kUmFkaW9Hcm91cCwgYW5kIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIE9uSW5pdCBvZiB0aGVcbiAgICAgICAgLy8gTmdNb2RlbCBvY2N1cnMgKmFmdGVyKiB0aGUgT25Jbml0IG9mIHRoZSBNZFJhZGlvR3JvdXAuXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFyayB0aGlzIGdyb3VwIGFzIGJlaW5nIFwidG91Y2hlZFwiIChmb3IgbmdNb2RlbCkuIE1lYW50IHRvIGJlIGNhbGxlZCBieSB0aGUgY29udGFpbmVkXG4gICAgICogcmFkaW8gYnV0dG9ucyB1cG9uIHRoZWlyIGJsdXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLl90b3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub25Ub3VjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVJhZGlvQnV0dG9uTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpb3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhZGlvcy5mb3JFYWNoKGZ1bmN0aW9uIChyYWRpbykge1xuICAgICAgICAgICAgICAgIHJhZGlvLm5hbWUgPSBfdGhpcy5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcmFkaW8gYnV0dG9uIGZyb20gdGhlIGludGVybmFsIF92YWx1ZSBzdGF0ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVNlbGVjdGVkUmFkaW9Gcm9tVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBhbHJlYWR5IG1hdGNoZXMgdGhlIHNlbGVjdGVkIHJhZGlvLCBkbyBub3RoaW5nLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0FscmVhZHlTZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGVkICE9IG51bGwgJiYgdGhpcy5fc2VsZWN0ZWQudmFsdWUgPT0gdGhpcy5fdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpb3MgIT0gbnVsbCAmJiAhaXNBbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JhZGlvcy5mb3JFYWNoKGZ1bmN0aW9uIChyYWRpbykge1xuICAgICAgICAgICAgICAgIHJhZGlvLmNoZWNrZWQgPSBfdGhpcy52YWx1ZSA9PSByYWRpby52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmFkaW8uY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VsZWN0ZWQgPSByYWRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggY2hhbmdlIGV2ZW50IHdpdGggY3VycmVudCBzZWxlY3Rpb24gYW5kIGdyb3VwIHZhbHVlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSBuZXcgTWRSYWRpb0NoYW5nZSgpO1xuICAgICAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgICAgICAgICBldmVudC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5fbWFya1JhZGlvc0ZvckNoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmFkaW9zKSB7XG4gICAgICAgICAgICB0aGlzLl9yYWRpb3MuZm9yRWFjaChmdW5jdGlvbiAocmFkaW8pIHsgcmV0dXJuIHJhZGlvLl9tYXJrRm9yQ2hlY2soKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1vZGVsIHZhbHVlLiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIG1vZGVsIHZhbHVlIGNoYW5nZXMuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGZuIENhbGxiYWNrIHRvIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbnRyb2wgaXMgdG91Y2hlZC5cbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7P30gZm4gQ2FsbGJhY2sgdG8gYmUgcmVnaXN0ZXJlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBjb250cm9sLiBJbXBsZW1lbnRlZCBhcyBhIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBpc0Rpc2FibGVkIFdoZXRoZXIgdGhlIGNvbnRyb2wgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kUmFkaW9Hcm91cDtcbn0oX01kUmFkaW9Hcm91cE1peGluQmFzZSkpO1xuTWRSYWRpb0dyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1yYWRpby1ncm91cCwgbWF0LXJhZGlvLWdyb3VwJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9SQURJT19HUk9VUF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3JhZGlvZ3JvdXAnLFxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LXJhZGlvLWdyb3VwJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlucHV0czogWydkaXNhYmxlZCddLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFJhZGlvR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiwgfSxcbl07IH07XG5NZFJhZGlvR3JvdXAucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ19yYWRpb3MnOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtmb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kUmFkaW9CdXR0b247IH0pLF0gfSxdLFxuICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdhbGlnbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbGFiZWxQb3NpdGlvbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRSYWRpb0J1dHRvbkJhc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFJhZGlvQnV0dG9uQmFzZShfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgfVxuICAgIHJldHVybiBNZFJhZGlvQnV0dG9uQmFzZTtcbn0oKSk7XG4vLyBBcyBwZXIgTWF0ZXJpYWwgZGVzaWduIHNwZWNpZmljYXRpb25zIHRoZSBzZWxlY3Rpb24gY29udHJvbCByYWRpbyBzaG91bGQgdXNlIHRoZSBhY2NlbnQgY29sb3Jcbi8vIHBhbGV0dGUgYnkgZGVmYXVsdC4gaHR0cHM6Ly9tYXRlcmlhbC5pby9ndWlkZWxpbmVzL2NvbXBvbmVudHMvc2VsZWN0aW9uLWNvbnRyb2xzLmh0bWxcbnZhciBfTWRSYWRpb0J1dHRvbk1peGluQmFzZSA9IG1peGluQ29sb3IoTWRSYWRpb0J1dHRvbkJhc2UsICdhY2NlbnQnKTtcbi8qKlxuICogQSByYWRpby1idXR0b24uIE1heSBiZSBpbnNpZGUgb2ZcbiAqL1xudmFyIE1kUmFkaW9CdXR0b24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFJhZGlvQnV0dG9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmFkaW9Hcm91cFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9jaGFuZ2VEZXRlY3RvclxuICAgICAqIEBwYXJhbSB7P30gX2ZvY3VzT3JpZ2luTW9uaXRvclxuICAgICAqIEBwYXJhbSB7P30gX3JhZGlvRGlzcGF0Y2hlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kUmFkaW9CdXR0b24ocmFkaW9Hcm91cCwgZWxlbWVudFJlZiwgcmVuZGVyZXIsIF9jaGFuZ2VEZXRlY3RvciwgX2ZvY3VzT3JpZ2luTW9uaXRvciwgX3JhZGlvRGlzcGF0Y2hlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZW5kZXJlciwgZWxlbWVudFJlZikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NoYW5nZURldGVjdG9yID0gX2NoYW5nZURldGVjdG9yO1xuICAgICAgICBfdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yID0gX2ZvY3VzT3JpZ2luTW9uaXRvcjtcbiAgICAgICAgX3RoaXMuX3JhZGlvRGlzcGF0Y2hlciA9IF9yYWRpb0Rpc3BhdGNoZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIElEIGZvciB0aGUgcmFkaW8gYnV0dG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaWQgPSBcIm1kLXJhZGlvLVwiICsgX3VuaXF1ZUlkQ291bnRlciQyKys7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgb2YgdGhpcyByYWRpbyBidXR0b24gY2hhbmdlcy5cbiAgICAgICAgICogQ2hhbmdlIGV2ZW50cyBhcmUgb25seSBlbWl0dGVkIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgZHVlIHRvIHVzZXIgaW50ZXJhY3Rpb24gd2l0aFxuICAgICAgICAgKiB0aGUgcmFkaW8gYnV0dG9uICh0aGUgc2FtZSBiZWhhdmlvciBhcyBgPGlucHV0IHR5cGUtXCJyYWRpb1wiPmApLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHJhZGlvIGlzIGNoZWNrZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgYXNzaWduZWQgdG8gdGhpcyByYWRpby5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIGZ1bmN0aW9uIGZvciBfcmFkaW9EaXNwYXRjaGVyICpcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9yZW1vdmVVbmlxdWVTZWxlY3Rpb25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLy8gQXNzZXJ0aW9ucy4gSWRlYWxseSB0aGVzZSBzaG91bGQgYmUgc3RyaXBwZWQgb3V0IGJ5IHRoZSBjb21waWxlci5cbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IEFzc2VydCB0aGF0IHRoZXJlJ3Mgbm8gbmFtZSBiaW5kaW5nIEFORCBhIHBhcmVudCByYWRpbyBncm91cC5cbiAgICAgICAgX3RoaXMucmFkaW9Hcm91cCA9IHJhZGlvR3JvdXA7XG4gICAgICAgIF90aGlzLl9yZW1vdmVVbmlxdWVTZWxlY3Rpb25MaXN0ZW5lciA9XG4gICAgICAgICAgICBfcmFkaW9EaXNwYXRjaGVyLmxpc3RlbihmdW5jdGlvbiAoaWQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gX3RoaXMuaWQgJiYgbmFtZSA9PSBfdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiZGlzYWJsZVJpcHBsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IGZvciB0aGlzIHJhZGlvIGJ1dHRvbiBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgcmFkaW8gYnV0dG9uIGlzIGNoZWNrZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZXdDaGVja2VkU3RhdGVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0NoZWNrZWRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoZWNrZWQgIT0gbmV3Q2hlY2tlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tlZCA9IG5ld0NoZWNrZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tlZFN0YXRlICYmIHRoaXMucmFkaW9Hcm91cCAmJiB0aGlzLnJhZGlvR3JvdXAudmFsdWUgIT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuc2VsZWN0ZWQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbmV3Q2hlY2tlZFN0YXRlICYmIHRoaXMucmFkaW9Hcm91cCAmJiB0aGlzLnJhZGlvR3JvdXAudmFsdWUgPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVuY2hlY2tpbmcgdGhlIHNlbGVjdGVkIHJhZGlvIGJ1dHRvbiwgdXBkYXRlIHRoZSBzZWxlY3RlZCByYWRpb1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBvbiB0aGUgZ3JvdXAuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cC5zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCByYWRpbyBidXR0b25zIHdpdGggdGhlIHNhbWUgbmFtZSB0byB1bi1jaGVjay5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmFkaW9EaXNwYXRjaGVyLm5vdGlmeSh0aGlzLmlkLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGlzIHJhZGlvIGJ1dHRvbi5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmFkaW9Hcm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY2hlY2tlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VkIHRvIG1hdGNoIHRoZSByYWRpbyBncm91cCdzIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSB0aGlzLnJhZGlvR3JvdXAudmFsdWUgPT0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLnNlbGVjdGVkID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImFsaWduXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSByYWRpby1idXR0b24gc2hvdWxkIGFwcGVhciBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGxhYmVsLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBhbGlnbiByZWZlcnMgdG8gdGhlIGNoZWNrYm94IHJlbGF0aXZlIHRvIHRoZSBsYWJlbCwgd2hpbGUgbGFiZWxQb3NpdGlvbiByZWZlcnMgdG8gdGhlXG4gICAgICAgICAgICAvLyBsYWJlbCByZWxhdGl2ZSB0byB0aGUgY2hlY2tib3guIEFzIHN1Y2gsIHRoZXkgYXJlIGludmVydGVkLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxQb3NpdGlvbiA9PSAnYWZ0ZXInID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsUG9zaXRpb24gPSAodiA9PSAnc3RhcnQnKSA/ICdhZnRlcicgOiAnYmVmb3JlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImxhYmVsUG9zaXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbGFiZWwgc2hvdWxkIGFwcGVhciBhZnRlciBvciBiZWZvcmUgdGhlIHJhZGlvIGJ1dHRvbi4gRGVmYXVsdHMgdG8gJ2FmdGVyJ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWxQb3NpdGlvbiB8fCAodGhpcy5yYWRpb0dyb3VwICYmIHRoaXMucmFkaW9Hcm91cC5sYWJlbFBvc2l0aW9uKSB8fCAnYWZ0ZXInO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsUG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHJhZGlvIGJ1dHRvbiBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkIHx8ICh0aGlzLnJhZGlvR3JvdXAgIT0gbnVsbCAmJiB0aGlzLnJhZGlvR3JvdXAuZGlzYWJsZWQpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImlucHV0SWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogSUQgb2YgdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IGluc2lkZSBgPG1kLXJhZGlvLWJ1dHRvbj5gXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkICsgXCItaW5wdXRcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgcmFkaW8gYnV0dG9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvci5mb2N1c1ZpYSh0aGlzLl9pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2tleWJvYXJkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgcmFkaW8gYnV0dG9uIGFzIG5lZWRpbmcgY2hlY2tpbmcgZm9yIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXhwb3NlZCBiZWNhdXNlIHRoZSBwYXJlbnQgcmFkaW8gZ3JvdXAgd2lsbCBkaXJlY3RseVxuICAgICAqIHVwZGF0ZSBib3VuZCBwcm9wZXJ0aWVzIG9mIHRoZSByYWRpbyBidXR0b24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fbWFya0ZvckNoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXaGVuIGdyb3VwIHZhbHVlIGNoYW5nZXMsIHRoZSBidXR0b24gd2lsbCBub3QgYmUgbm90aWZpZWQuIFVzZSBgbWFya0ZvckNoZWNrYCB0byBleHBsaWNpdFxuICAgICAgICAvLyB1cGRhdGUgcmFkaW8gYnV0dG9uJ3Mgc3RhdHVzXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmFkaW9Hcm91cCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJhZGlvIGlzIGluc2lkZSBhIHJhZGlvIGdyb3VwLCBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkIGJlIGNoZWNrZWRcbiAgICAgICAgICAgIHRoaXMuY2hlY2tlZCA9IHRoaXMucmFkaW9Hcm91cC52YWx1ZSA9PT0gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICAvLyBDb3B5IG5hbWUgZnJvbSBwYXJlbnQgcmFkaW8gZ3JvdXBcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMucmFkaW9Hcm91cC5uYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yXG4gICAgICAgICAgICAubW9uaXRvcih0aGlzLl9pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudCwgdGhpcy5fcmVuZGVyZXIsIGZhbHNlKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoZm9jdXNPcmlnaW4pIHsgcmV0dXJuIF90aGlzLl9vbklucHV0Rm9jdXNDaGFuZ2UoZm9jdXNPcmlnaW4pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvci5zdG9wTW9uaXRvcmluZyh0aGlzLl9pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVVuaXF1ZVNlbGVjdGlvbkxpc3RlbmVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBjaGFuZ2UgZXZlbnQgd2l0aCBjdXJyZW50IHZhbHVlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSBuZXcgTWRSYWRpb0NoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLmNoYW5nZS5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUuX2lzUmlwcGxlRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVSaXBwbGUgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLl9vbklucHV0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIGZvciBjbGljayBldmVudHMgb24gdGhlIHZpc3VhbCBoaWRkZW4gaW5wdXQgZWxlbWVudC5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgbGFiZWwgZWxlbWVudCwgYSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBkaXNwYXRjaGVkIG9uIHRoZSBhc3NvY2lhdGVkIGlucHV0IGVsZW1lbnQuIFNpbmNlIHdlIGFyZSB1c2luZyBhIGxhYmVsIGVsZW1lbnQgYXMgb3VyXG4gICAgICAgIC8vIHJvb3QgY29udGFpbmVyLCB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIGByYWRpby1idXR0b25gIHdpbGwgYmUgZXhlY3V0ZWQgdHdpY2UuXG4gICAgICAgIC8vIFRoZSByZWFsIGNsaWNrIGV2ZW50IHdpbGwgYnViYmxlIHVwLCBhbmQgdGhlIGdlbmVyYXRlZCBjbGljayBldmVudCBhbHNvIHRyaWVzIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGxlYWQgdG8gbXVsdGlwbGUgY2xpY2sgZXZlbnRzLlxuICAgICAgICAvLyBQcmV2ZW50aW5nIGJ1YmJsaW5nIGZvciB0aGUgc2Vjb25kIGV2ZW50IHdpbGwgc29sdmUgdGhhdCBpc3N1ZS5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgcmFkaW8gYnV0dG9uIHJlY2VpdmVkIGEgY2xpY2sgb3IgdGhlIGlucHV0IHJlY29nbml6ZWQgYW55IGNoYW5nZS5cbiAgICAgKiBDbGlja2luZyBvbiBhIGxhYmVsIGVsZW1lbnQsIHdpbGwgdHJpZ2dlciBhIGNoYW5nZSBldmVudCBvbiB0aGUgYXNzb2NpYXRlZCBpbnB1dC5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fb25JbnB1dENoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBXZSBhbHdheXMgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIG9uIHRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgY2hhbmdlIGV2ZW50LCBmcm9tIHRoZSBpbnB1dCBlbGVtZW50LCB3aWxsIGJ1YmJsZSB1cCBhbmRcbiAgICAgICAgLy8gZW1pdCBpdHMgZXZlbnQgb2JqZWN0IHRvIHRoZSBgY2hhbmdlYCBvdXRwdXQuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBncm91cFZhbHVlQ2hhbmdlZCA9IHRoaXMucmFkaW9Hcm91cCAmJiB0aGlzLnZhbHVlICE9IHRoaXMucmFkaW9Hcm91cC52YWx1ZTtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIGlmICh0aGlzLnJhZGlvR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cC5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cC5fdG91Y2goKTtcbiAgICAgICAgICAgIGlmIChncm91cFZhbHVlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cC5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgZm9jdXMgY2hhbmdlcyBmb3IgdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHs/fSBmb2N1c09yaWdpblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUuX29uSW5wdXRGb2N1c0NoYW5nZSA9IGZ1bmN0aW9uIChmb2N1c09yaWdpbikge1xuICAgICAgICBpZiAoIXRoaXMuX2ZvY3VzUmlwcGxlICYmIGZvY3VzT3JpZ2luID09PSAna2V5Ym9hcmQnKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c1JpcHBsZSA9IHRoaXMuX3JpcHBsZS5sYXVuY2goMCwgMCwgeyBwZXJzaXN0ZW50OiB0cnVlLCBjZW50ZXJlZDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZm9jdXNPcmlnaW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGlvR3JvdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuX3RvdWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZm9jdXNSaXBwbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c1JpcHBsZS5mYWRlT3V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNSaXBwbGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWRSYWRpb0J1dHRvbjtcbn0oX01kUmFkaW9CdXR0b25NaXhpbkJhc2UpKTtcbk1kUmFkaW9CdXR0b24uZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1yYWRpby1idXR0b24sIG1hdC1yYWRpby1idXR0b24nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxsYWJlbCBbYXR0ci5mb3JdPVxcXCJpbnB1dElkXFxcIiBjbGFzcz1cXFwibWF0LXJhZGlvLWxhYmVsXFxcIiAjbGFiZWw+PGRpdiBjbGFzcz1cXFwibWF0LXJhZGlvLWNvbnRhaW5lclxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXJhZGlvLW91dGVyLWNpcmNsZVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXJhZGlvLWlubmVyLWNpcmNsZVxcXCI+PC9kaXY+PGRpdiBtZC1yaXBwbGUgY2xhc3M9XFxcIm1hdC1yYWRpby1yaXBwbGVcXFwiIFttZFJpcHBsZVRyaWdnZXJdPVxcXCJsYWJlbFxcXCIgW21kUmlwcGxlRGlzYWJsZWRdPVxcXCJfaXNSaXBwbGVEaXNhYmxlZCgpXFxcIiBbbWRSaXBwbGVDZW50ZXJlZF09XFxcInRydWVcXFwiPjwvZGl2PjwvZGl2PjxpbnB1dCAjaW5wdXQgY2xhc3M9XFxcIm1hdC1yYWRpby1pbnB1dCBjZGstdmlzdWFsbHktaGlkZGVuXFxcIiB0eXBlPVxcXCJyYWRpb1xcXCIgW2lkXT1cXFwiaW5wdXRJZFxcXCIgW2NoZWNrZWRdPVxcXCJjaGVja2VkXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW25hbWVdPVxcXCJuYW1lXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiYXJpYUxhYmVsXFxcIiBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVxcXCJhcmlhTGFiZWxsZWRieVxcXCIgKGNoYW5nZSk9XFxcIl9vbklucHV0Q2hhbmdlKCRldmVudClcXFwiIChjbGljayk9XFxcIl9vbklucHV0Q2xpY2soJGV2ZW50KVxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXJhZGlvLWxhYmVsLWNvbnRlbnRcXFwiIFtjbGFzcy5tYXQtcmFkaW8tbGFiZWwtYmVmb3JlXT1cXFwibGFiZWxQb3NpdGlvbiA9PSAnYmVmb3JlJ1xcXCI+PHNwYW4gc3R5bGU9XFxcImRpc3BsYXk6bm9uZVxcXCI+Jm5ic3A7PC9zcGFuPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48L2xhYmVsPlwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1yYWRpby1idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2t9Lm1hdC1yYWRpby1sYWJlbHtjdXJzb3I6cG9pbnRlcjtkaXNwbGF5OmlubGluZS1mbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjt3aGl0ZS1zcGFjZTpub3dyYXA7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tYXQtcmFkaW8tY29udGFpbmVye2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MjBweDtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoyMHB4fS5tYXQtcmFkaW8tb3V0ZXItY2lyY2xle2JveC1zaXppbmc6Ym9yZGVyLWJveDtoZWlnaHQ6MjBweDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7dHJhbnNpdGlvbjpib3JkZXItY29sb3IgZWFzZSAyODBtczt3aWR0aDoyMHB4O2JvcmRlci13aWR0aDoycHg7Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci1yYWRpdXM6NTAlfS5tYXQtcmFkaW8taW5uZXItY2lyY2xle2JvcmRlci1yYWRpdXM6NTAlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtoZWlnaHQ6MjBweDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gZWFzZSAyODBtcyxiYWNrZ3JvdW5kLWNvbG9yIGVhc2UgMjgwbXM7dHJhbnNmb3JtOnNjYWxlKDApO3dpZHRoOjIwcHh9Lm1hdC1yYWRpby1jaGVja2VkIC5tYXQtcmFkaW8taW5uZXItY2lyY2xle3RyYW5zZm9ybTpzY2FsZSguNSl9Lm1hdC1yYWRpby1sYWJlbC1jb250ZW50e2Rpc3BsYXk6aW5saW5lLWJsb2NrO29yZGVyOjA7bGluZS1oZWlnaHQ6aW5oZXJpdDtwYWRkaW5nLWxlZnQ6OHB4O3BhZGRpbmctcmlnaHQ6MH1bZGlyPXJ0bF0gLm1hdC1yYWRpby1sYWJlbC1jb250ZW50e3BhZGRpbmctcmlnaHQ6OHB4O3BhZGRpbmctbGVmdDowfS5tYXQtcmFkaW8tbGFiZWwtY29udGVudC5tYXQtcmFkaW8tbGFiZWwtYmVmb3Jle29yZGVyOi0xO3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6OHB4fVtkaXI9cnRsXSAubWF0LXJhZGlvLWxhYmVsLWNvbnRlbnQubWF0LXJhZGlvLWxhYmVsLWJlZm9yZXtwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy1sZWZ0OjhweH0ubWF0LXJhZGlvLWRpc2FibGVkLC5tYXQtcmFkaW8tZGlzYWJsZWQgLm1hdC1yYWRpby1sYWJlbHtjdXJzb3I6ZGVmYXVsdH0ubWF0LXJhZGlvLXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xNXB4O3RvcDotMTVweDtyaWdodDotMTVweDtib3R0b206LTE1cHg7Ym9yZGVyLXJhZGl1czo1MCU7ei1pbmRleDoxO3BvaW50ZXItZXZlbnRzOm5vbmV9XCJdLFxuICAgICAgICAgICAgICAgIGlucHV0czogWydjb2xvciddLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LXJhZGlvLWJ1dHRvbicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXJhZGlvLWNoZWNrZWRdJzogJ2NoZWNrZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1yYWRpby1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuaWRdJzogJ2lkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFJhZGlvQnV0dG9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTWRSYWRpb0dyb3VwLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICB7IHR5cGU6IEZvY3VzT3JpZ2luTW9uaXRvciwgfSxcbiAgICB7IHR5cGU6IFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIsIH0sXG5dOyB9O1xuTWRSYWRpb0J1dHRvbi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnaWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2FyaWFMYWJlbCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2FyaWEtbGFiZWwnLF0gfSxdLFxuICAgICdhcmlhTGFiZWxsZWRieSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2FyaWEtbGFiZWxsZWRieScsXSB9LF0sXG4gICAgJ2Rpc2FibGVSaXBwbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NoZWNrZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdhbGlnbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbGFiZWxQb3NpdGlvbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ19yaXBwbGUnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtNZFJpcHBsZSxdIH0sXSxcbiAgICAnX2lucHV0RWxlbWVudCc6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydpbnB1dCcsXSB9LF0sXG59O1xudmFyIE1kUmFkaW9Nb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFJhZGlvTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRSYWRpb01vZHVsZTtcbn0oKSk7XG5NZFJhZGlvTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNZFJpcHBsZU1vZHVsZSwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZFJhZGlvR3JvdXAsIE1kUmFkaW9CdXR0b24sIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVIsIFZJRVdQT1JUX1JVTEVSX1BST1ZJREVSLCBGb2N1c09yaWdpbk1vbml0b3JdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kUmFkaW9Hcm91cCwgTWRSYWRpb0J1dHRvbl0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUmFkaW9Nb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbnZhciBGb2N1c0tleU1hbmFnZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGb2N1c0tleU1hbmFnZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpdGVtc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZvY3VzS2V5TWFuYWdlcihpdGVtcykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaXRlbXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogSXQgYWxzbyBhZGRzIGZvY3VzZXMgdGhlIG5ld2x5IGFjdGl2ZSBpdGVtLlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzS2V5TWFuYWdlci5wcm90b3R5cGUuc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldEFjdGl2ZUl0ZW0uY2FsbCh0aGlzLCBpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRm9jdXNLZXlNYW5hZ2VyO1xufShMaXN0S2V5TWFuYWdlcikpO1xuLyoqXG4gKiBUaGlzIGFuaW1hdGlvbiBzaHJpbmtzIHRoZSBwbGFjZWhvbGRlciB0ZXh0IHRvIDc1JSBvZiBpdHMgbm9ybWFsIHNpemUgYW5kIHRyYW5zbGF0ZXNcbiAqIGl0IHRvIGVpdGhlciB0aGUgdG9wIGxlZnQgY29ybmVyIChsdHIpIG9yIHRvcCByaWdodCBjb3JuZXIgKHJ0bCkgb2YgdGhlIHRyaWdnZXIsXG4gKiBkZXBlbmRpbmcgb24gdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAqL1xudmFyIHRyYW5zZm9ybVBsYWNlaG9sZGVyID0gdHJpZ2dlcigndHJhbnNmb3JtUGxhY2Vob2xkZXInLCBbXG4gICAgc3RhdGUoJ2Zsb2F0aW5nLWx0cicsIHN0eWxlKHtcbiAgICAgICAgdG9wOiAnLTIycHgnLFxuICAgICAgICBsZWZ0OiAnLTJweCcsXG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDAuNzUpJ1xuICAgIH0pKSxcbiAgICBzdGF0ZSgnZmxvYXRpbmctcnRsJywgc3R5bGUoe1xuICAgICAgICB0b3A6ICctMjJweCcsXG4gICAgICAgIGxlZnQ6ICcycHgnLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgwLjc1KSdcbiAgICB9KSksXG4gICAgdHJhbnNpdGlvbignKiA9PiAqJywgYW5pbWF0ZSgnNDAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSknKSlcbl0pO1xuLyoqXG4gKiBUaGlzIGFuaW1hdGlvbiB0cmFuc2Zvcm1zIHRoZSBzZWxlY3QncyBvdmVybGF5IHBhbmVsIG9uIGFuZCBvZmYgdGhlIHBhZ2UuXG4gKlxuICogV2hlbiB0aGUgcGFuZWwgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSwgaXQgZXhwYW5kcyBpdHMgd2lkdGggYnkgdGhlIGFtb3VudCBvZiBwYWRkaW5nLCBzY2FsZXMgaXRcbiAqIHVwIHRvIDEwMCUgb24gdGhlIFkgYXhpcywgZmFkZXMgaW4gaXRzIGJvcmRlciwgYW5kIHRyYW5zbGF0ZXMgc2xpZ2h0bHkgdXAgYW5kIHRvIHRoZVxuICogc2lkZSB0byBlbnN1cmUgdGhlIG9wdGlvbiB0ZXh0IGNvcnJlY3RseSBvdmVybGFwcyB0aGUgdHJpZ2dlciB0ZXh0LlxuICpcbiAqIFdoZW4gdGhlIHBhbmVsIGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLCBpdCBzaW1wbHkgZmFkZXMgb3V0IGxpbmVhcmx5LlxuICovXG52YXIgdHJhbnNmb3JtUGFuZWwgPSB0cmlnZ2VyKCd0cmFuc2Zvcm1QYW5lbCcsIFtcbiAgICBzdGF0ZSgnc2hvd2luZycsIHN0eWxlKHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgbWluV2lkdGg6ICdjYWxjKDEwMCUgKyAzMnB4KScsXG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlWSgxKSdcbiAgICB9KSksXG4gICAgc3RhdGUoJ3Nob3dpbmctbXVsdGlwbGUnLCBzdHlsZSh7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIG1pbldpZHRoOiAnY2FsYygxMDAlICsgNjRweCknLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVkoMSknXG4gICAgfSkpLFxuICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtcbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIG1pbldpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVkoMCknXG4gICAgICAgIH0pLFxuICAgICAgICBhbmltYXRlKCcxNTBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKScpXG4gICAgXSksXG4gICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xuICAgICAgICBhbmltYXRlKCcyNTBtcyAxMDBtcyBsaW5lYXInLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXG4gICAgXSlcbl0pO1xuLyoqXG4gKiBUaGlzIGFuaW1hdGlvbiBmYWRlcyBpbiB0aGUgYmFja2dyb3VuZCBjb2xvciBhbmQgdGV4dCBjb250ZW50IG9mIHRoZVxuICogc2VsZWN0J3Mgb3B0aW9ucy4gSXQgaXMgdGltZSBkZWxheWVkIHRvIG9jY3VyIDEwMG1zIGFmdGVyIHRoZSBvdmVybGF5XG4gKiBwYW5lbCBoYXMgdHJhbnNmb3JtZWQgaW4uXG4gKi9cbnZhciBmYWRlSW5Db250ZW50ID0gdHJpZ2dlcignZmFkZUluQ29udGVudCcsIFtcbiAgICBzdGF0ZSgnc2hvd2luZycsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSksXG4gICAgdHJhbnNpdGlvbigndm9pZCA9PiBzaG93aW5nJywgW1xuICAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICAgIGFuaW1hdGUoJzE1MG1zIDEwMG1zIGN1YmljLWJlemllcigwLjU1LCAwLCAwLjU1LCAwLjIpJylcbiAgICBdKVxuXSk7XG4vKipcbiAqIFJldHVybnMgYW4gZXhjZXB0aW9uIHRvIGJlIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gY2hhbmdlIGEgc1xuICogZWxlY3QncyBgbXVsdGlwbGVgIG9wdGlvbiBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TWRTZWxlY3REeW5hbWljTXVsdGlwbGVFcnJvcigpIHtcbiAgICByZXR1cm4gRXJyb3IoJ0Nhbm5vdCBjaGFuZ2UgYG11bHRpcGxlYCBtb2RlIG9mIHNlbGVjdCBhZnRlciBpbml0aWFsaXphdGlvbi4nKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBleGNlcHRpb24gdG8gYmUgdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhc3NpZ24gYSBub24tYXJyYXkgdmFsdWUgdG8gYSBzZWxlY3RcbiAqIGluIGBtdWx0aXBsZWAgbW9kZS4gTm90ZSB0aGF0IGB1bmRlZmluZWRgIGFuZCBgbnVsbGAgYXJlIHN0aWxsIHZhbGlkIHZhbHVlcyB0byBhbGxvdyBmb3JcbiAqIHJlc2V0dGluZyB0aGUgdmFsdWUuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE1kU2VsZWN0Tm9uQXJyYXlWYWx1ZUVycm9yKCkge1xuICAgIHJldHVybiBFcnJvcignQ2Fubm90IGFzc2lnbiB0cnV0aHkgbm9uLWFycmF5IHZhbHVlIHRvIHNlbGVjdCBpbiBgbXVsdGlwbGVgIG1vZGUuJyk7XG59XG4vKipcbiAqIFRoZSBmaXhlZCBoZWlnaHQgb2YgZXZlcnkgb3B0aW9uIGVsZW1lbnQgKG9wdGlvbiwgZ3JvdXAgaGVhZGVyIGV0Yy4pLlxuICovXG52YXIgU0VMRUNUX0lURU1fSEVJR0hUID0gNDg7XG4vKipcbiAqIFRoZSBtYXggaGVpZ2h0IG9mIHRoZSBzZWxlY3QncyBvdmVybGF5IHBhbmVsXG4gKi9cbnZhciBTRUxFQ1RfUEFORUxfTUFYX0hFSUdIVCA9IDI1Njtcbi8qKlxuICogVGhlIG1heCBudW1iZXIgb2Ygb3B0aW9ucyB2aXNpYmxlIGF0IG9uY2UgaW4gdGhlIHNlbGVjdCBwYW5lbC5cbiAqL1xudmFyIFNFTEVDVF9NQVhfT1BUSU9OU19ESVNQTEFZRUQgPSBNYXRoLmZsb29yKFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUIC8gU0VMRUNUX0lURU1fSEVJR0hUKTtcbi8qKlxuICogVGhlIGZpeGVkIGhlaWdodCBvZiB0aGUgc2VsZWN0J3MgdHJpZ2dlciBlbGVtZW50LlxuICovXG52YXIgU0VMRUNUX1RSSUdHRVJfSEVJR0hUID0gMzA7XG4vKipcbiAqIE11c3QgYWRqdXN0IGZvciB0aGUgZGlmZmVyZW5jZSBpbiBoZWlnaHQgYmV0d2VlbiB0aGUgb3B0aW9uIGFuZCB0aGUgdHJpZ2dlcixcbiAqIHNvIHRoZSB0ZXh0IHdpbGwgYWxpZ24gb24gdGhlIHkgYXhpcy5cbiAqL1xudmFyIFNFTEVDVF9PUFRJT05fSEVJR0hUX0FESlVTVE1FTlQgPSAoU0VMRUNUX0lURU1fSEVJR0hUIC0gU0VMRUNUX1RSSUdHRVJfSEVJR0hUKSAvIDI7XG4vKipcbiAqIFRoZSBwYW5lbCdzIHBhZGRpbmcgb24gdGhlIHgtYXhpc1xuICovXG52YXIgU0VMRUNUX1BBTkVMX1BBRERJTkdfWCA9IDE2O1xuLyoqXG4gKiBUaGUgcGFuZWwncyB4IGF4aXMgcGFkZGluZyBpZiBpdCBpcyBpbmRlbnRlZCAoZS5nLiB0aGVyZSBpcyBhbiBvcHRpb24gZ3JvdXApLlxuICovXG52YXIgU0VMRUNUX1BBTkVMX0lOREVOVF9QQURESU5HX1ggPSBTRUxFQ1RfUEFORUxfUEFERElOR19YICogMjtcbi8qKlxuICogRGlzdGFuY2UgYmV0d2VlbiB0aGUgcGFuZWwgZWRnZSBhbmQgdGhlIG9wdGlvbiB0ZXh0IGluXG4gKiBtdWx0aS1zZWxlY3Rpb24gbW9kZS5cbiAqXG4gKiAoU0VMRUNUX1BBRERJTkcgKiAxLjc1KSArIDIwID0gNDhcbiAqIFRoZSBwYWRkaW5nIGlzIG11bHRpcGxpZWQgYnkgMS43NSBiZWNhdXNlIHRoZSBjaGVja2JveCdzIG1hcmdpbiBpcyBoYWxmIHRoZSBwYWRkaW5nLCBhbmRcbiAqIHRoZSBicm93c2VyIGFkZHMgfjRweCwgYmVjYXVzZSB3ZSdyZSB1c2luZyBpbmxpbmUgZWxlbWVudHMuXG4gKiBUaGUgY2hlY2tib3ggd2lkdGggaXMgMjBweC5cbiAqL1xudmFyIFNFTEVDVF9NVUxUSVBMRV9QQU5FTF9QQURESU5HX1ggPSBTRUxFQ1RfUEFORUxfUEFERElOR19YICogMS43NSArIDIwO1xuLyoqXG4gKiBUaGUgcGFuZWwncyBwYWRkaW5nIG9uIHRoZSB5LWF4aXMuIFRoaXMgcGFkZGluZyBpbmRpY2F0ZXMgdGhlcmUgYXJlIG1vcmVcbiAqIG9wdGlvbnMgYXZhaWxhYmxlIGlmIHlvdSBzY3JvbGwuXG4gKi9cbnZhciBTRUxFQ1RfUEFORUxfUEFERElOR19ZID0gMTY7XG4vKipcbiAqIFRoZSBzZWxlY3QgcGFuZWwgd2lsbCBvbmx5IFwiZml0XCIgaW5zaWRlIHRoZSB2aWV3cG9ydCBpZiBpdCBpcyBwb3NpdGlvbmVkIGF0XG4gKiB0aGlzIHZhbHVlIG9yIG1vcmUgYXdheSBmcm9tIHRoZSB2aWV3cG9ydCBib3VuZGFyeS5cbiAqL1xudmFyIFNFTEVDVF9QQU5FTF9WSUVXUE9SVF9QQURESU5HID0gODtcbi8qKlxuICogQ2hhbmdlIGV2ZW50IG9iamVjdCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0IHZhbHVlIGhhcyBjaGFuZ2VkLlxuICovXG52YXIgTWRTZWxlY3RDaGFuZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFNlbGVjdENoYW5nZShzb3VyY2UsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBNZFNlbGVjdENoYW5nZTtcbn0oKSk7XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRTZWxlY3RCYXNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRTZWxlY3RCYXNlKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG4gICAgcmV0dXJuIE1kU2VsZWN0QmFzZTtcbn0oKSk7XG52YXIgX01kU2VsZWN0TWl4aW5CYXNlID0gbWl4aW5Db2xvcihtaXhpbkRpc2FibGVkKE1kU2VsZWN0QmFzZSksICdwcmltYXJ5Jyk7XG52YXIgTWRTZWxlY3QgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFNlbGVjdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF92aWV3cG9ydFJ1bGVyXG4gICAgICogQHBhcmFtIHs/fSBfY2hhbmdlRGV0ZWN0b3JSZWZcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICogQHBhcmFtIHs/fSBfY29udHJvbFxuICAgICAqIEBwYXJhbSB7P30gdGFiSW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHBsYWNlaG9sZGVyT3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kU2VsZWN0KF92aWV3cG9ydFJ1bGVyLCBfY2hhbmdlRGV0ZWN0b3JSZWYsIHJlbmRlcmVyLCBlbGVtZW50UmVmLCBfZGlyLCBfY29udHJvbCwgdGFiSW5kZXgsIHBsYWNlaG9sZGVyT3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZW5kZXJlciwgZWxlbWVudFJlZikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3ZpZXdwb3J0UnVsZXIgPSBfdmlld3BvcnRSdWxlcjtcbiAgICAgICAgX3RoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICBfdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgX3RoaXMuX2NvbnRyb2wgPSBfY29udHJvbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IHBhbmVsIGlzIG9wZW4uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fcGFuZWxPcGVuID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGZpbGxpbmcgb3V0IHRoZSBzZWxlY3QgaXMgcmVxdWlyZWQgaW4gdGhlIGZvcm0uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fcmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgcGFuZWwsIGNhbGN1bGF0ZWQgdG8gY2VudGVyIHRoZSBzZWxlY3RlZCBvcHRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBpbiBtdWx0aXBsZSBzZWxlY3Rpb24gbW9kZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9tdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFuaW1hdGlvbiBzdGF0ZSBvZiB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fcGxhY2Vob2xkZXJTdGF0ZSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVmlldyAtPiBtb2RlbCBjYWxsYmFjayBjYWxsZWQgd2hlbiB2YWx1ZSBjaGFuZ2VzXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWaWV3IC0+IG1vZGVsIGNhbGxiYWNrIGNhbGxlZCB3aGVuIHNlbGVjdCBoYXMgYmVlbiB0b3VjaGVkXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEcyBvZiBjaGlsZCBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUgYXJpYS1vd25zIGF0dHJpYnV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vcHRpb25JZHMgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0IHBhbmVsJ3MgdHJhbnNmb3JtLW9yaWdpbiBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSAndG9wJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHBhbmVsJ3MgYW5pbWF0aW9uIGlzIGRvbmUuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fcGFuZWxEb25lQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgeS1vZmZzZXQgb2YgdGhlIG92ZXJsYXkgcGFuZWwgaW4gcmVsYXRpb24gdG8gdGhlIHRyaWdnZXIncyB0b3Agc3RhcnQgY29ybmVyLlxuICAgICAgICAgKiBUaGlzIG11c3QgYmUgYWRqdXN0ZWQgdG8gYWxpZ24gdGhlIHNlbGVjdGVkIG9wdGlvbiB0ZXh0IG92ZXIgdGhlIHRyaWdnZXIgdGV4dC5cbiAgICAgICAgICogd2hlbiB0aGUgcGFuZWwgb3BlbnMuIFdpbGwgY2hhbmdlIGJhc2VkIG9uIHRoZSB5LXBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBvcHRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb2Zmc2V0WSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHBvc2l0aW9uIGNvbmZpZyBlbnN1cmVzIHRoYXQgdGhlIHRvcCBcInN0YXJ0XCIgY29ybmVyIG9mIHRoZSBvdmVybGF5XG4gICAgICAgICAqIGlzIGFsaWduZWQgd2l0aCB3aXRoIHRoZSB0b3AgXCJzdGFydFwiIG9mIHRoZSBvcmlnaW4gYnkgZGVmYXVsdCAob3ZlcmxhcHBpbmdcbiAgICAgICAgICogdGhlIHRyaWdnZXIgY29tcGxldGVseSkuIElmIHRoZSBwYW5lbCBjYW5ub3QgZml0IGJlbG93IHRoZSB0cmlnZ2VyLCBpdFxuICAgICAgICAgKiB3aWxsIGZhbGwgYmFjayB0byBhIHBvc2l0aW9uIGFib3ZlIHRoZSB0cmlnZ2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3Bvc2l0aW9ucyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlZOiAndG9wJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICBvdmVybGF5WTogJ2JvdHRvbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJpYSBsYWJlbCBvZiB0aGUgc2VsZWN0LiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBiZSB1c2VkIGFzIGxhYmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYXJpYUxhYmVsID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnB1dCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGBhcmlhLWxhYmVsbGVkYnlgIGF0dHJpYnV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmFyaWFMYWJlbGxlZGJ5ID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBoYXMgYmVlbiBvcGVuZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vbk9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBoYXMgYmVlbiBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vbkNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3RlZCB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkIGJ5IHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBpZiAoX3RoaXMuX2NvbnRyb2wpIHtcbiAgICAgICAgICAgIF90aGlzLl9jb250cm9sLnZhbHVlQWNjZXNzb3IgPSBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fdGFiSW5kZXggPSBwYXJzZUludCh0YWJJbmRleCkgfHwgMDtcbiAgICAgICAgX3RoaXMuX3BsYWNlaG9sZGVyT3B0aW9ucyA9IHBsYWNlaG9sZGVyT3B0aW9ucyA/IHBsYWNlaG9sZGVyT3B0aW9ucyA6IHt9O1xuICAgICAgICBfdGhpcy5mbG9hdFBsYWNlaG9sZGVyID0gX3RoaXMuX3BsYWNlaG9sZGVyT3B0aW9ucy5mbG9hdCB8fCAnYXV0byc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbGFjZWhvbGRlciB0byBiZSBzaG93biBpZiBubyB2YWx1ZSBoYXMgYmVlbiBzZWxlY3RlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXI7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBNdXN0IHdhaXQgdG8gcmVjb3JkIHRoZSB0cmlnZ2VyIHdpZHRoIHRvIGVuc3VyZSBwbGFjZWhvbGRlciB3aWR0aCBpcyBpbmNsdWRlZC5cbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9zZXRUcmlnZ2VyV2lkdGgoKTsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNlbGVjdC5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY29tcG9uZW50IGlzIHJlcXVpcmVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXF1aXJlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3JlcXVpcmVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJtdWx0aXBsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIHNob3VsZCBiZSBhbGxvd2VkIHRvIHNlbGVjdCBtdWx0aXBsZSBvcHRpb25zLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tdWx0aXBsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBnZXRNZFNlbGVjdER5bmFtaWNNdWx0aXBsZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tdWx0aXBsZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNlbGVjdC5wcm90b3R5cGUsIFwiZmxvYXRQbGFjZWhvbGRlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGZsb2F0IHRoZSBwbGFjZWhvbGRlciB0ZXh0LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXIgPSB2YWx1ZSB8fCB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbnMuZmxvYXQgfHwgJ2F1dG8nO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRhYiBpbmRleCBmb3IgdGhlIHNlbGVjdCBlbGVtZW50LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpc2FibGVkID8gLTEgOiB0aGlzLl90YWJJbmRleDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhYkluZGV4ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNlbGVjdC5wcm90b3R5cGUsIFwib3B0aW9uU2VsZWN0aW9uQ2hhbmdlc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21iaW5lZCBzdHJlYW0gb2YgYWxsIG9mIHRoZSBjaGlsZCBvcHRpb25zJyBjaGFuZ2UgZXZlbnRzLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2UuYXBwbHkodm9pZCAwLCB0aGlzLm9wdGlvbnMubWFwKGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIG9wdGlvbi5vblNlbGVjdGlvbkNoYW5nZTsgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwgPSBuZXcgU2VsZWN0aW9uTW9kZWwodGhpcy5tdWx0aXBsZSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luaXRLZXlNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVN1YnNjcmlwdGlvbiA9IHN0YXJ0V2l0aC5jYWxsKHRoaXMub3B0aW9ucy5jaGFuZ2VzLCBudWxsKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9jb250cm9sKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmZXIgc2V0dGluZyB0aGUgdmFsdWUgaW4gb3JkZXIgdG8gYXZvaWQgdGhlIFwiRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIC8vIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkXCIgZXJyb3JzIGZyb20gQW5ndWxhci5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc2V0U2VsZWN0aW9uQnlWYWx1ZShfdGhpcy5fY29udHJvbC52YWx1ZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kcm9wU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5fY2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdGFiU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgb3ZlcmxheSBwYW5lbCBvcGVuIG9yIGNsb3NlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFuZWxPcGVuID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgb3ZlcmxheSBwYW5lbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAhdGhpcy5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fdHJpZ2dlcldpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRUcmlnZ2VyV2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVPdmVybGF5UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJTdGF0ZSA9IHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLl9wYW5lbE9wZW4gPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBvdmVybGF5IHBhbmVsIGFuZCBmb2N1c2VzIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5lbE9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyU3RhdGUgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0J3MgdmFsdWUuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZVxuICAgICAqIHJlcXVpcmVkIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWUgTmV3IHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uQnlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzZWxlY3QncyB2YWx1ZVxuICAgICAqIGNoYW5nZXMgZnJvbSB1c2VyIGlucHV0LiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2VcbiAgICAgKiByZXF1aXJlZCB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzZWxlY3QgaXMgYmx1cnJlZFxuICAgICAqIGJ5IHRoZSB1c2VyLiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UgcmVxdWlyZWRcbiAgICAgKiB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdG91Y2hlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBzZWxlY3QuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSByZXF1aXJlZFxuICAgICAqIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZCBTZXRzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcInBhbmVsT3BlblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3ZlcmxheSBwYW5lbCBpcyBvcGVuLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFuZWxPcGVuO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNlbGVjdC5wcm90b3R5cGUsIFwidHJpZ2dlclZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBkaXNwbGF5ZWQgaW4gdGhlIHRyaWdnZXIuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdGVkT3B0aW9ucyA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBvcHRpb24udmlld1ZhbHVlOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNSdGwoKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE9wdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPKGNyaXNiZXRvKTogZGVsaW1pdGVyIHNob3VsZCBiZSBjb25maWd1cmFibGUgZm9yIHByb3BlciBsb2NhbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkT3B0aW9ucy5qb2luKCcsICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkWzBdLnZpZXdWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpcyBpbiBSVEwgbW9kZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5faXNSdGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgPT09ICdydGwnIDogZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB3aWR0aCBvZiB0aGUgdHJpZ2dlciBlbGVtZW50LiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBtYXRjaFxuICAgICAqIHRoZSBvdmVybGF5IHdpZHRoIHRvIHRoZSB0cmlnZ2VyIHdpZHRoLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9zZXRUcmlnZ2VyV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJXaWR0aCA9IHRoaXMuX2dldFRyaWdnZXJSZWN0KCkud2lkdGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBrZXlib2FyZCBpbnRlcmFjdGlvbnMgb2YgYSBjbG9zZWQgc2VsZWN0LlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5faGFuZGxlQ2xvc2VkS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBTUEFDRSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nIGRvd24gd2hlbiBwcmVzc2luZyBzcGFjZVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gVVBfQVJST1cgfHwgZXZlbnQua2V5Q29kZSA9PT0gRE9XTl9BUlJPVykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUFycm93S2V5KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBrZXlwcmVzc2VzIGluc2lkZSB0aGUgcGFuZWwuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9oYW5kbGVQYW5lbEtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEhPTUUgfHwgZXZlbnQua2V5Q29kZSA9PT0gRU5EKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQua2V5Q29kZSA9PT0gSE9NRSA/IHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCkgOlxuICAgICAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0TGFzdEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcGFuZWwgZWxlbWVudCBpcyBmaW5pc2hlZCB0cmFuc2Zvcm1pbmcgaW4gKHRob3VnaCBub3QgZmFkaW5nIGluKSwgaXRcbiAgICAgKiBlbWl0cyBhbiBldmVudCBhbmQgZm9jdXNlcyBhbiBvcHRpb24gaWYgdGhlIHBhbmVsIGlzIG9wZW4uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX29uUGFuZWxEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbE9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzQ29ycmVjdE9wdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5vbk9wZW4uZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhbmVsRG9uZUFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5RGlyLm9mZnNldFggPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBwYW5lbCBjb250ZW50IGlzIGRvbmUgZmFkaW5nIGluLCB0aGUgX3BhbmVsRG9uZUFuaW1hdGluZyBwcm9wZXJ0eSBpc1xuICAgICAqIHNldCBzbyB0aGUgcHJvcGVyIGNsYXNzIGNhbiBiZSBhZGRlZCB0byB0aGUgcGFuZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX29uRmFkZUluRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGFuZWxEb25lQW5pbWF0aW5nID0gdGhpcy5wYW5lbE9wZW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgdG91Y2hlZCBjYWxsYmFjayBvbmx5IGlmIHRoZSBwYW5lbCBpcyBjbG9zZWQuIE90aGVyd2lzZSwgdGhlIHRyaWdnZXIgd2lsbFxuICAgICAqIFwiYmx1clwiIHRvIHRoZSBwYW5lbCB3aGVuIGl0IG9wZW5zLCBjYXVzaW5nIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhbmVsT3Blbikge1xuICAgICAgICAgICAgdGhpcy5fb25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSBvdmVybGF5IHBhbmVsIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9vbkF0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVPdmVybGF5T2Zmc2V0WCgpO1xuICAgICAgICB0aGlzLl9zZXRTY3JvbGxUb3AoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lci4gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlclxuICAgICAqIHRoZSBvdmVybGF5IHBhbmUgaXMgYXR0YWNoZWQgb3IgdGhlIHNjcm9sbCBjb250YWluZXIgZWxlbWVudCB3aWxsIG5vdCB5ZXQgYmVcbiAgICAgKiBwcmVzZW50IGluIHRoZSBET00uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5vdmVybGF5RGlyLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1hdC1zZWxlY3QtcGFuZWwnKTsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAoKHNjcm9sbENvbnRhaW5lcikpLnNjcm9sbFRvcCA9IHRoaXMuX3Njcm9sbFRvcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdGVkIG9wdGlvbiBiYXNlZCBvbiBhIHZhbHVlLiBJZiBubyBvcHRpb24gY2FuIGJlXG4gICAgICogZm91bmQgd2l0aCB0aGUgZGVzaWduYXRlZCB2YWx1ZSwgdGhlIHNlbGVjdCB0cmlnZ2VyIGlzIGNsZWFyZWQuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IGlzVXNlcklucHV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NldFNlbGVjdGlvbkJ5VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGlzVXNlcklucHV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpc1VzZXJJbnB1dCA9PT0gdm9pZCAwKSB7IGlzVXNlcklucHV0ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSAmJiB2YWx1ZSAmJiAhaXNBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TWRTZWxlY3ROb25BcnJheVZhbHVlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudFZhbHVlKSB7IHJldHVybiBfdGhpcy5fc2VsZWN0VmFsdWUoY3VycmVudFZhbHVlLCBpc1VzZXJJbnB1dCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fc29ydFZhbHVlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0VmFsdWUodmFsdWUsIGlzVXNlcklucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRWYWx1ZVdpZHRoKCk7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyU3RhdGUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGFuZCBzZWxlY3RzIGFuZCBvcHRpb24gYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBpc1VzZXJJbnB1dFxuICAgICAqIEByZXR1cm4gez99IE9wdGlvbiB0aGF0IGhhcyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NlbGVjdFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBpc1VzZXJJbnB1dCkge1xuICAgICAgICBpZiAoaXNVc2VySW5wdXQgPT09IHZvaWQgMCkgeyBpc1VzZXJJbnB1dCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnNBcnJheSA9IHRoaXMub3B0aW9ucy50b0FycmF5KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvcnJlc3BvbmRpbmdPcHRpb24gPSBvcHRpb25zQXJyYXkuZmluZChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLnZhbHVlICE9IG51bGwgJiYgb3B0aW9uLnZhbHVlID09PSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb3JyZXNwb25kaW5nT3B0aW9uKSB7XG4gICAgICAgICAgICBpc1VzZXJJbnB1dCA/IGNvcnJlc3BvbmRpbmdPcHRpb24uX3NlbGVjdFZpYUludGVyYWN0aW9uKCkgOiBjb3JyZXNwb25kaW5nT3B0aW9uLnNlbGVjdCgpO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KGNvcnJlc3BvbmRpbmdPcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKG9wdGlvbnNBcnJheS5pbmRleE9mKGNvcnJlc3BvbmRpbmdPcHRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ycmVzcG9uZGluZ09wdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc2VsZWN0IHRyaWdnZXIgYW5kIGRlc2VsZWN0cyBldmVyeSBvcHRpb24gaW4gdGhlIGxpc3QuXG4gICAgICogQHBhcmFtIHs/PX0gc2tpcCBPcHRpb24gdGhhdCBzaG91bGQgbm90IGJlIGRlc2VsZWN0ZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2NsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24gKHNraXApIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbiAhPT0gc2tpcCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5kZXNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9nZXRUcmlnZ2VyUmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBhIGtleSBtYW5hZ2VyIHRvIGxpc3RlbiB0byBrZXlib2FyZCBldmVudHMgb24gdGhlIG92ZXJsYXkgcGFuZWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2luaXRLZXlNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEZvY3VzS2V5TWFuYWdlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLl90YWJTdWJzY3JpcHRpb24gPSB0aGlzLl9rZXlNYW5hZ2VyLnRhYk91dC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvc2UoKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEcm9wcyBjdXJyZW50IG9wdGlvbiBzdWJzY3JpcHRpb25zIGFuZCBJRHMgYW5kIHJlc2V0cyBmcm9tIHNjcmF0Y2guXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3Jlc2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZHJvcFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuVG9PcHRpb25zKCk7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbklkcygpO1xuICAgICAgICB0aGlzLl9zZXRPcHRpb25NdWx0aXBsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdGVucyB0byB1c2VyLWdlbmVyYXRlZCBzZWxlY3Rpb24gZXZlbnRzIG9uIGVhY2ggb3B0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9saXN0ZW5Ub09wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX29wdGlvblN1YnNjcmlwdGlvbiA9IGZpbHRlci5jYWxsKHRoaXMub3B0aW9uU2VsZWN0aW9uQ2hhbmdlcywgZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5pc1VzZXJJbnB1dDsgfSkuc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuX29uU2VsZWN0KGV2ZW50LnNvdXJjZSk7XG4gICAgICAgICAgICBfdGhpcy5fc2V0VmFsdWVXaWR0aCgpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIGFuIG9wdGlvbiBpcyBjbGlja2VkLlxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX29uU2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3YXNTZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQob3B0aW9uKTtcbiAgICAgICAgLy8gVE9ETyhjcmlzYmV0byk6IGhhbmRsZSBibGFuay9udWxsIG9wdGlvbnMgaW5zaWRlIG11bHRpLXNlbGVjdC5cbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnRvZ2dsZShvcHRpb24pO1xuICAgICAgICAgICAgd2FzU2VsZWN0ZWQgPyBvcHRpb24uZGVzZWxlY3QoKSA6IG9wdGlvbi5zZWxlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuX3NvcnRWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZWN0aW9uKG9wdGlvbi52YWx1ZSA9PSBudWxsID8gdW5kZWZpbmVkIDogb3B0aW9uKTtcbiAgICAgICAgICAgIGlmIChvcHRpb24udmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BhZ2F0ZUNoYW5nZXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdChvcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3YXNTZWxlY3RlZCAhPT0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuaXNTZWxlY3RlZChvcHRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9wYWdhdGVDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBtb2RlbCB2YWx1ZXMsIGVuc3VyaW5nIHRoYXQgdGhleSBrZWVwIHRoZSBzYW1lXG4gICAgICogb3JkZXIgdGhhdCB0aGV5IGhhdmUgaW4gdGhlIHBhbmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9zb3J0VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KG9wdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGFsbCBvcHRpb24gc3Vic2NyaXB0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZHJvcFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdHMgY2hhbmdlIGV2ZW50IHRvIHNldCB0aGUgbW9kZWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHs/PX0gZmFsbGJhY2tWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9wcm9wYWdhdGVDaGFuZ2VzID0gZnVuY3Rpb24gKGZhbGxiYWNrVmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVUb0VtaXQgPSBudWxsO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgdmFsdWVUb0VtaXQgPSB0aGlzLnNlbGVjdGVkLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBvcHRpb24udmFsdWU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVUb0VtaXQgPSB0aGlzLnNlbGVjdGVkID8gdGhpcy5zZWxlY3RlZC52YWx1ZSA6IGZhbGxiYWNrVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25DaGFuZ2UodmFsdWVUb0VtaXQpO1xuICAgICAgICB0aGlzLmNoYW5nZS5lbWl0KG5ldyBNZFNlbGVjdENoYW5nZSh0aGlzLCB2YWx1ZVRvRW1pdCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjb3JkcyBvcHRpb24gSURzIHRvIHBhc3MgdG8gdGhlIGFyaWEtb3ducyBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fc2V0T3B0aW9uSWRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vcHRpb25JZHMgPSB0aGlzLm9wdGlvbnMubWFwKGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIG9wdGlvbi5pZDsgfSkuam9pbignICcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYG11bHRpcGxlYCBwcm9wZXJ0eSBvbiBlYWNoIG9wdGlvbi4gVGhlIHByb21pc2UgaXMgbmVjZXNzYXJ5XG4gICAgICogaW4gb3JkZXIgdG8gYXZvaWQgQW5ndWxhciBlcnJvcnMgd2hlbiBtb2RpZnlpbmcgdGhlIHByb3BlcnR5IGFmdGVyIGluaXQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NldE9wdGlvbk11bHRpcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBvcHRpb24ubXVsdGlwbGUgPSBfdGhpcy5tdWx0aXBsZTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTXVzdCBzZXQgdGhlIHdpZHRoIG9mIHRoZSBzZWxlY3RlZCBvcHRpb24ncyB2YWx1ZSBwcm9ncmFtbWF0aWNhbGx5XG4gICAgICogYmVjYXVzZSBpdCBpcyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgYW5kIG90aGVyd2lzZSB3aWxsIG5vdCBjbGlwXG4gICAgICogb3ZlcmZsb3cuIFRoZSBzZWxlY3Rpb24gYXJyb3cgaXMgOXB4IHdpZGUsIGFkZCA0cHggb2YgcGFkZGluZyA9IDEzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NldFZhbHVlV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkVmFsdWVXaWR0aCA9IHRoaXMuX3RyaWdnZXJXaWR0aCAtIDEzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgc2VsZWN0ZWQgaXRlbS4gSWYgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLCBpdCB3aWxsIGZvY3VzXG4gICAgICogdGhlIGZpcnN0IGl0ZW0gaW5zdGVhZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZm9jdXNDb3JyZWN0T3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEZpcnN0SXRlbUFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLl9nZXRPcHRpb25JbmRleCh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZFswXSkpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIHNlbGVjdCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBwcm92aWRlZCBvcHRpb24gaW4gdGhlIG9wdGlvbiBsaXN0LlxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2dldE9wdGlvbkluZGV4ID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBjdXJyZW50LCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gKG9wdGlvbiA9PT0gY3VycmVudCA/IGluZGV4IDogdW5kZWZpbmVkKSA6IHJlc3VsdDtcbiAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNjcm9sbCBwb3NpdGlvbiBhbmQgeC0gYW5kIHktb2Zmc2V0cyBvZiB0aGUgb3ZlcmxheSBwYW5lbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2FsY3VsYXRlT3ZlcmxheVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpdGVtcyA9IHRoaXMuX2dldEl0ZW1Db3VudCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYW5lbEhlaWdodCA9IE1hdGgubWluKGl0ZW1zICogU0VMRUNUX0lURU1fSEVJR0hULCBTRUxFQ1RfUEFORUxfTUFYX0hFSUdIVCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcm9sbENvbnRhaW5lckhlaWdodCA9IGl0ZW1zICogU0VMRUNUX0lURU1fSEVJR0hUO1xuICAgICAgICAvLyBUaGUgZmFydGhlc3QgdGhlIHBhbmVsIGNhbiBiZSBzY3JvbGxlZCBiZWZvcmUgaXQgaGl0cyB0aGUgYm90dG9tXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1heFNjcm9sbCA9IHNjcm9sbENvbnRhaW5lckhlaWdodCAtIHBhbmVsSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0ZWRPcHRpb25PZmZzZXQgPSAoKHRoaXMuX2dldE9wdGlvbkluZGV4KHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkWzBdKSkpO1xuICAgICAgICAgICAgc2VsZWN0ZWRPcHRpb25PZmZzZXQgKz0gdGhpcy5fZ2V0TGFiZWxDb3VudEJlZm9yZU9wdGlvbihzZWxlY3RlZE9wdGlvbk9mZnNldCk7XG4gICAgICAgICAgICAvLyBXZSBtdXN0IG1haW50YWluIGEgc2Nyb2xsIGJ1ZmZlciBzbyB0aGUgc2VsZWN0ZWQgb3B0aW9uIHdpbGwgYmUgc2Nyb2xsZWQgdG8gdGhlXG4gICAgICAgICAgICAvLyBjZW50ZXIgb2YgdGhlIG92ZXJsYXkgcGFuZWwgcmF0aGVyIHRoYW4gdGhlIHRvcC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcm9sbEJ1ZmZlciA9IHBhbmVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IHRoaXMuX2NhbGN1bGF0ZU92ZXJsYXlTY3JvbGwoc2VsZWN0ZWRPcHRpb25PZmZzZXQsIHNjcm9sbEJ1ZmZlciwgbWF4U2Nyb2xsKTtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldFkgPSB0aGlzLl9jYWxjdWxhdGVPdmVybGF5T2Zmc2V0WShzZWxlY3RlZE9wdGlvbk9mZnNldCwgc2Nyb2xsQnVmZmVyLCBtYXhTY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLCB0aGUgcGFuZWwgY2VudGVycyBvbiB0aGUgZmlyc3Qgb3B0aW9uLiBJbiB0aGlzIGNhc2UsXG4gICAgICAgICAgICAvLyB3ZSBtdXN0IG9ubHkgYWRqdXN0IGZvciB0aGUgaGVpZ2h0IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgb3B0aW9uIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgdHJpZ2dlciBlbGVtZW50LCB0aGVuIG11bHRpcGx5IGl0IGJ5IC0xIHRvIGVuc3VyZSB0aGUgcGFuZWwgbW92ZXNcbiAgICAgICAgICAgIC8vIGluIHRoZSBjb3JyZWN0IGRpcmVjdGlvbiB1cCB0aGUgcGFnZS5cbiAgICAgICAgICAgIHRoaXMuX29mZnNldFkgPSAoU0VMRUNUX0lURU1fSEVJR0hUIC0gU0VMRUNUX1RSSUdHRVJfSEVJR0hUKSAvIDIgKiAtMSAtXG4gICAgICAgICAgICAgICAgKHRoaXMuX2dldExhYmVsQ291bnRCZWZvcmVPcHRpb24oMCkgKiBTRUxFQ1RfSVRFTV9IRUlHSFQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoZWNrT3ZlcmxheVdpdGhpblZpZXdwb3J0KG1heFNjcm9sbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHNlbGVjdCdzIG92ZXJsYXkgcGFuZWwuXG4gICAgICpcbiAgICAgKiBBdHRlbXB0cyB0byBjZW50ZXIgdGhlIHNlbGVjdGVkIG9wdGlvbiBpbiB0aGUgcGFuZWwuIElmIHRoZSBvcHRpb24gaXNcbiAgICAgKiB0b28gaGlnaCBvciB0b28gbG93IGluIHRoZSBwYW5lbCB0byBiZSBzY3JvbGxlZCB0byB0aGUgY2VudGVyLCBpdCBjbGFtcHMgdGhlXG4gICAgICogc2Nyb2xsIHBvc2l0aW9uIHRvIHRoZSBtaW4gb3IgbWF4IHNjcm9sbCBwb3NpdGlvbnMgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0ZWRJbmRleFxuICAgICAqIEBwYXJhbSB7P30gc2Nyb2xsQnVmZmVyXG4gICAgICogQHBhcmFtIHs/fSBtYXhTY3JvbGxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2FsY3VsYXRlT3ZlcmxheVNjcm9sbCA9IGZ1bmN0aW9uIChzZWxlY3RlZEluZGV4LCBzY3JvbGxCdWZmZXIsIG1heFNjcm9sbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25PZmZzZXRGcm9tU2Nyb2xsVG9wID0gU0VMRUNUX0lURU1fSEVJR0hUICogc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFsZk9wdGlvbkhlaWdodCA9IFNFTEVDVF9JVEVNX0hFSUdIVCAvIDI7XG4gICAgICAgIC8vIFN0YXJ0cyBhdCB0aGUgb3B0aW9uT2Zmc2V0RnJvbVNjcm9sbFRvcCwgd2hpY2ggc2Nyb2xscyB0aGUgb3B0aW9uIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgICAgIC8vIHNjcm9sbCBjb250YWluZXIsIHRoZW4gc3VidHJhY3RzIHRoZSBzY3JvbGwgYnVmZmVyIHRvIHNjcm9sbCB0aGUgb3B0aW9uIGRvd24gdG9cbiAgICAgICAgLy8gdGhlIGNlbnRlciBvZiB0aGUgb3ZlcmxheSBwYW5lbC4gSGFsZiB0aGUgb3B0aW9uIGhlaWdodCBtdXN0IGJlIHJlLWFkZGVkIHRvIHRoZVxuICAgICAgICAvLyBzY3JvbGxUb3Agc28gdGhlIG9wdGlvbiBpcyBjZW50ZXJlZCBiYXNlZCBvbiBpdHMgbWlkZGxlLCBub3QgaXRzIHRvcCBlZGdlLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpbWFsU2Nyb2xsUG9zaXRpb24gPSBvcHRpb25PZmZzZXRGcm9tU2Nyb2xsVG9wIC0gc2Nyb2xsQnVmZmVyICsgaGFsZk9wdGlvbkhlaWdodDtcbiAgICAgICAgcmV0dXJuIGNsYW1wVmFsdWUoMCwgb3B0aW1hbFNjcm9sbFBvc2l0aW9uLCBtYXhTY3JvbGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmlndXJlcyBvdXQgdGhlIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiBzdGF0ZSBmb3IgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9nZXRQbGFjZWhvbGRlckFuaW1hdGlvblN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5mbG9hdFBsYWNlaG9sZGVyID09PSAnbmV2ZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmxvYXRQbGFjZWhvbGRlciA9PT0gJ2Fsd2F5cycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXJTdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIENTUyBgb3BhY2l0eWAgb2YgdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2dldFBsYWNlaG9sZGVyT3BhY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsb2F0UGxhY2Vob2xkZXIgIT09ICduZXZlcicgfHwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpKSA/XG4gICAgICAgICAgICAnMScgOiAnMCc7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcIl9hcmlhTGFiZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgYXJpYS1sYWJlbCBvZiB0aGUgc2VsZWN0IGNvbXBvbmVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSWYgYW4gYXJpYUxhYmVsbGVkYnkgdmFsdWUgaGFzIGJlZW4gc2V0LCB0aGUgc2VsZWN0IHNob3VsZCBub3Qgb3ZlcndyaXRlIHRoZVxuICAgICAgICAgICAgLy8gYGFyaWEtbGFiZWxsZWRieWAgdmFsdWUgYnkgc2V0dGluZyB0aGUgYXJpYUxhYmVsIHRvIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyaWFMYWJlbGxlZGJ5ID8gbnVsbCA6IHRoaXMuYXJpYUxhYmVsIHx8IHRoaXMucGxhY2Vob2xkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHgtb2Zmc2V0IG9mIHRoZSBvdmVybGF5IHBhbmVsIGluIHJlbGF0aW9uIHRvIHRoZSB0cmlnZ2VyJ3MgdG9wIHN0YXJ0IGNvcm5lci5cbiAgICAgKiBUaGlzIG11c3QgYmUgYWRqdXN0ZWQgdG8gYWxpZ24gdGhlIHNlbGVjdGVkIG9wdGlvbiB0ZXh0IG92ZXIgdGhlIHRyaWdnZXIgdGV4dCB3aGVuXG4gICAgICogdGhlIHBhbmVsIG9wZW5zLiBXaWxsIGNoYW5nZSBiYXNlZCBvbiBMVFIgb3IgUlRMIHRleHQgZGlyZWN0aW9uLiBOb3RlIHRoYXQgdGhlIG9mZnNldFxuICAgICAqIGNhbid0IGJlIGNhbGN1bGF0ZWQgdW50aWwgdGhlIHBhbmVsIGhhcyBiZWVuIGF0dGFjaGVkLCBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyB0aGVcbiAgICAgKiBjb250ZW50IHdpZHRoIGluIG9yZGVyIHRvIGNvbnN0cmFpbiB0aGUgcGFuZWwgd2l0aGluIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2FsY3VsYXRlT3ZlcmxheU9mZnNldFggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlSZWN0ID0gdGhpcy5vdmVybGF5RGlyLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdwb3J0UmVjdCA9IHRoaXMuX3ZpZXdwb3J0UnVsZXIuZ2V0Vmlld3BvcnRSZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzUnRsID0gdGhpcy5faXNSdGwoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFkZGluZ1dpZHRoID0gdGhpcy5tdWx0aXBsZSA/IFNFTEVDVF9NVUxUSVBMRV9QQU5FTF9QQURESU5HX1ggKyBTRUxFQ1RfUEFORUxfUEFERElOR19YIDpcbiAgICAgICAgICAgIFNFTEVDVF9QQU5FTF9QQURESU5HX1ggKiAyO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXRYO1xuICAgICAgICAvLyBBZGp1c3QgdGhlIG9mZnNldCwgZGVwZW5kaW5nIG9uIHRoZSBvcHRpb24gcGFkZGluZy5cbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIG9mZnNldFggPSBTRUxFQ1RfTVVMVElQTEVfUEFORUxfUEFERElOR19YO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZFswXSB8fCB0aGlzLm9wdGlvbnMuZmlyc3Q7XG4gICAgICAgICAgICBvZmZzZXRYID0gc2VsZWN0ZWQgJiYgc2VsZWN0ZWQuZ3JvdXAgPyBTRUxFQ1RfUEFORUxfSU5ERU5UX1BBRERJTkdfWCA6IFNFTEVDVF9QQU5FTF9QQURESU5HX1g7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52ZXJ0IHRoZSBvZmZzZXQgaW4gTFRSLlxuICAgICAgICBpZiAoIWlzUnRsKSB7XG4gICAgICAgICAgICBvZmZzZXRYICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIERldGVybWluZSBob3cgbXVjaCB0aGUgc2VsZWN0IG92ZXJmbG93cyBvbiBlYWNoIHNpZGUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlZnRPdmVyZmxvdyA9IDAgLSAob3ZlcmxheVJlY3QubGVmdCArIG9mZnNldFggLSAoaXNSdGwgPyBwYWRkaW5nV2lkdGggOiAwKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0T3ZlcmZsb3cgPSBvdmVybGF5UmVjdC5yaWdodCArIG9mZnNldFggLSB2aWV3cG9ydFJlY3Qud2lkdGhcbiAgICAgICAgICAgICsgKGlzUnRsID8gMCA6IHBhZGRpbmdXaWR0aCk7XG4gICAgICAgIC8vIElmIHRoZSBlbGVtZW50IG92ZXJmbG93cyBvbiBlaXRoZXIgc2lkZSwgcmVkdWNlIHRoZSBvZmZzZXQgdG8gYWxsb3cgaXQgdG8gZml0LlxuICAgICAgICBpZiAobGVmdE92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgb2Zmc2V0WCArPSBsZWZ0T3ZlcmZsb3cgKyBTRUxFQ1RfUEFORUxfVklFV1BPUlRfUEFERElORztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyaWdodE92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgb2Zmc2V0WCAtPSByaWdodE92ZXJmbG93ICsgU0VMRUNUX1BBTkVMX1ZJRVdQT1JUX1BBRERJTkc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBvZmZzZXQgZGlyZWN0bHkgaW4gb3JkZXIgdG8gYXZvaWQgaGF2aW5nIHRvIGdvIHRocm91Z2ggY2hhbmdlIGRldGVjdGlvbiBhbmRcbiAgICAgICAgLy8gcG90ZW50aWFsbHkgdHJpZ2dlcmluZyBcImNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWRcIiBlcnJvcnMuXG4gICAgICAgIHRoaXMub3ZlcmxheURpci5vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICAgICAgdGhpcy5vdmVybGF5RGlyLm92ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHktb2Zmc2V0IG9mIHRoZSBzZWxlY3QncyBvdmVybGF5IHBhbmVsIGluIHJlbGF0aW9uIHRvIHRoZVxuICAgICAqIHRvcCBzdGFydCBjb3JuZXIgb2YgdGhlIHRyaWdnZXIuIEl0IGhhcyB0byBiZSBhZGp1c3RlZCBpbiBvcmRlciBmb3IgdGhlXG4gICAgICogc2VsZWN0ZWQgb3B0aW9uIHRvIGJlIGFsaWduZWQgb3ZlciB0aGUgdHJpZ2dlciB3aGVuIHRoZSBwYW5lbCBvcGVucy5cbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdGVkSW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHNjcm9sbEJ1ZmZlclxuICAgICAqIEBwYXJhbSB7P30gbWF4U2Nyb2xsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2NhbGN1bGF0ZU92ZXJsYXlPZmZzZXRZID0gZnVuY3Rpb24gKHNlbGVjdGVkSW5kZXgsIHNjcm9sbEJ1ZmZlciwgbWF4U2Nyb2xsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbk9mZnNldEZyb21QYW5lbFRvcDtcbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICAgICAgb3B0aW9uT2Zmc2V0RnJvbVBhbmVsVG9wID0gc2VsZWN0ZWRJbmRleCAqIFNFTEVDVF9JVEVNX0hFSUdIVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zY3JvbGxUb3AgPT09IG1heFNjcm9sbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlyc3REaXNwbGF5ZWRJbmRleCA9IHRoaXMuX2dldEl0ZW1Db3VudCgpIC0gU0VMRUNUX01BWF9PUFRJT05TX0RJU1BMQVlFRDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdGVkRGlzcGxheUluZGV4ID0gc2VsZWN0ZWRJbmRleCAtIGZpcnN0RGlzcGxheWVkSW5kZXg7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBwYW5lbCBoZWlnaHQgaXMgbG9uZ2VyIHRoYW4gdGhlIGhlaWdodCBvZiB0aGUgb3B0aW9ucyBhbG9uZSxcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFsd2F5cyBleHRyYSBwYWRkaW5nIGF0IHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSBwYW5lbC4gV2hlblxuICAgICAgICAgICAgLy8gc2Nyb2xsZWQgdG8gdGhlIHZlcnkgYm90dG9tLCB0aGlzIHBhZGRpbmcgaXMgYXQgdGhlIHRvcCBvZiB0aGUgcGFuZWwgYW5kXG4gICAgICAgICAgICAvLyBtdXN0IGJlIGFkZGVkIHRvIHRoZSBvZmZzZXQuXG4gICAgICAgICAgICBvcHRpb25PZmZzZXRGcm9tUGFuZWxUb3AgPVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGlzcGxheUluZGV4ICogU0VMRUNUX0lURU1fSEVJR0hUICsgU0VMRUNUX1BBTkVMX1BBRERJTkdfWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvcHRpb24gd2FzIHNjcm9sbGVkIHRvIHRoZSBtaWRkbGUgb2YgdGhlIHBhbmVsIHVzaW5nIGEgc2Nyb2xsIGJ1ZmZlcixcbiAgICAgICAgICAgIC8vIGl0cyBvZmZzZXQgd2lsbCBiZSB0aGUgc2Nyb2xsIGJ1ZmZlciBtaW51cyB0aGUgaGFsZiBoZWlnaHQgdGhhdCB3YXMgYWRkZWQgdG9cbiAgICAgICAgICAgIC8vIGNlbnRlciBpdC5cbiAgICAgICAgICAgIG9wdGlvbk9mZnNldEZyb21QYW5lbFRvcCA9IHNjcm9sbEJ1ZmZlciAtIFNFTEVDVF9JVEVNX0hFSUdIVCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGZpbmFsIG9mZnNldCBpcyB0aGUgb3B0aW9uJ3Mgb2Zmc2V0IGZyb20gdGhlIHRvcCwgYWRqdXN0ZWQgZm9yIHRoZSBoZWlnaHRcbiAgICAgICAgLy8gZGlmZmVyZW5jZSwgbXVsdGlwbGllZCBieSAtMSB0byBlbnN1cmUgdGhhdCB0aGUgb3ZlcmxheSBtb3ZlcyBpbiB0aGUgY29ycmVjdFxuICAgICAgICAvLyBkaXJlY3Rpb24gdXAgdGhlIHBhZ2UuXG4gICAgICAgIHJldHVybiBvcHRpb25PZmZzZXRGcm9tUGFuZWxUb3AgKiAtMSAtIFNFTEVDVF9PUFRJT05fSEVJR0hUX0FESlVTVE1FTlQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhhdCB0aGUgYXR0ZW1wdGVkIG92ZXJsYXkgcG9zaXRpb24gd2lsbCBmaXQgd2l0aGluIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBJZiBpdCB3aWxsIG5vdCBmaXQsIHRyaWVzIHRvIGFkanVzdCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFuZCB0aGUgYXNzb2NpYXRlZFxuICAgICAqIHktb2Zmc2V0IHNvIHRoZSBwYW5lbCBjYW4gb3BlbiBmdWxseSBvbi1zY3JlZW4uIElmIGl0IHN0aWxsIHdvbid0IGZpdCxcbiAgICAgKiBzZXRzIHRoZSBvZmZzZXQgYmFjayB0byAwIHRvIGFsbG93IHRoZSBmYWxsYmFjayBwb3NpdGlvbiB0byB0YWtlIG92ZXIuXG4gICAgICogQHBhcmFtIHs/fSBtYXhTY3JvbGxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2hlY2tPdmVybGF5V2l0aGluVmlld3BvcnQgPSBmdW5jdGlvbiAobWF4U2Nyb2xsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdwb3J0UmVjdCA9IHRoaXMuX3ZpZXdwb3J0UnVsZXIuZ2V0Vmlld3BvcnRSZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJSZWN0ID0gdGhpcy5fZ2V0VHJpZ2dlclJlY3QoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9wU3BhY2VBdmFpbGFibGUgPSB0cmlnZ2VyUmVjdC50b3AgLSBTRUxFQ1RfUEFORUxfVklFV1BPUlRfUEFERElORztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm90dG9tU3BhY2VBdmFpbGFibGUgPSB2aWV3cG9ydFJlY3QuaGVpZ2h0IC0gdHJpZ2dlclJlY3QuYm90dG9tIC0gU0VMRUNUX1BBTkVMX1ZJRVdQT1JUX1BBRERJTkc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhbmVsSGVpZ2h0VG9wID0gTWF0aC5hYnModGhpcy5fb2Zmc2V0WSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvdGFsUGFuZWxIZWlnaHQgPSBNYXRoLm1pbih0aGlzLl9nZXRJdGVtQ291bnQoKSAqIFNFTEVDVF9JVEVNX0hFSUdIVCwgU0VMRUNUX1BBTkVMX01BWF9IRUlHSFQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYW5lbEhlaWdodEJvdHRvbSA9IHRvdGFsUGFuZWxIZWlnaHQgLSBwYW5lbEhlaWdodFRvcCAtIHRyaWdnZXJSZWN0LmhlaWdodDtcbiAgICAgICAgaWYgKHBhbmVsSGVpZ2h0Qm90dG9tID4gYm90dG9tU3BhY2VBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkanVzdFBhbmVsVXAocGFuZWxIZWlnaHRCb3R0b20sIGJvdHRvbVNwYWNlQXZhaWxhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYW5lbEhlaWdodFRvcCA+IHRvcFNwYWNlQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGp1c3RQYW5lbERvd24ocGFuZWxIZWlnaHRUb3AsIHRvcFNwYWNlQXZhaWxhYmxlLCBtYXhTY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luQmFzZWRPbk9wdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSBvdmVybGF5IHBhbmVsIHVwIHRvIGZpdCBpbiB0aGUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIHs/fSBwYW5lbEhlaWdodEJvdHRvbVxuICAgICAqIEBwYXJhbSB7P30gYm90dG9tU3BhY2VBdmFpbGFibGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fYWRqdXN0UGFuZWxVcCA9IGZ1bmN0aW9uIChwYW5lbEhlaWdodEJvdHRvbSwgYm90dG9tU3BhY2VBdmFpbGFibGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlzdGFuY2VCZWxvd1ZpZXdwb3J0ID0gcGFuZWxIZWlnaHRCb3R0b20gLSBib3R0b21TcGFjZUF2YWlsYWJsZTtcbiAgICAgICAgLy8gU2Nyb2xscyB0aGUgcGFuZWwgdXAgYnkgdGhlIGRpc3RhbmNlIGl0IHdhcyBleHRlbmRpbmcgcGFzdCB0aGUgYm91bmRhcnksIHRoZW5cbiAgICAgICAgLy8gYWRqdXN0cyB0aGUgb2Zmc2V0IGJ5IHRoYXQgYW1vdW50IHRvIG1vdmUgdGhlIHBhbmVsIHVwIGludG8gdGhlIHZpZXdwb3J0LlxuICAgICAgICB0aGlzLl9zY3JvbGxUb3AgLT0gZGlzdGFuY2VCZWxvd1ZpZXdwb3J0O1xuICAgICAgICB0aGlzLl9vZmZzZXRZIC09IGRpc3RhbmNlQmVsb3dWaWV3cG9ydDtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luQmFzZWRPbk9wdGlvbigpO1xuICAgICAgICAvLyBJZiB0aGUgcGFuZWwgaXMgc2Nyb2xsZWQgdG8gdGhlIHZlcnkgdG9wLCBpdCB3b24ndCBiZSBhYmxlIHRvIGZpdCB0aGUgcGFuZWxcbiAgICAgICAgLy8gYnkgc2Nyb2xsaW5nLCBzbyBzZXQgdGhlIG9mZnNldCB0byAwIHRvIGFsbG93IHRoZSBmYWxsYmFjayBwb3NpdGlvbiB0byB0YWtlXG4gICAgICAgIC8vIGVmZmVjdC5cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFRvcCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSBcIjUwJSBib3R0b20gMHB4XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIG92ZXJsYXkgcGFuZWwgZG93biB0byBmaXQgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxIZWlnaHRUb3BcbiAgICAgKiBAcGFyYW0gez99IHRvcFNwYWNlQXZhaWxhYmxlXG4gICAgICogQHBhcmFtIHs/fSBtYXhTY3JvbGxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fYWRqdXN0UGFuZWxEb3duID0gZnVuY3Rpb24gKHBhbmVsSGVpZ2h0VG9wLCB0b3BTcGFjZUF2YWlsYWJsZSwgbWF4U2Nyb2xsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpc3RhbmNlQWJvdmVWaWV3cG9ydCA9IHBhbmVsSGVpZ2h0VG9wIC0gdG9wU3BhY2VBdmFpbGFibGU7XG4gICAgICAgIC8vIFNjcm9sbHMgdGhlIHBhbmVsIGRvd24gYnkgdGhlIGRpc3RhbmNlIGl0IHdhcyBleHRlbmRpbmcgcGFzdCB0aGUgYm91bmRhcnksIHRoZW5cbiAgICAgICAgLy8gYWRqdXN0cyB0aGUgb2Zmc2V0IGJ5IHRoYXQgYW1vdW50IHRvIG1vdmUgdGhlIHBhbmVsIGRvd24gaW50byB0aGUgdmlld3BvcnQuXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvcCArPSBkaXN0YW5jZUFib3ZlVmlld3BvcnQ7XG4gICAgICAgIHRoaXMuX29mZnNldFkgKz0gZGlzdGFuY2VBYm92ZVZpZXdwb3J0O1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW5CYXNlZE9uT3B0aW9uKCk7XG4gICAgICAgIC8vIElmIHRoZSBwYW5lbCBpcyBzY3JvbGxlZCB0byB0aGUgdmVyeSBib3R0b20sIGl0IHdvbid0IGJlIGFibGUgdG8gZml0IHRoZVxuICAgICAgICAvLyBwYW5lbCBieSBzY3JvbGxpbmcsIHNvIHNldCB0aGUgb2Zmc2V0IHRvIDAgdG8gYWxsb3cgdGhlIGZhbGxiYWNrIHBvc2l0aW9uXG4gICAgICAgIC8vIHRvIHRha2UgZWZmZWN0LlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsVG9wID49IG1heFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9wID0gbWF4U2Nyb2xsO1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSBcIjUwJSB0b3AgMHB4XCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRyYW5zZm9ybSBvcmlnaW4gcG9pbnQgYmFzZWQgb24gdGhlIHNlbGVjdGVkIG9wdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZ2V0T3JpZ2luQmFzZWRPbk9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luWSA9IE1hdGguYWJzKHRoaXMuX29mZnNldFkpIC0gU0VMRUNUX09QVElPTl9IRUlHSFRfQURKVVNUTUVOVCArIFNFTEVDVF9JVEVNX0hFSUdIVCAvIDI7XG4gICAgICAgIHJldHVybiBcIjUwJSBcIiArIG9yaWdpblkgKyBcInB4IDBweFwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmlndXJlcyBvdXQgdGhlIGZsb2F0aW5nIHBsYWNlaG9sZGVyIHN0YXRlIHZhbHVlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9mbG9hdFBsYWNlaG9sZGVyU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1J0bCgpID8gJ2Zsb2F0aW5nLXJ0bCcgOiAnZmxvYXRpbmctbHRyJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIHVzZXIgcHJlc3NpbmcgdGhlIGFycm93IGtleXMgb24gYSBjbG9zZWQgc2VsZWN0LlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5faGFuZGxlQXJyb3dLZXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX211bHRpcGxlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2QWN0aXZlSXRlbSA9IHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbTtcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRob3VnaCB0aGUgc2VsZWN0IG9wdGlvbnMgZXZlbiB3aGVuIHRoZSBzZWxlY3QgaXMgY2xvc2VkLFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgdGhlIGJlaGF2aW9yIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGVsZW1lbnQuXG4gICAgICAgICAgICAvLyBUT0RPKGNyaXNiZXRvKTogbmF0aXZlIHNlbGVjdHMgYWxzbyBjeWNsZSB0aHJvdWdoIHRoZSBvcHRpb25zIHdpdGggbGVmdC9yaWdodCBhcnJvd3MsXG4gICAgICAgICAgICAvLyBob3dldmVyIHRoZSBrZXkgbWFuYWdlciBvbmx5IHN1cHBvcnRzIHVwL2Rvd24gYXQgdGhlIG1vbWVudC5cbiAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRBY3RpdmVJdGVtID0gKHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEFjdGl2ZUl0ZW0gIT09IHByZXZBY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb25CeVZhbHVlKGN1cnJlbnRBY3RpdmVJdGVtLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wYWdhdGVDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFtb3VudCBvZiBpdGVtcyBpbiB0aGUgc2VsZWN0LiBUaGlzIGluY2x1ZGVzIG9wdGlvbnMgYW5kIGdyb3VwIGxhYmVscy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZ2V0SXRlbUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxlbmd0aCArIHRoaXMub3B0aW9uR3JvdXBzLmxlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFtb3VudCBvZiBvcHRpb24gZ3JvdXAgbGFiZWxzIHRoYXQgcHJlY2VkZSB0aGUgc3BlY2lmaWVkIG9wdGlvbi5cbiAgICAgKiBVc2VmdWwgd2hlbiBwb3NpdGlvbmluZyB0aGUgcGFuZWwsIGJlY2F1c2UgdGhlIGxhYmVscyB3aWxsIG9mZnNldCB0aGUgaW5kZXggb2YgdGhlXG4gICAgICogY3VycmVudGx5LXNlbGVjdGVkIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbkluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2dldExhYmVsQ291bnRCZWZvcmVPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uSW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uR3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9IHRoaXMub3B0aW9ucy50b0FycmF5KCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBncm91cHMgPSB0aGlzLm9wdGlvbkdyb3Vwcy50b0FycmF5KCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBncm91cENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IG9wdGlvbkluZGV4ICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbaV0uZ3JvdXAgJiYgb3B0aW9uc1tpXS5ncm91cCA9PT0gZ3JvdXBzW2dyb3VwQ291bnRlcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwQ291bnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIHJldHVybiBNZFNlbGVjdDtcbn0oX01kU2VsZWN0TWl4aW5CYXNlKSk7XG5NZFNlbGVjdC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLXNlbGVjdCwgbWF0LXNlbGVjdCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXNlbGVjdC10cmlnZ2VyXFxcIiBjZGstb3ZlcmxheS1vcmlnaW4gKGNsaWNrKT1cXFwidG9nZ2xlKClcXFwiICNvcmlnaW49XFxcImNka092ZXJsYXlPcmlnaW5cXFwiICN0cmlnZ2VyPjxzcGFuIGNsYXNzPVxcXCJtYXQtc2VsZWN0LXBsYWNlaG9sZGVyXFxcIiBbY2xhc3MubWF0LWZsb2F0aW5nLXBsYWNlaG9sZGVyXT1cXFwiX3NlbGVjdGlvbk1vZGVsLmhhc1ZhbHVlKClcXFwiIFtAdHJhbnNmb3JtUGxhY2Vob2xkZXJdPVxcXCJfZ2V0UGxhY2Vob2xkZXJBbmltYXRpb25TdGF0ZSgpXFxcIiBbc3R5bGUub3BhY2l0eV09XFxcIl9nZXRQbGFjZWhvbGRlck9wYWNpdHkoKVxcXCIgW3N0eWxlLndpZHRoLnB4XT1cXFwiX3NlbGVjdGVkVmFsdWVXaWR0aFxcXCI+e3sgcGxhY2Vob2xkZXIgfX0gPC9zcGFuPjxzcGFuIGNsYXNzPVxcXCJtYXQtc2VsZWN0LXZhbHVlXFxcIiAqbmdJZj1cXFwiX3NlbGVjdGlvbk1vZGVsLmhhc1ZhbHVlKClcXFwiPjxzcGFuIGNsYXNzPVxcXCJtYXQtc2VsZWN0LXZhbHVlLXRleHRcXFwiPnt7IHRyaWdnZXJWYWx1ZSB9fTwvc3Bhbj4gPC9zcGFuPjxzcGFuIGNsYXNzPVxcXCJtYXQtc2VsZWN0LWFycm93XFxcIj48L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJtYXQtc2VsZWN0LXVuZGVybGluZVxcXCI+PC9zcGFuPjwvZGl2PjxuZy10ZW1wbGF0ZSBjZGstY29ubmVjdGVkLW92ZXJsYXkgaGFzQmFja2Ryb3AgYmFja2Ryb3BDbGFzcz1cXFwiY2RrLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3BcXFwiIFtvcmlnaW5dPVxcXCJvcmlnaW5cXFwiIFtvcGVuXT1cXFwicGFuZWxPcGVuXFxcIiBbcG9zaXRpb25zXT1cXFwiX3Bvc2l0aW9uc1xcXCIgW21pbldpZHRoXT1cXFwiX3RyaWdnZXJXaWR0aFxcXCIgW29mZnNldFldPVxcXCJfb2Zmc2V0WVxcXCIgKGJhY2tkcm9wQ2xpY2spPVxcXCJjbG9zZSgpXFxcIiAoYXR0YWNoKT1cXFwiX29uQXR0YWNoZWQoKVxcXCIgKGRldGFjaCk9XFxcImNsb3NlKClcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1zZWxlY3QtcGFuZWwge3sgJ21hdC0nICsgY29sb3IgfX1cXFwiIFtuZ0NsYXNzXT1cXFwicGFuZWxDbGFzc1xcXCIgW0B0cmFuc2Zvcm1QYW5lbF09XFxcIm11bHRpcGxlID8gJ3Nob3dpbmctbXVsdGlwbGUnIDogJ3Nob3dpbmcnXFxcIiAoQHRyYW5zZm9ybVBhbmVsLmRvbmUpPVxcXCJfb25QYW5lbERvbmUoKVxcXCIgKGtleWRvd24pPVxcXCJfaGFuZGxlUGFuZWxLZXlkb3duKCRldmVudClcXFwiIFtzdHlsZS50cmFuc2Zvcm1PcmlnaW5dPVxcXCJfdHJhbnNmb3JtT3JpZ2luXFxcIiBbY2xhc3MubWF0LXNlbGVjdC1wYW5lbC1kb25lLWFuaW1hdGluZ109XFxcIl9wYW5lbERvbmVBbmltYXRpbmdcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1zZWxlY3QtY29udGVudFxcXCIgW0BmYWRlSW5Db250ZW50XT1cXFwiJ3Nob3dpbmcnXFxcIiAoQGZhZGVJbkNvbnRlbnQuZG9uZSk9XFxcIl9vbkZhZGVJbkRvbmUoKVxcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGl2PjwvZGl2PjwvbmctdGVtcGxhdGU+XCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXNlbGVjdHtkaXNwbGF5OmlubGluZS1ibG9jaztvdXRsaW5lOjB9Lm1hdC1zZWxlY3QtdHJpZ2dlcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2hlaWdodDozMHB4O21pbi13aWR0aDoxMTJweDtjdXJzb3I6cG9pbnRlcjtwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmJvcmRlci1ib3h9W2FyaWEtZGlzYWJsZWQ9dHJ1ZV0gLm1hdC1zZWxlY3QtdHJpZ2dlcnstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7Y3Vyc29yOmRlZmF1bHR9Lm1hdC1zZWxlY3QtdW5kZXJsaW5le3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO2xlZnQ6MDtyaWdodDowO2hlaWdodDoxcHh9W2FyaWEtZGlzYWJsZWQ9dHJ1ZV0gLm1hdC1zZWxlY3QtdW5kZXJsaW5le2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMCwwLDAsLjI2KSAwLHJnYmEoMCwwLDAsLjI2KSAzMyUsdHJhbnNwYXJlbnQgMCk7YmFja2dyb3VuZC1zaXplOjRweCAxcHg7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgYm90dG9tfS5tYXQtc2VsZWN0LXBsYWNlaG9sZGVye3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6MCAycHg7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IHRvcDtmbGV4LWdyb3c6MX0ubWF0LXNlbGVjdC1wbGFjZWhvbGRlci5tYXQtZmxvYXRpbmctcGxhY2Vob2xkZXJ7dG9wOi0yMnB4O2xlZnQ6LTJweDt0ZXh0LWFsaWduOmxlZnQ7dHJhbnNmb3JtOnNjYWxlKC43NSl9W2Rpcj1ydGxdIC5tYXQtc2VsZWN0LXBsYWNlaG9sZGVye3RyYW5zZm9ybS1vcmlnaW46cmlnaHQgdG9wfVtkaXI9cnRsXSAubWF0LXNlbGVjdC1wbGFjZWhvbGRlci5tYXQtZmxvYXRpbmctcGxhY2Vob2xkZXJ7bGVmdDoycHg7dGV4dC1hbGlnbjpyaWdodH1bYXJpYS1yZXF1aXJlZD10cnVlXSAubWF0LXNlbGVjdC1wbGFjZWhvbGRlcjo6YWZ0ZXJ7Y29udGVudDonKid9Lm1hdC1zZWxlY3QtdmFsdWV7cG9zaXRpb246YWJzb2x1dGU7bWF4LXdpZHRoOmNhbGMoMTAwJSAtIDE4cHgpO2ZsZXgtZ3JvdzoxO3RvcDowO2xlZnQ6MDtib3R0b206MDtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyfVtkaXI9cnRsXSAubWF0LXNlbGVjdC12YWx1ZXtsZWZ0OmF1dG87cmlnaHQ6MH0ubWF0LXNlbGVjdC12YWx1ZS10ZXh0e3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpcztsaW5lLWhlaWdodDozMHB4fS5tYXQtc2VsZWN0LWFycm93e3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyLWxlZnQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcDo1cHggc29saWQ7bWFyZ2luOjAgNHB4fS5tYXQtc2VsZWN0LXBhbmVse2JveC1zaGFkb3c6MCA1cHggNXB4IC0zcHggcmdiYSgwLDAsMCwuMiksMCA4cHggMTBweCAxcHggcmdiYSgwLDAsMCwuMTQpLDAgM3B4IDE0cHggMnB4IHJnYmEoMCwwLDAsLjEyKTttaW4td2lkdGg6MTEycHg7bWF4LXdpZHRoOjI4MHB4O292ZXJmbG93OmF1dG87LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7cGFkZGluZy10b3A6MDtwYWRkaW5nLWJvdHRvbTowO21heC1oZWlnaHQ6MjU2cHg7bWluLXdpZHRoOjEwMCV9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC1zZWxlY3QtcGFuZWx7b3V0bGluZTpzb2xpZCAxcHh9fVwiXSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sb3InLCAnZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnbGlzdGJveCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci50YWJpbmRleF0nOiAndGFiSW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1sYWJlbF0nOiAnX2FyaWFMYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWxhYmVsbGVkYnldJzogJ2FyaWFMYWJlbGxlZGJ5JyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtcmVxdWlyZWRdJzogJ3JlcXVpcmVkLnRvU3RyaW5nKCknLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQudG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWludmFsaWRdJzogJ19jb250cm9sPy5pbnZhbGlkIHx8IFwiZmFsc2VcIicsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLW93bnNdJzogJ19vcHRpb25JZHMnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zZWxlY3QtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1zZWxlY3QnLFxuICAgICAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVDbG9zZWRLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ19vbkJsdXIoKScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1QYW5lbCxcbiAgICAgICAgICAgICAgICAgICAgZmFkZUluQ29udGVudFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtZFNlbGVjdCcsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU2VsZWN0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVmlld3BvcnRSdWxlciwgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmLCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IERpcmVjdGlvbmFsaXR5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogU2VsZiB9LCB7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBBdHRyaWJ1dGUsIGFyZ3M6IFsndGFiaW5kZXgnLF0gfSxdIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTURfUExBQ0VIT0xERVJfR0xPQkFMX09QVElPTlMsXSB9LF0gfSxcbl07IH07XG5NZFNlbGVjdC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAndHJpZ2dlcic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWyd0cmlnZ2VyJyxdIH0sXSxcbiAgICAnb3ZlcmxheURpcic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW0Nvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUsXSB9LF0sXG4gICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtNZE9wdGlvbiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9LF0gfSxdLFxuICAgICdvcHRpb25Hcm91cHMnOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtNZE9wdGdyb3VwLF0gfSxdLFxuICAgICdwYW5lbENsYXNzJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdwbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAncmVxdWlyZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ211bHRpcGxlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdmbG9hdFBsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd0YWJJbmRleCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnYXJpYUxhYmVsJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnYXJpYS1sYWJlbCcsXSB9LF0sXG4gICAgJ2FyaWFMYWJlbGxlZGJ5JzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnYXJpYS1sYWJlbGxlZGJ5JyxdIH0sXSxcbiAgICAnb25PcGVuJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnb25DbG9zZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBDbGFtcHMgYSB2YWx1ZSBuIGJldHdlZW4gbWluIGFuZCBtYXggdmFsdWVzLlxuICogQHBhcmFtIHs/fSBtaW5cbiAqIEBwYXJhbSB7P30gblxuICogQHBhcmFtIHs/fSBtYXhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNsYW1wVmFsdWUobWluLCBuLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBuKSwgbWF4KTtcbn1cbnZhciBNZFNlbGVjdE1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2VsZWN0TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRTZWxlY3RNb2R1bGU7XG59KCkpO1xuTWRTZWxlY3RNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBPdmVybGF5TW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZE9wdGlvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRTZWxlY3QsIE1kT3B0aW9uTW9kdWxlLCBNZENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRTZWxlY3RdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNlbGVjdE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIE1EX1NMSURFX1RPR0dMRV9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZFNsaWRlVG9nZ2xlOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBNZFNsaWRlVG9nZ2xlQ2hhbmdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZVRvZ2dsZUNoYW5nZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kU2xpZGVUb2dnbGVDaGFuZ2U7XG59KCkpO1xuLy8gSW5jcmVhc2luZyBpbnRlZ2VyIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBpZHMgZm9yIHNsaWRlLXRvZ2dsZSBjb21wb25lbnRzLlxudmFyIG5leHRJZCQxID0gMDtcbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFNsaWRlVG9nZ2xlQmFzZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kU2xpZGVUb2dnbGVCYXNlKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG4gICAgcmV0dXJuIE1kU2xpZGVUb2dnbGVCYXNlO1xufSgpKTtcbnZhciBfTWRTbGlkZVRvZ2dsZU1peGluQmFzZSA9IG1peGluQ29sb3IobWl4aW5EaXNhYmxlZChNZFNsaWRlVG9nZ2xlQmFzZSksICdhY2NlbnQnKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHNsaWRhYmxlIFwic3dpdGNoXCIgdG9nZ2xlIHRoYXQgY2FuIGJlIG1vdmVkIGJldHdlZW4gb24gYW5kIG9mZi5cbiAqL1xudmFyIE1kU2xpZGVUb2dnbGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFNsaWRlVG9nZ2xlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9wbGF0Zm9ybVxuICAgICAqIEBwYXJhbSB7P30gX2ZvY3VzT3JpZ2luTW9uaXRvclxuICAgICAqIEBwYXJhbSB7P30gX2NoYW5nZURldGVjdG9yUmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRTbGlkZVRvZ2dsZShlbGVtZW50UmVmLCByZW5kZXJlciwgX3BsYXRmb3JtLCBfZm9jdXNPcmlnaW5Nb25pdG9yLCBfY2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVuZGVyZXIsIGVsZW1lbnRSZWYpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9wbGF0Zm9ybSA9IF9wbGF0Zm9ybTtcbiAgICAgICAgX3RoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvciA9IF9mb2N1c09yaWdpbk1vbml0b3I7XG4gICAgICAgIF90aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICBfdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIF90aGlzLl91bmlxdWVJZCA9IFwibWQtc2xpZGUtdG9nZ2xlLVwiICsgKytuZXh0SWQkMTtcbiAgICAgICAgX3RoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3JlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9kaXNhYmxlUmlwcGxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIHZhbHVlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiBwcmVzZW50XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdW5pcXVlIGlkIGZvciB0aGUgc2xpZGUtdG9nZ2xlIGlucHV0LiBJZiBub25lIGlzIHN1cHBsaWVkLCBpdCB3aWxsIGJlIGF1dG8tZ2VuZXJhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaWQgPSBfdGhpcy5fdW5pcXVlSWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIHNwZWNpZnkgdGhlIHRhYkluZGV4IHZhbHVlIGZvciB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudGFiSW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbGFiZWwgc2hvdWxkIGFwcGVhciBhZnRlciBvciBiZWZvcmUgdGhlIHNsaWRlLXRvZ2dsZS4gRGVmYXVsdHMgdG8gJ2FmdGVyJ1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubGFiZWxQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIHNldCB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmFyaWFMYWJlbCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIHNldCB0aGUgYXJpYS1sYWJlbGxlZGJ5IGF0dHJpYnV0ZSBvbiB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYXJpYUxhYmVsbGVkYnkgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgd2lsbCBiZSBkaXNwYXRjaGVkIGVhY2ggdGltZSB0aGUgc2xpZGUtdG9nZ2xlIGNoYW5nZXMgaXRzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzbGlkZS10b2dnbGUgaXMgcmVxdWlyZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlcXVpcmVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fcmVxdWlyZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiZGlzYWJsZVJpcHBsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IGZvciB0aGlzIHNsaWRlLXRvZ2dsZSBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUgaWQgZm9yIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5pZCB8fCB0aGlzLl91bmlxdWVJZCkgKyBcIi1pbnB1dFwiOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc2xpZGVSZW5kZXJlciA9IG5ldyBTbGlkZVRvZ2dsZVJlbmRlcmVyKHRoaXMuX2VsZW1lbnRSZWYsIHRoaXMuX3BsYXRmb3JtKTtcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yXG4gICAgICAgICAgICAubW9uaXRvcih0aGlzLl9pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudCwgdGhpcy5fcmVuZGVyZXIsIGZhbHNlKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoZm9jdXNPcmlnaW4pIHsgcmV0dXJuIF90aGlzLl9vbklucHV0Rm9jdXNDaGFuZ2UoZm9jdXNPcmlnaW4pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvci5zdG9wTW9uaXRvcmluZyh0aGlzLl9pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgb25DaGFuZ2VFdmVudCBtZXRob2Qgd2lsbCBiZSBhbHNvIGNhbGxlZCBvbiBjbGljay5cbiAgICAgKiBUaGlzIGlzIGJlY2F1c2UgZXZlcnl0aGluZyBmb3IgdGhlIHNsaWRlLXRvZ2dsZSBpcyB3cmFwcGVkIGluc2lkZSBvZiBhIGxhYmVsLFxuICAgICAqIHdoaWNoIHRyaWdnZXJzIGEgb25DaGFuZ2UgZXZlbnQgb24gY2xpY2suXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBvbiB0aGUgY2hhbmdlIGV2ZW50LlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGNoYW5nZSBldmVudCwgZnJvbSB0aGUgaW5wdXQgZWxlbWVudCwgd2lsbCBidWJibGUgdXAgYW5kXG4gICAgICAgIC8vIGVtaXQgaXRzIGV2ZW50IG9iamVjdCB0byB0aGUgY29tcG9uZW50J3MgYGNoYW5nZWAgb3V0cHV0LlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gT25jZSBhIGRyYWcgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLCB3ZSBkbyBub3Qgd2FudCB0byB0b2dnbGUgdGhlIHNsaWRlLXRvZ2dsZSBvbiBhIGNsaWNrLlxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIXRoaXMuX3NsaWRlUmVuZGVyZXIuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICAvLyBFbWl0IG91ciBjdXN0b20gY2hhbmdlIGV2ZW50IGlmIHRoZSBuYXRpdmUgaW5wdXQgZW1pdHRlZCBvbmUuXG4gICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gb25seSBlbWl0IGl0LCBpZiB0aGUgbmF0aXZlIGlucHV0IHRyaWdnZXJlZCBvbmUsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCwgd2hlbiB0aGUgYGNoZWNrZWRgIHZhcmlhYmxlIGNoYW5nZXMgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uSW5wdXRDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHN0b3AgcHJvcGFnYXRpb24gZm9yIGNsaWNrIGV2ZW50cyBvbiB0aGUgdmlzdWFsIGhpZGRlbiBpbnB1dCBlbGVtZW50LlxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB3aGVuIGEgdXNlciBjbGlja3Mgb24gYSBsYWJlbCBlbGVtZW50LCBhIGdlbmVyYXRlZCBjbGljayBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGRpc3BhdGNoZWQgb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gU2luY2Ugd2UgYXJlIHVzaW5nIGEgbGFiZWwgZWxlbWVudCBhcyBvdXJcbiAgICAgICAgLy8gcm9vdCBjb250YWluZXIsIHRoZSBjbGljayBldmVudCBvbiB0aGUgYHNsaWRlLXRvZ2dsZWAgd2lsbCBiZSBleGVjdXRlZCB0d2ljZS5cbiAgICAgICAgLy8gVGhlIHJlYWwgY2xpY2sgZXZlbnQgd2lsbCBidWJibGUgdXAsIGFuZCB0aGUgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IGFsc28gdHJpZXMgdG8gYnViYmxlIHVwLlxuICAgICAgICAvLyBUaGlzIHdpbGwgbGVhZCB0byBtdWx0aXBsZSBjbGljayBldmVudHMuXG4gICAgICAgIC8vIFByZXZlbnRpbmcgYnViYmxpbmcgZm9yIHRoZSBzZWNvbmQgZXZlbnQgd2lsbCBzb2x2ZSB0aGF0IGlzc3VlLlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBhIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBpc0Rpc2FibGVkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgc2xpZGUtdG9nZ2xlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvci5mb2N1c1ZpYSh0aGlzLl9pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2tleWJvYXJkJyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzbGlkZS10b2dnbGUgaXMgY2hlY2tlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLl9jaGVja2VkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQgIT09ICEhdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLl9jaGVja2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgY2hlY2tlZCBzdGF0ZSBvZiB0aGUgc2xpZGUtdG9nZ2xlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBmb2N1cyBjaGFuZ2VzIGZvciB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IGZvY3VzT3JpZ2luXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fb25JbnB1dEZvY3VzQ2hhbmdlID0gZnVuY3Rpb24gKGZvY3VzT3JpZ2luKSB7XG4gICAgICAgIGlmICghdGhpcy5fZm9jdXNSaXBwbGUgJiYgZm9jdXNPcmlnaW4gPT09ICdrZXlib2FyZCcpIHtcbiAgICAgICAgICAgIC8vIEZvciBrZXlib2FyZCBmb2N1cyBzaG93IGEgcGVyc2lzdGVudCByaXBwbGUgYXMgZm9jdXMgaW5kaWNhdG9yLlxuICAgICAgICAgICAgdGhpcy5fZm9jdXNSaXBwbGUgPSB0aGlzLl9yaXBwbGUubGF1bmNoKDAsIDAsIHsgcGVyc2lzdGVudDogdHJ1ZSwgY2VudGVyZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWZvY3VzT3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICAgICAgLy8gRmFkZSBvdXQgYW5kIGNsZWFyIHRoZSBmb2N1cyByaXBwbGUgaWYgb25lIGlzIGN1cnJlbnRseSBwcmVzZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzUmlwcGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNSaXBwbGUuZmFkZU91dCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUmlwcGxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdHMgdGhlIGNoYW5nZSBldmVudCB0byB0aGUgYGNoYW5nZWAgb3V0cHV0IEV2ZW50RW1pdHRlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSBuZXcgTWRTbGlkZVRvZ2dsZUNoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC5jaGVja2VkID0gdGhpcy5jaGVja2VkO1xuICAgICAgICB0aGlzLmNoYW5nZS5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlUmVuZGVyZXIuc3RhcnRUaHVtYkRyYWcodGhpcy5jaGVja2VkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fc2xpZGVSZW5kZXJlci5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5fc2xpZGVSZW5kZXJlci51cGRhdGVUaHVtYlBvc2l0aW9uKGV2ZW50LmRlbHRhWCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3NsaWRlUmVuZGVyZXIuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIF9wcmV2aW91c0NoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XG4gICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSB0aGlzLl9zbGlkZVJlbmRlcmVyLmRyYWdQZXJjZW50YWdlID4gNTA7XG4gICAgICAgICAgICBpZiAoX3ByZXZpb3VzQ2hlY2tlZCAhPT0gdGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgZHJhZyBzaG91bGQgYmUgc3RvcHBlZCBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IGV2ZW50IGhhbmRsZXIsIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZVxuICAgICAgICAgICAgLy8gY2xpY2sgZXZlbnQgd2lsbCBiZSBmaXJlZCBiZWZvcmUgYW5kIHdpbGwgcmV2ZXJ0IHRoZSBkcmFnIGNoYW5nZS5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NsaWRlUmVuZGVyZXIuc3RvcFRodW1iRHJhZygpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kU2xpZGVUb2dnbGU7XG59KF9NZFNsaWRlVG9nZ2xlTWl4aW5CYXNlKSk7XG5NZFNsaWRlVG9nZ2xlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtc2xpZGUtdG9nZ2xlLCBtYXQtc2xpZGUtdG9nZ2xlJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtc2xpZGUtdG9nZ2xlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2hlY2tlZF0nOiAnY2hlY2tlZCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbC1iZWZvcmVdJzogJ2xhYmVsUG9zaXRpb24gPT0gXCJiZWZvcmVcIicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bGFiZWwgY2xhc3M9XFxcIm1hdC1zbGlkZS10b2dnbGUtbGFiZWxcXFwiICNsYWJlbD48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGUtdG9nZ2xlLWJhclxcXCI+PGlucHV0ICNpbnB1dCBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS1pbnB1dCBjZGstdmlzdWFsbHktaGlkZGVuXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgW2lkXT1cXFwiaW5wdXRJZFxcXCIgW3JlcXVpcmVkXT1cXFwicmVxdWlyZWRcXFwiIFt0YWJJbmRleF09XFxcInRhYkluZGV4XFxcIiBbY2hlY2tlZF09XFxcImNoZWNrZWRcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcImFyaWFMYWJlbFxcXCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cXFwiYXJpYUxhYmVsbGVkYnlcXFwiIChjaGFuZ2UpPVxcXCJfb25DaGFuZ2VFdmVudCgkZXZlbnQpXFxcIiAoY2xpY2spPVxcXCJfb25JbnB1dENsaWNrKCRldmVudClcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVyXFxcIiAoc2xpZGVzdGFydCk9XFxcIl9vbkRyYWdTdGFydCgpXFxcIiAoc2xpZGUpPVxcXCJfb25EcmFnKCRldmVudClcXFwiIChzbGlkZWVuZCk9XFxcIl9vbkRyYWdFbmQoKVxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS10aHVtYlxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS1yaXBwbGVcXFwiIG1kLXJpcHBsZSBbbWRSaXBwbGVUcmlnZ2VyXT1cXFwibGFiZWxcXFwiIFttZFJpcHBsZUNlbnRlcmVkXT1cXFwidHJ1ZVxcXCIgW21kUmlwcGxlRGlzYWJsZWRdPVxcXCJkaXNhYmxlUmlwcGxlIHx8IGRpc2FibGVkXFxcIj48L2Rpdj48L2Rpdj48L2Rpdj48c3BhbiBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS1jb250ZW50XFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPjwvbGFiZWw+XCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXNsaWRlLXRvZ2dsZXtkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MjRweDtsaW5lLWhlaWdodDoyNHB4O3doaXRlLXNwYWNlOm5vd3JhcDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7b3V0bGluZTowfS5tYXQtc2xpZGUtdG9nZ2xlLm1hdC1jaGVja2VkIC5tYXQtc2xpZGUtdG9nZ2xlLXRodW1iLWNvbnRhaW5lcnt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMTZweCwwLDApfS5tYXQtc2xpZGUtdG9nZ2xlLm1hdC1kaXNhYmxlZCAubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbCwubWF0LXNsaWRlLXRvZ2dsZS5tYXQtZGlzYWJsZWQgLm1hdC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVye2N1cnNvcjpkZWZhdWx0fS5tYXQtc2xpZGUtdG9nZ2xlLWxhYmVse2Rpc3BsYXk6ZmxleDtmbGV4OjE7ZmxleC1kaXJlY3Rpb246cm93O2FsaWduLWl0ZW1zOmNlbnRlcjtjdXJzb3I6cG9pbnRlcn0ubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbC1iZWZvcmUgLm1hdC1zbGlkZS10b2dnbGUtbGFiZWx7b3JkZXI6MX0ubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbC1iZWZvcmUgLm1hdC1zbGlkZS10b2dnbGUtYmFye29yZGVyOjJ9Lm1hdC1zbGlkZS10b2dnbGUtYmFyLFtkaXI9cnRsXSAubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbC1iZWZvcmUgLm1hdC1zbGlkZS10b2dnbGUtYmFye21hcmdpbi1yaWdodDo4cHg7bWFyZ2luLWxlZnQ6MH0ubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbC1iZWZvcmUgLm1hdC1zbGlkZS10b2dnbGUtYmFyLFtkaXI9cnRsXSAubWF0LXNsaWRlLXRvZ2dsZS1iYXJ7bWFyZ2luLWxlZnQ6OHB4O21hcmdpbi1yaWdodDowfS5tYXQtc2xpZGUtdG9nZ2xlLXRodW1iLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjE7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDt0b3A6LTNweDtsZWZ0OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2l0aW9uOmFsbCA4MG1zIGxpbmVhcjt0cmFuc2l0aW9uLXByb3BlcnR5OnRyYW5zZm9ybTtjdXJzb3I6LXdlYmtpdC1ncmFiO2N1cnNvcjpncmFifS5tYXQtc2xpZGUtdG9nZ2xlLXRodW1iLWNvbnRhaW5lci5tYXQtZHJhZ2dpbmcsLm1hdC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVyOmFjdGl2ZXtjdXJzb3I6LXdlYmtpdC1ncmFiYmluZztjdXJzb3I6Z3JhYmJpbmc7dHJhbnNpdGlvbi1kdXJhdGlvbjowc30ubWF0LXNsaWRlLXRvZ2dsZS10aHVtYntoZWlnaHQ6MjBweDt3aWR0aDoyMHB4O2JvcmRlci1yYWRpdXM6NTAlO2JveC1zaGFkb3c6MCAycHggMXB4IC0xcHggcmdiYSgwLDAsMCwuMiksMCAxcHggMXB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDNweCAwIHJnYmEoMCwwLDAsLjEyKX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LXNsaWRlLXRvZ2dsZS10aHVtYntiYWNrZ3JvdW5kOiNmZmY7Ym9yZGVyOnNvbGlkIDFweCAjMDAwfX0ubWF0LXNsaWRlLXRvZ2dsZS1iYXJ7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MzZweDtoZWlnaHQ6MTRweDtib3JkZXItcmFkaXVzOjhweH1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LXNsaWRlLXRvZ2dsZS1iYXJ7YmFja2dyb3VuZDojZmZmfX0ubWF0LXNsaWRlLXRvZ2dsZS1pbnB1dHtib3R0b206MDtsZWZ0OjEwcHh9Lm1hdC1zbGlkZS10b2dnbGUtYmFyLC5tYXQtc2xpZGUtdG9nZ2xlLXRodW1ie3RyYW5zaXRpb246YWxsIDgwbXMgbGluZWFyO3RyYW5zaXRpb24tcHJvcGVydHk6YmFja2dyb3VuZC1jb2xvcjt0cmFuc2l0aW9uLWRlbGF5OjUwbXN9Lm1hdC1zbGlkZS10b2dnbGUtcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMTNweDtsZWZ0Oi0xM3B4O2hlaWdodDo0NnB4O3dpZHRoOjQ2cHg7Ym9yZGVyLXJhZGl1czo1MCU7ei1pbmRleDoxO3BvaW50ZXItZXZlbnRzOm5vbmV9XCJdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01EX1NMSURFX1RPR0dMRV9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2Rpc2FibGVkJywgJ2NvbG9yJ10sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNsaWRlVG9nZ2xlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCB9LFxuICAgIHsgdHlwZTogRm9jdXNPcmlnaW5Nb25pdG9yLCB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYsIH0sXG5dOyB9O1xuTWRTbGlkZVRvZ2dsZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3RhYkluZGV4JzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdsYWJlbFBvc2l0aW9uJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdhcmlhTGFiZWwnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydhcmlhLWxhYmVsJyxdIH0sXSxcbiAgICAnYXJpYUxhYmVsbGVkYnknOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydhcmlhLWxhYmVsbGVkYnknLF0gfSxdLFxuICAgICdyZXF1aXJlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGlzYWJsZVJpcHBsZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnY2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnX2lucHV0RWxlbWVudCc6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydpbnB1dCcsXSB9LF0sXG4gICAgJ19yaXBwbGUnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtNZFJpcHBsZSxdIH0sXSxcbiAgICAnY2hlY2tlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG4vKipcbiAqIFJlbmRlcmVyIGZvciB0aGUgU2xpZGUgVG9nZ2xlIGNvbXBvbmVudCwgd2hpY2ggc2VwYXJhdGVzIERPTSBtb2RpZmljYXRpb24gaW4gaXRzIG93biBjbGFzc1xuICovXG52YXIgU2xpZGVUb2dnbGVSZW5kZXJlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IHBsYXRmb3JtXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2xpZGVUb2dnbGVSZW5kZXJlcihfZWxlbWVudFJlZiwgcGxhdGZvcm0pIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdGh1bWIgaXMgY3VycmVudGx5IGJlaW5nIGRyYWdnZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBpbnRlcmFjdCB3aXRoIHRoZXNlIGVsZW1lbnRzIHdoZW4gd2UncmUgb24gdGhlIGJyb3dzZXIsIHNvIG9ubHkgZ3JhYlxuICAgICAgICAvLyB0aGUgcmVmZXJlbmNlIGluIHRoYXQgY2FzZS5cbiAgICAgICAgaWYgKHBsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGhpcy5fdGh1bWJFbCA9IF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1hdC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVyJyk7XG4gICAgICAgICAgICB0aGlzLl90aHVtYkJhckVsID0gX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWF0LXNsaWRlLXRvZ2dsZS1iYXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgZHJhZyBvZiB0aGUgc2xpZGUtdG9nZ2xlLlxuICAgICAqIEBwYXJhbSB7P30gY2hlY2tlZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2xpZGVUb2dnbGVSZW5kZXJlci5wcm90b3R5cGUuc3RhcnRUaHVtYkRyYWcgPSBmdW5jdGlvbiAoY2hlY2tlZCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RodW1iQmFyV2lkdGggPSB0aGlzLl90aHVtYkJhckVsLmNsaWVudFdpZHRoIC0gdGhpcy5fdGh1bWJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgdGhpcy5fdGh1bWJFbC5jbGFzc0xpc3QuYWRkKCdtYXQtZHJhZ2dpbmcnKTtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNDaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgZHJhZyBhbmQgcmV0dXJucyB0aGUgbmV3IGNoZWNrZWQgdmFsdWUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTbGlkZVRvZ2dsZVJlbmRlcmVyLnByb3RvdHlwZS5zdG9wVGh1bWJEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RodW1iRWwuY2xhc3NMaXN0LnJlbW92ZSgnbWF0LWRyYWdnaW5nJyk7XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0cmFuc2Zvcm0gYmVjYXVzZSB0aGUgY29tcG9uZW50IHdpbGwgdGFrZSBjYXJlIG9mIHRoZSB0aHVtYiBwb3NpdGlvbiBhZnRlciBkcmFnLlxuICAgICAgICBhcHBseUNzc1RyYW5zZm9ybSh0aGlzLl90aHVtYkVsLCAnJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdQZXJjZW50YWdlID4gNTA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0aHVtYiBjb250YWluZXJzIHBvc2l0aW9uIGZyb20gdGhlIHNwZWNpZmllZCBkaXN0YW5jZS5cbiAgICAgKiBAcGFyYW0gez99IGRpc3RhbmNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTbGlkZVRvZ2dsZVJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVUaHVtYlBvc2l0aW9uID0gZnVuY3Rpb24gKGRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuZHJhZ1BlcmNlbnRhZ2UgPSB0aGlzLl9nZXREcmFnUGVyY2VudGFnZShkaXN0YW5jZSk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbW92ZWQgZGlzdGFuY2UgYmFzZWQgb24gdGhlIHRodW1iIGJhciB3aWR0aC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHJhZ1ggPSAodGhpcy5kcmFnUGVyY2VudGFnZSAvIDEwMCkgKiB0aGlzLl90aHVtYkJhcldpZHRoO1xuICAgICAgICBhcHBseUNzc1RyYW5zZm9ybSh0aGlzLl90aHVtYkVsLCBcInRyYW5zbGF0ZTNkKFwiICsgZHJhZ1ggKyBcInB4LCAwLCAwKVwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgcGVyY2VudGFnZSBvZiB0aHVtYiBmcm9tIHRoZSBtb3ZlZCBkaXN0YW5jZS4gUGVyY2VudGFnZSBhcyBmcmFjdGlvbiBvZiAxMDAuXG4gICAgICogQHBhcmFtIHs/fSBkaXN0YW5jZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2xpZGVUb2dnbGVSZW5kZXJlci5wcm90b3R5cGUuX2dldERyYWdQZXJjZW50YWdlID0gZnVuY3Rpb24gKGRpc3RhbmNlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBlcmNlbnRhZ2UgPSAoZGlzdGFuY2UgLyB0aGlzLl90aHVtYkJhcldpZHRoKSAqIDEwMDtcbiAgICAgICAgLy8gV2hlbiB0aGUgdG9nZ2xlIHdhcyBpbml0aWFsbHkgY2hlY2tlZCwgdGhlbiB3ZSBoYXZlIHRvIHN0YXJ0IHRoZSBkcmFnIGF0IHRoZSBlbmQuXG4gICAgICAgIGlmICh0aGlzLl9wcmV2aW91c0NoZWNrZWQpIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgKz0gMTAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihwZXJjZW50YWdlLCAxMDApKTtcbiAgICB9O1xuICAgIHJldHVybiBTbGlkZVRvZ2dsZVJlbmRlcmVyO1xufSgpKTtcbnZhciBNZFNsaWRlVG9nZ2xlTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZVRvZ2dsZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kU2xpZGVUb2dnbGVNb2R1bGU7XG59KCkpO1xuTWRTbGlkZVRvZ2dsZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0Zvcm1zTW9kdWxlLCBNZFJpcHBsZU1vZHVsZSwgTWRDb21tb25Nb2R1bGUsIFBsYXRmb3JtTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRTbGlkZVRvZ2dsZSwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kU2xpZGVUb2dnbGVdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBGT0NVU19PUklHSU5fTU9OSVRPUl9QUk9WSURFUixcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBIQU1NRVJfR0VTVFVSRV9DT05GSUcsIHVzZUNsYXNzOiBHZXN0dXJlQ29uZmlnIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNsaWRlVG9nZ2xlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFZpc3VhbGx5LCBhIDMwcHggc2VwYXJhdGlvbiBiZXR3ZWVuIHRpY2sgbWFya3MgbG9va3MgYmVzdC4gVGhpcyBpcyB2ZXJ5IHN1YmplY3RpdmUgYnV0IGl0IGlzXG4gKiB0aGUgZGVmYXVsdCBzZXBhcmF0aW9uIHdlIGNob3NlLlxuICovXG52YXIgTUlOX0FVVE9fVElDS19TRVBBUkFUSU9OID0gMzA7XG4vKipcbiAqIFRoZSB0aHVtYiBnYXAgc2l6ZSBmb3IgYSBkaXNhYmxlZCBzbGlkZXIuXG4gKi9cbnZhciBESVNBQkxFRF9USFVNQl9HQVAgPSA3O1xuLyoqXG4gKiBUaGUgdGh1bWIgZ2FwIHNpemUgZm9yIGEgbm9uLWFjdGl2ZSBzbGlkZXIgYXQgaXRzIG1pbmltdW0gdmFsdWUuXG4gKi9cbnZhciBNSU5fVkFMVUVfTk9OQUNUSVZFX1RIVU1CX0dBUCA9IDc7XG4vKipcbiAqIFRoZSB0aHVtYiBnYXAgc2l6ZSBmb3IgYW4gYWN0aXZlIHNsaWRlciBhdCBpdHMgbWluaW11bSB2YWx1ZS5cbiAqL1xudmFyIE1JTl9WQUxVRV9BQ1RJVkVfVEhVTUJfR0FQID0gMTA7XG4vKipcbiAqIFByb3ZpZGVyIEV4cHJlc3Npb24gdGhhdCBhbGxvd3MgbWQtc2xpZGVyIHRvIHJlZ2lzdGVyIGFzIGEgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gKiBUaGlzIGFsbG93cyBpdCB0byBzdXBwb3J0IFsobmdNb2RlbCldIGFuZCBbZm9ybUNvbnRyb2xdLlxuICovXG52YXIgTURfU0xJREVSX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kU2xpZGVyOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogQSBzaW1wbGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgYnkgdGhlIE1kU2xpZGVyIGNvbXBvbmVudC5cbiAqL1xudmFyIE1kU2xpZGVyQ2hhbmdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZXJDaGFuZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNsaWRlckNoYW5nZTtcbn0oKSk7XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRTbGlkZXJCYXNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZXJCYXNlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRTbGlkZXJCYXNlO1xufSgpKTtcbnZhciBfTWRTbGlkZXJNaXhpbkJhc2UgPSBtaXhpbkRpc2FibGVkKE1kU2xpZGVyQmFzZSk7XG4vKipcbiAqIEFsbG93cyB1c2VycyB0byBzZWxlY3QgZnJvbSBhIHJhbmdlIG9mIHZhbHVlcyBieSBtb3ZpbmcgdGhlIHNsaWRlciB0aHVtYi4gSXQgaXMgc2ltaWxhciBpblxuICogYmVoYXZpb3IgdG8gdGhlIG5hdGl2ZSBgPGlucHV0IHR5cGU9XCJyYW5nZVwiPmAgZWxlbWVudC5cbiAqL1xudmFyIE1kU2xpZGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRTbGlkZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c09yaWdpbk1vbml0b3JcbiAgICAgKiBAcGFyYW0gez99IF9kaXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFNsaWRlcihyZW5kZXJlciwgX2VsZW1lbnRSZWYsIF9mb2N1c09yaWdpbk1vbml0b3IsIF9kaXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgX3RoaXMuX2ZvY3VzT3JpZ2luTW9uaXRvciA9IF9mb2N1c09yaWdpbk1vbml0b3I7XG4gICAgICAgIF90aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICBfdGhpcy5faW52ZXJ0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9tYXggPSAxMDA7XG4gICAgICAgIF90aGlzLl9taW4gPSAwO1xuICAgICAgICBfdGhpcy5fc3RlcCA9IDE7XG4gICAgICAgIF90aGlzLl90aHVtYkxhYmVsID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl90aWNrSW50ZXJ2YWwgPSAwO1xuICAgICAgICBfdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICBfdGhpcy5fdmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY29sb3IgPSAnYWNjZW50JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2xpZGVyIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzbGlkZXIgdGh1bWIgbW92ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pbnB1dCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9uVG91Y2ggZnVuY3Rpb24gcmVnaXN0ZXJlZCB2aWEgcmVnaXN0ZXJPblRvdWNoIChDb250cm9sVmFsdWVBY2Nlc3NvcikuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIF90aGlzLl9wZXJjZW50ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0aHVtYiBpcyBzbGlkaW5nLlxuICAgICAgICAgKiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGVyZSBzaG91bGQgYmUgYSB0cmFuc2l0aW9uIGZvciB0aGUgdGh1bWIgYW5kIGZpbGwgdHJhY2suXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc2xpZGVyIGlzIGFjdGl2ZSAoY2xpY2tlZCBvciBzbGlkaW5nKS5cbiAgICAgICAgICogVXNlZCB0byBzaHJpbmsgYW5kIGdyb3cgdGhlIHRodW1iIGFzIGFjY29yZGluZyB0byB0aGUgTWF0ZXJpYWwgRGVzaWduIHNwZWMuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIGEgdGljayBpbnRlcnZhbCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHNpemUgb2YgdGhlIHRyYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3RpY2tJbnRlcnZhbFBlcmNlbnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHNsaWRlci5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zbGlkZXJEaW1lbnNpb25zID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIF90aGlzLl9mb2N1c09yaWdpbk1vbml0b3IubW9uaXRvcihfdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCByZW5kZXJlciwgdHJ1ZSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKG9yaWdpbikgeyByZXR1cm4gX3RoaXMuX2lzQWN0aXZlID0gISFvcmlnaW4gJiYgb3JpZ2luICE9PSAna2V5Ym9hcmQnOyB9KTtcbiAgICAgICAgX3RoaXMuX3JlbmRlcmVyID0gbmV3IFNsaWRlclJlbmRlcmVyKF90aGlzLl9lbGVtZW50UmVmKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcImludmVydFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzbGlkZXIgaXMgaW52ZXJ0ZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2ludmVydDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2ludmVydCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwibWF4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIHNsaWRlciBjYW4gaGF2ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fbWF4ID0gY29lcmNlTnVtYmVyUHJvcGVydHkodiwgdGhpcy5fbWF4KTtcbiAgICAgICAgICAgIHRoaXMuX3BlcmNlbnQgPSB0aGlzLl9jYWxjdWxhdGVQZXJjZW50YWdlKHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJtaW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gdmFsdWUgdGhhdCB0aGUgc2xpZGVyIGNhbiBoYXZlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWluO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9taW4gPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2LCB0aGlzLl9taW4pO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIHdhc24ndCBleHBsaWNpdGx5IHNldCBieSB0aGUgdXNlciwgc2V0IGl0IHRvIHRoZSBtaW4uXG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5fbWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGVyY2VudCA9IHRoaXMuX2NhbGN1bGF0ZVBlcmNlbnRhZ2UodGhpcy5fdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInN0ZXBcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlcyBhdCB3aGljaCB0aGUgdGh1bWIgd2lsbCBzbmFwLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGVwOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGVwID0gY29lcmNlTnVtYmVyUHJvcGVydHkodiwgdGhpcy5fc3RlcCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RlcCAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3VuZExhYmVsVG8gPSAoKHRoaXMuX3N0ZXAudG9TdHJpbmcoKS5zcGxpdCgnLicpLnBvcCgpKSkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInRodW1iTGFiZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gc2hvdyB0aGUgdGh1bWIgbGFiZWwuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RodW1iTGFiZWw7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl90aHVtYkxhYmVsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJfdGh1bWJMYWJlbERlcHJlY2F0ZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdGh1bWJMYWJlbDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3RodW1iTGFiZWwgPSB2YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJ0aWNrSW50ZXJ2YWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogSG93IG9mdGVuIHRvIHNob3cgdGlja3MuIFJlbGF0aXZlIHRvIHRoZSBzdGVwIHNvIHRoYXQgYSB0aWNrIGFsd2F5cyBhcHBlYXJzIG9uIGEgc3RlcC5cbiAgICAgICAgICogRXg6IFRpY2sgaW50ZXJ2YWwgb2YgNCB3aXRoIGEgc3RlcCBvZiAzIHdpbGwgZHJhdyBhIHRpY2sgZXZlcnkgNCBzdGVwcyAoZXZlcnkgMTIgdmFsdWVzKS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdGlja0ludGVydmFsOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gY29lcmNlTnVtYmVyUHJvcGVydHkodmFsdWUsIC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuX3RpY2tJbnRlcnZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJfdGlja0ludGVydmFsRGVwcmVjYXRlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRpY2tJbnRlcnZhbDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLnRpY2tJbnRlcnZhbCA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIG5lZWRzIHRvIGJlIHJlYWQgYW5kIGl0IGlzIHN0aWxsIHVuaW5pdGlhbGl6ZWQsIGluaXRpYWxpemUgaXQgdG8gdGhlIG1pbi5cbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9taW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gY29lcmNlTnVtYmVyUHJvcGVydHkodiwgdGhpcy5fdmFsdWUgfHwgMCk7XG4gICAgICAgICAgICB0aGlzLl9wZXJjZW50ID0gdGhpcy5fY2FsY3VsYXRlUGVyY2VudGFnZSh0aGlzLl92YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidmVydGljYWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgc2xpZGVyIGlzIHZlcnRpY2FsLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92ZXJ0aWNhbDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3ZlcnRpY2FsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJkaXNwbGF5VmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIHRvIGJlIHVzZWQgZm9yIGRpc3BsYXkgcHVycG9zZXMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGNvdWxkIGJlIGltcHJvdmVkIGZ1cnRoZXIgYnkgcm91bmRpbmcgc29tZXRoaW5nIGxpa2UgMC45OTkgdG8gMSBvclxuICAgICAgICAgICAgLy8gMC44OTkgdG8gMC45LCBob3dldmVyIGl0IGlzIHZlcnkgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLCBiZWNhdXNlIGl0IGdldHMgY2FsbGVkIG9uXG4gICAgICAgICAgICAvLyBldmVyeSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3JvdW5kTGFiZWxUbyAmJiB0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUgJSAxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUudG9GaXhlZCh0aGlzLl9yb3VuZExhYmVsVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgfHwgMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJwZXJjZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBzbGlkZXIgdGhhdCBjb2luY2lkZXMgd2l0aCB0aGUgdmFsdWUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NsYW1wKHRoaXMuX3BlcmNlbnQpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl9pbnZlcnRBeGlzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGF4aXMgb2YgdGhlIHNsaWRlciBpcyBpbnZlcnRlZC5cbiAgICAgICAgICogKGkuZS4gd2hldGhlciBtb3ZpbmcgdGhlIHRodW1iIGluIHRoZSBwb3NpdGl2ZSB4IG9yIHkgZGlyZWN0aW9uIGRlY3JlYXNlcyB0aGUgc2xpZGVyJ3MgdmFsdWUpLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBTdGFuZGFyZCBub24taW52ZXJ0ZWQgbW9kZSBmb3IgYSB2ZXJ0aWNhbCBzbGlkZXIgc2hvdWxkIGJlIGRyYWdnaW5nIHRoZSB0aHVtYiBmcm9tIGJvdHRvbSB0b1xuICAgICAgICAgICAgLy8gdG9wLiBIb3dldmVyIGZyb20gYSB5LWF4aXMgc3RhbmRwb2ludCB0aGlzIGlzIGludmVydGVkLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVydGljYWwgPyAhdGhpcy5pbnZlcnQgOiB0aGlzLmludmVydDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJfaXNNaW5WYWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzbGlkZXIgaXMgYXQgaXRzIG1pbmltdW0gdmFsdWUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmNlbnQgPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX3RodW1iR2FwXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2Ygc3BhY2UgdG8gbGVhdmUgYmV0d2VlbiB0aGUgc2xpZGVyIHRodW1iIGFuZCB0aGUgdHJhY2sgZmlsbCAmIHRyYWNrIGJhY2tncm91bmRcbiAgICAgICAgICogZWxlbWVudHMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERJU0FCTEVEX1RIVU1CX0dBUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc01pblZhbHVlICYmICF0aGlzLnRodW1iTGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNBY3RpdmUgPyBNSU5fVkFMVUVfQUNUSVZFX1RIVU1CX0dBUCA6IE1JTl9WQUxVRV9OT05BQ1RJVkVfVEhVTUJfR0FQO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX3RyYWNrQmFja2dyb3VuZFN0eWxlc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDU1Mgc3R5bGVzIGZvciB0aGUgdHJhY2sgYmFja2dyb3VuZCBlbGVtZW50LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBheGlzID0gdGhpcy52ZXJ0aWNhbCA/ICdZJyA6ICdYJztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNpZ24gPSB0aGlzLl9pbnZlcnRNb3VzZUNvb3JkcyA/ICctJyA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogXCJ0cmFuc2xhdGVcIiArIGF4aXMgKyBcIihcIiArIHNpZ24gKyB0aGlzLl90aHVtYkdhcCArIFwicHgpIHNjYWxlXCIgKyBheGlzICsgXCIoXCIgKyAoMSAtIHRoaXMucGVyY2VudCkgKyBcIilcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJfdHJhY2tGaWxsU3R5bGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENTUyBzdHlsZXMgZm9yIHRoZSB0cmFjayBmaWxsIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gJ1knIDogJ1gnO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbiA9IHRoaXMuX2ludmVydE1vdXNlQ29vcmRzID8gJycgOiAnLSc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBcInRyYW5zbGF0ZVwiICsgYXhpcyArIFwiKFwiICsgc2lnbiArIHRoaXMuX3RodW1iR2FwICsgXCJweCkgc2NhbGVcIiArIGF4aXMgKyBcIihcIiArIHRoaXMucGVyY2VudCArIFwiKVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl90aWNrc0NvbnRhaW5lclN0eWxlc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDU1Mgc3R5bGVzIGZvciB0aGUgdGlja3MgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gJ1knIDogJ1gnO1xuICAgICAgICAgICAgLy8gRm9yIGEgaG9yaXpvbnRhbCBzbGlkZXIgaW4gUlRMIGxhbmd1YWdlcyB3ZSBwdXNoIHRoZSB0aWNrcyBjb250YWluZXIgb2ZmIHRoZSBsZWZ0IGVkZ2VcbiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgdGhlIHJpZ2h0IGVkZ2UgdG8gYXZvaWQgY2F1c2luZyBhIGhvcml6b250YWwgc2Nyb2xsYmFyIHRvIGFwcGVhci5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNpZ24gPSAhdGhpcy52ZXJ0aWNhbCAmJiB0aGlzLl9kaXJlY3Rpb24gPT0gJ3J0bCcgPyAnJyA6ICctJztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IHRoaXMuX3RpY2tJbnRlcnZhbFBlcmNlbnQgLyAyICogMTAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogXCJ0cmFuc2xhdGVcIiArIGF4aXMgKyBcIihcIiArIHNpZ24gKyBvZmZzZXQgKyBcIiUpXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX3RpY2tzU3R5bGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENTUyBzdHlsZXMgZm9yIHRoZSB0aWNrcyBlbGVtZW50LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aWNrU2l6ZSA9IHRoaXMuX3RpY2tJbnRlcnZhbFBlcmNlbnQgKiAxMDA7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYWNrZ3JvdW5kU2l6ZSA9IHRoaXMudmVydGljYWwgPyBcIjJweCBcIiArIHRpY2tTaXplICsgXCIlXCIgOiB0aWNrU2l6ZSArIFwiJSAycHhcIjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gJ1knIDogJ1gnO1xuICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gd2UgcHVzaGVkIHRoZSB0aWNrcyBjb250YWluZXIsIHB1c2ggdGhlIHRpY2tzIHRoZSBvcHBvc2l0ZVxuICAgICAgICAgICAgLy8gZGlyZWN0aW9uIHRvIHJlLWNlbnRlciB0aGVtIGJ1dCBjbGlwIG9mZiB0aGUgZW5kIGVkZ2UuIEluIFJUTCBsYW5ndWFnZXMgd2UgbmVlZCB0byBmbGlwIHRoZVxuICAgICAgICAgICAgLy8gdGlja3MgMTgwIGRlZ3JlZXMgc28gd2UncmUgcmVhbGx5IGN1dHRpbmcgb2ZmIHRoZSBlbmQgZWRnZSBhYmQgbm90IHRoZSBzdGFydC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNpZ24gPSAhdGhpcy52ZXJ0aWNhbCAmJiB0aGlzLl9kaXJlY3Rpb24gPT0gJ3J0bCcgPyAnLScgOiAnJztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvdGF0ZSA9ICF0aGlzLnZlcnRpY2FsICYmIHRoaXMuX2RpcmVjdGlvbiA9PSAncnRsJyA/ICcgcm90YXRlKDE4MGRlZyknIDogJyc7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB7XG4gICAgICAgICAgICAgICAgJ2JhY2tncm91bmRTaXplJzogYmFja2dyb3VuZFNpemUsXG4gICAgICAgICAgICAgICAgLy8gV2l0aG91dCB0cmFuc2xhdGVaIHRpY2tzIHNvbWV0aW1lcyBqaXR0ZXIgYXMgdGhlIHNsaWRlciBtb3ZlcyBvbiBDaHJvbWUgJiBGaXJlZm94LlxuICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBcInRyYW5zbGF0ZVooMCkgdHJhbnNsYXRlXCIgKyBheGlzICsgXCIoXCIgKyBzaWduICsgdGlja1NpemUgLyAyICsgXCIlKVwiICsgcm90YXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTWluVmFsdWUgJiYgdGhpcy5fdGh1bWJHYXApIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWRlID0gdGhpcy52ZXJ0aWNhbCA/XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9pbnZlcnRBeGlzID8gJ0JvdHRvbScgOiAnVG9wJykgOlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5faW52ZXJ0QXhpcyA/ICdSaWdodCcgOiAnTGVmdCcpO1xuICAgICAgICAgICAgICAgIHN0eWxlc1tcInBhZGRpbmdcIiArIHNpZGVdID0gdGhpcy5fdGh1bWJHYXAgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl90aHVtYkNvbnRhaW5lclN0eWxlc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBheGlzID0gdGhpcy52ZXJ0aWNhbCA/ICdZJyA6ICdYJztcbiAgICAgICAgICAgIC8vIEZvciBhIGhvcml6b250YWwgc2xpZGVyIGluIFJUTCBsYW5ndWFnZXMgd2UgcHVzaCB0aGUgdGh1bWIgY29udGFpbmVyIG9mZiB0aGUgbGVmdCBlZGdlXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSByaWdodCBlZGdlIHRvIGF2b2lkIGNhdXNpbmcgYSBob3Jpem9udGFsIHNjcm9sbGJhciB0byBhcHBlYXIuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnZlcnRPZmZzZXQgPSAodGhpcy5fZGlyZWN0aW9uID09ICdydGwnICYmICF0aGlzLnZlcnRpY2FsKSA/ICF0aGlzLl9pbnZlcnRBeGlzIDogdGhpcy5faW52ZXJ0QXhpcztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IChpbnZlcnRPZmZzZXQgPyB0aGlzLnBlcmNlbnQgOiAxIC0gdGhpcy5wZXJjZW50KSAqIDEwMDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IFwidHJhbnNsYXRlXCIgKyBheGlzICsgXCIoLVwiICsgb2Zmc2V0ICsgXCIlKVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl9pbnZlcnRNb3VzZUNvb3Jkc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG1vdXNlIGV2ZW50cyBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgc2xpZGVyIHBvc2l0aW9uIGJ5IGNhbGN1bGF0aW5nIHRoZWlyIGRpc3RhbmNlXG4gICAgICAgICAqIGZyb20gdGhlIHJpZ2h0IG9yIGJvdHRvbSBlZGdlIG9mIHRoZSBzbGlkZXIgYXMgb3Bwb3NlZCB0byB0aGUgdG9wIG9yIGxlZnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fZGlyZWN0aW9uID09ICdydGwnICYmICF0aGlzLnZlcnRpY2FsKSA/ICF0aGlzLl9pbnZlcnRBeGlzIDogdGhpcy5faW52ZXJ0QXhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJfZGlyZWN0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYW5ndWFnZSBkaXJlY3Rpb24gZm9yIHRoaXMgc2xpZGVyIGVsZW1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PSAncnRsJykgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLnN0b3BNb25pdG9yaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25Nb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHNhdmUgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHNsaWRlciBoZXJlIHNvIHdlIGNhbiB1c2UgdGhlbSB0byB1cGRhdGUgdGhlIHNwYWNpbmcgb2YgdGhlXG4gICAgICAgIC8vIHRpY2tzIGFuZCBkZXRlcm1pbmUgd2hlcmUgb24gdGhlIHNsaWRlciBjbGljayBhbmQgc2xpZGUgZXZlbnRzIGhhcHBlbi5cbiAgICAgICAgdGhpcy5fc2xpZGVyRGltZW5zaW9ucyA9IHRoaXMuX3JlbmRlcmVyLmdldFNsaWRlckRpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGlja0ludGVydmFsUGVyY2VudCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZEZvY3VzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlRnJvbVBvc2l0aW9uKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgICAgLyogRW1pdHMgYSBjaGFuZ2UgYW5kIGlucHV0IGV2ZW50IGlmIHRoZSB2YWx1ZSBjaGFuZ2VkLiAqL1xuICAgICAgICB0aGlzLl9lbWl0SW5wdXRFdmVudCgpO1xuICAgICAgICB0aGlzLl9lbWl0VmFsdWVJZkNoYW5nZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25TbGlkZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgdGhlIHNsaWRlIGZyb20gc2VsZWN0aW5nIGFueXRoaW5nIGVsc2UuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlRnJvbVBvc2l0aW9uKHsgeDogZXZlbnQuY2VudGVyLngsIHk6IGV2ZW50LmNlbnRlci55IH0pO1xuICAgICAgICAvLyBOYXRpdmUgcmFuZ2UgZWxlbWVudHMgYWx3YXlzIGVtaXQgYGlucHV0YCBldmVudHMgd2hlbiB0aGUgdmFsdWUgY2hhbmdlZCB3aGlsZSBzbGlkaW5nLlxuICAgICAgICB0aGlzLl9lbWl0SW5wdXRFdmVudCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vblNsaWRlU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW11bGF0ZSBtb3VzZWVudGVyIGluIGNhc2UgdGhpcyBpcyBhIG1vYmlsZSBkZXZpY2UuXG4gICAgICAgIHRoaXMuX29uTW91c2VlbnRlcigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRGb2N1cygpO1xuICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZUZyb21Qb3NpdGlvbih7IHg6IGV2ZW50LmNlbnRlci54LCB5OiBldmVudC5jZW50ZXIueSB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vblNsaWRlRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZW1pdFZhbHVlSWZDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2Ugc2F2ZSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgc2xpZGVyIGhlcmUgc28gd2UgY2FuIHVzZSB0aGVtIHRvIHVwZGF0ZSB0aGUgc3BhY2luZyBvZiB0aGVcbiAgICAgICAgLy8gdGlja3MgYW5kIGRldGVybWluZSB3aGVyZSBvbiB0aGUgc2xpZGVyIGNsaWNrIGFuZCBzbGlkZSBldmVudHMgaGFwcGVuLlxuICAgICAgICB0aGlzLl9zbGlkZXJEaW1lbnNpb25zID0gdGhpcy5fcmVuZGVyZXIuZ2V0U2xpZGVyRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLl91cGRhdGVUaWNrSW50ZXJ2YWxQZXJjZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vbktleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgUEFHRV9VUDpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZW1lbnQoMTApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQQUdFX0RPV046XG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KC0xMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVORDpcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5tYXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhPTUU6XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubWluO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IEZvciBhIHNpZ2h0ZWQgdXNlciBpdCB3b3VsZCBtYWtlIG1vcmUgc2Vuc2UgdGhhdCB3aGVuIHRoZXkgcHJlc3MgYW4gYXJyb3cga2V5IG9uIGFuXG4gICAgICAgICAgICAgICAgLy8gaW52ZXJ0ZWQgc2xpZGVyIHRoZSB0aHVtYiBtb3ZlcyBpbiB0aGF0IGRpcmVjdGlvbi4gSG93ZXZlciBmb3IgYSBibGluZCB1c2VyLCBub3RoaW5nXG4gICAgICAgICAgICAgICAgLy8gYWJvdXQgdGhlIHNsaWRlciBpbmRpY2F0ZXMgdGhhdCBpdCBpcyBpbnZlcnRlZC4gVGhleSB3aWxsIGV4cGVjdCBsZWZ0IHRvIGJlIGRlY3JlbWVudCxcbiAgICAgICAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIGhvdyBpdCBhcHBlYXJzIG9uIHRoZSBzY3JlZW4uIEZvciBzcGVha2VycyBvZlJUTCBsYW5ndWFnZXMsIHRoZXkgcHJvYmFibHlcbiAgICAgICAgICAgICAgICAvLyBleHBlY3QgbGVmdCB0byBtZWFuIGluY3JlbWVudC4gVGhlcmVmb3JlIHdlIGZsaXAgdGhlIG1lYW5pbmcgb2YgdGhlIHNpZGUgYXJyb3cga2V5cyBmb3JcbiAgICAgICAgICAgICAgICAvLyBSVEwuIEZvciBpbnZlcnRlZCBzbGlkZXJzIHdlIHByZWZlciBhIGdvb2QgYTExeSBleHBlcmllbmNlIHRvIGhhdmluZyBpdCBcImxvb2sgcmlnaHRcIiBmb3JcbiAgICAgICAgICAgICAgICAvLyBzaWdodGVkIHVzZXJzLCB0aGVyZWZvcmUgd2UgZG8gbm90IHN3YXAgdGhlIG1lYW5pbmcuXG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KHRoaXMuX2RpcmVjdGlvbiA9PSAncnRsJyA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudCgxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgb24gTEVGVF9BUlJPVyBhYm91dCB0aGUgY29uZGl0aW9ucyB1bmRlciB3aGljaCB3ZSBmbGlwIHRoZSBtZWFuaW5nLlxuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudCh0aGlzLl9kaXJlY3Rpb24gPT0gJ3J0bCcgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudCgtMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBpZiB0aGUga2V5IGlzIG5vdCBvbmUgdGhhdCB3ZSBleHBsaWNpdGx5IGhhbmRsZSB0byBhdm9pZCBjYWxsaW5nIHByZXZlbnREZWZhdWx0IG9uXG4gICAgICAgICAgICAgICAgLy8gaXQuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25LZXl1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnRzIHRoZSBzbGlkZXIgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBzdGVwcyAobmVnYXRpdmUgbnVtYmVyIGRlY3JlbWVudHMpLlxuICAgICAqIEBwYXJhbSB7P30gbnVtU3RlcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5faW5jcmVtZW50ID0gZnVuY3Rpb24gKG51bVN0ZXBzKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9jbGFtcCgodGhpcy52YWx1ZSB8fCAwKSArIHRoaXMuc3RlcCAqIG51bVN0ZXBzLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgICAgICB0aGlzLl9lbWl0SW5wdXRFdmVudCgpO1xuICAgICAgICB0aGlzLl9lbWl0VmFsdWVJZkNoYW5nZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgbmV3IHZhbHVlIGZyb20gdGhlIG5ldyBwaHlzaWNhbCBsb2NhdGlvbi4gVGhlIHZhbHVlIHdpbGwgYWx3YXlzIGJlIHNuYXBwZWQuXG4gICAgICogQHBhcmFtIHs/fSBwb3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fdXBkYXRlVmFsdWVGcm9tUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2xpZGVyRGltZW5zaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IHRoaXMudmVydGljYWwgPyB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLnRvcCA6IHRoaXMuX3NsaWRlckRpbWVuc2lvbnMubGVmdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2l6ZSA9IHRoaXMudmVydGljYWwgPyB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLmhlaWdodCA6IHRoaXMuX3NsaWRlckRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc0NvbXBvbmVudCA9IHRoaXMudmVydGljYWwgPyBwb3MueSA6IHBvcy54O1xuICAgICAgICAvLyBUaGUgZXhhY3QgdmFsdWUgaXMgY2FsY3VsYXRlZCBmcm9tIHRoZSBldmVudCBhbmQgdXNlZCB0byBmaW5kIHRoZSBjbG9zZXN0IHNuYXAgdmFsdWUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBlcmNlbnQgPSB0aGlzLl9jbGFtcCgocG9zQ29tcG9uZW50IC0gb2Zmc2V0KSAvIHNpemUpO1xuICAgICAgICBpZiAodGhpcy5faW52ZXJ0TW91c2VDb29yZHMpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAxIC0gcGVyY2VudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGFjdFZhbHVlID0gdGhpcy5fY2FsY3VsYXRlVmFsdWUocGVyY2VudCk7XG4gICAgICAgIC8vIFRoaXMgY2FsY3VsYXRpb24gZmluZHMgdGhlIGNsb3Nlc3Qgc3RlcCBieSBmaW5kaW5nIHRoZSBjbG9zZXN0IHdob2xlIG51bWJlciBkaXZpc2libGUgYnkgdGhlXG4gICAgICAgIC8vIHN0ZXAgcmVsYXRpdmUgdG8gdGhlIG1pbi5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvc2VzdFZhbHVlID0gTWF0aC5yb3VuZCgoZXhhY3RWYWx1ZSAtIHRoaXMubWluKSAvIHRoaXMuc3RlcCkgKiB0aGlzLnN0ZXAgKyB0aGlzLm1pbjtcbiAgICAgICAgLy8gVGhlIHZhbHVlIG5lZWRzIHRvIHNuYXAgdG8gdGhlIG1pbiBhbmQgbWF4LlxuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5fY2xhbXAoY2xvc2VzdFZhbHVlLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdHMgYSBjaGFuZ2UgZXZlbnQgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGxhc3QgZW1pdHRlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fZW1pdFZhbHVlSWZDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPSB0aGlzLl9sYXN0Q2hhbmdlVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV2ZW50ID0gdGhpcy5fY3JlYXRlQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RDaGFuZ2VWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGlucHV0IGV2ZW50IHdoZW4gdGhlIGN1cnJlbnQgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGxhc3QgZW1pdHRlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fZW1pdElucHV0RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9IHRoaXMuX2xhc3RJbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudCA9IHRoaXMuX2NyZWF0ZUNoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0SW5wdXRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aWNrcyBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHdpZHRoIG9mIHRoZSBzbGlkZXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX3VwZGF0ZVRpY2tJbnRlcnZhbFBlcmNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy50aWNrSW50ZXJ2YWwgfHwgIXRoaXMuX3NsaWRlckRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aWNrSW50ZXJ2YWwgPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFja1NpemUgPSB0aGlzLnZlcnRpY2FsID8gdGhpcy5fc2xpZGVyRGltZW5zaW9ucy5oZWlnaHQgOiB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGl4ZWxzUGVyU3RlcCA9IHRyYWNrU2l6ZSAqIHRoaXMuc3RlcCAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ZXBzUGVyVGljayA9IE1hdGguY2VpbChNSU5fQVVUT19USUNLX1NFUEFSQVRJT04gLyBwaXhlbHNQZXJTdGVwKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpeGVsc1BlclRpY2sgPSBzdGVwc1BlclRpY2sgKiB0aGlzLnN0ZXA7XG4gICAgICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWxQZXJjZW50ID0gcGl4ZWxzUGVyVGljayAvIHRyYWNrU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbFBlcmNlbnQgPSB0aGlzLnRpY2tJbnRlcnZhbCAqIHRoaXMuc3RlcCAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWRlciBjaGFuZ2Ugb2JqZWN0IGZyb20gdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9jcmVhdGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHRoaXMudmFsdWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSBuZXcgTWRTbGlkZXJDaGFuZ2UoKTtcbiAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcztcbiAgICAgICAgZXZlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcGVyY2VudGFnZSBvZiB0aGUgc2xpZGVyIHRoYXQgYSB2YWx1ZSBpcy5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX2NhbGN1bGF0ZVBlcmNlbnRhZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgodmFsdWUgfHwgMCkgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB2YWx1ZSBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHNsaWRlciBjb3JyZXNwb25kcyB0by5cbiAgICAgKiBAcGFyYW0gez99IHBlcmNlbnRhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlVmFsdWUgPSBmdW5jdGlvbiAocGVyY2VudGFnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4gKyBwZXJjZW50YWdlICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbnVtYmVyIGJldHdlZW4gdHdvIG51bWJlcnMuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IG1pblxuICAgICAqIEBwYXJhbSB7Pz19IG1heFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9jbGFtcCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdm9pZCAwKSB7IG1pbiA9IDA7IH1cbiAgICAgICAgaWYgKG1heCA9PT0gdm9pZCAwKSB7IG1heCA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW9kZWwgdmFsdWUuIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gZWIgdHJpZ2dlcmVkIHdoZW4gdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBmbiBDYWxsYmFjayB0byBiZSByZWdpc3RlcmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB0b3VjaGVkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHs/fSBmbiBDYWxsYmFjayB0byBiZSByZWdpc3RlcmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gTWRTbGlkZXI7XG59KF9NZFNsaWRlck1peGluQmFzZSkpO1xuTWRTbGlkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1zbGlkZXIsIG1hdC1zbGlkZXInLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01EX1NMSURFUl9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnKGZvY3VzKSc6ICdfb25Gb2N1cygpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdfb25CbHVyKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdfb25DbGljaygkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duKSc6ICdfb25LZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgICAgICAnKGtleXVwKSc6ICdfb25LZXl1cCgpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhtb3VzZWVudGVyKSc6ICdfb25Nb3VzZWVudGVyKCknLFxuICAgICAgICAgICAgICAgICAgICAnKHNsaWRlKSc6ICdfb25TbGlkZSgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhzbGlkZWVuZCknOiAnX29uU2xpZGVFbmQoKScsXG4gICAgICAgICAgICAgICAgICAgICcoc2xpZGVzdGFydCknOiAnX29uU2xpZGVTdGFydCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1zbGlkZXInLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdzbGlkZXInLFxuICAgICAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbWF4XSc6ICdtYXgnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS12YWx1ZW1pbl0nOiAnbWluJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVub3ddJzogJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtb3JpZW50YXRpb25dJzogJ3ZlcnRpY2FsID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wcmltYXJ5XSc6ICdjb2xvciA9PSBcInByaW1hcnlcIicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWFjY2VudF0nOiAnY29sb3IgIT0gXCJwcmltYXJ5XCIgJiYgY29sb3IgIT0gXCJ3YXJuXCInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC13YXJuXSc6ICdjb2xvciA9PSBcIndhcm5cIicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItaGFzLXRpY2tzXSc6ICd0aWNrSW50ZXJ2YWwnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItaG9yaXpvbnRhbF0nOiAnIXZlcnRpY2FsJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGVyLWF4aXMtaW52ZXJ0ZWRdJzogJ19pbnZlcnRBeGlzJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGVyLXNsaWRpbmddJzogJ19pc1NsaWRpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZ10nOiAndGh1bWJMYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci12ZXJ0aWNhbF0nOiAndmVydGljYWwnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItbWluLXZhbHVlXSc6ICdfaXNNaW5WYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1oaWRlLWxhc3QtdGlja10nOiAnZGlzYWJsZWQgfHwgX2lzTWluVmFsdWUgJiYgX3RodW1iR2FwICYmIF9pbnZlcnRBeGlzJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItd3JhcHBlclxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10cmFjay13cmFwcGVyXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmRcXFwiIFtuZ1N0eWxlXT1cXFwiX3RyYWNrQmFja2dyb3VuZFN0eWxlc1xcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10cmFjay1maWxsXFxcIiBbbmdTdHlsZV09XFxcIl90cmFja0ZpbGxTdHlsZXNcXFwiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItdGlja3MtY29udGFpbmVyXFxcIiBbbmdTdHlsZV09XFxcIl90aWNrc0NvbnRhaW5lclN0eWxlc1xcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10aWNrc1xcXCIgW25nU3R5bGVdPVxcXCJfdGlja3NTdHlsZXNcXFwiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItdGh1bWItY29udGFpbmVyXFxcIiBbbmdTdHlsZV09XFxcIl90aHVtYkNvbnRhaW5lclN0eWxlc1xcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci1mb2N1cy1yaW5nXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGVyLXRodW1iXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGVyLXRodW1iLWxhYmVsXFxcIj48c3BhbiBjbGFzcz1cXFwibWF0LXNsaWRlci10aHVtYi1sYWJlbC10ZXh0XFxcIj57e2Rpc3BsYXlWYWx1ZX19PC9zcGFuPjwvZGl2PjwvZGl2PjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1zbGlkZXJ7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmU7Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6OHB4O291dGxpbmU6MDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm1hdC1zbGlkZXItd3JhcHBlcntwb3NpdGlvbjphYnNvbHV0ZX0ubWF0LXNsaWRlci10cmFjay13cmFwcGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtvdmVyZmxvdzpoaWRkZW59Lm1hdC1zbGlkZXItdHJhY2stZmlsbHtwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm0tb3JpZ2luOjAgMDt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYmFja2dyb3VuZC1jb2xvciAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZHtwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm0tb3JpZ2luOjEwMCUgMTAwJTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYmFja2dyb3VuZC1jb2xvciAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItdGlja3MtY29udGFpbmVye3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDtvdmVyZmxvdzpoaWRkZW59Lm1hdC1zbGlkZXItdGlja3N7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0O2JhY2tncm91bmQtY2xpcDpjb250ZW50LWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItdGh1bWItY29udGFpbmVye3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItZm9jdXMtcmluZ3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDozMHB4O2hlaWdodDozMHB4O2JvcmRlci1yYWRpdXM6NTAlO3RyYW5zZm9ybTpzY2FsZSgwKTtvcGFjaXR5OjA7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJhY2tncm91bmQtY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLG9wYWNpdHkgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5jZGsta2V5Ym9hcmQtZm9jdXNlZCAubWF0LXNsaWRlci1mb2N1cy1yaW5ne3RyYW5zZm9ybTpzY2FsZSgxKTtvcGFjaXR5OjF9Lm1hdC1zbGlkZXI6bm90KC5tYXQtc2xpZGVyLWRpc2FibGVkKSAubWF0LXNsaWRlci10aHVtYiwubWF0LXNsaWRlcjpub3QoLm1hdC1zbGlkZXItZGlzYWJsZWQpIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse2N1cnNvcjotd2Via2l0LWdyYWI7Y3Vyc29yOmdyYWJ9Lm1hdC1zbGlkZXItc2xpZGluZzpub3QoLm1hdC1zbGlkZXItZGlzYWJsZWQpIC5tYXQtc2xpZGVyLXRodW1iLC5tYXQtc2xpZGVyLXNsaWRpbmc6bm90KC5tYXQtc2xpZGVyLWRpc2FibGVkKSAubWF0LXNsaWRlci10aHVtYi1sYWJlbCwubWF0LXNsaWRlcjpub3QoLm1hdC1zbGlkZXItZGlzYWJsZWQpIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVsOmFjdGl2ZSwubWF0LXNsaWRlcjpub3QoLm1hdC1zbGlkZXItZGlzYWJsZWQpIC5tYXQtc2xpZGVyLXRodW1iOmFjdGl2ZXtjdXJzb3I6LXdlYmtpdC1ncmFiYmluZztjdXJzb3I6Z3JhYmJpbmd9Lm1hdC1zbGlkZXItdGh1bWJ7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTEwcHg7Ym90dG9tOi0xMHB4O2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JvcmRlcjozcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJhZGl1czo1MCU7dHJhbnNmb3JtOnNjYWxlKC43KTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYmFja2dyb3VuZC1jb2xvciAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYm9yZGVyLWNvbG9yIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LXNsaWRlci10aHVtYi1sYWJlbHtkaXNwbGF5Om5vbmU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MjhweDtoZWlnaHQ6MjhweDtib3JkZXItcmFkaXVzOjUwJTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYm9yZGVyLXJhZGl1cyAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYmFja2dyb3VuZC1jb2xvciAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItdGh1bWItbGFiZWwtdGV4dHt6LWluZGV4OjE7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItc2xpZGluZyAubWF0LXNsaWRlci10aHVtYi1jb250YWluZXIsLm1hdC1zbGlkZXItc2xpZGluZyAubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5kLC5tYXQtc2xpZGVyLXNsaWRpbmcgLm1hdC1zbGlkZXItdHJhY2stZmlsbHt0cmFuc2l0aW9uLWR1cmF0aW9uOjBzfS5tYXQtc2xpZGVyLWhhcy10aWNrcyAubWF0LXNsaWRlci13cmFwcGVyOjphZnRlcntjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO2JvcmRlci13aWR0aDowO2JvcmRlci1zdHlsZTpzb2xpZDtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LXNsaWRlci1oYXMtdGlja3MuY2RrLWZvY3VzZWQ6bm90KC5tYXQtc2xpZGVyLWhpZGUtbGFzdC10aWNrKSAubWF0LXNsaWRlci13cmFwcGVyOjphZnRlciwubWF0LXNsaWRlci1oYXMtdGlja3M6aG92ZXI6bm90KC5tYXQtc2xpZGVyLWhpZGUtbGFzdC10aWNrKSAubWF0LXNsaWRlci13cmFwcGVyOjphZnRlcntvcGFjaXR5OjF9Lm1hdC1zbGlkZXItaGFzLXRpY2tzLmNkay1mb2N1c2VkOm5vdCgubWF0LXNsaWRlci1kaXNhYmxlZCkgLm1hdC1zbGlkZXItdGlja3MsLm1hdC1zbGlkZXItaGFzLXRpY2tzOmhvdmVyOm5vdCgubWF0LXNsaWRlci1kaXNhYmxlZCkgLm1hdC1zbGlkZXItdGlja3N7b3BhY2l0eToxfS5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXNob3dpbmcgLm1hdC1zbGlkZXItZm9jdXMtcmluZ3t0cmFuc2Zvcm06c2NhbGUoMCk7b3BhY2l0eTowfS5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXNob3dpbmcgLm1hdC1zbGlkZXItdGh1bWItbGFiZWx7ZGlzcGxheTpmbGV4fS5tYXQtc2xpZGVyLWF4aXMtaW52ZXJ0ZWQgLm1hdC1zbGlkZXItdHJhY2stZmlsbHt0cmFuc2Zvcm0tb3JpZ2luOjEwMCUgMTAwJX0ubWF0LXNsaWRlci1heGlzLWludmVydGVkIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmR7dHJhbnNmb3JtLW9yaWdpbjowIDB9LmNkay1mb2N1c2VkLm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZyAubWF0LXNsaWRlci10aHVtYnt0cmFuc2Zvcm06c2NhbGUoMCl9LmNkay1mb2N1c2VkIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse2JvcmRlci1yYWRpdXM6NTAlIDUwJSAwfS5jZGstZm9jdXNlZCAubWF0LXNsaWRlci10aHVtYi1sYWJlbC10ZXh0e29wYWNpdHk6MX0uY2RrLW1vdXNlLWZvY3VzZWQgLm1hdC1zbGlkZXItdGh1bWIsLmNkay1wcm9ncmFtLWZvY3VzZWQgLm1hdC1zbGlkZXItdGh1bWIsLmNkay10b3VjaC1mb2N1c2VkIC5tYXQtc2xpZGVyLXRodW1ie2JvcmRlci13aWR0aDoycHg7dHJhbnNmb3JtOnNjYWxlKDEpfS5tYXQtc2xpZGVyLWRpc2FibGVkIC5tYXQtc2xpZGVyLWZvY3VzLXJpbmd7dHJhbnNmb3JtOnNjYWxlKDApO29wYWNpdHk6MH0ubWF0LXNsaWRlci1kaXNhYmxlZCAubWF0LXNsaWRlci10aHVtYntib3JkZXItd2lkdGg6NHB4O3RyYW5zZm9ybTpzY2FsZSguNSl9Lm1hdC1zbGlkZXItZGlzYWJsZWQgLm1hdC1zbGlkZXItdGh1bWItbGFiZWx7ZGlzcGxheTpub25lfS5tYXQtc2xpZGVyLWhvcml6b250YWx7aGVpZ2h0OjQ4cHg7bWluLXdpZHRoOjEyOHB4fS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItd3JhcHBlcntoZWlnaHQ6MnB4O3RvcDoyM3B4O2xlZnQ6OHB4O3JpZ2h0OjhweH0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXdyYXBwZXI6OmFmdGVye2hlaWdodDoycHg7Ym9yZGVyLWxlZnQtd2lkdGg6MnB4O3JpZ2h0OjA7dG9wOjB9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10cmFjay13cmFwcGVye2hlaWdodDoycHg7d2lkdGg6MTAwJX0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRyYWNrLWZpbGx7aGVpZ2h0OjJweDt3aWR0aDoxMDAlO3RyYW5zZm9ybTpzY2FsZVgoMCl9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5ke2hlaWdodDoycHg7d2lkdGg6MTAwJTt0cmFuc2Zvcm06c2NhbGVYKDEpfS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdGlja3MtY29udGFpbmVye2hlaWdodDoycHg7d2lkdGg6MTAwJX0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRpY2tze2hlaWdodDoycHg7d2lkdGg6MTAwJX0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRodW1iLWNvbnRhaW5lcnt3aWR0aDoxMDAlO2hlaWdodDowO3RvcDo1MCV9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci1mb2N1cy1yaW5ne3RvcDotMTVweDtyaWdodDotMTVweH0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse3JpZ2h0Oi0xNHB4O3RvcDotNDBweDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgyNnB4KSBzY2FsZSguMDEpIHJvdGF0ZSg0NWRlZyl9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10aHVtYi1sYWJlbC10ZXh0e3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0ubWF0LXNsaWRlci1ob3Jpem9udGFsLmNkay1mb2N1c2VkIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5tYXQtc2xpZGVyLXZlcnRpY2Fse3dpZHRoOjQ4cHg7bWluLWhlaWdodDoxMjhweH0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci13cmFwcGVye3dpZHRoOjJweDt0b3A6OHB4O2JvdHRvbTo4cHg7bGVmdDoyM3B4fS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXdyYXBwZXI6OmFmdGVye3dpZHRoOjJweDtib3JkZXItdG9wLXdpZHRoOjJweDtib3R0b206MDtsZWZ0OjB9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdHJhY2std3JhcHBlcntoZWlnaHQ6MTAwJTt3aWR0aDoycHh9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdHJhY2stZmlsbHtoZWlnaHQ6MTAwJTt3aWR0aDoycHg7dHJhbnNmb3JtOnNjYWxlWSgwKX0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5ke2hlaWdodDoxMDAlO3dpZHRoOjJweDt0cmFuc2Zvcm06c2NhbGVZKDEpfS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXRpY2tzLWNvbnRhaW5lcnt3aWR0aDoycHg7aGVpZ2h0OjEwMCV9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItZm9jdXMtcmluZ3tib3R0b206LTE1cHg7bGVmdDotMTVweH0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10aWNrc3t3aWR0aDoycHg7aGVpZ2h0OjEwMCV9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdGh1bWItY29udGFpbmVye2hlaWdodDoxMDAlO3dpZHRoOjA7bGVmdDo1MCV9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdGh1bWItbGFiZWx7Ym90dG9tOi0xNHB4O2xlZnQ6LTQwcHg7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMjZweCkgc2NhbGUoLjAxKSByb3RhdGUoLTQ1ZGVnKX0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10aHVtYi1sYWJlbC10ZXh0e3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5tYXQtc2xpZGVyLXZlcnRpY2FsLmNkay1mb2N1c2VkIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX1bZGlyPXJ0bF0gLm1hdC1zbGlkZXItd3JhcHBlcjo6YWZ0ZXJ7bGVmdDowO3JpZ2h0OmF1dG99W2Rpcj1ydGxdIC5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdHJhY2stZmlsbHt0cmFuc2Zvcm0tb3JpZ2luOjEwMCUgMTAwJX1bZGlyPXJ0bF0gLm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5ke3RyYW5zZm9ybS1vcmlnaW46MCAwfVtkaXI9cnRsXSAubWF0LXNsaWRlci1ob3Jpem9udGFsLm1hdC1zbGlkZXItYXhpcy1pbnZlcnRlZCAubWF0LXNsaWRlci10cmFjay1maWxse3RyYW5zZm9ybS1vcmlnaW46MCAwfVtkaXI9cnRsXSAubWF0LXNsaWRlci1ob3Jpem9udGFsLm1hdC1zbGlkZXItYXhpcy1pbnZlcnRlZCAubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5ke3RyYW5zZm9ybS1vcmlnaW46MTAwJSAxMDAlfVwiXSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNsaWRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c09yaWdpbk1vbml0b3IsIH0sXG4gICAgeyB0eXBlOiBEaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG5dOyB9O1xuTWRTbGlkZXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2ludmVydCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbWF4JzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdtaW4nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3N0ZXAnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3RodW1iTGFiZWwnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ190aHVtYkxhYmVsRGVwcmVjYXRlZCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ3RodW1iLWxhYmVsJyxdIH0sXSxcbiAgICAndGlja0ludGVydmFsJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdfdGlja0ludGVydmFsRGVwcmVjYXRlZCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ3RpY2staW50ZXJ2YWwnLF0gfSxdLFxuICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndmVydGljYWwnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NvbG9yJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdjaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdpbnB1dCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBSZW5kZXJlciBjbGFzcyBpbiBvcmRlciB0byBrZWVwIGFsbCBkb20gbWFuaXB1bGF0aW9uIGluIG9uZSBwbGFjZSBhbmQgb3V0c2lkZSBvZiB0aGUgbWFpbiBjbGFzcy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgU2xpZGVyUmVuZGVyZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTbGlkZXJSZW5kZXJlcihlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3NsaWRlckVsZW1lbnQgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgdGhlIHNsaWRlciB0cmFjayBlbGVtZW50LlxuICAgICAqIFRoZSB0cmFjayBpcyB1c2VkIHJhdGhlciB0aGFuIHRoZSBuYXRpdmUgZWxlbWVudCB0byBpZ25vcmUgdGhlIGV4dHJhIHNwYWNlIHRoYXQgdGhlIHRodW1iIGNhblxuICAgICAqIHRha2UgdXAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTbGlkZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2xpZGVyRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd3JhcHBlckVsZW1lbnQgPSB0aGlzLl9zbGlkZXJFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYXQtc2xpZGVyLXdyYXBwZXInKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXJFbGVtZW50ID8gd3JhcHBlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbmF0aXZlIGVsZW1lbnQuXG4gICAgICogQ3VycmVudGx5IG9ubHkgdXNlZCB0byBhbGxvdyBhIGJsdXIgZXZlbnQgdG8gZmlyZSBidXQgd2lsbCBiZSB1c2VkIHdpdGgga2V5Ym9hcmQgaW5wdXQgbGF0ZXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTbGlkZXJSZW5kZXJlci5wcm90b3R5cGUuYWRkRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NsaWRlckVsZW1lbnQuZm9jdXMoKTtcbiAgICB9O1xuICAgIHJldHVybiBTbGlkZXJSZW5kZXJlcjtcbn0oKSk7XG52YXIgTWRTbGlkZXJNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNsaWRlck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kU2xpZGVyTW9kdWxlO1xufSgpKTtcbk1kU2xpZGVyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgTWRDb21tb25Nb2R1bGUsIFN0eWxlTW9kdWxlLCBCaWRpTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRTbGlkZXIsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNsaWRlcl0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBIQU1NRVJfR0VTVFVSRV9DT05GSUcsIHVzZUNsYXNzOiBHZXN0dXJlQ29uZmlnIH1dXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU2xpZGVyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiB0d28gTWRTaWRlbmF2IGFyZSBtYXRjaGluZyB0aGUgc2FtZSBzaWRlLlxuICogQHBhcmFtIHs/fSBhbGlnblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGhyb3dNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IoYWxpZ24pIHtcbiAgICB0aHJvdyBFcnJvcihcIkEgc2lkZW5hdiB3YXMgYWxyZWFkeSBkZWNsYXJlZCBmb3IgJ2FsaWduPVxcXCJcIiArIGFsaWduICsgXCJcXFwiJ1wiKTtcbn1cbi8qKlxuICogU2lkZW5hdiB0b2dnbGUgcHJvbWlzZSByZXN1bHQuXG4gKi9cbnZhciBNZFNpZGVuYXZUb2dnbGVSZXN1bHQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGFuaW1hdGlvbkZpbmlzaGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRTaWRlbmF2VG9nZ2xlUmVzdWx0KHR5cGUsIGFuaW1hdGlvbkZpbmlzaGVkKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRmluaXNoZWQgPSBhbmltYXRpb25GaW5pc2hlZDtcbiAgICB9XG4gICAgcmV0dXJuIE1kU2lkZW5hdlRvZ2dsZVJlc3VsdDtcbn0oKSk7XG4vKipcbiAqIDxtZC1zaWRlbmF2PiBjb21wb25lbnQuXG4gKlxuICogVGhpcyBjb21wb25lbnQgY29ycmVzcG9uZHMgdG8gdGhlIGRyYXdlciBvZiB0aGUgc2lkZW5hdi5cbiAqXG4gKiBQbGVhc2UgcmVmZXIgdG8gUkVBRE1FLm1kIGZvciBleGFtcGxlcyBvbiBob3cgdG8gdXNlIGl0LlxuICovXG52YXIgTWRTaWRlbmF2ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZiBUaGUgRE9NIGVsZW1lbnQgcmVmZXJlbmNlLiBVc2VkIGZvciB0cmFuc2l0aW9uIGFuZCB3aWR0aCBjYWxjdWxhdGlvbi5cbiAgICAgKiAgICAgSWYgbm90IGF2YWlsYWJsZSB3ZSBkbyBub3QgaG9vayBvbiB0cmFuc2l0aW9ucy5cbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c1RyYXBGYWN0b3J5XG4gICAgICogQHBhcmFtIHs/fSBfZG9jXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRTaWRlbmF2KF9lbGVtZW50UmVmLCBfZm9jdXNUcmFwRmFjdG9yeSwgX2RvYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkgPSBfZm9jdXNUcmFwRmFjdG9yeTtcbiAgICAgICAgdGhpcy5fZG9jID0gX2RvYztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWdubWVudCBvZiB0aGUgc2lkZW5hdiAoZGlyZWN0aW9uIG5ldXRyYWwpOyB3aGV0aGVyICdzdGFydCcgb3IgJ2VuZCcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlIG9mIHRoZSBzaWRlbmF2OyBvbmUgb2YgJ292ZXInLCAncHVzaCcgb3IgJ3NpZGUnLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb2RlID0gJ292ZXInO1xuICAgICAgICB0aGlzLl9kaXNhYmxlQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHNpZGVuYXYgaXMgb3BlbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3BlbmVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgaXMgYmVpbmcgb3BlbmVkLiBVc2UgdGhpcyB0byBzeW5jaHJvbml6ZSBhbmltYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbk9wZW5TdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2lkZW5hdiBpcyBmdWxseSBvcGVuZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uT3BlbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2lkZW5hdiBpcyBiZWluZyBjbG9zZWQuIFVzZSB0aGlzIHRvIHN5bmNocm9uaXplIGFuaW1hdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQ2xvc2VTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2lkZW5hdiBpcyBmdWxseSBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgYWxpZ25tZW50IGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQWxpZ25DaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgdG9nZ2xlIGFuaW1hdGlvbiBwcm9taXNlLiBgbnVsbGAgaWYgbm8gYW5pbWF0aW9uIGlzIGluIHByb2dyZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCB0b2dnbGUgYW5pbWF0aW9uIHByb21pc2UgcmVzb2x1dGlvbiBmdW5jdGlvbi5cbiAgICAgICAgICogYG51bGxgIGlmIG5vIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVTaWRlbmF2V2FzT3BlbmVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbk9wZW4uc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fZG9jKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlU2lkZW5hdldhc09wZW5lZCA9IF90aGlzLl9kb2MuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0ZvY3VzVHJhcEVuYWJsZWQgJiYgX3RoaXMuX2ZvY3VzVHJhcCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9mb2N1c1RyYXAuZm9jdXNJbml0aWFsRWxlbWVudFdoZW5SZWFkeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkNsb3NlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcmVzdG9yZUZvY3VzKCk7IH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJhbGlnblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXJlY3Rpb24gd2hpY2ggdGhlIHNpZGVuYXYgaXMgYWxpZ25lZCBpbi5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWxpZ247IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSB2YWxpZCB2YWx1ZS5cbiAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID09ICdlbmQnKSA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSB0aGlzLl9hbGlnbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsaWduID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFsaWduQ2hhbmdlZC5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcImRpc2FibGVDbG9zZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzaWRlbmF2IGNhbiBiZSBjbG9zZWQgd2l0aCB0aGUgZXNjYXBlIGtleSBvciBub3QuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVDbG9zZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVDbG9zZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcImlzRm9jdXNUcmFwRW5hYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUaGUgZm9jdXMgdHJhcCBpcyBvbmx5IGVuYWJsZWQgd2hlbiB0aGUgc2lkZW5hdiBpcyBvcGVuIGluIGFueSBtb2RlIG90aGVyIHRoYW4gc2lkZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5lZCAmJiB0aGlzLm1vZGUgIT09ICdzaWRlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSWYgZm9jdXMgaXMgY3VycmVudGx5IGluc2lkZSB0aGUgc2lkZW5hdiwgcmVzdG9yZXMgaXQgdG8gd2hlcmUgaXQgd2FzIGJlZm9yZSB0aGUgc2lkZW5hdlxuICAgICAqIG9wZW5lZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUuX3Jlc3RvcmVGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWN0aXZlRWwgPSB0aGlzLl9kb2MgJiYgdGhpcy5fZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChhY3RpdmVFbCAmJiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoYWN0aXZlRWwpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVTaWRlbmF2V2FzT3BlbmVkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZVNpZGVuYXZXYXNPcGVuZWQuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVTaWRlbmF2V2FzT3BlbmVkID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcC5lbmFibGVkID0gdGhpcy5pc0ZvY3VzVHJhcEVuYWJsZWQ7XG4gICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSBzaWRlbmF2IGlzIHNldCB0byBvcGVuZWQgaW5cbiAgICAgICAgLy8gdGhlIHRlbXBsYXRlIGFuZCB0aGUgdHJhbnNpdGlvbiBoYXNuJ3QgZW5kZWQuXG4gICAgICAgIGlmICh0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlICYmIHRoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UgPSB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzVHJhcCkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNUcmFwLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwib3BlbmVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHNpZGVuYXYgaXMgb3BlbmVkLiBXZSBvdmVybG9hZCB0aGlzIGJlY2F1c2Ugd2UgdHJpZ2dlciBhbiBldmVudCB3aGVuIGl0XG4gICAgICAgICAqIHN0YXJ0cyBvciBlbmQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29wZW5lZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoY29lcmNlQm9vbGVhblByb3BlcnR5KHYpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGlzIHNpZGVuYXYsIGFuZCByZXR1cm4gYSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gaXQncyBmdWxseSBvcGVuZWQgKG9yIGdldFxuICAgICAqIHJlamVjdGVkIGlmIGl0IGRpZG4ndCkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXYucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZSh0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlIHRoaXMgc2lkZW5hdiwgYW5kIHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiBpdCdzIGZ1bGx5IGNsb3NlZCAob3IgZ2V0XG4gICAgICogcmVqZWN0ZWQgaWYgaXQgZGlkbid0KS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhpcyBzaWRlbmF2LiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBvcGVuKCkgd2hlbiBpdCdzIGFscmVhZHkgb3BlbmVkLCBvclxuICAgICAqIGNsb3NlKCkgd2hlbiBpdCdzIGNsb3NlZC5cbiAgICAgKiBAcGFyYW0gez89fSBpc09wZW4gV2hldGhlciB0aGUgc2lkZW5hdiBzaG91bGQgYmUgb3Blbi5cbiAgICAgKiBAcmV0dXJuIHs/fSBSZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2Ygd2hldGhlciB0aGUgc2lkZW5hdiB3YXMgb3BlbmVkIG9yIGNsb3NlZC5cbiAgICAgKi9cbiAgICBNZFNpZGVuYXYucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChpc09wZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGlzT3BlbiA9PT0gdm9pZCAwKSB7IGlzT3BlbiA9ICF0aGlzLm9wZW5lZDsgfVxuICAgICAgICAvLyBTaG9ydGN1dCBpdCBpZiB3ZSdyZSBhbHJlYWR5IG9wZW5lZC5cbiAgICAgICAgaWYgKGlzT3BlbiA9PT0gdGhpcy5vcGVuZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlIHx8XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG5ldyBNZFNpZGVuYXZUb2dnbGVSZXN1bHQoaXNPcGVuID8gJ29wZW4nIDogJ2Nsb3NlJywgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5lZCA9IGlzT3BlbjtcbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzVHJhcCkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNUcmFwLmVuYWJsZWQgPSB0aGlzLmlzRm9jdXNUcmFwRW5hYmxlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3BlblN0YXJ0LmVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZVN0YXJ0LmVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSAmJiB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVRvZ2dsZUFuaW1hdGlvblByb21pc2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlID0gZnVuY3Rpb24gKGFuaW1hdGlvbkZpbmlzaGVkKSB7IHJldHVybiByZXNvbHZlKG5ldyBNZFNpZGVuYXZUb2dnbGVSZXN1bHQoaXNPcGVuID8gJ29wZW4nIDogJ2Nsb3NlJywgYW5pbWF0aW9uRmluaXNoZWQpKTsgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUga2V5Ym9hcmQgZXZlbnRzLlxuICAgICAqIFxcQGRvY3MtcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUuaGFuZGxlS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFICYmICF0aGlzLmRpc2FibGVDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdHJhbnNpdGlvbiBoYXMgZmluaXNoZWQsIHNldCB0aGUgaW50ZXJuYWwgc3RhdGUgZm9yIGNsYXNzZXMgYW5kIGVtaXQgdGhlIHByb3BlciBldmVudC5cbiAgICAgKiBUaGUgZXZlbnQgcGFzc2VkIGlzIGFjdHVhbGx5IG9mIHR5cGUgVHJhbnNpdGlvbkV2ZW50LCBidXQgdGhhdCB0eXBlIGlzIG5vdCBhdmFpbGFibGUgaW5cbiAgICAgKiBBbmRyb2lkIHNvIHdlIHVzZSBhbnkuXG4gICAgICogQHBhcmFtIHs/fSB0cmFuc2l0aW9uRXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUuX29uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uRXZlbnQpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25FdmVudC50YXJnZXQgPT0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50XG4gICAgICAgICAgICAmJiB0cmFuc2l0aW9uRXZlbnQucHJvcGVydHlOYW1lLmVuZHNXaXRoKCd0cmFuc2Zvcm0nKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wZW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25PcGVuLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSAmJiB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UgPSB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc0Nsb3NpbmdcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9vcGVuZWQgJiYgISF0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNPcGVuaW5nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcGVuZWQgJiYgISF0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNDbG9zZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9vcGVuZWQgJiYgIXRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc09wZW5lZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3BlbmVkICYmICF0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNFbmRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ24gPT0gJ2VuZCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9tb2RlU2lkZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdzaWRlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX21vZGVPdmVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT0gJ292ZXInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfbW9kZVB1c2hcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PSAncHVzaCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl93aWR0aFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTWRTaWRlbmF2O1xufSgpKTtcbk1kU2lkZW5hdi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLXNpZGVuYXYsIG1hdC1zaWRlbmF2JyxcbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1tYWxlcmJhKTogbW92ZSB0ZW1wbGF0ZSB0byBzZXBhcmF0ZSBmaWxlLlxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtc2lkZW5hdicsXG4gICAgICAgICAgICAgICAgICAgICcodHJhbnNpdGlvbmVuZCknOiAnX29uVHJhbnNpdGlvbkVuZCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duKSc6ICdoYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBhbGlnbmluZyB0ZXh0IGJhc2VkIG9uIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hbGlnbl0nOiAnbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtY2xvc2VkXSc6ICdfaXNDbG9zZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LWNsb3NpbmddJzogJ19pc0Nsb3NpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LWVuZF0nOiAnX2lzRW5kJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1vcGVuZWRdJzogJ19pc09wZW5lZCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtb3BlbmluZ10nOiAnX2lzT3BlbmluZycsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtb3Zlcl0nOiAnX21vZGVPdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1wdXNoXSc6ICdfbW9kZVB1c2gnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LXNpZGVdJzogJ19tb2RlU2lkZScsXG4gICAgICAgICAgICAgICAgICAgICd0YWJJbmRleCc6ICctMSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU2lkZW5hdi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c1RyYXBGYWN0b3J5LCB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0RPQ1VNRU5ULF0gfSxdIH0sXG5dOyB9O1xuTWRTaWRlbmF2LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdhbGlnbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbW9kZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGlzYWJsZUNsb3NlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdvbk9wZW5TdGFydCc6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydvcGVuLXN0YXJ0JyxdIH0sXSxcbiAgICAnb25PcGVuJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ29wZW4nLF0gfSxdLFxuICAgICdvbkNsb3NlU3RhcnQnOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnY2xvc2Utc3RhcnQnLF0gfSxdLFxuICAgICdvbkNsb3NlJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2Nsb3NlJyxdIH0sXSxcbiAgICAnb25BbGlnbkNoYW5nZWQnOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnYWxpZ24tY2hhbmdlZCcsXSB9LF0sXG4gICAgJ29wZW5lZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG4vKipcbiAqIDxtZC1zaWRlbmF2LWNvbnRhaW5lcj4gY29tcG9uZW50LlxuICpcbiAqIFRoaXMgaXMgdGhlIHBhcmVudCBjb21wb25lbnQgdG8gb25lIG9yIHR3byA8bWQtc2lkZW5hdj5zIHRoYXQgdmFsaWRhdGVzIHRoZSBzdGF0ZSBpbnRlcm5hbGx5XG4gKiBhbmQgY29vcmRpbmF0ZXMgdGhlIGJhY2tkcm9wIGFuZCBjb250ZW50IHN0eWxpbmcuXG4gKi9cbnZhciBNZFNpZGVuYXZDb250YWluZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kaXJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFNpZGVuYXZDb250YWluZXIoX2RpciwgX2VsZW1lbnQsIF9yZW5kZXJlciwgX25nWm9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzaWRlbmF2IGJhY2tkcm9wIGlzIGNsaWNrZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhY2tkcm9wQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBvcGVuL2Nsb3NlIHRyYW50aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2VuYWJsZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICAgIC8vIElmIGEgYERpcmAgZGlyZWN0aXZlIGV4aXN0cyB1cCB0aGUgdHJlZSwgbGlzdGVuIGRpcmVjdGlvbiBjaGFuZ2VzIGFuZCB1cGRhdGUgdGhlIGxlZnQvcmlnaHRcbiAgICAgICAgLy8gcHJvcGVydGllcyB0byBwb2ludCB0byB0aGUgcHJvcGVyIHN0YXJ0L2VuZC5cbiAgICAgICAgaWYgKF9kaXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgX2Rpci5jaGFuZ2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92YWxpZGF0ZURyYXdlcnMoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUsIFwic3RhcnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpZGVuYXYgY2hpbGQgd2l0aCB0aGUgYHN0YXJ0YCBhbGlnbm1lbnQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZSwgXCJlbmRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpZGVuYXYgY2hpbGQgd2l0aCB0aGUgYGVuZGAgYWxpZ25tZW50LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbmQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE9uIGNoYW5nZXMsIGFzc2VydCBvbiBjb25zaXN0ZW5jeS5cbiAgICAgICAgdGhpcy5fc2lkZW5hdnMuY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3ZhbGlkYXRlRHJhd2VycygpOyB9KTtcbiAgICAgICAgdGhpcy5fc2lkZW5hdnMuZm9yRWFjaChmdW5jdGlvbiAoc2lkZW5hdikge1xuICAgICAgICAgICAgX3RoaXMuX3dhdGNoU2lkZW5hdlRvZ2dsZShzaWRlbmF2KTtcbiAgICAgICAgICAgIF90aGlzLl93YXRjaFNpZGVuYXZBbGlnbihzaWRlbmF2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlRHJhd2VycygpO1xuICAgICAgICAvLyBHaXZlIHRoZSB2aWV3IGEgY2hhbmNlIHRvIHJlbmRlciB0aGUgaW5pdGlhbCBzdGF0ZSwgdGhlbiBlbmFibGUgdHJhbnNpdGlvbnMuXG4gICAgICAgIGZpcnN0LmNhbGwodGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZW5hYmxlVHJhbnNpdGlvbnMgPSB0cnVlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxzIGBvcGVuYCBvZiBib3RoIHN0YXJ0IGFuZCBlbmQgc2lkZW5hdnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLl9zdGFydCwgdGhpcy5fZW5kXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc2lkZW5hdikgeyByZXR1cm4gc2lkZW5hdjsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNpZGVuYXYpIHsgcmV0dXJuICgoc2lkZW5hdikpLm9wZW4oKTsgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYGNsb3NlYCBvZiBib3RoIHN0YXJ0IGFuZCBlbmQgc2lkZW5hdnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpcy5fc3RhcnQsIHRoaXMuX2VuZF1cbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHNpZGVuYXYpIHsgcmV0dXJuIHNpZGVuYXY7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzaWRlbmF2KSB7IHJldHVybiAoKHNpZGVuYXYpKS5jbG9zZSgpOyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHNpZGVuYXYgZXZlbnRzIGluIG9yZGVyIHRvIHNldCBhIGNsYXNzIG9uIHRoZSBtYWluIGNvbnRhaW5lciBlbGVtZW50IHdoZW4gdGhlXG4gICAgICogc2lkZW5hdiBpcyBvcGVuIGFuZCB0aGUgYmFja2Ryb3AgaXMgdmlzaWJsZS4gVGhpcyBlbnN1cmVzIGFueSBvdmVyZmxvdyBvbiB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBpcyBwcm9wZXJseSBoaWRkZW4uXG4gICAgICogQHBhcmFtIHs/fSBzaWRlbmF2XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl93YXRjaFNpZGVuYXZUb2dnbGUgPSBmdW5jdGlvbiAoc2lkZW5hdikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXNpZGVuYXYgfHwgc2lkZW5hdi5tb2RlID09PSAnc2lkZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzaWRlbmF2Lm9uT3Blbi5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NldENvbnRhaW5lckNsYXNzKHRydWUpOyB9KTtcbiAgICAgICAgc2lkZW5hdi5vbkNsb3NlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc2V0Q29udGFpbmVyQ2xhc3MoZmFsc2UpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gc2lkZW5hdiBvbkFsaWduQ2hhbmdlZCBldmVudCBpbiBvcmRlciB0byByZS12YWxpZGF0ZSBkcmF3ZXJzIHdoZW4gdGhlIGFsaWduXG4gICAgICogY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gez99IHNpZGVuYXZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX3dhdGNoU2lkZW5hdkFsaWduID0gZnVuY3Rpb24gKHNpZGVuYXYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFzaWRlbmF2KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGVtcHR5IGJlZm9yZSB2YWxpZGF0aW5nLFxuICAgICAgICAvLyBzaW5jZSBib3RoIGRyYXdlcnMgbWF5IGJlIHN3YXBwaW5nIHNpZGVzIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgIHNpZGVuYXYub25BbGlnbkNoYW5nZWQuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpcnN0LmNhbGwoX3RoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5KS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3ZhbGlkYXRlRHJhd2VycygpOyB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSAnbWF0LXNpZGVuYXYtb3BlbmVkJyBjbGFzcyBvbiB0aGUgbWFpbiAnbWQtc2lkZW5hdi1jb250YWluZXInIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHs/fSBpc0FkZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fc2V0Q29udGFpbmVyQ2xhc3MgPSBmdW5jdGlvbiAoaXNBZGQpIHtcbiAgICAgICAgaWYgKGlzQWRkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtYXQtc2lkZW5hdi1vcGVuZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ21hdC1zaWRlbmF2LW9wZW5lZCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIHNpZGVuYXYgY2hpbGRyZW4gY29tcG9uZW50cy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX3ZhbGlkYXRlRHJhd2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9lbmQgPSBudWxsO1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIGF0IG1vc3Qgb25lIHN0YXJ0IGFuZCBvbmUgZW5kIHNpZGVuYXYuXG4gICAgICAgIC8vIE5PVEU6IFdlIG11c3QgY2FsbCB0b0FycmF5IG9uIF9zaWRlbmF2cyBldmVuIHRob3VnaCBpdCdzIGl0ZXJhYmxlXG4gICAgICAgIC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMTY0KS5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3NpZGVuYXZzLnRvQXJyYXkoKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzaWRlbmF2ID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKHNpZGVuYXYuYWxpZ24gPT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IoJ2VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9lbmQgPSBzaWRlbmF2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IoJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gc2lkZW5hdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yaWdodCA9IHRoaXMuX2xlZnQgPSBudWxsO1xuICAgICAgICAvLyBEZXRlY3QgaWYgd2UncmUgTFRSIG9yIFJUTC5cbiAgICAgICAgaWYgKHRoaXMuX2RpciA9PSBudWxsIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJykge1xuICAgICAgICAgICAgdGhpcy5fbGVmdCA9IHRoaXMuX3N0YXJ0O1xuICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSB0aGlzLl9lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sZWZ0ID0gdGhpcy5fZW5kO1xuICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSB0aGlzLl9zdGFydDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9vbkJhY2tkcm9wQ2xpY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5iYWNrZHJvcENsaWNrLmVtaXQoKTtcbiAgICAgICAgdGhpcy5fY2xvc2VNb2RhbFNpZGVuYXYoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fY2xvc2VNb2RhbFNpZGVuYXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENsb3NlIGFsbCBvcGVuIHNpZGVuYXYncyB3aGVyZSBjbG9zaW5nIGlzIG5vdCBkaXNhYmxlZCBhbmQgdGhlIG1vZGUgaXMgbm90IGBzaWRlYC5cbiAgICAgICAgW3RoaXMuX3N0YXJ0LCB0aGlzLl9lbmRdXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzaWRlbmF2KSB7IHJldHVybiBzaWRlbmF2ICYmICFzaWRlbmF2LmRpc2FibGVDbG9zZSAmJiBzaWRlbmF2Lm1vZGUgIT09ICdzaWRlJzsgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlbmF2KSB7IHJldHVybiAoKHNpZGVuYXYpKS5jbG9zZSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5faXNTaG93aW5nQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faXNTaWRlbmF2T3Blbih0aGlzLl9zdGFydCkgJiYgKCh0aGlzLl9zdGFydCkpLm1vZGUgIT0gJ3NpZGUnKVxuICAgICAgICAgICAgfHwgKHRoaXMuX2lzU2lkZW5hdk9wZW4odGhpcy5fZW5kKSAmJiAoKHRoaXMuX2VuZCkpLm1vZGUgIT0gJ3NpZGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2lkZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5faXNTaWRlbmF2T3BlbiA9IGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgIHJldHVybiBzaWRlICE9IG51bGwgJiYgc2lkZS5vcGVuZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBzaWRlbmF2LCBpZiBpdCdzIGluIHRoZSBwcm9wZXIgbW9kZSBhbmQgb3BlbmVkLlxuICAgICAqIFRoaXMgbWF5IHJlbGF5b3V0IHRoZSB2aWV3LCBzbyBkbyBub3QgY2FsbCB0aGlzIG9mdGVuLlxuICAgICAqIEBwYXJhbSB7P30gc2lkZW5hdlxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0U2lkZW5hdkVmZmVjdGl2ZVdpZHRoID0gZnVuY3Rpb24gKHNpZGVuYXYsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9pc1NpZGVuYXZPcGVuKHNpZGVuYXYpICYmIHNpZGVuYXYubW9kZSA9PSBtb2RlKSA/IHNpZGVuYXYuX3dpZHRoIDogMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0TWFyZ2luTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQgPyB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fbGVmdCwgJ3NpZGUnKSA6IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2dldE1hcmdpblJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQgPyB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fcmlnaHQsICdzaWRlJykgOiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9nZXRQb3NpdGlvbkxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWZ0ID8gdGhpcy5fZ2V0U2lkZW5hdkVmZmVjdGl2ZVdpZHRoKHRoaXMuX2xlZnQsICdwdXNoJykgOiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9nZXRQb3NpdGlvblJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQgPyB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fcmlnaHQsICdwdXNoJykgOiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaG9yaXpvbnRhbCBvZmZzZXQgZm9yIHRoZSBjb250ZW50IGFyZWEuICBUaGVyZSBzaG91bGQgbmV2ZXIgYmUgYSB2YWx1ZSBmb3IgYm90aFxuICAgICAqIGxlZnQgYW5kIHJpZ2h0LCBzbyBieSBzdWJ0cmFjdGluZyB0aGUgcmlnaHQgdmFsdWUgZnJvbSB0aGUgbGVmdCB2YWx1ZSwgd2Ugc2hvdWxkIGFsd2F5cyBnZXRcbiAgICAgKiB0aGUgYXBwcm9wcmlhdGUgb2Zmc2V0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0UG9zaXRpb25PZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQb3NpdGlvbkxlZnQoKSAtIHRoaXMuX2dldFBvc2l0aW9uUmlnaHQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNpbmcgW25nU3R5bGVdIHJhdGhlciB0aGFuIHNlcGFyYXRlIFtzdHlsZS4uLl0gcHJvcGVydGllcyBiZWNhdXNlIFtzdHlsZS50cmFuc2Zvcm1dXG4gICAgICogZG9lc24ndCBzZWVtIHRvIHdvcmsgcmlnaHQgbm93LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFyZ2luTGVmdDogdGhpcy5fZ2V0TWFyZ2luTGVmdCgpICsgXCJweFwiLFxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IHRoaXMuX2dldE1hcmdpblJpZ2h0KCkgKyBcInB4XCIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlM2QoXCIgKyB0aGlzLl9nZXRQb3NpdGlvbk9mZnNldCgpICsgXCJweCwgMCwgMClcIlxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE1kU2lkZW5hdkNvbnRhaW5lcjtcbn0oKSk7XG5NZFNpZGVuYXZDb250YWluZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1zaWRlbmF2LWNvbnRhaW5lciwgbWF0LXNpZGVuYXYtY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgdXNlIENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaC4gSXQgZG9lcyBub3Qgd29yayBmb3IgdGhpcyBjb21wb25lbnQgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHRlY2huaWNhbGx5IGl0IGlzIGEgc2libGluZyBvZiBNZFNpZGVuYXYgKG9uIHRoZSBjb250ZW50IHRyZWUpIGFuZCBpc24ndCB1cGRhdGVkIHdoZW4gTWRTaWRlbmF2XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlcyBpdHMgc3RhdGUuXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXNpZGVuYXYtYmFja2Ryb3BcXFwiIChjbGljayk9XFxcIl9vbkJhY2tkcm9wQ2xpY2tlZCgpXFxcIiBbY2xhc3MubWF0LXNpZGVuYXYtc2hvd25dPVxcXCJfaXNTaG93aW5nQmFja2Ryb3AoKVxcXCI+PC9kaXY+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1zaWRlbmF2LCBtYXQtc2lkZW5hdlxcXCI+PC9uZy1jb250ZW50PjxkaXYgY2xhc3M9XFxcIm1hdC1zaWRlbmF2LWNvbnRlbnRcXFwiIFtuZ1N0eWxlXT1cXFwiX2dldFN0eWxlcygpXFxcIiBjZGstc2Nyb2xsYWJsZT48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXNpZGVuYXYtY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7Ym94LXNpemluZzpib3JkZXItYm94Oy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO2Rpc3BsYXk6YmxvY2s7b3ZlcmZsb3c6aGlkZGVufS5tYXQtc2lkZW5hdi1jb250YWluZXJbZnVsbHNjcmVlbl17cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjB9Lm1hdC1zaWRlbmF2LWNvbnRhaW5lcltmdWxsc2NyZWVuXS5tYXQtc2lkZW5hdi1vcGVuZWR7b3ZlcmZsb3c6aGlkZGVufS5tYXQtc2lkZW5hdi1iYWNrZHJvcHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDtkaXNwbGF5OmJsb2NrO3otaW5kZXg6Mjt2aXNpYmlsaXR5OmhpZGRlbn0ubWF0LXNpZGVuYXYtYmFja2Ryb3AubWF0LXNpZGVuYXYtc2hvd257dmlzaWJpbGl0eTp2aXNpYmxlfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtc2lkZW5hdi1iYWNrZHJvcHtvcGFjaXR5Oi41fX0ubWF0LXNpZGVuYXYtY29udGVudHtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMCU7b3ZlcmZsb3c6YXV0b30ubWF0LXNpZGVuYXZ7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JvdHRvbTowO3otaW5kZXg6MzttaW4td2lkdGg6NXZ3O291dGxpbmU6MDtib3gtc2l6aW5nOmJvcmRlci1ib3g7aGVpZ2h0OjEwMCU7b3ZlcmZsb3cteTphdXRvO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMTAwJSwwLDApfS5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1jbG9zZWR7dmlzaWJpbGl0eTpoaWRkZW59Lm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LW9wZW5lZCwubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtb3BlbmluZ3t0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApfS5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1zaWRle3otaW5kZXg6MX0ubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5ke3JpZ2h0OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDEwMCUsMCwwKX0ubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5kLm1hdC1zaWRlbmF2LWNsb3NlZHt2aXNpYmlsaXR5OmhpZGRlbn0ubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5kLm1hdC1zaWRlbmF2LW9wZW5lZCwubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5kLm1hdC1zaWRlbmF2LW9wZW5pbmd7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX1bZGlyPXJ0bF0gLm1hdC1zaWRlbmF2e3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgxMDAlLDAsMCl9W2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1jbG9zZWR7dmlzaWJpbGl0eTpoaWRkZW59W2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1vcGVuZWQsW2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1vcGVuaW5ne3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCl9W2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmR7bGVmdDowO3JpZ2h0OmF1dG87dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xMDAlLDAsMCl9W2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtY2xvc2Vke3Zpc2liaWxpdHk6aGlkZGVufVtkaXI9cnRsXSAubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5kLm1hdC1zaWRlbmF2LW9wZW5lZCxbZGlyPXJ0bF0gLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LWVuZC5tYXQtc2lkZW5hdi1vcGVuaW5ne3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCl9Lm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LW9wZW5lZDpub3QoLm1hdC1zaWRlbmF2LXNpZGUpLC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1vcGVuaW5nOm5vdCgubWF0LXNpZGVuYXYtc2lkZSl7Ym94LXNoYWRvdzowIDhweCAxMHB4IC01cHggcmdiYSgwLDAsMCwuMiksMCAxNnB4IDI0cHggMnB4IHJnYmEoMCwwLDAsLjE0KSwwIDZweCAzMHB4IDVweCByZ2JhKDAsMCwwLC4xMil9IC5tYXQtc2lkZW5hdi10cmFuc2l0aW9uIC5tYXQtc2lkZW5hdnt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zaWRlbmF2LXRyYW5zaXRpb24gLm1hdC1zaWRlbmF2LWNvbnRlbnR7dHJhbnNpdGlvbi1kdXJhdGlvbjouNHM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSk7dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm0sbWFyZ2luLWxlZnQsbWFyZ2luLXJpZ2h0fS5tYXQtc2lkZW5hdi10cmFuc2l0aW9uIC5tYXQtc2lkZW5hdi1iYWNrZHJvcC5tYXQtc2lkZW5hdi1zaG93bnt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfVwiXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtc2lkZW5hdi1jb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LXRyYW5zaXRpb25dJzogJ19lbmFibGVUcmFuc2l0aW9ucycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNpZGVuYXZDb250YWluZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBEaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogTmdab25lLCB9LFxuXTsgfTtcbk1kU2lkZW5hdkNvbnRhaW5lci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX3NpZGVuYXZzJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWRTaWRlbmF2LF0gfSxdLFxuICAgICdiYWNrZHJvcENsaWNrJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG52YXIgTWRTaWRlbmF2TW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTaWRlbmF2TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRTaWRlbmF2TW9kdWxlO1xufSgpKTtcbk1kU2lkZW5hdk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWRDb21tb25Nb2R1bGUsIEExMXlNb2R1bGUsIE92ZXJsYXlNb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZFNpZGVuYXZDb250YWluZXIsIE1kU2lkZW5hdiwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kU2lkZW5hdkNvbnRhaW5lciwgTWRTaWRlbmF2XSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRTaWRlbmF2TW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWRMaXN0RGl2aWRlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdERpdmlkZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZExpc3REaXZpZGVyO1xufSgpKTtcbk1kTGlzdERpdmlkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWRpdmlkZXIsIG1hdC1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3NlcGFyYXRvcicsXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogJ2hvcml6b250YWwnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZExpc3REaXZpZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWRMaXN0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0KCkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlUmlwcGxlID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZExpc3QucHJvdG90eXBlLCBcImRpc2FibGVSaXBwbGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgcmlwcGxlIGVmZmVjdCBzaG91bGQgYmUgZGlzYWJsZWQgb24gdGhlIGxpc3QtaXRlbXMgb3Igbm90LlxuICAgICAgICAgKiBUaGlzIGZsYWcgb25seSBoYXMgYW4gZWZmZWN0IGZvciBgbWQtbmF2LWxpc3RgIGNvbXBvbmVudHMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVSaXBwbGU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlUmlwcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE1kTGlzdDtcbn0oKSk7XG5NZExpc3QuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1saXN0LCBtYXQtbGlzdCwgbWQtbmF2LWxpc3QsIG1hdC1uYXYtbGlzdCcsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAncm9sZSc6ICdsaXN0JyB9LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXN1YmhlYWRlcntkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjE2cHg7bWFyZ2luOjB9Lm1hdC1saXN0LC5tYXQtbmF2LWxpc3R7cGFkZGluZy10b3A6OHB4O2Rpc3BsYXk6YmxvY2t9Lm1hdC1saXN0IC5tYXQtc3ViaGVhZGVyLC5tYXQtbmF2LWxpc3QgLm1hdC1zdWJoZWFkZXJ7aGVpZ2h0OjQ4cHh9Lm1hdC1saXN0IC5tYXQtc3ViaGVhZGVyOmZpcnN0LWNoaWxkLC5tYXQtbmF2LWxpc3QgLm1hdC1zdWJoZWFkZXI6Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDotOHB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVte2Rpc3BsYXk6YmxvY2t9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaXRlbS1jb250ZW50e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7YWxpZ24taXRlbXM6Y2VudGVyO2JveC1zaXppbmc6Ym9yZGVyLWJveDtoZWlnaHQ6NDhweDtwYWRkaW5nOjAgMTZweDtwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWl0ZW0tcmlwcGxlLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWl0ZW0tcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDtyaWdodDowO2JvdHRvbTowO3BvaW50ZXItZXZlbnRzOm5vbmV9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC1saXN0LWl0ZW0tYXZhdGFyIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbS5tYXQtbGlzdC1pdGVtLWF2YXRhciAubWF0LWxpc3QtaXRlbS1jb250ZW50e2hlaWdodDo1NnB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbS5tYXQtMi1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbS5tYXQtMi1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0OjcycHh9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC0zLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC0zLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6ODhweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0ubWF0LW11bHRpLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC1tdWx0aS1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0OjEwMCU7cGFkZGluZzo4cHggMTZweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3dpZHRoOjEwMCU7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjAgMTZweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ+KiwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0Pip7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6aW5oZXJpdH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ6ZW1wdHksLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDplbXB0eXtkaXNwbGF5Om5vbmV9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0Om50aC1jaGlsZCgyKSwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0Om50aC1jaGlsZCgyKXtwYWRkaW5nOjB9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1hdmF0YXIsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtYXZhdGFye2ZsZXgtc2hyaW5rOjA7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDtib3JkZXItcmFkaXVzOjUwJX0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWljb24sLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaWNvbnt3aWR0aDoyNHB4O2hlaWdodDoyNHB4O2ZvbnQtc2l6ZToyNHB4O2JveC1zaXppbmc6Y29udGVudC1ib3g7Ym9yZGVyLXJhZGl1czo1MCU7cGFkZGluZzo0cHh9Lm1hdC1saXN0W2RlbnNlXSwubWF0LW5hdi1saXN0W2RlbnNlXXtwYWRkaW5nLXRvcDo0cHg7ZGlzcGxheTpibG9ja30ubWF0LWxpc3RbZGVuc2VdIC5tYXQtc3ViaGVhZGVyLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtc3ViaGVhZGVye2hlaWdodDo0MHB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1zdWJoZWFkZXI6Zmlyc3QtY2hpbGQsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1zdWJoZWFkZXI6Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDotNHB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0sLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW17ZGlzcGxheTpibG9ja30ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWl0ZW0tY29udGVudHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2FsaWduLWl0ZW1zOmNlbnRlcjtib3gtc2l6aW5nOmJvcmRlci1ib3g7aGVpZ2h0OjQwcHg7cGFkZGluZzowIDE2cHg7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaXRlbS1yaXBwbGUsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWl0ZW0tcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDtyaWdodDowO2JvdHRvbTowO3BvaW50ZXItZXZlbnRzOm5vbmV9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbS5tYXQtbGlzdC1pdGVtLWF2YXRhciAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC1saXN0LWl0ZW0tYXZhdGFyIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0OjQ4cHh9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbS5tYXQtMi1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0ubWF0LTItbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50e2hlaWdodDo2MHB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0ubWF0LTMtbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC0zLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6NzZweH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC1tdWx0aS1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0ubWF0LW11bHRpLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6MTAwJTtwYWRkaW5nOjhweCAxNnB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt3aWR0aDoxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzowIDE2cHh9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dD4qLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0Pip7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6aW5oZXJpdH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0OmVtcHR5LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0OmVtcHR5e2Rpc3BsYXk6bm9uZX0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0Om50aC1jaGlsZCgyKSwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDpudGgtY2hpbGQoMil7cGFkZGluZzowfS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWF2YXRhciwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtYXZhdGFye2ZsZXgtc2hyaW5rOjA7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDtib3JkZXItcmFkaXVzOjUwJX0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1pY29uLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1pY29ue3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7Zm9udC1zaXplOjIwcHg7Ym94LXNpemluZzpjb250ZW50LWJveDtib3JkZXItcmFkaXVzOjUwJTtwYWRkaW5nOjRweH0ubWF0LWRpdmlkZXJ7ZGlzcGxheTpibG9jaztib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci10b3Atd2lkdGg6MXB4O21hcmdpbjowfS5tYXQtbmF2LWxpc3QgYXt0ZXh0LWRlY29yYXRpb246bm9uZTtjb2xvcjppbmhlcml0fS5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0tY29udGVudHtjdXJzb3I6cG9pbnRlcn0ubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQubWF0LWxpc3QtaXRlbS1mb2N1cywubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQ6aG92ZXJ7b3V0bGluZTowfVwiXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTGlzdC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuTWRMaXN0LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdkaXNhYmxlUmlwcGxlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTGlzdENzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdENzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTGlzdENzc01hdFN0eWxlcjtcbn0oKSk7XG5NZExpc3RDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWxpc3QsIG1hdC1saXN0JyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtbGlzdCcgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZExpc3RDc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTmF2TGlzdENzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTmF2TGlzdENzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTmF2TGlzdENzc01hdFN0eWxlcjtcbn0oKSk7XG5NZE5hdkxpc3RDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLW5hdi1saXN0LCBtYXQtbmF2LWxpc3QnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21hdC1uYXYtbGlzdCcgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZE5hdkxpc3RDc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kRGl2aWRlckNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGl2aWRlckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kRGl2aWRlckNzc01hdFN0eWxlcjtcbn0oKSk7XG5NZERpdmlkZXJDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWRpdmlkZXIsIG1hdC1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtZGl2aWRlcicgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERpdmlkZXJDc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlcjtcbn0oKSk7XG5NZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1saXN0LWF2YXRhcl0sIFttYXQtbGlzdC1hdmF0YXJdLCBbbWRMaXN0QXZhdGFyXSwgW21hdExpc3RBdmF0YXJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtbGlzdC1hdmF0YXInIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRMaXN0QXZhdGFyQ3NzTWF0U3R5bGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZExpc3RJY29uQ3NzTWF0U3R5bGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0SWNvbkNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTGlzdEljb25Dc3NNYXRTdHlsZXI7XG59KCkpO1xuTWRMaXN0SWNvbkNzc01hdFN0eWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWxpc3QtaWNvbl0sIFttYXQtbGlzdC1pY29uXSwgW21kTGlzdEljb25dLCBbbWF0TGlzdEljb25dJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtbGlzdC1pY29uJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTGlzdEljb25Dc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlcjtcbn0oKSk7XG5NZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1zdWJoZWFkZXJdLCBbbWF0LXN1YmhlYWRlcl0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21hdC1zdWJoZWFkZXInIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRMaXN0U3ViaGVhZGVyQ3NzTWF0U3R5bGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWRMaXN0SXRlbSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX2xpc3RcbiAgICAgKiBAcGFyYW0gez99IG5hdkxpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZExpc3RJdGVtKF9yZW5kZXJlciwgX2VsZW1lbnQsIF9saXN0LCBuYXZMaXN0KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2xpc3QgPSBfbGlzdDtcbiAgICAgICAgdGhpcy5fZGlzYWJsZVJpcHBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc05hdkxpc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNOYXZMaXN0ID0gISFuYXZMaXN0O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRMaXN0SXRlbS5wcm90b3R5cGUsIFwiZGlzYWJsZVJpcHBsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IG9uIGNsaWNrIHNob3VsZCBiZSBkaXNhYmxlZC4gVGhpcyBhcHBsaWVzIG9ubHkgdG8gbGlzdCBpdGVtcyB0aGF0IGFyZVxuICAgICAgICAgKiBwYXJ0IG9mIGEgbmF2IGxpc3QuIFRoZSB2YWx1ZSBvZiBgZGlzYWJsZVJpcHBsZWAgb24gdGhlIGBtZC1uYXYtbGlzdGAgb3ZlcnJpZGVzIHRoaXMgZmxhZy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRMaXN0SXRlbS5wcm90b3R5cGUsIFwiX2hhc0F2YXRhclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGF2YXRhclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYXZhdGFyKSB7XG4gICAgICAgICAgICBpZiAoYXZhdGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtYXQtbGlzdC1pdGVtLWF2YXRhcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnbWF0LWxpc3QtaXRlbS1hdmF0YXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZExpc3RJdGVtLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpbmVTZXR0ZXIgPSBuZXcgTWRMaW5lU2V0dGVyKHRoaXMuX2xpbmVzLCB0aGlzLl9yZW5kZXJlciwgdGhpcy5fZWxlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgbGlzdCBpdGVtIHNob3VsZCBzaG93IGEgcmlwcGxlIGVmZmVjdCB3aGVuIGNsaWNrZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZExpc3RJdGVtLnByb3RvdHlwZS5pc1JpcHBsZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kaXNhYmxlUmlwcGxlICYmIHRoaXMuX2lzTmF2TGlzdCAmJiAhdGhpcy5fbGlzdC5kaXNhYmxlUmlwcGxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZExpc3RJdGVtLnByb3RvdHlwZS5faGFuZGxlRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ21hdC1saXN0LWl0ZW0tZm9jdXMnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRMaXN0SXRlbS5wcm90b3R5cGUuX2hhbmRsZUJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ21hdC1saXN0LWl0ZW0tZm9jdXMnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIGNvbXBvbmVudCBob3N0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRMaXN0SXRlbS5wcm90b3R5cGUuX2dldEhvc3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH07XG4gICAgcmV0dXJuIE1kTGlzdEl0ZW07XG59KCkpO1xuTWRMaXN0SXRlbS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLWxpc3QtaXRlbSwgbWF0LWxpc3QtaXRlbSwgYVttZC1saXN0LWl0ZW1dLCBhW21hdC1saXN0LWl0ZW1dJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ2xpc3RpdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1saXN0LWl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICAnKGZvY3VzKSc6ICdfaGFuZGxlRm9jdXMoKScsXG4gICAgICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX2hhbmRsZUJsdXIoKScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtbGlzdC1pdGVtLWNvbnRlbnRcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1saXN0LWl0ZW0tcmlwcGxlXFxcIiBtZC1yaXBwbGUgW21kUmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIiBbbWRSaXBwbGVEaXNhYmxlZF09XFxcIiFpc1JpcHBsZUVuYWJsZWQoKVxcXCI+PC9kaXY+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWQtbGlzdC1hdmF0YXJdLFttZC1saXN0LWljb25dLCBbbWF0LWxpc3QtYXZhdGFyXSwgW21hdC1saXN0LWljb25dXFxcIj48L25nLWNvbnRlbnQ+PGRpdiBjbGFzcz1cXFwibWF0LWxpc3QtdGV4dFxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWQtbGluZV0sIFttYXQtbGluZV1cXFwiPjwvbmctY29udGVudD48L2Rpdj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZExpc3RJdGVtLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IE1kTGlzdCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBNZE5hdkxpc3RDc3NNYXRTdHlsZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbk1kTGlzdEl0ZW0ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2Rpc2FibGVSaXBwbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ19saW5lcyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kTGluZSxdIH0sXSxcbiAgICAnX2hhc0F2YXRhcic6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW01kTGlzdEF2YXRhckNzc01hdFN0eWxlcixdIH0sXSxcbn07XG52YXIgTWRMaXN0TW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRMaXN0TW9kdWxlO1xufSgpKTtcbk1kTGlzdE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW01kTGluZU1vZHVsZSwgTWRSaXBwbGVNb2R1bGUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgTWRMaXN0SXRlbSxcbiAgICAgICAgICAgICAgICAgICAgTWRMaXN0RGl2aWRlcixcbiAgICAgICAgICAgICAgICAgICAgTWRMaXN0QXZhdGFyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZExpbmVNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZExpc3RJY29uQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZExpc3RDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kTmF2TGlzdENzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWREaXZpZGVyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRMaXN0LFxuICAgICAgICAgICAgICAgICAgICBNZExpc3RJdGVtLFxuICAgICAgICAgICAgICAgICAgICBNZExpc3REaXZpZGVyLFxuICAgICAgICAgICAgICAgICAgICBNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kTGlzdEljb25Dc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kTGlzdENzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICAgICAgTWROYXZMaXN0Q3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZERpdmlkZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZExpc3RNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQ29udmVydHMgdmFsdWVzIGludG8gc3RyaW5ncy4gRmFsc3kgdmFsdWVzIGJlY29tZSBlbXB0eSBzdHJpbmdzLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb2VyY2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBcIlwiICsgKHZhbHVlIHx8ICcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB2YWx1ZSB0aGF0IG1pZ2h0IGJlIGEgc3RyaW5nIGludG8gYSBudW1iZXIuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUludCh2YWx1ZSwgMTApIDogdmFsdWU7XG59XG52YXIgTWRHcmlkVGlsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kR3JpZFRpbGUoX3JlbmRlcmVyLCBfZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9yb3dzcGFuID0gMTtcbiAgICAgICAgdGhpcy5fY29sc3BhbiA9IDE7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRUaWxlLnByb3RvdHlwZSwgXCJyb3dzcGFuXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFtb3VudCBvZiByb3dzIHRoYXQgdGhlIGdyaWQgdGlsZSB0YWtlcyB1cC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm93c3BhbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3Jvd3NwYW4gPSBjb2VyY2VUb051bWJlcih2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRUaWxlLnByb3RvdHlwZSwgXCJjb2xzcGFuXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFtb3VudCBvZiBjb2x1bW5zIHRoYXQgdGhlIGdyaWQgdGlsZSB0YWtlcyB1cC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sc3BhbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2NvbHNwYW4gPSBjb2VyY2VUb051bWJlcih2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0eWxlIG9mIHRoZSBncmlkLXRpbGUgZWxlbWVudC4gIE5lZWRzIHRvIGJlIHNldCBtYW51YWxseSB0byBhdm9pZFxuICAgICAqIFwiQ2hhbmdlZCBhZnRlciBjaGVja2VkXCIgZXJyb3JzIHRoYXQgd291bGQgb2NjdXIgd2l0aCBIb3N0QmluZGluZy5cbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRHcmlkVGlsZS5wcm90b3R5cGUuX3NldFN0eWxlID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRHcmlkVGlsZTtcbn0oKSk7XG5NZEdyaWRUaWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtZ3JpZC10aWxlLCBtYXQtZ3JpZC10aWxlJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ2xpc3RpdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1ncmlkLXRpbGUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGZpZ3VyZSBjbGFzcz1cXFwibWF0LWZpZ3VyZVxcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZmlndXJlPlwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1ncmlkLWxpc3R7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LWdyaWQtdGlsZXtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbn0ubWF0LWdyaWQtdGlsZSAubWF0LWZpZ3VyZXtkaXNwbGF5OmZsZXg7cG9zaXRpb246YWJzb2x1dGU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7aGVpZ2h0OjEwMCU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7cGFkZGluZzowO21hcmdpbjowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3RlciwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtoZWlnaHQ6NDhweDtjb2xvcjojZmZmO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMzgpO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjAgMTZweDtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7cmlnaHQ6MH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXI+KiwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXI+KnttYXJnaW46MDtwYWRkaW5nOjA7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc2l6ZTppbmhlcml0fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3Rlci5tYXQtMi1saW5lLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlci5tYXQtMi1saW5le2hlaWdodDo2OHB4fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1saXN0LXRleHR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt3aWR0aDoxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpoaWRkZW59Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWxpc3QtdGV4dD4qe21hcmdpbjowO3BhZGRpbmc6MDtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOmluaGVyaXR9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWxpc3QtdGV4dDplbXB0eXtkaXNwbGF5Om5vbmV9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVye3RvcDowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3Rlcntib3R0b206MH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtYXZhdGFye3BhZGRpbmctcmlnaHQ6MTZweH1bZGlyPXJ0bF0gLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWF2YXRhcntwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy1sZWZ0OjE2cHh9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWF2YXRhcjplbXB0eXtkaXNwbGF5Om5vbmV9XCJdLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kR3JpZFRpbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuXTsgfTtcbk1kR3JpZFRpbGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3Jvd3NwYW4nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2NvbHNwYW4nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xudmFyIE1kR3JpZFRpbGVUZXh0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRHcmlkVGlsZVRleHQoX3JlbmRlcmVyLCBfZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kR3JpZFRpbGVUZXh0LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpbmVTZXR0ZXIgPSBuZXcgTWRMaW5lU2V0dGVyKHRoaXMuX2xpbmVzLCB0aGlzLl9yZW5kZXJlciwgdGhpcy5fZWxlbWVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRHcmlkVGlsZVRleHQ7XG59KCkpO1xuTWRHcmlkVGlsZVRleHQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1ncmlkLXRpbGUtaGVhZGVyLCBtYXQtZ3JpZC10aWxlLWhlYWRlciwgbWQtZ3JpZC10aWxlLWZvb3RlciwgbWF0LWdyaWQtdGlsZS1mb290ZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLWdyaWQtYXZhdGFyXSwgW21hdC1ncmlkLWF2YXRhcl1cXFwiPjwvbmctY29udGVudD48ZGl2IGNsYXNzPVxcXCJtYXQtZ3JpZC1saXN0LXRleHRcXFwiPjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLWxpbmVdLCBbbWF0LWxpbmVdXFxcIj48L25nLWNvbnRlbnQ+PC9kaXY+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kR3JpZFRpbGVUZXh0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbl07IH07XG5NZEdyaWRUaWxlVGV4dC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX2xpbmVzJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWRMaW5lLF0gfSxdLFxufTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlcjtcbn0oKSk7XG5NZEdyaWRBdmF0YXJDc3NNYXRTdHlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1ncmlkLWF2YXRhcl0sIFttYXQtZ3JpZC1hdmF0YXJdLCBbbWRHcmlkQXZhdGFyXSwgW21hdEdyaWRBdmF0YXJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtZ3JpZC1hdmF0YXInIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRHcmlkQXZhdGFyQ3NzTWF0U3R5bGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEdyaWRUaWxlSGVhZGVyQ3NzTWF0U3R5bGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kR3JpZFRpbGVIZWFkZXJDc3NNYXRTdHlsZXI7XG59KCkpO1xuTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtZ3JpZC10aWxlLWhlYWRlciwgbWF0LWdyaWQtdGlsZS1oZWFkZXInLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21hdC1ncmlkLXRpbGUtaGVhZGVyJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kR3JpZFRpbGVIZWFkZXJDc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kR3JpZFRpbGVGb290ZXJDc3NNYXRTdHlsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEdyaWRUaWxlRm9vdGVyQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlcjtcbn0oKSk7XG5NZEdyaWRUaWxlRm9vdGVyQ3NzTWF0U3R5bGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1ncmlkLXRpbGUtZm9vdGVyLCBtYXQtZ3JpZC10aWxlLWZvb3RlcicsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWdyaWQtdGlsZS1mb290ZXInIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBDbGFzcyBmb3IgZGV0ZXJtaW5pbmcsIGZyb20gYSBsaXN0IG9mIHRpbGVzLCB0aGUgKHJvdywgY29sKSBwb3NpdGlvbiBvZiBlYWNoIG9mIHRob3NlIHRpbGVzXG4gKiBpbiB0aGUgZ3JpZC4gVGhpcyBpcyBuZWNlc3NhcnkgKHJhdGhlciB0aGFuIGp1c3QgcmVuZGVyaW5nIHRoZSB0aWxlcyBpbiBub3JtYWwgZG9jdW1lbnQgZmxvdylcbiAqIGJlY2F1c2UgdGhlIHRpbGVzIGNhbiBoYXZlIGEgcm93c3Bhbi5cbiAqXG4gKiBUaGUgcG9zaXRpb25pbmcgYWxnb3JpdGhtIGdyZWVkaWx5IHBsYWNlcyBlYWNoIHRpbGUgYXMgc29vbiBhcyBpdCBlbmNvdW50ZXJzIGEgZ2FwIGluIHRoZSBncmlkXG4gKiBsYXJnZSBlbm91Z2ggdG8gYWNjb21tb2RhdGUgaXQgc28gdGhhdCB0aGUgdGlsZXMgc3RpbGwgcmVuZGVyIGluIHRoZSBzYW1lIG9yZGVyIGluIHdoaWNoIHRoZXlcbiAqIGFyZSBnaXZlbi5cbiAqXG4gKiBUaGUgYmFzaXMgb2YgdGhlIGFsZ29yaXRobSBpcyB0aGUgdXNlIG9mIGFuIGFycmF5IHRvIHRyYWNrIHRoZSBhbHJlYWR5IHBsYWNlZCB0aWxlcy4gRWFjaFxuICogZWxlbWVudCBvZiB0aGUgYXJyYXkgY29ycmVzcG9uZHMgdG8gYSBjb2x1bW4sIGFuZCB0aGUgdmFsdWUgaW5kaWNhdGVzIGhvdyBtYW55IGNlbGxzIGluIHRoYXRcbiAqIGNvbHVtbiBhcmUgYWxyZWFkeSBvY2N1cGllZDsgemVybyBpbmRpY2F0ZXMgYW4gZW1wdHkgY2VsbC4gTW92aW5nIFwiZG93blwiIHRvIHRoZSBuZXh0IHJvd1xuICogZGVjcmVtZW50cyBlYWNoIHZhbHVlIGluIHRoZSB0cmFja2luZyBhcnJheSAoaW5kaWNhdGluZyB0aGF0IHRoZSBjb2x1bW4gaXMgb25lIGNlbGwgY2xvc2VyIHRvXG4gKiBiZWluZyBmcmVlKS5cbiAqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFRpbGVDb29yZGluYXRvciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbnVtQ29sdW1uc1xuICAgICAqIEBwYXJhbSB7P30gdGlsZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaWxlQ29vcmRpbmF0b3IobnVtQ29sdW1ucywgdGlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IGF0IHdoaWNoIHRoZSBzZWFyY2ggZm9yIHRoZSBuZXh0IGdhcCB3aWxsIHN0YXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5JbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCByb3cgaW5kZXguXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvd0luZGV4ID0gMDtcbiAgICAgICAgdGhpcy50cmFja2VyID0gbmV3IEFycmF5KG51bUNvbHVtbnMpO1xuICAgICAgICB0aGlzLnRyYWNrZXIuZmlsbCgwLCAwLCB0aGlzLnRyYWNrZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSB0aWxlcy5tYXAoZnVuY3Rpb24gKHRpbGUpIHsgcmV0dXJuIF90aGlzLl90cmFja1RpbGUodGlsZSk7IH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZSwgXCJyb3dDb3VudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2Ygcm93cyBvY2N1cGllZCBieSB0aWxlc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJvd0luZGV4ICsgMTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUsIFwicm93c3BhblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB0b3RhbCBzcGFuIG9mIHJvd3Mgb2NjdXBpZWQgYnkgdGlsZXMuXG4gICAgICAgICAqIEV4OiBBIGxpc3Qgd2l0aCAxIHJvdyB0aGF0IGNvbnRhaW5zIGEgdGlsZSB3aXRoIHJvd3NwYW4gMiB3aWxsIGhhdmUgYSB0b3RhbCByb3dzcGFuIG9mIDIuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RSb3dNYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCB0aGlzLnRyYWNrZXIpO1xuICAgICAgICAgICAgLy8gaWYgYW55IG9mIHRoZSB0aWxlcyBoYXMgYSByb3dzcGFuIHRoYXQgcHVzaGVzIGl0IGJleW9uZCB0aGUgdG90YWwgcm93IGNvdW50LFxuICAgICAgICAgICAgLy8gYWRkIHRoZSBkaWZmZXJlbmNlIHRvIHRoZSByb3djb3VudFxuICAgICAgICAgICAgcmV0dXJuIGxhc3RSb3dNYXggPiAxID8gdGhpcy5yb3dDb3VudCArIGxhc3RSb3dNYXggLSAxIDogdGhpcy5yb3dDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcm93IGFuZCBjb2wgcG9zaXRpb24gb2YgYSB0aWxlLlxuICAgICAqIEBwYXJhbSB7P30gdGlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZS5fdHJhY2tUaWxlID0gZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgICAgLy8gRmluZCBhIGdhcCBsYXJnZSBlbm91Z2ggZm9yIHRoaXMgdGlsZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ2FwU3RhcnRJbmRleCA9IHRoaXMuX2ZpbmRNYXRjaGluZ0dhcCh0aWxlLmNvbHNwYW4pO1xuICAgICAgICAvLyBQbGFjZSB0aWxlIGluIHRoZSByZXN1bHRpbmcgZ2FwLlxuICAgICAgICB0aGlzLl9tYXJrVGlsZVBvc2l0aW9uKGdhcFN0YXJ0SW5kZXgsIHRpbGUpO1xuICAgICAgICAvLyBUaGUgbmV4dCB0aW1lIHdlIGxvb2sgZm9yIGEgZ2FwLCB0aGUgc2VhcmNoIHdpbGwgc3RhcnQgYXQgY29sdW1uSW5kZXgsIHdoaWNoIHNob3VsZCBiZVxuICAgICAgICAvLyBpbW1lZGlhdGVseSBhZnRlciB0aGUgdGlsZSB0aGF0IGhhcyBqdXN0IGJlZW4gcGxhY2VkLlxuICAgICAgICB0aGlzLmNvbHVtbkluZGV4ID0gZ2FwU3RhcnRJbmRleCArIHRpbGUuY29sc3BhbjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaWxlUG9zaXRpb24odGhpcy5yb3dJbmRleCwgZ2FwU3RhcnRJbmRleCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmV4dCBhdmFpbGFibGUgc3BhY2UgbGFyZ2UgZW5vdWdoIHRvIGZpdCB0aGUgdGlsZS5cbiAgICAgKiBAcGFyYW0gez99IHRpbGVDb2xzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLl9maW5kTWF0Y2hpbmdHYXAgPSBmdW5jdGlvbiAodGlsZUNvbHMpIHtcbiAgICAgICAgaWYgKHRpbGVDb2xzID4gdGhpcy50cmFja2VyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJtZC1ncmlkLWxpc3Q6IHRpbGUgd2l0aCBjb2xzcGFuIFwiICsgdGlsZUNvbHMgKyBcIiBpcyB3aWRlciB0aGFuIFwiICtcbiAgICAgICAgICAgICAgICAoXCJncmlkIHdpdGggY29scz1cXFwiXCIgKyB0aGlzLnRyYWNrZXIubGVuZ3RoICsgXCJcXFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgaW5kZXggaXMgaW5jbHVzaXZlLCBlbmQgaW5kZXggaXMgZXhjbHVzaXZlLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnYXBTdGFydEluZGV4ID0gLTE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGdhcEVuZEluZGV4ID0gLTE7XG4gICAgICAgIC8vIExvb2sgZm9yIGEgZ2FwIGxhcmdlIGVub3VnaCB0byBmaXQgdGhlIGdpdmVuIHRpbGUuIEVtcHR5IHNwYWNlcyBhcmUgbWFya2VkIHdpdGggYSB6ZXJvLlxuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHJvdywgZ28gdG8gdGhlIG5leHQgcm93LlxuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uSW5kZXggKyB0aWxlQ29scyA+IHRoaXMudHJhY2tlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0Um93KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYXBTdGFydEluZGV4ID0gdGhpcy50cmFja2VyLmluZGV4T2YoMCwgdGhpcy5jb2x1bW5JbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbW9yZSBlbXB0eSBzcGFjZXMgaW4gdGhpcyByb3cgYXQgYWxsLCBtb3ZlIG9uIHRvIHRoZSBuZXh0IHJvdy5cbiAgICAgICAgICAgIGlmIChnYXBTdGFydEluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFJvdygpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2FwRW5kSW5kZXggPSB0aGlzLl9maW5kR2FwRW5kSW5kZXgoZ2FwU3RhcnRJbmRleCk7XG4gICAgICAgICAgICAvLyBJZiBhIGdhcCBsYXJnZSBlbm91Z2ggaXNuJ3QgZm91bmQsIHdlIHdhbnQgdG8gc3RhcnQgbG9va2luZyBpbW1lZGlhdGVseSBhZnRlciB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8gZ2FwIG9uIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIHRoaXMuY29sdW1uSW5kZXggPSBnYXBTdGFydEluZGV4ICsgMTtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIGl0ZXJhdGluZyB1bnRpbCB3ZSBmaW5kIGEgZ2FwIHdpZGUgZW5vdWdoIGZvciB0aGlzIHRpbGUuXG4gICAgICAgIH0gd2hpbGUgKGdhcEVuZEluZGV4IC0gZ2FwU3RhcnRJbmRleCA8IHRpbGVDb2xzKTtcbiAgICAgICAgcmV0dXJuIGdhcFN0YXJ0SW5kZXg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIFwiZG93blwiIHRvIHRoZSBuZXh0IHJvdy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUuX25leHRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sdW1uSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJvd0luZGV4Kys7XG4gICAgICAgIC8vIERlY3JlbWVudCBhbGwgc3BhY2VzIGJ5IG9uZSB0byByZWZsZWN0IG1vdmluZyBkb3duIG9uZSByb3cuXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLnRyYWNrZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlcltpXSA9IE1hdGgubWF4KDAsIHRoaXMudHJhY2tlcltpXSAtIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZW5kIGluZGV4IChleGNsdXNpdmUpIG9mIGEgZ2FwIGdpdmVuIHRoZSBpbmRleCBmcm9tIHdoaWNoIHRvIHN0YXJ0IGxvb2tpbmcuXG4gICAgICogVGhlIGdhcCBlbmRzIHdoZW4gYSBub24temVybyB2YWx1ZSBpcyBmb3VuZC5cbiAgICAgKiBAcGFyYW0gez99IGdhcFN0YXJ0SW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUuX2ZpbmRHYXBFbmRJbmRleCA9IGZ1bmN0aW9uIChnYXBTdGFydEluZGV4KSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IGdhcFN0YXJ0SW5kZXggKyAxOyBpIDwgdGhpcy50cmFja2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFja2VyW2ldICE9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZ2FwIGVuZHMgd2l0aCB0aGUgZW5kIG9mIHRoZSByb3cuXG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrZXIubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB0aWxlIHRyYWNrZXIgdG8gYWNjb3VudCBmb3IgdGhlIGdpdmVuIHRpbGUgaW4gdGhlIGdpdmVuIHNwYWNlLlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcGFyYW0gez99IHRpbGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUuX21hcmtUaWxlUG9zaXRpb24gPSBmdW5jdGlvbiAoc3RhcnQsIHRpbGUpIHtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRpbGUuY29sc3BhbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXJbc3RhcnQgKyBpXSA9IHRpbGUucm93c3BhbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRpbGVDb29yZGluYXRvcjtcbn0oKSk7XG4vKipcbiAqIFNpbXBsZSBkYXRhIHN0cnVjdHVyZSBmb3IgdGlsZSBwb3NpdGlvbiAocm93LCBjb2wpLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBUaWxlUG9zaXRpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvd1xuICAgICAqIEBwYXJhbSB7P30gY29sXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGlsZVBvc2l0aW9uKHJvdywgY29sKSB7XG4gICAgICAgIHRoaXMucm93ID0gcm93O1xuICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICB9XG4gICAgcmV0dXJuIFRpbGVQb3NpdGlvbjtcbn0oKSk7XG4vKipcbiAqIFNldHMgdGhlIHN0eWxlIHByb3BlcnRpZXMgZm9yIGFuIGluZGl2aWR1YWwgdGlsZSwgZ2l2ZW4gdGhlIHBvc2l0aW9uIGNhbGN1bGF0ZWQgYnkgdGhlXG4gKiBUaWxlIENvb3JkaW5hdG9yLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIFRpbGVTdHlsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaWxlU3R5bGVyKCkge1xuICAgICAgICB0aGlzLl9yb3dzID0gMDtcbiAgICAgICAgdGhpcy5fcm93c3BhbiA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZ3JpZC1saXN0IGxheW91dCBpbmZvIG9uY2UgaXQgaXMgYXZhaWxhYmxlLiBDYW5ub3QgYmUgcHJvY2Vzc2VkIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAqIGJlY2F1c2UgdGhlc2UgcHJvcGVydGllcyBoYXZlbid0IGJlZW4gY2FsY3VsYXRlZCBieSB0aGF0IHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBndXR0ZXJTaXplIFNpemUgb2YgdGhlIGdyaWQncyBndXR0ZXIuXG4gICAgICogQHBhcmFtIHs/fSB0cmFja2VyIEluc3RhbmNlIG9mIHRoZSBUaWxlQ29vcmRpbmF0b3IuXG4gICAgICogQHBhcmFtIHs/fSBjb2xzIEFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBncmlkLlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aW9uIExheW91dCBkaXJlY3Rpb24gb2YgdGhlIGdyaWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGd1dHRlclNpemUsIHRyYWNrZXIsIGNvbHMsIGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLl9ndXR0ZXJTaXplID0gbm9ybWFsaXplVW5pdHMoZ3V0dGVyU2l6ZSk7XG4gICAgICAgIHRoaXMuX3Jvd3MgPSB0cmFja2VyLnJvd0NvdW50O1xuICAgICAgICB0aGlzLl9yb3dzcGFuID0gdHJhY2tlci5yb3dzcGFuO1xuICAgICAgICB0aGlzLl9jb2xzID0gY29scztcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGFtb3VudCBvZiBzcGFjZSBhIHNpbmdsZSAxeDEgdGlsZSB3b3VsZCB0YWtlIHVwICh3aWR0aCBvciBoZWlnaHQpLlxuICAgICAqIFVzZWQgYXMgYSBiYXNpcyBmb3Igb3RoZXIgY2FsY3VsYXRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gc2l6ZVBlcmNlbnQgUGVyY2VudCBvZiB0aGUgdG90YWwgZ3JpZC1saXN0IHNwYWNlIHRoYXQgb25lIDF4MSB0aWxlIHdvdWxkIHRha2UgdXAuXG4gICAgICogQHBhcmFtIHs/fSBndXR0ZXJGcmFjdGlvbiBGcmFjdGlvbiBvZiB0aGUgZ3V0dGVyIHNpemUgdGFrZW4gdXAgYnkgb25lIDF4MSB0aWxlLlxuICAgICAqIEByZXR1cm4gez99IFRoZSBzaXplIG9mIGEgMXgxIHRpbGUgYXMgYW4gZXhwcmVzc2lvbiB0aGF0IGNhbiBiZSBldmFsdWF0ZWQgdmlhIENTUyBjYWxjKCkuXG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0QmFzZVRpbGVTaXplID0gZnVuY3Rpb24gKHNpemVQZXJjZW50LCBndXR0ZXJGcmFjdGlvbikge1xuICAgICAgICAvLyBUYWtlIHRoZSBiYXNlIHNpemUgcGVyY2VudCAoYXMgd291bGQgYmUgaWYgZXZlbmx5IGRpdmlkaW5nIHRoZSBzaXplIGJldHdlZW4gY2VsbHMpLFxuICAgICAgICAvLyBhbmQgdGhlbiBzdWJ0cmFjdGluZyB0aGUgc2l6ZSBvZiBvbmUgZ3V0dGVyLiBIb3dldmVyLCBzaW5jZSB0aGVyZSBhcmUgbm8gZ3V0dGVycyBvbiB0aGVcbiAgICAgICAgLy8gZWRnZXMsIGVhY2ggdGlsZSBvbmx5IHVzZXMgYSBmcmFjdGlvbiAoZ3V0dGVyU2hhcmUgPSBudW1HdXR0ZXJzIC8gbnVtQ2VsbHMpIG9mIHRoZSBndXR0ZXJcbiAgICAgICAgLy8gc2l6ZS4gKEltYWdpbmUgaGF2aW5nIG9uZSBndXR0ZXIgcGVyIHRpbGUsIGFuZCB0aGVuIGJyZWFraW5nIHVwIHRoZSBleHRyYSBndXR0ZXIgb24gdGhlXG4gICAgICAgIC8vIGVkZ2UgZXZlbmx5IGFtb25nIHRoZSBjZWxscykuXG4gICAgICAgIHJldHVybiBcIihcIiArIHNpemVQZXJjZW50ICsgXCIlIC0gKCBcIiArIHRoaXMuX2d1dHRlclNpemUgKyBcIiAqIFwiICsgZ3V0dGVyRnJhY3Rpb24gKyBcIiApKVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBUaGUgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhIHRpbGUsIGUuZy4sIHRoZSAndG9wJyBvciAnbGVmdCcgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHs/fSBiYXNlU2l6ZSBCYXNlIHNpemUgb2YgYSAxeDEgdGlsZSAoYXMgY29tcHV0ZWQgaW4gZ2V0QmFzZVRpbGVTaXplKS5cbiAgICAgKiBAcGFyYW0gez99IG9mZnNldCBOdW1iZXIgb2YgdGlsZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiByZW5kZXJlZCBpbiB0aGUgcm93L2NvbHVtbi5cbiAgICAgKiBAcmV0dXJuIHs/fSBQb3NpdGlvbiBvZiB0aGUgdGlsZSBhcyBhIENTUyBjYWxjKCkgZXhwcmVzc2lvbi5cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRUaWxlUG9zaXRpb24gPSBmdW5jdGlvbiAoYmFzZVNpemUsIG9mZnNldCkge1xuICAgICAgICAvLyBUaGUgcG9zaXRpb24gY29tZXMgdGhlIHNpemUgb2YgYSAxeDEgdGlsZSBwbHVzIGd1dHRlciBmb3IgZWFjaCBwcmV2aW91cyB0aWxlIGluIHRoZVxuICAgICAgICAvLyByb3cvY29sdW1uIChvZmZzZXQpLlxuICAgICAgICByZXR1cm4gY2FsYyhcIihcIiArIGJhc2VTaXplICsgXCIgKyBcIiArIHRoaXMuX2d1dHRlclNpemUgKyBcIikgKiBcIiArIG9mZnNldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhY3R1YWwgc2l6ZSBvZiBhIHRpbGUsIGUuZy4sIHdpZHRoIG9yIGhlaWdodCwgdGFraW5nIHJvd3NwYW4gb3IgY29sc3BhbiBpbnRvIGFjY291bnQuXG4gICAgICogQHBhcmFtIHs/fSBiYXNlU2l6ZSBCYXNlIHNpemUgb2YgYSAxeDEgdGlsZSAoYXMgY29tcHV0ZWQgaW4gZ2V0QmFzZVRpbGVTaXplKS5cbiAgICAgKiBAcGFyYW0gez99IHNwYW4gVGhlIHRpbGUncyByb3dzcGFuIG9yIGNvbHNwYW4uXG4gICAgICogQHJldHVybiB7P30gU2l6ZSBvZiB0aGUgdGlsZSBhcyBhIENTUyBjYWxjKCkgZXhwcmVzc2lvbi5cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRUaWxlU2l6ZSA9IGZ1bmN0aW9uIChiYXNlU2l6ZSwgc3Bhbikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyBiYXNlU2l6ZSArIFwiICogXCIgKyBzcGFuICsgXCIpICsgKFwiICsgKHNwYW4gLSAxKSArIFwiICogXCIgKyB0aGlzLl9ndXR0ZXJTaXplICsgXCIpXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQgdG8gYSB0aWxlIGZvciB0aGUgZ2l2ZW4gcm93IGFuZCBjb2x1bW4gaW5kZXguXG4gICAgICogQHBhcmFtIHs/fSB0aWxlIFRpbGUgdG8gd2hpY2ggdG8gYXBwbHkgdGhlIHN0eWxpbmcuXG4gICAgICogQHBhcmFtIHs/fSByb3dJbmRleCBJbmRleCBvZiB0aGUgdGlsZSdzIHJvdy5cbiAgICAgKiBAcGFyYW0gez99IGNvbEluZGV4IEluZGV4IG9mIHRoZSB0aWxlJ3MgY29sdW1uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiAodGlsZSwgcm93SW5kZXgsIGNvbEluZGV4KSB7XG4gICAgICAgIC8vIFBlcmNlbnQgb2YgdGhlIGF2YWlsYWJsZSBob3Jpem9udGFsIHNwYWNlIHRoYXQgb25lIGNvbHVtbiB0YWtlcyB1cC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGVyY2VudFdpZHRoUGVyVGlsZSA9IDEwMCAvIHRoaXMuX2NvbHM7XG4gICAgICAgIC8vIEZyYWN0aW9uIG9mIHRoZSB2ZXJ0aWNhbCBndXR0ZXIgc2l6ZSB0aGF0IGVhY2ggY29sdW1uIHRha2VzIHVwLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSwgaWYgdGhlcmUgYXJlIDUgY29sdW1ucywgZWFjaCBjb2x1bW4gdXNlcyA0LzUgPSAwLjggdGltZXMgdGhlIGd1dHRlciB3aWR0aC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ3V0dGVyV2lkdGhGcmFjdGlvblBlclRpbGUgPSAodGhpcy5fY29scyAtIDEpIC8gdGhpcy5fY29scztcbiAgICAgICAgdGhpcy5zZXRDb2xTdHlsZXModGlsZSwgY29sSW5kZXgsIHBlcmNlbnRXaWR0aFBlclRpbGUsIGd1dHRlcldpZHRoRnJhY3Rpb25QZXJUaWxlKTtcbiAgICAgICAgdGhpcy5zZXRSb3dTdHlsZXModGlsZSwgcm93SW5kZXgsIHBlcmNlbnRXaWR0aFBlclRpbGUsIGd1dHRlcldpZHRoRnJhY3Rpb25QZXJUaWxlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhvcml6b250YWwgcGxhY2VtZW50IG9mIHRoZSB0aWxlIGluIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7P30gdGlsZVxuICAgICAqIEBwYXJhbSB7P30gY29sSW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHBlcmNlbnRXaWR0aFxuICAgICAqIEBwYXJhbSB7P30gZ3V0dGVyV2lkdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLnNldENvbFN0eWxlcyA9IGZ1bmN0aW9uICh0aWxlLCBjb2xJbmRleCwgcGVyY2VudFdpZHRoLCBndXR0ZXJXaWR0aCkge1xuICAgICAgICAvLyBCYXNlIGhvcml6b250YWwgc2l6ZSBvZiBhIGNvbHVtbi5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZVRpbGVXaWR0aCA9IHRoaXMuZ2V0QmFzZVRpbGVTaXplKHBlcmNlbnRXaWR0aCwgZ3V0dGVyV2lkdGgpO1xuICAgICAgICAvLyBUaGUgd2lkdGggYW5kIGhvcml6b250YWwgcG9zaXRpb24gb2YgZWFjaCB0aWxlIGlzIGFsd2F5cyBjYWxjdWxhdGVkIHRoZSBzYW1lIHdheSwgYnV0IHRoZVxuICAgICAgICAvLyBoZWlnaHQgYW5kIHZlcnRpY2FsIHBvc2l0aW9uIGRlcGVuZHMgb24gdGhlIHJvd01vZGUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNpZGUgPSB0aGlzLl9kaXJlY3Rpb24gPT09ICdsdHInID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoc2lkZSwgdGhpcy5nZXRUaWxlUG9zaXRpb24oYmFzZVRpbGVXaWR0aCwgY29sSW5kZXgpKTtcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ3dpZHRoJywgY2FsYyh0aGlzLmdldFRpbGVTaXplKGJhc2VUaWxlV2lkdGgsIHRpbGUuY29sc3BhbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHRvdGFsIHNpemUgdGFrZW4gdXAgYnkgZ3V0dGVycyBhY3Jvc3Mgb25lIGF4aXMgb2YgYSBsaXN0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0R3V0dGVyU3BhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2d1dHRlclNpemUgKyBcIiAqIChcIiArIHRoaXMuX3Jvd3NwYW4gKyBcIiAtIDEpXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB0b3RhbCBzaXplIHRha2VuIHVwIGJ5IHRpbGVzIGFjcm9zcyBvbmUgYXhpcyBvZiBhIGxpc3QuXG4gICAgICogQHBhcmFtIHs/fSB0aWxlSGVpZ2h0IEhlaWdodCBvZiB0aGUgdGlsZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLmdldFRpbGVTcGFuID0gZnVuY3Rpb24gKHRpbGVIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd3NwYW4gKyBcIiAqIFwiICsgdGhpcy5nZXRUaWxlU2l6ZSh0aWxlSGVpZ2h0LCAxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZlcnRpY2FsIHBsYWNlbWVudCBvZiB0aGUgdGlsZSBpbiB0aGUgbGlzdC5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZSBvZiBUaWxlU3R5bGVyLlxuICAgICAqIFxcQGRvY3MtcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gdGlsZVxuICAgICAqIEBwYXJhbSB7P30gcm93SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHBlcmNlbnRXaWR0aFxuICAgICAqIEBwYXJhbSB7P30gZ3V0dGVyV2lkdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLnNldFJvd1N0eWxlcyA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCwgcGVyY2VudFdpZHRoLCBndXR0ZXJXaWR0aCkgeyB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGNvbXB1dGVkIGhlaWdodCBhbmQgcmV0dXJucyB0aGUgY29ycmVjdCBzdHlsZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZSBvZiBUaWxlU3R5bGVyLlxuICAgICAqIFxcQGRvY3MtcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBUaWxlU3R5bGVyO1xufSgpKTtcbi8qKlxuICogVGhpcyB0eXBlIG9mIHN0eWxlciBpcyBpbnN0YW50aWF0ZWQgd2hlbiB0aGUgdXNlciBwYXNzZXMgaW4gYSBmaXhlZCByb3cgaGVpZ2h0LlxuICogRXhhbXBsZSA8bWQtZ3JpZC1saXN0IGNvbHM9XCIzXCIgcm93SGVpZ2h0PVwiMTAwcHhcIj5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgRml4ZWRUaWxlU3R5bGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRml4ZWRUaWxlU3R5bGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZml4ZWRSb3dIZWlnaHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGaXhlZFRpbGVTdHlsZXIoZml4ZWRSb3dIZWlnaHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZml4ZWRSb3dIZWlnaHQgPSBmaXhlZFJvd0hlaWdodDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGd1dHRlclNpemVcbiAgICAgKiBAcGFyYW0gez99IHRyYWNrZXJcbiAgICAgKiBAcGFyYW0gez99IGNvbHNcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRml4ZWRUaWxlU3R5bGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGd1dHRlclNpemUsIHRyYWNrZXIsIGNvbHMsIGRpcmVjdGlvbikge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBndXR0ZXJTaXplLCB0cmFja2VyLCBjb2xzLCBkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmZpeGVkUm93SGVpZ2h0ID0gbm9ybWFsaXplVW5pdHModGhpcy5maXhlZFJvd0hlaWdodCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRpbGVcbiAgICAgKiBAcGFyYW0gez99IHJvd0luZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGaXhlZFRpbGVTdHlsZXIucHJvdG90eXBlLnNldFJvd1N0eWxlcyA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCkge1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgndG9wJywgdGhpcy5nZXRUaWxlUG9zaXRpb24odGhpcy5maXhlZFJvd0hlaWdodCwgcm93SW5kZXgpKTtcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ2hlaWdodCcsIGNhbGModGhpcy5nZXRUaWxlU2l6ZSh0aGlzLmZpeGVkUm93SGVpZ2h0LCB0aWxlLnJvd3NwYW4pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZpeGVkVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnaGVpZ2h0JywgY2FsYyh0aGlzLmdldFRpbGVTcGFuKHRoaXMuZml4ZWRSb3dIZWlnaHQpICsgXCIgKyBcIiArIHRoaXMuZ2V0R3V0dGVyU3BhbigpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgcmV0dXJuIEZpeGVkVGlsZVN0eWxlcjtcbn0oVGlsZVN0eWxlcikpO1xuLyoqXG4gKiBUaGlzIHR5cGUgb2Ygc3R5bGVyIGlzIGluc3RhbnRpYXRlZCB3aGVuIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHdpZHRoOmhlaWdodCByYXRpb1xuICogZm9yIHRoZSByb3cgaGVpZ2h0LiAgRXhhbXBsZSA8bWQtZ3JpZC1saXN0IGNvbHM9XCIzXCIgcm93SGVpZ2h0PVwiMzoxXCI+XG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFJhdGlvVGlsZVN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJhdGlvVGlsZVN0eWxlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmF0aW9UaWxlU3R5bGVyKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9wYXJzZVJhdGlvKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRpbGVcbiAgICAgKiBAcGFyYW0gez99IHJvd0luZGV4XG4gICAgICogQHBhcmFtIHs/fSBwZXJjZW50V2lkdGhcbiAgICAgKiBAcGFyYW0gez99IGd1dHRlcldpZHRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSYXRpb1RpbGVTdHlsZXIucHJvdG90eXBlLnNldFJvd1N0eWxlcyA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCwgcGVyY2VudFdpZHRoLCBndXR0ZXJXaWR0aCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwZXJjZW50SGVpZ2h0UGVyVGlsZSA9IHBlcmNlbnRXaWR0aCAvIHRoaXMucm93SGVpZ2h0UmF0aW87XG4gICAgICAgIHRoaXMuYmFzZVRpbGVIZWlnaHQgPSB0aGlzLmdldEJhc2VUaWxlU2l6ZShwZXJjZW50SGVpZ2h0UGVyVGlsZSwgZ3V0dGVyV2lkdGgpO1xuICAgICAgICAvLyBVc2UgcGFkZGluZ1RvcCBhbmQgbWFyZ2luVG9wIHRvIG1haW50YWluIHRoZSBnaXZlbiBhc3BlY3QgcmF0aW8sIGFzXG4gICAgICAgIC8vIGEgcGVyY2VudGFnZS1iYXNlZCB2YWx1ZSBmb3IgdGhlc2UgcHJvcGVydGllcyBpcyBhcHBsaWVkIHZlcnN1cyB0aGUgKndpZHRoKiBvZiB0aGVcbiAgICAgICAgLy8gY29udGFpbmluZyBibG9jay4gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvYm94Lmh0bWwjbWFyZ2luLXByb3BlcnRpZXNcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ21hcmdpblRvcCcsIHRoaXMuZ2V0VGlsZVBvc2l0aW9uKHRoaXMuYmFzZVRpbGVIZWlnaHQsIHJvd0luZGV4KSk7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCdwYWRkaW5nVG9wJywgY2FsYyh0aGlzLmdldFRpbGVTaXplKHRoaXMuYmFzZVRpbGVIZWlnaHQsIHRpbGUucm93c3BhbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmF0aW9UaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRDb21wdXRlZEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdwYWRkaW5nQm90dG9tJywgY2FsYyh0aGlzLmdldFRpbGVTcGFuKHRoaXMuYmFzZVRpbGVIZWlnaHQpICsgXCIgKyBcIiArIHRoaXMuZ2V0R3V0dGVyU3BhbigpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmF0aW9UaWxlU3R5bGVyLnByb3RvdHlwZS5fcGFyc2VSYXRpbyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByYXRpb1BhcnRzID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgaWYgKHJhdGlvUGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm1kLWdyaWQtbGlzdDogaW52YWxpZCByYXRpbyBnaXZlbiBmb3Igcm93LWhlaWdodDogXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dIZWlnaHRSYXRpbyA9IHBhcnNlRmxvYXQocmF0aW9QYXJ0c1swXSkgLyBwYXJzZUZsb2F0KHJhdGlvUGFydHNbMV0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJhdGlvVGlsZVN0eWxlcjtcbn0oVGlsZVN0eWxlcikpO1xuLyoqXG4gKiBUaGlzIHR5cGUgb2Ygc3R5bGVyIGlzIGluc3RhbnRpYXRlZCB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBcImZpdFwiIHJvdyBoZWlnaHQgbW9kZS5cbiAqIEluIG90aGVyIHdvcmRzLCB0aGUgcm93IGhlaWdodCB3aWxsIHJlZmxlY3QgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgY29udGFpbmVyIGRpdmlkZWRcbiAqIGJ5IHRoZSBudW1iZXIgb2Ygcm93cy4gIEV4YW1wbGUgPG1kLWdyaWQtbGlzdCBjb2xzPVwiM1wiIHJvd0hlaWdodD1cImZpdFwiPlxuICpcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgRml0VGlsZVN0eWxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEZpdFRpbGVTdHlsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRml0VGlsZVN0eWxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRpbGVcbiAgICAgKiBAcGFyYW0gez99IHJvd0luZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGaXRUaWxlU3R5bGVyLnByb3RvdHlwZS5zZXRSb3dTdHlsZXMgPSBmdW5jdGlvbiAodGlsZSwgcm93SW5kZXgpIHtcbiAgICAgICAgLy8gUGVyY2VudCBvZiB0aGUgYXZhaWxhYmxlIHZlcnRpY2FsIHNwYWNlIHRoYXQgb25lIHJvdyB0YWtlcyB1cC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGVyY2VudEhlaWdodFBlclRpbGUgPSAxMDAgLyB0aGlzLl9yb3dzcGFuO1xuICAgICAgICAvLyBGcmFjdGlvbiBvZiB0aGUgaG9yaXpvbnRhbCBndXR0ZXIgc2l6ZSB0aGF0IGVhY2ggY29sdW1uIHRha2VzIHVwLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBndXR0ZXJIZWlnaHRQZXJUaWxlID0gKHRoaXMuX3Jvd3MgLSAxKSAvIHRoaXMuX3Jvd3M7XG4gICAgICAgIC8vIEJhc2UgdmVydGljYWwgc2l6ZSBvZiBhIGNvbHVtbi5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZVRpbGVIZWlnaHQgPSB0aGlzLmdldEJhc2VUaWxlU2l6ZShwZXJjZW50SGVpZ2h0UGVyVGlsZSwgZ3V0dGVySGVpZ2h0UGVyVGlsZSk7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCd0b3AnLCB0aGlzLmdldFRpbGVQb3NpdGlvbihiYXNlVGlsZUhlaWdodCwgcm93SW5kZXgpKTtcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ2hlaWdodCcsIGNhbGModGhpcy5nZXRUaWxlU2l6ZShiYXNlVGlsZUhlaWdodCwgdGlsZS5yb3dzcGFuKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpdFRpbGVTdHlsZXI7XG59KFRpbGVTdHlsZXIpKTtcbi8qKlxuICogV3JhcHMgYSBDU1Mgc3RyaW5nIGluIGEgY2FsYyBmdW5jdGlvblxuICogQHBhcmFtIHs/fSBleHBcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNhbGMoZXhwKSB7IHJldHVybiBcImNhbGMoXCIgKyBleHAgKyBcIilcIjsgfVxuLyoqXG4gKiBBcHBlbmRzIHBpeGVscyB0byBhIENTUyBzdHJpbmcgaWYgbm8gdW5pdHMgYXJlIGdpdmVuLlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlLm1hdGNoKC9weHxlbXxyZW0vKSkgPyB2YWx1ZSA6IHZhbHVlICsgJ3B4Jztcbn1cbi8vIFRPRE8oa2FyYSk6IENvbmRpdGlvbmFsIChyZXNwb25zaXZlKSBjb2x1bW4gY291bnQgLyByb3cgc2l6ZS5cbi8vIFRPRE8oa2FyYSk6IFJlLWxheW91dCBvbiB3aW5kb3cgcmVzaXplIC8gbWVkaWEgY2hhbmdlIChkZWJvdW5jZWQpLlxuLy8gVE9ETyhrYXJhKTogZ3JpZFRpbGVIZWFkZXIgYW5kIGdyaWRUaWxlRm9vdGVyLlxudmFyIE1EX0ZJVF9NT0RFID0gJ2ZpdCc7XG52YXIgTWRHcmlkTGlzdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX2RpclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kR3JpZExpc3QoX3JlbmRlcmVyLCBfZWxlbWVudCwgX2Rpcikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiBzcGFjZSBiZXR3ZWVuIHRpbGVzLiBUaGlzIHdpbGwgYmUgc29tZXRoaW5nIGxpa2UgJzVweCcgb3IgJzJlbScuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ndXR0ZXIgPSAnMXB4JztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kR3JpZExpc3QucHJvdG90eXBlLCBcImNvbHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IG9mIGNvbHVtbnMgaW4gdGhlIGdyaWQgbGlzdC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sczsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2NvbHMgPSBjb2VyY2VUb051bWJlcih2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJndXR0ZXJTaXplXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpemUgb2YgdGhlIGdyaWQgbGlzdCdzIGd1dHRlciBpbiBwaXhlbHMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2d1dHRlcjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2d1dHRlciA9IGNvZXJjZVRvU3RyaW5nKHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kR3JpZExpc3QucHJvdG90eXBlLCBcInJvd0hlaWdodFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2Ygcm93IGhlaWdodCBmcm9tIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlLlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcm93SGVpZ2h0ID0gY29lcmNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fc2V0VGlsZVN0eWxlcigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jaGVja0NvbHMoKTtcbiAgICAgICAgdGhpcy5fY2hlY2tSb3dIZWlnaHQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBsYXlvdXQgY2FsY3VsYXRpb24gaXMgZmFpcmx5IGNoZWFwIGlmIG5vdGhpbmcgY2hhbmdlcywgc28gdGhlcmUncyBsaXR0bGUgY29zdFxuICAgICAqIHRvIHJ1biBpdCBmcmVxdWVudGx5LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sYXlvdXRUaWxlcygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhyb3cgYSBmcmllbmRseSBlcnJvciBpZiBjb2xzIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLl9jaGVja0NvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb2xzKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm1kLWdyaWQtbGlzdDogbXVzdCBwYXNzIGluIG51bWJlciBvZiBjb2x1bW5zLiBcIiArXG4gICAgICAgICAgICAgICAgXCJFeGFtcGxlOiA8bWQtZ3JpZC1saXN0IGNvbHM9XFxcIjNcXFwiPlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB0byBlcXVhbCB3aWR0aDpoZWlnaHQgaWYgcm93SGVpZ2h0IHByb3BlcnR5IGlzIG1pc3NpbmdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLl9jaGVja1Jvd0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdHlsZXIgPSBuZXcgUmF0aW9UaWxlU3R5bGVyKCcxOjEnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjb3JyZWN0IFRpbGUgU3R5bGVyIHN1YnR5cGUgYmFzZWQgb24gcm93SGVpZ2h0IHBhc3NlZCBpbiBieSB1c2VyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEdyaWRMaXN0LnByb3RvdHlwZS5fc2V0VGlsZVN0eWxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvd0hlaWdodCA9PT0gTURfRklUX01PREUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdHlsZXIgPSBuZXcgRml0VGlsZVN0eWxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Jvd0hlaWdodCAmJiB0aGlzLl9yb3dIZWlnaHQuaW5kZXhPZignOicpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdHlsZXIgPSBuZXcgUmF0aW9UaWxlU3R5bGVyKHRoaXMuX3Jvd0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aWxlU3R5bGVyID0gbmV3IEZpeGVkVGlsZVN0eWxlcih0aGlzLl9yb3dIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhbmQgYXBwbGllcyB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gZm9yIGFsbCBjaGlsZHJlbiBncmlkIHRpbGVzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUuX2xheW91dFRpbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFja2VyID0gbmV3IFRpbGVDb29yZGluYXRvcih0aGlzLmNvbHMsIHRoaXMuX3RpbGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyZWN0aW9uID0gdGhpcy5fZGlyID8gdGhpcy5fZGlyLnZhbHVlIDogJ2x0cic7XG4gICAgICAgIHRoaXMuX3RpbGVTdHlsZXIuaW5pdCh0aGlzLmd1dHRlclNpemUsIHRyYWNrZXIsIHRoaXMuY29scywgZGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5fdGlsZXMuZm9yRWFjaChmdW5jdGlvbiAodGlsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvcyA9IHRyYWNrZXIucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIF90aGlzLl90aWxlU3R5bGVyLnNldFN0eWxlKHRpbGUsIHBvcy5yb3csIHBvcy5jb2wpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2V0TGlzdFN0eWxlKHRoaXMuX3RpbGVTdHlsZXIuZ2V0Q29tcHV0ZWRIZWlnaHQoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHN0eWxlIG9uIHRoZSBtYWluIGdyaWQtbGlzdCBlbGVtZW50LCBnaXZlbiB0aGUgc3R5bGUgbmFtZSBhbmQgdmFsdWUuXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUuX3NldExpc3RTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSQkMSkge1xuICAgICAgICBpZiAoc3R5bGUkJDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgc3R5bGUkJDFbMF0sIHN0eWxlJCQxWzFdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kR3JpZExpc3Q7XG59KCkpO1xuTWRHcmlkTGlzdC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLWdyaWQtbGlzdCwgbWF0LWdyaWQtbGlzdCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWdyaWQtbGlzdHtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtZ3JpZC10aWxle2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7b3ZlcmZsb3c6aGlkZGVufS5tYXQtZ3JpZC10aWxlIC5tYXQtZmlndXJle2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjphYnNvbHV0ZTthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtoZWlnaHQ6MTAwJTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDtwYWRkaW5nOjA7bWFyZ2luOjB9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2hlaWdodDo0OHB4O2NvbG9yOiNmZmY7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4zOCk7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCAxNnB4O3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtyaWdodDowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3Rlcj4qLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlcj4qe21hcmdpbjowO3BhZGRpbmc6MDtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOmluaGVyaXR9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyLm1hdC0yLWxpbmUsLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVyLm1hdC0yLWxpbmV7aGVpZ2h0OjY4cHh9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWxpc3QtdGV4dHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3dpZHRoOjEwMCU7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OmhpZGRlbn0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtbGlzdC10ZXh0Pip7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6aW5oZXJpdH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtbGlzdC10ZXh0OmVtcHR5e2Rpc3BsYXk6bm9uZX0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXJ7dG9wOjB9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVye2JvdHRvbTowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1hdmF0YXJ7cGFkZGluZy1yaWdodDoxNnB4fVtkaXI9cnRsXSAubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtYXZhdGFye3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLWxlZnQ6MTZweH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtYXZhdGFyOmVtcHR5e2Rpc3BsYXk6bm9uZX1cIl0sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdsaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1ncmlkLWxpc3QnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRHcmlkTGlzdC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBEaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG5dOyB9O1xuTWRHcmlkTGlzdC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX3RpbGVzJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWRHcmlkVGlsZSxdIH0sXSxcbiAgICAnY29scyc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZ3V0dGVyU2l6ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAncm93SGVpZ2h0JzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbnZhciBNZEdyaWRMaXN0TW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkTGlzdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kR3JpZExpc3RNb2R1bGU7XG59KCkpO1xuTWRHcmlkTGlzdE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW01kTGluZU1vZHVsZSwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRHcmlkTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgTWRHcmlkVGlsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRHcmlkVGlsZVRleHQsXG4gICAgICAgICAgICAgICAgICAgIE1kTGluZU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kR3JpZFRpbGVIZWFkZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kR3JpZFRpbGVGb290ZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlclxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kR3JpZExpc3QsXG4gICAgICAgICAgICAgICAgICAgIE1kR3JpZFRpbGUsXG4gICAgICAgICAgICAgICAgICAgIE1kR3JpZFRpbGVUZXh0LFxuICAgICAgICAgICAgICAgICAgICBNZEdyaWRUaWxlSGVhZGVyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZEdyaWRUaWxlRm9vdGVyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgICAgICBNZEdyaWRBdmF0YXJDc3NNYXRTdHlsZXJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEdyaWRMaXN0TW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIENvbnRlbnQgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkQ29udGVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZENvbnRlbnQoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRDb250ZW50O1xufSgpKTtcbk1kQ2FyZENvbnRlbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWNhcmQtY29udGVudCwgbWF0LWNhcmQtY29udGVudCcsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWNhcmQtY29udGVudCcgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENhcmRDb250ZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFRpdGxlIG9mIGEgY2FyZCwgbmVlZGVkIGFzIGl0J3MgdXNlZCBhcyBhIHNlbGVjdG9yIGluIHRoZSBBUEkuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2FyZFRpdGxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkVGl0bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRUaXRsZTtcbn0oKSk7XG5NZENhcmRUaXRsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC10aXRsZSwgbWF0LWNhcmQtdGl0bGUsIFttZC1jYXJkLXRpdGxlXSwgW21hdC1jYXJkLXRpdGxlXSwnICtcbiAgICAgICAgICAgICAgICAgICAgJ1ttZENhcmRUaXRsZV0sIFttYXRDYXJkVGl0bGVdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtY2FyZC10aXRsZSAnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENhcmRUaXRsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBTdWItdGl0bGUgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkU3VidGl0bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRTdWJ0aXRsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ2FyZFN1YnRpdGxlO1xufSgpKTtcbk1kQ2FyZFN1YnRpdGxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLXN1YnRpdGxlLCBtYXQtY2FyZC1zdWJ0aXRsZSwgW21kLWNhcmQtc3VidGl0bGVdLCBbbWF0LWNhcmQtc3VidGl0bGVdLCcgK1xuICAgICAgICAgICAgICAgICAgICAnW21kQ2FyZFN1YnRpdGxlXSwgW21hdENhcmRTdWJ0aXRsZV0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1jYXJkLXN1YnRpdGxlICdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FyZFN1YnRpdGxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEFjdGlvbiBzZWN0aW9uIG9mIGEgY2FyZCwgbmVlZGVkIGFzIGl0J3MgdXNlZCBhcyBhIHNlbGVjdG9yIGluIHRoZSBBUEkuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2FyZEFjdGlvbnMgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRBY3Rpb25zKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkQWN0aW9ucztcbn0oKSk7XG5NZENhcmRBY3Rpb25zLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLWFjdGlvbnMsIG1hdC1jYXJkLWFjdGlvbnMnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21hdC1jYXJkLWFjdGlvbnMnIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkQWN0aW9ucy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBGb290ZXIgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkRm9vdGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkRm9vdGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkRm9vdGVyO1xufSgpKTtcbk1kQ2FyZEZvb3Rlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC1mb290ZXIsIG1hdC1jYXJkLWZvb3RlcicsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWNhcmQtZm9vdGVyJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FyZEZvb3Rlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBJbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkSW1hZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRJbWFnZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ2FyZEltYWdlO1xufSgpKTtcbk1kQ2FyZEltYWdlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtY2FyZC1pbWFnZV0sIFttYXQtY2FyZC1pbWFnZV0sIFttZENhcmRJbWFnZV0sIFttYXRDYXJkSW1hZ2VdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtY2FyZC1pbWFnZScgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENhcmRJbWFnZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBJbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkU21JbWFnZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZFNtSW1hZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRTbUltYWdlO1xufSgpKTtcbk1kQ2FyZFNtSW1hZ2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1jYXJkLXNtLWltYWdlXSwgW21hdC1jYXJkLXNtLWltYWdlXSwgW21kQ2FyZEltYWdlU21hbGxdLCBbbWF0Q2FyZEltYWdlU21hbGxdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtY2FyZC1zbS1pbWFnZScgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENhcmRTbUltYWdlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEltYWdlIHVzZWQgaW4gYSBjYXJkLCBuZWVkZWQgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZENhcmRNZEltYWdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkTWRJbWFnZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ2FyZE1kSW1hZ2U7XG59KCkpO1xuTWRDYXJkTWRJbWFnZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWNhcmQtbWQtaW1hZ2VdLCBbbWF0LWNhcmQtbWQtaW1hZ2VdLCBbbWRDYXJkSW1hZ2VNZWRpdW1dLCBbbWF0Q2FyZEltYWdlTWVkaXVtXScsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWNhcmQtbWQtaW1hZ2UnIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkTWRJbWFnZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBJbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYXJkTGdJbWFnZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZExnSW1hZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRMZ0ltYWdlO1xufSgpKTtcbk1kQ2FyZExnSW1hZ2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1jYXJkLWxnLWltYWdlXSwgW21hdC1jYXJkLWxnLWltYWdlXSwgW21kQ2FyZEltYWdlTGFyZ2VdLCBbbWF0Q2FyZEltYWdlTGFyZ2VdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtY2FyZC1sZy1pbWFnZScgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENhcmRMZ0ltYWdlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIExhcmdlIGltYWdlIHVzZWQgaW4gYSBjYXJkLCBuZWVkZWQgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZENhcmRYbEltYWdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkWGxJbWFnZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ2FyZFhsSW1hZ2U7XG59KCkpO1xuTWRDYXJkWGxJbWFnZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWNhcmQteGwtaW1hZ2VdLCBbbWF0LWNhcmQteGwtaW1hZ2VdLCBbbWRDYXJkSW1hZ2VYTGFyZ2VdLCBbbWF0Q2FyZEltYWdlWExhcmdlXScsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWNhcmQteGwtaW1hZ2UnIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkWGxJbWFnZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBBdmF0YXIgaW1hZ2UgdXNlZCBpbiBhIGNhcmQsIG5lZWRlZCB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2FyZEF2YXRhciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZEF2YXRhcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ2FyZEF2YXRhcjtcbn0oKSk7XG5NZENhcmRBdmF0YXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1jYXJkLWF2YXRhcl0sIFttYXQtY2FyZC1hdmF0YXJdLCBbbWRDYXJkQXZhdGFyXSwgW21hdENhcmRBdmF0YXJdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtY2FyZC1hdmF0YXInIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkQXZhdGFyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEEgYmFzaWMgY29udGVudCBjb250YWluZXIgY29tcG9uZW50IHRoYXQgYWRkcyB0aGUgc3R5bGVzIG9mIGEgTWF0ZXJpYWwgZGVzaWduIGNhcmQuXG4gKlxuICogV2hpbGUgdGhpcyBjb21wb25lbnQgY2FuIGJlIHVzZWQgYWxvbmUsIGl0IGFsc28gcHJvdmlkZXMgYSBudW1iZXJcbiAqIG9mIHByZXNldCBzdHlsZXMgZm9yIGNvbW1vbiBjYXJkIHNlY3Rpb25zLCBpbmNsdWRpbmc6XG4gKiAtIG1kLWNhcmQtdGl0bGVcbiAqIC0gbWQtY2FyZC1zdWJ0aXRsZVxuICogLSBtZC1jYXJkLWNvbnRlbnRcbiAqIC0gbWQtY2FyZC1hY3Rpb25zXG4gKiAtIG1kLWNhcmQtZm9vdGVyXG4gKi9cbnZhciBNZENhcmQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmQoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmQ7XG59KCkpO1xuTWRDYXJkLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtY2FyZCwgbWF0LWNhcmQnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtY2FyZHt0cmFuc2l0aW9uOmJveC1zaGFkb3cgMjgwbXMgY3ViaWMtYmV6aWVyKC40LDAsLjIsMSk7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjI0cHg7Ym9yZGVyLXJhZGl1czoycHh9Lm1hdC1jYXJkOm5vdChbY2xhc3MqPW1hdC1lbGV2YXRpb24tel0pe2JveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLDAsMCwuMiksMCAycHggMnB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDVweCAwIHJnYmEoMCwwLDAsLjEyKX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LWNhcmR7b3V0bGluZTpzb2xpZCAxcHh9fS5tYXQtY2FyZC1mbGF0e2JveC1zaGFkb3c6bm9uZX0ubWF0LWNhcmQtYWN0aW9ucywubWF0LWNhcmQtY29udGVudCwubWF0LWNhcmQtc3VidGl0bGUsLm1hdC1jYXJkLXRpdGxle2Rpc3BsYXk6YmxvY2s7bWFyZ2luLWJvdHRvbToxNnB4fS5tYXQtY2FyZC1hY3Rpb25ze21hcmdpbi1sZWZ0Oi0xNnB4O21hcmdpbi1yaWdodDotMTZweDtwYWRkaW5nOjhweCAwfS5tYXQtY2FyZC1hY3Rpb25zW2FsaWduPWVuZF17ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LWVuZH0ubWF0LWNhcmQtaW1hZ2V7d2lkdGg6Y2FsYygxMDAlICsgNDhweCk7bWFyZ2luOjAgLTI0cHggMTZweCAtMjRweH0ubWF0LWNhcmQteGwtaW1hZ2V7d2lkdGg6MjQwcHg7aGVpZ2h0OjI0MHB4O21hcmdpbjotOHB4fS5tYXQtY2FyZC1mb290ZXJ7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJTttaW4taGVpZ2h0OjVweDtib3R0b206MDtsZWZ0OjB9Lm1hdC1jYXJkLWFjdGlvbnMgLm1hdC1idXR0b24sLm1hdC1jYXJkLWFjdGlvbnMgLm1hdC1yYWlzZWQtYnV0dG9ue21hcmdpbjowIDRweH0ubWF0LWNhcmQtaGVhZGVye2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3d9Lm1hdC1jYXJkLWhlYWRlci10ZXh0e21hcmdpbjowIDhweH0ubWF0LWNhcmQtYXZhdGFye2hlaWdodDo0MHB4O3dpZHRoOjQwcHg7Ym9yZGVyLXJhZGl1czo1MCU7ZmxleC1zaHJpbms6MH0ubWF0LWNhcmQtbGctaW1hZ2UsLm1hdC1jYXJkLW1kLWltYWdlLC5tYXQtY2FyZC1zbS1pbWFnZXttYXJnaW46LThweCAwfS5tYXQtY2FyZC10aXRsZS1ncm91cHtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47bWFyZ2luOjAgLThweH0ubWF0LWNhcmQtc20taW1hZ2V7d2lkdGg6ODBweDtoZWlnaHQ6ODBweH0ubWF0LWNhcmQtbWQtaW1hZ2V7d2lkdGg6MTEycHg7aGVpZ2h0OjExMnB4fS5tYXQtY2FyZC1sZy1pbWFnZXt3aWR0aDoxNTJweDtoZWlnaHQ6MTUycHh9QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpey5tYXQtY2FyZHtwYWRkaW5nOjI0cHggMTZweH0ubWF0LWNhcmQtYWN0aW9uc3ttYXJnaW4tbGVmdDotOHB4O21hcmdpbi1yaWdodDotOHB4fS5tYXQtY2FyZC1pbWFnZXt3aWR0aDpjYWxjKDEwMCUgKyAzMnB4KTttYXJnaW46MTZweCAtMTZweH0ubWF0LWNhcmQtdGl0bGUtZ3JvdXB7bWFyZ2luOjB9Lm1hdC1jYXJkLXhsLWltYWdle21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjB9Lm1hdC1jYXJkLWhlYWRlcnttYXJnaW46LThweCAwIDAgMH19Lm1hdC1jYXJkLWNvbnRlbnQ+OmZpcnN0LWNoaWxkLC5tYXQtY2FyZD46Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDowfS5tYXQtY2FyZC1jb250ZW50PjpsYXN0LWNoaWxkLC5tYXQtY2FyZD46bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjB9Lm1hdC1jYXJkLWltYWdlOmZpcnN0LWNoaWxke21hcmdpbi10b3A6LTI0cHh9Lm1hdC1jYXJkPi5tYXQtY2FyZC1hY3Rpb25zOmxhc3QtY2hpbGR7bWFyZ2luLWJvdHRvbTotMTZweDtwYWRkaW5nLWJvdHRvbTowfS5tYXQtY2FyZC1hY3Rpb25zIC5tYXQtYnV0dG9uOmZpcnN0LWNoaWxkLC5tYXQtY2FyZC1hY3Rpb25zIC5tYXQtcmFpc2VkLWJ1dHRvbjpmaXJzdC1jaGlsZHttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5tYXQtY2FyZC1zdWJ0aXRsZTpub3QoOmZpcnN0LWNoaWxkKSwubWF0LWNhcmQtdGl0bGU6bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLXRvcDotNHB4fS5tYXQtY2FyZC1oZWFkZXIgLm1hdC1jYXJkLXN1YnRpdGxlOm5vdCg6Zmlyc3QtY2hpbGQpe21hcmdpbi10b3A6LThweH0ubWF0LWNhcmQ+Lm1hdC1jYXJkLXhsLWltYWdlOmZpcnN0LWNoaWxke21hcmdpbi10b3A6LThweH0ubWF0LWNhcmQ+Lm1hdC1jYXJkLXhsLWltYWdlOmxhc3QtY2hpbGR7bWFyZ2luLWJvdHRvbTotOHB4fVwiXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21hdC1jYXJkJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FyZC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBDb21wb25lbnQgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoaW4gdGhlIGA8bWQtY2FyZD5gIGNvbXBvbmVudC4gSXQgYWRkcyBzdHlsZXMgZm9yIGFcbiAqIHByZXNldCBoZWFkZXIgc2VjdGlvbiAoaS5lLiBhIHRpdGxlLCBzdWJ0aXRsZSwgYW5kIGF2YXRhciBsYXlvdXQpLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZENhcmRIZWFkZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRIZWFkZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENhcmRIZWFkZXI7XG59KCkpO1xuTWRDYXJkSGVhZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtY2FyZC1oZWFkZXIsIG1hdC1jYXJkLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWQtY2FyZC1hdmF0YXJdLCBbbWF0LWNhcmQtYXZhdGFyXVxcXCI+PC9uZy1jb250ZW50PjxkaXYgY2xhc3M9XFxcIm1hdC1jYXJkLWhlYWRlci10ZXh0XFxcIj48bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLWNhcmQtdGl0bGUsIG1hdC1jYXJkLXRpdGxlLCBtZC1jYXJkLXN1YnRpdGxlLCBtYXQtY2FyZC1zdWJ0aXRsZSwgW21kLWNhcmQtdGl0bGVdLCBbbWF0LWNhcmQtdGl0bGVdLCBbbWQtY2FyZC1zdWJ0aXRsZV0sIFttYXQtY2FyZC1zdWJ0aXRsZV1cXFwiPjwvbmctY29udGVudD48L2Rpdj48bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtY2FyZC1oZWFkZXInIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYXJkSGVhZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIENvbXBvbmVudCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGhpbiB0aGUgPG1kLWNhcmQ+IGNvbXBvbmVudC4gSXQgYWRkcyBzdHlsZXMgZm9yIGEgcHJlc2V0XG4gKiBsYXlvdXQgdGhhdCBncm91cHMgYW4gaW1hZ2Ugd2l0aCBhIHRpdGxlIHNlY3Rpb24uXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2FyZFRpdGxlR3JvdXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRUaXRsZUdyb3VwKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkVGl0bGVHcm91cDtcbn0oKSk7XG5NZENhcmRUaXRsZUdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtY2FyZC10aXRsZS1ncm91cCwgbWF0LWNhcmQtdGl0bGUtZ3JvdXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXY+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1jYXJkLXRpdGxlLCBtYXQtY2FyZC10aXRsZSwgbWQtY2FyZC1zdWJ0aXRsZSwgbWF0LWNhcmQtc3VidGl0bGUsIFttZC1jYXJkLXRpdGxlXSwgW21hdC1jYXJkLXRpdGxlXSwgW21kLWNhcmQtc3VidGl0bGVdLCBbbWF0LWNhcmQtc3VidGl0bGVdXFxcIj48L25nLWNvbnRlbnQ+PC9kaXY+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJpbWdcXFwiPjwvbmctY29udGVudD48bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtY2FyZC10aXRsZS1ncm91cCcgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENhcmRUaXRsZUdyb3VwLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWRDYXJkTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDYXJkTW9kdWxlO1xufSgpKTtcbk1kQ2FyZE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW01kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kQ2FyZCxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkSGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRUaXRsZUdyb3VwLFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBNZENhcmRUaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkU3VidGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kQ2FyZEFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIE1kQ2FyZEZvb3RlcixcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkU21JbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkTWRJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkTGdJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkSW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIE1kQ2FyZFhsSW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIE1kQ2FyZEF2YXRhcixcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkLCBNZENhcmRIZWFkZXIsIE1kQ2FyZFRpdGxlR3JvdXAsIE1kQ2FyZENvbnRlbnQsIE1kQ2FyZFRpdGxlLCBNZENhcmRTdWJ0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkQWN0aW9ucywgTWRDYXJkRm9vdGVyLCBNZENhcmRTbUltYWdlLCBNZENhcmRNZEltYWdlLCBNZENhcmRMZ0ltYWdlLCBNZENhcmRJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDYXJkWGxJbWFnZSwgTWRDYXJkQXZhdGFyLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2FyZE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kQ2hpcEJhc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZENoaXBCYXNlKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ2hpcEJhc2U7XG59KCkpO1xudmFyIF9NZENoaXBNaXhpbkJhc2UgPSBtaXhpbkNvbG9yKG1peGluRGlzYWJsZWQoTWRDaGlwQmFzZSksICdwcmltYXJ5Jyk7XG4vKipcbiAqIER1bW15IGRpcmVjdGl2ZSB0byBhZGQgQ1NTIGNsYXNzIHRvIGJhc2ljIGNoaXBzLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEJhc2ljQ2hpcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQmFzaWNDaGlwKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRCYXNpY0NoaXA7XG59KCkpO1xuTWRCYXNpY0NoaXAuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCJtZC1iYXNpYy1jaGlwLCBbbWQtYmFzaWMtY2hpcF0sIG1hdC1iYXNpYy1jaGlwLCBbbWF0LWJhc2ljLWNoaXBdXCIsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWJhc2ljLWNoaXAnIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRCYXNpY0NoaXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogTWF0ZXJpYWwgZGVzaWduIHN0eWxlZCBDaGlwIGNvbXBvbmVudC4gVXNlZCBpbnNpZGUgdGhlIE1kQ2hpcExpc3QgY29tcG9uZW50LlxuICovXG52YXIgTWRDaGlwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRDaGlwLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZENoaXAocmVuZGVyZXIsIGVsZW1lbnRSZWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVuZGVyZXIsIGVsZW1lbnRSZWYpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2hpcCBoYXMgZm9jdXMuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5faGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgY2hpcCBpcyBmb2N1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgY2hpcCBpcyBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgY2hpcCBpcyBkZXNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZGVzZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIGNoaXAgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZGVzdHJveSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGlwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjaGlwIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zZWxlY3RlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgICAgICAodGhpcy5zZWxlY3RlZCA/IHRoaXMuc2VsZWN0IDogdGhpcy5kZXNlbGVjdCkuZW1pdCh7IGNoaXA6IHRoaXMgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGlwLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95LmVtaXQoeyBjaGlwOiB0aGlzIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgY3VycmVudCBzZWxlY3RlZCBzdGF0ZSBvZiB0aGlzIGNoaXAuXG4gICAgICogQHJldHVybiB7P30gV2hldGhlciB0aGUgY2hpcCBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBNZENoaXAucHJvdG90eXBlLnRvZ2dsZVNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gIXRoaXMuc2VsZWN0ZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxsb3dzIGZvciBwcm9ncmFtbWF0aWMgZm9jdXNpbmcgb2YgdGhlIGNoaXAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoaXAucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5vbkZvY3VzLmVtaXQoeyBjaGlwOiB0aGlzIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBldmVudHMgZmlyZSBwcm9wZXJseSB1cG9uIGNsaWNrLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hpcC5wcm90b3R5cGUuX2hhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIENoZWNrIGRpc2FibGVkXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZENoaXA7XG59KF9NZENoaXBNaXhpbkJhc2UpKTtcbk1kQ2hpcC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBcIm1kLWJhc2ljLWNoaXAsIFttZC1iYXNpYy1jaGlwXSwgbWQtY2hpcCwgW21kLWNoaXBdLFxcbiAgICAgICAgICAgICBtYXQtYmFzaWMtY2hpcCwgW21hdC1iYXNpYy1jaGlwXSwgbWF0LWNoaXAsIFttYXQtY2hpcF1cIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sb3InLCAnZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtY2hpcCcsXG4gICAgICAgICAgICAgICAgICAgICd0YWJpbmRleCc6ICctMScsXG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ29wdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoaXAtc2VsZWN0ZWRdJzogJ3NlbGVjdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmRpc2FibGVkXSc6ICdkaXNhYmxlZCB8fCBudWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkLnRvU3RyaW5nKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdfaGFuZGxlQ2xpY2soJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ19oYXNGb2N1cyA9IHRydWUnLFxuICAgICAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ19oYXNGb2N1cyA9IGZhbHNlJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kQ2hpcC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG5dOyB9O1xuTWRDaGlwLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdzZWxlY3RlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc2VsZWN0JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnZGVzZWxlY3QnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdkZXN0cm95JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG4vKipcbiAqIEEgbWF0ZXJpYWwgZGVzaWduIGNoaXBzIGNvbXBvbmVudCAobmFtZWQgQ2hpcExpc3QgZm9yIGl0J3Mgc2ltaWxhcml0eSB0byB0aGUgTGlzdCBjb21wb25lbnQpLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDxtZC1jaGlwLWxpc3Q+XG4gKiAgICAgICA8bWQtY2hpcD5DaGlwIDE8bWQtY2hpcD5cbiAqICAgICAgIDxtZC1jaGlwPkNoaXAgMjxtZC1jaGlwPlxuICogICAgIDwvbWQtY2hpcC1saXN0PlxuICovXG52YXIgTWRDaGlwTGlzdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2hpcExpc3QoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFjayB3aGljaCBjaGlwcyB3ZSdyZSBsaXN0ZW5pbmcgdG8gZm9yIGZvY3VzL2Rlc3RydWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlZCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgY2hpcCBpcyBzZWxlY3RhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0YWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWIgaW5kZXggZm9yIHRoZSBjaGlwIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90YWJJbmRleCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEZvY3VzS2V5TWFuYWdlcih0aGlzLmNoaXBzKS53aXRoV3JhcCgpO1xuICAgICAgICAvLyBQcmV2ZW50cyB0aGUgY2hpcCBsaXN0IGZyb20gY2FwdHVyaW5nIGZvY3VzIGFuZCByZWRpcmVjdGluZ1xuICAgICAgICAvLyBpdCBiYWNrIHRvIHRoZSBmaXJzdCBjaGlwIHdoZW4gdGhlIHVzZXIgdGFicyBvdXQuXG4gICAgICAgIHRoaXMuX3RhYk91dFN1YnNjcmlwdGlvbiA9IHRoaXMuX2tleU1hbmFnZXIudGFiT3V0LnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fdGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3RhYkluZGV4ID0gMDsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBHbyBhaGVhZCBhbmQgc3Vic2NyaWJlIGFsbCBvZiB0aGUgaW5pdGlhbCBjaGlwc1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVDaGlwcyh0aGlzLmNoaXBzKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgbGlzdCBjaGFuZ2VzLCByZS1zdWJzY3JpYmVcbiAgICAgICAgdGhpcy5jaGlwcy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoY2hpcHMpIHtcbiAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpYmVDaGlwcyhjaGlwcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhYk91dFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdGFiT3V0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoaXBMaXN0LnByb3RvdHlwZSwgXCJzZWxlY3RhYmxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgY2hpcCBpcyBzZWxlY3RhYmxlLiBXaGVuIGEgY2hpcCBpcyBub3Qgc2VsZWN0YWJsZSxcbiAgICAgICAgICogaXQncyBzZWxlY3RlZCBzdGF0ZSBpcyBhbHdheXMgaWdub3JlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2VsZWN0YWJsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RhYmxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbW1hdGljYWxseSBmb2N1cyB0aGUgY2hpcCBsaXN0LiBUaGlzIGluIHR1cm4gZm9jdXNlcyB0aGUgZmlyc3RcbiAgICAgKiBub24tZGlzYWJsZWQgY2hpcCBpbiB0aGlzIGNoaXAgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hpcExpc3QucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiBBUklBIHNheXMgdGhpcyBzaG91bGQgZm9jdXMgdGhlIGZpcnN0IGBzZWxlY3RlZGAgY2hpcC5cbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRGaXJzdEl0ZW1BY3RpdmUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhc3NlcyByZWxldmFudCBrZXkgcHJlc3NlcyB0byBvdXIga2V5IG1hbmFnZXIuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUuX2tleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFyZ2V0ID0gKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIC8vIElmIHRoZXkgYXJlIG9uIGEgY2hpcCwgY2hlY2sgZm9yIHNwYWNlL2xlZnQvcmlnaHQsIG90aGVyd2lzZSBwYXNzIHRvIG91ciBrZXkgbWFuYWdlclxuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ21hdC1jaGlwJykpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBzZWxlY3RhYmxlLCB0b2dnbGUgdGhlIGZvY3VzZWQgY2hpcFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVTZWxlY3RPbkZvY3VzZWRDaGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHByZXZlbnQgc3BhY2UgZnJvbSBzY3JvbGxpbmcgdGhlIHBhZ2Ugc2luY2UgdGhlIGxpc3QgaGFzIGZvY3VzXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRQcmV2aW91c0l0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXROZXh0SXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBjaGlwLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUuX3RvZ2dsZVNlbGVjdE9uRm9jdXNlZENoaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFsbG93IGRpc2FibGluZyBvZiBjaGlwIHNlbGVjdGlvblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvY3VzZWRJbmRleCA9IHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbUluZGV4O1xuICAgICAgICBpZiAodHlwZW9mIGZvY3VzZWRJbmRleCA9PT0gJ251bWJlcicgJiYgdGhpcy5faXNWYWxpZEluZGV4KGZvY3VzZWRJbmRleCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvY3VzZWRDaGlwID0gdGhpcy5jaGlwcy50b0FycmF5KClbZm9jdXNlZEluZGV4XTtcbiAgICAgICAgICAgIGlmIChmb2N1c2VkQ2hpcCkge1xuICAgICAgICAgICAgICAgIGZvY3VzZWRDaGlwLnRvZ2dsZVNlbGVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiBjaGlwcyBhbmQgYWRkIHRoZW0gdG8gb3VyIGxpc3Qgb2ZcbiAgICAgKiBzdWJzY3JpYmVkIGNoaXBzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBjaGlwcyBUaGUgbGlzdCBvZiBjaGlwcyB0byBiZSBzdWJzY3JpYmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUuX3N1YnNjcmliZUNoaXBzID0gZnVuY3Rpb24gKGNoaXBzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNoaXBzLmZvckVhY2goZnVuY3Rpb24gKGNoaXApIHsgcmV0dXJuIF90aGlzLl9hZGRDaGlwKGNoaXApOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHNwZWNpZmljIGNoaXAgdG8gb3VyIHN1YnNjcmliZWQgbGlzdC4gSWYgdGhlIGNoaXAgaGFzXG4gICAgICogYWxyZWFkeSBiZWVuIHN1YnNjcmliZWQsIHRoaXMgZW5zdXJlcyBpdCBpcyBvbmx5IHN1YnNjcmliZWRcbiAgICAgKiBvbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBjaGlwIFRoZSBjaGlwIHRvIGJlIHN1YnNjcmliZWQgKG9yIGNoZWNrZWQgZm9yIGV4aXN0aW5nXG4gICAgICogc3Vic2NyaXB0aW9uKS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2hpcExpc3QucHJvdG90eXBlLl9hZGRDaGlwID0gZnVuY3Rpb24gKGNoaXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBiZWVuIHN1YnNjcmliZWQgdG8gYSBwYXJlbnQsIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmliZWQuaGFzKGNoaXApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2F0Y2ggZm9yIGZvY3VzIGV2ZW50cyBvdXRzaWRlIG9mIHRoZSBrZXlib2FyZCBuYXZpZ2F0aW9uXG4gICAgICAgIGNoaXAub25Gb2N1cy5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpcEluZGV4ID0gX3RoaXMuY2hpcHMudG9BcnJheSgpLmluZGV4T2YoY2hpcCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2lzVmFsaWRJbmRleChjaGlwSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2tleU1hbmFnZXIudXBkYXRlQWN0aXZlSXRlbUluZGV4KGNoaXBJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPbiBkZXN0cm95LCByZW1vdmUgdGhlIGl0ZW0gZnJvbSBvdXIgbGlzdCwgYW5kIGNoZWNrIGZvY3VzXG4gICAgICAgIGNoaXAuZGVzdHJveS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpcEluZGV4ID0gX3RoaXMuY2hpcHMudG9BcnJheSgpLmluZGV4T2YoY2hpcCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2lzVmFsaWRJbmRleChjaGlwSW5kZXgpICYmIGNoaXAuX2hhc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgY2hpcCBpcyB0aGUgbGFzdCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKGNoaXBJbmRleCA8IF90aGlzLmNoaXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShjaGlwSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlwSW5kZXggLSAxID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShjaGlwSW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaWJlZC5kZWxldGUoY2hpcCk7XG4gICAgICAgICAgICBjaGlwLmRlc3Ryb3kudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZWQuc2V0KGNoaXAsIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBlbnN1cmUgYWxsIGluZGV4ZXMgYXJlIHZhbGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleCBUaGUgaW5kZXggdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHs/fSBUcnVlIGlmIHRoZSBpbmRleCBpcyB2YWxpZCBmb3Igb3VyIGxpc3Qgb2YgY2hpcHMuXG4gICAgICovXG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUuX2lzVmFsaWRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuY2hpcHMubGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIE1kQ2hpcExpc3Q7XG59KCkpO1xuTWRDaGlwTGlzdC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLWNoaXAtbGlzdCwgbWF0LWNoaXAtbGlzdCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LWNoaXAtbGlzdC13cmFwcGVyXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci50YWJpbmRleF0nOiAnX3RhYkluZGV4JyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnbGlzdGJveCcsXG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtY2hpcC1saXN0JyxcbiAgICAgICAgICAgICAgICAgICAgLy8gRXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ2ZvY3VzKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19rZXlkb3duKCRldmVudCknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNoaXBzOiBuZXcgQ29udGVudENoaWxkcmVuKE1kQ2hpcClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1jaGlwLWxpc3Qtd3JhcHBlcntkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWl0ZW1zOmZsZXgtc3RhcnR9Lm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApe2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6OHB4IDEycHggOHB4IDEycHg7Ym9yZGVyLXJhZGl1czoyNHB4fS5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKSsubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCl7bWFyZ2luOjAgMCAwIDNweH1bZGlyPXJ0bF0gLm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApKy5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKXttYXJnaW46MCAzcHggMCAwfS5tYXQtY2hpcC1saXN0LXN0YWNrZWQgLm1hdC1jaGlwLWxpc3Qtd3JhcHBlcntkaXNwbGF5OmJsb2NrfS5tYXQtY2hpcC1saXN0LXN0YWNrZWQgLm1hdC1jaGlwLWxpc3Qtd3JhcHBlciAubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCl7ZGlzcGxheTpibG9jazttYXJnaW46MDttYXJnaW4tYm90dG9tOjhweH1bZGlyPXJ0bF0gLm1hdC1jaGlwLWxpc3Qtc3RhY2tlZCAubWF0LWNoaXAtbGlzdC13cmFwcGVyIC5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKXttYXJnaW46MDttYXJnaW4tYm90dG9tOjhweH0ubWF0LWNoaXAtbGlzdC1zdGFja2VkIC5tYXQtY2hpcC1saXN0LXdyYXBwZXIgLm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApOmxhc3QtY2hpbGQsW2Rpcj1ydGxdIC5tYXQtY2hpcC1saXN0LXN0YWNrZWQgLm1hdC1jaGlwLWxpc3Qtd3JhcHBlciAubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCk6bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjB9XCJdLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDaGlwTGlzdC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuTWRDaGlwTGlzdC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnc2VsZWN0YWJsZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG52YXIgTWRDaGlwc01vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2hpcHNNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENoaXBzTW9kdWxlO1xufSgpKTtcbk1kQ2hpcHNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZENoaXBMaXN0LCBNZENoaXAsIE1kQmFzaWNDaGlwXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZENoaXBMaXN0LCBNZENoaXAsIE1kQmFzaWNDaGlwXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENoaXBzTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFJldHVybnMgYW4gZXhjZXB0aW9uIHRvIGJlIHRocm93biBpbiB0aGUgY2FzZSB3aGVuIGF0dGVtcHRpbmcgdG9cbiAqIGxvYWQgYW4gaWNvbiB3aXRoIGEgbmFtZSB0aGF0IGNhbm5vdCBiZSBmb3VuZC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHBhcmFtIHs/fSBpY29uTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TWRJY29uTmFtZU5vdEZvdW5kRXJyb3IoaWNvbk5hbWUpIHtcbiAgICByZXR1cm4gRXJyb3IoXCJVbmFibGUgdG8gZmluZCBpY29uIHdpdGggdGhlIG5hbWUgXFxcIlwiICsgaWNvbk5hbWUgKyBcIlxcXCJcIik7XG59XG4vKipcbiAqIFJldHVybnMgYW4gZXhjZXB0aW9uIHRvIGJlIHRocm93biB3aGVuIHRoZSBjb25zdW1lciBhdHRlbXB0cyB0byB1c2VcbiAqIGA8bWQtaWNvbj5gIHdpdGhvdXQgaW5jbHVkaW5nIFxcQGFuZ3VsYXIvaHR0cC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TWRJY29uTm9IdHRwUHJvdmlkZXJFcnJvcigpIHtcbiAgICByZXR1cm4gRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIEh0dHAgcHJvdmlkZXIgZm9yIHVzZSB3aXRoIEFuZ3VsYXIgTWF0ZXJpYWwgaWNvbnMuICcgK1xuICAgICAgICAnUGxlYXNlIGluY2x1ZGUgdGhlIEh0dHBNb2R1bGUgZnJvbSBAYW5ndWxhci9odHRwIGluIHlvdXIgYXBwIGltcG9ydHMuJyk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gZXhjZXB0aW9uIHRvIGJlIHRocm93biB3aGVuIGEgVVJMIGNvdWxkbid0IGJlIHNhbml0aXplZC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHBhcmFtIHs/fSB1cmwgVVJMIHRoYXQgd2FzIGF0dGVtcHRlZCB0byBiZSBzYW5pdGl6ZWQuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRNZEljb25GYWlsZWRUb1Nhbml0aXplRXJyb3IodXJsKSB7XG4gICAgcmV0dXJuIEVycm9yKFwiVGhlIFVSTCBwcm92aWRlZCB0byBNZEljb25SZWdpc3RyeSB3YXMgbm90IHRydXN0ZWQgYXMgYSByZXNvdXJjZSBVUkwgXCIgK1xuICAgICAgICAoXCJ2aWEgQW5ndWxhcidzIERvbVNhbml0aXplci4gQXR0ZW1wdGVkIFVSTCB3YXMgXFxcIlwiICsgdXJsICsgXCJcXFwiLlwiKSk7XG59XG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGFuIGljb24sIGluY2x1ZGluZyB0aGUgVVJMIGFuZCBwb3NzaWJseSB0aGUgY2FjaGVkIFNWRyBlbGVtZW50LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBTdmdJY29uQ29uZmlnID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdmdJY29uQ29uZmlnKHVybCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFN2Z0ljb25Db25maWc7XG59KCkpO1xuLyoqXG4gKiBTZXJ2aWNlIHRvIHJlZ2lzdGVyIGFuZCBkaXNwbGF5IGljb25zIHVzZWQgYnkgdGhlIDxtZC1pY29uPiBjb21wb25lbnQuXG4gKiAtIFJlZ2lzdGVycyBpY29uIFVSTHMgYnkgbmFtZXNwYWNlIGFuZCBuYW1lLlxuICogLSBSZWdpc3RlcnMgaWNvbiBzZXQgVVJMcyBieSBuYW1lc3BhY2UuXG4gKiAtIFJlZ2lzdGVycyBhbGlhc2VzIGZvciBDU1MgY2xhc3NlcywgZm9yIHVzZSB3aXRoIGljb24gZm9udHMuXG4gKiAtIExvYWRzIGljb25zIGZyb20gVVJMcyBhbmQgZXh0cmFjdHMgaW5kaXZpZHVhbCBpY29ucyBmcm9tIGljb24gc2V0cy5cbiAqL1xudmFyIE1kSWNvblJlZ2lzdHJ5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfaHR0cFxuICAgICAqIEBwYXJhbSB7P30gX3Nhbml0aXplclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kSWNvblJlZ2lzdHJ5KF9odHRwLCBfc2FuaXRpemVyKSB7XG4gICAgICAgIHRoaXMuX2h0dHAgPSBfaHR0cDtcbiAgICAgICAgdGhpcy5fc2FuaXRpemVyID0gX3Nhbml0aXplcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVSTHMgYW5kIGNhY2hlZCBTVkcgZWxlbWVudHMgZm9yIGluZGl2aWR1YWwgaWNvbnMuIEtleXMgYXJlIG9mIHRoZSBmb3JtYXQgXCJbbmFtZXNwYWNlXTpbaWNvbl1cIi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N2Z0ljb25Db25maWdzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3ZnSWNvbkNvbmZpZyBvYmplY3RzIGFuZCBjYWNoZWQgU1ZHIGVsZW1lbnRzIGZvciBpY29uIHNldHMsIGtleWVkIGJ5IG5hbWVzcGFjZS5cbiAgICAgICAgICogTXVsdGlwbGUgaWNvbiBzZXRzIGNhbiBiZSByZWdpc3RlcmVkIHVuZGVyIHRoZSBzYW1lIG5hbWVzcGFjZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ljb25TZXRDb25maWdzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGUgZm9yIGljb25zIGxvYWRlZCBieSBkaXJlY3QgVVJMcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NhY2hlZEljb25zQnlVcmwgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbi1wcm9ncmVzcyBpY29uIGZldGNoZXMuIFVzZWQgdG8gY29hbGVzY2UgbXVsdGlwbGUgcmVxdWVzdHMgdG8gdGhlIHNhbWUgVVJMLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5Qcm9ncmVzc1VybEZldGNoZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgZnJvbSBmb250IGlkZW50aWZpZXJzIHRvIHRoZWlyIENTUyBjbGFzcyBuYW1lcy4gVXNlZCBmb3IgaWNvbiBmb250cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZvbnRDc3NDbGFzc2VzQnlBbGlhcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBDU1MgY2xhc3MgdG8gYXBwbHkgd2hlbiBhbiA8bWQtaWNvbj4gY29tcG9uZW50IGhhcyBubyBpY29uIG5hbWUsIHVybCwgb3IgZm9udCBzcGVjaWZpZWQuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0ICdtYXRlcmlhbC1pY29ucycgdmFsdWUgYXNzdW1lcyB0aGF0IHRoZSBtYXRlcmlhbCBpY29uIGZvbnQgaGFzIGJlZW4gbG9hZGVkIGFzXG4gICAgICAgICAqIGRlc2NyaWJlZCBhdCBodHRwOi8vZ29vZ2xlLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbnMvI2ljb24tZm9udC1mb3ItdGhlLXdlYlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGVmYXVsdEZvbnRTZXRDbGFzcyA9ICdtYXRlcmlhbC1pY29ucyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpY29uIGJ5IFVSTCBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIHs/fSBpY29uTmFtZSBOYW1lIHVuZGVyIHdoaWNoIHRoZSBpY29uIHNob3VsZCBiZSByZWdpc3RlcmVkLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuYWRkU3ZnSWNvbiA9IGZ1bmN0aW9uIChpY29uTmFtZSwgdXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFN2Z0ljb25Jbk5hbWVzcGFjZSgnJywgaWNvbk5hbWUsIHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaWNvbiBieSBVUkwgaW4gdGhlIHNwZWNpZmllZCBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2UgTmFtZXNwYWNlIGluIHdoaWNoIHRoZSBpY29uIHNob3VsZCBiZSByZWdpc3RlcmVkLlxuICAgICAqIEBwYXJhbSB7P30gaWNvbk5hbWUgTmFtZSB1bmRlciB3aGljaCB0aGUgaWNvbiBzaG91bGQgYmUgcmVnaXN0ZXJlZC5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmFkZFN2Z0ljb25Jbk5hbWVzcGFjZSA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIGljb25OYW1lLCB1cmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gaWNvbktleShuYW1lc3BhY2UsIGljb25OYW1lKTtcbiAgICAgICAgdGhpcy5fc3ZnSWNvbkNvbmZpZ3Muc2V0KGtleSwgbmV3IFN2Z0ljb25Db25maWcodXJsKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGljb24gc2V0IGJ5IFVSTCBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5hZGRTdmdJY29uU2V0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTdmdJY29uU2V0SW5OYW1lc3BhY2UoJycsIHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaWNvbiBzZXQgYnkgVVJMIGluIHRoZSBzcGVjaWZpZWQgbmFtZXNwYWNlLlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlIE5hbWVzcGFjZSBpbiB3aGljaCB0byByZWdpc3RlciB0aGUgaWNvbiBzZXQuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5hZGRTdmdJY29uU2V0SW5OYW1lc3BhY2UgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCB1cmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gbmV3IFN2Z0ljb25Db25maWcodXJsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnTmFtZXNwYWNlID0gdGhpcy5faWNvblNldENvbmZpZ3MuZ2V0KG5hbWVzcGFjZSk7XG4gICAgICAgIGlmIChjb25maWdOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIGNvbmZpZ05hbWVzcGFjZS5wdXNoKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pY29uU2V0Q29uZmlncy5zZXQobmFtZXNwYWNlLCBbY29uZmlnXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGFuIGFsaWFzIGZvciBhIENTUyBjbGFzcyBuYW1lIHRvIGJlIHVzZWQgZm9yIGljb24gZm9udHMuIENyZWF0aW5nIGFuIG1kSWNvblxuICAgICAqIGNvbXBvbmVudCB3aXRoIHRoZSBhbGlhcyBhcyB0aGUgZm9udFNldCBpbnB1dCB3aWxsIGNhdXNlIHRoZSBjbGFzcyBuYW1lIHRvIGJlIGFwcGxpZWRcbiAgICAgKiB0byB0aGUgPG1kLWljb24+IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGFsaWFzIEFsaWFzIGZvciB0aGUgZm9udC5cbiAgICAgKiBAcGFyYW0gez89fSBjbGFzc05hbWUgQ2xhc3MgbmFtZSBvdmVycmlkZSB0byBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGFsaWFzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyRm9udENsYXNzQWxpYXMgPSBmdW5jdGlvbiAoYWxpYXMsIGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoY2xhc3NOYW1lID09PSB2b2lkIDApIHsgY2xhc3NOYW1lID0gYWxpYXM7IH1cbiAgICAgICAgdGhpcy5fZm9udENzc0NsYXNzZXNCeUFsaWFzLnNldChhbGlhcywgY2xhc3NOYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBDU1MgY2xhc3MgbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFsaWFzIGJ5IGEgcHJldmlvdXMgY2FsbCB0b1xuICAgICAqIHJlZ2lzdGVyRm9udENsYXNzQWxpYXMuIElmIG5vIENTUyBjbGFzcyBoYXMgYmVlbiBhc3NvY2lhdGVkLCByZXR1cm5zIHRoZSBhbGlhcyB1bm1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSB7P30gYWxpYXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5jbGFzc05hbWVGb3JGb250QWxpYXMgPSBmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRDc3NDbGFzc2VzQnlBbGlhcy5nZXQoYWxpYXMpIHx8IGFsaWFzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgQ1NTIGNsYXNzIG5hbWUgdG8gYmUgdXNlZCBmb3IgaWNvbiBmb250cyB3aGVuIGFuIDxtZC1pY29uPiBjb21wb25lbnQgZG9lcyBub3RcbiAgICAgKiBoYXZlIGEgZm9udFNldCBpbnB1dCB2YWx1ZSwgYW5kIGlzIG5vdCBsb2FkaW5nIGFuIGljb24gYnkgbmFtZSBvciBVUkwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGNsYXNzTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLnNldERlZmF1bHRGb250U2V0Q2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRGb250U2V0Q2xhc3MgPSBjbGFzc05hbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQ1NTIGNsYXNzIG5hbWUgdG8gYmUgdXNlZCBmb3IgaWNvbiBmb250cyB3aGVuIGFuIDxtZC1pY29uPiBjb21wb25lbnQgZG9lcyBub3RcbiAgICAgKiBoYXZlIGEgZm9udFNldCBpbnB1dCB2YWx1ZSwgYW5kIGlzIG5vdCBsb2FkaW5nIGFuIGljb24gYnkgbmFtZSBvciBVUkwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdEZvbnRTZXRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRGb250U2V0Q2xhc3M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBwcm9kdWNlcyB0aGUgaWNvbiAoYXMgYW4gPHN2Zz4gRE9NIGVsZW1lbnQpIGZyb20gdGhlIGdpdmVuIFVSTC5cbiAgICAgKiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgVVJMIG1heSBiZSBjYWNoZWQgc28gdGhpcyB3aWxsIG5vdCBhbHdheXMgY2F1c2UgYW4gSFRUUCByZXF1ZXN0LCBidXRcbiAgICAgKiB0aGUgcHJvZHVjZWQgZWxlbWVudCB3aWxsIGFsd2F5cyBiZSBhIG5ldyBjb3B5IG9mIHRoZSBvcmlnaW5hbGx5IGZldGNoZWQgaWNvbi4gKFRoYXQgaXMsXG4gICAgICogaXQgd2lsbCBub3QgY29udGFpbiBhbnkgbW9kaWZpY2F0aW9ucyBtYWRlIHRvIGVsZW1lbnRzIHByZXZpb3VzbHkgcmV0dXJuZWQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBzYWZlVXJsIFVSTCBmcm9tIHdoaWNoIHRvIGZldGNoIHRoZSBTVkcgaWNvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRTdmdJY29uRnJvbVVybCA9IGZ1bmN0aW9uIChzYWZlVXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybCA9IHRoaXMuX3Nhbml0aXplci5zYW5pdGl6ZShTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBzYWZlVXJsKTtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kSWNvbkZhaWxlZFRvU2FuaXRpemVFcnJvcihzYWZlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYWNoZWRJY29uID0gdGhpcy5fY2FjaGVkSWNvbnNCeVVybC5nZXQodXJsKTtcbiAgICAgICAgaWYgKGNhY2hlZEljb24pIHtcbiAgICAgICAgICAgIHJldHVybiBvZihjbG9uZVN2ZyhjYWNoZWRJY29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJ4Q2hhaW4uZnJvbSh0aGlzLl9sb2FkU3ZnSWNvbkZyb21Db25maWcobmV3IFN2Z0ljb25Db25maWcodXJsKSkpXG4gICAgICAgICAgICAuY2FsbChkb09wZXJhdG9yLCBmdW5jdGlvbiAoc3ZnKSB7IHJldHVybiBfdGhpcy5fY2FjaGVkSWNvbnNCeVVybC5zZXQoLyoqIEB0eXBlIHs/fSAqLyAoKHVybCkpLCBzdmcpOyB9KVxuICAgICAgICAgICAgLmNhbGwobWFwLCBmdW5jdGlvbiAoc3ZnKSB7IHJldHVybiBjbG9uZVN2ZyhzdmcpOyB9KVxuICAgICAgICAgICAgLnJlc3VsdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgcHJvZHVjZXMgdGhlIGljb24gKGFzIGFuIDxzdmc+IERPTSBlbGVtZW50KSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAgICogYW5kIG5hbWVzcGFjZS4gVGhlIGljb24gbXVzdCBoYXZlIGJlZW4gcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkSWNvbiBvciBhZGRJY29uU2V0O1xuICAgICAqIGlmIG5vdCwgdGhlIE9ic2VydmFibGUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZSBOYW1lIG9mIHRoZSBpY29uIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2UgTmFtZXNwYWNlIGluIHdoaWNoIHRvIGxvb2sgZm9yIHRoZSBpY29uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmdldE5hbWVkU3ZnSWNvbiA9IGZ1bmN0aW9uIChuYW1lLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdm9pZCAwKSB7IG5hbWVzcGFjZSA9ICcnOyB9XG4gICAgICAgIC8vIFJldHVybiAoY29weSBvZikgY2FjaGVkIGljb24gaWYgcG9zc2libGUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IGljb25LZXkobmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gdGhpcy5fc3ZnSWNvbkNvbmZpZ3MuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRTdmdGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGlmIHdlIGhhdmUgYW55IGljb24gc2V0cyByZWdpc3RlcmVkIGZvciB0aGUgbmFtZXNwYWNlLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpY29uU2V0Q29uZmlncyA9IHRoaXMuX2ljb25TZXRDb25maWdzLmdldChuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoaWNvblNldENvbmZpZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRTdmdGcm9tSWNvblNldENvbmZpZ3MobmFtZSwgaWNvblNldENvbmZpZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhyb3coZ2V0TWRJY29uTmFtZU5vdEZvdW5kRXJyb3Ioa2V5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjYWNoZWQgaWNvbiBmb3IgYSBTdmdJY29uQ29uZmlnIGlmIGF2YWlsYWJsZSwgb3IgZmV0Y2hlcyBpdCBmcm9tIGl0cyBVUkwgaWYgbm90LlxuICAgICAqIEBwYXJhbSB7P30gY29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2dldFN2Z0Zyb21Db25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSBTVkcgZWxlbWVudCBmb3IgdGhpcyBpY29uLCByZXR1cm4gYSBjb3B5LlxuICAgICAgICAgICAgcmV0dXJuIG9mKGNsb25lU3ZnKGNvbmZpZy5zdmdFbGVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgaWNvbiBmcm9tIHRoZSBjb25maWcncyBVUkwsIGNhY2hlIGl0LCBhbmQgcmV0dXJuIGEgY29weS5cbiAgICAgICAgICAgIHJldHVybiBSeENoYWluLmZyb20odGhpcy5fbG9hZFN2Z0ljb25Gcm9tQ29uZmlnKGNvbmZpZykpXG4gICAgICAgICAgICAgICAgLmNhbGwoZG9PcGVyYXRvciwgZnVuY3Rpb24gKHN2ZykgeyByZXR1cm4gY29uZmlnLnN2Z0VsZW1lbnQgPSBzdmc7IH0pXG4gICAgICAgICAgICAgICAgLmNhbGwobWFwLCBmdW5jdGlvbiAoc3ZnKSB7IHJldHVybiBjbG9uZVN2ZyhzdmcpOyB9KVxuICAgICAgICAgICAgICAgIC5yZXN1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gZmluZCBhbiBpY29uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIGluIGFueSBvZiB0aGUgU1ZHIGljb24gc2V0cy5cbiAgICAgKiBGaXJzdCBzZWFyY2hlcyB0aGUgYXZhaWxhYmxlIGNhY2hlZCBpY29ucyBmb3IgYSBuZXN0ZWQgZWxlbWVudCB3aXRoIGEgbWF0Y2hpbmcgbmFtZSwgYW5kXG4gICAgICogaWYgZm91bmQgY29waWVzIHRoZSBlbGVtZW50IHRvIGEgbmV3IDxzdmc+IGVsZW1lbnQuIElmIG5vdCBmb3VuZCwgZmV0Y2hlcyBhbGwgaWNvbiBzZXRzXG4gICAgICogdGhhdCBoYXZlIG5vdCBiZWVuIGNhY2hlZCwgYW5kIHNlYXJjaGVzIGFnYWluIGFmdGVyIGFsbCBmZXRjaGVzIGFyZSBjb21wbGV0ZWQuXG4gICAgICogVGhlIHJldHVybmVkIE9ic2VydmFibGUgcHJvZHVjZXMgdGhlIFNWRyBlbGVtZW50IGlmIHBvc3NpYmxlLCBhbmQgdGhyb3dzXG4gICAgICogYW4gZXJyb3IgaWYgbm8gaWNvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBjYW4gYmUgZm91bmQuXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBpY29uU2V0Q29uZmlnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9nZXRTdmdGcm9tSWNvblNldENvbmZpZ3MgPSBmdW5jdGlvbiAobmFtZSwgaWNvblNldENvbmZpZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRm9yIGFsbCB0aGUgaWNvbiBzZXQgU1ZHIGVsZW1lbnRzIHdlJ3ZlIGZldGNoZWQsIHNlZSBpZiBhbnkgY29udGFpbiBhbiBpY29uIHdpdGggdGhlXG4gICAgICAgIC8vIHJlcXVlc3RlZCBuYW1lLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lZEljb24gPSB0aGlzLl9leHRyYWN0SWNvbldpdGhOYW1lRnJvbUFueVNldChuYW1lLCBpY29uU2V0Q29uZmlncyk7XG4gICAgICAgIGlmIChuYW1lZEljb24pIHtcbiAgICAgICAgICAgIC8vIFdlIGNvdWxkIGNhY2hlIG5hbWVkSWNvbiBpbiBfc3ZnSWNvbkNvbmZpZ3MsIGJ1dCBzaW5jZSB3ZSBoYXZlIHRvIG1ha2UgYSBjb3B5IGV2ZXJ5XG4gICAgICAgICAgICAvLyB0aW1lIGFueXdheSwgdGhlcmUncyBwcm9iYWJseSBub3QgbXVjaCBhZHZhbnRhZ2UgY29tcGFyZWQgdG8ganVzdCBhbHdheXMgZXh0cmFjdGluZ1xuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgaWNvbiBzZXQuXG4gICAgICAgICAgICByZXR1cm4gb2YobmFtZWRJY29uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgZm91bmQgaW4gYW55IGNhY2hlZCBpY29uIHNldHMuIElmIHRoZXJlIGFyZSBpY29uIHNldHMgd2l0aCBVUkxzIHRoYXQgd2UgaGF2ZW4ndFxuICAgICAgICAvLyBmZXRjaGVkLCBmZXRjaCB0aGVtIG5vdyBhbmQgbG9vayBmb3IgaWNvbk5hbWUgaW4gdGhlIHJlc3VsdHMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGljb25TZXRGZXRjaFJlcXVlc3RzID0gaWNvblNldENvbmZpZ3NcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGljb25TZXRDb25maWcpIHsgcmV0dXJuICFpY29uU2V0Q29uZmlnLnN2Z0VsZW1lbnQ7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpY29uU2V0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gUnhDaGFpbi5mcm9tKF90aGlzLl9sb2FkU3ZnSWNvblNldEZyb21Db25maWcoaWNvblNldENvbmZpZykpXG4gICAgICAgICAgICAgICAgLmNhbGwoY2F0Y2hPcGVyYXRvciwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybCA9IF90aGlzLl9zYW5pdGl6ZXIuc2FuaXRpemUoU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCwgaWNvblNldENvbmZpZy51cmwpO1xuICAgICAgICAgICAgICAgIC8vIFN3YWxsb3cgZXJyb3JzIGZldGNoaW5nIGluZGl2aWR1YWwgVVJMcyBzbyB0aGUgY29tYmluZWQgT2JzZXJ2YWJsZSB3b24ndFxuICAgICAgICAgICAgICAgIC8vIG5lY2Vzc2FyaWx5IGZhaWwuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkaW5nIGljb24gc2V0IFVSTDogXCIgKyB1cmwgKyBcIiBmYWlsZWQ6IFwiICsgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2YobnVsbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYWxsKGRvT3BlcmF0b3IsIGZ1bmN0aW9uIChzdmcpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgU1ZHIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKHN2Zykge1xuICAgICAgICAgICAgICAgICAgICBpY29uU2V0Q29uZmlnLnN2Z0VsZW1lbnQgPSBzdmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVzdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGZXRjaCBhbGwgdGhlIGljb24gc2V0IFVSTHMuIFdoZW4gdGhlIHJlcXVlc3RzIGNvbXBsZXRlLCBldmVyeSBJY29uU2V0IHNob3VsZCBoYXZlIGFcbiAgICAgICAgLy8gY2FjaGVkIFNWRyBlbGVtZW50ICh1bmxlc3MgdGhlIHJlcXVlc3QgZmFpbGVkKSwgYW5kIHdlIGNhbiBjaGVjayBhZ2FpbiBmb3IgdGhlIGljb24uXG4gICAgICAgIHJldHVybiBtYXAuY2FsbChmb3JrSm9pbi5jYWxsKE9ic2VydmFibGUsIGljb25TZXRGZXRjaFJlcXVlc3RzKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm91bmRJY29uID0gX3RoaXMuX2V4dHJhY3RJY29uV2l0aE5hbWVGcm9tQW55U2V0KG5hbWUsIGljb25TZXRDb25maWdzKTtcbiAgICAgICAgICAgIGlmICghZm91bmRJY29uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZ2V0TWRJY29uTmFtZU5vdEZvdW5kRXJyb3IobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm91bmRJY29uO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIHRoZSBjYWNoZWQgU1ZHIGVsZW1lbnRzIGZvciB0aGUgZ2l2ZW4gaWNvbiBzZXRzIGZvciBhIG5lc3RlZCBpY29uIGVsZW1lbnQgd2hvc2UgXCJpZFwiXG4gICAgICogdGFnIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBuYW1lLiBJZiBmb3VuZCwgY29waWVzIHRoZSBuZXN0ZWQgZWxlbWVudCB0byBhIG5ldyBTVkcgZWxlbWVudCBhbmRcbiAgICAgKiByZXR1cm5zIGl0LiBSZXR1cm5zIG51bGwgaWYgbm8gbWF0Y2hpbmcgZWxlbWVudCBpcyBmb3VuZC5cbiAgICAgKiBAcGFyYW0gez99IGljb25OYW1lXG4gICAgICogQHBhcmFtIHs/fSBpY29uU2V0Q29uZmlnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9leHRyYWN0SWNvbldpdGhOYW1lRnJvbUFueVNldCA9IGZ1bmN0aW9uIChpY29uTmFtZSwgaWNvblNldENvbmZpZ3MpIHtcbiAgICAgICAgLy8gSXRlcmF0ZSBiYWNrd2FyZHMsIHNvIGljb24gc2V0cyBhZGRlZCBsYXRlciBoYXZlIHByZWNlZGVuY2UuXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IGljb25TZXRDb25maWdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25maWcgPSBpY29uU2V0Q29uZmlnc1tpXTtcbiAgICAgICAgICAgIGlmIChjb25maWcuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvdW5kSWNvbiA9IHRoaXMuX2V4dHJhY3RTdmdJY29uRnJvbVNldChjb25maWcuc3ZnRWxlbWVudCwgaWNvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZEljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kSWNvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgY29udGVudCBvZiB0aGUgaWNvbiBVUkwgc3BlY2lmaWVkIGluIHRoZSBTdmdJY29uQ29uZmlnIGFuZCBjcmVhdGVzIGFuIFNWRyBlbGVtZW50XG4gICAgICogZnJvbSBpdC5cbiAgICAgKiBAcGFyYW0gez99IGNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9sb2FkU3ZnSWNvbkZyb21Db25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtYXAuY2FsbCh0aGlzLl9mZXRjaFVybChjb25maWcudXJsKSwgZnVuY3Rpb24gKHN2Z1RleHQpIHsgcmV0dXJuIF90aGlzLl9jcmVhdGVTdmdFbGVtZW50Rm9yU2luZ2xlSWNvbihzdmdUZXh0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgY29udGVudCBvZiB0aGUgaWNvbiBzZXQgVVJMIHNwZWNpZmllZCBpbiB0aGUgU3ZnSWNvbkNvbmZpZyBhbmQgY3JlYXRlcyBhbiBTVkcgZWxlbWVudFxuICAgICAqIGZyb20gaXQuXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fbG9hZFN2Z0ljb25TZXRGcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBUT0RPOiBEb2N1bWVudCB0aGF0IGljb25zIHNob3VsZCBvbmx5IGJlIGxvYWRlZCBmcm9tIHRydXN0ZWQgc291cmNlcy5cbiAgICAgICAgcmV0dXJuIG1hcC5jYWxsKHRoaXMuX2ZldGNoVXJsKGNvbmZpZy51cmwpLCBmdW5jdGlvbiAoc3ZnVGV4dCkgeyByZXR1cm4gX3RoaXMuX3N2Z0VsZW1lbnRGcm9tU3RyaW5nKHN2Z1RleHQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBET00gZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBTVkcgc3RyaW5nLCBhbmQgYWRkcyBkZWZhdWx0IGF0dHJpYnV0ZXMuXG4gICAgICogQHBhcmFtIHs/fSByZXNwb25zZVRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fY3JlYXRlU3ZnRWxlbWVudEZvclNpbmdsZUljb24gPSBmdW5jdGlvbiAocmVzcG9uc2VUZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN2ZyA9IHRoaXMuX3N2Z0VsZW1lbnRGcm9tU3RyaW5nKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHRoaXMuX3NldFN2Z0F0dHJpYnV0ZXMoc3ZnKTtcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIHRoZSBjYWNoZWQgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gU3ZnSWNvbkNvbmZpZyBmb3IgYSBuZXN0ZWQgaWNvbiBlbGVtZW50IHdob3NlIFwiaWRcIlxuICAgICAqIHRhZyBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgbmFtZS4gSWYgZm91bmQsIGNvcGllcyB0aGUgbmVzdGVkIGVsZW1lbnQgdG8gYSBuZXcgU1ZHIGVsZW1lbnQgYW5kXG4gICAgICogcmV0dXJucyBpdC4gUmV0dXJucyBudWxsIGlmIG5vIG1hdGNoaW5nIGVsZW1lbnQgaXMgZm91bmQuXG4gICAgICogQHBhcmFtIHs/fSBpY29uU2V0XG4gICAgICogQHBhcmFtIHs/fSBpY29uTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9leHRyYWN0U3ZnSWNvbkZyb21TZXQgPSBmdW5jdGlvbiAoaWNvblNldCwgaWNvbk5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWNvbk5vZGUgPSBpY29uU2V0LnF1ZXJ5U2VsZWN0b3IoJyMnICsgaWNvbk5hbWUpO1xuICAgICAgICBpZiAoIWljb25Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaWNvbiBub2RlIGlzIGl0c2VsZiBhbiA8c3ZnPiBub2RlLCBjbG9uZSBhbmQgcmV0dXJuIGl0IGRpcmVjdGx5LiBJZiBub3QsIHNldCBpdCBhc1xuICAgICAgICAvLyB0aGUgY29udGVudCBvZiBhIG5ldyA8c3ZnPiBub2RlLlxuICAgICAgICBpZiAoaWNvbk5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFN2Z0F0dHJpYnV0ZXMoLyoqIEB0eXBlIHs/fSAqLyAoaWNvbk5vZGUuY2xvbmVOb2RlKHRydWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgYSA8c3ltYm9sPiwgaXQgd29uJ3QgYmUgcmVuZGVyZWQgc28gd2UgaGF2ZSB0byBjb252ZXJ0IGl0IGludG8gPHN2Zz4uIE5vdGVcbiAgICAgICAgLy8gdGhhdCB0aGUgc2FtZSBjb3VsZCBiZSBhY2hpZXZlZCBieSByZWZlcnJpbmcgdG8gaXQgdmlhIDx1c2UgaHJlZj1cIiNpZFwiPiwgaG93ZXZlciB0aGUgPHVzZT5cbiAgICAgICAgLy8gdGFnIGlzIHByb2JsZW1hdGljIG9uIEZpcmVmb3gsIGJlY2F1c2UgaXQgbmVlZHMgdG8gaW5jbHVkZSB0aGUgY3VycmVudCBwYWdlIHBhdGguXG4gICAgICAgIGlmIChpY29uTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFN2Z0F0dHJpYnV0ZXModGhpcy5fdG9TdmdFbGVtZW50KGljb25Ob2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlRWxlbWVudCgnU1ZHJykgZG9lc24ndCB3b3JrIGFzIGV4cGVjdGVkOyB0aGUgRE9NIGVuZHMgdXAgd2l0aFxuICAgICAgICAvLyB0aGUgY29ycmVjdCBub2RlcywgYnV0IHRoZSBTVkcgY29udGVudCBkb2Vzbid0IHJlbmRlci4gSW5zdGVhZCB3ZVxuICAgICAgICAvLyBoYXZlIHRvIGNyZWF0ZSBhbiBlbXB0eSBTVkcgbm9kZSB1c2luZyBpbm5lckhUTUwgYW5kIGFwcGVuZCBpdHMgY29udGVudC5cbiAgICAgICAgLy8gRWxlbWVudHMgY3JlYXRlZCB1c2luZyBET01QYXJzZXIucGFyc2VGcm9tU3RyaW5nIGhhdmUgdGhlIHNhbWUgcHJvYmxlbS5cbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMzAwMzI3OC9zdmctaW5uZXJodG1sLWluLWZpcmVmb3gtY2FuLW5vdC1kaXNwbGF5XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN2ZyA9IHRoaXMuX3N2Z0VsZW1lbnRGcm9tU3RyaW5nKCc8c3ZnPjwvc3ZnPicpO1xuICAgICAgICAvLyBDbG9uZSB0aGUgbm9kZSBzbyB3ZSBkb24ndCByZW1vdmUgaXQgZnJvbSB0aGUgcGFyZW50IGljb24gc2V0IGVsZW1lbnQuXG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChpY29uTm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0U3ZnQXR0cmlidXRlcyhzdmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERPTSBlbGVtZW50IGZyb20gdGhlIGdpdmVuIFNWRyBzdHJpbmcuXG4gICAgICogQHBhcmFtIHs/fSBzdHJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fc3ZnRWxlbWVudEZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8vIFRPRE86IElzIHRoZXJlIGEgYmV0dGVyIHdheSB0aGFuIGlubmVySFRNTD8gUmVuZGVyZXIgZG9lc24ndCBhcHBlYXIgdG8gaGF2ZSBhIG1ldGhvZCBmb3JcbiAgICAgICAgLy8gY3JlYXRpbmcgYW4gZWxlbWVudCBmcm9tIGFuIEhUTUwgc3RyaW5nLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IHN0cjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ZnID0gKGRpdi5xdWVyeVNlbGVjdG9yKCdzdmcnKSk7XG4gICAgICAgIGlmICghc3ZnKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignPHN2Zz4gdGFnIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBlbGVtZW50IGludG8gYW4gU1ZHIG5vZGUgYnkgY2xvbmluZyBhbGwgb2YgaXRzIGNoaWxkcmVuLlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl90b1N2Z0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdmcgPSB0aGlzLl9zdmdFbGVtZW50RnJvbVN0cmluZygnPHN2Zz48L3N2Zz4nKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoZWxlbWVudC5jaGlsZE5vZGVzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgYW4gU1ZHIGVsZW1lbnQgdG8gYmUgdXNlZCBhcyBhbiBpY29uLlxuICAgICAqIEBwYXJhbSB7P30gc3ZnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX3NldFN2Z0F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgICAgIGlmICghc3ZnLmdldEF0dHJpYnV0ZSgneG1sbnMnKSkge1xuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdmaXQnLCAnJyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxMDAlJyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScsICdmYWxzZScpOyAvLyBEaXNhYmxlIElFMTEgZGVmYXVsdCBiZWhhdmlvciB0byBtYWtlIFNWR3MgZm9jdXNhYmxlLlxuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHdoaWNoIHByb2R1Y2VzIHRoZSBzdHJpbmcgY29udGVudHMgb2YgdGhlIGdpdmVuIFVSTC4gUmVzdWx0cyBtYXkgYmVcbiAgICAgKiBjYWNoZWQsIHNvIGZ1dHVyZSBjYWxscyB3aXRoIHRoZSBzYW1lIFVSTCBtYXkgbm90IGNhdXNlIGFub3RoZXIgSFRUUCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7P30gc2FmZVVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9mZXRjaFVybCA9IGZ1bmN0aW9uIChzYWZlVXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5faHR0cCkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TWRJY29uTm9IdHRwUHJvdmlkZXJFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybCA9IHRoaXMuX3Nhbml0aXplci5zYW5pdGl6ZShTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBzYWZlVXJsKTtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kSWNvbkZhaWxlZFRvU2FuaXRpemVFcnJvcihzYWZlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSBpbi1wcm9ncmVzcyBmZXRjaGVzIHRvIGF2b2lkIHNlbmRpbmcgYSBkdXBsaWNhdGUgcmVxdWVzdCBmb3IgYSBVUkwgd2hlbiB0aGVyZSBpc1xuICAgICAgICAvLyBhbHJlYWR5IGEgcmVxdWVzdCBpbiBwcm9ncmVzcyBmb3IgdGhhdCBVUkwuIEl0J3MgbmVjZXNzYXJ5IHRvIGNhbGwgc2hhcmUoKSBvbiB0aGVcbiAgICAgICAgLy8gT2JzZXJ2YWJsZSByZXR1cm5lZCBieSBodHRwLmdldCgpIHNvIHRoYXQgbXVsdGlwbGUgc3Vic2NyaWJlcnMgZG9uJ3QgY2F1c2UgbXVsdGlwbGUgWEhScy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5Qcm9ncmVzc0ZldGNoID0gdGhpcy5faW5Qcm9ncmVzc1VybEZldGNoZXMuZ2V0KHVybCk7XG4gICAgICAgIGlmIChpblByb2dyZXNzRmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBpblByb2dyZXNzRmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IGZvciBzb21lIHJlYXNvbiwgdGhlIGBmaW5hbGx5YCBvcGVyYXRvciBcImxvc2VzXCIgdGhlIGdlbmVyaWMgdHlwZSBvbiB0aGVcbiAgICAgICAgLy8gT2JzZXJ2YWJsZS4gRmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVxID0gUnhDaGFpbi5mcm9tKHRoaXMuX2h0dHAuZ2V0KHVybCkpXG4gICAgICAgICAgICAuY2FsbChtYXAsIGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2UudGV4dCgpOyB9KVxuICAgICAgICAgICAgLmNhbGwoZmluYWxseU9wZXJhdG9yLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faW5Qcm9ncmVzc1VybEZldGNoZXMuZGVsZXRlKHVybCk7IH0pXG4gICAgICAgICAgICAuY2FsbChzaGFyZSlcbiAgICAgICAgICAgIC5yZXN1bHQoKTtcbiAgICAgICAgdGhpcy5faW5Qcm9ncmVzc1VybEZldGNoZXMuc2V0KHVybCwgcmVxKTtcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9O1xuICAgIHJldHVybiBNZEljb25SZWdpc3RyeTtcbn0oKSk7XG5NZEljb25SZWdpc3RyeS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRJY29uUmVnaXN0cnkuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBIdHRwLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IERvbVNhbml0aXplciwgfSxcbl07IH07XG4vKipcbiAqIEBwYXJhbSB7P30gcGFyZW50UmVnaXN0cnlcbiAqIEBwYXJhbSB7P30gaHR0cFxuICogQHBhcmFtIHs/fSBzYW5pdGl6ZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIElDT05fUkVHSVNUUllfUFJPVklERVJfRkFDVE9SWShwYXJlbnRSZWdpc3RyeSwgaHR0cCwgc2FuaXRpemVyKSB7XG4gICAgcmV0dXJuIHBhcmVudFJlZ2lzdHJ5IHx8IG5ldyBNZEljb25SZWdpc3RyeShodHRwLCBzYW5pdGl6ZXIpO1xufVxudmFyIElDT05fUkVHSVNUUllfUFJPVklERVIgPSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBNZEljb25SZWdpc3RyeSBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IE1kSWNvblJlZ2lzdHJ5LFxuICAgIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBNZEljb25SZWdpc3RyeV0sIFtuZXcgT3B0aW9uYWwoKSwgSHR0cF0sIERvbVNhbml0aXplcl0sXG4gICAgdXNlRmFjdG9yeTogSUNPTl9SRUdJU1RSWV9QUk9WSURFUl9GQUNUT1JZXG59O1xuLyoqXG4gKiBDbG9uZXMgYW4gU1ZHRWxlbWVudCB3aGlsZSBwcmVzZXJ2aW5nIHR5cGUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0gez99IHN2Z1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2xvbmVTdmcoc3ZnKSB7XG4gICAgcmV0dXJuIChzdmcuY2xvbmVOb2RlKHRydWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY2FjaGUga2V5IHRvIHVzZSBmb3IgYW4gaWNvbiBuYW1lc3BhY2UgYW5kIG5hbWUuXG4gKiBAcGFyYW0gez99IG5hbWVzcGFjZVxuICogQHBhcmFtIHs/fSBuYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpY29uS2V5KG5hbWVzcGFjZSwgbmFtZSkge1xuICAgIHJldHVybiBuYW1lc3BhY2UgKyAnOicgKyBuYW1lO1xufVxuLyoqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kSWNvbkJhc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZEljb25CYXNlKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG4gICAgcmV0dXJuIE1kSWNvbkJhc2U7XG59KCkpO1xudmFyIF9NZEljb25NaXhpbkJhc2UgPSBtaXhpbkNvbG9yKE1kSWNvbkJhc2UpO1xuLyoqXG4gKiBDb21wb25lbnQgdG8gZGlzcGxheSBhbiBpY29uLiBJdCBjYW4gYmUgdXNlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIFNwZWNpZnkgdGhlIHN2Z1NyYyBpbnB1dCB0byBsb2FkIGFuIFNWRyBpY29uIGZyb20gYSBVUkwuIFRoZSBTVkcgY29udGVudCBpcyBkaXJlY3RseSBpbmxpbmVkXG4gKiAgIGFzIGEgY2hpbGQgb2YgdGhlIDxtZC1pY29uPiBjb21wb25lbnQsIHNvIHRoYXQgQ1NTIHN0eWxlcyBjYW4gZWFzaWx5IGJlIGFwcGxpZWQgdG8gaXQuXG4gKiAgIFRoZSBVUkwgaXMgbG9hZGVkIHZpYSBhbiBYTUxIdHRwUmVxdWVzdCwgc28gaXQgbXVzdCBiZSBvbiB0aGUgc2FtZSBkb21haW4gYXMgdGhlIHBhZ2Ugb3IgaXRzXG4gKiAgIHNlcnZlciBtdXN0IGJlIGNvbmZpZ3VyZWQgdG8gYWxsb3cgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLlxuICogICBFeGFtcGxlOlxuICogICAgIDxtZC1pY29uIHN2Z1NyYz1cImFzc2V0cy9hcnJvdy5zdmdcIj48L21kLWljb24+XG4gKlxuICogLSBTcGVjaWZ5IHRoZSBzdmdJY29uIGlucHV0IHRvIGxvYWQgYW4gU1ZHIGljb24gZnJvbSBhIFVSTCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCB0aGVcbiAqICAgYWRkU3ZnSWNvbiwgYWRkU3ZnSWNvbkluTmFtZXNwYWNlLCBhZGRTdmdJY29uU2V0LCBvciBhZGRTdmdJY29uU2V0SW5OYW1lc3BhY2UgbWV0aG9kcyBvZlxuICogICBNZEljb25SZWdpc3RyeS4gSWYgdGhlIHN2Z0ljb24gdmFsdWUgY29udGFpbnMgYSBjb2xvbiBpdCBpcyBhc3N1bWVkIHRvIGJlIGluIHRoZSBmb3JtYXRcbiAqICAgXCJbbmFtZXNwYWNlXTpbbmFtZV1cIiwgaWYgbm90IHRoZSB2YWx1ZSB3aWxsIGJlIHRoZSBuYW1lIG9mIGFuIGljb24gaW4gdGhlIGRlZmF1bHQgbmFtZXNwYWNlLlxuICogICBFeGFtcGxlczpcbiAqICAgICA8bWQtaWNvbiBzdmdJY29uPVwibGVmdC1hcnJvd1wiPjwvbWQtaWNvbj5cbiAqICAgICA8bWQtaWNvbiBzdmdJY29uPVwiYW5pbWFsczpjYXRcIj48L21kLWljb24+XG4gKlxuICogLSBVc2UgYSBmb250IGxpZ2F0dXJlIGFzIGFuIGljb24gYnkgcHV0dGluZyB0aGUgbGlnYXR1cmUgdGV4dCBpbiB0aGUgY29udGVudCBvZiB0aGUgPG1kLWljb24+XG4gKiAgIGNvbXBvbmVudC4gQnkgZGVmYXVsdCB0aGUgTWF0ZXJpYWwgaWNvbnMgZm9udCBpcyB1c2VkIGFzIGRlc2NyaWJlZCBhdFxuICogICBodHRwOi8vZ29vZ2xlLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbnMvI2ljb24tZm9udC1mb3ItdGhlLXdlYi4gWW91IGNhbiBzcGVjaWZ5IGFuXG4gKiAgIGFsdGVybmF0ZSBmb250IGJ5IHNldHRpbmcgdGhlIGZvbnRTZXQgaW5wdXQgdG8gZWl0aGVyIHRoZSBDU1MgY2xhc3MgdG8gYXBwbHkgdG8gdXNlIHRoZVxuICogICBkZXNpcmVkIGZvbnQsIG9yIHRvIGFuIGFsaWFzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIE1kSWNvblJlZ2lzdHJ5LnJlZ2lzdGVyRm9udENsYXNzQWxpYXMuXG4gKiAgIEV4YW1wbGVzOlxuICogICAgIDxtZC1pY29uPmhvbWU8L21kLWljb24+XG4gKiAgICAgPG1kLWljb24gZm9udFNldD1cIm15Zm9udFwiPnN1bjwvbWQtaWNvbj5cbiAqXG4gKiAtIFNwZWNpZnkgYSBmb250IGdseXBoIHRvIGJlIGluY2x1ZGVkIHZpYSBDU1MgcnVsZXMgYnkgc2V0dGluZyB0aGUgZm9udFNldCBpbnB1dCB0byBzcGVjaWZ5IHRoZVxuICogICBmb250LCBhbmQgdGhlIGZvbnRJY29uIGlucHV0IHRvIHNwZWNpZnkgdGhlIGljb24uIFR5cGljYWxseSB0aGUgZm9udEljb24gd2lsbCBzcGVjaWZ5IGFcbiAqICAgQ1NTIGNsYXNzIHdoaWNoIGNhdXNlcyB0aGUgZ2x5cGggdG8gYmUgZGlzcGxheWVkIHZpYSBhIDpiZWZvcmUgc2VsZWN0b3IsIGFzIGluXG4gKiAgIGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS9leGFtcGxlcy9cbiAqICAgRXhhbXBsZTpcbiAqICAgICA8bWQtaWNvbiBmb250U2V0PVwiZmFcIiBmb250SWNvbj1cImFsYXJtXCI+PC9tZC1pY29uPlxuICovXG52YXIgTWRJY29uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRJY29uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9tZEljb25SZWdpc3RyeVxuICAgICAqIEBwYXJhbSB7P30gYXJpYUhpZGRlblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kSWNvbihyZW5kZXJlciwgZWxlbWVudFJlZiwgX21kSWNvblJlZ2lzdHJ5LCBhcmlhSGlkZGVuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlbmRlcmVyLCBlbGVtZW50UmVmKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fbWRJY29uUmVnaXN0cnkgPSBfbWRJY29uUmVnaXN0cnk7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBub3QgZXhwbGljaXRseSBzZXQgYXJpYS1oaWRkZW4sIG1hcmsgdGhlIGljb24gYXMgaGlkZGVuLCBhcyB0aGlzIGlzXG4gICAgICAgIC8vIHRoZSByaWdodCB0aGluZyB0byBkbyBmb3IgdGhlIG1ham9yaXR5IG9mIGljb24gdXNlLWNhc2VzLlxuICAgICAgICBpZiAoIWFyaWFIaWRkZW4pIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYW4gc3ZnSWNvbiBiaW5kaW5nIHZhbHVlIGludG8gaXRzIGljb24gc2V0IGFuZCBpY29uIG5hbWUgY29tcG9uZW50cy5cbiAgICAgKiBSZXR1cm5zIGEgMi1lbGVtZW50IGFycmF5IG9mIFsoaWNvbiBzZXQpLCAoaWNvbiBuYW1lKV0uXG4gICAgICogVGhlIHNlcGFyYXRvciBmb3IgdGhlIHR3byBmaWVsZHMgaXMgJzonLiBJZiB0aGVyZSBpcyBubyBzZXBhcmF0b3IsIGFuIGVtcHR5XG4gICAgICogc3RyaW5nIGlzIHJldHVybmVkIGZvciB0aGUgaWNvbiBzZXQgYW5kIHRoZSBlbnRpcmUgdmFsdWUgaXMgcmV0dXJuZWQgZm9yXG4gICAgICogdGhlIGljb24gbmFtZS4gSWYgdGhlIGFyZ3VtZW50IGlzIGZhbHN5LCByZXR1cm5zIGFuIGFycmF5IG9mIHR3byBlbXB0eSBzdHJpbmdzLlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgbmFtZSBjb250YWlucyB0d28gb3IgbW9yZSAnOicgc2VwYXJhdG9ycy5cbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKiAgICdzb2NpYWw6Y2FrZScgLT4gWydzb2NpYWwnLCAnY2FrZSddXG4gICAgICogICAncGVuZ3VpbicgLT4gWycnLCAncGVuZ3VpbiddXG4gICAgICogICBudWxsIC0+IFsnJywgJyddXG4gICAgICogICAnYTpiOmMnIC0+ICh0aHJvd3MgRXJyb3IpXG4gICAgICogQHBhcmFtIHs/fSBpY29uTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uLnByb3RvdHlwZS5fc3BsaXRJY29uTmFtZSA9IGZ1bmN0aW9uIChpY29uTmFtZSkge1xuICAgICAgICBpZiAoIWljb25OYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gWycnLCAnJ107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBpY29uTmFtZS5zcGxpdCgnOicpO1xuICAgICAgICBzd2l0Y2ggKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vIFVzZSBkZWZhdWx0IG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gWycnLCBwYXJ0c1swXV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwYXJ0cyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBpY29uIG5hbWU6IFxcXCJcIiArIGljb25OYW1lICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSWNvbi5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFuZ2VkSW5wdXRzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBpbmxpbmUgU1ZHIGljb24gaWYgdGhlIGlucHV0cyBjaGFuZ2VkLCB0byBhdm9pZCB1bm5lY2Vzc2FyeSBET00gb3BlcmF0aW9ucy5cbiAgICAgICAgaWYgKGNoYW5nZWRJbnB1dHMuaW5kZXhPZignc3ZnSWNvbicpICE9IC0xIHx8IGNoYW5nZWRJbnB1dHMuaW5kZXhPZignc3ZnU3JjJykgIT0gLTEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN2Z0ljb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9zcGxpdEljb25OYW1lKHRoaXMuc3ZnSWNvbiksIG5hbWVzcGFjZSA9IF9hWzBdLCBpY29uTmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIGZpcnN0LmNhbGwodGhpcy5fbWRJY29uUmVnaXN0cnkuZ2V0TmFtZWRTdmdJY29uKGljb25OYW1lLCBuYW1lc3BhY2UpKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN2ZykgeyByZXR1cm4gX3RoaXMuX3NldFN2Z0VsZW1lbnQoc3ZnKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY29uc29sZS5sb2coXCJFcnJvciByZXRyaWV2aW5nIGljb246IFwiICsgZXJyLm1lc3NhZ2UpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdXNpbmdGb250SWNvbigpKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVGb250SWNvbkNsYXNzZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb24ucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBVcGRhdGUgZm9udCBjbGFzc2VzIGJlY2F1c2UgbmdPbkNoYW5nZXMgd29uJ3QgYmUgY2FsbGVkIGlmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgcHJlc2VudCxcbiAgICAgICAgLy8gZS5nLiA8bWQtaWNvbj5hcnJvdzwvbWQtaWNvbj4uIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGFkZCBhIENTUyBjbGFzcyBmb3IgdGhlIGRlZmF1bHQgZm9udC5cbiAgICAgICAgaWYgKHRoaXMuX3VzaW5nRm9udEljb24oKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9udEljb25DbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uLnByb3RvdHlwZS5fdXNpbmdGb250SWNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnN2Z0ljb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN2Z1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJY29uLnByb3RvdHlwZS5fc2V0U3ZnRWxlbWVudCA9IGZ1bmN0aW9uIChzdmcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGF5b3V0RWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIGNoaWxkIG5vZGVzIGFuZCBhZGQgdGhlIG5ldyBTVkcgZWxlbWVudC5cbiAgICAgICAgLy8gV2Ugd291bGQgdXNlIHJlbmRlcmVyLmRldGFjaFZpZXcoQXJyYXkuZnJvbShsYXlvdXRFbGVtZW50LmNoaWxkTm9kZXMpKSBoZXJlLFxuICAgICAgICAvLyBidXQgaXQgZmFpbHMgaW4gSUUxMTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNjMyN1xuICAgICAgICBsYXlvdXRFbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hcHBlbmRDaGlsZChsYXlvdXRFbGVtZW50LCBzdmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEljb24ucHJvdG90eXBlLl91cGRhdGVGb250SWNvbkNsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdXNpbmdGb250SWNvbigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9udFNldENsYXNzID0gdGhpcy5mb250U2V0ID9cbiAgICAgICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5LmNsYXNzTmFtZUZvckZvbnRBbGlhcyh0aGlzLmZvbnRTZXQpIDpcbiAgICAgICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5LmdldERlZmF1bHRGb250U2V0Q2xhc3MoKTtcbiAgICAgICAgaWYgKGZvbnRTZXRDbGFzcyAhPSB0aGlzLl9wcmV2aW91c0ZvbnRTZXRDbGFzcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzRm9udFNldENsYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbSwgdGhpcy5fcHJldmlvdXNGb250U2V0Q2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvbnRTZXRDbGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKGVsZW0sIGZvbnRTZXRDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0ZvbnRTZXRDbGFzcyA9IGZvbnRTZXRDbGFzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb250SWNvbiAhPSB0aGlzLl9wcmV2aW91c0ZvbnRJY29uQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2aW91c0ZvbnRJY29uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyhlbGVtLCB0aGlzLl9wcmV2aW91c0ZvbnRJY29uQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9udEljb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhlbGVtLCB0aGlzLmZvbnRJY29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzRm9udEljb25DbGFzcyA9IHRoaXMuZm9udEljb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZEljb247XG59KF9NZEljb25NaXhpbkJhc2UpKTtcbk1kSWNvbi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtaWNvbiwgbWF0LWljb24nLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1pY29ue2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtkaXNwbGF5OmlubGluZS1ibG9jaztmaWxsOmN1cnJlbnRDb2xvcjtoZWlnaHQ6MjRweDt3aWR0aDoyNHB4fVwiXSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sb3InXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ2ltZycsXG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtaWNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEljb24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogTWRJY29uUmVnaXN0cnksIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEF0dHJpYnV0ZSwgYXJnczogWydhcmlhLWhpZGRlbicsXSB9LF0gfSxcbl07IH07XG5NZEljb24ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3N2Z0ljb24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2ZvbnRTZXQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2ZvbnRJY29uJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbnZhciBNZEljb25Nb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEljb25Nb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEljb25Nb2R1bGU7XG59KCkpO1xuTWRJY29uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZEljb24sIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZEljb25dLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0lDT05fUkVHSVNUUllfUFJPVklERVJdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEljb25Nb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQSBzaW5nbGUgZGVncmVlIGluIHJhZGlhbnMuXG4gKi9cbnZhciBERUdSRUVfSU5fUkFESUFOUyA9IE1hdGguUEkgLyAxODA7XG4vKipcbiAqIER1cmF0aW9uIG9mIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbi5cbiAqL1xudmFyIERVUkFUSU9OX0lOREVURVJNSU5BVEUgPSA2Njc7XG4vKipcbiAqIER1cmF0aW9uIG9mIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbi5cbiAqL1xudmFyIERVUkFUSU9OX0RFVEVSTUlOQVRFID0gMjI1O1xuLyoqXG4gKiBTdGFydCBhbmltYXRpb24gdmFsdWUgb2YgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uXG4gKi9cbnZhciBzdGFydEluZGV0ZXJtaW5hdGUgPSAzO1xuLyoqXG4gKiBFbmQgYW5pbWF0aW9uIHZhbHVlIG9mIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvblxuICovXG52YXIgZW5kSW5kZXRlcm1pbmF0ZSA9IDgwO1xuLyoqXG4gKiBNYXhpbXVtIGFuZ2xlIGZvciB0aGUgYXJjLiBUaGUgYW5nbGUgY2FuJ3QgYmUgZXhhY3RseSAzNjAsIGJlY2F1c2UgdGhlIGFyYyBiZWNvbWVzIGhpZGRlbi5cbiAqL1xudmFyIE1BWF9BTkdMRSA9IDM1OS45OSAvIDEwMDtcbi8qKlxuICogV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgc3VwcG9ydHMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuICovXG52YXIgSEFTX1JBRiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBEZWZhdWx0IHN0cm9rZSB3aWR0aCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHZpZXdCb3guXG4gKi9cbnZhciBQUk9HUkVTU19TUElOTkVSX1NUUk9LRV9XSURUSCA9IDEwO1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kUHJvZ3Jlc3NTcGlubmVyQ3NzTWF0U3R5bGVyO1xufSgpKTtcbk1kUHJvZ3Jlc3NTcGlubmVyQ3NzTWF0U3R5bGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1wcm9ncmVzcy1zcGlubmVyLCBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lcicsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LXByb2dyZXNzLXNwaW5uZXInIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFByb2dyZXNzU3Bpbm5lckJhc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzU3Bpbm5lckJhc2UoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgIH1cbiAgICByZXR1cm4gTWRQcm9ncmVzc1NwaW5uZXJCYXNlO1xufSgpKTtcbnZhciBfTWRQcm9ncmVzc1NwaW5uZXJNaXhpbkJhc2UgPSBtaXhpbkNvbG9yKE1kUHJvZ3Jlc3NTcGlubmVyQmFzZSwgJ3ByaW1hcnknKTtcbi8qKlxuICogPG1kLXByb2dyZXNzLXNwaW5uZXI+IGNvbXBvbmVudC5cbiAqL1xudmFyIE1kUHJvZ3Jlc3NTcGlubmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRQcm9ncmVzc1NwaW5uZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kUHJvZ3Jlc3NTcGlubmVyKHJlbmRlcmVyLCBlbGVtZW50UmVmLCBfbmdab25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlbmRlcmVyLCBlbGVtZW50UmVmKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgbGFzdCByZXF1ZXN0ZWQgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2xhc3RBbmltYXRpb25JZCA9IDA7XG4gICAgICAgIF90aGlzLl9tb2RlID0gJ2RldGVybWluYXRlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cm9rZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3Mgc3Bpbm5lci4gQnkgZGVmYXVsdCB1c2VzIDEwcHggYXMgc3Ryb2tlIHdpZHRoLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc3Ryb2tlV2lkdGggPSBQUk9HUkVTU19TUElOTkVSX1NUUk9LRV9XSURUSDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcIl9hcmlhVmFsdWVNaW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVzIGZvciBhcmlhIG1heCBhbmQgbWluIGFyZSBvbmx5IGRlZmluZWQgYXMgbnVtYmVycyB3aGVuIGluIGEgZGV0ZXJtaW5hdGUgbW9kZS4gIFdlIGRvIHRoaXNcbiAgICAgICAgICogYmVjYXVzZSB2b2ljZW92ZXIgZG9lcyBub3QgcmVwb3J0IHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IgYXMgaW5kZXRlcm1pbmF0ZSBpZiB0aGUgYXJpYSBtaW5cbiAgICAgICAgICogYW5kL29yIG1heCB2YWx1ZSBhcmUgbnVtYmVyIHZhbHVlcy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PSAnZGV0ZXJtaW5hdGUnID8gMCA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwiX2FyaWFWYWx1ZU1heFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdkZXRlcm1pbmF0ZScgPyAxMDAgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcImludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBkb2NzLXByaXZhdGVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGRvY3MtcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gez99IGludGVydmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJkZXRlcm1pbmF0ZUludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCBhbnkgYW5pbWF0aW9ucyB0aGF0IHdlcmUgcnVubmluZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cEluZGV0ZXJtaW5hdGVBbmltYXRpb24oKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgb2YgdGhlIHByb2dyZXNzIGNpcmNsZS4gSXQgaXMgYm91bmQgdG8gdGhlIGhvc3QgYXMgdGhlIGF0dHJpYnV0ZSBhcmlhLXZhbHVlbm93LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlID09ICdkZXRlcm1pbmF0ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHYgIT0gbnVsbCAmJiB0aGlzLm1vZGUgPT0gJ2RldGVybWluYXRlJykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld1ZhbHVlID0gY2xhbXAodik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUNpcmNsZSh0aGlzLnZhbHVlIHx8IDAsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcIm1vZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZSBvZiB0aGUgcHJvZ3Jlc3MgY2lyY2xlXG4gICAgICAgICAqXG4gICAgICAgICAqIElucHV0IG11c3QgYmUgb25lIG9mIHRoZSB2YWx1ZXMgZnJvbSBQcm9ncmVzc01vZGUsIGRlZmF1bHRzIHRvICdkZXRlcm1pbmF0ZScuXG4gICAgICAgICAqIG1vZGUgaXMgYm91bmQgdG8gdGhlIGhvc3QgYXMgdGhlIGF0dHJpYnV0ZSBob3N0LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgICAgICAgaWYgKG1vZGUgIT09IHRoaXMuX21vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ2luZGV0ZXJtaW5hdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0SW5kZXRlcm1pbmF0ZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cEluZGV0ZXJtaW5hdGVBbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUNpcmNsZSgwLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBbmltYXRlcyB0aGUgY2lyY2xlIGZyb20gb25lIHBlcmNlbnRhZ2UgdmFsdWUgdG8gYW5vdGhlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0ZUZyb20gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNpcmNsZSBmaWxsZWQgc3RhcnRpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gez99IGFuaW1hdGVUbyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2lyY2xlIGZpbGxlZCBlbmRpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gez89fSBlYXNlIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gbWFuYWdlIHRoZSBwYWNlIG9mIGNoYW5nZSBpbiB0aGUgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7Pz19IGR1cmF0aW9uIFRoZSBsZW5ndGggb2YgdGltZSB0byBzaG93IHRoZSBhbmltYXRpb24sIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0gez89fSByb3RhdGlvbiBUaGUgc3RhcnRpbmcgYW5nbGUgb2YgdGhlIGNpcmNsZSBmaWxsLCB3aXRoIDDCsCByZXByZXNlbnRlZCBhdCB0aGUgdG9wIGNlbnRlclxuICAgICAqICAgIG9mIHRoZSBjaXJjbGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX2FuaW1hdGVDaXJjbGUgPSBmdW5jdGlvbiAoYW5pbWF0ZUZyb20sIGFuaW1hdGVUbywgZWFzZSwgZHVyYXRpb24sIHJvdGF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChlYXNlID09PSB2b2lkIDApIHsgZWFzZSA9IGxpbmVhckVhc2U7IH1cbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHsgZHVyYXRpb24gPSBEVVJBVElPTl9ERVRFUk1JTkFURTsgfVxuICAgICAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkgeyByb3RhdGlvbiA9IDA7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSArK3RoaXMuX2xhc3RBbmltYXRpb25JZDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhbmdlSW5WYWx1ZSA9IGFuaW1hdGVUbyAtIGFuaW1hdGVGcm9tO1xuICAgICAgICAvLyBObyBuZWVkIHRvIGFuaW1hdGUgaXQgaWYgdGhlIHZhbHVlcyBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKGFuaW1hdGVUbyA9PT0gYW5pbWF0ZUZyb20pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckFyYyhhbmltYXRlVG8sIHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvbl8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgc2tpcCBhaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxhcHNlZFRpbWUgPSBIQVNfUkFGID9cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgTWF0aC5taW4oRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSwgZHVyYXRpb24pKSA6XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXJBcmMoZWFzZShlbGFwc2VkVGltZSwgYW5pbWF0ZUZyb20sIGNoYW5nZUluVmFsdWUsIGR1cmF0aW9uKSwgcm90YXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgb3ZlcmxhcHBpbmcgYW5pbWF0aW9ucyBieSBjaGVja2luZyBpZiBhIG5ldyBhbmltYXRpb24gaGFzIGJlZW4gY2FsbGVkIGZvciBhbmRcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYW5pbWF0aW9uIGhhcyBsYXN0ZWQgbG9uZ2VyIHRoYW4gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoaWQgPT09IF90aGlzLl9sYXN0QW5pbWF0aW9uSWQgJiYgZWxhcHNlZFRpbWUgPCBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBSdW4gdGhlIGFuaW1hdGlvbiBvdXRzaWRlIG9mIEFuZ3VsYXIncyB6b25lLCBpbiBvcmRlciB0byBhdm9pZFxuICAgICAgICAgICAgLy8gaGl0dGluZyBab25lSlMgYW5kIGNoYW5nZSBkZXRlY3Rpb24gb24gZWFjaCBmcmFtZS5cbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihhbmltYXRpb25fMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgaW5kZXRlcm1pbmF0ZSBhbmltYXRpb24gaW50ZXJ2YWwsIGlmIGl0IGlzIG5vdCBhbHJlYWR5IHJ1bm5pbmcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX3N0YXJ0SW5kZXRlcm1pbmF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm90YXRpb25TdGFydFBvaW50ID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSBzdGFydEluZGV0ZXJtaW5hdGU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IGVuZEluZGV0ZXJtaW5hdGU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uID0gRFVSQVRJT05fSU5ERVRFUk1JTkFURTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0ZSQkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9hbmltYXRlQ2lyY2xlKHN0YXJ0LCBlbmQsIG1hdGVyaWFsRWFzZSwgZHVyYXRpb24sIHJvdGF0aW9uU3RhcnRQb2ludCk7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IHJvdGF0aW9uIGZyb20gcmVhY2hpbmcgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIuXG4gICAgICAgICAgICByb3RhdGlvblN0YXJ0UG9pbnQgPSAocm90YXRpb25TdGFydFBvaW50ICsgZW5kKSAlIDEwMDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXAgPSBzdGFydDtcbiAgICAgICAgICAgIHN0YXJ0ID0gLWVuZDtcbiAgICAgICAgICAgIGVuZCA9IC10ZW1wO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuaW50ZXJkZXRlcm1pbmF0ZUludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCA9IHNldEludGVydmFsKGFuaW1hdGUkJDEsIGR1cmF0aW9uICsgNTAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhbmltYXRlJCQxKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBpbnRlcnZhbCwgZW5kaW5nIHRoZSBhbmltYXRpb24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX2NsZWFudXBJbmRldGVybWluYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCA9IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBhcmMgb250byB0aGUgU1ZHIGVsZW1lbnQuIFByb3hpZXMgYGdldEFyY2Agd2hpbGUgc2V0dGluZyB0aGUgcHJvcGVyXG4gICAgICogRE9NIGF0dHJpYnV0ZSBvbiB0aGUgYDxwYXRoPmAuXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50VmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSByb3RhdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLl9yZW5kZXJBcmMgPSBmdW5jdGlvbiAoY3VycmVudFZhbHVlLCByb3RhdGlvbikge1xuICAgICAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkgeyByb3RhdGlvbiA9IDA7IH1cbiAgICAgICAgaWYgKHRoaXMuX3BhdGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN2Z0FyYyA9IGdldFN2Z0FyYyhjdXJyZW50VmFsdWUsIHJvdGF0aW9uLCB0aGlzLnN0cm9rZVdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLl9wYXRoLm5hdGl2ZUVsZW1lbnQsICdkJywgc3ZnQXJjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kUHJvZ3Jlc3NTcGlubmVyO1xufShfTWRQcm9ncmVzc1NwaW5uZXJNaXhpbkJhc2UpKTtcbk1kUHJvZ3Jlc3NTcGlubmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtcHJvZ3Jlc3Mtc3Bpbm5lciwgbWF0LXByb2dyZXNzLXNwaW5uZXInLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS12YWx1ZW1pbl0nOiAnX2FyaWFWYWx1ZU1pbicsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbWF4XSc6ICdfYXJpYVZhbHVlTWF4J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2NvbG9yJ10sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMTAwIDEwMFxcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCI+PHBhdGggI3BhdGggW3N0eWxlLnN0cm9rZVdpZHRoXT1cXFwic3Ryb2tlV2lkdGhcXFwiPjwvcGF0aD48L3N2Zz5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMHB4O3dpZHRoOjEwMHB4O292ZXJmbG93OmhpZGRlbn06aG9zdCBzdmd7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlcn06aG9zdCBwYXRoe2ZpbGw6dHJhbnNwYXJlbnQ7dHJhbnNpdGlvbjpzdHJva2UgLjNzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSBzdmd7YW5pbWF0aW9uLWR1cmF0aW9uOjUuMjVzLDIuODg3czthbmltYXRpb24tbmFtZTptYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zcG9yYWRpYy1yb3RhdGUsbWF0LXByb2dyZXNzLXNwaW5uZXItbGluZWFyLXJvdGF0ZTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMzUsMCwuMjUsMSksbGluZWFyO2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6aW5maW5pdGU7dHJhbnNpdGlvbjpub25lfUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLXNwaW5uZXItbGluZWFyLXJvdGF0ZXswJXt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLXNwb3JhZGljLXJvdGF0ZXsxMi41JXt0cmFuc2Zvcm06cm90YXRlKDEzNWRlZyl9MjUle3RyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKX0zNy41JXt0cmFuc2Zvcm06cm90YXRlKDQwNWRlZyl9NTAle3RyYW5zZm9ybTpyb3RhdGUoNTQwZGVnKX02Mi41JXt0cmFuc2Zvcm06cm90YXRlKDY3NWRlZyl9NzUle3RyYW5zZm9ybTpyb3RhdGUoODEwZGVnKX04Ny41JXt0cmFuc2Zvcm06cm90YXRlKDk0NWRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDEwODBkZWcpfX1cIl0sXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUHJvZ3Jlc3NTcGlubmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbl07IH07XG5NZFByb2dyZXNzU3Bpbm5lci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX3BhdGgnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsncGF0aCcsXSB9LF0sXG4gICAgJ3N0cm9rZVdpZHRoJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLXZhbHVlbm93JyxdIH0sXSxcbiAgICAnbW9kZSc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIubW9kZScsXSB9LCB7IHR5cGU6IElucHV0IH0sXSxcbn07XG4vKipcbiAqIDxtZC1zcGlubmVyPiBjb21wb25lbnQuXG4gKlxuICogVGhpcyBpcyBhIGNvbXBvbmVudCBkZWZpbml0aW9uIHRvIGJlIHVzZWQgYXMgYSBjb252ZW5pZW5jZSByZWZlcmVuY2UgdG8gY3JlYXRlIGFuXG4gKiBpbmRldGVybWluYXRlIDxtZC1wcm9ncmVzcy1zcGlubmVyPiBpbnN0YW5jZS5cbiAqL1xudmFyIE1kU3Bpbm5lciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kU3Bpbm5lciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IG5nWm9uZVxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFNwaW5uZXIoZWxlbWVudFJlZiwgbmdab25lLCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZW5kZXJlciwgZWxlbWVudFJlZiwgbmdab25lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tb2RlID0gJ2luZGV0ZXJtaW5hdGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTcGlubmVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhlIGBuZ09uRGVzdHJveWAgZnJvbSBgTWRQcm9ncmVzc1NwaW5uZXJgIHNob3VsZCBiZSBjYWxsZWQgZXhwbGljaXRseSwgYmVjYXVzZVxuICAgICAgICAvLyBpbiBjZXJ0YWluIGNhc2VzIEFuZ3VsYXIgd29uJ3QgY2FsbCBpdCAoZS5nLiB3aGVuIHVzaW5nIEFvVCBhbmQgaW4gdW5pdCB0ZXN0cykuXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBNZFNwaW5uZXI7XG59KE1kUHJvZ3Jlc3NTcGlubmVyKSk7XG5NZFNwaW5uZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1zcGlubmVyLCBtYXQtc3Bpbm5lcicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdwcm9ncmVzc2JhcicsXG4gICAgICAgICAgICAgICAgICAgICdtb2RlJzogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LXNwaW5uZXInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2NvbG9yJ10sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMTAwIDEwMFxcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCI+PHBhdGggI3BhdGggW3N0eWxlLnN0cm9rZVdpZHRoXT1cXFwic3Ryb2tlV2lkdGhcXFwiPjwvcGF0aD48L3N2Zz5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMHB4O3dpZHRoOjEwMHB4O292ZXJmbG93OmhpZGRlbn06aG9zdCBzdmd7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlcn06aG9zdCBwYXRoe2ZpbGw6dHJhbnNwYXJlbnQ7dHJhbnNpdGlvbjpzdHJva2UgLjNzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSBzdmd7YW5pbWF0aW9uLWR1cmF0aW9uOjUuMjVzLDIuODg3czthbmltYXRpb24tbmFtZTptYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zcG9yYWRpYy1yb3RhdGUsbWF0LXByb2dyZXNzLXNwaW5uZXItbGluZWFyLXJvdGF0ZTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMzUsMCwuMjUsMSksbGluZWFyO2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6aW5maW5pdGU7dHJhbnNpdGlvbjpub25lfUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLXNwaW5uZXItbGluZWFyLXJvdGF0ZXswJXt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLXNwb3JhZGljLXJvdGF0ZXsxMi41JXt0cmFuc2Zvcm06cm90YXRlKDEzNWRlZyl9MjUle3RyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKX0zNy41JXt0cmFuc2Zvcm06cm90YXRlKDQwNWRlZyl9NTAle3RyYW5zZm9ybTpyb3RhdGUoNTQwZGVnKX02Mi41JXt0cmFuc2Zvcm06cm90YXRlKDY3NWRlZyl9NzUle3RyYW5zZm9ybTpyb3RhdGUoODEwZGVnKX04Ny41JXt0cmFuc2Zvcm06cm90YXRlKDk0NWRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDEwODBkZWcpfX1cIl0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU3Bpbm5lci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG5dOyB9O1xuLyoqXG4gKiBDbGFtcHMgYSB2YWx1ZSB0byBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cbiAqIEBwYXJhbSB7P30gdlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2xhbXAodikge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIHYpKTtcbn1cbi8qKlxuICogQ29udmVydHMgUG9sYXIgY29vcmRpbmF0ZXMgdG8gQ2FydGVzaWFuLlxuICogQHBhcmFtIHs/fSByYWRpdXNcbiAqIEBwYXJhbSB7P30gcGF0aFJhZGl1c1xuICogQHBhcmFtIHs/fSBhbmdsZUluRGVncmVlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihyYWRpdXMsIHBhdGhSYWRpdXMsIGFuZ2xlSW5EZWdyZWVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5nbGVJblJhZGlhbnMgPSAoYW5nbGVJbkRlZ3JlZXMgLSA5MCkgKiBERUdSRUVfSU5fUkFESUFOUztcbiAgICByZXR1cm4gKHJhZGl1cyArIChwYXRoUmFkaXVzICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpKSkgK1xuICAgICAgICAnLCcgKyAocmFkaXVzICsgKHBhdGhSYWRpdXMgKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucykpKTtcbn1cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9uIGZvciBsaW5lYXIgYW5pbWF0aW9uLlxuICogQHBhcmFtIHs/fSBjdXJyZW50VGltZVxuICogQHBhcmFtIHs/fSBzdGFydFZhbHVlXG4gKiBAcGFyYW0gez99IGNoYW5nZUluVmFsdWVcbiAqIEBwYXJhbSB7P30gZHVyYXRpb25cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGxpbmVhckVhc2UoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGNoYW5nZUluVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGNoYW5nZUluVmFsdWUgKiBjdXJyZW50VGltZSAvIGR1cmF0aW9uICsgc3RhcnRWYWx1ZTtcbn1cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9uIHRvIG1hdGNoIG1hdGVyaWFsIGRlc2lnbiBpbmRldGVybWluYXRlIGFuaW1hdGlvbi5cbiAqIEBwYXJhbSB7P30gY3VycmVudFRpbWVcbiAqIEBwYXJhbSB7P30gc3RhcnRWYWx1ZVxuICogQHBhcmFtIHs/fSBjaGFuZ2VJblZhbHVlXG4gKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtYXRlcmlhbEVhc2UoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGNoYW5nZUluVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZSA9IGN1cnJlbnRUaW1lIC8gZHVyYXRpb247XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZUN1YmVkID0gTWF0aC5wb3codGltZSwgMyk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZVF1YWQgPSBNYXRoLnBvdyh0aW1lLCA0KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lUXVpbnQgPSBNYXRoLnBvdyh0aW1lLCA1KTtcbiAgICByZXR1cm4gc3RhcnRWYWx1ZSArIGNoYW5nZUluVmFsdWUgKiAoKDYgKiB0aW1lUXVpbnQpICsgKC0xNSAqIHRpbWVRdWFkKSArICgxMCAqIHRpbWVDdWJlZCkpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBwYXRoIHZhbHVlIHRvIGRlZmluZSB0aGUgYXJjLiAgQ29udmVydGluZyBwZXJjZW50YWdlIHZhbHVlcyB0byB0byBwb2xhclxuICogY29vcmRpbmF0ZXMgb24gdGhlIGNpcmNsZSwgYW5kIHRoZW4gdG8gY2FydGVzaWFuIGNvb3JkaW5hdGVzIGluIHRoZSB2aWV3cG9ydC5cbiAqXG4gKiBAcGFyYW0gez99IGN1cnJlbnRWYWx1ZSBUaGUgY3VycmVudCBwZXJjZW50YWdlIHZhbHVlIG9mIHRoZSBwcm9ncmVzcyBjaXJjbGUsIHRoZSBwZXJjZW50YWdlIG9mIHRoZVxuICogICAgY2lyY2xlIHRvIGZpbGwuXG4gKiBAcGFyYW0gez99IHJvdGF0aW9uIFRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgY2lyY2xlIHdpdGggMCBiZWluZyB0aGUgMCBkZWdyZWUgcG9pbnQuXG4gKiBAcGFyYW0gez99IHN0cm9rZVdpZHRoIFN0cm9rZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3Mgc3Bpbm5lciBhcmMuXG4gKiBAcmV0dXJuIHs/fSBBIHN0cmluZyBmb3IgYW4gU1ZHIHBhdGggcmVwcmVzZW50aW5nIGEgY2lyY2xlIGZpbGxlZCBmcm9tIHRoZSBzdGFydGluZyBwb2ludCB0byB0aGVcbiAqICAgIHBlcmNlbnRhZ2UgdmFsdWUgcHJvdmlkZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFN2Z0FyYyhjdXJyZW50VmFsdWUsIHJvdGF0aW9uLCBzdHJva2VXaWR0aCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0UG9pbnQgPSByb3RhdGlvbiB8fCAwO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJhZGl1cyA9IDUwO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhdGhSYWRpdXMgPSByYWRpdXMgLSBzdHJva2VXaWR0aDtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydEFuZ2xlID0gc3RhcnRQb2ludCAqIE1BWF9BTkdMRTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmRBbmdsZSA9IGN1cnJlbnRWYWx1ZSAqIE1BWF9BTkdMRTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHBvbGFyVG9DYXJ0ZXNpYW4ocmFkaXVzLCBwYXRoUmFkaXVzLCBzdGFydEFuZ2xlKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmQgPSBwb2xhclRvQ2FydGVzaWFuKHJhZGl1cywgcGF0aFJhZGl1cywgZW5kQW5nbGUgKyBzdGFydEFuZ2xlKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmNTd2VlcCA9IGVuZEFuZ2xlIDwgMCA/IDAgOiAxO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhcmdlQXJjRmxhZztcbiAgICBpZiAoZW5kQW5nbGUgPCAwKSB7XG4gICAgICAgIGxhcmdlQXJjRmxhZyA9IGVuZEFuZ2xlID49IC0xODAgPyAwIDogMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxhcmdlQXJjRmxhZyA9IGVuZEFuZ2xlIDw9IDE4MCA/IDAgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gXCJNXCIgKyBzdGFydCArIFwiQVwiICsgcGF0aFJhZGl1cyArIFwiLFwiICsgcGF0aFJhZGl1cyArIFwiIDAgXCIgKyBsYXJnZUFyY0ZsYWcgKyBcIixcIiArIGFyY1N3ZWVwICsgXCIgXCIgKyBlbmQ7XG59XG52YXIgTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlO1xufSgpKTtcbk1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRQcm9ncmVzc1NwaW5uZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kU3Bpbm5lcixcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kUHJvZ3Jlc3NTcGlubmVyQ3NzTWF0U3R5bGVyXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRQcm9ncmVzc1NwaW5uZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kU3Bpbm5lcixcbiAgICAgICAgICAgICAgICAgICAgTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFByb2dyZXNzU3Bpbm5lck1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiA8bWQtcHJvZ3Jlc3MtYmFyPiBjb21wb25lbnQuXG4gKi9cbnZhciBNZFByb2dyZXNzQmFyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQcm9ncmVzc0JhcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIG9mIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gJ3ByaW1hcnknO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuX2J1ZmZlclZhbHVlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGUgb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICAgICAgICpcbiAgICAgICAgICogSW5wdXQgbXVzdCBiZSBvbmUgb2YgdGhlc2UgdmFsdWVzOiBkZXRlcm1pbmF0ZSwgaW5kZXRlcm1pbmF0ZSwgYnVmZmVyLCBxdWVyeSwgZGVmYXVsdHMgdG9cbiAgICAgICAgICogJ2RldGVybWluYXRlJy5cbiAgICAgICAgICogTWlycm9yZWQgdG8gbW9kZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGUgPSAnZGV0ZXJtaW5hdGUnO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgb2YgdGhlIHByb2dyZXNzYmFyLiBEZWZhdWx0cyB0byB6ZXJvLiBNaXJyb3JlZCB0byBhcmlhLXZhbHVlbm93LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLl92YWx1ZSA9IGNsYW1wJDEodiB8fCAwKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLCBcImJ1ZmZlclZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZmZlciB2YWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiBEZWZhdWx0cyB0byB6ZXJvLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9idWZmZXJWYWx1ZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLl9idWZmZXJWYWx1ZSA9IGNsYW1wJDEodiB8fCAwKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB0cmFuc2Zvcm0gdmFsdWUgZm9yIHRoZSBwcm9ncmVzcyBiYXIncyBwcmltYXJ5IGluZGljYXRvci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLl9wcmltYXJ5VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2FsZSA9IHRoaXMudmFsdWUgLyAxMDA7XG4gICAgICAgIHJldHVybiB7IHRyYW5zZm9ybTogXCJzY2FsZVgoXCIgKyBzY2FsZSArIFwiKVwiIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybSB2YWx1ZSBmb3IgdGhlIHByb2dyZXNzIGJhcidzIGJ1ZmZlciBpbmRpY2F0b3IuICBPbmx5IHVzZWQgaWYgdGhlXG4gICAgICogcHJvZ3Jlc3MgbW9kZSBpcyBzZXQgdG8gYnVmZmVyLCBvdGhlcndpc2UgcmV0dXJucyBhbiB1bmRlZmluZWQsIGNhdXNpbmcgbm8gdHJhbnNmb3JtYXRpb24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzQmFyLnByb3RvdHlwZS5fYnVmZmVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09ICdidWZmZXInKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2FsZSA9IHRoaXMuYnVmZmVyVmFsdWUgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4geyB0cmFuc2Zvcm06IFwic2NhbGVYKFwiICsgc2NhbGUgKyBcIilcIiB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWRQcm9ncmVzc0Jhcjtcbn0oKSk7XG5NZFByb2dyZXNzQmFyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtcHJvZ3Jlc3MtYmFyLCBtYXQtcHJvZ3Jlc3MtYmFyJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtdmFsdWVtaW4nOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLXZhbHVlbWF4JzogJzEwMCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXByaW1hcnldJzogJ2NvbG9yID09IFwicHJpbWFyeVwiJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYWNjZW50XSc6ICdjb2xvciA9PSBcImFjY2VudFwiJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtd2Fybl0nOiAnY29sb3IgPT0gXCJ3YXJuXCInLFxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LXByb2dyZXNzLWJhcicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQgbWF0LXByb2dyZXNzLWJhci1lbGVtZW50XFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtcHJvZ3Jlc3MtYmFyLWJ1ZmZlciBtYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnRcXFwiIFtuZ1N0eWxlXT1cXFwiX2J1ZmZlclRyYW5zZm9ybSgpXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnkgbWF0LXByb2dyZXNzLWJhci1maWxsIG1hdC1wcm9ncmVzcy1iYXItZWxlbWVudFxcXCIgW25nU3R5bGVdPVxcXCJfcHJpbWFyeVRyYW5zZm9ybSgpXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeSBtYXQtcHJvZ3Jlc3MtYmFyLWZpbGwgbWF0LXByb2dyZXNzLWJhci1lbGVtZW50XFxcIj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjVweDtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNpdGlvbjpvcGFjaXR5IDI1MG1zIGxpbmVhcjt3aWR0aDoxMDAlfTpob3N0IC5tYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnQsOmhvc3QgLm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXJ7aGVpZ2h0OjEwMCU7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJX06aG9zdCAubWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5ke2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2JhY2tncm91bmQtc2l6ZToxMHB4IDRweDtkaXNwbGF5Om5vbmV9Omhvc3QgLm1hdC1wcm9ncmVzcy1iYXItYnVmZmVye3RyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMjUwbXMgZWFzZSxzdHJva2UgLjNzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9Omhvc3QgLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5e2Rpc3BsYXk6bm9uZX06aG9zdCAubWF0LXByb2dyZXNzLWJhci1maWxse2FuaW1hdGlvbjpub25lO3RyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMjUwbXMgZWFzZSxzdHJva2UgLjNzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9Omhvc3QgLm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXJ7YW5pbWF0aW9uOm5vbmU7Y29udGVudDonJztkaXNwbGF5OmlubGluZS1ibG9jaztsZWZ0OjB9Omhvc3RbbW9kZT1xdWVyeV17dHJhbnNmb3JtOnJvdGF0ZVooMTgwZGVnKX06aG9zdFttb2RlPWluZGV0ZXJtaW5hdGVdIC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGwsOmhvc3RbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItZmlsbHt0cmFuc2l0aW9uOm5vbmV9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1wcmltYXJ5LDpob3N0W21vZGU9cXVlcnldIC5tYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnl7YW5pbWF0aW9uOm1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeS1pbmRldGVybWluYXRlLXRyYW5zbGF0ZSAycyBpbmZpbml0ZSBsaW5lYXI7bGVmdDotMTQ1LjE2NjYxMSV9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1wcmltYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXIsOmhvc3RbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeS5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVye2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnktaW5kZXRlcm1pbmF0ZS1zY2FsZSAycyBpbmZpbml0ZSBsaW5lYXJ9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnksOmhvc3RbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5e2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeS1pbmRldGVybWluYXRlLXRyYW5zbGF0ZSAycyBpbmZpbml0ZSBsaW5lYXI7bGVmdDotNTQuODg4ODkxJTtkaXNwbGF5OmJsb2NrfTpob3N0W21vZGU9aW5kZXRlcm1pbmF0ZV0gLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXIsOmhvc3RbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXJ7YW5pbWF0aW9uOm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5LWluZGV0ZXJtaW5hdGUtc2NhbGUgMnMgaW5maW5pdGUgbGluZWFyfTpob3N0W21vZGU9YnVmZmVyXSAubWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5ke2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQtc2Nyb2xsIDI1MG1zIGluZmluaXRlIGxpbmVhcjtkaXNwbGF5OmJsb2NrfTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKXt0cmFuc2Zvcm06cm90YXRlWSgxODBkZWcpfUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLWJhci1wcmltYXJ5LWluZGV0ZXJtaW5hdGUtdHJhbnNsYXRlezAle3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApfTIwJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguNSwwLC43MDE3MywuNDk1ODIpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApfTU5LjE1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMzAyNDQsLjM4MTM1LC41NSwuOTU2MzUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDgzLjY3MTQyJSl9MTAwJXt0cmFuc2Zvcm06dHJhbnNsYXRlWCgyMDAuNjExMDYlKX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnktaW5kZXRlcm1pbmF0ZS1zY2FsZXswJXt0cmFuc2Zvcm06c2NhbGVYKC4wOCl9MzYuNjUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4zMzQ3MywuMTI0ODIsLjc4NTg0LDEpO3RyYW5zZm9ybTpzY2FsZVgoLjA4KX02OS4xNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjA2LC4xMSwuNiwxKTt0cmFuc2Zvcm06c2NhbGVYKC42NjE0OCl9MTAwJXt0cmFuc2Zvcm06c2NhbGVYKC4wOCl9fUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGV7MCV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjE1LDAsLjUxNTA2LC40MDk2OSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9MjUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4zMTAzMywuMjg0MDYsLjgsLjczMzcxKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgzNy42NTE5MSUpfTQ4LjM1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguNCwuNjI3MDQsLjYsLjkwMjAzKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCg4NC4zODYxNyUpfTEwMCV7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTYwLjI3Nzc4JSl9fUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnktaW5kZXRlcm1pbmF0ZS1zY2FsZXswJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMTUsMCwuNTE1MDYsLjQwOTY5KTt0cmFuc2Zvcm06c2NhbGVYKC4wOCl9MTkuMTUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4zMTAzMywuMjg0MDYsLjgsLjczMzcxKTt0cmFuc2Zvcm06c2NhbGVYKC40NTcxKX00NC4xNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjQsLjYyNzA0LC42LC45MDIwMyk7dHJhbnNmb3JtOnNjYWxlWCguNzI3OTYpfTEwMCV7dHJhbnNmb3JtOnNjYWxlWCguMDgpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZC1zY3JvbGx7dG97dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwcHgpfX1cIl0sXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUHJvZ3Jlc3NCYXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbk1kUHJvZ3Jlc3NCYXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2NvbG9yJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLXZhbHVlbm93JyxdIH0sXSxcbiAgICAnYnVmZmVyVmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ21vZGUnOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIubW9kZScsXSB9LF0sXG59O1xuLyoqXG4gKiBDbGFtcHMgYSB2YWx1ZSB0byBiZSBiZXR3ZWVuIHR3byBudW1iZXJzLCBieSBkZWZhdWx0IDAgYW5kIDEwMC5cbiAqIEBwYXJhbSB7P30gdlxuICogQHBhcmFtIHs/PX0gbWluXG4gKiBAcGFyYW0gez89fSBtYXhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNsYW1wJDEodiwgbWluLCBtYXgpIHtcbiAgICBpZiAobWluID09PSB2b2lkIDApIHsgbWluID0gMDsgfVxuICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSAxMDA7IH1cbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHYpKTtcbn1cbnZhciBNZFByb2dyZXNzQmFyTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQcm9ncmVzc0Jhck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kUHJvZ3Jlc3NCYXJNb2R1bGU7XG59KCkpO1xuTWRQcm9ncmVzc0Jhck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZFByb2dyZXNzQmFyLCBNZENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRQcm9ncmVzc0Jhcl0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUHJvZ3Jlc3NCYXJNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRNZElucHV0Q29udGFpbmVyUGxhY2Vob2xkZXJDb25mbGljdEVycm9yKCkge1xuICAgIHJldHVybiBFcnJvcignUGxhY2Vob2xkZXIgYXR0cmlidXRlIGFuZCBjaGlsZCBlbGVtZW50IHdlcmUgYm90aCBzcGVjaWZpZWQuJyk7XG59XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHBhcmFtIHs/fSB0eXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRNZElucHV0Q29udGFpbmVyVW5zdXBwb3J0ZWRUeXBlRXJyb3IodHlwZSkge1xuICAgIHJldHVybiBFcnJvcihcIklucHV0IHR5cGUgXFxcIlwiICsgdHlwZSArIFwiXFxcIiBpc24ndCBzdXBwb3J0ZWQgYnkgbWQtaW5wdXQtY29udGFpbmVyLlwiKTtcbn1cbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcGFyYW0gez99IGFsaWduXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRNZElucHV0Q29udGFpbmVyRHVwbGljYXRlZEhpbnRFcnJvcihhbGlnbikge1xuICAgIHJldHVybiBFcnJvcihcIkEgaGludCB3YXMgYWxyZWFkeSBkZWNsYXJlZCBmb3IgJ2FsaWduPVxcXCJcIiArIGFsaWduICsgXCJcXFwiJy5cIik7XG59XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TWRJbnB1dENvbnRhaW5lck1pc3NpbmdNZElucHV0RXJyb3IoKSB7XG4gICAgcmV0dXJuIEVycm9yKCdtZC1pbnB1dC1jb250YWluZXIgbXVzdCBjb250YWluIGFuIG1kSW5wdXQgZGlyZWN0aXZlLiAnICtcbiAgICAgICAgJ0RpZCB5b3UgZm9yZ2V0IHRvIGFkZCBtZElucHV0IHRvIHRoZSBuYXRpdmUgaW5wdXQgb3IgdGV4dGFyZWEgZWxlbWVudD8nKTtcbn1cbi8vIEludmFsaWQgaW5wdXQgdHlwZS4gVXNpbmcgb25lIG9mIHRoZXNlIHdpbGwgdGhyb3cgYW4gTWRJbnB1dENvbnRhaW5lclVuc3VwcG9ydGVkVHlwZUVycm9yLlxudmFyIE1EX0lOUFVUX0lOVkFMSURfVFlQRVMgPSBbXG4gICAgJ2J1dHRvbicsXG4gICAgJ2NoZWNrYm94JyxcbiAgICAnY29sb3InLFxuICAgICdmaWxlJyxcbiAgICAnaGlkZGVuJyxcbiAgICAnaW1hZ2UnLFxuICAgICdyYWRpbycsXG4gICAgJ3JhbmdlJyxcbiAgICAncmVzZXQnLFxuICAgICdzdWJtaXQnXG5dO1xudmFyIG5leHRVbmlxdWVJZCQxID0gMDtcbi8qKlxuICogVGhlIHBsYWNlaG9sZGVyIGRpcmVjdGl2ZS4gVGhlIGNvbnRlbnQgY2FuIGRlY2xhcmUgdGhpcyB0byBpbXBsZW1lbnQgbW9yZVxuICogY29tcGxleCBwbGFjZWhvbGRlcnMuXG4gKi9cbnZhciBNZFBsYWNlaG9sZGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQbGFjZWhvbGRlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kUGxhY2Vob2xkZXI7XG59KCkpO1xuTWRQbGFjZWhvbGRlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtcGxhY2Vob2xkZXIsIG1hdC1wbGFjZWhvbGRlcidcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRQbGFjZWhvbGRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBIaW50IHRleHQgdG8gYmUgc2hvd24gdW5kZXJuZWF0aCB0aGUgaW5wdXQuXG4gKi9cbnZhciBNZEhpbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEhpbnQoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGFsaWduIHRoZSBoaW50IGxhYmVsIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsaWduID0gJ3N0YXJ0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuaXF1ZSBJRCBmb3IgdGhlIGhpbnQuIFVzZWQgZm9yIHRoZSBhcmlhLWRlc2NyaWJlZGJ5IG9uIHRoZSBpbnB1dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBcIm1kLWlucHV0LWhpbnQtXCIgKyBuZXh0VW5pcXVlSWQkMSsrO1xuICAgIH1cbiAgICByZXR1cm4gTWRIaW50O1xufSgpKTtcbk1kSGludC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtaGludCwgbWF0LWhpbnQnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1oaW50JyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcmlnaHRdJzogJ2FsaWduID09IFwiZW5kXCInLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuaWRdJzogJ2lkJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kSGludC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuTWRIaW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdhbGlnbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xuLyoqXG4gKiBTaW5nbGUgZXJyb3IgbWVzc2FnZSB0byBiZSBzaG93biB1bmRlcm5lYXRoIHRoZSBpbnB1dC5cbiAqL1xudmFyIE1kRXJyb3JEaXJlY3RpdmUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEVycm9yRGlyZWN0aXZlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRFcnJvckRpcmVjdGl2ZTtcbn0oKSk7XG5NZEVycm9yRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1lcnJvciwgbWF0LWVycm9yJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtaW5wdXQtZXJyb3InXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEVycm9yRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFByZWZpeCB0byBiZSBwbGFjZWQgdGhlIHRoZSBmcm9udCBvZiB0aGUgaW5wdXQuXG4gKi9cbnZhciBNZFByZWZpeCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUHJlZml4KCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRQcmVmaXg7XG59KCkpO1xuTWRQcmVmaXguZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZFByZWZpeF0sIFttYXRQcmVmaXhdLCBbbWQtcHJlZml4XSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRQcmVmaXguY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogU3VmZml4IHRvIGJlIHBsYWNlZCBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAqL1xudmFyIE1kU3VmZml4ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTdWZmaXgoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFN1ZmZpeDtcbn0oKSk7XG5NZFN1ZmZpeC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kU3VmZml4XSwgW21hdFN1ZmZpeF0sIFttZC1zdWZmaXhdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFN1ZmZpeC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBNYXJrZXIgZm9yIHRoZSBpbnB1dCBlbGVtZW50IHRoYXQgYE1kSW5wdXRDb250YWluZXJgIGlzIHdyYXBwaW5nLlxuICovXG52YXIgTWRJbnB1dERpcmVjdGl2ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX3BsYXRmb3JtXG4gICAgICogQHBhcmFtIHs/fSBfbmdDb250cm9sXG4gICAgICogQHBhcmFtIHs/fSBfcGFyZW50Rm9ybVxuICAgICAqIEBwYXJhbSB7P30gX3BhcmVudEZvcm1Hcm91cFxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JPcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRJbnB1dERpcmVjdGl2ZShfZWxlbWVudFJlZiwgX3JlbmRlcmVyLCBfcGxhdGZvcm0sIF9uZ0NvbnRyb2wsIF9wYXJlbnRGb3JtLCBfcGFyZW50Rm9ybUdyb3VwLCBlcnJvck9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIHRoaXMuX25nQ29udHJvbCA9IF9uZ0NvbnRyb2w7XG4gICAgICAgIHRoaXMuX3BhcmVudEZvcm0gPSBfcGFyZW50Rm9ybTtcbiAgICAgICAgdGhpcy5fcGFyZW50Rm9ybUdyb3VwID0gX3BhcmVudEZvcm1Hcm91cDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhcmlhYmxlcyB1c2VkIGFzIGNhY2hlIGZvciBnZXR0ZXJzIGFuZCBzZXR0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZm9jdXNlZCBvciBub3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIHBsYWNlaG9sZGVyIGNoYW5nZXMgc28gdGhhdCB0aGUgYG1kLWlucHV0LWNvbnRhaW5lcmAgY2FuIHJlLXZhbGlkYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX25ldmVyRW1wdHlJbnB1dFR5cGVzID0gW1xuICAgICAgICAgICAgJ2RhdGUnLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJyxcbiAgICAgICAgICAgICdkYXRldGltZS1sb2NhbCcsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ3RpbWUnLFxuICAgICAgICAgICAgJ3dlZWsnXG4gICAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiBnZXRTdXBwb3J0ZWRJbnB1dFR5cGVzKCkuaGFzKHQpOyB9KTtcbiAgICAgICAgLy8gRm9yY2Ugc2V0dGVyIHRvIGJlIGNhbGxlZCBpbiBjYXNlIGlkIHdhcyBub3Qgc3BlY2lmaWVkLlxuICAgICAgICB0aGlzLmlkID0gdGhpcy5pZDtcbiAgICAgICAgdGhpcy5fZXJyb3JPcHRpb25zID0gZXJyb3JPcHRpb25zID8gZXJyb3JPcHRpb25zIDoge307XG4gICAgICAgIHRoaXMuZXJyb3JTdGF0ZU1hdGNoZXIgPSB0aGlzLl9lcnJvck9wdGlvbnMuZXJyb3JTdGF0ZU1hdGNoZXIgfHwgZGVmYXVsdEVycm9yU3RhdGVNYXRjaGVyO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25nQ29udHJvbCA/IHRoaXMuX25nQ29udHJvbC5kaXNhYmxlZCA6IHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuaXF1ZSBpZCBvZiB0aGUgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9pZCA9IHZhbHVlIHx8IHRoaXMuX3VpZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYWNlaG9sZGVyIGF0dHJpYnV0ZSBvZiB0aGUgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXI7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJDaGFuZ2UuZW1pdCh0aGlzLl9wbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHJlcXVpcmVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXF1aXJlZDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3JlcXVpcmVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcInR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5wdXQgdHlwZSBvZiB0aGUgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdHlwZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gdmFsdWUgfHwgJ3RleHQnO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVUeXBlKCk7XG4gICAgICAgICAgICAvLyBXaGVuIHVzaW5nIEFuZ3VsYXIgaW5wdXRzLCBkZXZlbG9wZXJzIGFyZSBubyBsb25nZXIgYWJsZSB0byBzZXQgdGhlIHByb3BlcnRpZXMgb24gdGhlIG5hdGl2ZVxuICAgICAgICAgICAgLy8gaW5wdXQgZWxlbWVudC4gVG8gZW5zdXJlIHRoYXQgYmluZGluZ3MgZm9yIGB0eXBlYCB3b3JrLCB3ZSBuZWVkIHRvIHN5bmMgdGhlIHNldHRlclxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgbmF0aXZlIHByb3BlcnR5LiBUZXh0YXJlYSBlbGVtZW50cyBkb24ndCBzdXBwb3J0IHRoZSB0eXBlIHByb3BlcnR5IG9yIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNUZXh0YXJlYSgpICYmIGdldFN1cHBvcnRlZElucHV0VHlwZXMoKS5oYXModGhpcy5fdHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd0eXBlJywgdGhpcy5fdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5wdXQgZWxlbWVudCdzIHZhbHVlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB2YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImVtcHR5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGVtcHR5LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX2lzTmV2ZXJFbXB0eSgpICYmXG4gICAgICAgICAgICAgICAgKHRoaXMudmFsdWUgPT0gbnVsbCB8fCB0aGlzLnZhbHVlID09PSAnJykgJiZcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5wdXQgY29udGFpbnMgYmFkIGlucHV0LiBJZiBzbywgd2Uga25vdyB0aGF0IGl0IG9ubHkgYXBwZWFycyBlbXB0eSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlIGZhaWxlZCB0byBwYXJzZS4gRnJvbSB0aGUgdXNlcidzIHBlcnNwZWN0aXZlIGl0IGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1tYWxlcmJhKTogQWRkIGUyZSB0ZXN0IGZvciBiYWQgaW5wdXQgY2FzZS5cbiAgICAgICAgICAgICAgICAhdGhpcy5faXNCYWRJbnB1dCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiX3VpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jYWNoZWRVaWQgPSB0aGlzLl9jYWNoZWRVaWQgfHwgXCJtZC1pbnB1dC1cIiArIG5leHRVbmlxdWVJZCQxKys7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5fb25Gb2N1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5mb2N1c2VkID0gdHJ1ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLl9vbkJsdXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZm9jdXNlZCA9IGZhbHNlOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX29uSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBub29wIGZ1bmN0aW9uIGFuZCBpcyB1c2VkIHRvIGxldCBBbmd1bGFyIGtub3cgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgIC8vIEFuZ3VsYXIgd2lsbCBydW4gYSBuZXcgY2hhbmdlIGRldGVjdGlvbiBlYWNoIHRpbWUgdGhlIGBpbnB1dGAgZXZlbnQgaGFzIGJlZW4gZGlzcGF0Y2hlZC5cbiAgICAgICAgLy8gSXQncyBuZWNlc3NhcnkgdGhhdCBBbmd1bGFyIHJlY29nbml6ZXMgdGhlIHZhbHVlIGNoYW5nZSwgYmVjYXVzZSB3aGVuIGZsb2F0aW5nTGFiZWxcbiAgICAgICAgLy8gaXMgc2V0IHRvIGZhbHNlIGFuZCBBbmd1bGFyIGZvcm1zIGFyZW4ndCB1c2VkLCB0aGUgcGxhY2Vob2xkZXIgd29uJ3QgcmVjb2duaXplIHRoZVxuICAgICAgICAvLyB2YWx1ZSBjaGFuZ2VzIGFuZCB3aWxsIG5vdCBkaXNhcHBlYXIuXG4gICAgICAgIC8vIExpc3RlbmluZyB0byB0aGUgaW5wdXQgZXZlbnQgd291bGRuJ3QgYmUgbmVjZXNzYXJ5IHdoZW4gdGhlIGlucHV0IGlzIHVzaW5nIHRoZVxuICAgICAgICAvLyBGb3Jtc01vZHVsZSBvciBSZWFjdGl2ZUZvcm1zTW9kdWxlLCBiZWNhdXNlIEFuZ3VsYXIgZm9ybXMgYWxzbyBsaXN0ZW5zIHRvIGlucHV0IGV2ZW50cy5cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGluIGFuIGVycm9yIHN0YXRlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX2lzRXJyb3JTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udHJvbCA9IHRoaXMuX25nQ29udHJvbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9ybSA9IHRoaXMuX3BhcmVudEZvcm1Hcm91cCB8fCB0aGlzLl9wYXJlbnRGb3JtO1xuICAgICAgICByZXR1cm4gY29udHJvbCAmJiB0aGlzLmVycm9yU3RhdGVNYXRjaGVyKC8qKiBAdHlwZSB7P30gKi8gKGNvbnRyb2wuY29udHJvbCksIGZvcm0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHRoZSBpbnB1dCBpcyBhIHN1cHBvcnRlZCB0eXBlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX3ZhbGlkYXRlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKE1EX0lOUFVUX0lOVkFMSURfVFlQRVMuaW5kZXhPZih0aGlzLl90eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kSW5wdXRDb250YWluZXJVbnN1cHBvcnRlZFR5cGVFcnJvcih0aGlzLl90eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5faXNOZXZlckVtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmV2ZXJFbXB0eUlucHV0VHlwZXMuaW5kZXhPZih0aGlzLl90eXBlKSAhPT0gLTE7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5faXNCYWRJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhlIGB2YWxpZGl0eWAgcHJvcGVydHkgd29uJ3QgYmUgcHJlc2VudCBvbiBwbGF0Zm9ybS1zZXJ2ZXIuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbGlkaXR5ID0gKCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKS52YWxpZGl0eTtcbiAgICAgICAgcmV0dXJuIHZhbGlkaXR5ICYmIHZhbGlkaXR5LmJhZElucHV0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgY29tcG9uZW50IGhvc3QgaXMgYSB0ZXh0YXJlYS4gSWYgbm90IHJlY29nbml6YWJsZSBpdCByZXR1cm5zIGZhbHNlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX2lzVGV4dGFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hdGl2ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIEluIFVuaXZlcnNhbCwgd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gYG5vZGVOYW1lYCwgYnV0IHRoZSBzYW1lIGNhbiBiZSBhY2hpZXZlZCB3aXRoIGBuYW1lYC5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSBvbmNlIEFuZ3VsYXIgc3dpdGNoZXMgdG8gYW4gQVBJIHRoYXQgcmVzZW1ibGVzIHRoZVxuICAgICAgICAvLyBET00gY2xvc2VyLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlTmFtZSA9IHRoaXMuX3BsYXRmb3JtLmlzQnJvd3NlciA/IG5hdGl2ZUVsZW1lbnQubm9kZU5hbWUgOiBuYXRpdmVFbGVtZW50Lm5hbWU7XG4gICAgICAgIHJldHVybiBub2RlTmFtZSA/IG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0YXJlYScgOiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBNZElucHV0RGlyZWN0aXZlO1xufSgpKTtcbk1kSW5wdXREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCJpbnB1dFttZElucHV0XSwgdGV4dGFyZWFbbWRJbnB1dF0sIGlucHV0W21hdElucHV0XSwgdGV4dGFyZWFbbWF0SW5wdXRdXCIsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LWlucHV0LWVsZW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAvLyBOYXRpdmUgaW5wdXQgcHJvcGVydGllcyB0aGF0IGFyZSBvdmVyd3JpdHRlbiBieSBBbmd1bGFyIGlucHV0cyBuZWVkIHRvIGJlIHN5bmNlZCB3aXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudC4gT3RoZXJ3aXNlIHByb3BlcnR5IGJpbmRpbmdzIGZvciB0aG9zZSBkb24ndCB3b3JrLlxuICAgICAgICAgICAgICAgICAgICAnW2lkXSc6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgICdbcGxhY2Vob2xkZXJdJzogJ3BsYWNlaG9sZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tkaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW3JlcXVpcmVkXSc6ICdyZXF1aXJlZCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XSc6ICdhcmlhRGVzY3JpYmVkYnkgfHwgbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWludmFsaWRdJzogJ19pc0Vycm9yU3RhdGUoKScsXG4gICAgICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX29uQmx1cigpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhmb2N1cyknOiAnX29uRm9jdXMoKScsXG4gICAgICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ19vbklucHV0KCknLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRJbnB1dERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIsIH0sXG4gICAgeyB0eXBlOiBQbGF0Zm9ybSwgfSxcbiAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBTZWxmIH0sXSB9LFxuICAgIHsgdHlwZTogTmdGb3JtLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IEZvcm1Hcm91cERpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTURfRVJST1JfR0xPQkFMX09QVElPTlMsXSB9LF0gfSxcbl07IH07XG5NZElucHV0RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdyZXF1aXJlZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndHlwZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZXJyb3JTdGF0ZU1hdGNoZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ19wbGFjZWhvbGRlckNoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBDb250YWluZXIgZm9yIHRleHQgaW5wdXRzIHRoYXQgYXBwbGllcyBNYXRlcmlhbCBEZXNpZ24gc3R5bGluZyBhbmQgYmVoYXZpb3IuXG4gKi9cbnZhciBNZElucHV0Q29udGFpbmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX2NoYW5nZURldGVjdG9yUmVmXG4gICAgICogQHBhcmFtIHs/fSBwbGFjZWhvbGRlck9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZElucHV0Q29udGFpbmVyKF9lbGVtZW50UmVmLCBfY2hhbmdlRGV0ZWN0b3JSZWYsIHBsYWNlaG9sZGVyT3B0aW9ucykge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3Igb2YgdGhlIGlucHV0IGRpdmlkZXIsIGJhc2VkIG9uIHRoZSB0aGVtZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sb3IgPSAncHJpbWFyeSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGF0ZSBvZiB0aGUgbWQtaGludCBhbmQgbWQtZXJyb3IgYW5pbWF0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdEFuaW1hdGlvblN0YXRlID0gJyc7XG4gICAgICAgIHRoaXMuX2hpbnRMYWJlbCA9ICcnO1xuICAgICAgICAvLyBVbmlxdWUgaWQgZm9yIHRoZSBoaW50IGxhYmVsLlxuICAgICAgICB0aGlzLl9oaW50TGFiZWxJZCA9IFwibWQtaW5wdXQtaGludC1cIiArIG5leHRVbmlxdWVJZCQxKys7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9ucyA9IHBsYWNlaG9sZGVyT3B0aW9ucyA/IHBsYWNlaG9sZGVyT3B0aW9ucyA6IHt9O1xuICAgICAgICB0aGlzLmZsb2F0UGxhY2Vob2xkZXIgPSB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbnMuZmxvYXQgfHwgJ2F1dG8nO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiZGl2aWRlckNvbG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBjb2xvciBpbnN0ZWFkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbG9yOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5jb2xvciA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiaGlkZVJlcXVpcmVkTWFya2VyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHJlcXVpcmVkIG1hcmtlciBzaG91bGQgYmUgaGlkZGVuLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oaWRlUmVxdWlyZWRNYXJrZXI7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGlkZVJlcXVpcmVkTWFya2VyID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLCBcIl9zaG91bGRBbHdheXNGbG9hdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBmbG9hdGluZyBsYWJlbCBzaG91bGQgYWx3YXlzIGZsb2F0IG9yIG5vdC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZmxvYXRQbGFjZWhvbGRlciA9PT0gJ2Fsd2F5cyc7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJfY2FuUGxhY2Vob2xkZXJGbG9hdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBwbGFjZWhvbGRlciBjYW4gZmxvYXQgb3Igbm90LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyICE9PSAnbmV2ZXInOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiaGludExhYmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgZm9yIHRoZSBpbnB1dCBoaW50LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oaW50TGFiZWw7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGludExhYmVsID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzSGludHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLCBcImZsb2F0UGxhY2Vob2xkZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGFsd2F5cyBmbG9hdCwgbmV2ZXIgZmxvYXQgb3IgZmxvYXQgYXMgdGhlIHVzZXIgdHlwZXMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXI7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZmxvYXRQbGFjZWhvbGRlciA9IHZhbHVlIHx8IHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9ucy5mbG9hdCB8fCAnYXV0byc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUlucHV0Q2hpbGQoKTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0hpbnRzKCk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlUGxhY2Vob2xkZXJzKCk7XG4gICAgICAgIC8vIFJlLXZhbGlkYXRlIHdoZW4gdGhpbmdzIGNoYW5nZS5cbiAgICAgICAgdGhpcy5faGludENoaWxkcmVuLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wcm9jZXNzSGludHMoKTsgfSk7XG4gICAgICAgIHRoaXMuX21kSW5wdXRDaGlsZC5fcGxhY2Vob2xkZXJDaGFuZ2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92YWxpZGF0ZVBsYWNlaG9sZGVycygpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUlucHV0Q2hpbGQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBdm9pZCBhbmltYXRpb25zIG9uIGxvYWQuXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdEFuaW1hdGlvblN0YXRlID0gJ2VudGVyJztcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgY2xhc3MgZnJvbSB0aGUgTmdDb250cm9sIHNob3VsZCBiZSBmb3J3YXJkZWQgdG8gdGhlIGhvc3QgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gez99IHByb3BcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLl9zaG91bGRGb3J3YXJkID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udHJvbCA9IHRoaXMuX21kSW5wdXRDaGlsZCA/IHRoaXMuX21kSW5wdXRDaGlsZC5fbmdDb250cm9sIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2wgJiYgKChjb250cm9sKSlbcHJvcF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBpbnB1dCBoYXMgYSBwbGFjZWhvbGRlci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLl9oYXNQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhKHRoaXMuX21kSW5wdXRDaGlsZC5wbGFjZWhvbGRlciB8fCB0aGlzLl9wbGFjZWhvbGRlckNoaWxkKTsgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSB1bmRlcmx5aW5nIGlucHV0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX2ZvY3VzSW5wdXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX21kSW5wdXRDaGlsZC5mb2N1cygpOyB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBkaXNwbGF5IGhpbnRzIG9yIGVycm9ycy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLl9nZXREaXNwbGF5ZWRNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXQgPSB0aGlzLl9tZElucHV0Q2hpbGQ7XG4gICAgICAgIHJldHVybiAodGhpcy5fZXJyb3JDaGlsZHJlbi5sZW5ndGggPiAwICYmIGlucHV0Ll9pc0Vycm9yU3RhdGUoKSkgPyAnZXJyb3InIDogJ2hpbnQnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgcGxhY2Vob2xkZXIgKGVpdGhlciBgaW5wdXRgIGF0dHJpYnV0ZSBvciBjaGlsZCBlbGVtZW50IHdpdGggdGhlXG4gICAgICogYG1kLXBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5fdmFsaWRhdGVQbGFjZWhvbGRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tZElucHV0Q2hpbGQucGxhY2Vob2xkZXIgJiYgdGhpcy5fcGxhY2Vob2xkZXJDaGlsZCkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TWRJbnB1dENvbnRhaW5lclBsYWNlaG9sZGVyQ29uZmxpY3RFcnJvcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb2VzIGFueSBleHRyYSBwcm9jZXNzaW5nIHRoYXQgaXMgcmVxdWlyZWQgd2hlbiBoYW5kbGluZyB0aGUgaGludHMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5fcHJvY2Vzc0hpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUhpbnRzKCk7XG4gICAgICAgIHRoaXMuX3N5bmNBcmlhRGVzY3JpYmVkYnkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGEgbWF4aW11bSBvZiBvbmUgb2YgZWFjaCBgPG1kLWhpbnQ+YCBhbGlnbm1lbnQgc3BlY2lmaWVkLCB3aXRoIHRoZVxuICAgICAqIGF0dHJpYnV0ZSBiZWluZyBjb25zaWRlcmVkIGFzIGBhbGlnbj1cInN0YXJ0XCJgLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX3ZhbGlkYXRlSGludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9oaW50Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0SGludF8xO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kSGludF8xO1xuICAgICAgICAgICAgdGhpcy5faGludENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGludC5hbGlnbiA9PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEhpbnRfMSB8fCBfdGhpcy5oaW50TGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGdldE1kSW5wdXRDb250YWluZXJEdXBsaWNhdGVkSGludEVycm9yKCdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SGludF8xID0gaGludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGludC5hbGlnbiA9PSAnZW5kJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSGludF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBnZXRNZElucHV0Q29udGFpbmVyRHVwbGljYXRlZEhpbnRFcnJvcignZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5kSGludF8xID0gaGludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2hpbGQgaW5wdXQncyBgYXJpYS1kZXNjcmliZWRieWAgdG8gYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGUgaWRzXG4gICAgICogb2YgdGhlIGN1cnJlbnRseS1zcGVjaWZpZWQgaGludHMsIGFzIHdlbGwgYXMgYSBnZW5lcmF0ZWQgaWQgZm9yIHRoZSBoaW50IGxhYmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX3N5bmNBcmlhRGVzY3JpYmVkYnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tZElucHV0Q2hpbGQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkcyA9IFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRIaW50ID0gdGhpcy5faGludENoaWxkcmVuID9cbiAgICAgICAgICAgICAgICB0aGlzLl9oaW50Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAoaGludCkgeyByZXR1cm4gaGludC5hbGlnbiA9PT0gJ3N0YXJ0JzsgfSkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kSGludCA9IHRoaXMuX2hpbnRDaGlsZHJlbiA/XG4gICAgICAgICAgICAgICAgdGhpcy5faGludENoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKGhpbnQpIHsgcmV0dXJuIGhpbnQuYWxpZ24gPT09ICdlbmQnOyB9KSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoc3RhcnRIaW50KSB7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goc3RhcnRIaW50LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2hpbnRMYWJlbCkge1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKHRoaXMuX2hpbnRMYWJlbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRIaW50KSB7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goZW5kSGludC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tZElucHV0Q2hpbGQuYXJpYURlc2NyaWJlZGJ5ID0gaWRzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjb250YWluZXIncyBpbnB1dCBjaGlsZCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLl92YWxpZGF0ZUlucHV0Q2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWRJbnB1dENoaWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRNZElucHV0Q29udGFpbmVyTWlzc2luZ01kSW5wdXRFcnJvcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWRJbnB1dENvbnRhaW5lcjtcbn0oKSk7XG5NZElucHV0Q29udGFpbmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtaW5wdXQtY29udGFpbmVyLCBtYXQtaW5wdXQtY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtd3JhcHBlclxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LWlucHV0LWZsZXhcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1pbnB1dC1wcmVmaXhcXFwiICpuZ0lmPVxcXCJfcHJlZml4Q2hpbGRyZW4ubGVuZ3RoXFxcIj48bmctY29udGVudCBzZWxlY3Q9XFxcIlttZFByZWZpeF0sIFttYXRQcmVmaXhdXFxcIj48L25nLWNvbnRlbnQ+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LWlucHV0LWluZml4XFxcIj48bmctY29udGVudCBzZWxlY3Rvcj1cXFwiaW5wdXQsIHRleHRhcmVhXFxcIj48L25nLWNvbnRlbnQ+PHNwYW4gY2xhc3M9XFxcIm1hdC1pbnB1dC1wbGFjZWhvbGRlci13cmFwcGVyXFxcIj48bGFiZWwgY2xhc3M9XFxcIm1hdC1pbnB1dC1wbGFjZWhvbGRlclxcXCIgW2F0dHIuZm9yXT1cXFwiX21kSW5wdXRDaGlsZC5pZFxcXCIgW2NsYXNzLm1hdC1lbXB0eV09XFxcIl9tZElucHV0Q2hpbGQuZW1wdHkgJiYgIV9zaG91bGRBbHdheXNGbG9hdFxcXCIgW2NsYXNzLm1hdC1mbG9hdF09XFxcIl9jYW5QbGFjZWhvbGRlckZsb2F0XFxcIiBbY2xhc3MubWF0LWFjY2VudF09XFxcImNvbG9yID09ICdhY2NlbnQnXFxcIiBbY2xhc3MubWF0LXdhcm5dPVxcXCJjb2xvciA9PSAnd2FybidcXFwiICpuZ0lmPVxcXCJfaGFzUGxhY2Vob2xkZXIoKVxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1wbGFjZWhvbGRlciwgbWF0LXBsYWNlaG9sZGVyXFxcIj48L25nLWNvbnRlbnQ+e3tfbWRJbnB1dENoaWxkLnBsYWNlaG9sZGVyfX0gPHNwYW4gY2xhc3M9XFxcIm1hdC1wbGFjZWhvbGRlci1yZXF1aXJlZFxcXCIgKm5nSWY9XFxcIiFoaWRlUmVxdWlyZWRNYXJrZXIgJiYgX21kSW5wdXRDaGlsZC5yZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPjwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtc3VmZml4XFxcIiAqbmdJZj1cXFwiX3N1ZmZpeENoaWxkcmVuLmxlbmd0aFxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWRTdWZmaXhdLCBbbWF0U3VmZml4XVxcXCI+PC9uZy1jb250ZW50PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1pbnB1dC11bmRlcmxpbmVcXFwiICN1bmRlcmxpbmUgW2NsYXNzLm1hdC1kaXNhYmxlZF09XFxcIl9tZElucHV0Q2hpbGQuZGlzYWJsZWRcXFwiPjxzcGFuIGNsYXNzPVxcXCJtYXQtaW5wdXQtcmlwcGxlXFxcIiBbY2xhc3MubWF0LWFjY2VudF09XFxcImNvbG9yID09ICdhY2NlbnQnXFxcIiBbY2xhc3MubWF0LXdhcm5dPVxcXCJjb2xvciA9PSAnd2FybidcXFwiPjwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtc3Vic2NyaXB0LXdyYXBwZXJcXFwiIFtuZ1N3aXRjaF09XFxcIl9nZXREaXNwbGF5ZWRNZXNzYWdlcygpXFxcIj48ZGl2ICpuZ1N3aXRjaENhc2U9XFxcIidlcnJvcidcXFwiIFtAdHJhbnNpdGlvbk1lc3NhZ2VzXT1cXFwiX3N1YnNjcmlwdEFuaW1hdGlvblN0YXRlXFxcIj48bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLWVycm9yLCBtYXQtZXJyb3JcXFwiPjwvbmctY29udGVudD48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtaGludC13cmFwcGVyXFxcIiAqbmdTd2l0Y2hDYXNlPVxcXCInaGludCdcXFwiIFtAdHJhbnNpdGlvbk1lc3NhZ2VzXT1cXFwiX3N1YnNjcmlwdEFuaW1hdGlvblN0YXRlXFxcIj48ZGl2ICpuZ0lmPVxcXCJoaW50TGFiZWxcXFwiIFtpZF09XFxcIl9oaW50TGFiZWxJZFxcXCIgY2xhc3M9XFxcIm1hdC1oaW50XFxcIj57e2hpbnRMYWJlbH19PC9kaXY+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1oaW50Om5vdChbYWxpZ249J2VuZCddKSwgbWF0LWhpbnQ6bm90KFthbGlnbj0nZW5kJ10pXFxcIj48L25nLWNvbnRlbnQ+PGRpdiBjbGFzcz1cXFwibWF0LWlucHV0LWhpbnQtc3BhY2VyXFxcIj48L2Rpdj48bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLWhpbnRbYWxpZ249J2VuZCddLCBtYXQtaGludFthbGlnbj0nZW5kJ11cXFwiPjwvbmctY29udGVudD48L2Rpdj48L2Rpdj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtaW5wdXQtY29udGFpbmVye2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO3RleHQtYWxpZ246bGVmdH1bZGlyPXJ0bF0gLm1hdC1pbnB1dC1jb250YWluZXJ7dGV4dC1hbGlnbjpyaWdodH0ubWF0LWlucHV0LXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC1pbnB1dC1mbGV4e2Rpc3BsYXk6aW5saW5lLWZsZXg7YWxpZ24taXRlbXM6YmFzZWxpbmU7d2lkdGg6MTAwJX0ubWF0LWlucHV0LXByZWZpeCwubWF0LWlucHV0LXN1ZmZpeHt3aGl0ZS1zcGFjZTpub3dyYXA7ZmxleDpub25lfS5tYXQtaW5wdXQtcHJlZml4IC5tYXQtZGF0ZXBpY2tlci10b2dnbGUsLm1hdC1pbnB1dC1wcmVmaXggLm1hdC1pY29uLC5tYXQtaW5wdXQtc3VmZml4IC5tYXQtZGF0ZXBpY2tlci10b2dnbGUsLm1hdC1pbnB1dC1zdWZmaXggLm1hdC1pY29ue3dpZHRoOjFlbTtoZWlnaHQ6MWVtO3ZlcnRpY2FsLWFsaWduOnRleHQtYm90dG9tfS5tYXQtaW5wdXQtcHJlZml4IC5tYXQtaWNvbi1idXR0b24sLm1hdC1pbnB1dC1zdWZmaXggLm1hdC1pY29uLWJ1dHRvbntmb250OmluaGVyaXQ7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9Lm1hdC1pbnB1dC1wcmVmaXggLm1hdC1pY29uLWJ1dHRvbiAubWF0LWljb24sLm1hdC1pbnB1dC1zdWZmaXggLm1hdC1pY29uLWJ1dHRvbiAubWF0LWljb257Zm9udC1zaXplOmluaGVyaXQ7d2lkdGg6MWVtO2hlaWdodDoxZW07dmVydGljYWwtYWxpZ246YmFzZWxpbmV9Lm1hdC1pbnB1dC1pbmZpeHtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXg6YXV0b30ubWF0LWlucHV0LWVsZW1lbnR7Zm9udDppbmhlcml0O2JhY2tncm91bmQ6MCAwO2NvbG9yOmN1cnJlbnRDb2xvcjtib3JkZXI6bm9uZTtvdXRsaW5lOjA7cGFkZGluZzowO3dpZHRoOjEwMCU7dmVydGljYWwtYWxpZ246Ym90dG9tfS5tYXQtaW5wdXQtZWxlbWVudDotbW96LXVpLWludmFsaWR7Ym94LXNoYWRvdzpub25lfS5tYXQtaW5wdXQtZWxlbWVudDotd2Via2l0LWF1dG9maWxsKy5tYXQtaW5wdXQtcGxhY2Vob2xkZXItd3JhcHBlciAubWF0LWlucHV0LXBsYWNlaG9sZGVye2Rpc3BsYXk6bm9uZX0ubWF0LWlucHV0LWVsZW1lbnQ6LXdlYmtpdC1hdXRvZmlsbCsubWF0LWlucHV0LXBsYWNlaG9sZGVyLXdyYXBwZXIgLm1hdC1mbG9hdHtkaXNwbGF5OmJsb2NrO3RyYW5zaXRpb246bm9uZX0ubWF0LWlucHV0LWVsZW1lbnQ6OnBsYWNlaG9sZGVye2NvbG9yOnRyYW5zcGFyZW50IWltcG9ydGFudH0ubWF0LWlucHV0LWVsZW1lbnQ6Oi1tb3otcGxhY2Vob2xkZXJ7Y29sb3I6dHJhbnNwYXJlbnQhaW1wb3J0YW50fS5tYXQtaW5wdXQtZWxlbWVudDo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjp0cmFuc3BhcmVudCFpbXBvcnRhbnR9Lm1hdC1pbnB1dC1lbGVtZW50Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjp0cmFuc3BhcmVudCFpbXBvcnRhbnR9Lm1hdC1pbnB1dC1wbGFjZWhvbGRlci13cmFwcGVye3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVuO3BvaW50ZXItZXZlbnRzOm5vbmV9dGV4dGFyZWEubWF0LWlucHV0LWVsZW1lbnR7b3ZlcmZsb3c6YXV0b30ubWF0LWlucHV0LXBsYWNlaG9sZGVye3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtmb250OmluaGVyaXQ7cG9pbnRlci1ldmVudHM6bm9uZTt3aWR0aDoxMDAlO3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO292ZXJmbG93OmhpZGRlbjt0cmFuc2Zvcm06cGVyc3BlY3RpdmUoMTAwcHgpOy1tcy10cmFuc2Zvcm06bm9uZTt0cmFuc2Zvcm0tb3JpZ2luOjAgMDt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLHdpZHRoIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKTtkaXNwbGF5Om5vbmV9Lm1hdC1mb2N1c2VkIC5tYXQtaW5wdXQtcGxhY2Vob2xkZXIubWF0LWZsb2F0LC5tYXQtaW5wdXQtcGxhY2Vob2xkZXIubWF0LWVtcHR5LC5tYXQtaW5wdXQtcGxhY2Vob2xkZXIubWF0LWZsb2F0Om5vdCgubWF0LWVtcHR5KXtkaXNwbGF5OmJsb2NrfVtkaXI9cnRsXSAubWF0LWlucHV0LXBsYWNlaG9sZGVye3RyYW5zZm9ybS1vcmlnaW46MTAwJSAwO2xlZnQ6YXV0bztyaWdodDowfS5tYXQtaW5wdXQtcGxhY2Vob2xkZXI6bm90KC5tYXQtZW1wdHkpe3RyYW5zaXRpb246bm9uZX0ubWF0LWlucHV0LXVuZGVybGluZXtwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MXB4O3dpZHRoOjEwMCV9Lm1hdC1pbnB1dC11bmRlcmxpbmUubWF0LWRpc2FibGVke2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMCwwLDAsLjI2KSAwLHJnYmEoMCwwLDAsLjI2KSAzMyUsdHJhbnNwYXJlbnQgMCk7YmFja2dyb3VuZC1zaXplOjRweCAxcHg7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7YmFja2dyb3VuZC1wb3NpdGlvbjowO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9Lm1hdC1pbnB1dC11bmRlcmxpbmUgLm1hdC1pbnB1dC1yaXBwbGV7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjJweDt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTt0cmFuc2Zvcm0tb3JpZ2luOjUwJTt0cmFuc2Zvcm06c2NhbGVYKC41KTt2aXNpYmlsaXR5OmhpZGRlbjt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjNzIGN1YmljLWJlemllciguNTUsMCwuNTUsLjIpfS5tYXQtZm9jdXNlZCAubWF0LWlucHV0LXVuZGVybGluZSAubWF0LWlucHV0LXJpcHBsZSwubWF0LWlucHV0LWludmFsaWQgLm1hdC1pbnB1dC11bmRlcmxpbmUgLm1hdC1pbnB1dC1yaXBwbGV7dmlzaWJpbGl0eTp2aXNpYmxlO3RyYW5zZm9ybTpzY2FsZVgoMSk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMTUwbXMgbGluZWFyLGJhY2tncm91bmQtY29sb3IgLjNzIGN1YmljLWJlemllciguNTUsMCwuNTUsLjIpfS5tYXQtaW5wdXQtc3Vic2NyaXB0LXdyYXBwZXJ7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW59Lm1hdC1pbnB1dC1wbGFjZWhvbGRlci13cmFwcGVyIC5tYXQtZGF0ZXBpY2tlci10b2dnbGUsLm1hdC1pbnB1dC1wbGFjZWhvbGRlci13cmFwcGVyIC5tYXQtaWNvbiwubWF0LWlucHV0LXN1YnNjcmlwdC13cmFwcGVyIC5tYXQtZGF0ZXBpY2tlci10b2dnbGUsLm1hdC1pbnB1dC1zdWJzY3JpcHQtd3JhcHBlciAubWF0LWljb257d2lkdGg6MWVtO2hlaWdodDoxZW07Zm9udC1zaXplOmluaGVyaXQ7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9Lm1hdC1pbnB1dC1oaW50LXdyYXBwZXJ7ZGlzcGxheTpmbGV4fS5tYXQtaW5wdXQtaGludC1zcGFjZXJ7ZmxleDoxIDAgMWVtfS5tYXQtaW5wdXQtZXJyb3J7ZGlzcGxheTpibG9ja31cIl0sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCd0cmFuc2l0aW9uTWVzc2FnZXMnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgnZW50ZXInLCBzdHlsZSh7IG9wYWNpdHk6IDEsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMCUpJyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IGVudGVyJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtMTAwJSknIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoJzMwMG1zIGN1YmljLWJlemllcigwLjU1LCAwLCAwLjU1LCAwLjIpJylcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGlnbiBhdHRyaWJ1dGUgdG8gcHJldmVudCBpdCBmcm9tIGludGVyZmVyaW5nIHdpdGggbGF5b3V0LlxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYWxpZ25dJzogJ251bGwnLFxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LWlucHV0LWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWlucHV0LWludmFsaWRdJzogJ19tZElucHV0Q2hpbGQuX2lzRXJyb3JTdGF0ZSgpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZm9jdXNlZF0nOiAnX21kSW5wdXRDaGlsZC5mb2N1c2VkJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy11bnRvdWNoZWRdJzogJ19zaG91bGRGb3J3YXJkKFwidW50b3VjaGVkXCIpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy10b3VjaGVkXSc6ICdfc2hvdWxkRm9yd2FyZChcInRvdWNoZWRcIiknLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXByaXN0aW5lXSc6ICdfc2hvdWxkRm9yd2FyZChcInByaXN0aW5lXCIpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1kaXJ0eV0nOiAnX3Nob3VsZEZvcndhcmQoXCJkaXJ0eVwiKScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubmctdmFsaWRdJzogJ19zaG91bGRGb3J3YXJkKFwidmFsaWRcIiknLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLWludmFsaWRdJzogJ19zaG91bGRGb3J3YXJkKFwiaW52YWxpZFwiKScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubmctcGVuZGluZ10nOiAnX3Nob3VsZEZvcndhcmQoXCJwZW5kaW5nXCIpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhjbGljayknOiAnX2ZvY3VzSW5wdXQoKScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZElucHV0Q29udGFpbmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmLCB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01EX1BMQUNFSE9MREVSX0dMT0JBTF9PUFRJT05TLF0gfSxdIH0sXG5dOyB9O1xuTWRJbnB1dENvbnRhaW5lci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnY29sb3InOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2RpdmlkZXJDb2xvcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaGlkZVJlcXVpcmVkTWFya2VyJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdoaW50TGFiZWwnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2Zsb2F0UGxhY2Vob2xkZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3VuZGVybGluZVJlZic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWyd1bmRlcmxpbmUnLF0gfSxdLFxuICAgICdfbWRJbnB1dENoaWxkJzogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTWRJbnB1dERpcmVjdGl2ZSxdIH0sXSxcbiAgICAnX3BsYWNlaG9sZGVyQ2hpbGQnOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtNZFBsYWNlaG9sZGVyLF0gfSxdLFxuICAgICdfZXJyb3JDaGlsZHJlbic6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kRXJyb3JEaXJlY3RpdmUsXSB9LF0sXG4gICAgJ19oaW50Q2hpbGRyZW4nOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtNZEhpbnQsXSB9LF0sXG4gICAgJ19wcmVmaXhDaGlsZHJlbic6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kUHJlZml4LF0gfSxdLFxuICAgICdfc3VmZml4Q2hpbGRyZW4nOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtNZFN1ZmZpeCxdIH0sXSxcbn07XG4vKipcbiAqIERpcmVjdGl2ZSB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSBhIHRleHRhcmVhIHRvIGZpdCBpdHMgY29udGVudC5cbiAqL1xudmFyIE1kVGV4dGFyZWFBdXRvc2l6ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IGZvcm1Db250cm9sXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRUZXh0YXJlYUF1dG9zaXplKF9lbGVtZW50UmVmLCBmb3JtQ29udHJvbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIGlmIChmb3JtQ29udHJvbCAmJiBmb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMpIHtcbiAgICAgICAgICAgIGZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVzaXplVG9GaXRDb250ZW50KCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLCBcIm1pblJvd3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWluUm93czsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9taW5Sb3dzID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9zZXRNaW5IZWlnaHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUsIFwibWF4Um93c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXhSb3dzOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21heFJvd3MgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3NldE1heEhlaWdodCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZSwgXCJfbWF0QXV0b3NpemVNaW5Sb3dzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWluUm93czsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1pblJvd3MgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZSwgXCJfbWF0QXV0b3NpemVNYXhSb3dzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWF4Um93czsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1heFJvd3MgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtaW5pbXVtIGhlaWdodCBvZiB0aGUgdGV4dGFyZWEgYXMgZGV0ZXJtaW5lZCBieSBtaW5Sb3dzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZS5fc2V0TWluSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtaW5IZWlnaHQgPSB0aGlzLm1pblJvd3MgJiYgdGhpcy5fY2FjaGVkTGluZUhlaWdodCA/XG4gICAgICAgICAgICB0aGlzLm1pblJvd3MgKiB0aGlzLl9jYWNoZWRMaW5lSGVpZ2h0ICsgXCJweFwiIDogbnVsbDtcbiAgICAgICAgaWYgKG1pbkhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VGV4dGFyZWFTdHlsZSgnbWluSGVpZ2h0JywgbWluSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWF4aW11bSBoZWlnaHQgb2YgdGhlIHRleHRhcmVhIGFzIGRldGVybWluZWQgYnkgbWF4Um93cy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUuX3NldE1heEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF4SGVpZ2h0ID0gdGhpcy5tYXhSb3dzICYmIHRoaXMuX2NhY2hlZExpbmVIZWlnaHQgP1xuICAgICAgICAgICAgdGhpcy5tYXhSb3dzICogdGhpcy5fY2FjaGVkTGluZUhlaWdodCArIFwicHhcIiA6IG51bGw7XG4gICAgICAgIGlmIChtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFRleHRhcmVhU3R5bGUoJ21heEhlaWdodCcsIG1heEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlVGV4dGFyZWFMaW5lSGVpZ2h0KCk7XG4gICAgICAgIHRoaXMucmVzaXplVG9GaXRDb250ZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb24gdGhlIHRleHRhcmVhIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUuX3NldFRleHRhcmVhU3R5bGUgPSBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRhcmVhID0gKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRleHRhcmVhLnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FjaGUgdGhlIGhlaWdodCBvZiBhIHNpbmdsZS1yb3cgdGV4dGFyZWEuXG4gICAgICpcbiAgICAgKiBXZSBuZWVkIHRvIGtub3cgaG93IGxhcmdlIGEgc2luZ2xlIFwicm93XCIgb2YgYSB0ZXh0YXJlYSBpcyBpbiBvcmRlciB0byBhcHBseSBtaW5Sb3dzIGFuZFxuICAgICAqIG1heFJvd3MuIEZvciB0aGUgaW5pdGlhbCB2ZXJzaW9uLCB3ZSB3aWxsIGFzc3VtZSB0aGF0IHRoZSBoZWlnaHQgb2YgYSBzaW5nbGUgbGluZSBpbiB0aGVcbiAgICAgKiB0ZXh0YXJlYSBkb2VzIG5vdCBldmVyIGNoYW5nZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUuX2NhY2hlVGV4dGFyZWFMaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0YXJlYSA9ICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAvLyBVc2UgYSBjbG9uZSBlbGVtZW50IGJlY2F1c2Ugd2UgaGF2ZSB0byBvdmVycmlkZSBzb21lIHN0eWxlcy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dGFyZWFDbG9uZSA9ICh0ZXh0YXJlYS5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5yb3dzID0gMTtcbiAgICAgICAgLy8gVXNlIGBwb3NpdGlvbjogYWJzb2x1dGVgIHNvIHRoYXQgdGhpcyBkb2Vzbid0IGNhdXNlIGEgYnJvd3NlciBsYXlvdXQgYW5kIHVzZVxuICAgICAgICAvLyBgdmlzaWJpbGl0eTogaGlkZGVuYCBzbyB0aGF0IG5vdGhpbmcgaXMgcmVuZGVyZWQuIENsZWFyIGFueSBvdGhlciBzdHlsZXMgdGhhdFxuICAgICAgICAvLyB3b3VsZCBhZmZlY3QgdGhlIGhlaWdodC5cbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRleHRhcmVhQ2xvbmUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLm1pbkhlaWdodCA9ICcnO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLm1heEhlaWdodCA9ICcnOyAvKiogQHR5cGUgez99ICovXG4gICAgICAgICgodGV4dGFyZWEucGFyZW50Tm9kZSkpLmFwcGVuZENoaWxkKHRleHRhcmVhQ2xvbmUpO1xuICAgICAgICB0aGlzLl9jYWNoZWRMaW5lSGVpZ2h0ID0gdGV4dGFyZWFDbG9uZS5jbGllbnRIZWlnaHQ7IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgKCh0ZXh0YXJlYS5wYXJlbnROb2RlKSkucmVtb3ZlQ2hpbGQodGV4dGFyZWFDbG9uZSk7XG4gICAgICAgIC8vIE1pbiBhbmQgbWF4IGhlaWdodHMgaGF2ZSB0byBiZSByZS1jYWxjdWxhdGVkIGlmIHRoZSBjYWNoZWQgbGluZSBoZWlnaHQgY2hhbmdlc1xuICAgICAgICB0aGlzLl9zZXRNaW5IZWlnaHQoKTtcbiAgICAgICAgdGhpcy5fc2V0TWF4SGVpZ2h0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIHRleHRhcmVhIHRvIGZpdCBpdHMgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUucmVzaXplVG9GaXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0YXJlYSA9ICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpZiAodGV4dGFyZWEudmFsdWUgPT09IHRoaXMuX3ByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgdGV4dGFyZWEgaGVpZ2h0IHRvIGF1dG8gaW4gb3JkZXIgdG8gc2hyaW5rIGJhY2sgdG8gaXRzIGRlZmF1bHQgc2l6ZS5cbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAvLyBVc2UgdGhlIHNjcm9sbEhlaWdodCB0byBrbm93IGhvdyBsYXJnZSB0aGUgdGV4dGFyZWEgKndvdWxkKiBiZSBpZiBmaXQgaXRzIGVudGlyZSB2YWx1ZS5cbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gdGV4dGFyZWEuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gdGV4dGFyZWEudmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gTWRUZXh0YXJlYUF1dG9zaXplO1xufSgpKTtcbk1kVGV4dGFyZWFBdXRvc2l6ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAndGV4dGFyZWFbbWQtYXV0b3NpemVdLCB0ZXh0YXJlYVttZFRleHRhcmVhQXV0b3NpemVdLCcgK1xuICAgICAgICAgICAgICAgICAgICAndGV4dGFyZWFbbWF0LWF1dG9zaXplXSwgdGV4dGFyZWFbbWF0VGV4dGFyZWFBdXRvc2l6ZV0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRUZXh0YXJlYUF1dG9zaXplJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ3Jlc2l6ZVRvRml0Q29udGVudCgpJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gVGV4dGFyZWEgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBkaXJlY3RpdmUgYXBwbGllZCBzaG91bGQgaGF2ZSBhIHNpbmdsZSByb3cgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnJvd3NlcnMgbm9ybWFsbHkgc2hvdyB0d28gcm93cyBieSBkZWZhdWx0IGFuZCB0aGVyZWZvcmUgdGhpcyBsaW1pdHMgdGhlIG1pblJvd3MgYmluZGluZy5cbiAgICAgICAgICAgICAgICAgICAgJ3Jvd3MnOiAnMScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUZXh0YXJlYUF1dG9zaXplLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBTZWxmIH0sXSB9LFxuXTsgfTtcbk1kVGV4dGFyZWFBdXRvc2l6ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnbWluUm93cyc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kQXV0b3NpemVNaW5Sb3dzJyxdIH0sXSxcbiAgICAnbWF4Um93cyc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kQXV0b3NpemVNYXhSb3dzJyxdIH0sXSxcbiAgICAnX21hdEF1dG9zaXplTWluUm93cyc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21hdEF1dG9zaXplTWF4Um93cycsXSB9LF0sXG4gICAgJ19tYXRBdXRvc2l6ZU1heFJvd3MnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXRBdXRvc2l6ZU1heFJvd3MnLF0gfSxdLFxufTtcbnZhciBNZElucHV0TW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRJbnB1dE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kSW5wdXRNb2R1bGU7XG59KCkpO1xuTWRJbnB1dE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kRXJyb3JEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIE1kSGludCxcbiAgICAgICAgICAgICAgICAgICAgTWRJbnB1dENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgTWRJbnB1dERpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgTWRQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgTWRQcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIE1kU3VmZml4LFxuICAgICAgICAgICAgICAgICAgICBNZFRleHRhcmVhQXV0b3NpemUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFBsYXRmb3JtTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBNZEVycm9yRGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICBNZEhpbnQsXG4gICAgICAgICAgICAgICAgICAgIE1kSW5wdXRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kSW5wdXREaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIE1kUGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBNZFN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICAgTWRUZXh0YXJlYUF1dG9zaXplLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kSW5wdXRNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQ29uZmlndXJhdGlvbiB1c2VkIHdoZW4gb3BlbmluZyBhIHNuYWNrLWJhci5cbiAqL1xudmFyIE1kU25hY2tCYXJDb25maWcgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyQ29uZmlnKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBvbGl0ZW5lc3MgbGV2ZWwgZm9yIHRoZSBNZEFyaWFMaXZlQW5ub3VuY2VyIGFubm91bmNlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9saXRlbmVzcyA9ICdhc3NlcnRpdmUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWVzc2FnZSB0byBiZSBhbm5vdW5jZWQgYnkgdGhlIE1kQXJpYUxpdmVBbm5vdW5jZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5ub3VuY2VtZW50TWVzc2FnZSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxlbmd0aCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhdXRvbWF0aWNhbGx5IGRpc21pc3NpbmcgdGhlIHNuYWNrIGJhci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGV4dCBsYXlvdXQgZGlyZWN0aW9uIGZvciB0aGUgc25hY2sgYmFyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAnbHRyJztcbiAgICB9XG4gICAgcmV0dXJuIE1kU25hY2tCYXJDb25maWc7XG59KCkpO1xuLyoqXG4gKiBSZWZlcmVuY2UgdG8gYSBzbmFjayBiYXIgZGlzcGF0Y2hlZCBmcm9tIHRoZSBzbmFjayBiYXIgc2VydmljZS5cbiAqL1xudmFyIE1kU25hY2tCYXJSZWYgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJJbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7P30gX292ZXJsYXlSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyUmVmKGluc3RhbmNlLCBjb250YWluZXJJbnN0YW5jZSwgX292ZXJsYXlSZWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IF9vdmVybGF5UmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoZSB1c2VyIHRoYXQgdGhlIHNuYWNrIGJhciBoYXMgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoZSB1c2VyIHRoYXQgdGhlIHNuYWNrIGJhciBhY3Rpb24gd2FzIGNhbGxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uQWN0aW9uID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLy8gU2V0cyB0aGUgcmVhZG9ubHkgaW5zdGFuY2Ugb2YgdGhlIHNuYWNrIGJhciBjb250ZW50IGNvbXBvbmVudC5cbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5jb250YWluZXJJbnN0YW5jZSA9IGNvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICAvLyBEaXNtaXNzIHNuYWNrYmFyIG9uIGFjdGlvbi5cbiAgICAgICAgdGhpcy5vbkFjdGlvbigpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kaXNtaXNzKCk7IH0pO1xuICAgICAgICBjb250YWluZXJJbnN0YW5jZS5fb25FeGl0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9maW5pc2hEaXNtaXNzKCk7IH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbmFja0JhclJlZi5wcm90b3R5cGUsIFwiaW5zdGFuY2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgbWFraW5nIHVwIHRoZSBjb250ZW50IG9mIHRoZSBzbmFjayBiYXIuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGlzbWlzc2VzIHRoZSBzbmFjayBiYXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyUmVmLnByb3RvdHlwZS5kaXNtaXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2FmdGVyQ2xvc2VkLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJJbnN0YW5jZS5leGl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2R1cmF0aW9uVGltZW91dElkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc21pc3NlcyB0aGUgc25hY2sgYmFyIGFmdGVyIHNvbWUgZHVyYXRpb25cbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyUmVmLnByb3RvdHlwZS5fZGlzbWlzc0FmdGVyID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kaXNtaXNzKCk7IH0sIGR1cmF0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBzbmFja2JhciBhY3Rpb24gY2xpY2tlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLl9hY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb25BY3Rpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkFjdGlvbi5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkFjdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgc25hY2tiYXIgYXMgb3BlbmVkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyUmVmLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hZnRlck9wZW5lZC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FmdGVyT3BlbmVkLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuX2FmdGVyT3BlbmVkLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCB0aGUgRE9NIGFmdGVyIGNsb3NpbmcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyUmVmLnByb3RvdHlwZS5fZmluaXNoRGlzbWlzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX2FmdGVyQ2xvc2VkLm5leHQoKTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gb2JzZXJ2YWJsZSB0aGF0IGlzIG5vdGlmaWVkIHdoZW4gdGhlIHNuYWNrIGJhciBpcyBmaW5pc2hlZCBjbG9zaW5nLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0JhclJlZi5wcm90b3R5cGUuYWZ0ZXJEaXNtaXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZnRlckNsb3NlZC5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gb2JzZXJ2YWJsZSB0aGF0IGlzIG5vdGlmaWVkIHdoZW4gdGhlIHNuYWNrIGJhciBoYXMgb3BlbmVkIGFuZCBhcHBlYXJlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLmFmdGVyT3BlbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJJbnN0YW5jZS5fb25FbnRlcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBvYnNlcnZhYmxlIHRoYXQgaXMgbm90aWZpZWQgd2hlbiB0aGUgc25hY2sgYmFyIGFjdGlvbiBpcyBjYWxsZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyUmVmLnByb3RvdHlwZS5vbkFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uQWN0aW9uLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kU25hY2tCYXJSZWY7XG59KCkpO1xuLy8gVE9ETyhqZWxib3Vybik6IHdlIGNhbid0IHVzZSBjb25zdGFudHMgZnJvbSBhbmltYXRpb24udHMgaGVyZSBiZWNhdXNlIHlvdSBjYW4ndCB1c2Vcbi8vIGEgdGV4dCBpbnRlcnBvbGF0aW9uIGluIGFueXRoaW5nIHRoYXQgaXMgYW5hbHl6ZWQgc3RhdGljYWxseSB3aXRoIG5nYyAoZm9yIEFvVCBjb21waWxlKS5cbnZhciBTSE9XX0FOSU1BVElPTiA9ICcyMjVtcyBjdWJpYy1iZXppZXIoMC40LDAuMCwxLDEpJztcbnZhciBISURFX0FOSU1BVElPTiA9ICcxOTVtcyBjdWJpYy1iZXppZXIoMC4wLDAuMCwwLjIsMSknO1xuLyoqXG4gKiBJbnRlcm5hbCBjb21wb25lbnQgdGhhdCB3cmFwcyB1c2VyLXByb3ZpZGVkIHNuYWNrIGJhciBjb250ZW50LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFNuYWNrQmFyQ29udGFpbmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRTbmFja0JhckNvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyQ29udGFpbmVyKF9uZ1pvbmUsIF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIF90aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgX3RoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGF0IHRoZSBzbmFjayBiYXIgaGFzIGV4aXRlZCBmcm9tIHZpZXcuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vbkV4aXQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoYXQgdGhlIHNuYWNrIGJhciBoYXMgZmluaXNoZWQgZW50ZXJpbmcgdGhlIHZpZXcuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vbkVudGVyID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdGF0ZSBvZiB0aGUgc25hY2sgYmFyIGFuaW1hdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5hbmltYXRpb25TdGF0ZSA9ICdpbml0aWFsJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSBjb21wb25lbnQgcG9ydGFsIGFzIGNvbnRlbnQgdG8gdGhpcyBzbmFjayBiYXIgY29udGFpbmVyLlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBwb3J0YWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLmF0dGFjaENvbXBvbmVudFBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BvcnRhbEhvc3QuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gYXR0YWNoIHNuYWNrIGJhciBjb250ZW50IGFmdGVyIGNvbnRlbnQgaXMgYWxyZWFkeSBhdHRhY2hlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNuYWNrQmFyQ29uZmlnLmV4dHJhQ2xhc3Nlcykge1xuICAgICAgICAgICAgLy8gTm90IHRoZSBtb3N0IGVmZmljaWVudCB3YXkgb2YgYWRkaW5nIGNsYXNzZXMsIGJ1dCB0aGUgcmVuZGVyZXIgZG9lc24ndCBhbGxvdyB1c1xuICAgICAgICAgICAgLy8gdG8gcGFzcyBpbiBhbiBhcnJheSBvciBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0LlxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc25hY2tCYXJDb25maWcuZXh0cmFDbGFzc2VzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjc3NDbGFzcyA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIGNzc0NsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsSG9zdC5hdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhIHRlbXBsYXRlIHBvcnRhbCBhcyBjb250ZW50IHRvIHRoaXMgc25hY2sgYmFyIGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLmF0dGFjaFRlbXBsYXRlUG9ydGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGVuZCBvZiBhbmltYXRpb25zLCB1cGRhdGluZyB0aGUgc3RhdGUgb2YgdGhlIHNuYWNrYmFyLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLm9uQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50b1N0YXRlID09PSAndm9pZCcgfHwgZXZlbnQudG9TdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGVFeGl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgLy8gTm90ZTogd2Ugc2hvdWxkbid0IHVzZSBgdGhpc2AgaW5zaWRlIHRoZSB6b25lIGNhbGxiYWNrLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBjYW4gY2F1c2UgYSBtZW1vcnkgbGVhay5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9uRW50ZXJfMSA9IHRoaXMub25FbnRlcjtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9uRW50ZXJfMS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgb25FbnRlcl8xLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQmVnaW4gYW5pbWF0aW9uIG9mIHNuYWNrIGJhciBlbnRyYW5jZSBpbnRvIHZpZXcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICd2aXNpYmxlJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSByZXNvbHZpbmcgd2hlbiB0aGUgZW50ZXIgYW5pbWF0aW9uIGNvbXBsZXRlcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLl9vbkVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gJ3Zpc2libGUnO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkVudGVyLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmVnaW4gYW5pbWF0aW9uIG9mIHRoZSBzbmFjayBiYXIgZXhpdGluZyBmcm9tIHZpZXcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5leGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gJ2NvbXBsZXRlJztcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRXhpdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgY29tcGxldGVzIGFmdGVyIHRoZSBjbG9zaW5nIGFuaW1hdGlvbiBpcyBkb25lLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0JhckNvbnRhaW5lci5wcm90b3R5cGUuX29uRXhpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25FeGl0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFrZXMgc3VyZSB0aGUgZXhpdCBjYWxsYmFja3MgaGF2ZSBiZWVuIGludm9rZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBkZXN0cm95ZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGVFeGl0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIHpvbmUgdG8gc2V0dGxlIGJlZm9yZSByZW1vdmluZyB0aGUgZWxlbWVudC4gSGVscHMgcHJldmVudFxuICAgICAqIGVycm9ycyB3aGVyZSB3ZSBlbmQgdXAgcmVtb3ZpbmcgYW4gZWxlbWVudCB3aGljaCBpcyBpbiB0aGUgbWlkZGxlIG9mIGFuIGFuaW1hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLl9jb21wbGV0ZUV4aXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5vdGU6IHdlIHNob3VsZG4ndCB1c2UgYHRoaXNgIGluc2lkZSB0aGUgem9uZSBjYWxsYmFjayxcbiAgICAgICAgLy8gYmVjYXVzZSBpdCBjYW4gY2F1c2UgYSBtZW1vcnkgbGVhay5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb25FeGl0ID0gdGhpcy5vbkV4aXQ7XG4gICAgICAgIGZpcnN0LmNhbGwodGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvbkV4aXQubmV4dCgpO1xuICAgICAgICAgICAgb25FeGl0LmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1kU25hY2tCYXJDb250YWluZXI7XG59KEJhc2VQb3J0YWxIb3N0KSk7XG5NZFNuYWNrQmFyQ29udGFpbmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnc25hY2stYmFyLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLXRlbXBsYXRlIGNka1BvcnRhbEhvc3Q+PC9uZy10ZW1wbGF0ZT5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2JveC1zaGFkb3c6MCAzcHggNXB4IC0xcHggcmdiYSgwLDAsMCwuMiksMCA2cHggMTBweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCAxOHB4IDAgcmdiYSgwLDAsMCwuMTIpO2JhY2tncm91bmQ6IzMyMzIzMjtib3JkZXItcmFkaXVzOjJweDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWF4LXdpZHRoOjU2OHB4O21pbi13aWR0aDoyODhweDtwYWRkaW5nOjE0cHggMjRweDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxMDAlKX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXs6aG9zdHtib3JkZXI6c29saWQgMXB4fX1cIl0sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdhbGVydCcsXG4gICAgICAgICAgICAgICAgICAgICdbQHN0YXRlXSc6ICdhbmltYXRpb25TdGF0ZScsXG4gICAgICAgICAgICAgICAgICAgICcoQHN0YXRlLmRvbmUpJzogJ29uQW5pbWF0aW9uRW5kKCRldmVudCknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ3N0YXRlJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2luaXRpYWwnLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMTAwJSknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCd2aXNpYmxlJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDAlKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2NvbXBsZXRlJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDEwMCUpJyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCd2aXNpYmxlID0+IGNvbXBsZXRlJywgYW5pbWF0ZShISURFX0FOSU1BVElPTikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignaW5pdGlhbCA9PiB2aXNpYmxlLCB2b2lkID0+IHZpc2libGUnLCBhbmltYXRlKFNIT1dfQU5JTUFUSU9OKSksXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRTbmFja0JhckNvbnRhaW5lci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG5dOyB9O1xuTWRTbmFja0JhckNvbnRhaW5lci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX3BvcnRhbEhvc3QnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtQb3J0YWxIb3N0RGlyZWN0aXZlLF0gfSxdLFxufTtcbi8qKlxuICogQSBjb21wb25lbnQgdXNlZCB0byBvcGVuIGFzIHRoZSBkZWZhdWx0IHNuYWNrIGJhciwgbWF0Y2hpbmcgbWF0ZXJpYWwgc3BlYy5cbiAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBzbmFjayBiYXIgc2VydmljZS5cbiAqL1xudmFyIFNpbXBsZVNuYWNrQmFyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2ltcGxlU25hY2tCYXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc21pc3NlcyB0aGUgc25hY2sgYmFyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlU25hY2tCYXIucHJvdG90eXBlLmRpc21pc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc25hY2tCYXJSZWYuX2FjdGlvbigpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVNuYWNrQmFyLnByb3RvdHlwZSwgXCJoYXNBY3Rpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGFjdGlvbiBidXR0b24gc2hvdWxkIGJlIHNob3duLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmFjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFNpbXBsZVNuYWNrQmFyO1xufSgpKTtcblNpbXBsZVNuYWNrQmFyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnc2ltcGxlLXNuYWNrLWJhcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwie3ttZXNzYWdlfX0gPGJ1dHRvbiBjbGFzcz1cXFwibWF0LXNpbXBsZS1zbmFja2Jhci1hY3Rpb25cXFwiICpuZ0lmPVxcXCJoYXNBY3Rpb25cXFwiIChjbGljayk9XFxcImRpc21pc3MoKVxcXCI+e3thY3Rpb259fTwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1zaW1wbGUtc25hY2tiYXJ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2NvbG9yOiNmZmY7bGluZS1oZWlnaHQ6MjBweH0ubWF0LXNpbXBsZS1zbmFja2Jhci1hY3Rpb257LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2N1cnNvcjpwb2ludGVyO291dGxpbmU6MDtib3JkZXI6bm9uZTstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6dHJhbnNwYXJlbnQ7YmFja2dyb3VuZDowIDA7Y29sb3I6aW5oZXJpdDtmbGV4LXNocmluazowO21hcmdpbi1sZWZ0OjQ4cHh9W2Rpcj1ydGxdIC5tYXQtc2ltcGxlLXNuYWNrYmFyLWFjdGlvbnttYXJnaW4tcmlnaHQ6NDhweDttYXJnaW4tbGVmdDowfVwiXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1zaW1wbGUtc25hY2tiYXInLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU2ltcGxlU25hY2tCYXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRXh0ZW5kcyBhbiBvYmplY3Qgd2l0aCB0aGUgKmVudW1lcmFibGUqIGFuZCAqb3duKiBwcm9wZXJ0aWVzIG9mIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzLFxuICogc2ltaWxhciB0byBPYmplY3QuYXNzaWduLlxuICpcbiAqIEBwYXJhbSB7P30gZGVzdCBUaGUgb2JqZWN0IHdoaWNoIHdpbGwgaGF2ZSBwcm9wZXJ0aWVzIGNvcGllZCB0byBpdC5cbiAqIEBwYXJhbSB7Li4uP30gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMgZnJvbSB3aGljaCBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkLlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kT2JqZWN0KGRlc3QpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChkZXN0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2EgPSAwLCBzb3VyY2VzXzEgPSBzb3VyY2VzOyBfYSA8IHNvdXJjZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNfMVtfYV07XG4gICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cbi8qKlxuICogU2VydmljZSB0byBkaXNwYXRjaCBNYXRlcmlhbCBEZXNpZ24gc25hY2sgYmFyIG1lc3NhZ2VzLlxuICovXG52YXIgTWRTbmFja0JhciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX292ZXJsYXlcbiAgICAgKiBAcGFyYW0gez99IF9saXZlXG4gICAgICogQHBhcmFtIHs/fSBfcGFyZW50U25hY2tCYXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyKF9vdmVybGF5LCBfbGl2ZSwgX3BhcmVudFNuYWNrQmFyKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fbGl2ZSA9IF9saXZlO1xuICAgICAgICB0aGlzLl9wYXJlbnRTbmFja0JhciA9IF9wYXJlbnRTbmFja0JhcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBzbmFjayBiYXIgaW4gdGhlIHZpZXcgKmF0IHRoaXMgbGV2ZWwqIChpbiB0aGUgQW5ndWxhciBpbmplY3RvciB0cmVlKS5cbiAgICAgICAgICogSWYgdGhlcmUgaXMgYSBwYXJlbnQgc25hY2stYmFyIHNlcnZpY2UsIGFsbCBvcGVyYXRpb25zIHNob3VsZCBkZWxlZ2F0ZSB0byB0aGF0IHBhcmVudFxuICAgICAgICAgKiB2aWEgYF9vcGVuZWRTbmFja0JhclJlZmAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zbmFja0JhclJlZkF0VGhpc0xldmVsID0gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU25hY2tCYXIucHJvdG90eXBlLCBcIl9vcGVuZWRTbmFja0JhclJlZlwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBvcGVuZWQgc25hY2tiYXIgYXQgKmFueSogbGV2ZWwuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudCA9IHRoaXMuX3BhcmVudFNuYWNrQmFyO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5fb3BlbmVkU25hY2tCYXJSZWYgOiB0aGlzLl9zbmFja0JhclJlZkF0VGhpc0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnRTbmFja0Jhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudFNuYWNrQmFyLl9vcGVuZWRTbmFja0JhclJlZiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc25hY2tCYXJSZWZBdFRoaXNMZXZlbCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBkaXNwYXRjaGVzIGEgc25hY2sgYmFyIHdpdGggYSBjdXN0b20gY29tcG9uZW50IGZvciB0aGUgY29udGVudCwgcmVtb3ZpbmcgYW55XG4gICAgICogY3VycmVudGx5IG9wZW5lZCBzbmFjayBiYXJzLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudCBDb21wb25lbnQgdG8gYmUgaW5zdGFudGlhdGVkLlxuICAgICAqIEBwYXJhbSB7Pz19IGNvbmZpZyBFeHRyYSBjb25maWd1cmF0aW9uIGZvciB0aGUgc25hY2sgYmFyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0Jhci5wcm90b3R5cGUub3BlbkZyb21Db21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uZmlnID0gX2FwcGx5Q29uZmlnRGVmYXVsdHMoY29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3ZlcmxheVJlZiA9IHRoaXMuX2NyZWF0ZU92ZXJsYXkoY29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc25hY2tCYXJDb250YWluZXIgPSB0aGlzLl9hdHRhY2hTbmFja0JhckNvbnRhaW5lcihvdmVybGF5UmVmLCBjb25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzbmFja0JhclJlZiA9IHRoaXMuX2F0dGFjaFNuYWNrYmFyQ29udGVudChjb21wb25lbnQsIHNuYWNrQmFyQ29udGFpbmVyLCBvdmVybGF5UmVmKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgc25hY2tiYXIgaXMgZGlzbWlzc2VkLCBjbGVhciB0aGUgcmVmZXJlbmNlIHRvIGl0LlxuICAgICAgICBzbmFja0JhclJlZi5hZnRlckRpc21pc3NlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgc25hY2tiYXIgcmVmIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcmVwbGFjZWQgYnkgYSBuZXdlciBzbmFja2Jhci5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYgPT0gc25hY2tCYXJSZWYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgYSBzbmFjayBiYXIgaXMgYWxyZWFkeSBpbiB2aWV3LCBkaXNtaXNzIGl0IGFuZCBlbnRlciB0aGUgbmV3IHNuYWNrIGJhciBhZnRlciBleGl0XG4gICAgICAgIC8vIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgICAgaWYgKHRoaXMuX29wZW5lZFNuYWNrQmFyUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuZWRTbmFja0JhclJlZi5hZnRlckRpc21pc3NlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc25hY2tCYXJSZWYuY29udGFpbmVySW5zdGFuY2UuZW50ZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYuZGlzbWlzcygpO1xuICAgICAgICAgICAgLy8gSWYgbm8gc25hY2sgYmFyIGlzIGluIHZpZXcsIGVudGVyIHRoZSBuZXcgc25hY2sgYmFyLlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc25hY2tCYXJSZWYuY29udGFpbmVySW5zdGFuY2UuZW50ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIGRpc21pc3MgdGltZW91dCBpcyBwcm92aWRlZCwgc2V0IHVwIGRpc21pc3MgYmFzZWQgb24gYWZ0ZXIgdGhlIHNuYWNrYmFyIGlzIG9wZW5lZC5cbiAgICAgICAgaWYgKGNvbmZpZy5kdXJhdGlvbiAmJiBjb25maWcuZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICBzbmFja0JhclJlZi5hZnRlck9wZW5lZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc25hY2tCYXJSZWYuX2Rpc21pc3NBZnRlcigvKiogQHR5cGUgez99ICovICgoKChjb25maWcpKS5kdXJhdGlvbikpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuYW5ub3VuY2VtZW50TWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5fbGl2ZS5hbm5vdW5jZShjb25maWcuYW5ub3VuY2VtZW50TWVzc2FnZSwgY29uZmlnLnBvbGl0ZW5lc3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5lZFNuYWNrQmFyUmVmID0gc25hY2tCYXJSZWY7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuZWRTbmFja0JhclJlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgc25hY2tiYXIgd2l0aCBhIG1lc3NhZ2UgYW5kIGFuIG9wdGlvbmFsIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gc2hvdyBpbiB0aGUgc25hY2tiYXIuXG4gICAgICogQHBhcmFtIHs/PX0gYWN0aW9uIFRoZSBsYWJlbCBmb3IgdGhlIHNuYWNrYmFyIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gez89fSBjb25maWcgQWRkaXRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBzbmFja2Jhci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAobWVzc2FnZSwgYWN0aW9uLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gdm9pZCAwKSB7IGFjdGlvbiA9ICcnOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIF9jb25maWcgPSBfYXBwbHlDb25maWdEZWZhdWx0cyhjb25maWcpO1xuICAgICAgICBfY29uZmlnLmFubm91bmNlbWVudE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaW1wbGVTbmFja0JhclJlZiA9IHRoaXMub3BlbkZyb21Db21wb25lbnQoU2ltcGxlU25hY2tCYXIsIF9jb25maWcpO1xuICAgICAgICBzaW1wbGVTbmFja0JhclJlZi5pbnN0YW5jZS5zbmFja0JhclJlZiA9IHNpbXBsZVNuYWNrQmFyUmVmO1xuICAgICAgICBzaW1wbGVTbmFja0JhclJlZi5pbnN0YW5jZS5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgc2ltcGxlU25hY2tCYXJSZWYuaW5zdGFuY2UuYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICByZXR1cm4gc2ltcGxlU25hY2tCYXJSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNtaXNzZXMgdGhlIGN1cnJlbnRseS12aXNpYmxlIHNuYWNrIGJhci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLmRpc21pc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcGVuZWRTbmFja0JhclJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYuZGlzbWlzcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgc25hY2sgYmFyIGNvbnRhaW5lciBjb21wb25lbnQgdG8gdGhlIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5UmVmXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLl9hdHRhY2hTbmFja0JhckNvbnRhaW5lciA9IGZ1bmN0aW9uIChvdmVybGF5UmVmLCBjb25maWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbmVyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChNZFNuYWNrQmFyQ29udGFpbmVyLCBjb25maWcudmlld0NvbnRhaW5lclJlZik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lclJlZiA9IG92ZXJsYXlSZWYuYXR0YWNoKGNvbnRhaW5lclBvcnRhbCk7XG4gICAgICAgIGNvbnRhaW5lclJlZi5pbnN0YW5jZS5zbmFja0JhckNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gVGhlIHNuYWNrYmFyIGFuaW1hdGlvbiBuZWVkcyB0aGUgY29udGVudCB0byBiZSByZXNvbHZlZCBpbiBvcmRlciB0byB0cmFuc2Zvcm0gdGhlIGJhclxuICAgICAgICAvLyBvdXQgb2YgdGhlIHZpZXcgaW5pdGlhbGx5IChzbyBpdCBjYW4gc2xpZGUgaW4pLiBUbyBtYWtlIHRoZSBjb250ZW50IHJlc29sdmUsIHdlIG1hbnVhbGx5XG4gICAgICAgIC8vIGRldGVjdCBjaGFuZ2VzLlxuICAgICAgICBjb250YWluZXJSZWYuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyUmVmLmluc3RhbmNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGxhY2VzIGEgbmV3IGNvbXBvbmVudCBhcyB0aGUgY29udGVudCBvZiB0aGUgc25hY2sgYmFyIGNvbnRhaW5lci5cbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlSZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLl9hdHRhY2hTbmFja2JhckNvbnRlbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBjb250YWluZXIsIG92ZXJsYXlSZWYpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChjb21wb25lbnQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50UmVmID0gY29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgICAgICByZXR1cm4gbmV3IE1kU25hY2tCYXJSZWYoY29udGVudFJlZi5pbnN0YW5jZSwgY29udGFpbmVyLCBvdmVybGF5UmVmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb3ZlcmxheSBhbmQgcGxhY2VzIGl0IGluIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gY29uZmlnIFRoZSB1c2VyLXNwZWNpZmllZCBzbmFjayBiYXIgY29uZmlnLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTbmFja0Jhci5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXkgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlJCQxID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICBzdGF0ZSQkMS5kaXJlY3Rpb24gPSBjb25maWcuZGlyZWN0aW9uO1xuICAgICAgICBzdGF0ZSQkMS5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpLmdsb2JhbCgpLmNlbnRlckhvcml6b250YWxseSgpLmJvdHRvbSgnMCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5jcmVhdGUoc3RhdGUkJDEpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kU25hY2tCYXI7XG59KCkpO1xuTWRTbmFja0Jhci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRTbmFja0Jhci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE92ZXJsYXksIH0sXG4gICAgeyB0eXBlOiBMaXZlQW5ub3VuY2VyLCB9LFxuICAgIHsgdHlwZTogTWRTbmFja0JhciwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBTa2lwU2VsZiB9LF0gfSxcbl07IH07XG4vKipcbiAqIEFwcGxpZXMgZGVmYXVsdCBvcHRpb25zIHRvIHRoZSBzbmFja2JhciBjb25maWcuXG4gKiBAcGFyYW0gez89fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gd2hpY2ggdGhlIGRlZmF1bHRzIHdpbGwgYmUgYXBwbGllZC5cbiAqIEByZXR1cm4gez99IFRoZSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBkZWZhdWx0cyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBfYXBwbHlDb25maWdEZWZhdWx0cyhjb25maWcpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JqZWN0KG5ldyBNZFNuYWNrQmFyQ29uZmlnKCksIGNvbmZpZyk7XG59XG52YXIgTWRTbmFja0Jhck1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNuYWNrQmFyTW9kdWxlO1xufSgpKTtcbk1kU25hY2tCYXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgUG9ydGFsTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kU25hY2tCYXJDb250YWluZXIsIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNuYWNrQmFyQ29udGFpbmVyLCBTaW1wbGVTbmFja0Jhcl0sXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTWRTbmFja0JhckNvbnRhaW5lciwgU2ltcGxlU25hY2tCYXJdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01kU25hY2tCYXIsIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFNuYWNrQmFyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE3ODQ5XG4gKi9cbnZhciBfTWRUYWJMYWJlbEJhc2VDbGFzcyA9IFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlO1xuLyoqXG4gKiBVc2VkIHRvIGZsYWcgdGFiIGxhYmVscyBmb3IgdXNlIHdpdGggdGhlIHBvcnRhbCBkaXJlY3RpdmVcbiAqL1xudmFyIE1kVGFiTGFiZWwgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFRhYkxhYmVsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVSZWZcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDb250YWluZXJSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFRhYkxhYmVsKHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZikgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1kVGFiTGFiZWw7XG59KF9NZFRhYkxhYmVsQmFzZUNsYXNzKSk7XG5NZFRhYkxhYmVsLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtdGFiLWxhYmVsXSwgW21hdC10YWItbGFiZWxdLCBbbWRUYWJMYWJlbF0sIFttYXRUYWJMYWJlbF0nLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFRhYkxhYmVsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIH0sXG4gICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuXTsgfTtcbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFRhYkJhc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRhYkJhc2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFRhYkJhc2U7XG59KCkpO1xudmFyIF9NZFRhYk1peGluQmFzZSA9IG1peGluRGlzYWJsZWQoTWRUYWJCYXNlKTtcbnZhciBNZFRhYiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kVGFiLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdDb250YWluZXJSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFRhYihfdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBsYWluIHRleHQgbGFiZWwgZm9yIHRoZSB0YWIsIHVzZWQgd2hlbiB0aGVyZSBpcyBubyB0ZW1wbGF0ZSBsYWJlbC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRleHRMYWJlbCA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBvcnRhbCB0aGF0IHdpbGwgYmUgdGhlIGhvc3RlZCBjb250ZW50IG9mIHRoZSB0YWJcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9jb250ZW50UG9ydGFsID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWxhdGl2ZWx5IGluZGV4ZWQgcG9zaXRpb24gd2hlcmUgMCByZXByZXNlbnRzIHRoZSBjZW50ZXIsIG5lZ2F0aXZlIGlzIGxlZnQsIGFuZCBwb3NpdGl2ZVxuICAgICAgICAgKiByZXByZXNlbnRzIHRoZSByaWdodC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbml0aWFsIHJlbGF0aXZlbHkgaW5kZXggb3JpZ2luIG9mIHRoZSB0YWIgaWYgaXQgd2FzIGNyZWF0ZWQgYW5kIHNlbGVjdGVkIGFmdGVyIHRoZXJlXG4gICAgICAgICAqIHdhcyBhbHJlYWR5IGEgc2VsZWN0ZWQgdGFiLiBQcm92aWRlcyBjb250ZXh0IG9mIHdoYXQgcG9zaXRpb24gdGhlIHRhYiBzaG91bGQgb3JpZ2luYXRlIGZyb20uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vcmlnaW4gPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYi5wcm90b3R5cGUsIFwiY29udGVudFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250ZW50UG9ydGFsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29udGVudFBvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0aGlzLl9jb250ZW50LCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9O1xuICAgIHJldHVybiBNZFRhYjtcbn0oX01kVGFiTWl4aW5CYXNlKSk7XG5NZFRhYi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLXRhYiwgbWF0LXRhYicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLXRlbXBsYXRlPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L25nLXRlbXBsYXRlPlwiLFxuICAgICAgICAgICAgICAgIGlucHV0czogWydkaXNhYmxlZCddXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVGFiLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbl07IH07XG5NZFRhYi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAndGVtcGxhdGVMYWJlbCc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW01kVGFiTGFiZWwsXSB9LF0sXG4gICAgJ19jb250ZW50JzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbVGVtcGxhdGVSZWYsXSB9LF0sXG4gICAgJ3RleHRMYWJlbCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2xhYmVsJyxdIH0sXSxcbn07XG4vKipcbiAqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEJ3MgZm9yIGVhY2ggdGFiIGNvbXBvbmVudFxuICovXG52YXIgbmV4dElkJDIgPSAwO1xuLyoqXG4gKiBBIHNpbXBsZSBjaGFuZ2UgZXZlbnQgZW1pdHRlZCBvbiBmb2N1cyBvciBzZWxlY3Rpb24gY2hhbmdlcy5cbiAqL1xudmFyIE1kVGFiQ2hhbmdlRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRhYkNoYW5nZUV2ZW50KCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRUYWJDaGFuZ2VFdmVudDtcbn0oKSk7XG4vKipcbiAqIE1hdGVyaWFsIGRlc2lnbiB0YWItZ3JvdXAgY29tcG9uZW50LiAgU3VwcG9ydHMgYmFzaWMgdGFiIHBhaXJzIChsYWJlbCArIGNvbnRlbnQpIGFuZCBpbmNsdWRlc1xuICogYW5pbWF0ZWQgaW5rLWJhciwga2V5Ym9hcmQgbmF2aWdhdGlvbiwgYW5kIHNjcmVlbiByZWFkZXIuXG4gKiBTZWU6IGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvY29tcG9uZW50cy90YWJzLmh0bWxcbiAqL1xudmFyIE1kVGFiR3JvdXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kVGFiR3JvdXAoX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0YWIgaW5kZXggdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQgYWZ0ZXIgdGhlIGNvbnRlbnQgaGFzIGJlZW4gY2hlY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZGV4VG9TZWxlY3QgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogU25hcHNob3Qgb2YgdGhlIGhlaWdodCBvZiB0aGUgdGFiIGJvZHkgd3JhcHBlciBiZWZvcmUgYW5vdGhlciB0YWIgaXMgYWN0aXZhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGFiQm9keVdyYXBwZXJIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9keW5hbWljSGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3NpdGlvbiBvZiB0aGUgdGFiIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVhZGVyUG9zaXRpb24gPSAnYWJvdmUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIGZvY3VzIGhhcyBjaGFuZ2VkIHdpdGhpbiBhIHRhYiBncm91cC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHRhYiBzZWxlY3Rpb24gaGFzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2dyb3VwSWQgPSBuZXh0SWQkMisrO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiZHluYW1pY0hlaWdodFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB0YWIgZ3JvdXAgc2hvdWxkIGdyb3cgdG8gdGhlIHNpemUgb2YgdGhlIGFjdGl2ZSB0YWIuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2R5bmFtaWNIZWlnaHQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9keW5hbWljSGVpZ2h0ID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiR3JvdXAucHJvdG90eXBlLCBcIl9keW5hbWljSGVpZ2h0RGVwcmVjYXRlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9keW5hbWljSGVpZ2h0OyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZHluYW1pY0hlaWdodCA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiZGlzYWJsZVJpcHBsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHJpcHBsZXMgZm9yIHRoZSB0YWItZ3JvdXAgc2hvdWxkIGJlIGRpc2FibGVkIG9yIG5vdC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zZWxlY3RlZEluZGV4OyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBhY3RpdmUgdGFiLlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9pbmRleFRvU2VsZWN0ID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4Q2hhbmdlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE91dHB1dCB0byBlbmFibGUgc3VwcG9ydCBmb3IgdHdvLXdheSBiaW5kaW5nIG9uIGBbKHNlbGVjdGVkSW5kZXgpXWBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcC5jYWxsKHRoaXMuc2VsZWN0Q2hhbmdlLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LmluZGV4OyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgdGhlIGNvbnRlbnQgaXMgY2hlY2tlZCwgdGhpcyBjb21wb25lbnQga25vd3Mgd2hhdCB0YWJzIGhhdmUgYmVlbiBkZWZpbmVkXG4gICAgICogYW5kIHdoYXQgdGhlIHNlbGVjdGVkIGluZGV4IHNob3VsZCBiZS4gVGhpcyBpcyB3aGVyZSB3ZSBjYW4ga25vdyBleGFjdGx5IHdoYXQgcG9zaXRpb25cbiAgICAgKiBlYWNoIHRhYiBzaG91bGQgYmUgaW4gYWNjb3JkaW5nIHRvIHRoZSBuZXcgc2VsZWN0ZWQgaW5kZXgsIGFuZCBhZGRpdGlvbmFsbHkgd2Uga25vdyBob3dcbiAgICAgKiBhIG5ldyBzZWxlY3RlZCB0YWIgc2hvdWxkIHRyYW5zaXRpb24gaW4gKGZyb20gdGhlIGxlZnQgb3IgcmlnaHQpLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBDbGFtcCB0aGUgbmV4dCBzZWxlY3RlZCBpbmRleCB0byB0aGUgYm91bmRzIG9mIDAgYW5kIHRoZSB0YWJzIGxlbmd0aC4gTm90ZSB0aGUgYHx8IDBgLCB3aGljaFxuICAgICAgICAvLyBlbnN1cmVzIHRoYXQgdmFsdWVzIGxpa2UgTmFOIGNhbid0IGdldCB0aHJvdWdoIGFuZCB3aGljaCB3b3VsZCBvdGhlcndpc2UgdGhyb3cgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudCBpbnRvIGFuIGluZmluaXRlIGxvb3AgKHNpbmNlIE1hdGgubWF4KE5hTiwgMCkgPT09IE5hTikuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4VG9TZWxlY3QgPSB0aGlzLl9pbmRleFRvU2VsZWN0ID1cbiAgICAgICAgICAgIE1hdGgubWluKHRoaXMuX3RhYnMubGVuZ3RoIC0gMSwgTWF0aC5tYXgodGhpcy5faW5kZXhUb1NlbGVjdCB8fCAwLCAwKSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgY2hhbmdlIGluIHNlbGVjdGVkIGluZGV4LCBlbWl0IGEgY2hhbmdlIGV2ZW50LiBTaG91bGQgbm90IHRyaWdnZXIgaWZcbiAgICAgICAgLy8gdGhlIHNlbGVjdGVkIGluZGV4IGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZEluZGV4ICE9IGluZGV4VG9TZWxlY3QgJiYgdGhpcy5fc2VsZWN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdENoYW5nZS5lbWl0KHRoaXMuX2NyZWF0ZUNoYW5nZUV2ZW50KGluZGV4VG9TZWxlY3QpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXR1cCB0aGUgcG9zaXRpb24gZm9yIGVhY2ggdGFiIGFuZCBvcHRpb25hbGx5IHNldHVwIGFuIG9yaWdpbiBvbiB0aGUgbmV4dCBzZWxlY3RlZCB0YWIuXG4gICAgICAgIHRoaXMuX3RhYnMuZm9yRWFjaChmdW5jdGlvbiAodGFiLCBpbmRleCkge1xuICAgICAgICAgICAgdGFiLnBvc2l0aW9uID0gaW5kZXggLSBpbmRleFRvU2VsZWN0O1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIHNlbGVjdGVkIHRhYiwgdGhlbiBzZXQgdXAgYW4gb3JpZ2luIGZvciB0aGUgbmV4dCBzZWxlY3RlZCB0YWJcbiAgICAgICAgICAgIC8vIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmUgYWxyZWFkeS5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZWN0ZWRJbmRleCAhPSBudWxsICYmIHRhYi5wb3NpdGlvbiA9PSAwICYmICF0YWIub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgdGFiLm9yaWdpbiA9IGluZGV4VG9TZWxlY3QgLSBfdGhpcy5fc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSBpbmRleFRvU2VsZWN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2FpdHMgb25lIGZyYW1lIGZvciB0aGUgdmlldyB0byB1cGRhdGUsIHRoZW4gdXBkYXRlcyB0aGUgaW5rIGJhclxuICAgICAqIE5vdGU6IFRoaXMgbXVzdCBiZSBydW4gb3V0c2lkZSBvZiB0aGUgem9uZSBvciBpdCB3aWxsIGNyZWF0ZSBhbiBpbmZpbml0ZSBjaGFuZ2UgZGV0ZWN0aW9uIGxvb3AuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX2ZvY3VzQ2hhbmdlZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLmZvY3VzQ2hhbmdlLmVtaXQodGhpcy5fY3JlYXRlQ2hhbmdlRXZlbnQoaW5kZXgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9jcmVhdGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudCA9IG5ldyBNZFRhYkNoYW5nZUV2ZW50O1xuICAgICAgICBldmVudC5pbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAodGhpcy5fdGFicyAmJiB0aGlzLl90YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgZXZlbnQudGFiID0gdGhpcy5fdGFicy50b0FycmF5KClbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGxhYmVsIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9nZXRUYWJMYWJlbElkID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIFwibWQtdGFiLWxhYmVsLVwiICsgdGhpcy5fZ3JvdXBJZCArIFwiLVwiICsgaTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGNvbnRlbnQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gaVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX2dldFRhYkNvbnRlbnRJZCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBcIm1kLXRhYi1jb250ZW50LVwiICsgdGhpcy5fZ3JvdXBJZCArIFwiLVwiICsgaTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgYm9keSB3cmFwcGVyIHRvIHRoZSBoZWlnaHQgb2YgdGhlIGFjdGl2YXRpbmcgdGFiIGlmIGR5bmFtaWNcbiAgICAgKiBoZWlnaHQgcHJvcGVydHkgaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0gez99IHRhYkhlaWdodFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX3NldFRhYkJvZHlXcmFwcGVySGVpZ2h0ID0gZnVuY3Rpb24gKHRhYkhlaWdodCkge1xuICAgICAgICBpZiAoIXRoaXMuX2R5bmFtaWNIZWlnaHQgfHwgIXRoaXMuX3RhYkJvZHlXcmFwcGVySGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fdGFiQm9keVdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIHRoaXMuX3RhYkJvZHlXcmFwcGVySGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgIC8vIFRoaXMgY29uZGl0aW9uYWwgZm9yY2VzIHRoZSBicm93c2VyIHRvIHBhaW50IHRoZSBoZWlnaHQgc28gdGhhdFxuICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIHRvIHRoZSBuZXcgaGVpZ2h0IGNhbiBoYXZlIGFuIG9yaWdpbi5cbiAgICAgICAgaWYgKHRoaXMuX3RhYkJvZHlXcmFwcGVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl90YWJCb2R5V3JhcHBlci5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgdGFiSGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGhlaWdodCBvZiB0aGUgdGFiIGJvZHkgd3JhcHBlci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9yZW1vdmVUYWJCb2R5V3JhcHBlckhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFiQm9keVdyYXBwZXJIZWlnaHQgPSB0aGlzLl90YWJCb2R5V3JhcHBlci5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fdGFiQm9keVdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsICcnKTtcbiAgICB9O1xuICAgIHJldHVybiBNZFRhYkdyb3VwO1xufSgpKTtcbk1kVGFiR3JvdXAuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC10YWItZ3JvdXAsIG1hdC10YWItZ3JvdXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxtZC10YWItaGVhZGVyICN0YWJIZWFkZXIgW3NlbGVjdGVkSW5kZXhdPVxcXCJzZWxlY3RlZEluZGV4XFxcIiBbZGlzYWJsZVJpcHBsZV09XFxcImRpc2FibGVSaXBwbGVcXFwiIChpbmRleEZvY3VzZWQpPVxcXCJfZm9jdXNDaGFuZ2VkKCRldmVudClcXFwiIChzZWxlY3RGb2N1c2VkSW5kZXgpPVxcXCJzZWxlY3RlZEluZGV4ID0gJGV2ZW50XFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWxhYmVsXFxcIiByb2xlPVxcXCJ0YWJcXFwiIG1kLXRhYi1sYWJlbC13cmFwcGVyIG1kLXJpcHBsZSAqbmdGb3I9XFxcImxldCB0YWIgb2YgX3RhYnM7IGxldCBpID0gaW5kZXhcXFwiIFtpZF09XFxcIl9nZXRUYWJMYWJlbElkKGkpXFxcIiBbdGFiSW5kZXhdPVxcXCJzZWxlY3RlZEluZGV4ID09IGkgPyAwIDogLTFcXFwiIFthdHRyLmFyaWEtY29udHJvbHNdPVxcXCJfZ2V0VGFiQ29udGVudElkKGkpXFxcIiBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cXFwic2VsZWN0ZWRJbmRleCA9PSBpXFxcIiBbY2xhc3MubWF0LXRhYi1sYWJlbC1hY3RpdmVdPVxcXCJzZWxlY3RlZEluZGV4ID09IGlcXFwiIFtkaXNhYmxlZF09XFxcInRhYi5kaXNhYmxlZFxcXCIgW21kUmlwcGxlRGlzYWJsZWRdPVxcXCJkaXNhYmxlUmlwcGxlXFxcIiAoY2xpY2spPVxcXCJ0YWJIZWFkZXIuZm9jdXNJbmRleCA9IHNlbGVjdGVkSW5kZXggPSBpXFxcIj48bmctdGVtcGxhdGUgW25nSWZdPVxcXCJ0YWIudGVtcGxhdGVMYWJlbFxcXCI+PG5nLXRlbXBsYXRlIFtjZGtQb3J0YWxIb3N0XT1cXFwidGFiLnRlbXBsYXRlTGFiZWxcXFwiPjwvbmctdGVtcGxhdGU+PC9uZy10ZW1wbGF0ZT48bmctdGVtcGxhdGUgW25nSWZdPVxcXCIhdGFiLnRlbXBsYXRlTGFiZWxcXFwiPnt7dGFiLnRleHRMYWJlbH19PC9uZy10ZW1wbGF0ZT48L2Rpdj48L21kLXRhYi1oZWFkZXI+PGRpdiBjbGFzcz1cXFwibWF0LXRhYi1ib2R5LXdyYXBwZXJcXFwiICN0YWJCb2R5V3JhcHBlcj48bWQtdGFiLWJvZHkgcm9sZT1cXFwidGFicGFuZWxcXFwiICpuZ0Zvcj1cXFwibGV0IHRhYiBvZiBfdGFiczsgbGV0IGkgPSBpbmRleFxcXCIgW2lkXT1cXFwiX2dldFRhYkNvbnRlbnRJZChpKVxcXCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cXFwiX2dldFRhYkxhYmVsSWQoaSlcXFwiIFtjbGFzcy5tYXQtdGFiLWJvZHktYWN0aXZlXT1cXFwic2VsZWN0ZWRJbmRleCA9PSBpXFxcIiBbY29udGVudF09XFxcInRhYi5jb250ZW50XFxcIiBbcG9zaXRpb25dPVxcXCJ0YWIucG9zaXRpb25cXFwiIFtvcmlnaW5dPVxcXCJ0YWIub3JpZ2luXFxcIiAob25DZW50ZXJlZCk9XFxcIl9yZW1vdmVUYWJCb2R5V3JhcHBlckhlaWdodCgpXFxcIiAob25DZW50ZXJpbmcpPVxcXCJfc2V0VGFiQm9keVdyYXBwZXJIZWlnaHQoJGV2ZW50KVxcXCI+PC9tZC10YWItYm9keT48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Omhvc3QubWF0LXRhYi1ncm91cC1pbnZlcnRlZC1oZWFkZXJ7ZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2V9Lm1hdC10YWItbGFiZWx7bGluZS1oZWlnaHQ6NDhweDtoZWlnaHQ6NDhweDtwYWRkaW5nOjAgMTJweDtjdXJzb3I6cG9pbnRlcjtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3BhY2l0eTouNjttaW4td2lkdGg6MTYwcHg7dGV4dC1hbGlnbjpjZW50ZXI7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC10YWItbGFiZWw6Zm9jdXN7b3V0bGluZTowO29wYWNpdHk6MX0ubWF0LXRhYi1sYWJlbC5tYXQtdGFiLWRpc2FibGVke2N1cnNvcjpkZWZhdWx0O3BvaW50ZXItZXZlbnRzOm5vbmV9QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpey5tYXQtdGFiLWxhYmVse21pbi13aWR0aDo3MnB4fX06aG9zdFttYXQtc3RyZXRjaC10YWJzXSAubWF0LXRhYi1sYWJlbCw6aG9zdFttZC1zdHJldGNoLXRhYnNdIC5tYXQtdGFiLWxhYmVse2ZsZXgtYmFzaXM6MDtmbGV4LWdyb3c6MX0ubWF0LXRhYi1ib2R5LXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVuO2Rpc3BsYXk6ZmxleDt0cmFuc2l0aW9uOmhlaWdodCAuNXMgY3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKX0ubWF0LXRhYi1ib2R5e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO2Rpc3BsYXk6YmxvY2s7b3ZlcmZsb3c6aGlkZGVufS5tYXQtdGFiLWJvZHkubWF0LXRhYi1ib2R5LWFjdGl2ZXtwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdy14OmhpZGRlbjtvdmVyZmxvdy15OmF1dG87ei1pbmRleDoxO2ZsZXgtZ3JvdzoxfTpob3N0Lm1hdC10YWItZ3JvdXAtZHluYW1pYy1oZWlnaHQgLm1hdC10YWItYm9keS5tYXQtdGFiLWJvZHktYWN0aXZle292ZXJmbG93LXk6aGlkZGVufVwiXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtdGFiLWdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWdyb3VwLWR5bmFtaWMtaGVpZ2h0XSc6ICdkeW5hbWljSGVpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWdyb3VwLWludmVydGVkLWhlYWRlcl0nOiAnaGVhZGVyUG9zaXRpb24gPT09IFwiYmVsb3dcIicsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFRhYkdyb3VwLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuXTsgfTtcbk1kVGFiR3JvdXAucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ190YWJzJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWRUYWIsXSB9LF0sXG4gICAgJ190YWJCb2R5V3JhcHBlcic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWyd0YWJCb2R5V3JhcHBlcicsXSB9LF0sXG4gICAgJ2R5bmFtaWNIZWlnaHQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ19keW5hbWljSGVpZ2h0RGVwcmVjYXRlZCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kLWR5bmFtaWMtaGVpZ2h0JyxdIH0sXSxcbiAgICAnZGlzYWJsZVJpcHBsZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc2VsZWN0ZWRJbmRleCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaGVhZGVyUG9zaXRpb24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkSW5kZXhDaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICdmb2N1c0NoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ3NlbGVjdENoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kVGFiTGFiZWxXcmFwcGVyQmFzZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFiTGFiZWxXcmFwcGVyQmFzZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kVGFiTGFiZWxXcmFwcGVyQmFzZTtcbn0oKSk7XG52YXIgX01kVGFiTGFiZWxXcmFwcGVyTWl4aW5CYXNlID0gbWl4aW5EaXNhYmxlZChNZFRhYkxhYmVsV3JhcHBlckJhc2UpO1xuLyoqXG4gKiBVc2VkIGluIHRoZSBgbWQtdGFiLWdyb3VwYCB2aWV3IHRvIGRpc3BsYXkgdGFiIGxhYmVscy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRUYWJMYWJlbFdyYXBwZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFRhYkxhYmVsV3JhcHBlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFRhYkxhYmVsV3JhcHBlcihlbGVtZW50UmVmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgZm9jdXMgb24gdGhlIHdyYXBwZXIgZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJMYWJlbFdyYXBwZXIucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkxhYmVsV3JhcHBlci5wcm90b3R5cGUuZ2V0T2Zmc2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiTGFiZWxXcmFwcGVyLnByb3RvdHlwZS5nZXRPZmZzZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIH07XG4gICAgcmV0dXJuIE1kVGFiTGFiZWxXcmFwcGVyO1xufShfTWRUYWJMYWJlbFdyYXBwZXJNaXhpbkJhc2UpKTtcbk1kVGFiTGFiZWxXcmFwcGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtdGFiLWxhYmVsLXdyYXBwZXJdLCBbbWF0LXRhYi1sYWJlbC13cmFwcGVyXScsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2Rpc2FibGVkJ10sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItZGlzYWJsZWRdJzogJ2Rpc2FibGVkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUYWJMYWJlbFdyYXBwZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuXTsgfTtcbi8qKlxuICogVGhlIGluay1iYXIgaXMgdXNlZCB0byBkaXNwbGF5IGFuZCBhbmltYXRlIHRoZSBsaW5lIHVuZGVybmVhdGggdGhlIGN1cnJlbnQgYWN0aXZlIHRhYiBsYWJlbC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRJbmtCYXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZElua0JhcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmLCBfbmdab25lKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHN0eWxlcyBmcm9tIHRoZSBwcm92aWRlZCBlbGVtZW50IGluIG9yZGVyIHRvIGFsaWduIHRoZSBpbmstYmFyIHRvIHRoYXQgZWxlbWVudC5cbiAgICAgKiBTaG93cyB0aGUgaW5rIGJhciBpZiBwcmV2aW91c2x5IHNldCBhcyBoaWRkZW4uXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuYWxpZ25Ub0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlcmVyLnNldFN0eWxlKF90aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdsZWZ0JywgX3RoaXMuX2dldExlZnRQb3NpdGlvbihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlcmVyLnNldFN0eWxlKF90aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIF90aGlzLl9nZXRFbGVtZW50V2lkdGgoZWxlbWVudCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIGluayBiYXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgaW5rIGJhci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kSW5rQmFyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBwaXhlbCBkaXN0YW5jZSBmcm9tIHRoZSBsZWZ0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBlbGVtZW50IGluIHN0cmluZyBmb3JtYXQuXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuX2dldExlZnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vZmZzZXRMZWZ0ICsgJ3B4JyA6ICcwJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgcGl4ZWwgd2lkdGggZnJvbSB0aGUgcHJvdmlkZWQgZWxlbWVudCBpbiBzdHJpbmcgZm9ybWF0LlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRJbmtCYXIucHJvdG90eXBlLl9nZXRFbGVtZW50V2lkdGggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggKyAncHgnIDogJzAnO1xuICAgIH07XG4gICAgcmV0dXJuIE1kSW5rQmFyO1xufSgpKTtcbk1kSW5rQmFyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1pbmstYmFyLCBtYXQtaW5rLWJhcicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LWluay1iYXInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kSW5rQmFyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbl07IH07XG4vKipcbiAqIE5hdmlnYXRpb24gY29tcG9uZW50IG1hdGNoaW5nIHRoZSBzdHlsZXMgb2YgdGhlIHRhYiBncm91cCBoZWFkZXIuXG4gKiBQcm92aWRlcyBhbmNob3JlZCBuYXZpZ2F0aW9uIHdpdGggYW5pbWF0ZWQgaW5rIGJhci5cbiAqL1xudmFyIE1kVGFiTmF2ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRUYWJOYXYoX2RpciwgX25nWm9uZSkge1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3ViamVjdCB0aGF0IGVtaXRzIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBkZXN0cm95ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGUgY29tcG9uZW50IHRoYXQgdGhlIGFjdGl2ZSBsaW5rIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYk5hdi5wcm90b3R5cGUudXBkYXRlQWN0aXZlTGluayA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUxpbmtDaGFuZ2VkID0gdGhpcy5fYWN0aXZlTGlua0VsZW1lbnQgIT0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5fYWN0aXZlTGlua0VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYk5hdi5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9yZXNpemVTdWJzY3JpcHRpb24gPSB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyQ2hhbmdlID0gX3RoaXMuX2RpciA/IF90aGlzLl9kaXIuY2hhbmdlIDogb2YobnVsbCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNpemUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICAgICAgYXVkaXRUaW1lLmNhbGwoZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLCAxMCkgOlxuICAgICAgICAgICAgICAgIG9mKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRha2VVbnRpbC5jYWxsKG1lcmdlKGRpckNoYW5nZSwgcmVzaXplKSwgX3RoaXMuX29uRGVzdHJveSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hbGlnbklua0JhcigpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGFjdGl2ZSBsaW5rIGhhcyBiZWVuIGNoYW5nZWQgYW5kLCBpZiBzbywgd2lsbCB1cGRhdGUgdGhlIGluayBiYXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYk5hdi5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlTGlua0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FsaWduSW5rQmFyKCk7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVMaW5rQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiTmF2LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fcmVzaXplU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGlnbnMgdGhlIGluayBiYXIgdG8gdGhlIGFjdGl2ZSBsaW5rLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJOYXYucHJvdG90eXBlLl9hbGlnbklua0JhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUxpbmtFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9pbmtCYXIuYWxpZ25Ub0VsZW1lbnQodGhpcy5fYWN0aXZlTGlua0VsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZFRhYk5hdjtcbn0oKSk7XG5NZFRhYk5hdi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ1ttZC10YWItbmF2LWJhcl0sIFttYXQtdGFiLW5hdi1iYXJdJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWxpbmtzXFxcIiAoY2RrT2JzZXJ2ZUNvbnRlbnQpPVxcXCJfYWxpZ25JbmtCYXIoKVxcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjxtZC1pbmstYmFyPjwvbWQtaW5rLWJhcj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtdGFiLW5hdi1iYXJ7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtc2hyaW5rOjB9Lm1hdC10YWItbGlua3N7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC10YWItbGlua3tsaW5lLWhlaWdodDo0OHB4O2hlaWdodDo0OHB4O3BhZGRpbmc6MCAxMnB4O2N1cnNvcjpwb2ludGVyO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvcGFjaXR5Oi42O21pbi13aWR0aDoxNjBweDt0ZXh0LWFsaWduOmNlbnRlcjtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjp0b3A7dGV4dC1kZWNvcmF0aW9uOm5vbmU7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVufS5tYXQtdGFiLWxpbms6Zm9jdXN7b3V0bGluZTowO29wYWNpdHk6MX0ubWF0LXRhYi1saW5rLm1hdC10YWItZGlzYWJsZWR7Y3Vyc29yOmRlZmF1bHQ7cG9pbnRlci1ldmVudHM6bm9uZX1AbWVkaWEgKG1heC13aWR0aDo2MDBweCl7Lm1hdC10YWItbGlua3ttaW4td2lkdGg6NzJweH19Lm1hdC1pbmstYmFye3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO2hlaWdodDoycHg7dHJhbnNpdGlvbjouNXMgY3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKX0ubWF0LXRhYi1ncm91cC1pbnZlcnRlZC1oZWFkZXIgLm1hdC1pbmstYmFye2JvdHRvbTphdXRvO3RvcDowfVwiXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtdGFiLW5hdi1iYXInIH0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUYWJOYXYuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBEaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG5dOyB9O1xuTWRUYWJOYXYucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ19pbmtCYXInOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtNZElua0JhcixdIH0sXSxcbn07XG52YXIgTWRUYWJMaW5rQmFzZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFiTGlua0Jhc2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFRhYkxpbmtCYXNlO1xufSgpKTtcbnZhciBfTWRUYWJMaW5rTWl4aW5CYXNlID0gbWl4aW5EaXNhYmxlZChNZFRhYkxpbmtCYXNlKTtcbi8qKlxuICogTGluayBpbnNpZGUgb2YgYSBgbWQtdGFiLW5hdi1iYXJgLlxuICovXG52YXIgTWRUYWJMaW5rID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRUYWJMaW5rLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX21kVGFiTmF2QmFyXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBydWxlclxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1cbiAgICAgKiBAcGFyYW0gez99IGdsb2JhbE9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFRhYkxpbmsoX21kVGFiTmF2QmFyLCBfZWxlbWVudFJlZiwgbmdab25lLCBydWxlciwgcGxhdGZvcm0sIGdsb2JhbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX21kVGFiTmF2QmFyID0gX21kVGFiTmF2QmFyO1xuICAgICAgICBfdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdGFiIGxpbmsgaXMgYWN0aXZlIG9yIG5vdC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvLyBNYW51YWxseSBjcmVhdGUgYSByaXBwbGUgaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSB0YWIgbGluayBlbGVtZW50IGFzIHRyaWdnZXIgZWxlbWVudC5cbiAgICAgICAgLy8gTm90aWNlIHRoYXQgdGhlIGxpZmVjeWNsZSBob29rcyBmb3IgdGhlIHJpcHBsZSBjb25maWcgd29uJ3QgYmUgY2FsbGVkIGFueW1vcmUuXG4gICAgICAgIF90aGlzLl90YWJMaW5rUmlwcGxlID0gbmV3IE1kUmlwcGxlKF9lbGVtZW50UmVmLCBuZ1pvbmUsIHJ1bGVyLCBwbGF0Zm9ybSwgZ2xvYmFsT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiTGluay5wcm90b3R5cGUsIFwiYWN0aXZlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGxpbmsgaXMgYWN0aXZlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pc0FjdGl2ZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWRUYWJOYXZCYXIudXBkYXRlQWN0aXZlTGluayh0aGlzLl9lbGVtZW50UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiTGluay5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAZG9jcy1wcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gLTEgOiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiTGluay5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE1hbnVhbGx5IGNhbGwgdGhlIG5nT25EZXN0cm95IGxpZmVjeWNsZSBob29rIG9mIHRoZSByaXBwbGUgaW5zdGFuY2UgYmVjYXVzZSBpdCB3b24ndCBiZVxuICAgICAgICAvLyBjYWxsZWQgYXV0b21hdGljYWxseSBzaW5jZSBpdHMgaW5zdGFuY2UgaXMgbm90IGNyZWF0ZWQgYnkgQW5ndWxhci5cbiAgICAgICAgdGhpcy5fdGFiTGlua1JpcHBsZS5uZ09uRGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kVGFiTGluaztcbn0oX01kVGFiTGlua01peGluQmFzZSkpO1xuTWRUYWJMaW5rLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtdGFiLWxpbmtdLCBbbWF0LXRhYi1saW5rXSwgW21kVGFiTGlua10sIFttYXRUYWJMaW5rXScsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2Rpc2FibGVkJ10sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LXRhYi1saW5rJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkLnRvU3RyaW5nKCknLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItZGlzYWJsZWRdJzogJ2Rpc2FibGVkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUYWJMaW5rLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTWRUYWJOYXYsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogVmlld3BvcnRSdWxlciwgfSxcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01EX1JJUFBMRV9HTE9CQUxfT1BUSU9OUyxdIH0sXSB9LFxuXTsgfTtcbk1kVGFiTGluay5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnYWN0aXZlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd0YWJJbmRleCc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3RhYkluZGV4JyxdIH0sXSxcbn07XG4vKipcbiAqIFdyYXBwZXIgZm9yIHRoZSBjb250ZW50cyBvZiBhIHRhYi5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRUYWJCb2R5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX2RpclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kVGFiQm9keShfZWxlbWVudFJlZiwgX2Rpcikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHRhYiBiZWdpbnMgdG8gYW5pbWF0ZSB0b3dhcmRzIHRoZSBjZW50ZXIgYXMgdGhlIGFjdGl2ZSB0YWIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQ2VudGVyaW5nID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB0YWIgY29tcGxldGVzIGl0cyBhbmltYXRpb24gdG93YXJkcyB0aGUgY2VudGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNlbnRlcmVkID0gbmV3IEV2ZW50RW1pdHRlcih0cnVlKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiQm9keS5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwb3NpdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fZ2V0TGF5b3V0RGlyZWN0aW9uKCkgPT0gJ2x0cicgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiQm9keS5wcm90b3R5cGUsIFwib3JpZ2luXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcmlnaW4gcG9zaXRpb24gZnJvbSB3aGljaCB0aGlzIHRhYiBzaG91bGQgYXBwZWFyIHdoZW4gaXQgaXMgY2VudGVyZWQgaW50byB2aWV3LlxuICAgICAgICAgKiBAcGFyYW0gez99IG9yaWdpblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXIgPSB0aGlzLl9nZXRMYXlvdXREaXJlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICgoZGlyID09ICdsdHInICYmIG9yaWdpbiA8PSAwKSB8fCAoZGlyID09ICdydGwnICYmIG9yaWdpbiA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luID0gJ2xlZnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgaW5pdGlhbGl6ZWQsIGNoZWNrIGlmIHRoZSBjb250ZW50IGlzIGNlbnRlcmVkIGFuZCBoYXMgYW4gb3JpZ2luLiBJZiBzbywgc2V0IHRoZVxuICAgICAqIHNwZWNpYWwgcG9zaXRpb24gc3RhdGVzIHRoYXQgdHJhbnNpdGlvbiB0aGUgdGFiIGZyb20gdGhlIGxlZnQgb3IgcmlnaHQgYmVmb3JlIGNlbnRlcmluZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiQm9keS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvbiA9PSAnY2VudGVyJyAmJiB0aGlzLl9vcmlnaW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fb3JpZ2luID09ICdsZWZ0JyA/ICdsZWZ0LW9yaWdpbi1jZW50ZXInIDogJ3JpZ2h0LW9yaWdpbi1jZW50ZXInO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZnRlciB0aGUgdmlldyBoYXMgYmVlbiBzZXQsIGNoZWNrIGlmIHRoZSB0YWIgY29udGVudCBpcyBzZXQgdG8gdGhlIGNlbnRlciBhbmQgYXR0YWNoIHRoZVxuICAgICAqIGNvbnRlbnQgaWYgaXQgaXMgbm90IGFscmVhZHkgYXR0YWNoZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkJvZHkucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2VudGVyUG9zaXRpb24odGhpcy5fcG9zaXRpb24pICYmICF0aGlzLl9wb3J0YWxIb3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnRhbEhvc3QuYXR0YWNoKHRoaXMuX2NvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiQm9keS5wcm90b3R5cGUuX29uVHJhbnNsYXRlVGFiU3RhcnRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NlbnRlclBvc2l0aW9uKGUudG9TdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMub25DZW50ZXJpbmcuZW1pdCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkJvZHkucHJvdG90eXBlLl9vblRyYW5zbGF0ZVRhYkNvbXBsZXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGVuZCBzdGF0ZSBpcyB0aGF0IHRoZSB0YWIgaXMgbm90IGNlbnRlcmVkLCB0aGVuIGRldGFjaCB0aGUgY29udGVudC5cbiAgICAgICAgaWYgKCF0aGlzLl9pc0NlbnRlclBvc2l0aW9uKGUudG9TdGF0ZSkgJiYgIXRoaXMuX2lzQ2VudGVyUG9zaXRpb24odGhpcy5fcG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWxIb3N0LmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB0cmFuc2l0aW9uIHRvIHRoZSBjZW50ZXIgaXMgY29tcGxldGUsIGVtaXQgYW4gZXZlbnQuXG4gICAgICAgIGlmICh0aGlzLl9pc0NlbnRlclBvc2l0aW9uKGUudG9TdGF0ZSkgJiYgdGhpcy5faXNDZW50ZXJQb3NpdGlvbih0aGlzLl9wb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMub25DZW50ZXJlZC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkJvZHkucHJvdG90eXBlLl9nZXRMYXlvdXREaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBwcm92aWRlZCBwb3NpdGlvbiBzdGF0ZSBpcyBjb25zaWRlcmVkIGNlbnRlciwgcmVnYXJkbGVzcyBvZiBvcmlnaW4uXG4gICAgICogQHBhcmFtIHs/fSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJCb2R5LnByb3RvdHlwZS5faXNDZW50ZXJQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gPT0gJ2NlbnRlcicgfHxcbiAgICAgICAgICAgIHBvc2l0aW9uID09ICdsZWZ0LW9yaWdpbi1jZW50ZXInIHx8XG4gICAgICAgICAgICBwb3NpdGlvbiA9PSAncmlnaHQtb3JpZ2luLWNlbnRlcic7XG4gICAgfTtcbiAgICByZXR1cm4gTWRUYWJCb2R5O1xufSgpKTtcbk1kVGFiQm9keS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLXRhYi1ib2R5LCBtYXQtdGFiLWJvZHknLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC10YWItYm9keS1jb250ZW50XFxcIiAjY29udGVudCBbQHRyYW5zbGF0ZVRhYl09XFxcIl9wb3NpdGlvblxcXCIgKEB0cmFuc2xhdGVUYWIuc3RhcnQpPVxcXCJfb25UcmFuc2xhdGVUYWJTdGFydGVkKCRldmVudClcXFwiIChAdHJhbnNsYXRlVGFiLmRvbmUpPVxcXCJfb25UcmFuc2xhdGVUYWJDb21wbGV0ZSgkZXZlbnQpXFxcIj48bmctdGVtcGxhdGUgY2RrUG9ydGFsSG9zdD48L25nLXRlbXBsYXRlPjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC10YWItYm9keS1jb250ZW50e2hlaWdodDoxMDAlO292ZXJmbG93OmF1dG99Lm1hdC10YWItZ3JvdXAtZHluYW1pYy1oZWlnaHQgLm1hdC10YWItYm9keS1jb250ZW50e292ZXJmbG93OmhpZGRlbn1cIl0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtdGFiLWJvZHknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCd0cmFuc2xhdGVUYWInLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgndm9pZCcsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCUsIDAsIDApJyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgnbGVmdCcsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApJyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgnbGVmdC1vcmlnaW4tY2VudGVyJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwJSwgMCwgMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdyaWdodC1vcmlnaW4tY2VudGVyJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwJSwgMCwgMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdjZW50ZXInLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAlLCAwLCAwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ3JpZ2h0Jywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiBsZWZ0LCAqID0+IHJpZ2h0LCBsZWZ0ID0+IGNlbnRlciwgcmlnaHQgPT4gY2VudGVyJywgYW5pbWF0ZSgnNTAwbXMgY3ViaWMtYmV6aWVyKDAuMzUsIDAsIDAuMjUsIDEpJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiBsZWZ0LW9yaWdpbi1jZW50ZXInLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCknIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoJzUwMG1zIGN1YmljLWJlemllcigwLjM1LCAwLCAwLjI1LCAxKScpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gcmlnaHQtb3JpZ2luLWNlbnRlcicsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDEwMCUsIDAsIDApJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKCc1MDBtcyBjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSknKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVGFiQm9keS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBEaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG5dOyB9O1xuTWRUYWJCb2R5LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdfcG9ydGFsSG9zdCc6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW1BvcnRhbEhvc3REaXJlY3RpdmUsXSB9LF0sXG4gICAgJ29uQ2VudGVyaW5nJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnb25DZW50ZXJlZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ19jb250ZW50JzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnY29udGVudCcsXSB9LF0sXG4gICAgJ3Bvc2l0aW9uJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsncG9zaXRpb24nLF0gfSxdLFxuICAgICdvcmlnaW4nOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydvcmlnaW4nLF0gfSxdLFxufTtcbi8qKlxuICogVGhlIGRpc3RhbmNlIGluIHBpeGVscyB0aGF0IHdpbGwgYmUgb3ZlcnNob3Qgd2hlbiBzY3JvbGxpbmcgYSB0YWIgbGFiZWwgaW50byB2aWV3LiBUaGlzIGhlbHBzXG4gKiBwcm92aWRlIGEgc21hbGwgYWZmb3JkYW5jZSB0byB0aGUgbGFiZWwgbmV4dCB0byBpdC5cbiAqL1xudmFyIEVYQUdHRVJBVEVEX09WRVJTQ1JPTEwgPSA2MDtcbi8qKlxuICogVGhlIGhlYWRlciBvZiB0aGUgdGFiIGdyb3VwIHdoaWNoIGRpc3BsYXlzIGEgbGlzdCBvZiBhbGwgdGhlIHRhYnMgaW4gdGhlIHRhYiBncm91cC4gSW5jbHVkZXNcbiAqIGFuIGluayBiYXIgdGhhdCBmb2xsb3dzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFiLiBXaGVuIHRoZSB0YWJzIGxpc3QncyB3aWR0aCBleGNlZWRzIHRoZVxuICogd2lkdGggb2YgdGhlIGhlYWRlciBjb250YWluZXIsIHRoZW4gYXJyb3dzIHdpbGwgYmUgZGlzcGxheWVkIHRvIGFsbG93IHRoZSB1c2VyIHRvIHNjcm9sbFxuICogbGVmdCBhbmQgcmlnaHQgYWNyb3NzIHRoZSBoZWFkZXIuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kVGFiSGVhZGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRUYWJIZWFkZXIoX2VsZW1lbnRSZWYsIF9uZ1pvbmUsIF9yZW5kZXJlciwgX2Rpcikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRhYiBpbmRleCB0aGF0IGlzIGZvY3VzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9mb2N1c0luZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgdGhhdCB0aGUgdGFiIGxhYmVscyBzaG91bGQgYmUgdHJhbnNsYXRlZCB0byB0aGUgbGVmdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Njcm9sbERpc3RhbmNlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGhlYWRlciBzaG91bGQgc2Nyb2xsIHRvIHRoZSBzZWxlY3RlZCBpbmRleCBhZnRlciB0aGUgdmlldyBoYXMgYmVlbiBjaGVja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbWJpbmVzIGxpc3RlbmVycyB0aGF0IHdpbGwgcmUtYWxpZ24gdGhlIGluayBiYXIgd2hlbmV2ZXIgdGhleSdyZSBpbnZva2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVhbGlnbklua0JhciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb250cm9scyBmb3IgcGFnaW5hdGlvbiBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zaG93UGFnaW5hdGlvbkNvbnRyb2xzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB0YWIgbGlzdCBjYW4gYmUgc2Nyb2xsZWQgbW9yZSB0b3dhcmRzIHRoZSBlbmQgb2YgdGhlIHRhYiBsYWJlbCBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZVNjcm9sbEFmdGVyID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRhYiBsaXN0IGNhbiBiZSBzY3JvbGxlZCBtb3JlIHRvd2FyZHMgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGFiIGxhYmVsIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsQmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RGb2N1c2VkSW5kZXggPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gYSBsYWJlbCBpcyBmb2N1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleEZvY3VzZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkhlYWRlci5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGFjdGl2ZSB0YWIuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSW5kZXg7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleENoYW5nZWQgPSB0aGlzLl9zZWxlY3RlZEluZGV4ICE9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNJbmRleCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcImRpc2FibGVSaXBwbGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciByaXBwbGVzIGZvciB0aGUgdGFiLWhlYWRlciBsYWJlbHMgc2hvdWxkIGJlIGRpc2FibGVkIG9yIG5vdC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIHRoZSBudW1iZXIgb2YgdGFiIGxhYmVscyBoYXZlIGNoYW5nZWQsIGNoZWNrIGlmIHNjcm9sbGluZyBzaG91bGQgYmUgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5fdGFiTGFiZWxDb3VudCAhPSB0aGlzLl9sYWJlbFdyYXBwZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fdGFiTGFiZWxDb3VudCA9IHRoaXMuX2xhYmVsV3JhcHBlcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3RlZCBpbmRleCBoYXMgY2hhbmdlZCwgc2Nyb2xsIHRvIHRoZSBsYWJlbCBhbmQgY2hlY2sgaWYgdGhlIHNjcm9sbGluZyBjb250cm9sc1xuICAgICAgICAvLyBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZEluZGV4Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9MYWJlbCh0aGlzLl9zZWxlY3RlZEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrU2Nyb2xsaW5nQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2FsaWduSW5rQmFyVG9TZWxlY3RlZFRhYigpO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc2Nyb2xsIGRpc3RhbmNlIGhhcyBiZWVuIGNoYW5nZWQgKHRhYiBzZWxlY3RlZCwgZm9jdXNlZCwgc2Nyb2xsIGNvbnRyb2xzIGFjdGl2YXRlZCksXG4gICAgICAgIC8vIHRoZW4gdHJhbnNsYXRlIHRoZSBoZWFkZXIgdG8gcmVmbGVjdCB0aGlzLlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsRGlzdGFuY2VDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUYWJTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRGlzdGFuY2VDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5faGFuZGxlS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNOZXh0VGFiKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNQcmV2aW91c1RhYigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFTlRFUjpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZvY3VzZWRJbmRleC5lbWl0KHRoaXMuZm9jdXNJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFsaWducyB0aGUgaW5rIGJhciB0byB0aGUgc2VsZWN0ZWQgdGFiIG9uIGxvYWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9yZWFsaWduSW5rQmFyID0gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpckNoYW5nZSA9IF90aGlzLl9kaXIgPyBfdGhpcy5fZGlyLmNoYW5nZSA6IG9mKG51bGwpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzaXplID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgICAgIGF1ZGl0VGltZS5jYWxsKGZyb21FdmVudCh3aW5kb3csICdyZXNpemUnKSwgMTApIDpcbiAgICAgICAgICAgICAgICBvZihudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFydFdpdGguY2FsbChtZXJnZShkaXJDaGFuZ2UsIHJlc2l6ZSksIG51bGwpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVBhZ2luYXRpb24oKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYWxpZ25JbmtCYXJUb1NlbGVjdGVkVGFiKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlYWxpZ25JbmtCYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWxpZ25JbmtCYXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlYWxpZ25JbmtCYXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmb3Igd2hlbiB0aGUgTXV0YXRpb25PYnNlcnZlciBkZXRlY3RzIHRoYXQgdGhlIGNvbnRlbnQgaGFzIGNoYW5nZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX29uQ29udGVudENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBhZ2luYXRpb24oKTtcbiAgICAgICAgdGhpcy5fYWxpZ25JbmtCYXJUb1NlbGVjdGVkVGFiKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGluZyB0aGUgdmlldyB3aGV0aGVyIHBhZ2luYXRpb24gc2hvdWxkIGJlIGVuYWJsZWQgb3Igbm90XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX3VwZGF0ZVBhZ2luYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUGFnaW5hdGlvbkVuYWJsZWQoKTtcbiAgICAgICAgdGhpcy5fY2hlY2tTY3JvbGxpbmdDb250cm9scygpO1xuICAgICAgICB0aGlzLl91cGRhdGVUYWJTY3JvbGxQb3NpdGlvbigpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJmb2N1c0luZGV4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyB3aGljaCBlbGVtZW50IGhhcyBmb2N1czsgdXNlZCBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9mb2N1c0luZGV4OyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0aGUgZm9jdXMgaW5kZXggaXMgc2V0LCB3ZSBtdXN0IG1hbnVhbGx5IHNlbmQgZm9jdXMgdG8gdGhlIGNvcnJlY3QgbGFiZWxcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZEluZGV4KHZhbHVlKSB8fCB0aGlzLl9mb2N1c0luZGV4ID09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZm9jdXNJbmRleCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5pbmRleEZvY3VzZWQuZW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRUYWJGb2N1cyh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYW4gaW5kZXggaXMgdmFsaWQuICBJZiB0aGUgdGFicyBhcmUgbm90IHJlYWR5IHlldCwgd2UgYXNzdW1lIHRoYXQgdGhlIHVzZXIgaXNcbiAgICAgKiBwcm92aWRpbmcgYSB2YWxpZCBpbmRleCBhbmQgcmV0dXJuIHRydWUuXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9pc1ZhbGlkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sYWJlbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWIgPSB0aGlzLl9sYWJlbFdyYXBwZXJzID8gdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KClbaW5kZXhdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuICEhdGFiICYmICF0YWIuZGlzYWJsZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGZvY3VzIG9uIHRoZSBIVE1MIGVsZW1lbnQgZm9yIHRoZSBsYWJlbCB3cmFwcGVyIGFuZCBzY3JvbGxzIGl0IGludG8gdGhlIHZpZXcgaWZcbiAgICAgKiBzY3JvbGxpbmcgaXMgZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0gez99IHRhYkluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX3NldFRhYkZvY3VzID0gZnVuY3Rpb24gKHRhYkluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl9zaG93UGFnaW5hdGlvbkNvbnRyb2xzKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb0xhYmVsKHRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGFiZWxXcmFwcGVycyAmJiB0aGlzLl9sYWJlbFdyYXBwZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KClbdGFiSW5kZXhdLmZvY3VzKCk7XG4gICAgICAgICAgICAvLyBEbyBub3QgbGV0IHRoZSBicm93c2VyIG1hbmFnZSBzY3JvbGxpbmcgdG8gZm9jdXMgdGhlIGVsZW1lbnQsIHRoaXMgd2lsbCBiZSBoYW5kbGVkXG4gICAgICAgICAgICAvLyBieSB1c2luZyB0cmFuc2xhdGlvbi4gSW4gTFRSLCB0aGUgc2Nyb2xsIGxlZnQgc2hvdWxkIGJlIDAuIEluIFJUTCwgdGhlIHNjcm9sbCB3aWR0aFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHRoZSBmdWxsIHdpZHRoIG1pbnVzIHRoZSBvZmZzZXQgd2lkdGguXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluZXJFbCA9IHRoaXMuX3RhYkxpc3RDb250YWluZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpciA9IHRoaXMuX2dldExheW91dERpcmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGRpciA9PSAnbHRyJykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsLnNjcm9sbExlZnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWwuc2Nyb2xsTGVmdCA9IGNvbnRhaW5lckVsLnNjcm9sbFdpZHRoIC0gY29udGFpbmVyRWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBmb2N1cyB0b3dhcmRzIHRoZSBiZWdpbm5pbmcgb3IgdGhlIGVuZCBvZiB0aGUgbGlzdCBkZXBlbmRpbmcgb24gdGhlIG9mZnNldCBwcm92aWRlZC5cbiAgICAgKiBWYWxpZCBvZmZzZXRzIGFyZSAxIGFuZCAtMS5cbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9tb3ZlRm9jdXMgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWJzID0gdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KCk7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSB0aGlzLmZvY3VzSW5kZXggKyBvZmZzZXQ7IGkgPCB0YWJzLmxlbmd0aCAmJiBpID49IDA7IGkgKz0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnQgdGhlIGZvY3VzIGluZGV4IGJ5IDEgdW50aWwgYSB2YWxpZCB0YWIgaXMgZm91bmQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2ZvY3VzTmV4dFRhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW92ZUZvY3VzKHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInID8gMSA6IC0xKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlY3JlbWVudCB0aGUgZm9jdXMgaW5kZXggYnkgMSB1bnRpbCBhIHZhbGlkIHRhYiBpcyBmb3VuZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fZm9jdXNQcmV2aW91c1RhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW92ZUZvY3VzKHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInID8gLTEgOiAxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBsYXlvdXQgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluaW5nIGFwcC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fZ2V0TGF5b3V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIENTUyB0cmFuc2Zvcm1hdGlvbiBvbiB0aGUgdGFiIGxpc3QgdGhhdCB3aWxsIGNhdXNlIHRoZSBsaXN0IHRvIHNjcm9sbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fdXBkYXRlVGFiU2Nyb2xsUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjcm9sbERpc3RhbmNlID0gdGhpcy5zY3JvbGxEaXN0YW5jZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNsYXRlWCA9IHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09PSAnbHRyJyA/IC1zY3JvbGxEaXN0YW5jZSA6IHNjcm9sbERpc3RhbmNlO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl90YWJMaXN0Lm5hdGl2ZUVsZW1lbnQsICd0cmFuc2Zvcm0nLCBcInRyYW5zbGF0ZTNkKFwiICsgdHJhbnNsYXRlWCArIFwicHgsIDAsIDApXCIpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJzY3JvbGxEaXN0YW5jZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zY3JvbGxEaXN0YW5jZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRpc3RhbmNlIGluIHBpeGVscyB0aGF0IHRoZSB0YWIgaGVhZGVyIHNob3VsZCBiZSB0cmFuc2Zvcm1lZCBpbiB0aGUgWC1heGlzLlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbERpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5fZ2V0TWF4U2Nyb2xsRGlzdGFuY2UoKSwgdikpO1xuICAgICAgICAgICAgLy8gTWFyayB0aGF0IHRoZSBzY3JvbGwgZGlzdGFuY2UgaGFzIGNoYW5nZWQgc28gdGhhdCBhZnRlciB0aGUgdmlldyBpcyBjaGVja2VkLCB0aGUgQ1NTXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm1hdGlvbiBjYW4gbW92ZSB0aGUgaGVhZGVyLlxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRGlzdGFuY2VDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrU2Nyb2xsaW5nQ29udHJvbHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHRhYiBsaXN0IGluIHRoZSAnYmVmb3JlJyBvciAnYWZ0ZXInIGRpcmVjdGlvbiAodG93YXJkcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0IG9yXG4gICAgICogdGhlIGVuZCBvZiB0aGUgbGlzdCwgcmVzcGVjdGl2ZWx5KS4gVGhlIGRpc3RhbmNlIHRvIHNjcm9sbCBpcyBjb21wdXRlZCB0byBiZSBhIHRoaXJkIG9mIHRoZVxuICAgICAqIGxlbmd0aCBvZiB0aGUgdGFiIGxpc3QgdmlldyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBjYWxsIHRoYXQgZm9yY2VzIGEgbGF5b3V0IHJlZmxvdyB0byBjb21wdXRlIGJveCBhbmQgc2Nyb2xsIG1ldHJpY3MgYW5kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBzcGFyaW5nbHkuXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxEaXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fc2Nyb2xsSGVhZGVyID0gZnVuY3Rpb24gKHNjcm9sbERpcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3TGVuZ3RoID0gdGhpcy5fdGFiTGlzdENvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAvLyBNb3ZlIHRoZSBzY3JvbGwgZGlzdGFuY2Ugb25lLXRoaXJkIHRoZSBsZW5ndGggb2YgdGhlIHRhYiBsaXN0J3Mgdmlld3BvcnQuXG4gICAgICAgIHRoaXMuc2Nyb2xsRGlzdGFuY2UgKz0gKHNjcm9sbERpciA9PSAnYmVmb3JlJyA/IC0xIDogMSkgKiB2aWV3TGVuZ3RoIC8gMztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSB0YWIgbGlzdCBzdWNoIHRoYXQgdGhlIGRlc2lyZWQgdGFiIGxhYmVsIChtYXJrZWQgYnkgaW5kZXgpIGlzIG1vdmVkIGludG8gdmlldy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gZXhwZW5zaXZlIGNhbGwgdGhhdCBmb3JjZXMgYSBsYXlvdXQgcmVmbG93IHRvIGNvbXB1dGUgYm94IGFuZCBzY3JvbGwgbWV0cmljcyBhbmRcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIHNwYXJpbmdseS5cbiAgICAgKiBAcGFyYW0gez99IGxhYmVsSW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fc2Nyb2xsVG9MYWJlbCA9IGZ1bmN0aW9uIChsYWJlbEluZGV4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdGVkTGFiZWwgPSB0aGlzLl9sYWJlbFdyYXBwZXJzXG4gICAgICAgICAgICA/IHRoaXMuX2xhYmVsV3JhcHBlcnMudG9BcnJheSgpW2xhYmVsSW5kZXhdXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICghc2VsZWN0ZWRMYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSB2aWV3IGxlbmd0aCBpcyB0aGUgdmlzaWJsZSB3aWR0aCBvZiB0aGUgdGFiIGxhYmVscy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0xlbmd0aCA9IHRoaXMuX3RhYkxpc3RDb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFiZWxCZWZvcmVQb3MsIC8qKiBAdHlwZSB7P30gKi8gbGFiZWxBZnRlclBvcztcbiAgICAgICAgaWYgKHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInKSB7XG4gICAgICAgICAgICBsYWJlbEJlZm9yZVBvcyA9IHNlbGVjdGVkTGFiZWwuZ2V0T2Zmc2V0TGVmdCgpO1xuICAgICAgICAgICAgbGFiZWxBZnRlclBvcyA9IGxhYmVsQmVmb3JlUG9zICsgc2VsZWN0ZWRMYWJlbC5nZXRPZmZzZXRXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWxBZnRlclBvcyA9IHRoaXMuX3RhYkxpc3QubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAtIHNlbGVjdGVkTGFiZWwuZ2V0T2Zmc2V0TGVmdCgpO1xuICAgICAgICAgICAgbGFiZWxCZWZvcmVQb3MgPSBsYWJlbEFmdGVyUG9zIC0gc2VsZWN0ZWRMYWJlbC5nZXRPZmZzZXRXaWR0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJlZm9yZVZpc2libGVQb3MgPSB0aGlzLnNjcm9sbERpc3RhbmNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhZnRlclZpc2libGVQb3MgPSB0aGlzLnNjcm9sbERpc3RhbmNlICsgdmlld0xlbmd0aDtcbiAgICAgICAgaWYgKGxhYmVsQmVmb3JlUG9zIDwgYmVmb3JlVmlzaWJsZVBvcykge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIGhlYWRlciB0byBtb3ZlIGxhYmVsIHRvIHRoZSBiZWZvcmUgZGlyZWN0aW9uXG4gICAgICAgICAgICB0aGlzLnNjcm9sbERpc3RhbmNlIC09IGJlZm9yZVZpc2libGVQb3MgLSBsYWJlbEJlZm9yZVBvcyArIEVYQUdHRVJBVEVEX09WRVJTQ1JPTEw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFiZWxBZnRlclBvcyA+IGFmdGVyVmlzaWJsZVBvcykge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIGhlYWRlciB0byBtb3ZlIGxhYmVsIHRvIHRoZSBhZnRlciBkaXJlY3Rpb25cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlzdGFuY2UgKz0gbGFiZWxBZnRlclBvcyAtIGFmdGVyVmlzaWJsZVBvcyArIEVYQUdHRVJBVEVEX09WRVJTQ1JPTEw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHdoZXRoZXIgdGhlIHBhZ2luYXRpb24gY29udHJvbHMgc2hvdWxkIGJlIGRpc3BsYXllZC4gSWYgdGhlIHNjcm9sbCB3aWR0aCBvZiB0aGVcbiAgICAgKiB0YWIgbGlzdCBpcyB3aWRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBoZWFkZXIgY29udGFpbmVyLCB0aGVuIHRoZSBwYWdpbmF0aW9uIGNvbnRyb2xzIHNob3VsZFxuICAgICAqIGJlIHNob3duLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBleHBlbnNpdmUgY2FsbCB0aGF0IGZvcmNlcyBhIGxheW91dCByZWZsb3cgdG8gY29tcHV0ZSBib3ggYW5kIHNjcm9sbCBtZXRyaWNzIGFuZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgc3BhcmluZ2x5LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9jaGVja1BhZ2luYXRpb25FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zaG93UGFnaW5hdGlvbkNvbnRyb2xzID1cbiAgICAgICAgICAgIHRoaXMuX3RhYkxpc3QubmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aCA+IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93UGFnaW5hdGlvbkNvbnRyb2xzKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERpc3RhbmNlID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgd2hldGhlciB0aGUgYmVmb3JlIGFuZCBhZnRlciBjb250cm9scyBzaG91bGQgYmUgZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAgICAgKiBJZiB0aGUgaGVhZGVyIGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QgKHNjcm9sbCBkaXN0YW5jZSBpcyBlcXVhbCB0byAwKSB0aGVuIGRpc2FibGUgdGhlXG4gICAgICogYmVmb3JlIGJ1dHRvbi4gSWYgdGhlIGhlYWRlciBpcyBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IChzY3JvbGwgZGlzdGFuY2UgaXMgZXF1YWwgdG8gdGhlXG4gICAgICogbWF4aW11bSBkaXN0YW5jZSB3ZSBjYW4gc2Nyb2xsKSwgdGhlbiBkaXNhYmxlIHRoZSBhZnRlciBidXR0b24uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBjYWxsIHRoYXQgZm9yY2VzIGEgbGF5b3V0IHJlZmxvdyB0byBjb21wdXRlIGJveCBhbmQgc2Nyb2xsIG1ldHJpY3MgYW5kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBzcGFyaW5nbHkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2NoZWNrU2Nyb2xsaW5nQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwYWdpbmF0aW9uIGFycm93cyBzaG91bGQgYmUgYWN0aXZhdGVkLlxuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsQmVmb3JlID0gdGhpcy5zY3JvbGxEaXN0YW5jZSA9PSAwO1xuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsQWZ0ZXIgPSB0aGlzLnNjcm9sbERpc3RhbmNlID09IHRoaXMuX2dldE1heFNjcm9sbERpc3RhbmNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoYXQgaXMgdGhlIG1heGltdW0gbGVuZ3RoIGluIHBpeGVscyB0aGF0IGNhbiBiZSBzZXQgZm9yIHRoZSBzY3JvbGwgZGlzdGFuY2UuIFRoaXNcbiAgICAgKiBpcyBlcXVhbCB0byB0aGUgZGlmZmVyZW5jZSBpbiB3aWR0aCBiZXR3ZWVuIHRoZSB0YWIgbGlzdCBjb250YWluZXIgYW5kIHRhYiBoZWFkZXIgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBleHBlbnNpdmUgY2FsbCB0aGF0IGZvcmNlcyBhIGxheW91dCByZWZsb3cgdG8gY29tcHV0ZSBib3ggYW5kIHNjcm9sbCBtZXRyaWNzIGFuZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgc3BhcmluZ2x5LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9nZXRNYXhTY3JvbGxEaXN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuZ3RoT2ZUYWJMaXN0ID0gdGhpcy5fdGFiTGlzdC5uYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3TGVuZ3RoID0gdGhpcy5fdGFiTGlzdENvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICByZXR1cm4gKGxlbmd0aE9mVGFiTGlzdCAtIHZpZXdMZW5ndGgpIHx8IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgaW5rLWJhciB0byBhbGlnbiBpdHNlbGYgdG8gdGhlIGN1cnJlbnQgbGFiZWwgd3JhcHBlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9hbGlnbklua0JhclRvU2VsZWN0ZWRUYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdGVkTGFiZWxXcmFwcGVyID0gdGhpcy5fbGFiZWxXcmFwcGVycyAmJiB0aGlzLl9sYWJlbFdyYXBwZXJzLmxlbmd0aFxuICAgICAgICAgICAgPyB0aGlzLl9sYWJlbFdyYXBwZXJzLnRvQXJyYXkoKVt0aGlzLnNlbGVjdGVkSW5kZXhdLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudFxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB0aGlzLl9pbmtCYXIuYWxpZ25Ub0VsZW1lbnQoc2VsZWN0ZWRMYWJlbFdyYXBwZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kVGFiSGVhZGVyO1xufSgpKTtcbk1kVGFiSGVhZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtdGFiLWhlYWRlciwgbWF0LXRhYi1oZWFkZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24gbWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1iZWZvcmUgbWF0LWVsZXZhdGlvbi16NFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIG1kLXJpcHBsZSBbbWRSaXBwbGVEaXNhYmxlZF09XFxcIl9kaXNhYmxlU2Nyb2xsQmVmb3JlIHx8IGRpc2FibGVSaXBwbGVcXFwiIFtjbGFzcy5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWRpc2FibGVkXT1cXFwiX2Rpc2FibGVTY3JvbGxCZWZvcmVcXFwiIChjbGljayk9XFxcIl9zY3JvbGxIZWFkZXIoJ2JlZm9yZScpXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb25cXFwiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGFiZWwtY29udGFpbmVyXFxcIiAjdGFiTGlzdENvbnRhaW5lciAoa2V5ZG93bik9XFxcIl9oYW5kbGVLZXlkb3duKCRldmVudClcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGlzdFxcXCIgI3RhYkxpc3Qgcm9sZT1cXFwidGFibGlzdFxcXCIgKGNka09ic2VydmVDb250ZW50KT1cXFwiX29uQ29udGVudENoYW5nZXMoKVxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXRhYi1sYWJlbHNcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48bWQtaW5rLWJhcj48L21kLWluay1iYXI+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbiBtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWFmdGVyIG1hdC1lbGV2YXRpb24tejRcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBtZC1yaXBwbGUgW21kUmlwcGxlRGlzYWJsZWRdPVxcXCJfZGlzYWJsZVNjcm9sbEFmdGVyIHx8IGRpc2FibGVSaXBwbGVcXFwiIFtjbGFzcy5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWRpc2FibGVkXT1cXFwiX2Rpc2FibGVTY3JvbGxBZnRlclxcXCIgKGNsaWNrKT1cXFwiX3Njcm9sbEhlYWRlcignYWZ0ZXInKVxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9uXFxcIj48L2Rpdj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtdGFiLWhlYWRlcntkaXNwbGF5OmZsZXg7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtc2hyaW5rOjB9Lm1hdC10YWItbGFiZWx7bGluZS1oZWlnaHQ6NDhweDtoZWlnaHQ6NDhweDtwYWRkaW5nOjAgMTJweDtjdXJzb3I6cG9pbnRlcjtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3BhY2l0eTouNjttaW4td2lkdGg6MTYwcHg7dGV4dC1hbGlnbjpjZW50ZXI7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC10YWItbGFiZWw6Zm9jdXN7b3V0bGluZTowO29wYWNpdHk6MX0ubWF0LXRhYi1sYWJlbC5tYXQtdGFiLWRpc2FibGVke2N1cnNvcjpkZWZhdWx0O3BvaW50ZXItZXZlbnRzOm5vbmV9QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpey5tYXQtdGFiLWxhYmVse21pbi13aWR0aDo3MnB4fX0ubWF0LWluay1iYXJ7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjA7aGVpZ2h0OjJweDt0cmFuc2l0aW9uOi41cyBjdWJpYy1iZXppZXIoLjM1LDAsLjI1LDEpfS5tYXQtdGFiLWdyb3VwLWludmVydGVkLWhlYWRlciAubWF0LWluay1iYXJ7Ym90dG9tOmF1dG87dG9wOjB9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb257cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpub25lO2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO21pbi13aWR0aDozMnB4O2N1cnNvcjpwb2ludGVyO3otaW5kZXg6Mn0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jb250cm9scy1lbmFibGVkIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9ue2Rpc3BsYXk6ZmxleH0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1iZWZvcmUsLm1hdC10YWItaGVhZGVyLXJ0bCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1hZnRlcntwYWRkaW5nLWxlZnQ6NHB4fS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWJlZm9yZSAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9uLC5tYXQtdGFiLWhlYWRlci1ydGwgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYWZ0ZXIgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbnt0cmFuc2Zvcm06cm90YXRlKC0xMzVkZWcpfS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWFmdGVyLC5tYXQtdGFiLWhlYWRlci1ydGwgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYmVmb3Jle3BhZGRpbmctcmlnaHQ6NHB4fS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWFmdGVyIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb24sLm1hdC10YWItaGVhZGVyLXJ0bCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1iZWZvcmUgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbnt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9ue2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItd2lkdGg6MnB4IDJweCAwIDA7Y29udGVudDonJztoZWlnaHQ6OHB4O3dpZHRoOjhweH0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1kaXNhYmxlZHtib3gtc2hhZG93Om5vbmU7Y3Vyc29yOmRlZmF1bHR9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tZGlzYWJsZWQgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbntib3JkZXItY29sb3I6I2NjY30ubWF0LXRhYi1sYWJlbC1jb250YWluZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtZ3JvdzoxO292ZXJmbG93OmhpZGRlbjt6LWluZGV4OjF9Lm1hdC10YWItbGlzdHtmbGV4LWdyb3c6MTtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNXMgY3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKX0ubWF0LXRhYi1sYWJlbHN7ZGlzcGxheTpmbGV4fVwiXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC10YWItaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNvbnRyb2xzLWVuYWJsZWRdJzogJ19zaG93UGFnaW5hdGlvbkNvbnRyb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWhlYWRlci1ydGxdJzogXCJfZ2V0TGF5b3V0RGlyZWN0aW9uKCkgPT0gJ3J0bCdcIixcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVGFiSGVhZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IERpcmVjdGlvbmFsaXR5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbl07IH07XG5NZFRhYkhlYWRlci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX2xhYmVsV3JhcHBlcnMnOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtNZFRhYkxhYmVsV3JhcHBlcixdIH0sXSxcbiAgICAnX2lua0Jhcic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW01kSW5rQmFyLF0gfSxdLFxuICAgICdfdGFiTGlzdENvbnRhaW5lcic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWyd0YWJMaXN0Q29udGFpbmVyJyxdIH0sXSxcbiAgICAnX3RhYkxpc3QnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsndGFiTGlzdCcsXSB9LF0sXG4gICAgJ3NlbGVjdGVkSW5kZXgnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2Rpc2FibGVSaXBwbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdEZvY3VzZWRJbmRleCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2luZGV4Rm9jdXNlZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xudmFyIE1kVGFic01vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFic01vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kVGFic01vZHVsZTtcbn0oKSk7XG5NZFRhYnNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBQb3J0YWxNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kUmlwcGxlTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBPYnNlcnZlQ29udGVudE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgU2Nyb2xsRGlzcGF0Y2hNb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBleHBvcnQgYWxsIGNvbXBvbmVudHMgYmVjYXVzZSBzb21lIGFyZSBvbmx5IHRvIGJlIHVzZWQgaW50ZXJuYWxseS5cbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiTGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiLFxuICAgICAgICAgICAgICAgICAgICBNZFRhYk5hdixcbiAgICAgICAgICAgICAgICAgICAgTWRUYWJMaW5rLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiTGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiLFxuICAgICAgICAgICAgICAgICAgICBNZElua0JhcixcbiAgICAgICAgICAgICAgICAgICAgTWRUYWJMYWJlbFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiTmF2LFxuICAgICAgICAgICAgICAgICAgICBNZFRhYkxpbmssXG4gICAgICAgICAgICAgICAgICAgIE1kVGFiQm9keSxcbiAgICAgICAgICAgICAgICAgICAgTWRUYWJIZWFkZXJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1ZJRVdQT1JUX1JVTEVSX1BST1ZJREVSXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUYWJzTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWRUb29sYmFyUm93ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sYmFyUm93KCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRUb29sYmFyUm93O1xufSgpKTtcbk1kVG9vbGJhclJvdy5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtdG9vbGJhci1yb3csIG1hdC10b29sYmFyLXJvdycsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LXRvb2xiYXItcm93JyB9LFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFRvb2xiYXJSb3cuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFRvb2xiYXJCYXNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRUb29sYmFyQmFzZShfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgfVxuICAgIHJldHVybiBNZFRvb2xiYXJCYXNlO1xufSgpKTtcbnZhciBfTWRUb29sYmFyTWl4aW5CYXNlID0gbWl4aW5Db2xvcihNZFRvb2xiYXJCYXNlKTtcbnZhciBNZFRvb2xiYXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZFRvb2xiYXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kVG9vbGJhcihyZW5kZXJlciwgZWxlbWVudFJlZikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcmVuZGVyZXIsIGVsZW1lbnRSZWYpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZFRvb2xiYXI7XG59KF9NZFRvb2xiYXJNaXhpbkJhc2UpKTtcbk1kVG9vbGJhci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLXRvb2xiYXIsIG1hdC10b29sYmFyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtdG9vbGJhci1sYXlvdXRcXFwiPjxtZC10b29sYmFyLXJvdz48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9tZC10b29sYmFyLXJvdz48bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLXRvb2xiYXItcm93LCBtYXQtdG9vbGJhci1yb3dcXFwiPjwvbmctY29udGVudD48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtdG9vbGJhcntkaXNwbGF5OmZsZXg7Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOjEwMCU7cGFkZGluZzowIDE2cHg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5tYXQtdG9vbGJhciAubWF0LXRvb2xiYXItcm93e2Rpc3BsYXk6ZmxleDtib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6MTAwJTtmbGV4LWRpcmVjdGlvbjpyb3c7YWxpZ24taXRlbXM6Y2VudGVyO3doaXRlLXNwYWNlOm5vd3JhcH0ubWF0LXRvb2xiYXJ7bWluLWhlaWdodDo2NHB4fS5tYXQtdG9vbGJhci1yb3d7aGVpZ2h0OjY0cHh9QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpey5tYXQtdG9vbGJhcnttaW4taGVpZ2h0OjU2cHh9Lm1hdC10b29sYmFyLXJvd3toZWlnaHQ6NTZweH19XCJdLFxuICAgICAgICAgICAgICAgIGlucHV0czogWydjb2xvciddLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC10b29sYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAndG9vbGJhcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUb29sYmFyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbl07IH07XG52YXIgTWRUb29sYmFyTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sYmFyTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRUb29sYmFyTW9kdWxlO1xufSgpKTtcbk1kVG9vbGJhck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW01kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWRUb29sYmFyLCBNZFRvb2xiYXJSb3csIE1kQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFRvb2xiYXIsIE1kVG9vbGJhclJvd10sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVG9vbGJhck1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBUaW1lIGluIG1zIHRvIGRlbGF5IGJlZm9yZSBjaGFuZ2luZyB0aGUgdG9vbHRpcCB2aXNpYmlsaXR5IHRvIGhpZGRlblxuICovXG52YXIgVE9VQ0hFTkRfSElERV9ERUxBWSA9IDE1MDA7XG4vKipcbiAqIFRpbWUgaW4gbXMgdG8gdGhyb3R0bGUgcmVwb3NpdGlvbmluZyBhZnRlciBzY3JvbGwgZXZlbnRzLlxuICovXG52YXIgU0NST0xMX1RIUk9UVExFX01TID0gMjA7XG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3IgdG8gYmUgdGhyb3duIGlmIHRoZSB1c2VyIHN1cHBsaWVkIGFuIGludmFsaWQgdG9vbHRpcCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7P30gcG9zaXRpb25cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE1kVG9vbHRpcEludmFsaWRQb3NpdGlvbkVycm9yKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIEVycm9yKFwiVG9vbHRpcCBwb3NpdGlvbiBcXFwiXCIgKyBwb3NpdGlvbiArIFwiXFxcIiBpcyBpbnZhbGlkLlwiKTtcbn1cbi8qKlxuICogRGlyZWN0aXZlIHRoYXQgYXR0YWNoZXMgYSBtYXRlcmlhbCBkZXNpZ24gdG9vbHRpcCB0byB0aGUgaG9zdCBlbGVtZW50LiBBbmltYXRlcyB0aGUgc2hvd2luZyBhbmRcbiAqIGhpZGluZyBvZiBhIHRvb2x0aXAgcHJvdmlkZWQgcG9zaXRpb24gKGRlZmF1bHRzIHRvIGJlbG93IHRoZSBlbGVtZW50KS5cbiAqXG4gKiBodHRwczovL21hdGVyaWFsLmdvb2dsZS5jb20vY29tcG9uZW50cy90b29sdGlwcy5odG1sXG4gKi9cbnZhciBNZFRvb2x0aXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9vdmVybGF5XG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX3Njcm9sbERpc3BhdGNoZXJcbiAgICAgKiBAcGFyYW0gez99IF92aWV3Q29udGFpbmVyUmVmXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez99IF9wbGF0Zm9ybVxuICAgICAqIEBwYXJhbSB7P30gX2RpclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kVG9vbHRpcChfb3ZlcmxheSwgX2VsZW1lbnRSZWYsIF9zY3JvbGxEaXNwYXRjaGVyLCBfdmlld0NvbnRhaW5lclJlZiwgX25nWm9uZSwgX3JlbmRlcmVyLCBfcGxhdGZvcm0sIF9kaXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fb3ZlcmxheSA9IF9vdmVybGF5O1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3Njcm9sbERpc3BhdGNoZXIgPSBfc2Nyb2xsRGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gJ2JlbG93JztcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGRlbGF5IGluIG1zIGJlZm9yZSBzaG93aW5nIHRoZSB0b29sdGlwIGFmdGVyIHNob3cgaXMgY2FsbGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dEZWxheSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBkZWxheSBpbiBtcyBiZWZvcmUgaGlkaW5nIHRoZSB0b29sdGlwIGFmdGVyIGhpZGUgaXMgY2FsbGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpZGVEZWxheSA9IDA7XG4gICAgICAgIC8vIFRoZSBtb3VzZSBldmVudHMgc2hvdWxkbid0IGJlIGJvdW5kIG9uIGlPUyBkZXZpY2VzLCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZXkgY2FuIHByZXZlbnQgdGhlIGZpcnN0IHRhcCBmcm9tIGZpcmluZyBpdHMgY2xpY2sgZXZlbnQuXG4gICAgICAgIGlmICghX3BsYXRmb3JtLklPUykge1xuICAgICAgICAgICAgX3JlbmRlcmVyLmxpc3RlbihfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNob3coKTsgfSk7XG4gICAgICAgICAgICBfcmVuZGVyZXIubGlzdGVuKF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaGlkZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcG9zaXRpb247IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmRyZXdqcyk6IFdoZW4gdGhlIG92ZXJsYXkncyBwb3NpdGlvbiBjYW4gYmUgZHluYW1pY2FsbHkgY2hhbmdlZCwgZG8gbm90IGRlc3Ryb3lcbiAgICAgICAgICAgICAgICAvLyB0aGUgdG9vbHRpcC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGlzcGxheSBvZiB0aGUgdG9vbHRpcC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICAgICAgLy8gSWYgdG9vbHRpcCBpcyBkaXNhYmxlZCwgaGlkZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX3Bvc2l0aW9uRGVwcmVjYXRlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wb3NpdGlvbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2U7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2V0VG9vbHRpcE1lc3NhZ2UodGhpcy5fbWVzc2FnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcInRvb2x0aXBDbGFzc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGFzc2VzIHRvIGJlIHBhc3NlZCB0byB0aGUgdG9vbHRpcC4gU3VwcG9ydHMgdGhlIHNhbWUgc3ludGF4IGFzIGBuZ0NsYXNzYC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdG9vbHRpcENsYXNzOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBDbGFzcyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFRvb2x0aXBDbGFzcyh0aGlzLl90b29sdGlwQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfZGVwcmVjYXRlZE1lc3NhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZXNzYWdlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMubWVzc2FnZSA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9tYXRNZXNzYWdlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1lc3NhZ2UgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0UG9zaXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wb3NpdGlvbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLnBvc2l0aW9uID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX21hdERpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5kaXNhYmxlZCA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9tYXRIaWRlRGVsYXlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5oaWRlRGVsYXk7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5oaWRlRGVsYXkgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0U2hvd0RlbGF5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc2hvd0RlbGF5OyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuc2hvd0RlbGF5ID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX21hdENsYXNzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudG9vbHRpcENsYXNzOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMudG9vbHRpcENsYXNzID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB0aGUgdG9vbHRpcCB3aGVuIGRlc3Ryb3llZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSB0b29sdGlwIGFmdGVyIHRoZSBkZWxheSBpbiBtcywgZGVmYXVsdHMgdG8gdG9vbHRpcC1kZWxheS1zaG93IG9yIDBtcyBpZiBubyBpbnB1dFxuICAgICAqIEBwYXJhbSB7Pz19IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSB0aGlzLnNob3dEZWxheTsgfVxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAhdGhpcy5fbWVzc2FnZSB8fCAhdGhpcy5fbWVzc2FnZS50cmltKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlVG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFRvb2x0aXBDbGFzcyh0aGlzLl90b29sdGlwQ2xhc3MpO1xuICAgICAgICB0aGlzLl9zZXRUb29sdGlwTWVzc2FnZSh0aGlzLl9tZXNzYWdlKTsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAoKHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkpLnNob3codGhpcy5fcG9zaXRpb24sIGRlbGF5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSB0b29sdGlwIGFmdGVyIHRoZSBkZWxheSBpbiBtcywgZGVmYXVsdHMgdG8gdG9vbHRpcC1kZWxheS1oaWRlIG9yIDBtcyBpZiBubyBpbnB1dFxuICAgICAqIEBwYXJhbSB7Pz19IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSB0aGlzLmhpZGVEZWxheTsgfVxuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UuaGlkZShkZWxheSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNob3dzL2hpZGVzIHRoZSB0b29sdGlwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNUb29sdGlwVmlzaWJsZSgpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9vbHRpcCBpcyBjdXJyZW50bHkgdmlzaWJsZSB0byB0aGUgdXNlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5faXNUb29sdGlwVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdG9vbHRpcEluc3RhbmNlICYmIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5pc1Zpc2libGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgdG9vbHRpcCB0byBkaXNwbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLl9jcmVhdGVUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5UmVmID0gdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3J0YWwgPSBuZXcgQ29tcG9uZW50UG9ydGFsKFRvb2x0aXBDb21wb25lbnQsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UgPSBvdmVybGF5UmVmLmF0dGFjaChwb3J0YWwpLmluc3RhbmNlOyAvKiogQHR5cGUgez99ICovXG4gICAgICAgICgoXG4gICAgICAgIC8vIERpc3Bvc2UgdGhlIG92ZXJsYXkgd2hlbiBmaW5pc2hlZCB0aGUgc2hvd24gdG9vbHRpcC5cbiAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlKSkuYWZ0ZXJIaWRkZW4oKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZmlyc3QgaWYgdGhlIHRvb2x0aXAgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIHRocm91Z2ggdGhpcyBjb21wb25lbnRzIGRlc3Ryb3kuXG4gICAgICAgICAgICBpZiAoX3RoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwb3NlVG9vbHRpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgb3ZlcmxheSBjb25maWcgYW5kIHBvc2l0aW9uIHN0cmF0ZWd5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW4oKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zaXRpb24gPSB0aGlzLl9nZXRPdmVybGF5UG9zaXRpb24oKTtcbiAgICAgICAgLy8gQ3JlYXRlIGNvbm5lY3RlZCBwb3NpdGlvbiBzdHJhdGVneSB0aGF0IGxpc3RlbnMgZm9yIHNjcm9sbCBldmVudHMgdG8gcmVwb3NpdGlvbi5cbiAgICAgICAgLy8gQWZ0ZXIgcG9zaXRpb24gY2hhbmdlcyBvY2N1ciBhbmQgdGhlIG92ZXJsYXkgaXMgY2xpcHBlZCBieSBhIHBhcmVudCBzY3JvbGxhYmxlIHRoZW5cbiAgICAgICAgLy8gY2xvc2UgdGhlIHRvb2x0aXAuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpLmNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnRSZWYsIG9yaWdpbiwgcG9zaXRpb24pO1xuICAgICAgICBzdHJhdGVneS53aXRoU2Nyb2xsYWJsZUNvbnRhaW5lcnModGhpcy5fc2Nyb2xsRGlzcGF0Y2hlci5nZXRTY3JvbGxDb250YWluZXJzKHRoaXMuX2VsZW1lbnRSZWYpKTtcbiAgICAgICAgc3RyYXRlZ3kub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5zY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMuaXNPdmVybGF5Q2xpcHBlZCAmJlxuICAgICAgICAgICAgICAgIF90aGlzLl90b29sdGlwSW5zdGFuY2UgJiYgX3RoaXMuX3Rvb2x0aXBJbnN0YW5jZS5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25maWcgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIGNvbmZpZy5kaXJlY3Rpb24gPSB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICAgICAgY29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgY29uZmlnLnNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oe1xuICAgICAgICAgICAgc2Nyb2xsVGhyb3R0bGU6IFNDUk9MTF9USFJPVFRMRV9NU1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5UmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhlIGN1cnJlbnQgdG9vbHRpcCBhbmQgdGhlIG92ZXJsYXkgaXQgaXMgYXR0YWNoZWQgdG9cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX2Rpc3Bvc2VUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UgPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb3JpZ2luIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSB1c2VyJ3MgcG9zaXRpb24gcHJlZmVyZW5jZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fZ2V0T3JpZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAnYWJvdmUnIHx8IHRoaXMucG9zaXRpb24gPT0gJ2JlbG93Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2NlbnRlcicsIG9yaWdpblk6IHRoaXMucG9zaXRpb24gPT0gJ2Fib3ZlJyA/ICd0b3AnIDogJ2JvdHRvbScgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0RpcmVjdGlvbkx0ciA9ICF0aGlzLl9kaXIgfHwgdGhpcy5fZGlyLnZhbHVlID09ICdsdHInO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAnbGVmdCcgfHxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2JlZm9yZScgJiYgaXNEaXJlY3Rpb25MdHIgfHxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2FmdGVyJyAmJiAhaXNEaXJlY3Rpb25MdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdjZW50ZXInIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ3JpZ2h0JyB8fFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYWZ0ZXInICYmIGlzRGlyZWN0aW9uTHRyIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdiZWZvcmUnICYmICFpc0RpcmVjdGlvbkx0cikge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICdjZW50ZXInIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZ2V0TWRUb29sdGlwSW52YWxpZFBvc2l0aW9uRXJyb3IodGhpcy5wb3NpdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVybGF5IHBvc2l0aW9uIGJhc2VkIG9uIHRoZSB1c2VyJ3MgcHJlZmVyZW5jZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fZ2V0T3ZlcmxheVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAnYWJvdmUnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ2NlbnRlcicsIG92ZXJsYXlZOiAnYm90dG9tJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09ICdiZWxvdycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnY2VudGVyJywgb3ZlcmxheVk6ICd0b3AnIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNMdHIgPSAhdGhpcy5fZGlyIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJztcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ2xlZnQnIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdiZWZvcmUnICYmIGlzTHRyIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdhZnRlcicgJiYgIWlzTHRyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09ICdyaWdodCcgfHxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2FmdGVyJyAmJiBpc0x0ciB8fFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYmVmb3JlJyAmJiAhaXNMdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2NlbnRlcicgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBnZXRNZFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvcih0aGlzLnBvc2l0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRvb2x0aXAgbWVzc2FnZSBhbmQgcmVwb3NpdGlvbnMgdGhlIG92ZXJsYXkgYWNjb3JkaW5nIHRvIHRoZSBuZXcgbWVzc2FnZSBsZW5ndGhcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX3NldFRvb2x0aXBNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTXVzdCB3YWl0IGZvciB0aGUgbWVzc2FnZSB0byBiZSBwYWludGVkIHRvIHRoZSB0b29sdGlwIHNvIHRoYXQgdGhlIG92ZXJsYXkgY2FuIHByb3Blcmx5XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCBwb3NpdGlvbmluZyBiYXNlZCBvbiB0aGUgc2l6ZSBvZiB0aGUgdGV4dC5cbiAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLl9tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIGZpcnN0LmNhbGwodGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgKChfdGhpcy5fb3ZlcmxheVJlZikpLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRvb2x0aXAgY2xhc3NcbiAgICAgKiBAcGFyYW0gez99IHRvb2x0aXBDbGFzc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fc2V0VG9vbHRpcENsYXNzID0gZnVuY3Rpb24gKHRvb2x0aXBDbGFzcykge1xuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UudG9vbHRpcENsYXNzID0gdG9vbHRpcENsYXNzO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLl9tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kVG9vbHRpcDtcbn0oKSk7XG5NZFRvb2x0aXAuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC10b29sdGlwXSwgW21kVG9vbHRpcF0sIFttYXQtdG9vbHRpcF0sIFttYXRUb29sdGlwXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnKGxvbmdwcmVzcyknOiAnc2hvdygpJyxcbiAgICAgICAgICAgICAgICAgICAgJyh0b3VjaGVuZCknOiAnaGlkZSgnICsgVE9VQ0hFTkRfSElERV9ERUxBWSArICcpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRUb29sdGlwJyxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUb29sdGlwLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogT3ZlcmxheSwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBTY3JvbGxEaXNwYXRjaGVyLCB9LFxuICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCB9LFxuICAgIHsgdHlwZTogRGlyZWN0aW9uYWxpdHksIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbk1kVG9vbHRpcC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAncG9zaXRpb24nOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFRvb2x0aXBQb3NpdGlvbicsXSB9LF0sXG4gICAgJ2Rpc2FibGVkJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWRUb29sdGlwRGlzYWJsZWQnLF0gfSxdLFxuICAgICdfcG9zaXRpb25EZXByZWNhdGVkJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsndG9vbHRpcC1wb3NpdGlvbicsXSB9LF0sXG4gICAgJ3Nob3dEZWxheSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kVG9vbHRpcFNob3dEZWxheScsXSB9LF0sXG4gICAgJ2hpZGVEZWxheSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kVG9vbHRpcEhpZGVEZWxheScsXSB9LF0sXG4gICAgJ21lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFRvb2x0aXAnLF0gfSxdLFxuICAgICd0b29sdGlwQ2xhc3MnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFRvb2x0aXBDbGFzcycsXSB9LF0sXG4gICAgJ19kZXByZWNhdGVkTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kLXRvb2x0aXAnLF0gfSxdLFxuICAgICdfbWF0TWVzc2FnZSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21hdFRvb2x0aXAnLF0gfSxdLFxuICAgICdfbWF0UG9zaXRpb24nOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXRUb29sdGlwUG9zaXRpb24nLF0gfSxdLFxuICAgICdfbWF0RGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXRUb29sdGlwRGlzYWJsZWQnLF0gfSxdLFxuICAgICdfbWF0SGlkZURlbGF5JzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0VG9vbHRpcEhpZGVEZWxheScsXSB9LF0sXG4gICAgJ19tYXRTaG93RGVsYXknOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXRUb29sdGlwU2hvd0RlbGF5JyxdIH0sXSxcbiAgICAnX21hdENsYXNzJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0VG9vbHRpcENsYXNzJyxdIH0sXSxcbn07XG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCB0aGF0IHdyYXBzIHRoZSB0b29sdGlwJ3MgY29udGVudC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgVG9vbHRpcENvbXBvbmVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2RpclxuICAgICAqIEBwYXJhbSB7P30gX2NoYW5nZURldGVjdG9yUmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9vbHRpcENvbXBvbmVudChfZGlyLCBfY2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYgPSBfY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0eSB3YXRjaGVkIGJ5IHRoZSBhbmltYXRpb24gZnJhbWV3b3JrIHRvIHNob3cgb3IgaGlkZSB0aGUgdG9vbHRpcFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eSA9ICdpbml0aWFsJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgaW50ZXJhY3Rpb25zIG9uIHRoZSBwYWdlIHNob3VsZCBjbG9zZSB0aGUgdG9vbHRpcFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2xvc2VPbkludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJhbnNmb3JtIG9yaWdpbiB1c2VkIGluIHRoZSBhbmltYXRpb24gZm9yIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgdG9vbHRpcFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ2JvdHRvbSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhhdCB0aGUgdG9vbHRpcCBoYXMgYmVlbiBoaWRkZW4gZnJvbSB0aGUgdmlld1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25IaWRlID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHRvb2x0aXAgd2l0aCBhbiBhbmltYXRpb24gb3JpZ2luYXRpbmcgZnJvbSB0aGUgcHJvdmlkZWQgb3JpZ2luXG4gICAgICogQHBhcmFtIHs/fSBwb3NpdGlvbiBQb3NpdGlvbiBvZiB0aGUgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0gez99IGRlbGF5IEFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGRlbGF5IHNob3dpbmcgdGhlIHRvb2x0aXAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBkZWxheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGRlbGF5ZWQgaGlkZSBpZiBpdCBpcyBzY2hlZHVsZWRcbiAgICAgICAgaWYgKHRoaXMuX2hpZGVUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCb2R5IGludGVyYWN0aW9ucyBzaG91bGQgY2FuY2VsIHRoZSB0b29sdGlwIGlmIHRoZXJlIGlzIGEgZGVsYXkgaW4gc2hvd2luZy5cbiAgICAgICAgdGhpcy5fY2xvc2VPbkludGVyYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2V0VHJhbnNmb3JtT3JpZ2luKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fc2hvd1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3Zpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBzZXQgdG8gdHJ1ZSBpbW1lZGlhdGVseSwgdGhlbiBhIGJvZHkgY2xpY2sgdGhhdCB0cmlnZ2VycyBzaG93KCkgd291bGRcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgaW50ZXJhY3Rpb24gYW5kIGNsb3NlIHRoZSB0b29sdGlwIHJpZ2h0IGFmdGVyIGl0IHdhcyBkaXNwbGF5ZWQuXG4gICAgICAgICAgICBfdGhpcy5fY2xvc2VPbkludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBNYXJrIGZvciBjaGVjayBzbyBpZiBhbnkgcGFyZW50IGNvbXBvbmVudCBoYXMgc2V0IHRoZVxuICAgICAgICAgICAgLy8gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgdG8gT25QdXNoIGl0IHdpbGwgYmUgY2hlY2tlZCBhbnl3YXlzXG4gICAgICAgICAgICBfdGhpcy5fbWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jbG9zZU9uSW50ZXJhY3Rpb24gPSB0cnVlOyB9LCAwKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmVnaW5zIHRoZSBhbmltYXRpb24gdG8gaGlkZSB0aGUgdG9vbHRpcCBhZnRlciB0aGUgcHJvdmlkZWQgZGVsYXkgaW4gbXMuXG4gICAgICogQHBhcmFtIHs/fSBkZWxheSBBbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IHNob3dpbmcgdGhlIHRvb2x0aXAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgZGVsYXllZCBzaG93IGlmIGl0IGlzIHNjaGVkdWxlZFxuICAgICAgICBpZiAodGhpcy5fc2hvd1RpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl92aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBfdGhpcy5fY2xvc2VPbkludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBNYXJrIGZvciBjaGVjayBzbyBpZiBhbnkgcGFyZW50IGNvbXBvbmVudCBoYXMgc2V0IHRoZVxuICAgICAgICAgICAgLy8gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgdG8gT25QdXNoIGl0IHdpbGwgYmUgY2hlY2tlZCBhbnl3YXlzXG4gICAgICAgICAgICBfdGhpcy5fbWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IG5vdGlmaWVzIHdoZW4gdGhlIHRvb2x0aXAgaGFzIGJlZW4gaGlkZGVuIGZyb20gdmlld1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuYWZ0ZXJIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkhpZGUuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB0b29sdGlwIGlzIGJlaW5nIGRpc3BsYXllZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJpbGl0eSA9PT0gJ3Zpc2libGUnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdG9vbHRpcCB0cmFuc2Zvcm0gb3JpZ2luIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLl9zZXRUcmFuc2Zvcm1PcmlnaW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNMdHIgPSAhdGhpcy5fZGlyIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJztcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSBpc0x0ciA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhZnRlcic6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gaXNMdHIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhYm92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBnZXRNZFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuX2FmdGVyVmlzaWJpbGl0eUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RhdGUgPT09ICdoaWRkZW4nICYmICF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkhpZGUubmV4dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcmFjdGlvbnMgb24gdGhlIEhUTUwgYm9keSBzaG91bGQgY2xvc2UgdGhlIHRvb2x0aXAgaW1tZWRpYXRlbHkgYXMgZGVmaW5lZCBpbiB0aGVcbiAgICAgKiBtYXRlcmlhbCBkZXNpZ24gc3BlYy5cbiAgICAgKiBodHRwczovL21hdGVyaWFsLmdvb2dsZS5jb20vY29tcG9uZW50cy90b29sdGlwcy5odG1sI3Rvb2x0aXBzLWludGVyYWN0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZS5faGFuZGxlQm9keUludGVyYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VPbkludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoYXQgdGhlIHRvb2x0aXAgbmVlZHMgdG8gYmUgY2hlY2tlZCBpbiB0aGUgbmV4dCBjaGFuZ2UgZGV0ZWN0aW9uIHJ1bi5cbiAgICAgKiBNYWlubHkgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBpbml0aWFsIHRleHQgYmVmb3JlIHBvc2l0aW9uaW5nIGEgdG9vbHRpcCwgd2hpY2hcbiAgICAgKiBjYW4gYmUgcHJvYmxlbWF0aWMgaW4gY29tcG9uZW50cyB3aXRoIE9uUHVzaCBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuX21hcmtGb3JDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbHRpcENvbXBvbmVudDtcbn0oKSk7XG5Ub29sdGlwQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtdG9vbHRpcC1jb21wb25lbnQsIG1hdC10b29sdGlwLWNvbXBvbmVudCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXRvb2x0aXBcXFwiIFtuZ0NsYXNzXT1cXFwidG9vbHRpcENsYXNzXFxcIiBbc3R5bGUudHJhbnNmb3JtLW9yaWdpbl09XFxcIl90cmFuc2Zvcm1PcmlnaW5cXFwiIFtAc3RhdGVdPVxcXCJfdmlzaWJpbGl0eVxcXCIgKEBzdGF0ZS5kb25lKT1cXFwiX2FmdGVyVmlzaWJpbGl0eUFuaW1hdGlvbigkZXZlbnQpXFxcIj57e21lc3NhZ2V9fTwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7cG9pbnRlci1ldmVudHM6bm9uZX0ubWF0LXRvb2x0aXB7Y29sb3I6I2ZmZjtib3JkZXItcmFkaXVzOjJweDttYXJnaW46MTRweDttYXgtd2lkdGg6MjUwcHg7cGFkZGluZy1sZWZ0OjhweDtwYWRkaW5nLXJpZ2h0OjhweH1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LXRvb2x0aXB7b3V0bGluZTpzb2xpZCAxcHh9fVwiXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcignc3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgndm9pZCcsIHN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdpbml0aWFsJywgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ3Zpc2libGUnLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDEpJyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgnaGlkZGVuJywgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiB2aXNpYmxlJywgYW5pbWF0ZSgnMTUwbXMgY3ViaWMtYmV6aWVyKDAuMCwgMC4wLCAwLjIsIDEpJykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiBoaWRkZW4nLCBhbmltYXRlKCcxNTBtcyBjdWJpYy1iZXppZXIoMC40LCAwLjAsIDEsIDEpJykpLFxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhIGxheW91dCBpbiBJRSBhbmQgRWRnZS4gVGhpcyBmaXhlcyBpc3N1ZXMgd2hlcmUgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gd29uJ3QgYmUgcmVuZGVyZWQgaWYgdGhlIGFuaW1hdGlvbnMgYXJlIGRpc2FibGVkIG9yIHRoZXJlIGlzIG5vIHdlYiBhbmltYXRpb25zIHBvbHlmaWxsLlxuICAgICAgICAgICAgICAgICAgICAnW3N0eWxlLnpvb21dJzogJ192aXNpYmlsaXR5ID09PSBcInZpc2libGVcIiA/IDEgOiBudWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJyhib2R5OmNsaWNrKSc6ICd0aGlzLl9oYW5kbGVCb2R5SW50ZXJhY3Rpb24oKSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblRvb2x0aXBDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBEaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiwgfSxcbl07IH07XG52YXIgTWRUb29sdGlwTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sdGlwTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRUb29sdGlwTW9kdWxlO1xufSgpKTtcbk1kVG9vbHRpcE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBQbGF0Zm9ybU1vZHVsZVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kVG9vbHRpcCwgVG9vbHRpcENvbXBvbmVudCwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kVG9vbHRpcCwgVG9vbHRpcENvbXBvbmVudF0sXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbVG9vbHRpcENvbXBvbmVudF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kVG9vbHRpcE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGZvciB0aGUgY2FzZSB3aGVuIG1lbnUgdHJpZ2dlciBkb2Vzbid0IGhhdmUgYSB2YWxpZCBtZC1tZW51IGluc3RhbmNlXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRocm93TWRNZW51TWlzc2luZ0Vycm9yKCkge1xuICAgIHRocm93IEVycm9yKFwibWQtbWVudS10cmlnZ2VyOiBtdXN0IHBhc3MgaW4gYW4gbWQtbWVudSBpbnN0YW5jZS5cXG5cXG4gICAgRXhhbXBsZTpcXG4gICAgICA8bWQtbWVudSAjbWVudT1cXFwibWRNZW51XFxcIj48L21kLW1lbnU+XFxuICAgICAgPGJ1dHRvbiBbbWRNZW51VHJpZ2dlckZvcl09XFxcIm1lbnVcXFwiPjwvYnV0dG9uPlwiKTtcbn1cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIGNhc2Ugd2hlbiBtZW51J3MgeC1wb3NpdGlvbiB2YWx1ZSBpc24ndCB2YWxpZC5cbiAqIEluIG90aGVyIHdvcmRzLCBpdCBkb2Vzbid0IG1hdGNoICdiZWZvcmUnIG9yICdhZnRlcicuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRocm93TWRNZW51SW52YWxpZFBvc2l0aW9uWCgpIHtcbiAgICB0aHJvdyBFcnJvcihcIngtcG9zaXRpb24gdmFsdWUgbXVzdCBiZSBlaXRoZXIgJ2JlZm9yZScgb3IgYWZ0ZXInLlxcbiAgICAgIEV4YW1wbGU6IDxtZC1tZW51IHgtcG9zaXRpb249XFxcImJlZm9yZVxcXCIgI21lbnU9XFxcIm1kTWVudVxcXCI+PC9tZC1tZW51PlwiKTtcbn1cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIGNhc2Ugd2hlbiBtZW51J3MgeS1wb3NpdGlvbiB2YWx1ZSBpc24ndCB2YWxpZC5cbiAqIEluIG90aGVyIHdvcmRzLCBpdCBkb2Vzbid0IG1hdGNoICdhYm92ZScgb3IgJ2JlbG93Jy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGhyb3dNZE1lbnVJbnZhbGlkUG9zaXRpb25ZKCkge1xuICAgIHRocm93IEVycm9yKFwieS1wb3NpdGlvbiB2YWx1ZSBtdXN0IGJlIGVpdGhlciAnYWJvdmUnIG9yIGJlbG93Jy5cXG4gICAgICBFeGFtcGxlOiA8bWQtbWVudSB5LXBvc2l0aW9uPVxcXCJhYm92ZVxcXCIgI21lbnU9XFxcIm1kTWVudVxcXCI+PC9tZC1tZW51PlwiKTtcbn1cbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZE1lbnVJdGVtQmFzZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTWVudUl0ZW1CYXNlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRNZW51SXRlbUJhc2U7XG59KCkpO1xudmFyIF9NZE1lbnVJdGVtTWl4aW5CYXNlID0gbWl4aW5EaXNhYmxlZChNZE1lbnVJdGVtQmFzZSk7XG4vKipcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW5zaWRlIGFuIG1kLW1lbnUgdGFnLlxuICogSXQgZXhpc3RzIG1vc3RseSB0byBzZXQgdGhlIHJvbGUgYXR0cmlidXRlLlxuICovXG52YXIgTWRNZW51SXRlbSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kTWVudUl0ZW0sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kTWVudUl0ZW0oX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBtZW51IGl0ZW0uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVJdGVtLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ2V0SG9zdEVsZW1lbnQoKS5mb2N1cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzZXQgdGhlIGB0YWJpbmRleGAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVJdGVtLnByb3RvdHlwZS5fZ2V0VGFiSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gJy0xJyA6ICcwJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhvc3QgRE9NIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVJdGVtLnByb3RvdHlwZS5fZ2V0SG9zdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBlbGVtZW50IGFjdGlvbnMgaWYgaXQgaXMgZGlzYWJsZWQuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51SXRlbS5wcm90b3R5cGUuX2NoZWNrRGlzYWJsZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kTWVudUl0ZW07XG59KF9NZE1lbnVJdGVtTWl4aW5CYXNlKSk7XG5NZE1lbnVJdGVtLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21kLW1lbnUtaXRlbV0sIFttYXQtbWVudS1pdGVtXScsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2Rpc2FibGVkJ10sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdtZW51aXRlbScsXG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtbWVudS1pdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLnRhYmluZGV4XSc6ICdfZ2V0VGFiSW5kZXgoKScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdkaXNhYmxlZC50b1N0cmluZygpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmRpc2FibGVkXSc6ICdkaXNhYmxlZCB8fCBudWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJyhjbGljayknOiAnX2NoZWNrRGlzYWJsZWQoJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+PGRpdiBjbGFzcz1cXFwibWF0LW1lbnUtcmlwcGxlXFxcIiAqbmdJZj1cXFwiIWRpc2FibGVkXFxcIiBtZC1yaXBwbGUgW21kUmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21kTWVudUl0ZW0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTWVudUl0ZW0uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuXTsgfTtcbi8qKlxuICogQmVsb3cgYXJlIGFsbCB0aGUgYW5pbWF0aW9ucyBmb3IgdGhlIG1kLW1lbnUgY29tcG9uZW50LlxuICogQW5pbWF0aW9uIGR1cmF0aW9uIGFuZCB0aW1pbmcgdmFsdWVzIGFyZSBiYXNlZCBvbiBBbmd1bGFySlMgTWF0ZXJpYWwuXG4gKi9cbi8qKlxuICogVGhpcyBhbmltYXRpb24gY29udHJvbHMgdGhlIG1lbnUgcGFuZWwncyBlbnRyeSBhbmQgZXhpdCBmcm9tIHRoZSBwYWdlLlxuICpcbiAqIFdoZW4gdGhlIG1lbnUgcGFuZWwgaXMgYWRkZWQgdG8gdGhlIERPTSwgaXQgc2NhbGVzIGluIGFuZCBmYWRlcyBpbiBpdHMgYm9yZGVyLlxuICpcbiAqIFdoZW4gdGhlIG1lbnUgcGFuZWwgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00sIGl0IHNpbXBseSBmYWRlcyBvdXQgYWZ0ZXIgYSBicmllZlxuICogZGVsYXkgdG8gZGlzcGxheSB0aGUgcmlwcGxlLlxuICovXG4vLyBUT0RPKGthcmEpOiBzd2l0Y2ggdG8gOmVudGVyIGFuZCA6bGVhdmUgb25jZSBNb2JpbGUgU2FmYXJpIGlzIHNvcnRlZCBvdXQuXG52YXIgdHJhbnNmb3JtTWVudSA9IHRyaWdnZXIoJ3RyYW5zZm9ybU1lbnUnLCBbXG4gICAgc3RhdGUoJ3Nob3dpbmcnLCBzdHlsZSh7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiXG4gICAgfSkpLFxuICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtcbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwKVwiXG4gICAgICAgIH0pLFxuICAgICAgICBhbmltYXRlKFwiMjAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSlcIilcbiAgICBdKSxcbiAgICB0cmFuc2l0aW9uKCcqID0+IHZvaWQnLCBbXG4gICAgICAgIGFuaW1hdGUoJzUwbXMgMTAwbXMgbGluZWFyJywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKVxuICAgIF0pXG5dKTtcbi8qKlxuICogVGhpcyBhbmltYXRpb24gZmFkZXMgaW4gdGhlIGJhY2tncm91bmQgY29sb3IgYW5kIGNvbnRlbnQgb2YgdGhlIG1lbnUgcGFuZWxcbiAqIGFmdGVyIGl0cyBjb250YWluaW5nIGVsZW1lbnQgaXMgc2NhbGVkIGluLlxuICovXG52YXIgZmFkZUluSXRlbXMgPSB0cmlnZ2VyKCdmYWRlSW5JdGVtcycsIFtcbiAgICBzdGF0ZSgnc2hvd2luZycsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSksXG4gICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW1xuICAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICAgIGFuaW1hdGUoXCIyMDBtcyAxMDBtcyBjdWJpYy1iZXppZXIoMC41NSwgMCwgMC41NSwgMC4yKVwiKVxuICAgIF0pXG5dKTtcbnZhciBNZE1lbnUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRNZW51KF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5feFBvc2l0aW9uID0gJ2FmdGVyJztcbiAgICAgICAgdGhpcy5feVBvc2l0aW9uID0gJ2JlbG93JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZyBvYmplY3QgdG8gYmUgcGFzc2VkIGludG8gdGhlIG1lbnUncyBuZ0NsYXNzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3QgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIG1lbnUgc2hvdWxkIG92ZXJsYXAgaXRzIHRyaWdnZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm92ZXJsYXBUcmlnZ2VyID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgbWVudSBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51LnByb3RvdHlwZSwgXCJ4UG9zaXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUG9zaXRpb24gb2YgdGhlIG1lbnUgaW4gdGhlIFggYXhpcy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5feFBvc2l0aW9uOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJ2JlZm9yZScgJiYgdmFsdWUgIT09ICdhZnRlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvd01kTWVudUludmFsaWRQb3NpdGlvblgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hQb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudS5wcm90b3R5cGUsIFwieVBvc2l0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvc2l0aW9uIG9mIHRoZSBtZW51IGluIHRoZSBZIGF4aXMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3lQb3NpdGlvbjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICdhYm92ZScgJiYgdmFsdWUgIT09ICdiZWxvdycpIHtcbiAgICAgICAgICAgICAgICB0aHJvd01kTWVudUludmFsaWRQb3NpdGlvblkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3lQb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudS5wcm90b3R5cGUsIFwiY2xhc3NMaXN0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGNsYXNzZXMgc2V0IG9uIHRoZSBob3N0IG1kLW1lbnUgZWxlbWVudCBhbmQgYXBwbGllcyB0aGVtIG9uIHRoZVxuICAgICAgICAgKiBtZW51IHRlbXBsYXRlIHRoYXQgZGlzcGxheXMgaW4gdGhlIG92ZXJsYXkgY29udGFpbmVyLiAgT3RoZXJ3aXNlLCBpdCdzIGRpZmZpY3VsdFxuICAgICAgICAgKiB0byBzdHlsZSB0aGUgY29udGFpbmluZyBtZW51IGZyb20gb3V0c2lkZSB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiBAcGFyYW0gez99IGNsYXNzZXMgbGlzdCBvZiBjbGFzcyBuYW1lc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgaWYgKGNsYXNzZXMgJiYgY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGFzc0xpc3QgPSBjbGFzc2VzLnNwbGl0KCcgJykucmVkdWNlKGZ1bmN0aW9uIChvYmosIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbY2xhc3NOYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc05hbWUgPSAnJztcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEZvY3VzS2V5TWFuYWdlcih0aGlzLml0ZW1zKS53aXRoV3JhcCgpO1xuICAgICAgICB0aGlzLl90YWJTdWJzY3JpcHRpb24gPSB0aGlzLl9rZXlNYW5hZ2VyLnRhYk91dC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2VtaXRDbG9zZUV2ZW50KCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdGFiU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEga2V5Ym9hcmQgZXZlbnQgZnJvbSB0aGUgbWVudSwgZGVsZWdhdGluZyB0byB0aGUgYXBwcm9wcmlhdGUgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudS5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEVTQ0FQRTpcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0Q2xvc2VFdmVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5vbktleWRvd24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1cyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbWVudS4gVGhpcyBtZXRob2QgaXMgdXNlZCBieSB0aGUgbWVudSB0cmlnZ2VyXG4gICAgICogdG8gZm9jdXMgdGhlIGZpcnN0IGl0ZW0gd2hlbiB0aGUgbWVudSBpcyBvcGVuZWQgYnkgdGhlIEVOVEVSIGtleS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudS5wcm90b3R5cGUuZm9jdXNGaXJzdEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGVtaXRzIGEgY2xvc2UgZXZlbnQgdG8gd2hpY2ggdGhlIHRyaWdnZXIgaXMgc3Vic2NyaWJlZC4gV2hlbiBlbWl0dGVkLCB0aGVcbiAgICAgKiB0cmlnZ2VyIHdpbGwgY2xvc2UgdGhlIG1lbnUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnUucHJvdG90eXBlLl9lbWl0Q2xvc2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbG9zZS5lbWl0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJdCdzIG5lY2Vzc2FyeSB0byBzZXQgcG9zaXRpb24tYmFzZWQgY2xhc3NlcyB0byBlbnN1cmUgdGhlIG1lbnUgcGFuZWwgYW5pbWF0aW9uXG4gICAgICogZm9sZHMgb3V0IGZyb20gdGhlIGNvcnJlY3QgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Pz19IHBvc1hcbiAgICAgKiBAcGFyYW0gez89fSBwb3NZXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnUucHJvdG90eXBlLnNldFBvc2l0aW9uQ2xhc3NlcyA9IGZ1bmN0aW9uIChwb3NYLCBwb3NZKSB7XG4gICAgICAgIGlmIChwb3NYID09PSB2b2lkIDApIHsgcG9zWCA9IHRoaXMueFBvc2l0aW9uOyB9XG4gICAgICAgIGlmIChwb3NZID09PSB2b2lkIDApIHsgcG9zWSA9IHRoaXMueVBvc2l0aW9uOyB9XG4gICAgICAgIHRoaXMuX2NsYXNzTGlzdFsnbWF0LW1lbnUtYmVmb3JlJ10gPSBwb3NYID09PSAnYmVmb3JlJztcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydtYXQtbWVudS1hZnRlciddID0gcG9zWCA9PT0gJ2FmdGVyJztcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydtYXQtbWVudS1hYm92ZSddID0gcG9zWSA9PT0gJ2Fib3ZlJztcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydtYXQtbWVudS1iZWxvdyddID0gcG9zWSA9PT0gJ2JlbG93JztcbiAgICB9O1xuICAgIHJldHVybiBNZE1lbnU7XG59KCkpO1xuTWRNZW51LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtbWVudSwgbWF0LW1lbnUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy10ZW1wbGF0ZT48ZGl2IGNsYXNzPVxcXCJtYXQtbWVudS1wYW5lbFxcXCIgW25nQ2xhc3NdPVxcXCJfY2xhc3NMaXN0XFxcIiAoa2V5ZG93bik9XFxcIl9oYW5kbGVLZXlkb3duKCRldmVudClcXFwiIChjbGljayk9XFxcIl9lbWl0Q2xvc2VFdmVudCgpXFxcIiBbQHRyYW5zZm9ybU1lbnVdPVxcXCInc2hvd2luZydcXFwiIHJvbGU9XFxcIm1lbnVcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1tZW51LWNvbnRlbnRcXFwiIFtAZmFkZUluSXRlbXNdPVxcXCInc2hvd2luZydcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48L2Rpdj48L25nLXRlbXBsYXRlPlwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1tZW51LXBhbmVse2JveC1zaGFkb3c6MCA1cHggNXB4IC0zcHggcmdiYSgwLDAsMCwuMiksMCA4cHggMTBweCAxcHggcmdiYSgwLDAsMCwuMTQpLDAgM3B4IDE0cHggMnB4IHJnYmEoMCwwLDAsLjEyKTttaW4td2lkdGg6MTEycHg7bWF4LXdpZHRoOjI4MHB4O292ZXJmbG93OmF1dG87LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7bWF4LWhlaWdodDpjYWxjKDEwMHZoIC0gNDhweCl9Lm1hdC1tZW51LXBhbmVsLm1hdC1tZW51LWFmdGVyLm1hdC1tZW51LWJlbG93e3RyYW5zZm9ybS1vcmlnaW46bGVmdCB0b3B9Lm1hdC1tZW51LXBhbmVsLm1hdC1tZW51LWFmdGVyLm1hdC1tZW51LWFib3Zle3RyYW5zZm9ybS1vcmlnaW46bGVmdCBib3R0b219Lm1hdC1tZW51LXBhbmVsLm1hdC1tZW51LWJlZm9yZS5tYXQtbWVudS1iZWxvd3t0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0IHRvcH0ubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYmVmb3JlLm1hdC1tZW51LWFib3Zle3RyYW5zZm9ybS1vcmlnaW46cmlnaHQgYm90dG9tfVtkaXI9cnRsXSAubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYWZ0ZXIubWF0LW1lbnUtYmVsb3d7dHJhbnNmb3JtLW9yaWdpbjpyaWdodCB0b3B9W2Rpcj1ydGxdIC5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1hZnRlci5tYXQtbWVudS1hYm92ZXt0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0IGJvdHRvbX1bZGlyPXJ0bF0gLm1hdC1tZW51LXBhbmVsLm1hdC1tZW51LWJlZm9yZS5tYXQtbWVudS1iZWxvd3t0cmFuc2Zvcm0tb3JpZ2luOmxlZnQgdG9wfVtkaXI9cnRsXSAubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYmVmb3JlLm1hdC1tZW51LWFib3Zle3RyYW5zZm9ybS1vcmlnaW46bGVmdCBib3R0b219QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC1tZW51LXBhbmVse291dGxpbmU6c29saWQgMXB4fX0ubWF0LW1lbnUtY29udGVudHtwYWRkaW5nLXRvcDo4cHg7cGFkZGluZy1ib3R0b206OHB4fS5tYXQtbWVudS1pdGVtey13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtjdXJzb3I6cG9pbnRlcjtvdXRsaW5lOjA7Ym9yZGVyOm5vbmU7LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpcztkaXNwbGF5OmJsb2NrO2xpbmUtaGVpZ2h0OjQ4cHg7aGVpZ2h0OjQ4cHg7cGFkZGluZzowIDE2cHg7dGV4dC1hbGlnbjpsZWZ0O3RleHQtZGVjb3JhdGlvbjpub25lO3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtbWVudS1pdGVtW2Rpc2FibGVkXXtjdXJzb3I6ZGVmYXVsdH1bZGlyPXJ0bF0gLm1hdC1tZW51LWl0ZW17dGV4dC1hbGlnbjpyaWdodH0ubWF0LW1lbnUtaXRlbSAubWF0LWljb257bWFyZ2luLXJpZ2h0OjE2cHh9W2Rpcj1ydGxdIC5tYXQtbWVudS1pdGVtIC5tYXQtaWNvbnttYXJnaW4tbGVmdDoxNnB4O21hcmdpbi1yaWdodDowfWJ1dHRvbi5tYXQtbWVudS1pdGVte3dpZHRoOjEwMCV9Lm1hdC1tZW51LXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MH1cIl0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU1lbnUsXG4gICAgICAgICAgICAgICAgICAgIGZhZGVJbkl0ZW1zXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21kTWVudSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRNZW51LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbl07IH07XG5NZE1lbnUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3hQb3NpdGlvbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAneVBvc2l0aW9uJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd0ZW1wbGF0ZVJlZic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW1RlbXBsYXRlUmVmLF0gfSxdLFxuICAgICdpdGVtcyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01kTWVudUl0ZW0sXSB9LF0sXG4gICAgJ292ZXJsYXBUcmlnZ2VyJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdjbGFzc0xpc3QnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydjbGFzcycsXSB9LF0sXG4gICAgJ2Nsb3NlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG4vKipcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhbiBtZC1tZW51IHRhZy4gIEl0IGlzXG4gKiByZXNwb25zaWJsZSBmb3IgdG9nZ2xpbmcgdGhlIGRpc3BsYXkgb2YgdGhlIHByb3ZpZGVkIG1lbnUgaW5zdGFuY2UuXG4gKi9cbnZhciBNZE1lbnVUcmlnZ2VyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfb3ZlcmxheVxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IF92aWV3Q29udGFpbmVyUmVmXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRNZW51VHJpZ2dlcihfb3ZlcmxheSwgX2VsZW1lbnQsIF92aWV3Q29udGFpbmVyUmVmLCBfZGlyKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICB0aGlzLl9tZW51T3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vcGVuZWRCeU1vdXNlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgbWVudSBpcyBvcGVuZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uTWVudU9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgbWVudSBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uTWVudUNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwiX2RlcHJlY2F0ZWRNZE1lbnVUcmlnZ2VyRm9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVudTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1lbnUgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwiX2RlcHJlY2F0ZWRNYXRNZW51VHJpZ2dlckZvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1lbnU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5tZW51ID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIl9tYXRNZW51VHJpZ2dlckZvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1lbnU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5tZW51ID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NoZWNrTWVudSgpO1xuICAgICAgICB0aGlzLm1lbnUuY2xvc2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsb3NlTWVudSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZGVzdHJveU1lbnUoKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwibWVudU9wZW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgbWVudSBpcyBvcGVuLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tZW51T3BlbjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgbWVudSBiZXR3ZWVuIHRoZSBvcGVuIGFuZCBjbG9zZWQgc3RhdGVzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUudG9nZ2xlTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lbnVPcGVuID8gdGhpcy5jbG9zZU1lbnUoKSA6IHRoaXMub3Blbk1lbnUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBtZW51LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUub3Blbk1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWVudU9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKS5hdHRhY2godGhpcy5fcG9ydGFsKTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvQmFja2Ryb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRNZW51KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgbWVudS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLmNsb3NlTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRNZW51KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG1lbnUgZnJvbSB0aGUgRE9NLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuZGVzdHJveU1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW5VcFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbWVudSB0cmlnZ2VyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcImRpclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGNvbnRhaW5pbmcgYXBwLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBlbnN1cmVzIHRoYXQgdGhlIG1lbnUgY2xvc2VzIHdoZW4gdGhlIG92ZXJsYXkgYmFja2Ryb3AgaXMgY2xpY2tlZC5cbiAgICAgKiBXZSBkbyBub3QgdXNlIGZpcnN0KCkgaGVyZSBiZWNhdXNlIGRvaW5nIHNvIHdvdWxkIG5vdCBjYXRjaCBjbGlja3MgZnJvbSB3aXRoaW5cbiAgICAgKiB0aGUgbWVudSwgYW5kIGl0IHdvdWxkIGZhaWwgdG8gdW5zdWJzY3JpYmUgcHJvcGVybHkuIEluc3RlYWQsIHdlIHVuc3Vic2NyaWJlXG4gICAgICogZXhwbGljaXRseSB3aGVuIHRoZSBtZW51IGlzIGNsb3NlZCBvciBkZXN0cm95ZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5fc3Vic2NyaWJlVG9CYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uID0gdGhpcy5fb3ZlcmxheVJlZi5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tZW51Ll9lbWl0Q2xvc2VFdmVudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIG1lbnUgc3RhdGUgdG8gb3BlbiBhbmQgZm9jdXNlcyB0aGUgZmlyc3QgaXRlbSBpZlxuICAgICAqIHRoZSBtZW51IHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9pbml0TWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0SXNNZW51T3Blbih0cnVlKTtcbiAgICAgICAgLy8gU2hvdWxkIG9ubHkgc2V0IGZvY3VzIGlmIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLCBzbyBrZXlib2FyZCB1c2VycyBjYW5cbiAgICAgICAgLy8gY2FuIGVhc2lseSBuYXZpZ2F0ZSBtZW51IGl0ZW1zLiBBY2NvcmRpbmcgdG8gc3BlYywgbW91c2UgdXNlcnMgc2hvdWxkIG5vdFxuICAgICAgICAvLyBzZWUgdGhlIGZvY3VzIHN0eWxlLlxuICAgICAgICBpZiAoIXRoaXMuX29wZW5lZEJ5TW91c2UpIHtcbiAgICAgICAgICAgIHRoaXMubWVudS5mb2N1c0ZpcnN0SXRlbSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIG1lbnUgd2hlbiBpdCdzIGNsb3NlZCwgbW9zdCBpbXBvcnRhbnRseSByZXN0b3JpbmdcbiAgICAgKiBmb2N1cyB0byB0aGUgbWVudSB0cmlnZ2VyIGlmIHRoZSBtZW51IHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9yZXNldE1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldElzTWVudU9wZW4oZmFsc2UpO1xuICAgICAgICAvLyBGb2N1cyBvbmx5IG5lZWRzIHRvIGJlIHJlc2V0IHRvIHRoZSBob3N0IGVsZW1lbnQgaWYgdGhlIG1lbnUgd2FzIG9wZW5lZFxuICAgICAgICAvLyBieSB0aGUga2V5Ym9hcmQgYW5kIG1hbnVhbGx5IHNoaWZ0ZWQgdG8gdGhlIGZpcnN0IG1lbnUgaXRlbS5cbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWRCeU1vdXNlKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3BlbmVkQnlNb3VzZSA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc09wZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9zZXRJc01lbnVPcGVuID0gZnVuY3Rpb24gKGlzT3Blbikge1xuICAgICAgICB0aGlzLl9tZW51T3BlbiA9IGlzT3BlbjtcbiAgICAgICAgdGhpcy5fbWVudU9wZW4gPyB0aGlzLm9uTWVudU9wZW4uZW1pdCgpIDogdGhpcy5vbk1lbnVDbG9zZS5lbWl0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAgVGhpcyBtZXRob2QgY2hlY2tzIHRoYXQgYSB2YWxpZCBpbnN0YW5jZSBvZiBNZE1lbnUgaGFzIGJlZW4gcGFzc2VkIGludG9cbiAgICAgKiAgbWRNZW51VHJpZ2dlckZvci4gSWYgbm90LCBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2NoZWNrTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgIHRocm93TWRNZW51TWlzc2luZ0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqICBUaGlzIG1ldGhvZCBjcmVhdGVzIHRoZSBvdmVybGF5IGZyb20gdGhlIHByb3ZpZGVkIG1lbnUncyB0ZW1wbGF0ZSBhbmQgc2F2ZXMgaXRzXG4gICAgICogIE92ZXJsYXlSZWYgc28gdGhhdCBpdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSB3aGVuIG9wZW5NZW51IGlzIGNhbGxlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0aGlzLm1lbnUudGVtcGxhdGVSZWYsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gdGhpcy5fZ2V0T3ZlcmxheUNvbmZpZygpO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9Qb3NpdGlvbnMoLyoqIEB0eXBlIHs/fSAqLyAoY29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kpKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5UmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYnVpbGRzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBuZWVkZWQgdG8gY3JlYXRlIHRoZSBvdmVybGF5LCB0aGUgT3ZlcmxheVN0YXRlLlxuICAgICAqIEByZXR1cm4gez99IE92ZXJsYXlTdGF0ZVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9nZXRPdmVybGF5Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5U3RhdGUgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fZ2V0UG9zaXRpb24oKVxuICAgICAgICAgICAgLndpdGhEaXJlY3Rpb24odGhpcy5kaXIpO1xuICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgICBvdmVybGF5U3RhdGUuYmFja2Ryb3BDbGFzcyA9ICdjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCc7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5kaXJlY3Rpb24gPSB0aGlzLmRpcjtcbiAgICAgICAgb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlTdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbnMgdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldHMgdGhlIGNvcnJlY3QgY2xhc3Nlc1xuICAgICAqIG9uIHRoZSBtZW51IGJhc2VkIG9uIHRoZSBuZXcgcG9zaXRpb24uIFRoaXMgZW5zdXJlcyB0aGUgYW5pbWF0aW9uIG9yaWdpbiBpcyBhbHdheXNcbiAgICAgKiBjb3JyZWN0LCBldmVuIGlmIGEgZmFsbGJhY2sgcG9zaXRpb24gaXMgdXNlZCBmb3IgdGhlIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHs/fSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX3N1YnNjcmliZVRvUG9zaXRpb25zID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uID0gcG9zaXRpb24ub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zWCA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vcmlnaW5YID09PSAnc3RhcnQnID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zWSA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vcmlnaW5ZID09PSAndG9wJyA/ICdiZWxvdycgOiAnYWJvdmUnO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5tZW51Lm92ZXJsYXBUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgcG9zWSA9IHBvc1kgPT09ICdiZWxvdycgPyAnYWJvdmUnIDogJ2JlbG93JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm1lbnUuc2V0UG9zaXRpb25DbGFzc2VzKHBvc1gsIHBvc1kpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgZm9yIHRoZSBvdmVybGF5LCBzbyB0aGUgbWVudSBpcyBwcm9wZXJseSBjb25uZWN0ZWRcbiAgICAgKiB0byB0aGUgdHJpZ2dlci5cbiAgICAgKiBAcmV0dXJuIHs/fSBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2dldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm1lbnUueFBvc2l0aW9uID09PSAnYmVmb3JlJyA/IFsnZW5kJywgJ3N0YXJ0J10gOiBbJ3N0YXJ0JywgJ2VuZCddLCBwb3NYID0gX2FbMF0sIGZhbGxiYWNrWCA9IF9hWzFdO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLm1lbnUueVBvc2l0aW9uID09PSAnYWJvdmUnID8gWydib3R0b20nLCAndG9wJ10gOiBbJ3RvcCcsICdib3R0b20nXSwgb3ZlcmxheVkgPSBfYlswXSwgZmFsbGJhY2tPdmVybGF5WSA9IF9iWzFdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5ZID0gb3ZlcmxheVk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZhbGxiYWNrT3JpZ2luWSA9IGZhbGxiYWNrT3ZlcmxheVk7XG4gICAgICAgIGlmICghdGhpcy5tZW51Lm92ZXJsYXBUcmlnZ2VyKSB7XG4gICAgICAgICAgICBvcmlnaW5ZID0gb3ZlcmxheVkgPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICAgIGZhbGxiYWNrT3JpZ2luWSA9IGZhbGxiYWNrT3ZlcmxheVkgPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAgICAgICAuY29ubmVjdGVkVG8odGhpcy5fZWxlbWVudCwgeyBvcmlnaW5YOiBwb3NYLCBvcmlnaW5ZOiBvcmlnaW5ZIH0sIHsgb3ZlcmxheVg6IHBvc1gsIG92ZXJsYXlZOiBvdmVybGF5WSB9KVxuICAgICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKHsgb3JpZ2luWDogZmFsbGJhY2tYLCBvcmlnaW5ZOiBvcmlnaW5ZIH0sIHsgb3ZlcmxheVg6IGZhbGxiYWNrWCwgb3ZlcmxheVk6IG92ZXJsYXlZIH0pXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oeyBvcmlnaW5YOiBwb3NYLCBvcmlnaW5ZOiBmYWxsYmFja09yaWdpblkgfSwgeyBvdmVybGF5WDogcG9zWCwgb3ZlcmxheVk6IGZhbGxiYWNrT3ZlcmxheVkgfSlcbiAgICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbih7IG9yaWdpblg6IGZhbGxiYWNrWCwgb3JpZ2luWTogZmFsbGJhY2tPcmlnaW5ZIH0sIHsgb3ZlcmxheVg6IGZhbGxiYWNrWCwgb3ZlcmxheVk6IGZhbGxiYWNrT3ZlcmxheVkgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9jbGVhblVwU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2hhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuZWRCeU1vdXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kTWVudVRyaWdnZXI7XG59KCkpO1xuTWRNZW51VHJpZ2dlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBcIlttZC1tZW51LXRyaWdnZXItZm9yXSwgW21hdC1tZW51LXRyaWdnZXItZm9yXSxcXG4gICAgICAgICAgICAgW21kTWVudVRyaWdnZXJGb3JdLCBbbWF0TWVudVRyaWdnZXJGb3JdXCIsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgJyhtb3VzZWRvd24pJzogJ19oYW5kbGVNb3VzZWRvd24oJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ3RvZ2dsZU1lbnUoKScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21kTWVudVRyaWdnZXInXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTWVudVRyaWdnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBPdmVybGF5LCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgeyB0eXBlOiBEaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG5dOyB9O1xuTWRNZW51VHJpZ2dlci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnX2RlcHJlY2F0ZWRNZE1lbnVUcmlnZ2VyRm9yJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWQtbWVudS10cmlnZ2VyLWZvcicsXSB9LF0sXG4gICAgJ19kZXByZWNhdGVkTWF0TWVudVRyaWdnZXJGb3InOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXQtbWVudS10cmlnZ2VyLWZvcicsXSB9LF0sXG4gICAgJ19tYXRNZW51VHJpZ2dlckZvcic6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21hdE1lbnVUcmlnZ2VyRm9yJyxdIH0sXSxcbiAgICAnbWVudSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kTWVudVRyaWdnZXJGb3InLF0gfSxdLFxuICAgICdvbk1lbnVPcGVuJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnb25NZW51Q2xvc2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxufTtcbnZhciBNZE1lbnVNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE1lbnVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZE1lbnVNb2R1bGU7XG59KCkpO1xuTWRNZW51TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRSaXBwbGVNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kTWVudSwgTWRNZW51SXRlbSwgTWRNZW51VHJpZ2dlciwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kTWVudSwgTWRNZW51SXRlbSwgTWRNZW51VHJpZ2dlcl0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kTWVudU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBDdXN0b20gaW5qZWN0b3IgdHlwZSBzcGVjaWZpY2FsbHkgZm9yIGluc3RhbnRpYXRpbmcgY29tcG9uZW50cyB3aXRoIGEgZGlhbG9nLlxuICovXG52YXIgRGlhbG9nSW5qZWN0b3IgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9wYXJlbnRJbmplY3RvclxuICAgICAqIEBwYXJhbSB7P30gX2N1c3RvbVRva2Vuc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpYWxvZ0luamVjdG9yKF9wYXJlbnRJbmplY3RvciwgX2N1c3RvbVRva2Vucykge1xuICAgICAgICB0aGlzLl9wYXJlbnRJbmplY3RvciA9IF9wYXJlbnRJbmplY3RvcjtcbiAgICAgICAgdGhpcy5fY3VzdG9tVG9rZW5zID0gX2N1c3RvbVRva2VucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEBwYXJhbSB7Pz19IG5vdEZvdW5kVmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpYWxvZ0luamVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLl9jdXN0b21Ub2tlbnMuZ2V0KHRva2VuKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50SW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBEaWFsb2dJbmplY3Rvcjtcbn0oKSk7XG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIG9wZW5pbmcgYSBtb2RhbCBkaWFsb2cgd2l0aCB0aGUgTWREaWFsb2cgc2VydmljZS5cbiAqL1xudmFyIE1kRGlhbG9nQ29uZmlnID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWREaWFsb2dDb25maWcoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgQVJJQSByb2xlIG9mIHRoZSBkaWFsb2cgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9sZSA9ICdkaWFsb2cnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VzdG9tIGNsYXNzIGZvciB0aGUgb3ZlcmxheSBwYW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYW5lbENsYXNzID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBkaWFsb2cgaGFzIGEgYmFja2Ryb3AuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0JhY2tkcm9wID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1c3RvbSBjbGFzcyBmb3IgdGhlIGJhY2tkcm9wLFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYWNrZHJvcENsYXNzID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIGNhbiB1c2UgZXNjYXBlIG9yIGNsaWNraW5nIG91dHNpZGUgdG8gY2xvc2UgYSBtb2RhbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZUNsb3NlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWR0aCBvZiB0aGUgZGlhbG9nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVpZ2h0IG9mIHRoZSBkaWFsb2cuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YSBiZWluZyBpbmplY3RlZCBpbnRvIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGF5b3V0IGRpcmVjdGlvbiBmb3IgdGhlIGRpYWxvZydzIGNvbnRlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICdsdHInO1xuICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogYWRkIGNvbmZpZ3VyYXRpb24gZm9yIGxpZmVjeWNsZSBob29rcywgQVJJQSBsYWJlbGxpbmcuXG4gICAgfVxuICAgIHJldHVybiBNZERpYWxvZ0NvbmZpZztcbn0oKSk7XG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGRpYWxvZyBvcGVuZWQgdmlhIHRoZSBNZERpYWxvZyBzZXJ2aWNlLlxuICovXG52YXIgTWREaWFsb2dSZWYgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9vdmVybGF5UmVmXG4gICAgICogQHBhcmFtIHs/fSBfY29udGFpbmVySW5zdGFuY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZERpYWxvZ1JlZihfb3ZlcmxheVJlZiwgX2NvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBfb3ZlcmxheVJlZjtcbiAgICAgICAgdGhpcy5fY29udGFpbmVySW5zdGFuY2UgPSBfY29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gY2xvc2UgdGhlIGRpYWxvZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZUNsb3NlID0gdGhpcy5fY29udGFpbmVySW5zdGFuY2UuX2NvbmZpZy5kaXNhYmxlQ2xvc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhlIHVzZXIgdGhhdCB0aGUgZGlhbG9nIGhhcyBmaW5pc2hlZCBjbG9zaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICBmaWx0ZXIuY2FsbChfY29udGFpbmVySW5zdGFuY2UuX29uQW5pbWF0aW9uU3RhdGVDaGFuZ2UsIGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQudG9TdGF0ZSA9PT0gJ2V4aXQnOyB9KVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7IH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2FmdGVyQ2xvc2VkLm5leHQoX3RoaXMuX3Jlc3VsdCk7XG4gICAgICAgICAgICBfdGhpcy5fYWZ0ZXJDbG9zZWQuY29tcGxldGUoKTtcbiAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIHs/PX0gZGlhbG9nUmVzdWx0IE9wdGlvbmFsIHJlc3VsdCB0byByZXR1cm4gdG8gdGhlIGRpYWxvZyBvcGVuZXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERpYWxvZ1JlZi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZGlhbG9nUmVzdWx0KSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdCA9IGRpYWxvZ1Jlc3VsdDtcbiAgICAgICAgdGhpcy5fY29udGFpbmVySW5zdGFuY2UuX3N0YXRlID0gJ2V4aXQnO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaEJhY2tkcm9wKCk7IC8vIFRyYW5zaXRpb24gdGhlIGJhY2tkcm9wIGluIHBhcmFsbGVsIHdpdGggdGhlIGRpYWxvZy5cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gb2JzZXJ2YWJsZSB0aGF0IGlzIG5vdGlmaWVkIHdoZW4gdGhlIGRpYWxvZyBpcyBmaW5pc2hlZCBjbG9zaW5nLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2dSZWYucHJvdG90eXBlLmFmdGVyQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWZ0ZXJDbG9zZWQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBkaWFsb2cncyBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gez89fSBwb3NpdGlvbiBOZXcgZGlhbG9nIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2dSZWYucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0cmF0ZWd5ID0gdGhpcy5fZ2V0UG9zaXRpb25TdHJhdGVneSgpO1xuICAgICAgICBpZiAocG9zaXRpb24gJiYgKHBvc2l0aW9uLmxlZnQgfHwgcG9zaXRpb24ucmlnaHQpKSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5sZWZ0ID8gc3RyYXRlZ3kubGVmdChwb3NpdGlvbi5sZWZ0KSA6IHN0cmF0ZWd5LnJpZ2h0KHBvc2l0aW9uLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmF0ZWd5LmNlbnRlckhvcml6b250YWxseSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiAmJiAocG9zaXRpb24udG9wIHx8IHBvc2l0aW9uLmJvdHRvbSkpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnRvcCA/IHN0cmF0ZWd5LnRvcChwb3NpdGlvbi50b3ApIDogc3RyYXRlZ3kuYm90dG9tKHBvc2l0aW9uLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJhdGVneS5jZW50ZXJWZXJ0aWNhbGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGRpYWxvZydzIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICogQHBhcmFtIHs/PX0gd2lkdGggTmV3IHdpZHRoIG9mIHRoZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIHs/PX0gaGVpZ2h0IE5ldyBoZWlnaHQgb2YgdGhlIGRpYWxvZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGlhbG9nUmVmLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHsgd2lkdGggPSAnYXV0byc7IH1cbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdm9pZCAwKSB7IGhlaWdodCA9ICdhdXRvJzsgfVxuICAgICAgICB0aGlzLl9nZXRQb3NpdGlvblN0cmF0ZWd5KCkud2lkdGgod2lkdGgpLmhlaWdodChoZWlnaHQpO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgb2JqZWN0IGZyb20gdGhlIG92ZXJsYXkgcmVmLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2dSZWYucHJvdG90eXBlLl9nZXRQb3NpdGlvblN0cmF0ZWd5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX292ZXJsYXlSZWYuZ2V0U3RhdGUoKS5wb3NpdGlvblN0cmF0ZWd5KTtcbiAgICB9O1xuICAgIHJldHVybiBNZERpYWxvZ1JlZjtcbn0oKSk7XG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gZm9yIHRoZSBjYXNlIHdoZW4gYSBDb21wb25lbnRQb3J0YWwgaXNcbiAqIGF0dGFjaGVkIHRvIGEgRG9tUG9ydGFsSG9zdCB3aXRob3V0IGFuIG9yaWdpbi5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGhyb3dNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvcigpIHtcbiAgICB0aHJvdyBFcnJvcignQXR0ZW1wdGluZyB0byBhdHRhY2ggZGlhbG9nIGNvbnRlbnQgYWZ0ZXIgY29udGVudCBpcyBhbHJlYWR5IGF0dGFjaGVkJyk7XG59XG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCB0aGF0IHdyYXBzIHVzZXItcHJvdmlkZWQgZGlhbG9nIGNvbnRlbnQuXG4gKiBBbmltYXRpb24gaXMgYmFzZWQgb24gaHR0cHM6Ly9tYXRlcmlhbC5pby9ndWlkZWxpbmVzL21vdGlvbi9jaG9yZW9ncmFwaHkuaHRtbC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWREaWFsb2dDb250YWluZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZERpYWxvZ0NvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9uZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfZm9jdXNUcmFwRmFjdG9yeVxuICAgICAqIEBwYXJhbSB7P30gX2RvY3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gTWREaWFsb2dDb250YWluZXIoX25nWm9uZSwgX2VsZW1lbnRSZWYsIF9mb2N1c1RyYXBGYWN0b3J5LCBfZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIF90aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIF90aGlzLl9mb2N1c1RyYXBGYWN0b3J5ID0gX2ZvY3VzVHJhcEZhY3Rvcnk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSBkaWFsb2cgd2FzIG9wZW5lZC4gU2F2ZSB0aGlzIHRvIHJlc3RvcmUgdXBvbiBjbG9zZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZURpYWxvZ1dhc09wZW5lZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGF0ZSBvZiB0aGUgZGlhbG9nIGFuaW1hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zdGF0ZSA9ICdlbnRlcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgd2hlbmV2ZXIgaXQgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vbkFuaW1hdGlvblN0YXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSUQgb2YgdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyB0aGUgZGlhbG9nJ3MgbGFiZWwuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fYXJpYUxhYmVsbGVkQnkgPSBudWxsO1xuICAgICAgICBfdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgQ29tcG9uZW50UG9ydGFsIGFzIGNvbnRlbnQgdG8gdGhpcyBkaWFsb2cgY29udGFpbmVyLlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBwb3J0YWwgUG9ydGFsIHRvIGJlIGF0dGFjaGVkIGFzIHRoZSBkaWFsb2cgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZS5hdHRhY2hDb21wb25lbnRQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3J0YWxIb3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93TWREaWFsb2dDb250ZW50QWxyZWFkeUF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3J0YWxIb3N0LmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgVGVtcGxhdGVQb3J0YWwgYXMgY29udGVudCB0byB0aGlzIGRpYWxvZyBjb250YWluZXIuXG4gICAgICogQHBhcmFtIHs/fSBwb3J0YWwgUG9ydGFsIHRvIGJlIGF0dGFjaGVkIGFzIHRoZSBkaWFsb2cgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZS5hdHRhY2hUZW1wbGF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BvcnRhbEhvc3QuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhyb3dNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NhdmVQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbEhvc3QuYXR0YWNoVGVtcGxhdGVQb3J0YWwocG9ydGFsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBmb2N1cyBpbnNpZGUgdGhlIGZvY3VzIHRyYXAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUuX3RyYXBGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mb2N1c1RyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2VyZSB0byBhdHRlbXB0IHRvIGZvY3VzIGltbWVkaWF0ZWx5LCB0aGVuIHRoZSBjb250ZW50IG9mIHRoZSBkaWFsb2cgd291bGQgbm90IHlldCBiZVxuICAgICAgICAvLyByZWFkeSBpbiBpbnN0YW5jZXMgd2hlcmUgY2hhbmdlIGRldGVjdGlvbiBoYXMgdG8gcnVuIGZpcnN0LiBUbyBkZWFsIHdpdGggdGhpcywgd2Ugc2ltcGx5XG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZW1wdHkuXG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcC5mb2N1c0luaXRpYWxFbGVtZW50V2hlblJlYWR5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBmb2N1cyB0byB0aGUgZWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgZGlhbG9nIG9wZW5lZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZS5fcmVzdG9yZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b0ZvY3VzID0gdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVEaWFsb2dXYXNPcGVuZWQ7XG4gICAgICAgIC8vIFdlIG5lZWQgdGhlIGV4dHJhIGNoZWNrLCBiZWNhdXNlIElFIGNhbiBzZXQgdGhlIGBhY3RpdmVFbGVtZW50YCB0byBudWxsIGluIHNvbWUgY2FzZXMuXG4gICAgICAgIGlmICh0b0ZvY3VzICYmICdmb2N1cycgaW4gdG9Gb2N1cykge1xuICAgICAgICAgICAgdG9Gb2N1cy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mb2N1c1RyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSBkaWFsb2cgd2FzIG9wZW5lZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZS5fc2F2ZVByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZURpYWxvZ1dhc09wZW5lZCA9ICh0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2ssIGludm9rZWQgd2hlbmV2ZXIgYW4gYW5pbWF0aW9uIG9uIHRoZSBob3N0IGNvbXBsZXRlcy5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUuX29uQW5pbWF0aW9uRG9uZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLl9vbkFuaW1hdGlvblN0YXRlQ2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ2VudGVyJykge1xuICAgICAgICAgICAgdGhpcy5fdHJhcEZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ2V4aXQnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN0b3JlRm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQW5pbWF0aW9uU3RhdGVDaGFuZ2UuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kRGlhbG9nQ29udGFpbmVyO1xufShCYXNlUG9ydGFsSG9zdCkpO1xuTWREaWFsb2dDb250YWluZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1kaWFsb2ctY29udGFpbmVyLCBtYXQtZGlhbG9nLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLXRlbXBsYXRlIGNka1BvcnRhbEhvc3Q+PC9uZy10ZW1wbGF0ZT5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtZGlhbG9nLWNvbnRhaW5lcntib3gtc2hhZG93OjAgMTFweCAxNXB4IC03cHggcmdiYSgwLDAsMCwuMiksMCAyNHB4IDM4cHggM3B4IHJnYmEoMCwwLDAsLjE0KSwwIDlweCA0NnB4IDhweCByZ2JhKDAsMCwwLC4xMik7ZGlzcGxheTpibG9jaztwYWRkaW5nOjI0cHg7Ym9yZGVyLXJhZGl1czoycHg7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OmF1dG87bWF4LXdpZHRoOjgwdnc7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LWRpYWxvZy1jb250YWluZXJ7b3V0bGluZTpzb2xpZCAxcHh9fS5tYXQtZGlhbG9nLWNvbnRlbnR7ZGlzcGxheTpibG9jazttYXJnaW46MCAtMjRweDtwYWRkaW5nOjAgMjRweDttYXgtaGVpZ2h0OjY1dmg7b3ZlcmZsb3c6YXV0bzstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaH0ubWF0LWRpYWxvZy10aXRsZXttYXJnaW46MCAwIDIwcHg7ZGlzcGxheTpibG9ja30ubWF0LWRpYWxvZy1hY3Rpb25ze3BhZGRpbmc6MTJweCAwO2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6d3JhcH0ubWF0LWRpYWxvZy1hY3Rpb25zOmxhc3QtY2hpbGR7bWFyZ2luLWJvdHRvbTotMjRweH0ubWF0LWRpYWxvZy1hY3Rpb25zW2FsaWduPWVuZF17anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfS5tYXQtZGlhbG9nLWFjdGlvbnNbYWxpZ249Y2VudGVyXXtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfVwiXSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcignc2xpZGVEaWFsb2cnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBUaGUgYGVudGVyYCBhbmltYXRpb24gZG9lc24ndCB0cmFuc2l0aW9uIHRvIHNvbWV0aGluZyBsaWtlIGB0cmFuc2xhdGUzZCgwLCAwLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NhbGUoMSlgLCBiZWNhdXNlIGZvciBzb21lIHJlYXNvbiBzcGVjaWZ5aW5nIHRoZSB0cmFuc2Zvcm0gZXhwbGljaXRseSwgY2F1c2VzIElFIGJvdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGJsdXIgdGhlIGRpYWxvZyBjb250ZW50IGFuZCBkZWNpbWF0ZSB0aGUgYW5pbWF0aW9uIHBlcmZvcm1hbmNlLiBMZWF2aW5nIGl0IGFzIGBub25lYFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc29sdmVzIGJvdGggaXNzdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2VudGVyJywgc3R5bGUoeyB0cmFuc2Zvcm06ICdub25lJywgb3BhY2l0eTogMSB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgndm9pZCcsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMjUlLCAwKSBzY2FsZSgwLjkpJywgb3BhY2l0eTogMCB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgnZXhpdCcsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMjUlLCAwKScsIG9wYWNpdHk6IDAgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiAqJywgYW5pbWF0ZSgnNDAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSknKSksXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtZGlhbG9nLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5yb2xlXSc6ICdfY29uZmlnPy5yb2xlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtbGFiZWxsZWRieV0nOiAnX2FyaWFMYWJlbGxlZEJ5JyxcbiAgICAgICAgICAgICAgICAgICAgJ1tAc2xpZGVEaWFsb2ddJzogJ19zdGF0ZScsXG4gICAgICAgICAgICAgICAgICAgICcoQHNsaWRlRGlhbG9nLmRvbmUpJzogJ19vbkFuaW1hdGlvbkRvbmUoJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWREaWFsb2dDb250YWluZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogRm9jdXNUcmFwRmFjdG9yeSwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtET0NVTUVOVCxdIH0sXSB9LFxuXTsgfTtcbk1kRGlhbG9nQ29udGFpbmVyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdfcG9ydGFsSG9zdCc6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW1BvcnRhbEhvc3REaXJlY3RpdmUsXSB9LF0sXG59O1xudmFyIE1EX0RJQUxPR19EQVRBID0gbmV3IEluamVjdGlvblRva2VuKCdNZERpYWxvZ0RhdGEnKTtcbi8qKlxuICogU2VydmljZSB0byBvcGVuIE1hdGVyaWFsIERlc2lnbiBtb2RhbCBkaWFsb2dzLlxuICovXG52YXIgTWREaWFsb2cgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9vdmVybGF5XG4gICAgICogQHBhcmFtIHs/fSBfaW5qZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IF9sb2NhdGlvblxuICAgICAqIEBwYXJhbSB7P30gX3BhcmVudERpYWxvZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nKF9vdmVybGF5LCBfaW5qZWN0b3IsIF9sb2NhdGlvbiwgX3BhcmVudERpYWxvZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gX292ZXJsYXk7XG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IF9sb2NhdGlvbjtcbiAgICAgICAgdGhpcy5fcGFyZW50RGlhbG9nID0gX3BhcmVudERpYWxvZztcbiAgICAgICAgdGhpcy5fb3BlbkRpYWxvZ3NBdFRoaXNMZXZlbCA9IFtdO1xuICAgICAgICB0aGlzLl9hZnRlckFsbENsb3NlZEF0VGhpc0xldmVsID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJPcGVuQXRUaGlzTGV2ZWwgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl9ib3VuZEtleWRvd24gPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGFuIG9ic2VydmFibGUgdGhhdCBpcyBub3RpZmllZCB3aGVuIGEgZGlhbG9nIGhhcyBiZWVuIG9wZW5lZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWZ0ZXJPcGVuID0gdGhpcy5fYWZ0ZXJPcGVuLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhbiBvYnNlcnZhYmxlIHRoYXQgaXMgbm90aWZpZWQgd2hlbiBhbGwgb3BlbiBkaWFsb2cgaGF2ZSBmaW5pc2hlZCBjbG9zaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZnRlckFsbENsb3NlZCA9IHRoaXMuX2FmdGVyQWxsQ2xvc2VkLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICAvLyBDbG9zZSBhbGwgb2YgdGhlIGRpYWxvZ3Mgd2hlbiB0aGUgdXNlciBnb2VzIGZvcndhcmRzL2JhY2t3YXJkcyBpbiBoaXN0b3J5IG9yIHdoZW4gdGhlXG4gICAgICAgIC8vIGxvY2F0aW9uIGhhc2ggY2hhbmdlcy4gTm90ZSB0aGF0IHRoaXMgdXN1YWxseSBkb2Vzbid0IGluY2x1ZGUgY2xpY2tpbmcgb24gbGlua3MgKHVubGVzc1xuICAgICAgICAvLyB0aGUgdXNlciBpcyB1c2luZyB0aGUgYEhhc2hMb2NhdGlvblN0cmF0ZWd5YCkuXG4gICAgICAgIGlmICghX3BhcmVudERpYWxvZyAmJiBfbG9jYXRpb24pIHtcbiAgICAgICAgICAgIF9sb2NhdGlvbi5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvc2VBbGwoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGlhbG9nLnByb3RvdHlwZSwgXCJfb3BlbkRpYWxvZ3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnRseS1vcGVuIGRpYWxvZ3MuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnREaWFsb2cgPyB0aGlzLl9wYXJlbnREaWFsb2cuX29wZW5EaWFsb2dzIDogdGhpcy5fb3BlbkRpYWxvZ3NBdFRoaXNMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGlhbG9nLnByb3RvdHlwZSwgXCJfYWZ0ZXJPcGVuXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGUgdXNlciB0aGF0IGEgZGlhbG9nIGhhcyBvcGVuZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnREaWFsb2cgPyB0aGlzLl9wYXJlbnREaWFsb2cuX2FmdGVyT3BlbiA6IHRoaXMuX2FmdGVyT3BlbkF0VGhpc0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREaWFsb2cucHJvdG90eXBlLCBcIl9hZnRlckFsbENsb3NlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhlIHVzZXIgdGhhdCBhbGwgb3BlbiBkaWFsb2dzIGhhdmUgZmluaXNoZWQgY2xvc2luZy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudERpYWxvZyA/XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50RGlhbG9nLl9hZnRlckFsbENsb3NlZCA6IHRoaXMuX2FmdGVyQWxsQ2xvc2VkQXRUaGlzTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgbW9kYWwgZGlhbG9nIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGNvbXBvbmVudC5cbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50T3JUZW1wbGF0ZVJlZiBUeXBlIG9mIHRoZSBjb21wb25lbnQgdG8gbG9hZCBpbnRvIHRoZSBkaWFsb2csXG4gICAgICogICAgIG9yIGEgVGVtcGxhdGVSZWYgdG8gaW5zdGFudGlhdGUgYXMgdGhlIGRpYWxvZyBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7Pz19IGNvbmZpZyBFeHRyYSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybiB7P30gUmVmZXJlbmNlIHRvIHRoZSBuZXdseS1vcGVuZWQgZGlhbG9nLlxuICAgICAqL1xuICAgIE1kRGlhbG9nLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25maWcgPSBfYXBwbHlDb25maWdEZWZhdWx0cyQxKGNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlSZWYgPSB0aGlzLl9jcmVhdGVPdmVybGF5KGNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpYWxvZ0NvbnRhaW5lciA9IHRoaXMuX2F0dGFjaERpYWxvZ0NvbnRhaW5lcihvdmVybGF5UmVmLCBjb25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaWFsb2dSZWYgPSB0aGlzLl9hdHRhY2hEaWFsb2dDb250ZW50KGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIGRpYWxvZ0NvbnRhaW5lciwgb3ZlcmxheVJlZiwgY29uZmlnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuRGlhbG9ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEtleWRvd24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5EaWFsb2dzLnB1c2goZGlhbG9nUmVmKTtcbiAgICAgICAgZGlhbG9nUmVmLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9yZW1vdmVPcGVuRGlhbG9nKGRpYWxvZ1JlZik7IH0pO1xuICAgICAgICB0aGlzLl9hZnRlck9wZW4ubmV4dChkaWFsb2dSZWYpO1xuICAgICAgICByZXR1cm4gZGlhbG9nUmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBvZiB0aGUgY3VycmVudGx5LW9wZW4gZGlhbG9ncy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGlhbG9nLnByb3RvdHlwZS5jbG9zZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IHRoaXMuX29wZW5EaWFsb2dzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgLy8gVGhlIGBfb3BlbkRpYWxvZ3NgIHByb3BlcnR5IGlzbid0IHVwZGF0ZWQgYWZ0ZXIgY2xvc2UgdW50aWwgdGhlIHJ4anMgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAvLyBydW5zIG9uIHRoZSBuZXh0IG1pY3JvdGFzaywgaW4gYWRkaXRpb24gdG8gbW9kaWZ5aW5nIHRoZSBhcnJheSBhcyB3ZSdyZSBnb2luZ1xuICAgICAgICAgICAgLy8gdGhyb3VnaCBpdC4gV2UgbG9vcCB0aHJvdWdoIGFsbCBvZiB0aGVtIGFuZCBjYWxsIGNsb3NlIHdpdGhvdXQgYXNzdW1pbmcgdGhhdFxuICAgICAgICAgICAgLy8gdGhleSdsbCBiZSByZW1vdmVkIGZyb20gdGhlIGxpc3QgaW5zdGFudGFuZW91c2x5LlxuICAgICAgICAgICAgdGhpcy5fb3BlbkRpYWxvZ3NbaV0uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgb3ZlcmxheSBpbnRvIHdoaWNoIHRoZSBkaWFsb2cgd2lsbCBiZSBsb2FkZWQuXG4gICAgICogQHBhcmFtIHs/fSBjb25maWcgVGhlIGRpYWxvZyBjb25maWd1cmF0aW9uLlxuICAgICAqIEByZXR1cm4gez99IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIE92ZXJsYXlSZWYgZm9yIHRoZSBjcmVhdGVkIG92ZXJsYXkuXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5U3RhdGUgPSB0aGlzLl9nZXRPdmVybGF5U3RhdGUoY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuY3JlYXRlKG92ZXJsYXlTdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkgc3RhdGUgZnJvbSBhIGRpYWxvZyBjb25maWcuXG4gICAgICogQHBhcmFtIHs/fSBkaWFsb2dDb25maWcgVGhlIGRpYWxvZyBjb25maWd1cmF0aW9uLlxuICAgICAqIEByZXR1cm4gez99IFRoZSBvdmVybGF5IGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9nZXRPdmVybGF5U3RhdGUgPSBmdW5jdGlvbiAoZGlhbG9nQ29uZmlnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG92ZXJsYXlTdGF0ZSA9IG5ldyBPdmVybGF5U3RhdGUoKTtcbiAgICAgICAgb3ZlcmxheVN0YXRlLnBhbmVsQ2xhc3MgPSBkaWFsb2dDb25maWcucGFuZWxDbGFzcztcbiAgICAgICAgb3ZlcmxheVN0YXRlLmhhc0JhY2tkcm9wID0gZGlhbG9nQ29uZmlnLmhhc0JhY2tkcm9wO1xuICAgICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMuYmxvY2soKTtcbiAgICAgICAgb3ZlcmxheVN0YXRlLmRpcmVjdGlvbiA9IGRpYWxvZ0NvbmZpZy5kaXJlY3Rpb247XG4gICAgICAgIGlmIChkaWFsb2dDb25maWcuYmFja2Ryb3BDbGFzcykge1xuICAgICAgICAgICAgb3ZlcmxheVN0YXRlLmJhY2tkcm9wQ2xhc3MgPSBkaWFsb2dDb25maWcuYmFja2Ryb3BDbGFzcztcbiAgICAgICAgfVxuICAgICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX292ZXJsYXkucG9zaXRpb24oKS5nbG9iYWwoKTtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlTdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGFuIE1kRGlhbG9nQ29udGFpbmVyIHRvIGEgZGlhbG9nJ3MgYWxyZWFkeS1jcmVhdGVkIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5IFJlZmVyZW5jZSB0byB0aGUgZGlhbG9nJ3MgdW5kZXJseWluZyBvdmVybGF5LlxuICAgICAqIEBwYXJhbSB7P30gY29uZmlnIFRoZSBkaWFsb2cgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGEgQ29tcG9uZW50UmVmIGZvciB0aGUgYXR0YWNoZWQgY29udGFpbmVyLlxuICAgICAqL1xuICAgIE1kRGlhbG9nLnByb3RvdHlwZS5fYXR0YWNoRGlhbG9nQ29udGFpbmVyID0gZnVuY3Rpb24gKG92ZXJsYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluZXJQb3J0YWwgPSBuZXcgQ29tcG9uZW50UG9ydGFsKE1kRGlhbG9nQ29udGFpbmVyLCBjb25maWcudmlld0NvbnRhaW5lclJlZik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lclJlZiA9IG92ZXJsYXkuYXR0YWNoKGNvbnRhaW5lclBvcnRhbCk7XG4gICAgICAgIGNvbnRhaW5lclJlZi5pbnN0YW5jZS5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyUmVmLmluc3RhbmNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdGhlIHVzZXItcHJvdmlkZWQgY29tcG9uZW50IHRvIHRoZSBhbHJlYWR5LWNyZWF0ZWQgTWREaWFsb2dDb250YWluZXIuXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudE9yVGVtcGxhdGVSZWYgVGhlIHR5cGUgb2YgY29tcG9uZW50IGJlaW5nIGxvYWRlZCBpbnRvIHRoZSBkaWFsb2csXG4gICAgICogICAgIG9yIGEgVGVtcGxhdGVSZWYgdG8gaW5zdGFudGlhdGUgYXMgdGhlIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHs/fSBkaWFsb2dDb250YWluZXIgUmVmZXJlbmNlIHRvIHRoZSB3cmFwcGluZyBNZERpYWxvZ0NvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlSZWYgUmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IGluIHdoaWNoIHRoZSBkaWFsb2cgcmVzaWRlcy5cbiAgICAgKiBAcGFyYW0gez99IGNvbmZpZyBUaGUgZGlhbG9nIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybiB7P30gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgTWREaWFsb2dSZWYgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWQgdG8gdGhlIHVzZXIuXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9hdHRhY2hEaWFsb2dDb250ZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIGRpYWxvZ0NvbnRhaW5lciwgb3ZlcmxheVJlZiwgY29uZmlnKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHJlZmVyZW5jZSB0byB0aGUgZGlhbG9nIHdlJ3JlIGNyZWF0aW5nIGluIG9yZGVyIHRvIGdpdmUgdGhlIHVzZXIgYSBoYW5kbGVcbiAgICAgICAgLy8gdG8gbW9kaWZ5IGFuZCBjbG9zZSBpdC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlhbG9nUmVmID0gbmV3IE1kRGlhbG9nUmVmKG92ZXJsYXlSZWYsIGRpYWxvZ0NvbnRhaW5lcik7XG4gICAgICAgIC8vIFdoZW4gdGhlIGRpYWxvZyBiYWNrZHJvcCBpcyBjbGlja2VkLCB3ZSB3YW50IHRvIGNsb3NlIGl0LlxuICAgICAgICBpZiAoY29uZmlnLmhhc0JhY2tkcm9wKSB7XG4gICAgICAgICAgICBvdmVybGF5UmVmLmJhY2tkcm9wQ2xpY2soKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghZGlhbG9nUmVmLmRpc2FibGVDbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2dSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50T3JUZW1wbGF0ZVJlZiBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICBkaWFsb2dDb250YWluZXIuYXR0YWNoVGVtcGxhdGVQb3J0YWwobmV3IFRlbXBsYXRlUG9ydGFsKGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIC8qKiBAdHlwZSB7P30gKi8gKChudWxsKSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluamVjdG9yID0gdGhpcy5fY3JlYXRlSW5qZWN0b3IoY29uZmlnLCBkaWFsb2dSZWYsIGRpYWxvZ0NvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50UmVmID0gZGlhbG9nQ29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbChuZXcgQ29tcG9uZW50UG9ydGFsKGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIHVuZGVmaW5lZCwgaW5qZWN0b3IpKTtcbiAgICAgICAgICAgIGRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZSA9IGNvbnRlbnRSZWYuaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZGlhbG9nUmVmXG4gICAgICAgICAgICAudXBkYXRlU2l6ZShjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQpXG4gICAgICAgICAgICAudXBkYXRlUG9zaXRpb24oY29uZmlnLnBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIGRpYWxvZ1JlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjdXN0b20gaW5qZWN0b3IgdG8gYmUgdXNlZCBpbnNpZGUgdGhlIGRpYWxvZy4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgbG9hZGVkIGluc2lkZVxuICAgICAqIG9mIGEgZGlhbG9nIHRvIGNsb3NlIGl0c2VsZiBhbmQsIG9wdGlvbmFsbHksIHRvIHJldHVybiBhIHZhbHVlLlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBjb25maWcgQ29uZmlnIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gY29uc3RydWN0IHRoZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIHs/fSBkaWFsb2dSZWYgUmVmZXJlbmNlIHRvIHRoZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIHs/fSBkaWFsb2dDb250YWluZXJcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgY3VzdG9tIGluamVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIHRoZSBkaWFsb2cuXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9jcmVhdGVJbmplY3RvciA9IGZ1bmN0aW9uIChjb25maWcsIGRpYWxvZ1JlZiwgZGlhbG9nQ29udGFpbmVyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVzZXJJbmplY3RvciA9IGNvbmZpZyAmJiBjb25maWcudmlld0NvbnRhaW5lclJlZiAmJiBjb25maWcudmlld0NvbnRhaW5lclJlZi5pbmplY3RvcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5qZWN0aW9uVG9rZW5zID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgaW5qZWN0aW9uVG9rZW5zLnNldChNZERpYWxvZ1JlZiwgZGlhbG9nUmVmKTtcbiAgICAgICAgaW5qZWN0aW9uVG9rZW5zLnNldChNZERpYWxvZ0NvbnRhaW5lciwgZGlhbG9nQ29udGFpbmVyKTtcbiAgICAgICAgaW5qZWN0aW9uVG9rZW5zLnNldChNRF9ESUFMT0dfREFUQSwgY29uZmlnLmRhdGEpO1xuICAgICAgICByZXR1cm4gbmV3IERpYWxvZ0luamVjdG9yKHVzZXJJbmplY3RvciB8fCB0aGlzLl9pbmplY3RvciwgaW5qZWN0aW9uVG9rZW5zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkaWFsb2cgZnJvbSB0aGUgYXJyYXkgb2Ygb3BlbiBkaWFsb2dzLlxuICAgICAqIEBwYXJhbSB7P30gZGlhbG9nUmVmIERpYWxvZyB0byBiZSByZW1vdmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9yZW1vdmVPcGVuRGlhbG9nID0gZnVuY3Rpb24gKGRpYWxvZ1JlZikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHRoaXMuX29wZW5EaWFsb2dzLmluZGV4T2YoZGlhbG9nUmVmKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX29wZW5EaWFsb2dzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAvLyBubyBvcGVuIGRpYWxvZ3MgYXJlIGxlZnQsIGNhbGwgbmV4dCBvbiBhZnRlckFsbENsb3NlZCBTdWJqZWN0XG4gICAgICAgICAgICBpZiAoIXRoaXMuX29wZW5EaWFsb2dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FmdGVyQWxsQ2xvc2VkLm5leHQoKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRLZXlkb3duKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBnbG9iYWwga2V5IHByZXNzZXMgd2hpbGUgdGhlcmUgYXJlIG9wZW4gZGlhbG9ncy4gQ2xvc2VzIHRoZVxuICAgICAqIHRvcCBkaWFsb2cgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGVzY2FwZS5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9wRGlhbG9nID0gdGhpcy5fb3BlbkRpYWxvZ3NbdGhpcy5fb3BlbkRpYWxvZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhbkNsb3NlID0gdG9wRGlhbG9nID8gIXRvcERpYWxvZy5kaXNhYmxlQ2xvc2UgOiBmYWxzZTtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSAmJiBjYW5DbG9zZSkge1xuICAgICAgICAgICAgdG9wRGlhbG9nLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZERpYWxvZztcbn0oKSk7XG5NZERpYWxvZy5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWREaWFsb2cuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBPdmVybGF5LCB9LFxuICAgIHsgdHlwZTogSW5qZWN0b3IsIH0sXG4gICAgeyB0eXBlOiBMb2NhdGlvbiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBNZERpYWxvZywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBTa2lwU2VsZiB9LF0gfSxcbl07IH07XG4vKipcbiAqIEFwcGxpZXMgZGVmYXVsdCBvcHRpb25zIHRvIHRoZSBkaWFsb2cgY29uZmlnLlxuICogQHBhcmFtIHs/PX0gY29uZmlnIENvbmZpZyB0byBiZSBtb2RpZmllZC5cbiAqIEByZXR1cm4gez99IFRoZSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9hcHBseUNvbmZpZ0RlZmF1bHRzJDEoY29uZmlnKSB7XG4gICAgcmV0dXJuIGV4dGVuZE9iamVjdChuZXcgTWREaWFsb2dDb25maWcoKSwgY29uZmlnKTtcbn1cbi8qKlxuICogQ291bnRlciB1c2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMgZm9yIGRpYWxvZyBlbGVtZW50cy5cbiAqL1xudmFyIGRpYWxvZ0VsZW1lbnRVaWQgPSAwO1xuLyoqXG4gKiBCdXR0b24gdGhhdCB3aWxsIGNsb3NlIHRoZSBjdXJyZW50IGRpYWxvZy5cbiAqL1xudmFyIE1kRGlhbG9nQ2xvc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpYWxvZ1JlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nQ2xvc2UoZGlhbG9nUmVmKSB7XG4gICAgICAgIHRoaXMuZGlhbG9nUmVmID0gZGlhbG9nUmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NyZWVucmVhZGVyIGxhYmVsIGZvciB0aGUgYnV0dG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcmlhTGFiZWwgPSAnQ2xvc2UgZGlhbG9nJztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGlhbG9nQ2xvc2UucHJvdG90eXBlLCBcIl9tYXREaWFsb2dDbG9zZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaWFsb2cgY2xvc2UgaW5wdXQgZm9yIGNvbXBhdGliaWxpdHkgbW9kZS5cbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5kaWFsb2dSZXN1bHQgPSB2YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE1kRGlhbG9nQ2xvc2U7XG59KCkpO1xuTWREaWFsb2dDbG9zZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYnV0dG9uW21kLWRpYWxvZy1jbG9zZV0sIGJ1dHRvblttYXQtZGlhbG9nLWNsb3NlXSwnICtcbiAgICAgICAgICAgICAgICAgICAgJ2J1dHRvblttZERpYWxvZ0Nsb3NlXSwgYnV0dG9uW21hdERpYWxvZ0Nsb3NlXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdkaWFsb2dSZWYuY2xvc2UoZGlhbG9nUmVzdWx0KScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdhcmlhTGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWREaWFsb2dDbG9zZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE1kRGlhbG9nUmVmLCB9LFxuXTsgfTtcbk1kRGlhbG9nQ2xvc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2FyaWFMYWJlbCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2FyaWEtbGFiZWwnLF0gfSxdLFxuICAgICdkaWFsb2dSZXN1bHQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZC1kaWFsb2ctY2xvc2UnLF0gfSxdLFxuICAgICdfbWF0RGlhbG9nQ2xvc2UnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXQtZGlhbG9nLWNsb3NlJyxdIH0sXSxcbn07XG4vKipcbiAqIFRpdGxlIG9mIGEgZGlhbG9nIGVsZW1lbnQuIFN0YXlzIGZpeGVkIHRvIHRoZSB0b3Agb2YgdGhlIGRpYWxvZyB3aGVuIHNjcm9sbGluZy5cbiAqL1xudmFyIE1kRGlhbG9nVGl0bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb250YWluZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZERpYWxvZ1RpdGxlKF9jb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gX2NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5pZCA9IFwibWQtZGlhbG9nLXRpdGxlLVwiICsgZGlhbG9nRWxlbWVudFVpZCsrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGlhbG9nVGl0bGUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyICYmICF0aGlzLl9jb250YWluZXIuX2FyaWFMYWJlbGxlZEJ5KSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jb250YWluZXIuX2FyaWFMYWJlbGxlZEJ5ID0gX3RoaXMuaWQ7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWREaWFsb2dUaXRsZTtcbn0oKSk7XG5NZERpYWxvZ1RpdGxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtZGlhbG9nLXRpdGxlXSwgW21hdC1kaWFsb2ctdGl0bGVdLCBbbWREaWFsb2dUaXRsZV0sIFttYXREaWFsb2dUaXRsZV0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1kaWFsb2ctdGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICAnW2lkXSc6ICdpZCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWREaWFsb2dUaXRsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE1kRGlhbG9nQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbl07IH07XG5NZERpYWxvZ1RpdGxlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdpZCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG4vKipcbiAqIFNjcm9sbGFibGUgY29udGVudCBjb250YWluZXIgb2YgYSBkaWFsb2cuXG4gKi9cbnZhciBNZERpYWxvZ0NvbnRlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ0NvbnRlbnQoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZERpYWxvZ0NvbnRlbnQ7XG59KCkpO1xuTWREaWFsb2dDb250ZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtZGlhbG9nLWNvbnRlbnRdLCBtZC1kaWFsb2ctY29udGVudCwgW21hdC1kaWFsb2ctY29udGVudF0sIG1hdC1kaWFsb2ctY29udGVudCwnICtcbiAgICAgICAgICAgICAgICAgICAgJ1ttZERpYWxvZ0NvbnRlbnRdLCBbbWF0RGlhbG9nQ29udGVudF0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21hdC1kaWFsb2ctY29udGVudCcgfVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERpYWxvZ0NvbnRlbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQ29udGFpbmVyIGZvciB0aGUgYm90dG9tIGFjdGlvbiBidXR0b25zIGluIGEgZGlhbG9nLlxuICogU3RheXMgZml4ZWQgdG8gdGhlIGJvdHRvbSB3aGVuIHNjcm9sbGluZy5cbiAqL1xudmFyIE1kRGlhbG9nQWN0aW9ucyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nQWN0aW9ucygpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kRGlhbG9nQWN0aW9ucztcbn0oKSk7XG5NZERpYWxvZ0FjdGlvbnMuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1kaWFsb2ctYWN0aW9uc10sIG1kLWRpYWxvZy1hY3Rpb25zLCBbbWF0LWRpYWxvZy1hY3Rpb25zXSwgbWF0LWRpYWxvZy1hY3Rpb25zLCcgK1xuICAgICAgICAgICAgICAgICAgICAnW21kRGlhbG9nQWN0aW9uc10sIFttYXREaWFsb2dBY3Rpb25zXScsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWF0LWRpYWxvZy1hY3Rpb25zJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kRGlhbG9nQWN0aW9ucy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIE1kRGlhbG9nTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWREaWFsb2dNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZERpYWxvZ01vZHVsZTtcbn0oKSk7XG5NZERpYWxvZ01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFBvcnRhbE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgQTExeU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBNZERpYWxvZ0Nsb3NlLFxuICAgICAgICAgICAgICAgICAgICBNZERpYWxvZ1RpdGxlLFxuICAgICAgICAgICAgICAgICAgICBNZERpYWxvZ0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgTWRDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWREaWFsb2dDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nQ2xvc2UsXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nVGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgTWREaWFsb2dDb250ZW50LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIE1kRGlhbG9nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTWREaWFsb2dDb250YWluZXJdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERpYWxvZ01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBJdCBhbHNvIGFkZHMgYWN0aXZlIHN0eWxlcyB0byB0aGUgbmV3bHkgYWN0aXZlIGl0ZW0gYW5kIHJlbW92ZXMgYWN0aXZlXG4gICAgICogc3R5bGVzIGZyb20gdGhlIHByZXZpb3VzbHkgYWN0aXZlIGl0ZW0uXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIucHJvdG90eXBlLnNldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZUl0ZW0uc2V0SW5hY3RpdmVTdHlsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0QWN0aXZlSXRlbS5jYWxsKF90aGlzLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZUl0ZW0uc2V0QWN0aXZlU3R5bGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyO1xufShMaXN0S2V5TWFuYWdlcikpO1xuLyoqXG4gKiBBdXRvY29tcGxldGUgSURzIG5lZWQgdG8gYmUgdW5pcXVlIGFjcm9zcyBjb21wb25lbnRzLCBzbyB0aGlzIGNvdW50ZXIgZXhpc3RzIG91dHNpZGUgb2ZcbiAqIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xudmFyIF91bmlxdWVBdXRvY29tcGxldGVJZENvdW50ZXIgPSAwO1xudmFyIE1kQXV0b2NvbXBsZXRlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfY2hhbmdlRGV0ZWN0b3JSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZEF1dG9jb21wbGV0ZShfY2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYgPSBfY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgZGlzcGxheXMgYWJvdmUgb3IgYmVsb3cgaXRzIHRyaWdnZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uWSA9ICdiZWxvdyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgc2hvdWxkIGJlIHZpc2libGUsIGRlcGVuZGluZyBvbiBvcHRpb24gbGVuZ3RoLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93UGFuZWwgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgbWFwcyBhbiBvcHRpb24ncyBjb250cm9sIHZhbHVlIHRvIGl0cyBkaXNwbGF5IHZhbHVlIGluIHRoZSB0cmlnZ2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNwbGF5V2l0aCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmlxdWUgSUQgdG8gYmUgdXNlZCBieSBhdXRvY29tcGxldGUgdHJpZ2dlcidzIFwiYXJpYS1vd25zXCIgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gXCJtZC1hdXRvY29tcGxldGUtXCIgKyBfdW5pcXVlQXV0b2NvbXBsZXRlSWRDb3VudGVyKys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGUucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlciA9IG5ldyBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcih0aGlzLm9wdGlvbnMpLndpdGhXcmFwKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwYW5lbCBzY3JvbGxUb3AuIFRoaXMgYWxsb3dzIHVzIHRvIG1hbnVhbGx5IHNjcm9sbCB0byBkaXNwbGF5IG9wdGlvbnNcbiAgICAgKiBhYm92ZSBvciBiZWxvdyB0aGUgZm9sZCwgYXMgdGhleSBhcmUgbm90IGFjdHVhbGx5IGJlaW5nIGZvY3VzZWQgd2hlbiBhY3RpdmUuXG4gICAgICogQHBhcmFtIHs/fSBzY3JvbGxUb3BcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5fc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHNjcm9sbFRvcCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbCkge1xuICAgICAgICAgICAgdGhpcy5wYW5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFuZWwncyBzY3JvbGxUb3AuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuX2dldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFuZWwgPyB0aGlzLnBhbmVsLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wIDogMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhbmVsIHNob3VsZCBoaWRlIGl0c2VsZiB3aGVuIHRoZSBvcHRpb24gbGlzdCBpcyBlbXB0eS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5fc2V0VmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zaG93UGFuZWwgPSAhIV90aGlzLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgX3RoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYSBjbGFzcyBvbiB0aGUgcGFuZWwgYmFzZWQgb24gaXRzIHBvc2l0aW9uICh1c2VkIHRvIHNldCB5LW9mZnNldCkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuX2dldENsYXNzTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdtYXQtYXV0b2NvbXBsZXRlLXBhbmVsLWJlbG93JzogdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycsXG4gICAgICAgICAgICAnbWF0LWF1dG9jb21wbGV0ZS1wYW5lbC1hYm92ZSc6IHRoaXMucG9zaXRpb25ZID09PSAnYWJvdmUnLFxuICAgICAgICAgICAgJ21hdC1hdXRvY29tcGxldGUtdmlzaWJsZSc6IHRoaXMuc2hvd1BhbmVsLFxuICAgICAgICAgICAgJ21hdC1hdXRvY29tcGxldGUtaGlkZGVuJzogIXRoaXMuc2hvd1BhbmVsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTWRBdXRvY29tcGxldGU7XG59KCkpO1xuTWRBdXRvY29tcGxldGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1hdXRvY29tcGxldGUsIG1hdC1hdXRvY29tcGxldGUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy10ZW1wbGF0ZT48ZGl2IGNsYXNzPVxcXCJtYXQtYXV0b2NvbXBsZXRlLXBhbmVsXFxcIiByb2xlPVxcXCJsaXN0Ym94XFxcIiBbaWRdPVxcXCJpZFxcXCIgW25nQ2xhc3NdPVxcXCJfZ2V0Q2xhc3NMaXN0KClcXFwiICNwYW5lbD48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+PC9uZy10ZW1wbGF0ZT5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtYXV0b2NvbXBsZXRlLXBhbmVse2JveC1zaGFkb3c6MCA1cHggNXB4IC0zcHggcmdiYSgwLDAsMCwuMiksMCA4cHggMTBweCAxcHggcmdiYSgwLDAsMCwuMTQpLDAgM3B4IDE0cHggMnB4IHJnYmEoMCwwLDAsLjEyKTttaW4td2lkdGg6MTEycHg7bWF4LXdpZHRoOjI4MHB4O292ZXJmbG93OmF1dG87LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7dmlzaWJpbGl0eTpoaWRkZW47bWF4LXdpZHRoOm5vbmU7bWF4LWhlaWdodDoyNTZweDtwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LWF1dG9jb21wbGV0ZS1wYW5lbC5tYXQtYXV0b2NvbXBsZXRlLXBhbmVsLWJlbG93e3RvcDo2cHh9Lm1hdC1hdXRvY29tcGxldGUtcGFuZWwubWF0LWF1dG9jb21wbGV0ZS1wYW5lbC1hYm92ZXt0b3A6LTI0cHh9Lm1hdC1hdXRvY29tcGxldGUtcGFuZWwubWF0LWF1dG9jb21wbGV0ZS12aXNpYmxle3Zpc2liaWxpdHk6dmlzaWJsZX0ubWF0LWF1dG9jb21wbGV0ZS1wYW5lbC5tYXQtYXV0b2NvbXBsZXRlLWhpZGRlbnt2aXNpYmlsaXR5OmhpZGRlbn1cIl0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21kQXV0b2NvbXBsZXRlJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtYXV0b2NvbXBsZXRlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRBdXRvY29tcGxldGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiwgfSxcbl07IH07XG5NZEF1dG9jb21wbGV0ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAndGVtcGxhdGUnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtUZW1wbGF0ZVJlZixdIH0sXSxcbiAgICAncGFuZWwnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsncGFuZWwnLF0gfSxdLFxuICAgICdvcHRpb25zJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWRPcHRpb24sXSB9LF0sXG4gICAgJ2Rpc3BsYXlXaXRoJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbi8qKlxuICogVGhlIGhlaWdodCBvZiBlYWNoIGF1dG9jb21wbGV0ZSBvcHRpb24uXG4gKi9cbnZhciBBVVRPQ09NUExFVEVfT1BUSU9OX0hFSUdIVCA9IDQ4O1xuLyoqXG4gKiBUaGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBhdXRvY29tcGxldGUgcGFuZWwuXG4gKi9cbnZhciBBVVRPQ09NUExFVEVfUEFORUxfSEVJR0hUID0gMjU2O1xuLyoqXG4gKiBQcm92aWRlciB0aGF0IGFsbG93cyB0aGUgYXV0b2NvbXBsZXRlIHRvIHJlZ2lzdGVyIGFzIGEgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1EX0FVVE9DT01QTEVURV9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZEF1dG9jb21wbGV0ZVRyaWdnZXI7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gdXNlIGFuIGF1dG9jb21wbGV0ZSB0cmlnZ2VyIHdpdGhvdXQgYSBwYW5lbC5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE1kQXV0b2NvbXBsZXRlTWlzc2luZ1BhbmVsRXJyb3IoKSB7XG4gICAgcmV0dXJuIEVycm9yKCdBdHRlbXB0aW5nIHRvIG9wZW4gYW4gdW5kZWZpbmVkIGluc3RhbmNlIG9mIGBtZC1hdXRvY29tcGxldGVgLiAnICtcbiAgICAgICAgJ01ha2Ugc3VyZSB0aGF0IHRoZSBpZCBwYXNzZWQgdG8gdGhlIGBtZEF1dG9jb21wbGV0ZWAgaXMgY29ycmVjdCBhbmQgdGhhdCAnICtcbiAgICAgICAgJ3lvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gb3BlbiBpdCBhZnRlciB0aGUgbmdBZnRlckNvbnRlbnRJbml0IGhvb2suJyk7XG59XG52YXIgTWRBdXRvY29tcGxldGVUcmlnZ2VyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX292ZXJsYXlcbiAgICAgKiBAcGFyYW0gez99IF92aWV3Q29udGFpbmVyUmVmXG4gICAgICogQHBhcmFtIHs/fSBfem9uZVxuICAgICAqIEBwYXJhbSB7P30gX2NoYW5nZURldGVjdG9yUmVmXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICogQHBhcmFtIHs/fSBfaW5wdXRDb250YWluZXJcbiAgICAgKiBAcGFyYW0gez99IF9kb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kQXV0b2NvbXBsZXRlVHJpZ2dlcihfZWxlbWVudCwgX292ZXJsYXksIF92aWV3Q29udGFpbmVyUmVmLCBfem9uZSwgX2NoYW5nZURldGVjdG9yUmVmLCBfZGlyLCBfaW5wdXRDb250YWluZXIsIF9kb2N1bWVudCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9pbnB1dENvbnRhaW5lciA9IF9pbnB1dENvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHBsYWNlaG9sZGVyIHN0YXRlIGlzIGJlaW5nIG92ZXJyaWRkZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW51YWxseUZsb2F0aW5nUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gdmFsdWUgY2hhbmdlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWaWV3IC0+IG1vZGVsIGNhbGxiYWNrIGNhbGxlZCB3aGVuIGF1dG9jb21wbGV0ZSBoYXMgYmVlbiB0b3VjaGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLCBcIl9tYXRBdXRvY29tcGxldGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydHkgd2l0aCBtYXQtIHByZWZpeCBmb3Igbm8tY29uZmxpY3QgbW9kZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0b2NvbXBsZXRlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhdXRvY29tcGxldGVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGF1dG9jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGUgPSBhdXRvY29tcGxldGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhbmVsUG9zaXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhbmVsUG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZXN0cm95UGFuZWwoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLCBcInBhbmVsT3BlblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFuZWxPcGVuICYmIHRoaXMuYXV0b2NvbXBsZXRlLnNob3dQYW5lbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uIHBhbmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5vcGVuUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5hdXRvY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1kQXV0b2NvbXBsZXRlTWlzc2luZ1BhbmVsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qKiBVcGRhdGUgdGhlIHBhbmVsIHdpZHRoLCBpbiBjYXNlIHRoZSBob3N0IHdpZHRoIGhhcyBjaGFuZ2VkICovXG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmdldFN0YXRlKCkud2lkdGggPSB0aGlzLl9nZXRIb3N0V2lkdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYudXBkYXRlU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmICYmICF0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zaW5nQWN0aW9uc1N1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmliZVRvQ2xvc2luZ0FjdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5fc2V0VmlzaWJpbGl0eSgpO1xuICAgICAgICB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyKCk7XG4gICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uIHBhbmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5jbG9zZVBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZiAmJiB0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zaW5nQWN0aW9uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXNldFBsYWNlaG9sZGVyKCk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIG1hbnVhbGx5LCBiZWNhdXNlXG4gICAgICAgIC8vIGBmcm9tRXZlbnRgIGRvZXNuJ3Qgc2VlbSB0byBkbyBpdCBhdCB0aGUgcHJvcGVyIHRpbWUuXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBwbGFjZWhvbGRlciBpcyByZXNldCB3aGVuIHRoZVxuICAgICAgICAvLyB1c2VyIGNsaWNrcyBvdXRzaWRlLlxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZSwgXCJwYW5lbENsb3NpbmdBY3Rpb25zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RyZWFtIG9mIGFjdGlvbnMgdGhhdCBzaG91bGQgY2xvc2UgdGhlIGF1dG9jb21wbGV0ZSBwYW5lbCwgaW5jbHVkaW5nXG4gICAgICAgICAqIHdoZW4gYW4gb3B0aW9uIGlzIHNlbGVjdGVkLCBvbiBibHVyLCBhbmQgd2hlbiBUQUIgaXMgcHJlc3NlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlKHRoaXMub3B0aW9uU2VsZWN0aW9ucywgdGhpcy5hdXRvY29tcGxldGUuX2tleU1hbmFnZXIudGFiT3V0LCB0aGlzLl9vdXRzaWRlQ2xpY2tTdHJlYW0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZSwgXCJvcHRpb25TZWxlY3Rpb25zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmVhbSBvZiBhdXRvY29tcGxldGUgb3B0aW9uIHNlbGVjdGlvbnMuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZS5hcHBseSh2b2lkIDAsIHRoaXMuYXV0b2NvbXBsZXRlLm9wdGlvbnMubWFwKGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIG9wdGlvbi5vblNlbGVjdGlvbkNoYW5nZTsgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZSwgXCJhY3RpdmVPcHRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgb3B0aW9uLCBjb2VyY2VkIHRvIE1kT3B0aW9uIHR5cGUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9jb21wbGV0ZSAmJiB0aGlzLmF1dG9jb21wbGV0ZS5fa2V5TWFuYWdlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5hdXRvY29tcGxldGUuX2tleU1hbmFnZXIuYWN0aXZlSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUsIFwiX291dHNpZGVDbGlja1N0cmVhbVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJlYW0gb2YgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGF1dG9jb21wbGV0ZSBwYW5lbC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2YobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUnhDaGFpbi5mcm9tKG1lcmdlKGZyb21FdmVudCh0aGlzLl9kb2N1bWVudCwgJ2NsaWNrJyksIGZyb21FdmVudCh0aGlzLl9kb2N1bWVudCwgJ3RvdWNoZW5kJykpKS5jYWxsKGZpbHRlciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xpY2tUYXJnZXQgPSAoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dENvbnRhaW5lciA9IF90aGlzLl9pbnB1dENvbnRhaW5lciA/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnB1dENvbnRhaW5lci5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50IDogbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3BhbmVsT3BlbiAmJlxuICAgICAgICAgICAgICAgICAgICBjbGlja1RhcmdldCAhPT0gX3RoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAoIWlucHV0Q29udGFpbmVyIHx8ICFpbnB1dENvbnRhaW5lci5jb250YWlucyhjbGlja1RhcmdldCkpICYmXG4gICAgICAgICAgICAgICAgICAgICghIV90aGlzLl9vdmVybGF5UmVmICYmICFfdGhpcy5fb3ZlcmxheVJlZi5vdmVybGF5RWxlbWVudC5jb250YWlucyhjbGlja1RhcmdldCkpO1xuICAgICAgICAgICAgfSkucmVzdWx0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGF1dG9jb21wbGV0ZSdzIHZhbHVlLiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2VcbiAgICAgKiByZXF1aXJlZCB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlIE5ldyB2YWx1ZSB0byBiZSB3cml0dGVuIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc2V0VHJpZ2dlclZhbHVlKHZhbHVlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYXZlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgYXV0b2NvbXBsZXRlJ3MgdmFsdWVcbiAgICAgKiBjaGFuZ2VzIGZyb20gdXNlciBpbnB1dC4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlXG4gICAgICogcmVxdWlyZWQgdG8gaW50ZWdyYXRlIHdpdGggQW5ndWxhcidzIGNvcmUgZm9ybXMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBmbiBDYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2F2ZXMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gdGhlIGF1dG9jb21wbGV0ZSBpcyBibHVycmVkXG4gICAgICogYnkgdGhlIHVzZXIuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSByZXF1aXJlZFxuICAgICAqIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZm4gQ2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB0b3VjaGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSAmJiB0aGlzLnBhbmVsT3Blbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVPcHRpb24gJiYgZXZlbnQua2V5Q29kZSA9PT0gRU5URVIpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlT3B0aW9uLl9zZWxlY3RWaWFJbnRlcmFjdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZBY3RpdmVJdGVtXzEgPSB0aGlzLmF1dG9jb21wbGV0ZS5fa2V5TWFuYWdlci5hY3RpdmVJdGVtO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNBcnJvd0tleV8xID0gZXZlbnQua2V5Q29kZSA9PT0gVVBfQVJST1cgfHwgZXZlbnQua2V5Q29kZSA9PT0gRE9XTl9BUlJPVztcbiAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLl9rZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgICAgICAgICBpZiAoaXNBcnJvd0tleV8xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuUGFuZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Fycm93S2V5XzEgfHwgX3RoaXMuYXV0b2NvbXBsZXRlLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0gIT09IHByZXZBY3RpdmVJdGVtXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njcm9sbFRvT3B0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2hhbmRsZUlucHV0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGlucHV0IGlzIGZvY3VzZWQsIGJlY2F1c2UgSUUgd2lsbCBmaXJlIHRoZSBgaW5wdXRgXG4gICAgICAgIC8vIGV2ZW50IG9uIGZvY3VzL2JsdXIvbG9hZCBpZiB0aGUgaW5wdXQgaGFzIGEgcGxhY2Vob2xkZXIuIFNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84ODU3NDcvXG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBldmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCgoZXZlbnQudGFyZ2V0KSkudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5vcGVuUGFuZWwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW4gXCJhdXRvXCIgbW9kZSwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYW5pbWF0ZSBkb3duIGFzIHNvb24gYXMgZm9jdXMgaXMgbG9zdC5cbiAgICAgKiBUaGlzIGNhdXNlcyB0aGUgdmFsdWUgdG8ganVtcCB3aGVuIHNlbGVjdGluZyBhbiBvcHRpb24gd2l0aCB0aGUgbW91c2UuXG4gICAgICogVGhpcyBtZXRob2QgbWFudWFsbHkgZmxvYXRzIHRoZSBwbGFjZWhvbGRlciB1bnRpbCB0aGUgcGFuZWwgY2FuIGJlIGNsb3NlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2Zsb2F0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dENvbnRhaW5lciAmJiB0aGlzLl9pbnB1dENvbnRhaW5lci5mbG9hdFBsYWNlaG9sZGVyID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0Q29udGFpbmVyLmZsb2F0UGxhY2Vob2xkZXIgPSAnYWx3YXlzJztcbiAgICAgICAgICAgIHRoaXMuX21hbnVhbGx5RmxvYXRpbmdQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBwbGFjZWhvbGRlciBoYXMgYmVlbiBtYW51YWxseSBlbGV2YXRlZCwgcmV0dXJuIGl0IHRvIGl0cyBub3JtYWwgc3RhdGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9yZXNldFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFudWFsbHlGbG9hdGluZ1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dENvbnRhaW5lci5mbG9hdFBsYWNlaG9sZGVyID0gJ2F1dG8nO1xuICAgICAgICAgICAgdGhpcy5fbWFudWFsbHlGbG9hdGluZ1BsYWNlaG9sZGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoYXQgd2UgYXJlIG5vdCBhY3R1YWxseSBmb2N1c2luZyBhY3RpdmUgb3B0aW9ucywgd2UgbXVzdCBtYW51YWxseSBhZGp1c3Qgc2Nyb2xsXG4gICAgICogdG8gcmV2ZWFsIG9wdGlvbnMgYmVsb3cgdGhlIGZvbGQuIEZpcnN0LCB3ZSBmaW5kIHRoZSBvZmZzZXQgb2YgdGhlIG9wdGlvbiBmcm9tIHRoZSB0b3BcbiAgICAgKiBvZiB0aGUgcGFuZWwuIElmIHRoYXQgb2Zmc2V0IGlzIGJlbG93IHRoZSBmb2xkLCB0aGUgbmV3IHNjcm9sbFRvcCB3aWxsIGJlIHRoZSBvZmZzZXQgLVxuICAgICAqIHRoZSBwYW5lbCBoZWlnaHQgKyB0aGUgb3B0aW9uIGhlaWdodCwgc28gdGhlIGFjdGl2ZSBvcHRpb24gd2lsbCBiZSBqdXN0IHZpc2libGUgYXQgdGhlXG4gICAgICogYm90dG9tIG9mIHRoZSBwYW5lbC4gSWYgdGhhdCBvZmZzZXQgaXMgYWJvdmUgdGhlIHRvcCBvZiB0aGUgdmlzaWJsZSBwYW5lbCwgdGhlIG5ldyBzY3JvbGxUb3BcbiAgICAgKiB3aWxsIGJlY29tZSB0aGUgb2Zmc2V0LiBJZiB0aGF0IG9mZnNldCBpcyB2aXNpYmxlIHdpdGhpbiB0aGUgcGFuZWwgYWxyZWFkeSwgdGhlIHNjcm9sbFRvcCBpc1xuICAgICAqIG5vdCBhZGp1c3RlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3Njcm9sbFRvT3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25PZmZzZXQgPSB0aGlzLmF1dG9jb21wbGV0ZS5fa2V5TWFuYWdlci5hY3RpdmVJdGVtSW5kZXggP1xuICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuX2tleU1hbmFnZXIuYWN0aXZlSXRlbUluZGV4ICogQVVUT0NPTVBMRVRFX09QVElPTl9IRUlHSFQgOiAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYW5lbFRvcCA9IHRoaXMuYXV0b2NvbXBsZXRlLl9nZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgaWYgKG9wdGlvbk9mZnNldCA8IHBhbmVsVG9wKSB7XG4gICAgICAgICAgICAvLyBTY3JvbGwgdXAgdG8gcmV2ZWFsIHNlbGVjdGVkIG9wdGlvbiBzY3JvbGxlZCBhYm92ZSB0aGUgcGFuZWwgdG9wXG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5fc2V0U2Nyb2xsVG9wKG9wdGlvbk9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9uT2Zmc2V0ICsgQVVUT0NPTVBMRVRFX09QVElPTl9IRUlHSFQgPiBwYW5lbFRvcCArIEFVVE9DT01QTEVURV9QQU5FTF9IRUlHSFQpIHtcbiAgICAgICAgICAgIC8vIFNjcm9sbCBkb3duIHRvIHJldmVhbCBzZWxlY3RlZCBvcHRpb24gc2Nyb2xsZWQgYmVsb3cgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3U2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgb3B0aW9uT2Zmc2V0IC0gQVVUT0NPTVBMRVRFX1BBTkVMX0hFSUdIVCArIEFVVE9DT01QTEVURV9PUFRJT05fSEVJR0hUKTtcbiAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLl9zZXRTY3JvbGxUb3AobmV3U2Nyb2xsVG9wKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbGlzdGVucyB0byBhIHN0cmVhbSBvZiBwYW5lbCBjbG9zaW5nIGFjdGlvbnMgYW5kIHJlc2V0cyB0aGVcbiAgICAgKiBzdHJlYW0gZXZlcnkgdGltZSB0aGUgb3B0aW9uIGxpc3QgY2hhbmdlcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3N1YnNjcmliZVRvQ2xvc2luZ0FjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdoZW4gdGhlIHpvbmUgaXMgc3RhYmxlIGluaXRpYWxseSwgYW5kIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGNoYW5nZXMuLi5cbiAgICAgICAgcmV0dXJuIFJ4Q2hhaW4uZnJvbShtZXJnZShmaXJzdC5jYWxsKHRoaXMuX3pvbmUub25TdGFibGUpLCB0aGlzLmF1dG9jb21wbGV0ZS5vcHRpb25zLmNoYW5nZXMpKVxuICAgICAgICAgICAgLmNhbGwoc3dpdGNoTWFwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzZXRQYW5lbCgpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBhbmVsQ2xvc2luZ0FjdGlvbnM7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2FsbChmaXJzdClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5fc2V0VmFsdWVBbmRDbG9zZShldmVudCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uIHBhbmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fZGVzdHJveVBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9zZXRUcmlnZ2VyVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9EaXNwbGF5ID0gdGhpcy5hdXRvY29tcGxldGUuZGlzcGxheVdpdGggPyB0aGlzLmF1dG9jb21wbGV0ZS5kaXNwbGF5V2l0aCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgLy8gU2ltcGx5IGZhbGxpbmcgYmFjayB0byBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGRpc3BsYXkgdmFsdWUgaXMgZmFsc3kgZG9lcyBub3Qgd29yayBwcm9wZXJseS5cbiAgICAgICAgLy8gVGhlIGRpc3BsYXkgdmFsdWUgY2FuIGFsc28gYmUgdGhlIG51bWJlciB6ZXJvIGFuZCBzaG91bGRuJ3QgZmFsbCBiYWNrIHRvIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LnZhbHVlID0gdG9EaXNwbGF5ICE9IG51bGwgPyB0b0Rpc3BsYXkgOiAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNsb3NlcyB0aGUgcGFuZWwsIGFuZCBpZiBhIHZhbHVlIGlzIHNwZWNpZmllZCwgYWxzbyBzZXRzIHRoZSBhc3NvY2lhdGVkXG4gICAgICogY29udHJvbCB0byB0aGF0IHZhbHVlLiBJdCB3aWxsIGFsc28gbWFyayB0aGUgY29udHJvbCBhcyBkaXJ0eSBpZiB0aGlzIGludGVyYWN0aW9uXG4gICAgICogc3RlbW1lZCBmcm9tIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3NldFZhbHVlQW5kQ2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJQcmV2aW91c1NlbGVjdGVkT3B0aW9uKGV2ZW50LnNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRUcmlnZ2VyVmFsdWUoZXZlbnQuc291cmNlLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKGV2ZW50LnNvdXJjZS52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlUGFuZWwoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFyIGFueSBwcmV2aW91cyBzZWxlY3RlZCBvcHRpb24gYW5kIGVtaXQgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGZvciB0aGlzIG9wdGlvblxuICAgICAqIEBwYXJhbSB7P30gc2tpcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fY2xlYXJQcmV2aW91c1NlbGVjdGVkT3B0aW9uID0gZnVuY3Rpb24gKHNraXApIHtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24gIT0gc2tpcCAmJiBvcHRpb24uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uZGVzZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0aGlzLmF1dG9jb21wbGV0ZS50ZW1wbGF0ZSwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZSh0aGlzLl9nZXRPdmVybGF5Q29uZmlnKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9nZXRPdmVybGF5Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5U3RhdGUgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fZ2V0T3ZlcmxheVBvc2l0aW9uKCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS53aWR0aCA9IHRoaXMuX2dldEhvc3RXaWR0aCgpO1xuICAgICAgICBvdmVybGF5U3RhdGUuZGlyZWN0aW9uID0gdGhpcy5fZGlyID8gdGhpcy5fZGlyLnZhbHVlIDogJ2x0cic7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5zY3JvbGxTdHJhdGVneSA9IHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKCk7XG4gICAgICAgIHJldHVybiBvdmVybGF5U3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2dldE92ZXJsYXlQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX292ZXJsYXkucG9zaXRpb24oKS5jb25uZWN0ZWRUbyh0aGlzLl9lbGVtZW50LCB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nIH0sIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAndG9wJyB9KVxuICAgICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ3RvcCcgfSwgeyBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICdib3R0b20nIH0pO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb1Bvc2l0aW9uQ2hhbmdlcyh0aGlzLl9wb3NpdGlvblN0cmF0ZWd5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3k7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzdWJzY3JpYmVzIHRvIHBvc2l0aW9uIGNoYW5nZXMgaW4gdGhlIGF1dG9jb21wbGV0ZSBwYW5lbCwgc28gdGhlIHBhbmVsJ3NcbiAgICAgKiB5LW9mZnNldCBjYW4gYmUgYWRqdXN0ZWQgdG8gbWF0Y2ggdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gez99IHN0cmF0ZWd5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9zdWJzY3JpYmVUb1Bvc2l0aW9uQ2hhbmdlcyA9IGZ1bmN0aW9uIChzdHJhdGVneSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9wYW5lbFBvc2l0aW9uU3Vic2NyaXB0aW9uID0gc3RyYXRlZ3kub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgX3RoaXMuYXV0b2NvbXBsZXRlLnBvc2l0aW9uWSA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vcmlnaW5ZID09PSAndG9wJyA/ICdhYm92ZScgOiAnYmVsb3cnO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBpbnB1dCBlbGVtZW50LCBzbyB0aGUgcGFuZWwgd2lkdGggY2FuIG1hdGNoIGl0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fZ2V0SG9zdFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXQgYWN0aXZlIGl0ZW0gdG8gLTEgc28gYXJyb3cgZXZlbnRzIHdpbGwgYWN0aXZhdGUgdGhlIGNvcnJlY3Qgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3Jlc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuX2tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbSgtMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGFjdGl2ZSBpdGVtIGFuZCByZS1jYWxjdWxhdGVzIGFsaWdubWVudCBvZiB0aGUgcGFuZWwgaW4gY2FzZSBpdHMgc2l6ZVxuICAgICAqIGhhcyBjaGFuZ2VkIGR1ZSB0byBmZXdlciBvciBncmVhdGVyIG51bWJlciBvZiBvcHRpb25zLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fcmVzZXRQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRBY3RpdmVJdGVtKCk7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kucmVjYWxjdWxhdGVMYXN0UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuX3NldFZpc2liaWxpdHkoKTtcbiAgICB9O1xuICAgIHJldHVybiBNZEF1dG9jb21wbGV0ZVRyaWdnZXI7XG59KCkpO1xuTWRBdXRvY29tcGxldGVUcmlnZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFttZEF1dG9jb21wbGV0ZV0sIGlucHV0W21hdEF1dG9jb21wbGV0ZV0sJyArXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0YXJlYVttZEF1dG9jb21wbGV0ZV0sIHRleHRhcmVhW21hdEF1dG9jb21wbGV0ZV0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnY29tYm9ib3gnLFxuICAgICAgICAgICAgICAgICAgICAnYXV0b2NvbXBsZXRlJzogJ29mZicsXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6ICdsaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtbXVsdGlsaW5lJzogJ2ZhbHNlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtYWN0aXZlZGVzY2VuZGFudF0nOiAnYWN0aXZlT3B0aW9uPy5pZCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdwYW5lbE9wZW4udG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLW93bnNdJzogJ2F1dG9jb21wbGV0ZT8uaWQnLFxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSB1c2UgYGZvY3VzaW5gLCBhcyBvcHBvc2VkIHRvIGBmb2N1c2AsIGluIG9yZGVyIHRvIG9wZW4gdGhlIHBhbmVsXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgbGl0dGxlIGVhcmxpZXIuIFRoaXMgYXZvaWRzIGlzc3VlcyB3aGVyZSBJRSBkZWxheXMgdGhlIGZvY3VzaW5nIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgICAgICAgICAgICAgJyhmb2N1c2luKSc6ICdvcGVuUGFuZWwoKScsXG4gICAgICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ19oYW5kbGVJbnB1dCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdfb25Ub3VjaGVkKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfQVVUT0NPTVBMRVRFX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEF1dG9jb21wbGV0ZVRyaWdnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogT3ZlcmxheSwgfSxcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICB7IHR5cGU6IERpcmVjdGlvbmFsaXR5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IE1kSW5wdXRDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSG9zdCB9LF0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtET0NVTUVOVCxdIH0sXSB9LFxuXTsgfTtcbk1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnYXV0b2NvbXBsZXRlJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWRBdXRvY29tcGxldGUnLF0gfSxdLFxuICAgICdfbWF0QXV0b2NvbXBsZXRlJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0QXV0b2NvbXBsZXRlJyxdIH0sXSxcbn07XG52YXIgTWRBdXRvY29tcGxldGVNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEF1dG9jb21wbGV0ZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQXV0b2NvbXBsZXRlTW9kdWxlO1xufSgpKTtcbk1kQXV0b2NvbXBsZXRlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWRPcHRpb25Nb2R1bGUsIE92ZXJsYXlNb2R1bGUsIE1kQ29tbW9uTW9kdWxlLCBDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNZEF1dG9jb21wbGV0ZSwgTWRPcHRpb25Nb2R1bGUsIE1kQXV0b2NvbXBsZXRlVHJpZ2dlciwgTWRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kQXV0b2NvbXBsZXRlLCBNZEF1dG9jb21wbGV0ZVRyaWdnZXJdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZEF1dG9jb21wbGV0ZU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBBbiBpbnRlcm5hbCBjbGFzcyB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGEgY29ycmVzcG9uZGluZyB0byBhIHNpbmdsZSBjYWxlbmRhciBjZWxsLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZENhbGVuZGFyQ2VsbCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGRpc3BsYXlWYWx1ZVxuICAgICAqIEBwYXJhbSB7P30gYXJpYUxhYmVsXG4gICAgICogQHBhcmFtIHs/fSBlbmFibGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRDYWxlbmRhckNlbGwodmFsdWUsIGRpc3BsYXlWYWx1ZSwgYXJpYUxhYmVsLCBlbmFibGVkKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgIHRoaXMuYXJpYUxhYmVsID0gYXJpYUxhYmVsO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIH1cbiAgICByZXR1cm4gTWRDYWxlbmRhckNlbGw7XG59KCkpO1xuLyoqXG4gKiBBbiBpbnRlcm5hbCBjb21wb25lbnQgdXNlZCB0byBkaXNwbGF5IGNhbGVuZGFyIGRhdGEgaW4gYSB0YWJsZS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYWxlbmRhckJvZHkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhbGVuZGFyQm9keSgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm51bUNvbHMgPSA3O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBhbGxvdyBzZWxlY3Rpb24gb2YgZGlzYWJsZWQgY2VsbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbG93RGlzYWJsZWRTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjZWxsIG51bWJlciBvZiB0aGUgYWN0aXZlIGNlbGwgaW4gdGhlIHRhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVDZWxsID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gYSBuZXcgdmFsdWUgaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2VsbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhckJvZHkucHJvdG90eXBlLl9jZWxsQ2xpY2tlZCA9IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0Rpc2FibGVkU2VsZWN0aW9uICYmICFjZWxsLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWVDaGFuZ2UuZW1pdChjZWxsLnZhbHVlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENhbGVuZGFyQm9keS5wcm90b3R5cGUsIFwiX2ZpcnN0Um93T2Zmc2V0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgYmxhbmsgY2VsbHMgdG8gcHV0IGF0IHRoZSBiZWdpbm5pbmcgZm9yIHRoZSBmaXJzdCByb3cuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd3MgJiYgdGhpcy5yb3dzLmxlbmd0aCAmJiB0aGlzLnJvd3NbMF0ubGVuZ3RoID9cbiAgICAgICAgICAgICAgICB0aGlzLm51bUNvbHMgLSB0aGlzLnJvd3NbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByb3dJbmRleFxuICAgICAqIEBwYXJhbSB7P30gY29sSW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXJCb2R5LnByb3RvdHlwZS5faXNBY3RpdmVDZWxsID0gZnVuY3Rpb24gKHJvd0luZGV4LCBjb2xJbmRleCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjZWxsTnVtYmVyID0gcm93SW5kZXggKiB0aGlzLm51bUNvbHMgKyBjb2xJbmRleDtcbiAgICAgICAgLy8gQWNjb3VudCBmb3IgdGhlIGZhY3QgdGhhdCB0aGUgZmlyc3Qgcm93IG1heSBub3QgaGF2ZSBhcyBtYW55IGNlbGxzLlxuICAgICAgICBpZiAocm93SW5kZXgpIHtcbiAgICAgICAgICAgIGNlbGxOdW1iZXIgLT0gdGhpcy5fZmlyc3RSb3dPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGxOdW1iZXIgPT0gdGhpcy5hY3RpdmVDZWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE1kQ2FsZW5kYXJCb2R5O1xufSgpKTtcbk1kQ2FsZW5kYXJCb2R5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21kLWNhbGVuZGFyLWJvZHldJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dHIgKm5nSWY9XFxcIl9maXJzdFJvd09mZnNldCA8IGxhYmVsTWluUmVxdWlyZWRDZWxsc1xcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjx0ZCBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLWJvZHktbGFiZWxcXFwiIFthdHRyLmNvbHNwYW5dPVxcXCJudW1Db2xzXFxcIj57e2xhYmVsfX08L3RkPjwvdHI+PHRyICpuZ0Zvcj1cXFwibGV0IHJvdyBvZiByb3dzOyBsZXQgcm93SW5kZXggPSBpbmRleFxcXCIgcm9sZT1cXFwicm93XFxcIj48dGQgKm5nSWY9XFxcInJvd0luZGV4ID09PSAwICYmIF9maXJzdFJvd09mZnNldFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItYm9keS1sYWJlbFxcXCIgW2F0dHIuY29sc3Bhbl09XFxcIl9maXJzdFJvd09mZnNldFxcXCI+e3tfZmlyc3RSb3dPZmZzZXQgPj0gbGFiZWxNaW5SZXF1aXJlZENlbGxzID8gbGFiZWwgOiAnJ319PC90ZD48dGQgKm5nRm9yPVxcXCJsZXQgaXRlbSBvZiByb3c7IGxldCBjb2xJbmRleCA9IGluZGV4XFxcIiByb2xlPVxcXCJncmlkY2VsbFxcXCIgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1ib2R5LWNlbGxcXFwiIFt0YWJpbmRleF09XFxcIl9pc0FjdGl2ZUNlbGwocm93SW5kZXgsIGNvbEluZGV4KSA/IDAgOiAtMVxcXCIgW2NsYXNzLm1hdC1jYWxlbmRhci1ib2R5LWRpc2FibGVkXT1cXFwiIWl0ZW0uZW5hYmxlZFxcXCIgW2NsYXNzLm1hdC1jYWxlbmRhci1ib2R5LWFjdGl2ZV09XFxcIl9pc0FjdGl2ZUNlbGwocm93SW5kZXgsIGNvbEluZGV4KVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcIml0ZW0uYXJpYUxhYmVsXFxcIiBbYXR0ci5hcmlhLWRpc2FibGVkXT1cXFwiIWl0ZW0uZW5hYmxlZCB8fCBudWxsXFxcIiAoY2xpY2spPVxcXCJfY2VsbENsaWNrZWQoaXRlbSlcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1ib2R5LWNlbGwtY29udGVudFxcXCIgW2NsYXNzLm1hdC1jYWxlbmRhci1ib2R5LXNlbGVjdGVkXT1cXFwic2VsZWN0ZWRWYWx1ZSA9PT0gaXRlbS52YWx1ZVxcXCIgW2NsYXNzLm1hdC1jYWxlbmRhci1ib2R5LXRvZGF5XT1cXFwidG9kYXlWYWx1ZSA9PT0gaXRlbS52YWx1ZVxcXCI+e3tpdGVtLmRpc3BsYXlWYWx1ZX19PC9kaXY+PC90ZD48L3RyPlwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1jYWxlbmRhci1ib2R5e21pbi13aWR0aDoyMjRweH0ubWF0LWNhbGVuZGFyLWJvZHktbGFiZWx7cGFkZGluZzo3LjE0Mjg2JSAwIDcuMTQyODYlIDcuMTQyODYlO2hlaWdodDowO2xpbmUtaGVpZ2h0OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTZweCk7dGV4dC1hbGlnbjpsZWZ0fS5tYXQtY2FsZW5kYXItYm9keS1jZWxse3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjE0LjI4NTcxJTtoZWlnaHQ6MDtsaW5lLWhlaWdodDowO3BhZGRpbmc6Ny4xNDI4NiUgMDt0ZXh0LWFsaWduOmNlbnRlcjtvdXRsaW5lOjA7Y3Vyc29yOnBvaW50ZXJ9Lm1hdC1jYWxlbmRhci1ib2R5LWRpc2FibGVke2N1cnNvcjpkZWZhdWx0fS5tYXQtY2FsZW5kYXItYm9keS1jZWxsLWNvbnRlbnR7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUlO2xlZnQ6NSU7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDo5MCU7aGVpZ2h0OjkwJTtib3JkZXItd2lkdGg6MXB4O2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItcmFkaXVzOjUwJX1bZGlyPXJ0bF0gLm1hdC1jYWxlbmRhci1ib2R5LWxhYmVse3BhZGRpbmc6MCA3LjE0Mjg2JSAwIDA7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoNnB4KTt0ZXh0LWFsaWduOnJpZ2h0fVwiXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtY2FsZW5kYXItYm9keScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENhbGVuZGFyQm9keS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuTWRDYWxlbmRhckJvZHkucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2xhYmVsJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdyb3dzJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd0b2RheVZhbHVlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzZWxlY3RlZFZhbHVlJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdsYWJlbE1pblJlcXVpcmVkQ2VsbHMnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ251bUNvbHMnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2FsbG93RGlzYWJsZWRTZWxlY3Rpb24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2FjdGl2ZUNlbGwnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkVmFsdWVDaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxufTtcbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcihwcm92aWRlcikge1xuICAgIHJldHVybiBFcnJvcihcIk1kRGF0ZXBpY2tlcjogTm8gcHJvdmlkZXIgZm91bmQgZm9yIFwiICsgcHJvdmlkZXIgKyBcIi4gWW91IG11c3QgaW1wb3J0IG9uZSBvZiB0aGUgZm9sbG93aW5nIFwiICtcbiAgICAgICAgXCJtb2R1bGVzIGF0IHlvdXIgYXBwbGljYXRpb24gcm9vdDogTWROYXRpdmVEYXRlTW9kdWxlLCBvciBwcm92aWRlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlwiKTtcbn1cbnZhciBEQVlTX1BFUl9XRUVLID0gNztcbi8qKlxuICogQW4gaW50ZXJuYWwgY29tcG9uZW50IHVzZWQgdG8gZGlzcGxheSBhIHNpbmdsZSBtb250aCBpbiB0aGUgZGF0ZXBpY2tlci5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRNb250aFZpZXcgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kYXRlQWRhcHRlclxuICAgICAqIEBwYXJhbSB7P30gX2RhdGVGb3JtYXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRNb250aFZpZXcoX2RhdGVBZGFwdGVyLCBfZGF0ZUZvcm1hdHMpIHtcbiAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIgPSBfZGF0ZUFkYXB0ZXI7XG4gICAgICAgIHRoaXMuX2RhdGVGb3JtYXRzID0gX2RhdGVGb3JtYXRzO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgd2hlbiBhIG5ldyBkYXRlIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlcikge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ0RhdGVBZGFwdGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlRm9ybWF0cykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ01EX0RBVEVfRk9STUFUUycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdERheU9mV2VlayA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldEZpcnN0RGF5T2ZXZWVrKCk7XG4gICAgICAgIHZhciBuYXJyb3dXZWVrZGF5cyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldERheU9mV2Vla05hbWVzKCduYXJyb3cnKTtcbiAgICAgICAgdmFyIGxvbmdXZWVrZGF5cyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldERheU9mV2Vla05hbWVzKCdsb25nJyk7XG4gICAgICAgIC8vIFJvdGF0ZSB0aGUgbGFiZWxzIGZvciBkYXlzIG9mIHRoZSB3ZWVrIGJhc2VkIG9uIHRoZSBjb25maWd1cmVkIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgdmFyIHdlZWtkYXlzID0gbG9uZ1dlZWtkYXlzLm1hcChmdW5jdGlvbiAobG9uZywgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbG9uZzogbG9uZywgbmFycm93OiBuYXJyb3dXZWVrZGF5c1tpXSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXMgPSB3ZWVrZGF5cy5zbGljZShmaXJzdERheU9mV2VlaykuY29uY2F0KHdlZWtkYXlzLnNsaWNlKDAsIGZpcnN0RGF5T2ZXZWVrKSk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci50b2RheSgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNb250aFZpZXcucHJvdG90eXBlLCBcImFjdGl2ZURhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGUgdG8gZGlzcGxheSBpbiB0aGlzIG1vbnRoIHZpZXcgKGV2ZXJ5dGhpbmcgb3RoZXIgdGhhbiB0aGUgbW9udGggYW5kIHllYXIgaXMgaWdub3JlZCkuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FjdGl2ZURhdGU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkQWN0aXZlRGF0ZSA9IHRoaXMuX2FjdGl2ZURhdGU7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdmFsdWUgfHwgdGhpcy5fZGF0ZUFkYXB0ZXIudG9kYXkoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFzU2FtZU1vbnRoQW5kWWVhcihvbGRBY3RpdmVEYXRlLCB0aGlzLl9hY3RpdmVEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTW9udGhWaWV3LnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZERhdGUgPSB0aGlzLl9nZXREYXRlSW5DdXJyZW50TW9udGgodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNb250aFZpZXcucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB3aGVuIGEgbmV3IGRhdGUgaXMgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1vbnRoVmlldy5wcm90b3R5cGUuX2RhdGVTZWxlY3RlZCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZERhdGUgPT0gZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSwgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5hY3RpdmVEYXRlKSwgZGF0ZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhpcyBtb250aCB2aWV3LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNb250aFZpZXcucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZERhdGUgPSB0aGlzLl9nZXREYXRlSW5DdXJyZW50TW9udGgodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuX3RvZGF5RGF0ZSA9IHRoaXMuX2dldERhdGVJbkN1cnJlbnRNb250aCh0aGlzLl9kYXRlQWRhcHRlci50b2RheSgpKTtcbiAgICAgICAgdGhpcy5fbW9udGhMYWJlbCA9XG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aE5hbWVzKCdzaG9ydCcpW3RoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKHRoaXMuYWN0aXZlRGF0ZSldXG4gICAgICAgICAgICAgICAgLnRvTG9jYWxlVXBwZXJDYXNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpcnN0T2ZNb250aCA9IHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLmFjdGl2ZURhdGUpLCB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aCh0aGlzLmFjdGl2ZURhdGUpLCAxKTtcbiAgICAgICAgdGhpcy5fZmlyc3RXZWVrT2Zmc2V0ID1cbiAgICAgICAgICAgIChEQVlTX1BFUl9XRUVLICsgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF5T2ZXZWVrKGZpcnN0T2ZNb250aCkgLVxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldEZpcnN0RGF5T2ZXZWVrKCkpICUgREFZU19QRVJfV0VFSztcbiAgICAgICAgdGhpcy5fY3JlYXRlV2Vla0NlbGxzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIE1kQ2FsZW5kYXJDZWxscyBmb3IgdGhlIGRhdGVzIGluIHRoaXMgbW9udGguXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE1vbnRoVmlldy5wcm90b3R5cGUuX2NyZWF0ZVdlZWtDZWxscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGF5c0luTW9udGggPSB0aGlzLl9kYXRlQWRhcHRlci5nZXROdW1EYXlzSW5Nb250aCh0aGlzLmFjdGl2ZURhdGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkYXRlTmFtZXMgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXREYXRlTmFtZXMoKTtcbiAgICAgICAgdGhpcy5fd2Vla3MgPSBbW11dO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwLCAvKiogQHR5cGUgez99ICovIGNlbGwgPSB0aGlzLl9maXJzdFdlZWtPZmZzZXQ7IGkgPCBkYXlzSW5Nb250aDsgaSsrLCBjZWxsKyspIHtcbiAgICAgICAgICAgIGlmIChjZWxsID09IERBWVNfUEVSX1dFRUspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrcy5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICBjZWxsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSwgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5hY3RpdmVEYXRlKSwgaSArIDEpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5hYmxlZCA9ICF0aGlzLmRhdGVGaWx0ZXIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGVGaWx0ZXIoZGF0ZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmlhTGFiZWwgPSB0aGlzLl9kYXRlQWRhcHRlci5mb3JtYXQoZGF0ZSwgdGhpcy5fZGF0ZUZvcm1hdHMuZGlzcGxheS5kYXRlQTExeUxhYmVsKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtzW3RoaXMuX3dlZWtzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgLnB1c2gobmV3IE1kQ2FsZW5kYXJDZWxsKGkgKyAxLCBkYXRlTmFtZXNbaV0sIGFyaWFMYWJlbCwgZW5hYmxlZCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRlIGluIHRoaXMgbW9udGggdGhhdCB0aGUgZ2l2ZW4gRGF0ZSBmYWxscyBvbi5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGdpdmVuIERhdGUgaXMgaW4gYW5vdGhlciBtb250aC5cbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kTW9udGhWaWV3LnByb3RvdHlwZS5fZ2V0RGF0ZUluQ3VycmVudE1vbnRoID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1NhbWVNb250aEFuZFllYXIoZGF0ZSwgdGhpcy5hY3RpdmVEYXRlKSA/XG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXREYXRlKGRhdGUpIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSAyIGRhdGVzIGFyZSBub24tbnVsbCBhbmQgZmFsbCB3aXRoaW4gdGhlIHNhbWUgbW9udGggb2YgdGhlIHNhbWUgeWVhci5cbiAgICAgKiBAcGFyYW0gez99IGQxXG4gICAgICogQHBhcmFtIHs/fSBkMlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRNb250aFZpZXcucHJvdG90eXBlLl9oYXNTYW1lTW9udGhBbmRZZWFyID0gZnVuY3Rpb24gKGQxLCBkMikge1xuICAgICAgICByZXR1cm4gISEoZDEgJiYgZDIgJiYgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgoZDEpID09IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGQyKSAmJlxuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkMSkgPT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkMikpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kTW9udGhWaWV3O1xufSgpKTtcbk1kTW9udGhWaWV3LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtbW9udGgtdmlldycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHRhYmxlIGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItdGFibGVcXFwiPjx0aGVhZCBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLXRhYmxlLWhlYWRlclxcXCI+PHRyPjx0aCAqbmdGb3I9XFxcImxldCBkYXkgb2YgX3dlZWtkYXlzXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiZGF5LmxvbmdcXFwiPnt7ZGF5Lm5hcnJvd319PC90aD48L3RyPjx0cj48dGggY2xhc3M9XFxcIm1hdC1jYWxlbmRhci10YWJsZS1oZWFkZXItZGl2aWRlclxcXCIgY29sc3Bhbj1cXFwiN1xcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvdGg+PC90cj48L3RoZWFkPjx0Ym9keSBtZC1jYWxlbmRhci1ib2R5IHJvbGU9XFxcImdyaWRcXFwiIFtsYWJlbF09XFxcIl9tb250aExhYmVsXFxcIiBbcm93c109XFxcIl93ZWVrc1xcXCIgW3RvZGF5VmFsdWVdPVxcXCJfdG9kYXlEYXRlXFxcIiBbc2VsZWN0ZWRWYWx1ZV09XFxcIl9zZWxlY3RlZERhdGVcXFwiIFtsYWJlbE1pblJlcXVpcmVkQ2VsbHNdPVxcXCIzXFxcIiBbYWN0aXZlQ2VsbF09XFxcIl9kYXRlQWRhcHRlci5nZXREYXRlKGFjdGl2ZURhdGUpIC0gMVxcXCIgKHNlbGVjdGVkVmFsdWVDaGFuZ2UpPVxcXCJfZGF0ZVNlbGVjdGVkKCRldmVudClcXFwiPjwvdGJvZHk+PC90YWJsZT5cIixcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZE1vbnRoVmlldy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IERhdGVBZGFwdGVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNRF9EQVRFX0ZPUk1BVFMsXSB9LF0gfSxcbl07IH07XG5NZE1vbnRoVmlldy5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnYWN0aXZlRGF0ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc2VsZWN0ZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2RhdGVGaWx0ZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG4vKipcbiAqIEFuIGludGVybmFsIGNvbXBvbmVudCB1c2VkIHRvIGRpc3BsYXkgYSBzaW5nbGUgeWVhciBpbiB0aGUgZGF0ZXBpY2tlci5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRZZWFyVmlldyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2RhdGVBZGFwdGVyXG4gICAgICogQHBhcmFtIHs/fSBfZGF0ZUZvcm1hdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFllYXJWaWV3KF9kYXRlQWRhcHRlciwgX2RhdGVGb3JtYXRzKSB7XG4gICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyID0gX2RhdGVBZGFwdGVyO1xuICAgICAgICB0aGlzLl9kYXRlRm9ybWF0cyA9IF9kYXRlRm9ybWF0cztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gYSBuZXcgbW9udGggaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGVBZGFwdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignRGF0ZUFkYXB0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2RhdGVGb3JtYXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignTURfREFURV9GT1JNQVRTJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLnRvZGF5KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFllYXJWaWV3LnByb3RvdHlwZSwgXCJhY3RpdmVEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIHRvIGRpc3BsYXkgaW4gdGhpcyB5ZWFyIHZpZXcgKGV2ZXJ5dGhpbmcgb3RoZXIgdGhhbiB0aGUgeWVhciBpcyBpZ25vcmVkKS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWN0aXZlRGF0ZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRBY3RpdmVEYXRlID0gdGhpcy5fYWN0aXZlRGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB2YWx1ZSB8fCB0aGlzLl9kYXRlQWRhcHRlci50b2RheSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIob2xkQWN0aXZlRGF0ZSkgIT0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLl9hY3RpdmVEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kWWVhclZpZXcucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGggPSB0aGlzLl9nZXRNb250aEluQ3VycmVudFllYXIodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRZZWFyVmlldy5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdoZW4gYSBuZXcgbW9udGggaXMgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHs/fSBtb250aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRZZWFyVmlldy5wcm90b3R5cGUuX21vbnRoU2VsZWN0ZWQgPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuX2RhdGVBZGFwdGVyLmNyZWF0ZURhdGUodGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcih0aGlzLmFjdGl2ZURhdGUpLCBtb250aCwgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF0ZSh0aGlzLmFjdGl2ZURhdGUpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGlzIG1vbnRoIHZpZXcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFllYXJWaWV3LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRNb250aCA9IHRoaXMuX2dldE1vbnRoSW5DdXJyZW50WWVhcih0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5fdG9kYXlNb250aCA9IHRoaXMuX2dldE1vbnRoSW5DdXJyZW50WWVhcih0aGlzLl9kYXRlQWRhcHRlci50b2RheSgpKTtcbiAgICAgICAgdGhpcy5feWVhckxhYmVsID0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhck5hbWUodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9udGhOYW1lcyA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoTmFtZXMoJ3Nob3J0Jyk7XG4gICAgICAgIC8vIEZpcnN0IHJvdyBvZiBtb250aHMgb25seSBjb250YWlucyA1IGVsZW1lbnRzIHNvIHdlIGNhbiBmaXQgdGhlIHllYXIgbGFiZWwgb24gdGhlIHNhbWUgcm93LlxuICAgICAgICB0aGlzLl9tb250aHMgPSBbWzAsIDEsIDIsIDMsIDRdLCBbNSwgNiwgNywgOCwgOSwgMTAsIDExXV0ubWFwKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKG1vbnRoKSB7IHJldHVybiBfdGhpcy5fY3JlYXRlQ2VsbEZvck1vbnRoKG1vbnRoLCBtb250aE5hbWVzW21vbnRoXSk7IH0pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1vbnRoIGluIHRoaXMgeWVhciB0aGF0IHRoZSBnaXZlbiBEYXRlIGZhbGxzIG9uLlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZ2l2ZW4gRGF0ZSBpcyBpbiBhbm90aGVyIHllYXIuXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFllYXJWaWV3LnByb3RvdHlwZS5fZ2V0TW9udGhJbkN1cnJlbnRZZWFyID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUgJiYgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhcihkYXRlKSA9PSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuYWN0aXZlRGF0ZSkgP1xuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgoZGF0ZSkgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBNZENhbGVuZGFyQ2VsbCBmb3IgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAqIEBwYXJhbSB7P30gbW9udGhcbiAgICAgKiBAcGFyYW0gez99IG1vbnRoTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRZZWFyVmlldy5wcm90b3R5cGUuX2NyZWF0ZUNlbGxGb3JNb250aCA9IGZ1bmN0aW9uIChtb250aCwgbW9udGhOYW1lKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyaWFMYWJlbCA9IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdCh0aGlzLl9kYXRlQWRhcHRlci5jcmVhdGVEYXRlKHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSwgbW9udGgsIDEpLCB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5Lm1vbnRoWWVhckExMXlMYWJlbCk7XG4gICAgICAgIHJldHVybiBuZXcgTWRDYWxlbmRhckNlbGwobW9udGgsIG1vbnRoTmFtZS50b0xvY2FsZVVwcGVyQ2FzZSgpLCBhcmlhTGFiZWwsIHRoaXMuX2lzTW9udGhFbmFibGVkKG1vbnRoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBnaXZlbiBtb250aCBpcyBlbmFibGVkLlxuICAgICAqIEBwYXJhbSB7P30gbW9udGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kWWVhclZpZXcucHJvdG90eXBlLl9pc01vbnRoRW5hYmxlZCA9IGZ1bmN0aW9uIChtb250aCkge1xuICAgICAgICBpZiAoIXRoaXMuZGF0ZUZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlyc3RPZk1vbnRoID0gdGhpcy5fZGF0ZUFkYXB0ZXIuY3JlYXRlRGF0ZSh0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKHRoaXMuYWN0aXZlRGF0ZSksIG1vbnRoLCAxKTtcbiAgICAgICAgLy8gSWYgYW55IGRhdGUgaW4gdGhlIG1vbnRoIGlzIGVuYWJsZWQgY291bnQgdGhlIG1vbnRoIGFzIGVuYWJsZWQuXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gZGF0ZSA9IGZpcnN0T2ZNb250aDsgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgoZGF0ZSkgPT0gbW9udGg7IGRhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhckRheXMoZGF0ZSwgMSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGVGaWx0ZXIoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gTWRZZWFyVmlldztcbn0oKSk7XG5NZFllYXJWaWV3LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQteWVhci12aWV3JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dGFibGUgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci10YWJsZVxcXCI+PHRoZWFkIGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItdGFibGUtaGVhZGVyXFxcIj48dHI+PHRoIGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItdGFibGUtaGVhZGVyLWRpdmlkZXJcXFwiIGNvbHNwYW49XFxcIjdcXFwiPjwvdGg+PC90cj48L3RoZWFkPjx0Ym9keSBtZC1jYWxlbmRhci1ib2R5IHJvbGU9XFxcImdyaWRcXFwiIGFsbG93RGlzYWJsZWRTZWxlY3Rpb249XFxcInRydWVcXFwiIFtsYWJlbF09XFxcIl95ZWFyTGFiZWxcXFwiIFtyb3dzXT1cXFwiX21vbnRoc1xcXCIgW3RvZGF5VmFsdWVdPVxcXCJfdG9kYXlNb250aFxcXCIgW3NlbGVjdGVkVmFsdWVdPVxcXCJfc2VsZWN0ZWRNb250aFxcXCIgW2xhYmVsTWluUmVxdWlyZWRDZWxsc109XFxcIjJcXFwiIFthY3RpdmVDZWxsXT1cXFwiX2RhdGVBZGFwdGVyLmdldE1vbnRoKGFjdGl2ZURhdGUpXFxcIiAoc2VsZWN0ZWRWYWx1ZUNoYW5nZSk9XFxcIl9tb250aFNlbGVjdGVkKCRldmVudClcXFwiPjwvdGJvZHk+PC90YWJsZT5cIixcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFllYXJWaWV3LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRGF0ZUFkYXB0ZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01EX0RBVEVfRk9STUFUUyxdIH0sXSB9LFxuXTsgfTtcbk1kWWVhclZpZXcucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2FjdGl2ZURhdGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdkYXRlRmlsdGVyJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzZWxlY3RlZENoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG59O1xuLyoqXG4gKiBEYXRlcGlja2VyIGRhdGEgdGhhdCByZXF1aXJlcyBpbnRlcm5hdGlvbmFsaXphdGlvbi5cbiAqL1xudmFyIE1kRGF0ZXBpY2tlckludGwgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERhdGVwaWNrZXJJbnRsKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsYWJlbCBmb3IgdGhlIGNhbGVuZGFyIHBvcHVwICh1c2VkIGJ5IHNjcmVlbiByZWFkZXJzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FsZW5kYXJMYWJlbCA9ICdDYWxlbmRhcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxhYmVsIGZvciB0aGUgYnV0dG9uIHVzZWQgdG8gb3BlbiB0aGUgY2FsZW5kYXIgcG9wdXAgKHVzZWQgYnkgc2NyZWVuIHJlYWRlcnMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuQ2FsZW5kYXJMYWJlbCA9ICdPcGVuIGNhbGVuZGFyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSBwcmV2aW91cyBtb250aCBidXR0b24gKHVzZWQgYnkgc2NyZWVuIHJlYWRlcnMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2TW9udGhMYWJlbCA9ICdQcmV2aW91cyBtb250aCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxhYmVsIGZvciB0aGUgbmV4dCBtb250aCBidXR0b24gKHVzZWQgYnkgc2NyZWVuIHJlYWRlcnMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0TW9udGhMYWJlbCA9ICdOZXh0IG1vbnRoJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSBwcmV2aW91cyB5ZWFyIGJ1dHRvbiAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZZZWFyTGFiZWwgPSAnUHJldmlvdXMgeWVhcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxhYmVsIGZvciB0aGUgbmV4dCB5ZWFyIGJ1dHRvbiAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHRZZWFyTGFiZWwgPSAnTmV4dCB5ZWFyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSAnc3dpdGNoIHRvIG1vbnRoIHZpZXcnIGJ1dHRvbiAodXNlZCBieSBzY3JlZW4gcmVhZGVycykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN3aXRjaFRvTW9udGhWaWV3TGFiZWwgPSAnQ2hhbmdlIHRvIG1vbnRoIHZpZXcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsYWJlbCBmb3IgdGhlICdzd2l0Y2ggdG8geWVhciB2aWV3JyBidXR0b24gKHVzZWQgYnkgc2NyZWVuIHJlYWRlcnMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zd2l0Y2hUb1llYXJWaWV3TGFiZWwgPSAnQ2hhbmdlIHRvIHllYXIgdmlldyc7XG4gICAgfVxuICAgIHJldHVybiBNZERhdGVwaWNrZXJJbnRsO1xufSgpKTtcbk1kRGF0ZXBpY2tlckludGwuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kRGF0ZXBpY2tlckludGwuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQSBjYWxlbmRhciB0aGF0IGlzIHVzZWQgYXMgcGFydCBvZiB0aGUgZGF0ZXBpY2tlci5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRDYWxlbmRhciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9pbnRsXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBfaXNDb21wYXRpYmlsaXR5TW9kZVxuICAgICAqIEBwYXJhbSB7P30gX2RhdGVBZGFwdGVyXG4gICAgICogQHBhcmFtIHs/fSBfZGF0ZUZvcm1hdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZENhbGVuZGFyKF9lbGVtZW50UmVmLCBfaW50bCwgX25nWm9uZSwgX2lzQ29tcGF0aWJpbGl0eU1vZGUsIF9kYXRlQWRhcHRlciwgX2RhdGVGb3JtYXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5faW50bCA9IF9pbnRsO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9pc0NvbXBhdGliaWxpdHlNb2RlID0gX2lzQ29tcGF0aWJpbGl0eU1vZGU7XG4gICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyID0gX2RhdGVBZGFwdGVyO1xuICAgICAgICB0aGlzLl9kYXRlRm9ybWF0cyA9IF9kYXRlRm9ybWF0cztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIHNob3VsZCBiZSBzdGFydGVkIGluIG1vbnRoIG9yIHllYXIgdmlldy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRWaWV3ID0gJ21vbnRoJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlIGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGF0ZSBmaWx0ZXIgZm9yIHRoZSBtb250aCBhbmQgeWVhciB2aWV3cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RhdGVGaWx0ZXJGb3JWaWV3cyA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gISFkYXRlICYmXG4gICAgICAgICAgICAgICAgKCFfdGhpcy5kYXRlRmlsdGVyIHx8IF90aGlzLmRhdGVGaWx0ZXIoZGF0ZSkpICYmXG4gICAgICAgICAgICAgICAgKCFfdGhpcy5taW5EYXRlIHx8IF90aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShkYXRlLCBfdGhpcy5taW5EYXRlKSA+PSAwKSAmJlxuICAgICAgICAgICAgICAgICghX3RoaXMubWF4RGF0ZSB8fCBfdGhpcy5fZGF0ZUFkYXB0ZXIuY29tcGFyZURhdGUoZGF0ZSwgX3RoaXMubWF4RGF0ZSkgPD0gMCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5fZGF0ZUFkYXB0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdEYXRlQWRhcHRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGF0ZUZvcm1hdHMpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdEYXRlSW1wbEVycm9yKCdNRF9EQVRFX0ZPUk1BVFMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDYWxlbmRhci5wcm90b3R5cGUsIFwiX2FjdGl2ZURhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgYWN0aXZlIGRhdGUuIFRoaXMgZGV0ZXJtaW5lcyB3aGljaCB0aW1lIHBlcmlvZCBpcyBzaG93biBhbmQgd2hpY2ggZGF0ZSBpc1xuICAgICAgICAgKiBoaWdobGlnaHRlZCB3aGVuIHVzaW5nIGtleWJvYXJkIG5hdmlnYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NsYW1wZWRBY3RpdmVEYXRlOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsYW1wZWRBY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuY2xhbXBEYXRlKHZhbHVlLCB0aGlzLm1pbkRhdGUsIHRoaXMubWF4RGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENhbGVuZGFyLnByb3RvdHlwZSwgXCJfcGVyaW9kQnV0dG9uVGV4dFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFiZWwgZm9yIHRoZSBjdXJyZW50IGNhbGVuZGFyIHZpZXcuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aFZpZXcgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdCh0aGlzLl9hY3RpdmVEYXRlLCB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5Lm1vbnRoWWVhckxhYmVsKVxuICAgICAgICAgICAgICAgICAgICAudG9Mb2NhbGVVcHBlckNhc2UoKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0WWVhck5hbWUodGhpcy5fYWN0aXZlRGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENhbGVuZGFyLnByb3RvdHlwZSwgXCJfcGVyaW9kQnV0dG9uTGFiZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoVmlldyA/IHRoaXMuX2ludGwuc3dpdGNoVG9ZZWFyVmlld0xhYmVsIDogdGhpcy5faW50bC5zd2l0Y2hUb01vbnRoVmlld0xhYmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDYWxlbmRhci5wcm90b3R5cGUsIFwiX3ByZXZCdXR0b25MYWJlbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFiZWwgZm9yIHRoZSB0aGUgcHJldmlvdXMgYnV0dG9uLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhWaWV3ID8gdGhpcy5faW50bC5wcmV2TW9udGhMYWJlbCA6IHRoaXMuX2ludGwucHJldlllYXJMYWJlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2FsZW5kYXIucHJvdG90eXBlLCBcIl9uZXh0QnV0dG9uTGFiZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhYmVsIGZvciB0aGUgdGhlIG5leHQgYnV0dG9uLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhWaWV3ID8gdGhpcy5faW50bC5uZXh0TW9udGhMYWJlbCA6IHRoaXMuX2ludGwubmV4dFllYXJMYWJlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENhbGVuZGFyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLnN0YXJ0QXQgfHwgdGhpcy5fZGF0ZUFkYXB0ZXIudG9kYXkoKTtcbiAgICAgICAgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKCk7XG4gICAgICAgIHRoaXMuX21vbnRoVmlldyA9IHRoaXMuc3RhcnRWaWV3ICE9ICd5ZWFyJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgZGF0ZSBzZWxlY3Rpb24gaW4gdGhlIG1vbnRoIHZpZXcuXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENhbGVuZGFyLnByb3RvdHlwZS5fZGF0ZVNlbGVjdGVkID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlci5zYW1lRGF0ZShkYXRlLCB0aGlzLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KGRhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG1vbnRoIHNlbGVjdGlvbiBpbiB0aGUgeWVhciB2aWV3LlxuICAgICAqIEBwYXJhbSB7P30gbW9udGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9tb250aFNlbGVjdGVkID0gZnVuY3Rpb24gKG1vbnRoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBtb250aDtcbiAgICAgICAgdGhpcy5fbW9udGhWaWV3ID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdXNlciBjbGlja3Mgb24gdGhlIHBlcmlvZCBsYWJlbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9jdXJyZW50UGVyaW9kQ2xpY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW9udGhWaWV3ID0gIXRoaXMuX21vbnRoVmlldztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdXNlciBjbGlja3Mgb24gdGhlIHByZXZpb3VzIGJ1dHRvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9wcmV2aW91c0NsaWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9tb250aFZpZXcgP1xuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSwgLTEpIDpcbiAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyWWVhcnModGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB1c2VyIGNsaWNrcyBvbiB0aGUgbmV4dCBidXR0b24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENhbGVuZGFyLnByb3RvdHlwZS5fbmV4dENsaWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9tb250aFZpZXcgP1xuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSwgMSkgOlxuICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLCAxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHByZXZpb3VzIHBlcmlvZCBidXR0b24gaXMgZW5hYmxlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9wcmV2aW91c0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5taW5EYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMubWluRGF0ZSB8fCAhdGhpcy5faXNTYW1lVmlldyh0aGlzLl9hY3RpdmVEYXRlLCB0aGlzLm1pbkRhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbmV4dCBwZXJpb2QgYnV0dG9uIGlzIGVuYWJsZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENhbGVuZGFyLnByb3RvdHlwZS5fbmV4dEVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5tYXhEYXRlIHx8ICF0aGlzLl9pc1NhbWVWaWV3KHRoaXMuX2FjdGl2ZURhdGUsIHRoaXMubWF4RGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzIG9uIHRoZSBjYWxlbmRhciBib2R5LlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9oYW5kbGVDYWxlbmRhckJvZHlLZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFRPRE8obW1hbGVyYmEpOiBXZSBjdXJyZW50bHkgYWxsb3cga2V5Ym9hcmQgbmF2aWdhdGlvbiB0byBkaXNhYmxlZCBkYXRlcywgYnV0IGp1c3QgcHJldmVudFxuICAgICAgICAvLyBkaXNhYmxlZCBvbmVzIGZyb20gYmVpbmcgc2VsZWN0ZWQuIFRoaXMgbWF5IG5vdCBiZSBpZGVhbCwgd2Ugc2hvdWxkIGxvb2sgaW50byB3aGV0aGVyXG4gICAgICAgIC8vIG5hdmlnYXRpb24gc2hvdWxkIHNraXAgb3ZlciBkaXNhYmxlZCBkYXRlcywgYW5kIGlmIHNvLCBob3cgdG8gaW1wbGVtZW50IHRoYXQgZWZmaWNpZW50bHkuXG4gICAgICAgIGlmICh0aGlzLl9tb250aFZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd25Jbk1vbnRoVmlldyhldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVDYWxlbmRhckJvZHlLZXlkb3duSW5ZZWFyVmlldyhldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGFjdGl2ZSBjZWxsIGFmdGVyIHRoZSBtaWNyb3Rhc2sgcXVldWUgaXMgZW1wdHkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZENhbGVuZGFyLnByb3RvdHlwZS5fZm9jdXNBY3RpdmVDZWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlyc3QuY2FsbChfdGhpcy5fbmdab25lLm9uU3RhYmxlKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWF0LWNhbGVuZGFyLWJvZHktYWN0aXZlJykuZm9jdXMoKTtcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgdHdvIGRhdGVzIHJlcHJlc2VudCB0aGUgc2FtZSB2aWV3IGluIHRoZSBjdXJyZW50IHZpZXcgbW9kZSAobW9udGggb3IgeWVhcikuXG4gICAgICogQHBhcmFtIHs/fSBkYXRlMVxuICAgICAqIEBwYXJhbSB7P30gZGF0ZTJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9pc1NhbWVWaWV3ID0gZnVuY3Rpb24gKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhWaWV3ID9cbiAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZTEpID09IHRoaXMuX2RhdGVBZGFwdGVyLmdldFllYXIoZGF0ZTIpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgoZGF0ZTEpID09IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUyKSA6XG4gICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKGRhdGUxKSA9PSB0aGlzLl9kYXRlQWRhcHRlci5nZXRZZWFyKGRhdGUyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMga2V5ZG93biBldmVudHMgb24gdGhlIGNhbGVuZGFyIGJvZHkgd2hlbiBjYWxlbmRhciBpcyBpbiBtb250aCB2aWV3LlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9oYW5kbGVDYWxlbmRhckJvZHlLZXlkb3duSW5Nb250aFZpZXcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyRGF5cyh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhckRheXModGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhckRheXModGhpcy5fYWN0aXZlRGF0ZSwgLTcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhckRheXModGhpcy5fYWN0aXZlRGF0ZSwgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhPTUU6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyRGF5cyh0aGlzLl9hY3RpdmVEYXRlLCAxIC0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0RGF0ZSh0aGlzLl9hY3RpdmVEYXRlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVORDpcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJEYXlzKHRoaXMuX2FjdGl2ZURhdGUsICh0aGlzLl9kYXRlQWRhcHRlci5nZXROdW1EYXlzSW5Nb250aCh0aGlzLl9hY3RpdmVEYXRlKSAtXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmdldERhdGUodGhpcy5fYWN0aXZlRGF0ZSkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUEFHRV9VUDpcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gZXZlbnQuYWx0S2V5ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLCAtMSkgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBBR0VfRE9XTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gZXZlbnQuYWx0S2V5ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLCAxKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFTlRFUjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGF0ZUZpbHRlckZvclZpZXdzKHRoaXMuX2FjdGl2ZURhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVTZWxlY3RlZCh0aGlzLl9hY3RpdmVEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCB1bmV4cGVjdGVkIGRlZmF1bHQgYWN0aW9ucyBzdWNoIGFzIGZvcm0gc3VibWlzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwcmV2ZW50IGRlZmF1bHQgb3IgZm9jdXMgYWN0aXZlIGNlbGwgb24ga2V5cyB0aGF0IHdlIGRvbid0IGV4cGxpY2l0bHkgaGFuZGxlLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb2N1c0FjdGl2ZUNlbGwoKTtcbiAgICAgICAgLy8gUHJldmVudCB1bmV4cGVjdGVkIGRlZmF1bHQgYWN0aW9ucyBzdWNoIGFzIGZvcm0gc3VibWlzc2lvbi5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMga2V5ZG93biBldmVudHMgb24gdGhlIGNhbGVuZGFyIGJvZHkgd2hlbiBjYWxlbmRhciBpcyBpbiB5ZWFyIHZpZXcuXG4gICAgICogQHBhcmFtIHs/fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhci5wcm90b3R5cGUuX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd25JblllYXJWaWV3ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLl9hY3RpdmVEYXRlLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX3ByZXZNb250aEluU2FtZUNvbCh0aGlzLl9hY3RpdmVEYXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRE9XTl9BUlJPVzpcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fbmV4dE1vbnRoSW5TYW1lQ29sKHRoaXMuX2FjdGl2ZURhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIT01FOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyh0aGlzLl9hY3RpdmVEYXRlLCAtdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5fYWN0aXZlRGF0ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFTkQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsIDExIC0gdGhpcy5fZGF0ZUFkYXB0ZXIuZ2V0TW9udGgodGhpcy5fYWN0aXZlRGF0ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQQUdFX1VQOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhclllYXJzKHRoaXMuX2FjdGl2ZURhdGUsIGV2ZW50LmFsdEtleSA/IC0xMCA6IC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUEFHRV9ET1dOOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhclllYXJzKHRoaXMuX2FjdGl2ZURhdGUsIGV2ZW50LmFsdEtleSA/IDEwIDogMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVOVEVSOlxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoU2VsZWN0ZWQodGhpcy5fYWN0aXZlRGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIERvbid0IHByZXZlbnQgZGVmYXVsdCBvciBmb2N1cyBhY3RpdmUgY2VsbCBvbiBrZXlzIHRoYXQgd2UgZG9uJ3QgZXhwbGljaXRseSBoYW5kbGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCgpO1xuICAgICAgICAvLyBQcmV2ZW50IHVuZXhwZWN0ZWQgZGVmYXVsdCBhY3Rpb25zIHN1Y2ggYXMgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBkYXRlIGZvciB0aGUgbW9udGggdGhhdCBjb21lcyBiZWZvcmUgdGhlIGdpdmVuIG1vbnRoIGluIHRoZSBzYW1lIGNvbHVtbiBpbiB0aGVcbiAgICAgKiBjYWxlbmRhciB0YWJsZS5cbiAgICAgKiBAcGFyYW0gez99IGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kQ2FsZW5kYXIucHJvdG90eXBlLl9wcmV2TW9udGhJblNhbWVDb2wgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgaG93IG1hbnkgbW9udGhzIHRvIGp1bXAgZm9yd2FyZCBnaXZlbiB0aGF0IHRoZXJlIGFyZSAyIGVtcHR5IHNsb3RzIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgLy8gb2YgZWFjaCB5ZWFyLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmNyZW1lbnQgPSB0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aChkYXRlKSA8PSA0ID8gLTUgOlxuICAgICAgICAgICAgKHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUpID49IDcgPyAtNyA6IC0xMik7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlQWRhcHRlci5hZGRDYWxlbmRhck1vbnRocyhkYXRlLCBpbmNyZW1lbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBkYXRlIGZvciB0aGUgbW9udGggdGhhdCBjb21lcyBhZnRlciB0aGUgZ2l2ZW4gbW9udGggaW4gdGhlIHNhbWUgY29sdW1uIGluIHRoZVxuICAgICAqIGNhbGVuZGFyIHRhYmxlLlxuICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRDYWxlbmRhci5wcm90b3R5cGUuX25leHRNb250aEluU2FtZUNvbCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIC8vIERldGVybWluZSBob3cgbWFueSBtb250aHMgdG8ganVtcCBmb3J3YXJkIGdpdmVuIHRoYXQgdGhlcmUgYXJlIDIgZW1wdHkgc2xvdHMgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAvLyBvZiBlYWNoIHllYXIuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluY3JlbWVudCA9IHRoaXMuX2RhdGVBZGFwdGVyLmdldE1vbnRoKGRhdGUpIDw9IDQgPyA3IDpcbiAgICAgICAgICAgICh0aGlzLl9kYXRlQWRhcHRlci5nZXRNb250aChkYXRlKSA+PSA3ID8gNSA6IDEyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVBZGFwdGVyLmFkZENhbGVuZGFyTW9udGhzKGRhdGUsIGluY3JlbWVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRDYWxlbmRhcjtcbn0oKSk7XG5NZENhbGVuZGFyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtY2FsZW5kYXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1oZWFkZXJcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1jb250cm9sc1xcXCI+PGJ1dHRvbiAqbmdJZj1cXFwiIV9pc0NvbXBhdGliaWxpdHlNb2RlXFxcIiBtZC1idXR0b24gY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1wZXJpb2QtYnV0dG9uXFxcIiAoY2xpY2spPVxcXCJfY3VycmVudFBlcmlvZENsaWNrZWQoKVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcIl9wZXJpb2RCdXR0b25MYWJlbFxcXCI+e3tfcGVyaW9kQnV0dG9uVGV4dH19PGRpdiBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLWFycm93XFxcIiBbY2xhc3MubWF0LWNhbGVuZGFyLWludmVydF09XFxcIiFfbW9udGhWaWV3XFxcIj48L2Rpdj48L2J1dHRvbj4gPGJ1dHRvbiAqbmdJZj1cXFwiX2lzQ29tcGF0aWJpbGl0eU1vZGVcXFwiIG1hdC1idXR0b24gY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1wZXJpb2QtYnV0dG9uXFxcIiAoY2xpY2spPVxcXCJfY3VycmVudFBlcmlvZENsaWNrZWQoKVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcIl9wZXJpb2RCdXR0b25MYWJlbFxcXCI+e3tfcGVyaW9kQnV0dG9uVGV4dH19PGRpdiBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLWFycm93XFxcIiBbY2xhc3MubWF0LWNhbGVuZGFyLWludmVydF09XFxcIiFfbW9udGhWaWV3XFxcIj48L2Rpdj48L2J1dHRvbj48ZGl2IGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItc3BhY2VyXFxcIj48L2Rpdj48YnV0dG9uICpuZ0lmPVxcXCIhX2lzQ29tcGF0aWJpbGl0eU1vZGVcXFwiIG1kLWljb24tYnV0dG9uIGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItcHJldmlvdXMtYnV0dG9uXFxcIiBbZGlzYWJsZWRdPVxcXCIhX3ByZXZpb3VzRW5hYmxlZCgpXFxcIiAoY2xpY2spPVxcXCJfcHJldmlvdXNDbGlja2VkKClcXFwiIFthdHRyLmFyaWEtbGFiZWxdPVxcXCJfcHJldkJ1dHRvbkxhYmVsXFxcIj48L2J1dHRvbj4gPGJ1dHRvbiAqbmdJZj1cXFwiX2lzQ29tcGF0aWJpbGl0eU1vZGVcXFwiIG1hdC1pY29uLWJ1dHRvbiBjbGFzcz1cXFwibWF0LWNhbGVuZGFyLXByZXZpb3VzLWJ1dHRvblxcXCIgW2Rpc2FibGVkXT1cXFwiIV9wcmV2aW91c0VuYWJsZWQoKVxcXCIgKGNsaWNrKT1cXFwiX3ByZXZpb3VzQ2xpY2tlZCgpXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiX3ByZXZCdXR0b25MYWJlbFxcXCI+PC9idXR0b24+IDxidXR0b24gKm5nSWY9XFxcIiFfaXNDb21wYXRpYmlsaXR5TW9kZVxcXCIgbWQtaWNvbi1idXR0b24gY2xhc3M9XFxcIm1hdC1jYWxlbmRhci1uZXh0LWJ1dHRvblxcXCIgW2Rpc2FibGVkXT1cXFwiIV9uZXh0RW5hYmxlZCgpXFxcIiAoY2xpY2spPVxcXCJfbmV4dENsaWNrZWQoKVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcIl9uZXh0QnV0dG9uTGFiZWxcXFwiPjwvYnV0dG9uPiA8YnV0dG9uICpuZ0lmPVxcXCJfaXNDb21wYXRpYmlsaXR5TW9kZVxcXCIgbWF0LWljb24tYnV0dG9uIGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItbmV4dC1idXR0b25cXFwiIFtkaXNhYmxlZF09XFxcIiFfbmV4dEVuYWJsZWQoKVxcXCIgKGNsaWNrKT1cXFwiX25leHRDbGlja2VkKClcXFwiIFthdHRyLmFyaWEtbGFiZWxdPVxcXCJfbmV4dEJ1dHRvbkxhYmVsXFxcIj48L2J1dHRvbj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtY2FsZW5kYXItY29udGVudFxcXCIgKGtleWRvd24pPVxcXCJfaGFuZGxlQ2FsZW5kYXJCb2R5S2V5ZG93bigkZXZlbnQpXFxcIiBbbmdTd2l0Y2hdPVxcXCJfbW9udGhWaWV3XFxcIiBjZGtNb25pdG9yU3VidHJlZUZvY3VzPjxtZC1tb250aC12aWV3ICpuZ1N3aXRjaENhc2U9XFxcInRydWVcXFwiIFthY3RpdmVEYXRlXT1cXFwiX2FjdGl2ZURhdGVcXFwiIFtzZWxlY3RlZF09XFxcInNlbGVjdGVkXFxcIiBbZGF0ZUZpbHRlcl09XFxcIl9kYXRlRmlsdGVyRm9yVmlld3NcXFwiIChzZWxlY3RlZENoYW5nZSk9XFxcIl9kYXRlU2VsZWN0ZWQoJGV2ZW50KVxcXCI+PC9tZC1tb250aC12aWV3PjxtZC15ZWFyLXZpZXcgKm5nU3dpdGNoRGVmYXVsdCBbYWN0aXZlRGF0ZV09XFxcIl9hY3RpdmVEYXRlXFxcIiBbc2VsZWN0ZWRdPVxcXCJzZWxlY3RlZFxcXCIgW2RhdGVGaWx0ZXJdPVxcXCJfZGF0ZUZpbHRlckZvclZpZXdzXFxcIiAoc2VsZWN0ZWRDaGFuZ2UpPVxcXCJfbW9udGhTZWxlY3RlZCgkZXZlbnQpXFxcIj48L21kLXllYXItdmlldz48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtY2FsZW5kYXJ7ZGlzcGxheTpibG9ja30ubWF0LWNhbGVuZGFyLWhlYWRlcntwYWRkaW5nOjhweCA4cHggMCA4cHh9Lm1hdC1jYWxlbmRhci1jb250ZW50e3BhZGRpbmc6MCA4cHggOHB4IDhweDtvdXRsaW5lOjB9Lm1hdC1jYWxlbmRhci1jb250cm9sc3tkaXNwbGF5OmZsZXg7cGFkZGluZzo1JSBjYWxjKDEwMCUgLyAxNCAtIDIycHgpIDUlIGNhbGMoMTAwJSAvIDE0IC0gMjJweCl9Lm1hdC1jYWxlbmRhci1zcGFjZXJ7ZmxleDoxIDEgYXV0b30ubWF0LWNhbGVuZGFyLXBlcmlvZC1idXR0b257bWluLXdpZHRoOjB9Lm1hdC1jYWxlbmRhci1hcnJvd3tkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlci1sZWZ0OjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci10b3Atd2lkdGg6NXB4O2JvcmRlci10b3Atc3R5bGU6c29saWQ7bWFyZ2luOjAgMCAwIDVweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm1hdC1jYWxlbmRhci1hcnJvdy5tYXQtY2FsZW5kYXItaW52ZXJ0e3RyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKX1bZGlyPXJ0bF0gLm1hdC1jYWxlbmRhci1hcnJvd3ttYXJnaW46MCA1cHggMCAwfS5tYXQtY2FsZW5kYXItbmV4dC1idXR0b24sLm1hdC1jYWxlbmRhci1wcmV2aW91cy1idXR0b257cG9zaXRpb246cmVsYXRpdmV9Lm1hdC1jYWxlbmRhci1uZXh0LWJ1dHRvbjo6YWZ0ZXIsLm1hdC1jYWxlbmRhci1wcmV2aW91cy1idXR0b246OmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO2JvdHRvbTowO3JpZ2h0OjA7bWFyZ2luOjE1LjVweDtib3JkZXI6MCBzb2xpZCBjdXJyZW50Q29sb3I7Ym9yZGVyLXRvcC13aWR0aDoycHh9W2Rpcj1ydGxdIC5tYXQtY2FsZW5kYXItbmV4dC1idXR0b24sW2Rpcj1ydGxdIC5tYXQtY2FsZW5kYXItcHJldmlvdXMtYnV0dG9ue3RyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKX0ubWF0LWNhbGVuZGFyLXByZXZpb3VzLWJ1dHRvbjo6YWZ0ZXJ7Ym9yZGVyLWxlZnQtd2lkdGg6MnB4O3RyYW5zZm9ybTp0cmFuc2xhdGVYKDJweCkgcm90YXRlKC00NWRlZyl9Lm1hdC1jYWxlbmRhci1uZXh0LWJ1dHRvbjo6YWZ0ZXJ7Ym9yZGVyLXJpZ2h0LXdpZHRoOjJweDt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMnB4KSByb3RhdGUoNDVkZWcpfS5tYXQtY2FsZW5kYXItdGFibGV7Ym9yZGVyLXNwYWNpbmc6MDtib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7d2lkdGg6MTAwJX0ubWF0LWNhbGVuZGFyLXRhYmxlLWhlYWRlciB0aHt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOjAgMCA4cHggMH0ubWF0LWNhbGVuZGFyLXRhYmxlLWhlYWRlci1kaXZpZGVye3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxcHh9Lm1hdC1jYWxlbmRhci10YWJsZS1oZWFkZXItZGl2aWRlcjo6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0Oi04cHg7cmlnaHQ6LThweDtoZWlnaHQ6MXB4fVwiXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtY2FsZW5kYXInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRDYWxlbmRhci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBNZERhdGVwaWNrZXJJbnRsLCB9LFxuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSxdIH0sXSB9LFxuICAgIHsgdHlwZTogRGF0ZUFkYXB0ZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01EX0RBVEVfRk9STUFUUyxdIH0sXSB9LFxuXTsgfTtcbk1kQ2FsZW5kYXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3N0YXJ0QXQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3N0YXJ0Vmlldyc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc2VsZWN0ZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ21pbkRhdGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ21heERhdGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2RhdGVGaWx0ZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ3NlbGVjdGVkQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG4vKipcbiAqIFVzZWQgdG8gZ2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIGVhY2ggZGF0ZXBpY2tlciBpbnN0YW5jZS5cbiAqL1xudmFyIGRhdGVwaWNrZXJVaWQgPSAwO1xuLyoqXG4gKiBDb21wb25lbnQgdXNlZCBhcyB0aGUgY29udGVudCBmb3IgdGhlIGRhdGVwaWNrZXIgZGlhbG9nIGFuZCBwb3B1cC4gV2UgdXNlIHRoaXMgaW5zdGVhZCBvZiB1c2luZ1xuICogTWRDYWxlbmRhciBkaXJlY3RseSBhcyB0aGUgY29udGVudCBzbyB3ZSBjYW4gY29udHJvbCB0aGUgaW5pdGlhbCBmb2N1cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFcbiAqIHBsYWNlIHRvIHB1dCBhZGRpdGlvbmFsIGZlYXR1cmVzIG9mIHRoZSBwb3B1cCB0aGF0IGFyZSBub3QgcGFydCBvZiB0aGUgY2FsZW5kYXIgaXRzZWxmIGluIHRoZVxuICogZnV0dXJlLiAoZS5nLiBjb25maXJtYXRpb24gYnV0dG9ucykuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kRGF0ZXBpY2tlckNvbnRlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERhdGVwaWNrZXJDb250ZW50KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlckNvbnRlbnQucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIuX2ZvY3VzQWN0aXZlQ2VsbCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBrZXlkb3duIGV2ZW50IG9uIGRhdGVwaWNrZXIgY29udGVudC5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50IFRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlckNvbnRlbnQucHJvdG90eXBlLl9oYW5kbGVLZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NBUEUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZXBpY2tlci5jbG9zZSgpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1kRGF0ZXBpY2tlckNvbnRlbnQ7XG59KCkpO1xuTWREYXRlcGlja2VyQ29udGVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ21kLWRhdGVwaWNrZXItY29udGVudCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG1kLWNhbGVuZGFyIGNka1RyYXBGb2N1cyBbaWRdPVxcXCJkYXRlcGlja2VyLmlkXFxcIiBbc3RhcnRBdF09XFxcImRhdGVwaWNrZXIuc3RhcnRBdFxcXCIgW3N0YXJ0Vmlld109XFxcImRhdGVwaWNrZXIuc3RhcnRWaWV3XFxcIiBbbWluRGF0ZV09XFxcImRhdGVwaWNrZXIuX21pbkRhdGVcXFwiIFttYXhEYXRlXT1cXFwiZGF0ZXBpY2tlci5fbWF4RGF0ZVxcXCIgW2RhdGVGaWx0ZXJdPVxcXCJkYXRlcGlja2VyLl9kYXRlRmlsdGVyXFxcIiBbc2VsZWN0ZWRdPVxcXCJkYXRlcGlja2VyLl9zZWxlY3RlZFxcXCIgKHNlbGVjdGVkQ2hhbmdlKT1cXFwiZGF0ZXBpY2tlci5fc2VsZWN0QW5kQ2xvc2UoJGV2ZW50KVxcXCI+PC9tZC1jYWxlbmRhcj5cIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtZGF0ZXBpY2tlci1jb250ZW50e2JveC1zaGFkb3c6MCA1cHggNXB4IC0zcHggcmdiYSgwLDAsMCwuMiksMCA4cHggMTBweCAxcHggcmdiYSgwLDAsMCwuMTQpLDAgM3B4IDE0cHggMnB4IHJnYmEoMCwwLDAsLjEyKTtkaXNwbGF5OmJsb2NrfS5tYXQtY2FsZW5kYXJ7d2lkdGg6Mjk2cHh9Lm1hdC1kYXRlcGlja2VyLWNvbnRlbnQtdG91Y2h7Ym94LXNoYWRvdzowIDAgMCAwIHJnYmEoMCwwLDAsLjIpLDAgMCAwIDAgcmdiYSgwLDAsMCwuMTQpLDAgMCAwIDAgcmdiYSgwLDAsMCwuMTIpO2Rpc3BsYXk6YmxvY2s7bWF4LWhlaWdodDo4MHZoO292ZXJmbG93OmF1dG87bWFyZ2luOi0yNHB4fS5tYXQtZGF0ZXBpY2tlci1jb250ZW50LXRvdWNoIC5tYXQtY2FsZW5kYXJ7d2lkdGg6NjR2bWluO2hlaWdodDo4MHZtaW47bWluLXdpZHRoOjI1MHB4O21pbi1oZWlnaHQ6MzEycHg7bWF4LXdpZHRoOjc1MHB4O21heC1oZWlnaHQ6Nzg4cHh9XCJdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1kYXRlcGlja2VyLWNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1kYXRlcGlja2VyLWNvbnRlbnQtdG91Y2hdJzogJ2RhdGVwaWNrZXIudG91Y2hVaScsXG4gICAgICAgICAgICAgICAgICAgICcoa2V5ZG93biknOiAnX2hhbmRsZUtleWRvd24oJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERhdGVwaWNrZXJDb250ZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG5NZERhdGVwaWNrZXJDb250ZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdfY2FsZW5kYXInOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtNZENhbGVuZGFyLF0gfSxdLFxufTtcbi8qKlxuICogQ29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB0aGUgZGF0ZXBpY2tlciBwb3B1cC9kaWFsb2cuXG4gKi9cbnZhciBNZERhdGVwaWNrZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kaWFsb2dcbiAgICAgKiBAcGFyYW0gez99IF9vdmVybGF5XG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBfdmlld0NvbnRhaW5lclJlZlxuICAgICAqIEBwYXJhbSB7P30gX2RhdGVBZGFwdGVyXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICogQHBhcmFtIHs/fSBfZG9jdW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZERhdGVwaWNrZXIoX2RpYWxvZywgX292ZXJsYXksIF9uZ1pvbmUsIF92aWV3Q29udGFpbmVyUmVmLCBfZGF0ZUFkYXB0ZXIsIF9kaXIsIF9kb2N1bWVudCkge1xuICAgICAgICB0aGlzLl9kaWFsb2cgPSBfZGlhbG9nO1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gX292ZXJsYXk7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgdGhpcy5fZGF0ZUFkYXB0ZXIgPSBfZGF0ZUFkYXB0ZXI7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gX2RvY3VtZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZpZXcgdGhhdCB0aGUgY2FsZW5kYXIgc2hvdWxkIHN0YXJ0IGluLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydFZpZXcgPSAnbW9udGgnO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2FsZW5kYXIgVUkgaXMgaW4gdG91Y2ggbW9kZS4gSW4gdG91Y2ggbW9kZSB0aGUgY2FsZW5kYXIgb3BlbnMgaW4gYSBkaWFsb2cgcmF0aGVyXG4gICAgICAgICAqIHRoYW4gYSBwb3B1cCBhbmQgZWxlbWVudHMgaGF2ZSBtb3JlIHBhZGRpbmcgdG8gYWxsb3cgZm9yIGJpZ2dlciB0b3VjaCB0YXJnZXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b3VjaFVpID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBuZXcgc2VsZWN0ZWQgZGF0ZSB3aGVuIHNlbGVjdGVkIGRhdGUgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2FsZW5kYXIgaXMgb3Blbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWQgZm9yIHRoZSBkYXRlcGlja2VyIGNhbGVuZGFyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IFwibWQtZGF0ZXBpY2tlci1cIiArIGRhdGVwaWNrZXJVaWQrKztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSBkYXRlcGlja2VyIHdhcyBvcGVuZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4gPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGVBZGFwdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nRGF0ZUltcGxFcnJvcignRGF0ZUFkYXB0ZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREYXRlcGlja2VyLnByb3RvdHlwZSwgXCJzdGFydEF0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlIHRvIG9wZW4gdGhlIGNhbGVuZGFyIHRvIGluaXRpYWxseS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSWYgYW4gZXhwbGljaXQgc3RhcnRBdCBpcyBzZXQgd2Ugc3RhcnQgdGhlcmUsIG90aGVyd2lzZSB3ZSBzdGFydCBhdCB3aGF0ZXZlciB0aGUgY3VycmVudGx5XG4gICAgICAgICAgICAvLyBzZWxlY3RlZCB2YWx1ZSBpcy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydEF0IHx8ICh0aGlzLl9kYXRlcGlja2VySW5wdXQgPyB0aGlzLl9kYXRlcGlja2VySW5wdXQudmFsdWUgOiBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSkgeyB0aGlzLl9zdGFydEF0ID0gZGF0ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGF0ZXBpY2tlci5wcm90b3R5cGUsIFwiX21pbkRhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gc2VsZWN0YWJsZSBkYXRlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZXBpY2tlcklucHV0ICYmIHRoaXMuX2RhdGVwaWNrZXJJbnB1dC5taW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERhdGVwaWNrZXIucHJvdG90eXBlLCBcIl9tYXhEYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHNlbGVjdGFibGUgZGF0ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVwaWNrZXJJbnB1dCAmJiB0aGlzLl9kYXRlcGlja2VySW5wdXQubWF4O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREYXRlcGlja2VyLnByb3RvdHlwZSwgXCJfZGF0ZUZpbHRlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZXBpY2tlcklucHV0ICYmIHRoaXMuX2RhdGVwaWNrZXJJbnB1dC5fZGF0ZUZpbHRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLl9wb3B1cFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWYuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5faW5wdXRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gZGF0ZSBhbmQgY2xvc2VzIHRoZSBjdXJyZW50bHkgb3BlbiBwb3B1cCBvciBkaWFsb2cuXG4gICAgICogQHBhcmFtIHs/fSBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXIucHJvdG90eXBlLl9zZWxlY3RBbmRDbG9zZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFZhbHVlID0gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gZGF0ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlci5zYW1lRGF0ZShvbGRWYWx1ZSwgdGhpcy5fc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlZC5lbWl0KGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGlucHV0IHdpdGggdGhpcyBkYXRlcGlja2VyLlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXQgVGhlIGRhdGVwaWNrZXIgaW5wdXQgdG8gcmVnaXN0ZXIgd2l0aCB0aGlzIGRhdGVwaWNrZXIuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXIucHJvdG90eXBlLl9yZWdpc3RlcklucHV0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9kYXRlcGlja2VySW5wdXQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdBbiBNZERhdGVwaWNrZXIgY2FuIG9ubHkgYmUgYXNzb2NpYXRlZCB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXJJbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9pbnB1dFN1YnNjcmlwdGlvbiA9XG4gICAgICAgICAgICB0aGlzLl9kYXRlcGlja2VySW5wdXQuX3ZhbHVlQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLl9zZWxlY3RlZCA9IHZhbHVlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGNhbGVuZGFyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2RhdGVwaWNrZXJJbnB1dCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0F0dGVtcHRlZCB0byBvcGVuIGFuIE1kRGF0ZXBpY2tlciB3aXRoIG5vIGFzc29jaWF0ZWQgaW5wdXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4gPSB0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hVaSA/IHRoaXMuX29wZW5Bc0RpYWxvZygpIDogdGhpcy5fb3BlbkFzUG9wdXAoKTtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGNhbGVuZGFyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wZW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wb3B1cFJlZiAmJiB0aGlzLl9wb3B1cFJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGlhbG9nUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWFsb2dSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2RpYWxvZ1JlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NhbGVuZGFyUG9ydGFsICYmIHRoaXMuX2NhbGVuZGFyUG9ydGFsLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFyUG9ydGFsLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4gJiYgJ2ZvY3VzJyBpbiB0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzZWRFbGVtZW50QmVmb3JlT3Blbi5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgY2FsZW5kYXIgYXMgYSBkaWFsb2cuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXIucHJvdG90eXBlLl9vcGVuQXNEaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2RpYWxvZ1JlZiA9IHRoaXMuX2RpYWxvZy5vcGVuKE1kRGF0ZXBpY2tlckNvbnRlbnQsIHtcbiAgICAgICAgICAgIHZpZXdDb250YWluZXJSZWY6IHRoaXMuX3ZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuX2RpciA/IHRoaXMuX2Rpci52YWx1ZSA6ICdsdHInXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kaWFsb2dSZWYuYWZ0ZXJDbG9zZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvc2UoKTsgfSk7XG4gICAgICAgIHRoaXMuX2RpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5kYXRlcGlja2VyID0gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGNhbGVuZGFyIGFzIGEgcG9wdXAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXIucHJvdG90eXBlLl9vcGVuQXNQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxlbmRhclBvcnRhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsZW5kYXJQb3J0YWwgPSBuZXcgQ29tcG9uZW50UG9ydGFsKE1kRGF0ZXBpY2tlckNvbnRlbnQsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wb3B1cFJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRSZWYgPSB0aGlzLl9wb3B1cFJlZi5hdHRhY2godGhpcy5fY2FsZW5kYXJQb3J0YWwpO1xuICAgICAgICAgICAgY29tcG9uZW50UmVmLmluc3RhbmNlLmRhdGVwaWNrZXIgPSB0aGlzO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwb3NpdGlvbiBvbmNlIHRoZSBjYWxlbmRhciBoYXMgcmVuZGVyZWQuXG4gICAgICAgICAgICBmaXJzdC5jYWxsKHRoaXMuX25nWm9uZS5vblN0YWJsZSkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wb3B1cFJlZi51cGRhdGVQb3NpdGlvbigpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb3B1cFJlZi5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsb3NlKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBwb3B1cC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlci5wcm90b3R5cGUuX2NyZWF0ZVBvcHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdmVybGF5U3RhdGUgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fY3JlYXRlUG9wdXBQb3NpdGlvblN0cmF0ZWd5KCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5oYXNCYWNrZHJvcCA9IHRydWU7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5iYWNrZHJvcENsYXNzID0gJ21kLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnO1xuICAgICAgICBvdmVybGF5U3RhdGUuZGlyZWN0aW9uID0gdGhpcy5fZGlyID8gdGhpcy5fZGlyLnZhbHVlIDogJ2x0cic7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5zY3JvbGxTdHJhdGVneSA9IHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuX3BvcHVwUmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheVN0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgcG9wdXAgUG9zaXRpb25TdHJhdGVneS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlci5wcm90b3R5cGUuX2NyZWF0ZVBvcHVwUG9zaXRpb25TdHJhdGVneSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxuICAgICAgICAgICAgLmNvbm5lY3RlZFRvKHRoaXMuX2RhdGVwaWNrZXJJbnB1dC5nZXRQb3B1cENvbm5lY3Rpb25FbGVtZW50UmVmKCksIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ2JvdHRvbScgfSwgeyBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnIH0pXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oeyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAndG9wJyB9LCB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2JvdHRvbScgfSlcbiAgICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbih7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAnYm90dG9tJyB9LCB7IG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICd0b3AnIH0pXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oeyBvcmlnaW5YOiAnZW5kJywgb3JpZ2luWTogJ3RvcCcgfSwgeyBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnYm90dG9tJyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNZERhdGVwaWNrZXI7XG59KCkpO1xuTWREYXRlcGlja2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbWQtZGF0ZXBpY2tlciwgbWF0LWRhdGVwaWNrZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnJyxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWREYXRlcGlja2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTWREaWFsb2csIH0sXG4gICAgeyB0eXBlOiBPdmVybGF5LCB9LFxuICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICB7IHR5cGU6IERhdGVBZGFwdGVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IERpcmVjdGlvbmFsaXR5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtET0NVTUVOVCxdIH0sXSB9LFxuXTsgfTtcbk1kRGF0ZXBpY2tlci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnc3RhcnRBdCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc3RhcnRWaWV3JzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICd0b3VjaFVpJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdzZWxlY3RlZENoYW5nZWQnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxufTtcbnZhciBNRF9EQVRFUElDS0VSX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kRGF0ZXBpY2tlcklucHV0OyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBNRF9EQVRFUElDS0VSX1ZBTElEQVRPUlMgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZERhdGVwaWNrZXJJbnB1dDsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIERpcmVjdGl2ZSB1c2VkIHRvIGNvbm5lY3QgYW4gaW5wdXQgdG8gYSBNZERhdGVwaWNrZXIuXG4gKi9cbnZhciBNZERhdGVwaWNrZXJJbnB1dCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gX2RhdGVBZGFwdGVyXG4gICAgICogQHBhcmFtIHs/fSBfZGF0ZUZvcm1hdHNcbiAgICAgKiBAcGFyYW0gez99IF9tZElucHV0Q29udGFpbmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWREYXRlcGlja2VySW5wdXQoX2VsZW1lbnRSZWYsIF9yZW5kZXJlciwgX2RhdGVBZGFwdGVyLCBfZGF0ZUZvcm1hdHMsIF9tZElucHV0Q29udGFpbmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2RhdGVBZGFwdGVyID0gX2RhdGVBZGFwdGVyO1xuICAgICAgICB0aGlzLl9kYXRlRm9ybWF0cyA9IF9kYXRlRm9ybWF0cztcbiAgICAgICAgdGhpcy5fbWRJbnB1dENvbnRhaW5lciA9IF9tZElucHV0Q29udGFpbmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyAoZWl0aGVyIGR1ZSB0byB1c2VyIGlucHV0IG9yIHByb2dyYW1tYXRpYyBjaGFuZ2UpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy5fY3ZhT25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBtaW4gZGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21pblZhbGlkYXRvciA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFfdGhpcy5taW4gfHwgIWNvbnRyb2wudmFsdWUgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGF0ZUFkYXB0ZXIuY29tcGFyZURhdGUoX3RoaXMubWluLCBjb250cm9sLnZhbHVlKSA8PSAwKSA/XG4gICAgICAgICAgICAgICAgbnVsbCA6IHsgJ21kRGF0ZXBpY2tlck1pbic6IHsgJ21pbic6IF90aGlzLm1pbiwgJ2FjdHVhbCc6IGNvbnRyb2wudmFsdWUgfSB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBtYXggZGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21heFZhbGlkYXRvciA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFfdGhpcy5tYXggfHwgIWNvbnRyb2wudmFsdWUgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGF0ZUFkYXB0ZXIuY29tcGFyZURhdGUoX3RoaXMubWF4LCBjb250cm9sLnZhbHVlKSA+PSAwKSA/XG4gICAgICAgICAgICAgICAgbnVsbCA6IHsgJ21kRGF0ZXBpY2tlck1heCc6IHsgJ21heCc6IF90aGlzLm1heCwgJ2FjdHVhbCc6IGNvbnRyb2wudmFsdWUgfSB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBkYXRlIGZpbHRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZpbHRlclZhbGlkYXRvciA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gIV90aGlzLl9kYXRlRmlsdGVyIHx8ICFjb250cm9sLnZhbHVlIHx8IF90aGlzLl9kYXRlRmlsdGVyKGNvbnRyb2wudmFsdWUpID9cbiAgICAgICAgICAgICAgICBudWxsIDogeyAnbWREYXRlcGlja2VyRmlsdGVyJzogdHJ1ZSB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbWJpbmVkIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoaXMgaW5wdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW3RoaXMuX21pblZhbGlkYXRvciwgdGhpcy5fbWF4VmFsaWRhdG9yLCB0aGlzLl9maWx0ZXJWYWxpZGF0b3JdKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlQWRhcHRlcikge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ0RhdGVBZGFwdGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kYXRlRm9ybWF0cykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ0RhdGVJbXBsRXJyb3IoJ01EX0RBVEVfRk9STUFUUycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUsIFwibWREYXRlcGlja2VyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlcGlja2VyIHRoYXQgdGhpcyBpbnB1dCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRlcGlja2VyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5fcmVnaXN0ZXJJbnB1dCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGF0ZXBpY2tlcklucHV0LnByb3RvdHlwZSwgXCJtYXREYXRlcGlja2VyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMubWREYXRlcGlja2VyID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUsIFwibWREYXRlcGlja2VyRmlsdGVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZmlsdGVyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmaWx0ZXIkJDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGVGaWx0ZXIgPSBmaWx0ZXIkJDE7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLCBcIm1hdERhdGVwaWNrZXJGaWx0ZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmaWx0ZXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGZpbHRlciQkMSkge1xuICAgICAgICAgICAgdGhpcy5tZERhdGVwaWNrZXJGaWx0ZXIgPSBmaWx0ZXIkJDE7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVBZGFwdGVyLnBhcnNlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSwgdGhpcy5fZGF0ZUZvcm1hdHMucGFyc2UuZGF0ZUlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkYXRlID0gdGhpcy5fZGF0ZUFkYXB0ZXIucGFyc2UodmFsdWUsIHRoaXMuX2RhdGVGb3JtYXRzLnBhcnNlLmRhdGVJbnB1dCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGREYXRlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgZGF0ZSA/IHRoaXMuX2RhdGVBZGFwdGVyLmZvcm1hdChkYXRlLCB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5LmRhdGVJbnB1dCkgOiAnJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RhdGVBZGFwdGVyLnNhbWVEYXRlKG9sZERhdGUsIGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2UuZW1pdChkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGF0ZXBpY2tlcklucHV0LnByb3RvdHlwZSwgXCJtaW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gdmFsaWQgZGF0ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWluOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21pbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGF0ZXBpY2tlcklucHV0LnByb3RvdHlwZSwgXCJtYXhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gdmFsaWQgZGF0ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWF4OyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21heCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fZGF0ZXBpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5fZGF0ZXBpY2tlclN1YnNjcmlwdGlvbiA9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZWxlY3RlZENoYW5nZWQuc3Vic2NyaWJlKGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY3ZhT25DaGFuZ2Uoc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlcklucHV0LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGVwaWNrZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvciA/IHRoaXMuX3ZhbGlkYXRvcihjKSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGVtZW50IHRoYXQgdGhlIGRhdGVwaWNrZXIgcG9wdXAgc2hvdWxkIGJlIGNvbm5lY3RlZCB0by5cbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgZWxlbWVudCB0byBjb25uZWN0IHRoZSBwb3B1cCB0by5cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUuZ2V0UG9wdXBDb25uZWN0aW9uRWxlbWVudFJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21kSW5wdXRDb250YWluZXIgPyB0aGlzLl9tZElucHV0Q29udGFpbmVyLnVuZGVybGluZVJlZiA6IHRoaXMuX2VsZW1lbnRSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9jdmFPbkNoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXNhYmxlZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBkaXNhYmxlZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZERhdGVwaWNrZXJJbnB1dC5wcm90b3R5cGUuX29uS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09IERPV05fQVJST1cpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXIub3BlbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWREYXRlcGlja2VySW5wdXQucHJvdG90eXBlLl9vbklucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGUgPSB0aGlzLl9kYXRlQWRhcHRlci5wYXJzZSh2YWx1ZSwgdGhpcy5fZGF0ZUZvcm1hdHMucGFyc2UuZGF0ZUlucHV0KTtcbiAgICAgICAgdGhpcy5fY3ZhT25DaGFuZ2UoZGF0ZSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlLmVtaXQoZGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWREYXRlcGlja2VySW5wdXQ7XG59KCkpO1xuTWREYXRlcGlja2VySW5wdXQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W21kRGF0ZXBpY2tlcl0sIGlucHV0W21hdERhdGVwaWNrZXJdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9EQVRFUElDS0VSX1ZBTFVFX0FDQ0VTU09SLCBNRF9EQVRFUElDS0VSX1ZBTElEQVRPUlNdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZXhwYW5kZWRdJzogJ19kYXRlcGlja2VyPy5vcGVuZWQgfHwgXCJmYWxzZVwiJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtaGFzcG9wdXBdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1vd25zXSc6ICdfZGF0ZXBpY2tlcj8uaWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIubWluXSc6ICdtaW4gPyBfZGF0ZUFkYXB0ZXIuZ2V0SVNPRGF0ZVN0cmluZyhtaW4pIDogbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5tYXhdJzogJ21heCA/IF9kYXRlQWRhcHRlci5nZXRJU09EYXRlU3RyaW5nKG1heCkgOiBudWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnX29uSW5wdXQoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ19vblRvdWNoZWQoKScsXG4gICAgICAgICAgICAgICAgICAgICcoa2V5ZG93biknOiAnX29uS2V5ZG93bigkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kRGF0ZXBpY2tlcklucHV0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IERhdGVBZGFwdGVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNRF9EQVRFX0ZPUk1BVFMsXSB9LF0gfSxcbiAgICB7IHR5cGU6IE1kSW5wdXRDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuXTsgfTtcbk1kRGF0ZXBpY2tlcklucHV0LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdtZERhdGVwaWNrZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ21hdERhdGVwaWNrZXInOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ21kRGF0ZXBpY2tlckZpbHRlcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbWF0RGF0ZXBpY2tlckZpbHRlcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ21pbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbWF4JzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbnZhciBNZERhdGVwaWNrZXJUb2dnbGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9pbnRsXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWREYXRlcGlja2VyVG9nZ2xlKF9pbnRsKSB7XG4gICAgICAgIHRoaXMuX2ludGwgPSBfaW50bDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGF0ZXBpY2tlclRvZ2dsZS5wcm90b3R5cGUsIFwiX2RhdGVwaWNrZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRlcGlja2VyOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuZGF0ZXBpY2tlciA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRGF0ZXBpY2tlclRvZ2dsZS5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZXBpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5kYXRlcGlja2VyLm9wZW4oKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWREYXRlcGlja2VyVG9nZ2xlO1xufSgpKTtcbk1kRGF0ZXBpY2tlclRvZ2dsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbeyBzZWxlY3RvcjogJ2J1dHRvblttZERhdGVwaWNrZXJUb2dnbGVdLCBidXR0b25bbWF0RGF0ZXBpY2tlclRvZ2dsZV0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnJyxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtZGF0ZXBpY2tlci10b2dnbGV7ZGlzcGxheTppbmxpbmUtYmxvY2s7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkhCNElpQm9aV2xuYUhROUlqSTBjSGdpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ1ptbHNiRDBpWTNWeWNtVnVkRU52Ykc5eUlqNDhjR0YwYUNCa1BTSk5NQ0F3YURJMGRqSTBTREI2SWlCbWFXeHNQU0p1YjI1bElpOCtQSEJoZEdnZ1pEMGlUVEU1SUROb0xURldNV2d0TW5ZeVNEaFdNVWcyZGpKSU5XTXRNUzR4TVNBd0xURXVPVGt1T1MweExqazVJREpNTXlBeE9XTXdJREV1TVM0NE9TQXlJRElnTW1neE5HTXhMakVnTUNBeUxTNDVJREl0TWxZMVl6QXRNUzR4TFM0NUxUSXRNaTB5ZW0wd0lERTJTRFZXT0dneE5IWXhNWHBOTnlBeE1HZzFkalZJTjNvaUx6NDhMM04yWno0PSkgbm8tcmVwZWF0O2JhY2tncm91bmQtc2l6ZTpjb250YWluO2hlaWdodDoyNHB4O3dpZHRoOjI0cHg7Ym9yZGVyOm5vbmU7b3V0bGluZTowO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWF0LWRhdGVwaWNrZXItdG9nZ2xlOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1cIl0sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LWRhdGVwaWNrZXItdG9nZ2xlJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtbGFiZWxdJzogJ19pbnRsLm9wZW5DYWxlbmRhckxhYmVsJyxcbiAgICAgICAgICAgICAgICAgICAgJyhjbGljayknOiAnX29wZW4oJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZERhdGVwaWNrZXJUb2dnbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBNZERhdGVwaWNrZXJJbnRsLCB9LFxuXTsgfTtcbk1kRGF0ZXBpY2tlclRvZ2dsZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnZGF0ZXBpY2tlcic6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kRGF0ZXBpY2tlclRvZ2dsZScsXSB9LF0sXG4gICAgJ19kYXRlcGlja2VyJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0RGF0ZXBpY2tlclRvZ2dsZScsXSB9LF0sXG59O1xudmFyIE1kRGF0ZXBpY2tlck1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGF0ZXBpY2tlck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kRGF0ZXBpY2tlck1vZHVsZTtcbn0oKSk7XG5NZERhdGVwaWNrZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZEJ1dHRvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWREaWFsb2dNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFN0eWxlTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBBMTF5TW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBNZERhdGVwaWNrZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kRGF0ZXBpY2tlckNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIE1kRGF0ZXBpY2tlcklucHV0LFxuICAgICAgICAgICAgICAgICAgICBNZERhdGVwaWNrZXJUb2dnbGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWRDYWxlbmRhcixcbiAgICAgICAgICAgICAgICAgICAgTWRDYWxlbmRhckJvZHksXG4gICAgICAgICAgICAgICAgICAgIE1kRGF0ZXBpY2tlcixcbiAgICAgICAgICAgICAgICAgICAgTWREYXRlcGlja2VyQ29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgTWREYXRlcGlja2VySW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIE1kRGF0ZXBpY2tlclRvZ2dsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRNb250aFZpZXcsXG4gICAgICAgICAgICAgICAgICAgIE1kWWVhclZpZXcsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTWREYXRlcGlja2VySW50bCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICBNZERhdGVwaWNrZXJDb250ZW50LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWREYXRlcGlja2VyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFVuaXF1ZSBJRCBjb3VudGVyXG4gKi9cbnZhciBuZXh0SWQkMyA9IDA7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIG1hbmFnZSB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgQ2RrQWNjb3JkaW9uSXRlbSBjaGlsZHJlbi5cbiAqL1xudmFyIENka0FjY29yZGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENka0FjY29yZGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVhZG9ubHkgaWQgdmFsdWUgdG8gdXNlIGZvciB1bmlxdWUgc2VsZWN0aW9uIGNvb3JkaW5hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBcImNkay1hY2NvcmRpb24tXCIgKyBuZXh0SWQkMysrO1xuICAgICAgICB0aGlzLl9tdWx0aSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oaWRlVG9nZ2xlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzcGxheSBtb2RlIHVzZWQgZm9yIGFsbCBleHBhbnNpb24gcGFuZWxzIGluIHRoZSBhY2NvcmRpb24uIEN1cnJlbnRseSB0d28gZGlzcGxheVxuICAgICAgICAgKiBtb2RlcyBleGlzdDpcbiAgICAgICAgICogICBkZWZhdWx0IC0gYSBndXR0ZXItbGlrZSBzcGFjaW5nIGlzIHBsYWNlZCBhcm91bmQgYW55IGV4cGFuZGVkIHBhbmVsLCBwbGFjaW5nIHRoZSBleHBhbmRlZFxuICAgICAgICAgKiAgICAgcGFuZWwgYXQgYSBkaWZmZXJlbnQgZWxldmF0aW9uIGZyb20gdGhlIHJlc2V0IG9mIHRoZSBhY2NvcmRpb24uXG4gICAgICAgICAqICBmbGF0IC0gbm8gc3BhY2luZyBpcyBwbGFjZWQgYXJvdW5kIGV4cGFuZGVkIHBhbmVscywgc2hvd2luZyBhbGwgcGFuZWxzIGF0IHRoZSBzYW1lXG4gICAgICAgICAqICAgICBlbGV2YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc3BsYXlNb2RlID0gJ2RlZmF1bHQnO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2RrQWNjb3JkaW9uLnByb3RvdHlwZSwgXCJtdWx0aVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBhY2NvcmRpb24gc2hvdWxkIGFsbG93IG11bHRpcGxlIGV4cGFuZGVkIGFjY29yZGlvbiBpdGVtcyBzaW11bGF0ZW91c2x5LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tdWx0aTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbXVsdGlcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG11bHRpKSB7IHRoaXMuX211bHRpID0gY29lcmNlQm9vbGVhblByb3BlcnR5KG11bHRpKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENka0FjY29yZGlvbi5wcm90b3R5cGUsIFwiaGlkZVRvZ2dsZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBleHBhbnNpb24gaW5kaWNhdG9yIHNob3VsZCBiZSBoaWRkZW4uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hpZGVUb2dnbGU7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNob3dcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNob3cpIHsgdGhpcy5faGlkZVRvZ2dsZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eShzaG93KTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENka0FjY29yZGlvbjtcbn0oKSk7XG5DZGtBY2NvcmRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGstYWNjb3JkaW9uXScsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNka0FjY29yZGlvbi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuQ2RrQWNjb3JkaW9uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdtdWx0aSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnaGlkZVRvZ2dsZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnZGlzcGxheU1vZGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgZm9yIGEgTWF0ZXJpYWwgRGVzaWduIEFjY29yZGlvbi5cbiAqL1xudmFyIE1kQWNjb3JkaW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRBY2NvcmRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRBY2NvcmRpb24oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1kQWNjb3JkaW9uO1xufShDZGtBY2NvcmRpb24pKTtcbk1kQWNjb3JkaW9uLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYXQtYWNjb3JkaW9uLCBtZC1hY2NvcmRpb24nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdtYXQtYWNjb3JkaW9uJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRBY2NvcmRpb24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSUQgZm9yIGVhY2ggZXhwYW5zaW9uIHBhbmVsLlxuICovXG52YXIgbmV4dElkJDQgPSAwO1xuLyoqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0byBiZSBleHRlbmRlZCBhbmQgZGVjb3JhdGVkIGFzIGEgY29tcG9uZW50LiAgU2V0cyB1cCBhbGxcbiAqIGV2ZW50cyBhbmQgYXR0cmlidXRlcyBuZWVkZWQgdG8gYmUgbWFuYWdlZCBieSBhIENka0FjY29yZGlvbiBwYXJlbnQuXG4gKi9cbnZhciBBY2NvcmRpb25JdGVtID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhY2NvcmRpb25cbiAgICAgKiBAcGFyYW0gez99IF9leHBhbnNpb25EaXNwYXRjaGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWNjb3JkaW9uSXRlbShhY2NvcmRpb24sIF9leHBhbnNpb25EaXNwYXRjaGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWNjb3JkaW9uID0gYWNjb3JkaW9uO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25EaXNwYXRjaGVyID0gX2V4cGFuc2lvbkRpc3BhdGNoZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIGV2ZXJ5IHRpbWUgdGhlIE1kQWNjb3JkaWFuQ2hpbGQgaXMgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIGV2ZXJ5IHRpbWUgdGhlIE1kQWNjb3JkaWFuQ2hpbGQgaXMgb3BlbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIE1kQWNjb3JkaWFuQ2hpbGQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIE1kQWNjb3JkaWFuQ2hpbGQgaWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gXCJjZGstYWNjb3JkaW9uLWNoaWxkLVwiICsgbmV4dElkJDQrKztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgZnVuY3Rpb24gZm9yIF9leHBhbnNpb25EaXNwYXRjaGVyICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlbW92ZVVuaXF1ZVNlbGVjdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB0aGlzLl9yZW1vdmVVbmlxdWVTZWxlY3Rpb25MaXN0ZW5lciA9XG4gICAgICAgICAgICBfZXhwYW5zaW9uRGlzcGF0Y2hlci5saXN0ZW4oZnVuY3Rpb24gKGlkLCBhY2NvcmRpb25JZCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hY2NvcmRpb24gJiYgIV90aGlzLmFjY29yZGlvbi5tdWx0aSAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2NvcmRpb24uaWQgPT09IGFjY29yZGlvbklkICYmIF90aGlzLmlkICE9PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWNjb3JkaW9uSXRlbS5wcm90b3R5cGUsIFwiZXhwYW5kZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgTWRBY2NvcmRpYW5DaGlsZCBpcyBleHBhbmRlZC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZXhwYW5kZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGV4cGFuZGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChleHBhbmRlZCkge1xuICAgICAgICAgICAgLy8gT25seSBlbWl0IGV2ZW50cyBhbmQgdXBkYXRlIHRoZSBpbnRlcm5hbCB2YWx1ZSBpZiB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9leHBhbmRlZCAhPT0gZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRlZCA9IGV4cGFuZGVkO1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5lZC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJbiB0aGUgdW5pcXVlIHNlbGVjdGlvbiBkaXNwYXRjaGVyLCB0aGUgaWQgcGFyYW1ldGVyIGlzIHRoZSBpZCBvZiB0aGUgQ2RrQWNjb3Jkb25JdGVtLFxuICAgICAgICAgICAgICAgICAgICAgKiB0aGUgbmFtZSB2YWx1ZSBpcyB0aGUgaWQgb2YgdGhlIGFjY29yZGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2NvcmRpb25JZCA9IHRoaXMuYWNjb3JkaW9uID8gdGhpcy5hY2NvcmRpb24uaWQgOiB0aGlzLmlkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBhbnNpb25EaXNwYXRjaGVyLm5vdGlmeSh0aGlzLmlkLCBhY2NvcmRpb25JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlZC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBmb3IgdGhlIGFjY29yZGlvbiBpdGVtIGJlaW5nIGRlc3Ryb3llZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFjY29yZGlvbkl0ZW0ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZC5lbWl0KCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVVuaXF1ZVNlbGVjdGlvbkxpc3RlbmVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgYWNjb3JkaW9uIGl0ZW0uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBY2NvcmRpb25JdGVtLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGV4cGFuZGVkIHN0YXRlIG9mIHRoZSBhY2NvcmRpb24gaXRlbSB0byBmYWxzZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFjY29yZGlvbkl0ZW0ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgYWNjb3JkaW9uIGl0ZW0gdG8gdHJ1ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFjY29yZGlvbkl0ZW0ucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY29yZGlvbkl0ZW07XG59KCkpO1xuQWNjb3JkaW9uSXRlbS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQWNjb3JkaW9uSXRlbS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IENka0FjY29yZGlvbiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLCB9LFxuXTsgfTtcbkFjY29yZGlvbkl0ZW0ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2Nsb3NlZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ29wZW5lZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2Rlc3Ryb3llZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ2V4cGFuZGVkJzogW3sgdHlwZTogSW5wdXQgfSxdLFxufTtcbi8qKlxuICogVGltZSBhbmQgdGltaW5nIGN1cnZlIGZvciBleHBhbnNpb24gcGFuZWwgYW5pbWF0aW9ucy5cbiAqL1xudmFyIEVYUEFOU0lPTl9QQU5FTF9BTklNQVRJT05fVElNSU5HID0gJzIyNW1zIGN1YmljLWJlemllcigwLjQsMC4wLDAuMiwxKSc7XG4vKipcbiAqIDxtZC1leHBhbnNpb24tcGFuZWw+IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBjYW4gYmUgdXNlZCBhcyBhIHNpbmdsZSBlbGVtZW50IHRvIHNob3cgZXhwYW5kYWJsZSBjb250ZW50LCBvciBhcyBvbmUgb2ZcbiAqIG11bHRpcGxlIGNoaWxkcmVuIG9mIGFuIGVsZW1lbnQgd2l0aCB0aGUgQ2RrQWNjb3JkaW9uIGRpcmVjdGl2ZSBhdHRhY2hlZC5cbiAqXG4gKiBQbGVhc2UgcmVmZXIgdG8gUkVBRE1FLm1kIGZvciBleGFtcGxlcyBvbiBob3cgdG8gdXNlIGl0LlxuICovXG52YXIgTWRFeHBhbnNpb25QYW5lbCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kRXhwYW5zaW9uUGFuZWwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhY2NvcmRpb25cbiAgICAgKiBAcGFyYW0gez99IF91bmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRFeHBhbnNpb25QYW5lbChhY2NvcmRpb24sIF91bmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGFjY29yZGlvbiwgX3VuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB0b2dnbGUgaW5kaWNhdG9yIHNob3VsZCBiZSBoaWRkZW4uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5oaWRlVG9nZ2xlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmFjY29yZGlvbiA9IGFjY29yZGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBleHBhbnNpb24gaW5kaWNhdG9yIHNob3VsZCBiZSBoaWRkZW4uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEV4cGFuc2lvblBhbmVsLnByb3RvdHlwZS5fZ2V0SGlkZVRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWNjb3JkaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2NvcmRpb24uaGlkZVRvZ2dsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oaWRlVG9nZ2xlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFuZWwncyBkaXNwbGF5IG1vZGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEV4cGFuc2lvblBhbmVsLnByb3RvdHlwZS5fZ2V0RGlzcGxheU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEV4cGFuZGVkU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY2NvcmRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY29yZGlvbi5kaXNwbGF5TW9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RXhwYW5kZWRTdGF0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZXhwYW5kZWQgc3RhdGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRFeHBhbnNpb25QYW5lbC5wcm90b3R5cGUuX2dldEV4cGFuZGVkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZGVkID8gJ2V4cGFuZGVkJyA6ICdjb2xsYXBzZWQnO1xuICAgIH07XG4gICAgcmV0dXJuIE1kRXhwYW5zaW9uUGFuZWw7XG59KEFjY29yZGlvbkl0ZW0pKTtcbk1kRXhwYW5zaW9uUGFuZWwuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc3R5bGVzOiBbXCIubWF0LWV4cGFuc2lvbi1wYW5lbHt0cmFuc2l0aW9uOmJveC1zaGFkb3cgMjgwbXMgY3ViaWMtYmV6aWVyKC40LDAsLjIsMSk7Ym94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrfS5tYXQtZXhwYW5zaW9uLXBhbmVsOm5vdChbY2xhc3MqPW1hdC1lbGV2YXRpb24tel0pe2JveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLDAsMCwuMiksMCAycHggMnB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDVweCAwIHJnYmEoMCwwLDAsLjEyKX0ubWF0LWV4cGFuc2lvbi1wYW5lbC1jb250ZW50e292ZXJmbG93OmhpZGRlbn0ubWF0LWV4cGFuc2lvbi1wYW5lbC1ib2R5e3BhZGRpbmc6MCAyNHB4IDE2cHh9Lm1hdC1hY3Rpb24tcm93e2JvcmRlci10b3Atc3R5bGU6c29saWQ7Ym9yZGVyLXRvcC13aWR0aDoxcHg7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdztqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7cGFkZGluZzoxNnB4IDhweCAxNnB4IDI0cHh9Lm1hdC1hY3Rpb24tcm93IGJ1dHRvbi5tYXQtYnV0dG9ue21hcmdpbi1sZWZ0OjhweH1cIl0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1leHBhbnNpb24tcGFuZWwsIG1hdC1leHBhbnNpb24tcGFuZWwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50IHNlbGVjdD1cXFwibWF0LWV4cGFuc2lvbi1wYW5lbC1oZWFkZXIsIG1kLWV4cGFuc2lvbi1wYW5lbC1oZWFkZXJcXFwiPjwvbmctY29udGVudD48ZGl2IFtjbGFzcy5tYXQtZXhwYW5kZWRdPVxcXCJleHBhbmRlZFxcXCIgY2xhc3M9XFxcIm1hdC1leHBhbnNpb24tcGFuZWwtY29udGVudFxcXCIgW0Bib2R5RXhwYW5zaW9uXT1cXFwiX2dldEV4cGFuZGVkU3RhdGUoKVxcXCIgW2lkXT1cXFwiaWRcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1leHBhbnNpb24tcGFuZWwtYm9keVxcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGl2PjxuZy1jb250ZW50IHNlbGVjdD1cXFwibWF0LWFjdGlvbi1yb3csIG1kLWFjdGlvbi1yb3dcXFwiPjwvbmctY29udGVudD48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1leHBhbnNpb24tcGFuZWwnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1leHBhbmRlZF0nOiAnZXhwYW5kZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW0BkaXNwbGF5TW9kZV0nOiAnX2dldERpc3BsYXlNb2RlKCknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogQWNjb3JkaW9uSXRlbSwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRFeHBhbnNpb25QYW5lbDsgfSkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdib2R5RXhwYW5zaW9uJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2NvbGxhcHNlZCcsIHN0eWxlKHsgaGVpZ2h0OiAnMHB4JyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgnZXhwYW5kZWQnLCBzdHlsZSh7IGhlaWdodDogJyonIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2V4cGFuZGVkIDw9PiBjb2xsYXBzZWQnLCBhbmltYXRlKEVYUEFOU0lPTl9QQU5FTF9BTklNQVRJT05fVElNSU5HKSksXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdkaXNwbGF5TW9kZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdjb2xsYXBzZWQnLCBzdHlsZSh7IG1hcmdpbjogJzAnIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdkZWZhdWx0Jywgc3R5bGUoeyBtYXJnaW46ICcxNnB4IDAnIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdmbGF0Jywgc3R5bGUoeyBtYXJnaW46ICcwJyB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCdmbGF0IDw9PiBjb2xsYXBzZWQsIGRlZmF1bHQgPD0+IGNvbGxhcHNlZCwgZmxhdCA8PT4gZGVmYXVsdCcsIGFuaW1hdGUoRVhQQU5TSU9OX1BBTkVMX0FOSU1BVElPTl9USU1JTkcpKSxcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRFeHBhbnNpb25QYW5lbC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IE1kQWNjb3JkaW9uLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEhvc3QgfSxdIH0sXG4gICAgeyB0eXBlOiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLCB9LFxuXTsgfTtcbk1kRXhwYW5zaW9uUGFuZWwucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2hpZGVUb2dnbGUnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xudmFyIE1kRXhwYW5zaW9uUGFuZWxBY3Rpb25Sb3cgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEV4cGFuc2lvblBhbmVsQWN0aW9uUm93KCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRFeHBhbnNpb25QYW5lbEFjdGlvblJvdztcbn0oKSk7XG5NZEV4cGFuc2lvblBhbmVsQWN0aW9uUm93LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYXQtYWN0aW9uLXJvdywgbWQtYWN0aW9uLXJvdycsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogJ21hdC1hY3Rpb24tcm93J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRFeHBhbnNpb25QYW5lbEFjdGlvblJvdy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiA8bWQtZXhwYW5zaW9uLXBhbmVsLWhlYWRlcj4gY29tcG9uZW50LlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBoZWFkZXIgZWxlbWVudCBvZiBhbiA8bWQtZXhwYW5zaW9uLXBhbmVsPi5cbiAqXG4gKiBQbGVhc2UgcmVmZXIgdG8gUkVBRE1FLm1kIGZvciBleGFtcGxlcyBvbiBob3cgdG8gdXNlIGl0LlxuICovXG52YXIgTWRFeHBhbnNpb25QYW5lbEhlYWRlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFuZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZEV4cGFuc2lvblBhbmVsSGVhZGVyKHBhbmVsKSB7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgdGhlIHBhbmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRFeHBhbnNpb25QYW5lbEhlYWRlci5wcm90b3R5cGUuX3RvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYW5lbC50b2dnbGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcGFuZWwgaXMgZXhwYW5kZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEV4cGFuc2lvblBhbmVsSGVhZGVyLnByb3RvdHlwZS5faXNFeHBhbmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFuZWwuZXhwYW5kZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBleHBhbmRlZCBzdGF0ZSBzdHJpbmcgb2YgdGhlIHBhbmVsLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRFeHBhbnNpb25QYW5lbEhlYWRlci5wcm90b3R5cGUuX2dldEV4cGFuZGVkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhbmVsLl9nZXRFeHBhbmRlZFN0YXRlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYW5lbCBpZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRXhwYW5zaW9uUGFuZWxIZWFkZXIucHJvdG90eXBlLl9nZXRQYW5lbElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYW5lbC5pZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgZXhwYW5kIGluZGljYXRvciBpcyBoaWRkZW4uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZEV4cGFuc2lvblBhbmVsSGVhZGVyLnByb3RvdHlwZS5fZ2V0SGlkZVRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFuZWwuaGlkZVRvZ2dsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBrZXl1cCBldmVudCBjYWxsaW5nIHRvIHRvZ2dsZSgpIGlmIGFwcHJvcHJpYXRlLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kRXhwYW5zaW9uUGFuZWxIZWFkZXIucHJvdG90eXBlLl9rZXl1cCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIC8vIFRvZ2dsZSBmb3Igc3BhY2UgYW5kIGVudGVyIGtleXMuXG4gICAgICAgICAgICBjYXNlIFNQQUNFOlxuICAgICAgICAgICAgY2FzZSBFTlRFUjpcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZEV4cGFuc2lvblBhbmVsSGVhZGVyO1xufSgpKTtcbk1kRXhwYW5zaW9uUGFuZWxIZWFkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1leHBhbnNpb24tcGFuZWwtaGVhZGVyLCBtYXQtZXhwYW5zaW9uLXBhbmVsLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWV4cGFuc2lvbi1wYW5lbC1oZWFkZXJ7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdztoZWlnaHQ6NDhweDtsaW5lLWhlaWdodDo0OHB4O3BhZGRpbmc6MCAyNHB4fS5tYXQtZXhwYW5zaW9uLXBhbmVsLWhlYWRlci5tYXQtZXhwYW5kZWR7aGVpZ2h0OjY0cHg7bGluZS1oZWlnaHQ6NjRweH0ubWF0LWV4cGFuc2lvbi1wYW5lbC1oZWFkZXI6Zm9jdXMsLm1hdC1leHBhbnNpb24tcGFuZWwtaGVhZGVyOmhvdmVye291dGxpbmU6MH0ubWF0LWV4cGFuc2lvbi1wYW5lbC1oZWFkZXIubWF0LWV4cGFuZGVkOmZvY3VzLC5tYXQtZXhwYW5zaW9uLXBhbmVsLWhlYWRlci5tYXQtZXhwYW5kZWQ6aG92ZXJ7YmFja2dyb3VuZDppbmhlcml0fS5tYXQtY29udGVudHtkaXNwbGF5OmZsZXg7ZmxleDoxO2ZsZXgtZGlyZWN0aW9uOnJvdztvdmVyZmxvdzpoaWRkZW59Lm1hdC1leHBhbnNpb24tcGFuZWwtaGVhZGVyLXRpdGxle2Rpc3BsYXk6ZmxleDtmbGV4LWdyb3c6MTtmb250LXNpemU6MTVweDttYXJnaW4tcmlnaHQ6MTZweH0ubWF0LWV4cGFuc2lvbi1wYW5lbC1oZWFkZXItZGVzY3JpcHRpb257ZGlzcGxheTpmbGV4O2ZsZXgtZ3JvdzoyO2ZvbnQtc2l6ZToxNXB4O21hcmdpbi1yaWdodDoxNnB4fS5tYXQtZXhwYW5zaW9uLWluZGljYXRvcjo6YWZ0ZXJ7Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci13aWR0aDowIDJweCAycHggMDtjb250ZW50OicnO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6M3B4O3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX1cIl0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHNwYW4gY2xhc3M9XFxcIm1hdC1jb250ZW50XFxcIj48bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLXBhbmVsLXRpdGxlLCBtYXQtcGFuZWwtdGl0bGVcXFwiPjwvbmctY29udGVudD48bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLXBhbmVsLWRlc2NyaXB0aW9uLCBtYXQtcGFuZWwtZGVzY3JpcHRpb25cXFwiPjwvbmctY29udGVudD48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPjxzcGFuIFtAaW5kaWNhdG9yUm90YXRlXT1cXFwiX2dldEV4cGFuZGVkU3RhdGUoKVxcXCIgKm5nSWY9XFxcIiFfZ2V0SGlkZVRvZ2dsZSgpXFxcIiBjbGFzcz1cXFwibWF0LWV4cGFuc2lvbi1pbmRpY2F0b3JcXFwiPjwvc3Bhbj5cIixcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1leHBhbnNpb24tcGFuZWwtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RhYmluZGV4JzogJzAnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1jb250cm9sc10nOiAnX2dldFBhbmVsSWQoKScsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdfaXNFeHBhbmRlZCgpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZXhwYW5kZWRdJzogJ19pc0V4cGFuZGVkKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdfdG9nZ2xlKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGtleXVwKSc6ICdfa2V5dXAoJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgICAgICdbQGV4cGFuc2lvbkhlaWdodF0nOiAnX2dldEV4cGFuZGVkU3RhdGUoKScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2luZGljYXRvclJvdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdjb2xsYXBzZWQnLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3JvdGF0ZSgwZGVnKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2V4cGFuZGVkJywgc3R5bGUoeyB0cmFuc2Zvcm06ICdyb3RhdGUoMTgwZGVnKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignZXhwYW5kZWQgPD0+IGNvbGxhcHNlZCcsIGFuaW1hdGUoRVhQQU5TSU9OX1BBTkVMX0FOSU1BVElPTl9USU1JTkcpKSxcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2V4cGFuc2lvbkhlaWdodCcsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdjb2xsYXBzZWQnLCBzdHlsZSh7IGhlaWdodDogJzQ4cHgnLCAnbGluZS1oZWlnaHQnOiAnNDhweCcgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2V4cGFuZGVkJywgc3R5bGUoeyBoZWlnaHQ6ICc2NHB4JywgJ2xpbmUtaGVpZ2h0JzogJzY4cHgnIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2V4cGFuZGVkIDw9PiBjb2xsYXBzZWQnLCBhbmltYXRlKEVYUEFOU0lPTl9QQU5FTF9BTklNQVRJT05fVElNSU5HKSksXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kRXhwYW5zaW9uUGFuZWxIZWFkZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBNZEV4cGFuc2lvblBhbmVsLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBIb3N0IH0sXSB9LFxuXTsgfTtcbi8qKlxuICogPG1kLXBhbmVsLWRlc2NyaXB0aW9uPiBkaXJlY3RpdmUuXG4gKlxuICogVGhpcyBkaXJlY3Rpb24gaXMgdG8gYmUgdXNlZCBpbnNpZGUgb2YgdGhlIE1kRXhwYW5zaW9uUGFuZWxIZWFkZXIgY29tcG9uZW50LlxuICovXG52YXIgTWRFeHBhbnNpb25QYW5lbERlc2NyaXB0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRFeHBhbnNpb25QYW5lbERlc2NyaXB0aW9uKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRFeHBhbnNpb25QYW5lbERlc2NyaXB0aW9uO1xufSgpKTtcbk1kRXhwYW5zaW9uUGFuZWxEZXNjcmlwdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtcGFuZWwtZGVzY3JpcHRpb24sIG1hdC1wYW5lbC1kZXNjcmlwdGlvbicsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogJ21hdC1leHBhbnNpb24tcGFuZWwtaGVhZGVyLWRlc2NyaXB0aW9uJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRFeHBhbnNpb25QYW5lbERlc2NyaXB0aW9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIDxtZC1wYW5lbC10aXRsZT4gZGlyZWN0aXZlLlxuICpcbiAqIFRoaXMgZGlyZWN0aW9uIGlzIHRvIGJlIHVzZWQgaW5zaWRlIG9mIHRoZSBNZEV4cGFuc2lvblBhbmVsSGVhZGVyIGNvbXBvbmVudC5cbiAqL1xudmFyIE1kRXhwYW5zaW9uUGFuZWxUaXRsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRXhwYW5zaW9uUGFuZWxUaXRsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kRXhwYW5zaW9uUGFuZWxUaXRsZTtcbn0oKSk7XG5NZEV4cGFuc2lvblBhbmVsVGl0bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLXBhbmVsLXRpdGxlLCBtYXQtcGFuZWwtdGl0bGUnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdtYXQtZXhwYW5zaW9uLXBhbmVsLWhlYWRlci10aXRsZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kRXhwYW5zaW9uUGFuZWxUaXRsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIE1kRXhwYW5zaW9uTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRFeHBhbnNpb25Nb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEV4cGFuc2lvbk1vZHVsZTtcbn0oKSk7XG5NZEV4cGFuc2lvbk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbXBhdGliaWxpdHlNb2R1bGUsIENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBDZGtBY2NvcmRpb24sXG4gICAgICAgICAgICAgICAgICAgIE1kQWNjb3JkaW9uLFxuICAgICAgICAgICAgICAgICAgICBNZEV4cGFuc2lvblBhbmVsLFxuICAgICAgICAgICAgICAgICAgICBNZEV4cGFuc2lvblBhbmVsQWN0aW9uUm93LFxuICAgICAgICAgICAgICAgICAgICBNZEV4cGFuc2lvblBhbmVsSGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBNZEV4cGFuc2lvblBhbmVsVGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kRXhwYW5zaW9uUGFuZWxEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIENka0FjY29yZGlvbixcbiAgICAgICAgICAgICAgICAgICAgTWRBY2NvcmRpb24sXG4gICAgICAgICAgICAgICAgICAgIE1kRXhwYW5zaW9uUGFuZWwsXG4gICAgICAgICAgICAgICAgICAgIE1kRXhwYW5zaW9uUGFuZWxBY3Rpb25Sb3csXG4gICAgICAgICAgICAgICAgICAgIE1kRXhwYW5zaW9uUGFuZWxIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIE1kRXhwYW5zaW9uUGFuZWxUaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRFeHBhbnNpb25QYW5lbERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVJdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kRXhwYW5zaW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE3ODQ5XG4gKi9cbnZhciBfTWRUYWJsZSA9IENka1RhYmxlO1xuLyoqXG4gKiBXcmFwcGVyIGZvciB0aGUgQ2RrVGFibGUgd2l0aCBNYXRlcmlhbCBkZXNpZ24gc3R5bGVzLlxuICovXG52YXIgTWRUYWJsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kVGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRUYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWRUYWJsZTtcbn0oX01kVGFibGUpKTtcbk1kVGFibGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC10YWJsZSwgbWF0LXRhYmxlJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogQ0RLX1RBQkxFX1RFTVBMQVRFLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC10YWJsZXtkaXNwbGF5OmJsb2NrfS5tYXQtaGVhZGVyLXJvdywubWF0LXJvd3tkaXNwbGF5OmZsZXg7Ym9yZGVyLWJvdHRvbS13aWR0aDoxcHg7Ym9yZGVyLWJvdHRvbS1zdHlsZTpzb2xpZDthbGlnbi1pdGVtczpjZW50ZXI7aGVpZ2h0OjQ4cHg7cGFkZGluZzowIDI0cHh9Lm1hdC1jZWxsLC5tYXQtaGVhZGVyLWNlbGx7ZmxleDoxfVwiXSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtdGFibGUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRUYWJsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xNzg0OVxuICovXG52YXIgX01kSGVhZGVyQ2VsbEJhc2UgPSBDZGtIZWFkZXJDZWxsO1xudmFyIF9NZENlbGwgPSBDZGtDZWxsO1xuLyoqXG4gKiBIZWFkZXIgY2VsbCB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBhZGRzIHRoZSByaWdodCBjbGFzc2VzIGFuZCByb2xlLlxuICovXG52YXIgTWRIZWFkZXJDZWxsID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRIZWFkZXJDZWxsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29sdW1uRGVmXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kSGVhZGVyQ2VsbChjb2x1bW5EZWYsIGVsZW1lbnRSZWYsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbHVtbkRlZiwgZWxlbWVudFJlZiwgcmVuZGVyZXIpIHx8IHRoaXM7XG4gICAgICAgIHJlbmRlcmVyLmFkZENsYXNzKGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJtYXQtY29sdW1uLVwiICsgY29sdW1uRGVmLm5hbWUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZEhlYWRlckNlbGw7XG59KF9NZEhlYWRlckNlbGxCYXNlKSk7XG5NZEhlYWRlckNlbGwuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWhlYWRlci1jZWxsLCBtYXQtaGVhZGVyLWNlbGwnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1oZWFkZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ2NvbHVtbmhlYWRlcicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRIZWFkZXJDZWxsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ2RrQ29sdW1uRGVmLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbl07IH07XG4vKipcbiAqIENlbGwgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgYWRkcyB0aGUgcmlnaHQgY2xhc3NlcyBhbmQgcm9sZS5cbiAqL1xudmFyIE1kQ2VsbCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1kQ2VsbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbHVtbkRlZlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZENlbGwoY29sdW1uRGVmLCBlbGVtZW50UmVmLCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb2x1bW5EZWYsIGVsZW1lbnRSZWYsIHJlbmRlcmVyKSB8fCB0aGlzO1xuICAgICAgICByZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwibWF0LWNvbHVtbi1cIiArIGNvbHVtbkRlZi5uYW1lKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWRDZWxsO1xufShfTWRDZWxsKSk7XG5NZENlbGwuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWNlbGwsIG1hdC1jZWxsJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ2dyaWRjZWxsJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZENlbGwuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDZGtDb2x1bW5EZWYsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuXTsgfTtcbi8qKlxuICogV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTc4NDlcbiAqL1xudmFyIF9NZEhlYWRlclJvdyA9IENka0hlYWRlclJvdztcbnZhciBfTWRSb3cgPSBDZGtSb3c7XG4vKipcbiAqIEhlYWRlciB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGUgY2VsbCBvdXRsZXQuIEFkZHMgdGhlIHJpZ2h0IGNsYXNzIGFuZCByb2xlLlxuICovXG52YXIgTWRIZWFkZXJSb3cgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZEhlYWRlclJvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZEhlYWRlclJvdygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWRIZWFkZXJSb3c7XG59KF9NZEhlYWRlclJvdykpO1xuTWRIZWFkZXJSb3cuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21kLWhlYWRlci1yb3csIG1hdC1oZWFkZXItcm93JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogQ0RLX1JPV19URU1QTEFURSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtaGVhZGVyLXJvdycsXG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3JvdycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRIZWFkZXJSb3cuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRGF0YSByb3cgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhlIGNlbGwgb3V0bGV0LiBBZGRzIHRoZSByaWdodCBjbGFzcyBhbmQgcm9sZS5cbiAqL1xudmFyIE1kUm93ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWRSb3csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRSb3coKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1kUm93O1xufShfTWRSb3cpKTtcbk1kUm93LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1yb3csIG1hdC1yb3cnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBDREtfUk9XX1RFTVBMQVRFLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1yb3cnLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdyb3cnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kUm93LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgTWRUYWJsZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFibGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFRhYmxlTW9kdWxlO1xufSgpKTtcbk1kVGFibGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDZGtUYWJsZU1vZHVsZSwgQ29tbW9uTW9kdWxlLCBNZENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kVGFibGUsIE1kSGVhZGVyQ2VsbCwgTWRDZWxsLCBNZEhlYWRlclJvdywgTWRSb3ddLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kVGFibGUsIE1kSGVhZGVyQ2VsbCwgTWRDZWxsLCBNZEhlYWRlclJvdywgTWRSb3ddLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZFRhYmxlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHBhcmFtIHs/fSBpZFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TWRTb3J0RHVwbGljYXRlTWRTb3J0YWJsZUlkRXJyb3IoaWQpIHtcbiAgICByZXR1cm4gRXJyb3IoXCJDYW5ub3QgaGF2ZSB0d28gTWRTb3J0YWJsZXMgd2l0aCB0aGUgc2FtZSBpZCAoXCIgKyBpZCArIFwiKS5cIik7XG59XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TWRTb3J0SGVhZGVyTm90Q29udGFpbmVkV2l0aGluTWRTb3J0RXJyb3IoKSB7XG4gICAgcmV0dXJuIEVycm9yKFwiTWRTb3J0SGVhZGVyIG11c3QgYmUgcGxhY2VkIHdpdGhpbiBhIHBhcmVudCBlbGVtZW50IHdpdGggdGhlIE1kU29ydCBkaXJlY3RpdmUuXCIpO1xufVxuLyoqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE1kU29ydEhlYWRlck1pc3NpbmdJZEVycm9yKCkge1xuICAgIHJldHVybiBFcnJvcihcIk1kU29ydEhlYWRlciBtdXN0IGJlIHByb3ZpZGVkIHdpdGggYSB1bmlxdWUgaWQuXCIpO1xufVxuLyoqXG4gKiBDb250YWluZXIgZm9yIE1kU29ydGFibGVzIHRvIG1hbmFnZSB0aGUgc29ydCBzdGF0ZSBhbmQgcHJvdmlkZSBkZWZhdWx0IHNvcnQgcGFyYW1ldGVycy5cbiAqL1xudmFyIE1kU29ydCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU29ydCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgYWxsIHJlZ2lzdGVyZWQgc29ydGFibGVzIHRoYXQgdGhpcyBkaXJlY3RpdmUgbWFuYWdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydGFibGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpcmVjdGlvbiB0byBzZXQgd2hlbiBhbiBNZFNvcnRhYmxlIGlzIGluaXRpYWxseSBzb3J0ZWQuXG4gICAgICAgICAqIE1heSBiZSBvdmVycmlkZW4gYnkgdGhlIE1kU29ydGFibGUncyBzb3J0IHN0YXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydCA9ICdhc2MnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNvcnQgZGlyZWN0aW9uIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIE1kU29ydGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgZWl0aGVyIHRoZSBhY3RpdmUgc29ydCBvciBzb3J0IGRpcmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWRTb3J0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTb3J0LnByb3RvdHlwZSwgXCJkaXNhYmxlQ2xlYXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBkaXNhYmxlIHRoZSB1c2VyIGZyb20gY2xlYXJpbmcgdGhlIHNvcnQgYnkgZmluaXNoaW5nIHRoZSBzb3J0IGRpcmVjdGlvbiBjeWNsZS5cbiAgICAgICAgICogTWF5IGJlIG92ZXJyaWRlbiBieSB0aGUgTWRTb3J0YWJsZSdzIGRpc2FibGUgY2xlYXIgaW5wdXQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVDbGVhcjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLl9kaXNhYmxlQ2xlYXIgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodik7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgYnkgdGhlIGNvbnRhaW5lZCBNZFNvcnRhYmxlcy4gQWRkcyB0aGUgTWRTb3J0YWJsZSB0byB0aGVcbiAgICAgKiBjb2xsZWN0aW9uIG9mIE1kU29ydGFibGVzLlxuICAgICAqIEBwYXJhbSB7P30gc29ydGFibGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU29ydC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoc29ydGFibGUpIHtcbiAgICAgICAgaWYgKCFzb3J0YWJsZS5pZCkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TWRTb3J0SGVhZGVyTWlzc2luZ0lkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zb3J0YWJsZXMuaGFzKHNvcnRhYmxlLmlkKSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TWRTb3J0RHVwbGljYXRlTWRTb3J0YWJsZUlkRXJyb3Ioc29ydGFibGUuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ydGFibGVzLnNldChzb3J0YWJsZS5pZCwgc29ydGFibGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciBmdW5jdGlvbiB0byBiZSB1c2VkIGJ5IHRoZSBjb250YWluZWQgTWRTb3J0YWJsZXMuIFJlbW92ZXMgdGhlIE1kU29ydGFibGUgZnJvbSB0aGVcbiAgICAgKiBjb2xsZWN0aW9uIG9mIGNvbnRhaW5lZCBNZFNvcnRhYmxlcy5cbiAgICAgKiBAcGFyYW0gez99IHNvcnRhYmxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNvcnQucHJvdG90eXBlLmRlcmVnaXN0ZXIgPSBmdW5jdGlvbiAoc29ydGFibGUpIHtcbiAgICAgICAgdGhpcy5zb3J0YWJsZXMuZGVsZXRlKHNvcnRhYmxlLmlkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBzb3J0IGlkIGFuZCBkZXRlcm1pbmVzIHRoZSBuZXcgc29ydCBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHs/fSBzb3J0YWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRTb3J0LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKHNvcnRhYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSAhPSBzb3J0YWJsZS5pZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBzb3J0YWJsZS5pZDtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gc29ydGFibGUuc3RhcnQgPyBzb3J0YWJsZS5zdGFydCA6IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMuZ2V0TmV4dFNvcnREaXJlY3Rpb24oc29ydGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWRTb3J0Q2hhbmdlLm5leHQoeyBhY3RpdmU6IHRoaXMuYWN0aXZlLCBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBzb3J0IGRpcmVjdGlvbiBvZiB0aGUgYWN0aXZlIHNvcnRhYmxlLCBjaGVja2luZyBmb3IgcG90ZW50aWFsIG92ZXJyaWRlcy5cbiAgICAgKiBAcGFyYW0gez99IHNvcnRhYmxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNvcnQucHJvdG90eXBlLmdldE5leHRTb3J0RGlyZWN0aW9uID0gZnVuY3Rpb24gKHNvcnRhYmxlKSB7XG4gICAgICAgIGlmICghc29ydGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIHNvcnQgZGlyZWN0aW9uIGN5Y2xlIHdpdGggdGhlIHBvdGVudGlhbCBzb3J0YWJsZSBvdmVycmlkZXMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpc2FibGVDbGVhciA9IHNvcnRhYmxlLmRpc2FibGVDbGVhciAhPSBudWxsID8gc29ydGFibGUuZGlzYWJsZUNsZWFyIDogdGhpcy5kaXNhYmxlQ2xlYXI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvcnREaXJlY3Rpb25DeWNsZSA9IGdldFNvcnREaXJlY3Rpb25DeWNsZShzb3J0YWJsZS5zdGFydCB8fCB0aGlzLnN0YXJ0LCBkaXNhYmxlQ2xlYXIpO1xuICAgICAgICAvLyBHZXQgYW5kIHJldHVybiB0aGUgbmV4dCBkaXJlY3Rpb24gaW4gdGhlIGN5Y2xlXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHREaXJlY3Rpb25JbmRleCA9IHNvcnREaXJlY3Rpb25DeWNsZS5pbmRleE9mKHRoaXMuZGlyZWN0aW9uKSArIDE7XG4gICAgICAgIGlmIChuZXh0RGlyZWN0aW9uSW5kZXggPj0gc29ydERpcmVjdGlvbkN5Y2xlLmxlbmd0aCkge1xuICAgICAgICAgICAgbmV4dERpcmVjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ydERpcmVjdGlvbkN5Y2xlW25leHREaXJlY3Rpb25JbmRleF07XG4gICAgfTtcbiAgICByZXR1cm4gTWRTb3J0O1xufSgpKTtcbk1kU29ydC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kU29ydF0sIFttYXRTb3J0XScsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk1kU29ydC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuTWRTb3J0LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdhY3RpdmUnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtZFNvcnRBY3RpdmUnLF0gfSxdLFxuICAgICdzdGFydCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kU29ydFN0YXJ0JyxdIH0sXSxcbiAgICAnZGlyZWN0aW9uJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWRTb3J0RGlyZWN0aW9uJyxdIH0sXSxcbiAgICAnZGlzYWJsZUNsZWFyJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWRTb3J0RGlzYWJsZUNsZWFyJyxdIH0sXSxcbiAgICAnbWRTb3J0Q2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHNvcnQgZGlyZWN0aW9uIGN5Y2xlIHRvIHVzZSBnaXZlbiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycyBvZiBvcmRlciBhbmQgY2xlYXIuXG4gKiBAcGFyYW0gez99IHN0YXJ0XG4gKiBAcGFyYW0gez99IGRpc2FibGVDbGVhclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0U29ydERpcmVjdGlvbkN5Y2xlKHN0YXJ0LCBkaXNhYmxlQ2xlYXIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3J0T3JkZXIgPSBbJ2FzYycsICdkZXNjJ107XG4gICAgaWYgKHN0YXJ0ID09ICdkZXNjJykge1xuICAgICAgICBzb3J0T3JkZXIucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBpZiAoIWRpc2FibGVDbGVhcikge1xuICAgICAgICBzb3J0T3JkZXIucHVzaCgnJyk7XG4gICAgfVxuICAgIHJldHVybiBzb3J0T3JkZXI7XG59XG4vKipcbiAqIFRvIG1vZGlmeSB0aGUgbGFiZWxzIGFuZCB0ZXh0IGRpc3BsYXllZCwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIE1kU29ydEhlYWRlckludGwgYW5kXG4gKiBpbmNsdWRlIGl0IGluIGEgY3VzdG9tIHByb3ZpZGVyLlxuICovXG52YXIgTWRTb3J0SGVhZGVySW50bCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU29ydEhlYWRlckludGwoKSB7XG4gICAgICAgIHRoaXMuc29ydEJ1dHRvbkxhYmVsID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJDaGFuZ2Ugc29ydGluZyBmb3IgXCIgKyBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgdG8gZGVzY3JpYmUgdGhlIGN1cnJlbnQgc29ydCAodmlzaWJsZSBvbmx5IHRvIHNjcmVlbnJlYWRlcnMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3J0RGVzY3JpcHRpb25MYWJlbCA9IGZ1bmN0aW9uIChpZCwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJTb3J0ZWQgYnkgXCIgKyBpZCArIFwiIFwiICsgKGRpcmVjdGlvbiA9PSAnYXNjJyA/ICdhc2NlbmRpbmcnIDogJ2Rlc2NlbmRpbmcnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE1kU29ydEhlYWRlckludGw7XG59KCkpO1xuTWRTb3J0SGVhZGVySW50bC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRTb3J0SGVhZGVySW50bC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBBcHBsaWVzIHNvcnRpbmcgYmVoYXZpb3IgKGNsaWNrIHRvIGNoYW5nZSBzb3J0KSBhbmQgc3R5bGVzIHRvIGFuIGVsZW1lbnQsIGluY2x1ZGluZyBhblxuICogYXJyb3cgdG8gZGlzcGxheSB0aGUgY3VycmVudCBzb3J0IGRpcmVjdGlvbi5cbiAqXG4gKiBNdXN0IGJlIHByb3ZpZGVkIHdpdGggYW4gaWQgYW5kIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgTWRTb3J0IGRpcmVjdGl2ZS5cbiAqXG4gKiBJZiB1c2VkIG9uIGhlYWRlciBjZWxscyBpbiBhIENka1RhYmxlLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgZGVmYXVsdCBpdHMgaWQgZnJvbSBpdHMgY29udGFpbmluZ1xuICogY29sdW1uIGRlZmluaXRpb24uXG4gKi9cbnZhciBNZFNvcnRIZWFkZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9pbnRsXG4gICAgICogQHBhcmFtIHs/fSBfY2hhbmdlRGV0ZWN0b3JSZWZcbiAgICAgKiBAcGFyYW0gez99IF9zb3J0XG4gICAgICogQHBhcmFtIHs/fSBfY2RrQ29sdW1uRGVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRTb3J0SGVhZGVyKF9pbnRsLCBfY2hhbmdlRGV0ZWN0b3JSZWYsIF9zb3J0LCBfY2RrQ29sdW1uRGVmKSB7XG4gICAgICAgIHRoaXMuX2ludGwgPSBfaW50bDtcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYgPSBfY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIHRoaXMuX3NvcnQgPSBfc29ydDtcbiAgICAgICAgdGhpcy5fY2RrQ29sdW1uRGVmID0gX2Nka0NvbHVtbkRlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBhcnJvdyB0aGF0IGRpc3BsYXlzIHdoZW4gc29ydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcnJvd1Bvc2l0aW9uID0gJ2FmdGVyJztcbiAgICAgICAgaWYgKCFfc29ydCkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TWRTb3J0SGVhZGVyTm90Q29udGFpbmVkV2l0aGluTWRTb3J0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvcnRTdWJzY3JpcHRpb24gPSBfc29ydC5tZFNvcnRDaGFuZ2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTsgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNvcnRIZWFkZXIucHJvdG90eXBlLCBcImRpc2FibGVDbGVhclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGRpc2FibGUgY2xlYXIgdmFsdWUgb2YgdGhlIGNvbnRhaW5pbmcgTWRTb3J0IGZvciB0aGlzIE1kU29ydGFibGUuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVDbGVhcjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLl9kaXNhYmxlQ2xlYXIgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodik7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNvcnRIZWFkZXIucHJvdG90eXBlLCBcIl9pZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmlkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuaWQgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU29ydEhlYWRlci5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pZCAmJiB0aGlzLl9jZGtDb2x1bW5EZWYpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLl9jZGtDb2x1bW5EZWYubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3J0LnJlZ2lzdGVyKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFNvcnRIZWFkZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zb3J0LmRlcmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc29ydFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIE1kU29ydEhlYWRlciBpcyBjdXJyZW50bHkgc29ydGVkIGluIGVpdGhlciBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kU29ydEhlYWRlci5wcm90b3R5cGUuX2lzU29ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc29ydC5hY3RpdmUgPT0gdGhpcy5pZCAmJiB0aGlzLl9zb3J0LmRpcmVjdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBNZFNvcnRIZWFkZXI7XG59KCkpO1xuTWRTb3J0SGVhZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21kLXNvcnQtaGVhZGVyXSwgW21hdC1zb3J0LWhlYWRlcl0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1zb3J0LWhlYWRlci1jb250YWluZXJcXFwiIFtjbGFzcy5tYXQtc29ydC1oZWFkZXItcG9zaXRpb24tYmVmb3JlXT1cXFwiYXJyb3dQb3NpdGlvbiA9PSAnYmVmb3JlJ1xcXCI+PGJ1dHRvbiBjbGFzcz1cXFwibWF0LXNvcnQtaGVhZGVyLWJ1dHRvblxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiX2ludGwuc29ydEJ1dHRvbkxhYmVsKGlkKVxcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvYnV0dG9uPjxkaXYgKm5nSWY9XFxcIl9pc1NvcnRlZCgpXFxcIiBjbGFzcz1cXFwibWF0LXNvcnQtaGVhZGVyLWFycm93XFxcIiBbY2xhc3MubWF0LXNvcnQtaGVhZGVyLWFzY109XFxcIl9zb3J0LmRpcmVjdGlvbiA9PSAnYXNjJ1xcXCIgW2NsYXNzLm1hdC1zb3J0LWhlYWRlci1kZXNjXT1cXFwiX3NvcnQuZGlyZWN0aW9uID09ICdkZXNjJ1xcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNvcnQtaGVhZGVyLXN0ZW1cXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1zb3J0LWhlYWRlci1wb2ludGVyLWxlZnRcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1zb3J0LWhlYWRlci1wb2ludGVyLXJpZ2h0XFxcIj48L2Rpdj48L2Rpdj48L2Rpdj48c3BhbiBjbGFzcz1cXFwiY2RrLXZpc3VhbGx5LWhpZGRlblxcXCIgKm5nSWY9XFxcIl9pc1NvcnRlZCgpXFxcIj57e19pbnRsLnNvcnREZXNjcmlwdGlvbkxhYmVsKGlkLCBfc29ydC5kaXJlY3Rpb24pfX08L3NwYW4+XCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXNvcnQtaGVhZGVyLWNvbnRhaW5lcntkaXNwbGF5OmZsZXg7Y3Vyc29yOnBvaW50ZXJ9Lm1hdC1zb3J0LWhlYWRlci1wb3NpdGlvbi1iZWZvcmV7ZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2V9Lm1hdC1zb3J0LWhlYWRlci1idXR0b257Ym9yZGVyOm5vbmU7YmFja2dyb3VuZDowIDA7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtwYWRkaW5nOjA7Y3Vyc29yOnBvaW50ZXI7b3V0bGluZTowO2ZvbnQ6aW5oZXJpdDtjb2xvcjpjdXJyZW50Q29sb3J9Lm1hdC1zb3J0LWhlYWRlci1hcnJvd3tkaXNwbGF5Om5vbmU7aGVpZ2h0OjEwcHg7d2lkdGg6MTBweDtwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW46MCAwIDAgNnB4fS5tYXQtc29ydC1oZWFkZXItcG9zaXRpb24tYmVmb3JlIC5tYXQtc29ydC1oZWFkZXItYXJyb3d7bWFyZ2luOjAgNnB4IDAgMH0ubWF0LXNvcnQtaGVhZGVyLWFzY3tkaXNwbGF5OmJsb2NrO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5tYXQtc29ydC1oZWFkZXItZGVzY3tkaXNwbGF5OmJsb2NrO3RyYW5zZm9ybTpyb3RhdGUoMjI1ZGVnKTt0b3A6MnB4fS5tYXQtc29ydC1oZWFkZXItc3RlbXtiYWNrZ3JvdW5kOmN1cnJlbnRDb2xvcjt0cmFuc2Zvcm06cm90YXRlKDEzNWRlZyk7aGVpZ2h0OjEwcHg7d2lkdGg6MnB4O21hcmdpbjphdXRvfS5tYXQtc29ydC1oZWFkZXItcG9pbnRlci1sZWZ0e2JhY2tncm91bmQ6Y3VycmVudENvbG9yO3dpZHRoOjJweDtoZWlnaHQ6OHB4O3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO3JpZ2h0OjB9Lm1hdC1zb3J0LWhlYWRlci1wb2ludGVyLXJpZ2h0e2JhY2tncm91bmQ6Y3VycmVudENvbG9yO3dpZHRoOjhweDtoZWlnaHQ6MnB4O3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO3JpZ2h0OjB9XCJdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJyhjbGljayknOiAnX3NvcnQuc29ydCh0aGlzKScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNvcnQtaGVhZGVyLXNvcnRlZF0nOiAnX2lzU29ydGVkKCknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRTb3J0SGVhZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTWRTb3J0SGVhZGVySW50bCwgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmLCB9LFxuICAgIHsgdHlwZTogTWRTb3J0LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IENka0NvbHVtbkRlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG5dOyB9O1xuTWRTb3J0SGVhZGVyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdpZCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21kLXNvcnQtaGVhZGVyJyxdIH0sXSxcbiAgICAnYXJyb3dQb3NpdGlvbic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnc3RhcnQnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydzdGFydCcsXSB9LF0sXG4gICAgJ2Rpc2FibGVDbGVhcic6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnX2lkJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0LXNvcnQtaGVhZGVyJyxdIH0sXSxcbn07XG52YXIgTWRTb3J0TW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTb3J0TW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRTb3J0TW9kdWxlO1xufSgpKTtcbk1kU29ydE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kU29ydCwgTWRTb3J0SGVhZGVyXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNvcnQsIE1kU29ydEhlYWRlcl0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWRTb3J0SGVhZGVySW50bF1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRTb3J0TW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFRvIG1vZGlmeSB0aGUgbGFiZWxzIGFuZCB0ZXh0IGRpc3BsYXllZCwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIE1kUGFnaW5hdG9ySW50bCBhbmRcbiAqIGluY2x1ZGUgaXQgaW4gYSBjdXN0b20gcHJvdmlkZXJcbiAqL1xudmFyIE1kUGFnaW5hdG9ySW50bCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUGFnaW5hdG9ySW50bCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSBwYWdlIHNpemUgc2VsZWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1zUGVyUGFnZUxhYmVsID0gJ0l0ZW1zIHBlciBwYWdlOic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxhYmVsIGZvciB0aGUgYnV0dG9uIHRoYXQgaW5jcmVtZW50cyB0aGUgY3VycmVudCBwYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0UGFnZUxhYmVsID0gJ05leHQgcGFnZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxhYmVsIGZvciB0aGUgYnV0dG9uIHRoYXQgZGVjcmVtZW50cyB0aGUgY3VycmVudCBwYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2aW91c1BhZ2VMYWJlbCA9ICdQcmV2aW91cyBwYWdlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSByYW5nZSBvZiBpdGVtcyB3aXRoaW4gdGhlIGN1cnJlbnQgcGFnZSBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgd2hvbGUgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UmFuZ2VMYWJlbCA9IGZ1bmN0aW9uIChwYWdlLCBwYWdlU2l6ZSwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09IDAgfHwgcGFnZVNpemUgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjAgb2YgXCIgKyBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZW5ndGggPSBNYXRoLm1heChsZW5ndGgsIDApO1xuICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBwYWdlICogcGFnZVNpemU7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3RhcnQgaW5kZXggZXhjZWVkcyB0aGUgbGlzdCBsZW5ndGgsIGRvIG5vdCB0cnkgYW5kIGZpeCB0aGUgZW5kIGluZGV4IHRvIHRoZSBlbmQuXG4gICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBzdGFydEluZGV4IDwgbGVuZ3RoID9cbiAgICAgICAgICAgICAgICBNYXRoLm1pbihzdGFydEluZGV4ICsgcGFnZVNpemUsIGxlbmd0aCkgOlxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggKyBwYWdlU2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBzdGFydEluZGV4ICsgMSArIFwiIC0gXCIgKyBlbmRJbmRleCArIFwiIG9mIFwiICsgbGVuZ3RoO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gTWRQYWdpbmF0b3JJbnRsO1xufSgpKTtcbk1kUGFnaW5hdG9ySW50bC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRQYWdpbmF0b3JJbnRsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIENoYW5nZSBldmVudCBvYmplY3QgdGhhdCBpcyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhXG4gKiBkaWZmZXJlbnQgcGFnZSBzaXplIG9yIG5hdmlnYXRlcyB0byBhbm90aGVyIHBhZ2UuXG4gKi9cbnZhciBQYWdlRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWdlRXZlbnQoKSB7XG4gICAgfVxuICAgIHJldHVybiBQYWdlRXZlbnQ7XG59KCkpO1xuLyoqXG4gKiBDb21wb25lbnQgdG8gcHJvdmlkZSBuYXZpZ2F0aW9uIGJldHdlZW4gcGFnZWQgaW5mb3JtYXRpb24uIERpc3BsYXlzIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50XG4gKiBwYWdlLCB1c2VyLXNlbGVjdGFibGUgb3B0aW9ucyB0byBjaGFuZ2UgdGhhdCBzaXplLCB3aGF0IGl0ZW1zIGFyZSBiZWluZyBzaG93biwgYW5kXG4gKiBuYXZpZ2F0aW9uYWwgYnV0dG9uIHRvIGdvIHRvIHRoZSBwcmV2aW91cyBvciBuZXh0IHBhZ2UuXG4gKi9cbnZhciBNZFBhZ2luYXRvciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2ludGxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFBhZ2luYXRvcihfaW50bCkge1xuICAgICAgICB0aGlzLl9pbnRsID0gX2ludGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgemVyby1iYXNlZCBwYWdlIGluZGV4IG9mIHRoZSBkaXNwbGF5ZWQgbGlzdCBvZiBpdGVtcy4gRGVmYXVsdGVkIHRvIDAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhZ2VJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgdGhhdCBhcmUgYmVpbmcgcGFnaW5hdGVkLiBEZWZhdWx0ZWQgdG8gMC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fcGFnZVNpemUgPSA1MDtcbiAgICAgICAgdGhpcy5fcGFnZVNpemVPcHRpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHBhZ2luYXRvciBjaGFuZ2VzIHRoZSBwYWdlIHNpemUgb3IgcGFnZSBpbmRleC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFnZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUGFnaW5hdG9yLnByb3RvdHlwZSwgXCJwYWdlU2l6ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgaXRlbXMgdG8gZGlzcGxheSBvbiBhIHBhZ2UuIEJ5IGRlZmF1bHQgc2V0IHRvIDUwLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYWdlU2l6ZTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFnZVNpemVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBhZ2VTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWdlU2l6ZSA9IHBhZ2VTaXplO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlzcGxheWVkUGFnZVNpemVPcHRpb25zKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFBhZ2luYXRvci5wcm90b3R5cGUsIFwicGFnZVNpemVPcHRpb25zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXQgb2YgcHJvdmlkZWQgcGFnZSBzaXplIG9wdGlvbnMgdG8gZGlzcGxheSB0byB0aGUgdXNlci5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFnZVNpemVPcHRpb25zOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYWdlU2l6ZU9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBhZ2VTaXplT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fcGFnZVNpemVPcHRpb25zID0gcGFnZVNpemVPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlzcGxheWVkUGFnZVNpemVPcHRpb25zKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRQYWdpbmF0b3IucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpc3BsYXllZFBhZ2VTaXplT3B0aW9ucygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWR2YW5jZXMgdG8gdGhlIG5leHQgcGFnZSBpZiBpdCBleGlzdHMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFBhZ2luYXRvci5wcm90b3R5cGUubmV4dFBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYWdlSW5kZXgrKztcbiAgICAgICAgdGhpcy5fZW1pdFBhZ2VFdmVudCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZSBiYWNrIHRvIHRoZSBwcmV2aW91cyBwYWdlIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUGFnaW5hdG9yLnByb3RvdHlwZS5wcmV2aW91c1BhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNQcmV2aW91c1BhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFnZUluZGV4LS07XG4gICAgICAgIHRoaXMuX2VtaXRQYWdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlcmUgaXMgYSBwcmV2aW91cyBwYWdlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWRQYWdpbmF0b3IucHJvdG90eXBlLmhhc1ByZXZpb3VzUGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUluZGV4ID49IDEgJiYgdGhpcy5wYWdlU2l6ZSAhPSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGVyZSBpcyBhIG5leHQgcGFnZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUGFnaW5hdG9yLnByb3RvdHlwZS5oYXNOZXh0UGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnVtYmVyT2ZQYWdlcyA9IE1hdGguY2VpbCh0aGlzLmxlbmd0aCAvIHRoaXMucGFnZVNpemUpIC0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUluZGV4IDwgbnVtYmVyT2ZQYWdlcyAmJiB0aGlzLnBhZ2VTaXplICE9IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBwYWdlIHNpemUgc28gdGhhdCB0aGUgZmlyc3QgaXRlbSBkaXNwbGF5ZWQgb24gdGhlIHBhZ2Ugd2lsbCBzdGlsbCBiZVxuICAgICAqIGRpc3BsYXllZCB1c2luZyB0aGUgbmV3IHBhZ2Ugc2l6ZS5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCBpZiB0aGUgcGFnZSBzaXplIGlzIDEwIGFuZCBvbiB0aGUgc2Vjb25kIHBhZ2UgKGl0ZW1zIGluZGV4ZWQgMTAtMTkpIHRoZW5cbiAgICAgKiBzd2l0Y2hpbmcgc28gdGhhdCB0aGUgcGFnZSBzaXplIGlzIDUgd2lsbCBzZXQgdGhlIHRoaXJkIHBhZ2UgYXMgdGhlIGN1cnJlbnQgcGFnZSBzb1xuICAgICAqIHRoYXQgdGhlIDEwdGggaXRlbSB3aWxsIHN0aWxsIGJlIGRpc3BsYXllZC5cbiAgICAgKiBAcGFyYW0gez99IHBhZ2VTaXplXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFBhZ2luYXRvci5wcm90b3R5cGUuX2NoYW5nZVBhZ2VTaXplID0gZnVuY3Rpb24gKHBhZ2VTaXplKSB7XG4gICAgICAgIC8vIEN1cnJlbnQgcGFnZSBuZWVkcyB0byBiZSB1cGRhdGVkIHRvIHJlZmxlY3QgdGhlIG5ldyBwYWdlIHNpemUuIE5hdmlnYXRlIHRvIHRoZSBwYWdlXG4gICAgICAgIC8vIGNvbnRhaW5pbmcgdGhlIHByZXZpb3VzIHBhZ2UncyBmaXJzdCBpdGVtLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydEluZGV4ID0gdGhpcy5wYWdlSW5kZXggKiB0aGlzLnBhZ2VTaXplO1xuICAgICAgICB0aGlzLnBhZ2VJbmRleCA9IE1hdGguZmxvb3Ioc3RhcnRJbmRleCAvIHBhZ2VTaXplKSB8fCAwO1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gcGFnZVNpemU7XG4gICAgICAgIHRoaXMuX2VtaXRQYWdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxpc3Qgb2YgcGFnZSBzaXplIG9wdGlvbnMgdG8gZGlzcGxheSB0byB0aGUgdXNlci4gSW5jbHVkZXMgbWFraW5nIHN1cmUgdGhhdFxuICAgICAqIHRoZSBwYWdlIHNpemUgaXMgYW4gb3B0aW9uIGFuZCB0aGF0IHRoZSBsaXN0IGlzIHNvcnRlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1kUGFnaW5hdG9yLnByb3RvdHlwZS5fdXBkYXRlRGlzcGxheWVkUGFnZVNpemVPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzcGxheWVkUGFnZVNpemVPcHRpb25zID0gdGhpcy5wYWdlU2l6ZU9wdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3BsYXllZFBhZ2VTaXplT3B0aW9ucy5pbmRleE9mKHRoaXMucGFnZVNpemUpID09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5ZWRQYWdlU2l6ZU9wdGlvbnMucHVzaCh0aGlzLnBhZ2VTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0IHRoZSBudW1iZXJzIHVzaW5nIGEgbnVtYmVyLXNwZWNpZmljIHNvcnQgZnVuY3Rpb24uXG4gICAgICAgIHRoaXMuX2Rpc3BsYXllZFBhZ2VTaXplT3B0aW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBub3RpZnlpbmcgdGhhdCBhIGNoYW5nZSBvZiB0aGUgcGFnaW5hdG9yJ3MgcHJvcGVydGllcyBoYXMgYmVlbiB0cmlnZ2VyZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZFBhZ2luYXRvci5wcm90b3R5cGUuX2VtaXRQYWdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFnZS5uZXh0KHtcbiAgICAgICAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5wYWdlU2l6ZSxcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRQYWdpbmF0b3I7XG59KCkpO1xuTWRQYWdpbmF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3sgc2VsZWN0b3I6ICdtZC1wYWdpbmF0b3IsIG1hdC1wYWdpbmF0b3InLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1wYWdpbmF0b3ItcGFnZS1zaXplXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtcGFnaW5hdG9yLXBhZ2Utc2l6ZS1sYWJlbFxcXCI+e3tfaW50bC5pdGVtc1BlclBhZ2VMYWJlbH19PC9kaXY+PG1kLXNlbGVjdCAqbmdJZj1cXFwiX2Rpc3BsYXllZFBhZ2VTaXplT3B0aW9ucy5sZW5ndGggPiAxXFxcIiBjbGFzcz1cXFwibWF0LXBhZ2luYXRvci1wYWdlLXNpemUtc2VsZWN0XFxcIiBbbmdNb2RlbF09XFxcInBhZ2VTaXplXFxcIiBbYXJpYS1sYWJlbF09XFxcIl9pbnRsLml0ZW1zUGVyUGFnZUxhYmVsXFxcIiAoY2hhbmdlKT1cXFwiX2NoYW5nZVBhZ2VTaXplKCRldmVudC52YWx1ZSlcXFwiPjxtZC1vcHRpb24gKm5nRm9yPVxcXCJsZXQgcGFnZVNpemVPcHRpb24gb2YgX2Rpc3BsYXllZFBhZ2VTaXplT3B0aW9uc1xcXCIgW3ZhbHVlXT1cXFwicGFnZVNpemVPcHRpb25cXFwiPnt7cGFnZVNpemVPcHRpb259fTwvbWQtb3B0aW9uPjwvbWQtc2VsZWN0PjxkaXYgKm5nSWY9XFxcIl9kaXNwbGF5ZWRQYWdlU2l6ZU9wdGlvbnMubGVuZ3RoIDw9IDFcXFwiPnt7cGFnZVNpemV9fTwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1wYWdpbmF0b3ItcmFuZ2UtbGFiZWxcXFwiPnt7X2ludGwuZ2V0UmFuZ2VMYWJlbChwYWdlSW5kZXgsIHBhZ2VTaXplLCBsZW5ndGgpfX08L2Rpdj48YnV0dG9uIG1kLWljb24tYnV0dG9uIGNsYXNzPVxcXCJtYXQtcGFnaW5hdG9yLW5hdmlnYXRpb24tcHJldmlvdXNcXFwiIChjbGljayk9XFxcInByZXZpb3VzUGFnZSgpXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiX2ludGwucHJldmlvdXNQYWdlTGFiZWxcXFwiIFttZFRvb2x0aXBdPVxcXCJfaW50bC5wcmV2aW91c1BhZ2VMYWJlbFxcXCIgW21kVG9vbHRpcFBvc2l0aW9uXT1cXFwiJ2Fib3ZlJ1xcXCIgW2Rpc2FibGVkXT1cXFwiIWhhc1ByZXZpb3VzUGFnZSgpXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtcGFnaW5hdG9yLWluY3JlbWVudFxcXCI+PC9kaXY+PC9idXR0b24+IDxidXR0b24gbWQtaWNvbi1idXR0b24gY2xhc3M9XFxcIm1hdC1wYWdpbmF0b3ItbmF2aWdhdGlvbi1uZXh0XFxcIiAoY2xpY2spPVxcXCJuZXh0UGFnZSgpXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiX2ludGwubmV4dFBhZ2VMYWJlbFxcXCIgW21kVG9vbHRpcF09XFxcIl9pbnRsLm5leHRQYWdlTGFiZWxcXFwiIFttZFRvb2x0aXBQb3NpdGlvbl09XFxcIidhYm92ZSdcXFwiIFtkaXNhYmxlZF09XFxcIiFoYXNOZXh0UGFnZSgpXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtcGFnaW5hdG9yLWRlY3JlbWVudFxcXCI+PC9kaXY+PC9idXR0b24+XCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXBhZ2luYXRvcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpmbGV4LWVuZDttaW4taGVpZ2h0OjU2cHg7cGFkZGluZzowIDhweH0ubWF0LXBhZ2luYXRvci1wYWdlLXNpemV7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcn0ubWF0LXBhZ2luYXRvci1wYWdlLXNpemUtbGFiZWx7bWFyZ2luOjAgNHB4fS5tYXQtcGFnaW5hdG9yLXBhZ2Utc2l6ZS1zZWxlY3R7bWFyZ2luOjAgNHB4fS5tYXQtcGFnaW5hdG9yLXBhZ2Utc2l6ZS1zZWxlY3QgLm1hdC1zZWxlY3QtdHJpZ2dlcnttaW4td2lkdGg6NTZweH0ubWF0LXBhZ2luYXRvci1yYW5nZS1sYWJlbHttYXJnaW46MCAzMnB4fS5tYXQtcGFnaW5hdG9yLWluY3JlbWVudC1idXR0b24rLm1hdC1wYWdpbmF0b3ItaW5jcmVtZW50LWJ1dHRvbnttYXJnaW46MCAwIDAgOHB4fVtkaXI9cnRsXSAubWF0LXBhZ2luYXRvci1pbmNyZW1lbnQtYnV0dG9uKy5tYXQtcGFnaW5hdG9yLWluY3JlbWVudC1idXR0b257bWFyZ2luOjAgOHB4IDAgMH0ubWF0LXBhZ2luYXRvci1kZWNyZW1lbnQsLm1hdC1wYWdpbmF0b3ItaW5jcmVtZW50e3dpZHRoOjhweDtoZWlnaHQ6OHB4fS5tYXQtcGFnaW5hdG9yLWRlY3JlbWVudCxbZGlyPXJ0bF0gLm1hdC1wYWdpbmF0b3ItaW5jcmVtZW50e3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5tYXQtcGFnaW5hdG9yLWluY3JlbWVudCxbZGlyPXJ0bF0gLm1hdC1wYWdpbmF0b3ItZGVjcmVtZW50e3RyYW5zZm9ybTpyb3RhdGUoMjI1ZGVnKX0ubWF0LXBhZ2luYXRvci1kZWNyZW1lbnR7bWFyZ2luLWxlZnQ6MTJweH1bZGlyPXJ0bF0gLm1hdC1wYWdpbmF0b3ItZGVjcmVtZW50e21hcmdpbi1yaWdodDoxMnB4fS5tYXQtcGFnaW5hdG9yLWluY3JlbWVudHttYXJnaW4tbGVmdDoxNnB4fVtkaXI9cnRsXSAubWF0LXBhZ2luYXRvci1pbmNyZW1lbnR7bWFyZ2luLXJpZ2h0OjE2cHh9XCJdLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1wYWdpbmF0b3InLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTUFURVJJQUxfQ09NUEFUSUJJTElUWV9NT0RFLCB1c2VWYWx1ZTogZmFsc2UgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRQYWdpbmF0b3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBNZFBhZ2luYXRvckludGwsIH0sXG5dOyB9O1xuTWRQYWdpbmF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3BhZ2VJbmRleCc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAnbGVuZ3RoJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdwYWdlU2l6ZSc6IFt7IHR5cGU6IElucHV0IH0sXSxcbiAgICAncGFnZVNpemVPcHRpb25zJzogW3sgdHlwZTogSW5wdXQgfSxdLFxuICAgICdwYWdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbn07XG52YXIgTWRQYWdpbmF0b3JNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFBhZ2luYXRvck1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kUGFnaW5hdG9yTW9kdWxlO1xufSgpKTtcbk1kUGFnaW5hdG9yTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE1kQnV0dG9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBNZFNlbGVjdE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTWRUb29sdGlwTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW01kUGFnaW5hdG9yXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFBhZ2luYXRvcl0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWRQYWdpbmF0b3JJbnRsXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWRQYWdpbmF0b3JNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbnZhciBNQVRFUklBTF9NT0RVTEVTID0gW1xuICAgIE1kQXV0b2NvbXBsZXRlTW9kdWxlLFxuICAgIE1kQnV0dG9uTW9kdWxlLFxuICAgIE1kQnV0dG9uVG9nZ2xlTW9kdWxlLFxuICAgIE1kQ2FyZE1vZHVsZSxcbiAgICBNZENoaXBzTW9kdWxlLFxuICAgIE1kQ2hlY2tib3hNb2R1bGUsXG4gICAgTWREYXRlcGlja2VyTW9kdWxlLFxuICAgIE1kVGFibGVNb2R1bGUsXG4gICAgTWREaWFsb2dNb2R1bGUsXG4gICAgTWRFeHBhbnNpb25Nb2R1bGUsXG4gICAgTWRHcmlkTGlzdE1vZHVsZSxcbiAgICBNZEljb25Nb2R1bGUsXG4gICAgTWRJbnB1dE1vZHVsZSxcbiAgICBNZExpc3RNb2R1bGUsXG4gICAgTWRNZW51TW9kdWxlLFxuICAgIE1kUGFnaW5hdG9yTW9kdWxlLFxuICAgIE1kUHJvZ3Jlc3NCYXJNb2R1bGUsXG4gICAgTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUsXG4gICAgTWRSYWRpb01vZHVsZSxcbiAgICBNZFJpcHBsZU1vZHVsZSxcbiAgICBNZFNlbGVjdE1vZHVsZSxcbiAgICBNZFNpZGVuYXZNb2R1bGUsXG4gICAgTWRTbGlkZXJNb2R1bGUsXG4gICAgTWRTbGlkZVRvZ2dsZU1vZHVsZSxcbiAgICBNZFNuYWNrQmFyTW9kdWxlLFxuICAgIE1kU29ydE1vZHVsZSxcbiAgICBNZFRhYnNNb2R1bGUsXG4gICAgTWRUb29sYmFyTW9kdWxlLFxuICAgIE1kVG9vbHRpcE1vZHVsZSxcbiAgICBPdmVybGF5TW9kdWxlLFxuICAgIFBvcnRhbE1vZHVsZSxcbiAgICBCaWRpTW9kdWxlLFxuICAgIFN0eWxlTW9kdWxlLFxuICAgIEExMXlNb2R1bGUsXG4gICAgUGxhdGZvcm1Nb2R1bGUsXG4gICAgTWRDb21tb25Nb2R1bGUsXG4gICAgT2JzZXJ2ZUNvbnRlbnRNb2R1bGVcbl07XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbnZhciBNYXRlcmlhbE1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdGVyaWFsTW9kdWxlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWF0ZXJpYWxNb2R1bGU7XG59KCkpO1xuTWF0ZXJpYWxNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IE1BVEVSSUFMX01PRFVMRVMsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogTUFURVJJQUxfTU9EVUxFUyxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTWF0ZXJpYWxNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cbmV4cG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSwgY29lcmNlTnVtYmVyUHJvcGVydHksIE9ic2VydmVDb250ZW50TW9kdWxlLCBPYnNlcnZlQ29udGVudCwgRGlyLCBEaXJlY3Rpb25hbGl0eSwgQmlkaU1vZHVsZSwgUG9ydGFsLCBCYXNlUG9ydGFsSG9zdCwgQ29tcG9uZW50UG9ydGFsLCBUZW1wbGF0ZVBvcnRhbCwgUG9ydGFsSG9zdERpcmVjdGl2ZSwgVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUsIFBvcnRhbE1vZHVsZSwgRG9tUG9ydGFsSG9zdCwgR2VzdHVyZUNvbmZpZywgTGl2ZUFubm91bmNlciwgTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTiwgTElWRV9BTk5PVU5DRVJfUFJPVklERVIsIEludGVyYWN0aXZpdHlDaGVja2VyLCBpc0Zha2VNb3VzZWRvd25Gcm9tU2NyZWVuUmVhZGVyLCBBMTF5TW9kdWxlLCBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLCBVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVIsIE1kTGluZU1vZHVsZSwgTWRMaW5lLCBNZExpbmVTZXR0ZXIsIENvbXBhdGliaWxpdHlNb2R1bGUsIE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlLCBNZENvbW1vbk1vZHVsZSwgTUFURVJJQUxfU0FOSVRZX0NIRUNLUywgTURfUExBQ0VIT0xERVJfR0xPQkFMX09QVElPTlMsIE1EX0VSUk9SX0dMT0JBTF9PUFRJT05TLCBkZWZhdWx0RXJyb3JTdGF0ZU1hdGNoZXIsIHNob3dPbkRpcnR5RXJyb3JTdGF0ZU1hdGNoZXIsIE1kQ29yZU1vZHVsZSwgTWRPcHRpb25Nb2R1bGUsIE1kT3B0aW9uU2VsZWN0aW9uQ2hhbmdlLCBNZE9wdGlvbiwgTWRPcHRncm91cEJhc2UsIF9NZE9wdGdyb3VwTWl4aW5CYXNlLCBNZE9wdGdyb3VwLCBQbGF0Zm9ybU1vZHVsZSwgUGxhdGZvcm0sIGdldFN1cHBvcnRlZElucHV0VHlwZXMsIE9WRVJMQVlfUFJPVklERVJTLCBPdmVybGF5TW9kdWxlLCBPdmVybGF5LCBPdmVybGF5Q29udGFpbmVyLCBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lciwgT3ZlcmxheVJlZiwgT3ZlcmxheVN0YXRlLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLCBPdmVybGF5T3JpZ2luLCBWaWV3cG9ydFJ1bGVyLCBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LCBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LCBDb25uZWN0aW9uUG9zaXRpb25QYWlyLCBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMsIENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZSwgU2Nyb2xsYWJsZSwgU2Nyb2xsRGlzcGF0Y2hlciwgU2Nyb2xsU3RyYXRlZ3lPcHRpb25zLCBSZXBvc2l0aW9uU2Nyb2xsU3RyYXRlZ3ksIENsb3NlU2Nyb2xsU3RyYXRlZ3ksIE5vb3BTY3JvbGxTdHJhdGVneSwgQmxvY2tTY3JvbGxTdHJhdGVneSwgU2Nyb2xsRGlzcGF0Y2hNb2R1bGUsIE1kUmlwcGxlLCBNRF9SSVBQTEVfR0xPQkFMX09QVElPTlMsIFJpcHBsZVJlZiwgUmlwcGxlU3RhdGUsIFJJUFBMRV9GQURFX0lOX0RVUkFUSU9OLCBSSVBQTEVfRkFERV9PVVRfRFVSQVRJT04sIE1kUmlwcGxlTW9kdWxlLCBTZWxlY3Rpb25Nb2RlbCwgU2VsZWN0aW9uQ2hhbmdlLCBGb2N1c1RyYXAsIEZvY3VzVHJhcEZhY3RvcnksIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUsIEZvY3VzVHJhcERpcmVjdGl2ZSwgU3R5bGVNb2R1bGUsIFRPVUNIX0JVRkZFUl9NUywgRm9jdXNPcmlnaW5Nb25pdG9yLCBDZGtNb25pdG9yRm9jdXMsIEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSX0ZBQ1RPUlksIEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSLCBhcHBseUNzc1RyYW5zZm9ybSwgVVBfQVJST1csIERPV05fQVJST1csIFJJR0hUX0FSUk9XLCBMRUZUX0FSUk9XLCBQQUdFX1VQLCBQQUdFX0RPV04sIEhPTUUsIEVORCwgRU5URVIsIFNQQUNFLCBUQUIsIEVTQ0FQRSwgQkFDS1NQQUNFLCBERUxFVEUsIE1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSwgZ2V0TWRDb21wYXRpYmlsaXR5SW52YWxpZFByZWZpeEVycm9yLCBNQVRfRUxFTUVOVFNfU0VMRUNUT1IsIE1EX0VMRU1FTlRTX1NFTEVDVE9SLCBNYXRQcmVmaXhSZWplY3RvciwgTWRQcmVmaXhSZWplY3RvciwgQW5pbWF0aW9uQ3VydmVzLCBBbmltYXRpb25EdXJhdGlvbnMsIE1kU2VsZWN0aW9uTW9kdWxlLCBNZFBzZXVkb0NoZWNrYm94QmFzZSwgX01kUHNldWRvQ2hlY2tib3hCYXNlLCBNZFBzZXVkb0NoZWNrYm94LCBOYXRpdmVEYXRlTW9kdWxlLCBNZE5hdGl2ZURhdGVNb2R1bGUsIERhdGVBZGFwdGVyLCBNRF9EQVRFX0ZPUk1BVFMsIE5hdGl2ZURhdGVBZGFwdGVyLCBNRF9OQVRJVkVfREFURV9GT1JNQVRTLCBNYXRlcmlhbE1vZHVsZSwgTWRBdXRvY29tcGxldGVNb2R1bGUsIE1kQXV0b2NvbXBsZXRlLCBBVVRPQ09NUExFVEVfT1BUSU9OX0hFSUdIVCwgQVVUT0NPTVBMRVRFX1BBTkVMX0hFSUdIVCwgTURfQVVUT0NPTVBMRVRFX1ZBTFVFX0FDQ0VTU09SLCBnZXRNZEF1dG9jb21wbGV0ZU1pc3NpbmdQYW5lbEVycm9yLCBNZEF1dG9jb21wbGV0ZVRyaWdnZXIsIE1kQnV0dG9uTW9kdWxlLCBNZEJ1dHRvbkNzc01hdFN0eWxlciwgTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIsIE1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlciwgTWRGYWIsIE1kTWluaUZhYiwgTWRCdXR0b25CYXNlLCBfTWRCdXR0b25NaXhpbkJhc2UsIE1kQnV0dG9uLCBNZEFuY2hvciwgTWRCdXR0b25Ub2dnbGVNb2R1bGUsIE1kQnV0dG9uVG9nZ2xlR3JvdXBCYXNlLCBfTWRCdXR0b25Ub2dnbGVHcm91cE1peGluQmFzZSwgTURfQlVUVE9OX1RPR0dMRV9HUk9VUF9WQUxVRV9BQ0NFU1NPUiwgTWRCdXR0b25Ub2dnbGVDaGFuZ2UsIE1kQnV0dG9uVG9nZ2xlR3JvdXAsIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSwgTWRCdXR0b25Ub2dnbGUsIE1kQ2FyZE1vZHVsZSwgTWRDYXJkQ29udGVudCwgTWRDYXJkVGl0bGUsIE1kQ2FyZFN1YnRpdGxlLCBNZENhcmRBY3Rpb25zLCBNZENhcmRGb290ZXIsIE1kQ2FyZEltYWdlLCBNZENhcmRTbUltYWdlLCBNZENhcmRNZEltYWdlLCBNZENhcmRMZ0ltYWdlLCBNZENhcmRYbEltYWdlLCBNZENhcmRBdmF0YXIsIE1kQ2FyZCwgTWRDYXJkSGVhZGVyLCBNZENhcmRUaXRsZUdyb3VwLCBNZENoaXBzTW9kdWxlLCBNZENoaXBMaXN0LCBNZENoaXBCYXNlLCBfTWRDaGlwTWl4aW5CYXNlLCBNZEJhc2ljQ2hpcCwgTWRDaGlwLCBNZENoZWNrYm94TW9kdWxlLCBNRF9DSEVDS0JPWF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLCBUcmFuc2l0aW9uQ2hlY2tTdGF0ZSwgTWRDaGVja2JveENoYW5nZSwgTWRDaGVja2JveEJhc2UsIF9NZENoZWNrYm94TWl4aW5CYXNlLCBNZENoZWNrYm94LCBNZERhdGVwaWNrZXJNb2R1bGUsIE1kQ2FsZW5kYXIsIE1kQ2FsZW5kYXJDZWxsLCBNZENhbGVuZGFyQm9keSwgTWREYXRlcGlja2VyQ29udGVudCwgTWREYXRlcGlja2VyLCBNRF9EQVRFUElDS0VSX1ZBTFVFX0FDQ0VTU09SLCBNRF9EQVRFUElDS0VSX1ZBTElEQVRPUlMsIE1kRGF0ZXBpY2tlcklucHV0LCBNZERhdGVwaWNrZXJJbnRsLCBNZERhdGVwaWNrZXJUb2dnbGUsIE1kTW9udGhWaWV3LCBNZFllYXJWaWV3LCBNZERpYWxvZ01vZHVsZSwgTURfRElBTE9HX0RBVEEsIE1kRGlhbG9nLCB0aHJvd01kRGlhbG9nQ29udGVudEFscmVhZHlBdHRhY2hlZEVycm9yLCBNZERpYWxvZ0NvbnRhaW5lciwgTWREaWFsb2dDbG9zZSwgTWREaWFsb2dUaXRsZSwgTWREaWFsb2dDb250ZW50LCBNZERpYWxvZ0FjdGlvbnMsIE1kRGlhbG9nQ29uZmlnLCBNZERpYWxvZ1JlZiwgTWRFeHBhbnNpb25Nb2R1bGUsIENka0FjY29yZGlvbiwgTWRBY2NvcmRpb24sIEFjY29yZGlvbkl0ZW0sIE1kRXhwYW5zaW9uUGFuZWwsIE1kRXhwYW5zaW9uUGFuZWxBY3Rpb25Sb3csIE1kRXhwYW5zaW9uUGFuZWxIZWFkZXIsIE1kRXhwYW5zaW9uUGFuZWxEZXNjcmlwdGlvbiwgTWRFeHBhbnNpb25QYW5lbFRpdGxlLCBNZEdyaWRMaXN0TW9kdWxlLCBNZEdyaWRUaWxlLCBNZEdyaWRMaXN0LCBNZEljb25Nb2R1bGUsIE1kSWNvbkJhc2UsIF9NZEljb25NaXhpbkJhc2UsIE1kSWNvbiwgZ2V0TWRJY29uTmFtZU5vdEZvdW5kRXJyb3IsIGdldE1kSWNvbk5vSHR0cFByb3ZpZGVyRXJyb3IsIGdldE1kSWNvbkZhaWxlZFRvU2FuaXRpemVFcnJvciwgTWRJY29uUmVnaXN0cnksIElDT05fUkVHSVNUUllfUFJPVklERVJfRkFDVE9SWSwgSUNPTl9SRUdJU1RSWV9QUk9WSURFUiwgTWRJbnB1dE1vZHVsZSwgTWRUZXh0YXJlYUF1dG9zaXplLCBNZFBsYWNlaG9sZGVyLCBNZEhpbnQsIE1kRXJyb3JEaXJlY3RpdmUsIE1kUHJlZml4LCBNZFN1ZmZpeCwgTWRJbnB1dERpcmVjdGl2ZSwgTWRJbnB1dENvbnRhaW5lciwgZ2V0TWRJbnB1dENvbnRhaW5lclBsYWNlaG9sZGVyQ29uZmxpY3RFcnJvciwgZ2V0TWRJbnB1dENvbnRhaW5lclVuc3VwcG9ydGVkVHlwZUVycm9yLCBnZXRNZElucHV0Q29udGFpbmVyRHVwbGljYXRlZEhpbnRFcnJvciwgZ2V0TWRJbnB1dENvbnRhaW5lck1pc3NpbmdNZElucHV0RXJyb3IsIE1kTGlzdE1vZHVsZSwgTWRMaXN0RGl2aWRlciwgTWRMaXN0LCBNZExpc3RDc3NNYXRTdHlsZXIsIE1kTmF2TGlzdENzc01hdFN0eWxlciwgTWREaXZpZGVyQ3NzTWF0U3R5bGVyLCBNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIsIE1kTGlzdEljb25Dc3NNYXRTdHlsZXIsIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlciwgTWRMaXN0SXRlbSwgTWRNZW51TW9kdWxlLCBmYWRlSW5JdGVtcywgdHJhbnNmb3JtTWVudSwgTWRNZW51LCBNZE1lbnVJdGVtLCBNZE1lbnVUcmlnZ2VyLCBNZFBhZ2luYXRvck1vZHVsZSwgUGFnZUV2ZW50LCBNZFBhZ2luYXRvciwgTWRQcm9ncmVzc0Jhck1vZHVsZSwgTWRQcm9ncmVzc0JhciwgTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUsIFBST0dSRVNTX1NQSU5ORVJfU1RST0tFX1dJRFRILCBNZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlciwgTWRQcm9ncmVzc1NwaW5uZXJCYXNlLCBfTWRQcm9ncmVzc1NwaW5uZXJNaXhpbkJhc2UsIE1kUHJvZ3Jlc3NTcGlubmVyLCBNZFNwaW5uZXIsIE1kUmFkaW9Nb2R1bGUsIE1EX1JBRElPX0dST1VQX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsIE1kUmFkaW9DaGFuZ2UsIE1kUmFkaW9Hcm91cEJhc2UsIF9NZFJhZGlvR3JvdXBNaXhpbkJhc2UsIE1kUmFkaW9Hcm91cCwgTWRSYWRpb0J1dHRvbkJhc2UsIF9NZFJhZGlvQnV0dG9uTWl4aW5CYXNlLCBNZFJhZGlvQnV0dG9uLCBNZFNlbGVjdE1vZHVsZSwgZmFkZUluQ29udGVudCwgdHJhbnNmb3JtUGFuZWwsIHRyYW5zZm9ybVBsYWNlaG9sZGVyLCBTRUxFQ1RfSVRFTV9IRUlHSFQsIFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hULCBTRUxFQ1RfTUFYX09QVElPTlNfRElTUExBWUVELCBTRUxFQ1RfVFJJR0dFUl9IRUlHSFQsIFNFTEVDVF9PUFRJT05fSEVJR0hUX0FESlVTVE1FTlQsIFNFTEVDVF9QQU5FTF9QQURESU5HX1gsIFNFTEVDVF9QQU5FTF9JTkRFTlRfUEFERElOR19YLCBTRUxFQ1RfTVVMVElQTEVfUEFORUxfUEFERElOR19YLCBTRUxFQ1RfUEFORUxfUEFERElOR19ZLCBTRUxFQ1RfUEFORUxfVklFV1BPUlRfUEFERElORywgTWRTZWxlY3RDaGFuZ2UsIE1kU2VsZWN0QmFzZSwgX01kU2VsZWN0TWl4aW5CYXNlLCBNZFNlbGVjdCwgTWRTaWRlbmF2TW9kdWxlLCB0aHJvd01kRHVwbGljYXRlZFNpZGVuYXZFcnJvciwgTWRTaWRlbmF2VG9nZ2xlUmVzdWx0LCBNZFNpZGVuYXYsIE1kU2lkZW5hdkNvbnRhaW5lciwgTWRTbGlkZXJNb2R1bGUsIE1EX1NMSURFUl9WQUxVRV9BQ0NFU1NPUiwgTWRTbGlkZXJDaGFuZ2UsIE1kU2xpZGVyQmFzZSwgX01kU2xpZGVyTWl4aW5CYXNlLCBNZFNsaWRlciwgU2xpZGVyUmVuZGVyZXIsIE1kU2xpZGVUb2dnbGVNb2R1bGUsIE1EX1NMSURFX1RPR0dMRV9WQUxVRV9BQ0NFU1NPUiwgTWRTbGlkZVRvZ2dsZUNoYW5nZSwgTWRTbGlkZVRvZ2dsZUJhc2UsIF9NZFNsaWRlVG9nZ2xlTWl4aW5CYXNlLCBNZFNsaWRlVG9nZ2xlLCBNZFNuYWNrQmFyTW9kdWxlLCBNZFNuYWNrQmFyLCBTSE9XX0FOSU1BVElPTiwgSElERV9BTklNQVRJT04sIE1kU25hY2tCYXJDb250YWluZXIsIE1kU25hY2tCYXJDb25maWcsIE1kU25hY2tCYXJSZWYsIFNpbXBsZVNuYWNrQmFyLCBNZFNvcnRNb2R1bGUsIE1kU29ydEhlYWRlciwgTWRTb3J0SGVhZGVySW50bCwgTWRTb3J0LCBNZFRhYmxlTW9kdWxlLCBfTWRIZWFkZXJDZWxsQmFzZSwgX01kQ2VsbCwgTWRIZWFkZXJDZWxsLCBNZENlbGwsIF9NZFRhYmxlLCBNZFRhYmxlLCBfTWRIZWFkZXJSb3csIF9NZFJvdywgTWRIZWFkZXJSb3csIE1kUm93LCBNZFRhYnNNb2R1bGUsIE1kSW5rQmFyLCBNZFRhYkJvZHksIE1kVGFiSGVhZGVyLCBNZFRhYkxhYmVsV3JhcHBlciwgTWRUYWIsIE1kVGFiTGFiZWwsIE1kVGFiTmF2LCBNZFRhYkxpbmssIE1kVGFiQ2hhbmdlRXZlbnQsIE1kVGFiR3JvdXAsIE1kVGFiTGlua0Jhc2UsIF9NZFRhYkxpbmtNaXhpbkJhc2UsIE1kVG9vbGJhck1vZHVsZSwgTWRUb29sYmFyUm93LCBNZFRvb2xiYXJCYXNlLCBfTWRUb29sYmFyTWl4aW5CYXNlLCBNZFRvb2xiYXIsIE1kVG9vbHRpcE1vZHVsZSwgVE9VQ0hFTkRfSElERV9ERUxBWSwgU0NST0xMX1RIUk9UVExFX01TLCBnZXRNZFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvciwgTWRUb29sdGlwLCBUb29sdGlwQ29tcG9uZW50LCBtaXhpbkNvbG9yIGFzIMm1dSwgbWl4aW5EaXNhYmxlZCBhcyDJtXYsIFVOSVFVRV9TRUxFQ1RJT05fRElTUEFUQ0hFUl9QUk9WSURFUl9GQUNUT1JZIGFzIMm1aCwgT1ZFUkxBWV9DT05UQUlORVJfUFJPVklERVIgYXMgybViLCBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUl9GQUNUT1JZIGFzIMm1YSwgT3ZlcmxheVBvc2l0aW9uQnVpbGRlciBhcyDJtXQsIFZJRVdQT1JUX1JVTEVSX1BST1ZJREVSIGFzIMm1ZCwgVklFV1BPUlRfUlVMRVJfUFJPVklERVJfRkFDVE9SWSBhcyDJtWMsIFNDUk9MTF9ESVNQQVRDSEVSX1BST1ZJREVSIGFzIMm1ZiwgU0NST0xMX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWSBhcyDJtWUsIFJpcHBsZVJlbmRlcmVyIGFzIMm1ZywgRVhQQU5TSU9OX1BBTkVMX0FOSU1BVElPTl9USU1JTkcgYXMgybVpLCBNZEdyaWRBdmF0YXJDc3NNYXRTdHlsZXIgYXMgybVrLCBNZEdyaWRUaWxlRm9vdGVyQ3NzTWF0U3R5bGVyIGFzIMm1bSwgTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlciBhcyDJtWwsIE1kR3JpZFRpbGVUZXh0IGFzIMm1aiwgTWRNZW51SXRlbUJhc2UgYXMgybVuLCBfTWRNZW51SXRlbU1peGluQmFzZSBhcyDJtW8sIE1kUGFnaW5hdG9ySW50bCBhcyDJtXgsIE1kVGFiQmFzZSBhcyDJtXIsIF9NZFRhYk1peGluQmFzZSBhcyDJtXMsIE1kVGFiTGFiZWxXcmFwcGVyQmFzZSBhcyDJtXAsIF9NZFRhYkxhYmVsV3JhcHBlck1peGluQmFzZSBhcyDJtXEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGVyaWFsLmVzNS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL21hdGVyaWFsL0Bhbmd1bGFyL21hdGVyaWFsLmVzNS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1244\\n')\n},1245:function(module,__webpack_exports__,__webpack_require__){\"use strict\"\n;eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return A11yModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D\", function() { return LIVE_ANNOUNCER_ELEMENT_TOKEN; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"G\", function() { return LiveAnnouncer; });\\n/* unused harmony export LIVE_ANNOUNCER_PROVIDER_FACTORY */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"E\", function() { return LIVE_ANNOUNCER_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_6\", function() { return isFakeMousedownFromScreenReader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"w\", function() { return FocusTrap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z\", function() { return FocusTrapFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return FocusTrapDeprecatedDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"y\", function() { return FocusTrapDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"B\", function() { return InteractivityChecker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"F\", function() { return ListKeyManager; });\\n/* unused harmony export ActiveDescendantKeyManager */\\n/* unused harmony export FocusKeyManager */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return Directionality; });\\n/* unused harmony export DIRECTIONALITY_PROVIDER_FACTORY */\\n/* unused harmony export DIRECTIONALITY_PROVIDER */\\n/* unused harmony export DIR_DOCUMENT */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return Dir; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return BidiModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Z\", function() { return coerceBooleanProperty; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_0\", function() { return coerceNumberProperty; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return CdkTableModule; });\\n/* unused harmony export DataSource */\\n/* unused harmony export getTableUnknownColumnError */\\n/* unused harmony export RowPlaceholder */\\n/* unused harmony export HeaderRowPlaceholder */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return CDK_TABLE_TEMPLATE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return CdkTable; });\\n/* unused harmony export CdkCellDef */\\n/* unused harmony export CdkHeaderCellDef */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return CdkColumnDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return CdkHeaderCell; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return CdkCell; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return CDK_ROW_TEMPLATE; });\\n/* unused harmony export BaseRowDef */\\n/* unused harmony export CdkHeaderRowDef */\\n/* unused harmony export CdkRowDef */\\n/* unused harmony export CdkCellOutlet */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return CdkHeaderRow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return CdkRow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"M\", function() { return PlatformModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"L\", function() { return Platform; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_5\", function() { return getSupportedInputTypes; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"N\", function() { return Portal; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return ComponentPortal; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"U\", function() { return TemplatePortal; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return BasePortalHost; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return DomPortalHost; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"V\", function() { return TemplatePortalDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"O\", function() { return PortalHostDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"P\", function() { return PortalModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R\", function() { return RxChain; });\\n/* unused harmony export FinallyBrand */\\n/* unused harmony export CatchBrand */\\n/* unused harmony export DoBrand */\\n/* unused harmony export MapBrand */\\n/* unused harmony export FilterBrand */\\n/* unused harmony export ShareBrand */\\n/* unused harmony export FirstBrand */\\n/* unused harmony export SwitchMapBrand */\\n/* unused harmony export StartWithBrand */\\n/* unused harmony export DebounceTimeBrand */\\n/* unused harmony export AuditTimeBrand */\\n/* unused harmony export TakeUntilBrand */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_3\", function() { return finallyOperator; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Y\", function() { return catchOperator; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_1\", function() { return doOperator; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_7\", function() { return map$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_2\", function() { return filter$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_8\", function() { return share$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_4\", function() { return first$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_10\", function() { return switchMap$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_9\", function() { return startWith$1; });\\n/* unused harmony export debounceTime */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"X\", function() { return auditTime$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_11\", function() { return takeUntil$1; });\\n/* unused harmony export MdMutationObserverFactory */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return ObserveContent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"I\", function() { return ObserveContentModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"W\", function() { return UP_ARROW; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return DOWN_ARROW; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Q\", function() { return RIGHT_ARROW; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"C\", function() { return LEFT_ARROW; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"K\", function() { return PAGE_UP; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"J\", function() { return PAGE_DOWN; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return HOME; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return END; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return ENTER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"S\", function() { return SPACE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"T\", function() { return TAB; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return ESCAPE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return BACKSPACE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return DELETE; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(37);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_operator_finally__ = __webpack_require__(295);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_operator_finally___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_operator_finally__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_operator_catch__ = __webpack_require__(178);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_operator_catch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_operator_catch__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_operator_do__ = __webpack_require__(294);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_operator_do___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_operator_do__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_operator_map__ = __webpack_require__(85);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_operator_map__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_operator_filter__ = __webpack_require__(130);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_operator_filter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_operator_filter__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_share__ = __webpack_require__(170);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_share___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_operator_share__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_first__ = __webpack_require__(177);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_first___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs_operator_first__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_switchMap__ = __webpack_require__(302);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_switchMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs_operator_switchMap__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_operator_startWith__ = __webpack_require__(298);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_operator_startWith___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_rxjs_operator_startWith__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_debounceTime__ = __webpack_require__(292);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_operator_debounceTime___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_rxjs_operator_debounceTime__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_auditTime__ = __webpack_require__(297);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_operator_auditTime___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs_operator_auditTime__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_takeUntil__ = __webpack_require__(303);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_takeUntil___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_rxjs_operator_takeUntil__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__angular_common__ = __webpack_require__(65);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_Subject__ = __webpack_require__(19);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_rxjs_Subject__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__angular_platform_browser__ = __webpack_require__(46);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_observable_merge__ = __webpack_require__(126);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_observable_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_rxjs_observable_merge__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_BehaviorSubject__ = __webpack_require__(86);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_BehaviorSubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_rxjs_BehaviorSubject__);\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Coerces a data-bound value (typically a string) to a boolean.\\n * @param {?} value\\n * @return {?}\\n */\\nfunction coerceBooleanProperty(value) {\\n    return value != null && \"\" + value !== \\'false\\';\\n}\\n// Whether the current platform supports the V8 Break Iterator. The V8 check\\n// is necessary to detect all Blink based browsers.\\nvar hasV8BreakIterator = (typeof (Intl) !== \\'undefined\\' && ((Intl)).v8BreakIterator);\\n/**\\n * Service to detect the current platform by comparing the userAgent strings and\\n * checking browser-specific global properties.\\n * \\\\@docs-private\\n */\\nvar Platform = /*@__PURE__*/(function () {\\n    function Platform() {\\n        this.isBrowser = typeof document === \\'object\\' && !!document;\\n        /**\\n         * Layout Engines\\n         */\\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\\n        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\\n        this.BLINK = this.isBrowser &&\\n            (!!(((window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\\n        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\\n        // ensure that Webkit runs standalone and is not used as another engine\\'s base.\\n        this.WEBKIT = this.isBrowser &&\\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\\n        /**\\n         * Browsers and Platform Types\\n         */\\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\\n        // It\\'s difficult to detect the plain Gecko engine, because most of the browsers identify\\n        // them self as Gecko-like browsers and modify the userAgent\\'s according to that.\\n        // Since we only cover one explicit Firefox case, we can simply check for Firefox\\n        // instead of having an unstable check for Gecko.\\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\\n        // Trident on mobile adds the android platform to the userAgent to trick detections.\\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\\n        // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\\n        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\\n        // Safari browser should also use Webkit as its layout engine.\\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\\n    }\\n    return Platform;\\n}());\\nPlatform.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nPlatform.ctorParameters = function () { return []; };\\n/**\\n * Utility for checking the interactivity of an element, such as whether is is focusable or\\n * tabbable.\\n */\\nvar InteractivityChecker = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _platform\\n     */\\n    function InteractivityChecker(_platform) {\\n        this._platform = _platform;\\n    }\\n    /**\\n     * Gets whether an element is disabled.\\n     *\\n     * @param {?} element Element to be checked.\\n     * @return {?} Whether the element is disabled.\\n     */\\n    InteractivityChecker.prototype.isDisabled = function (element) {\\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\\n        // a form control inside of a disabled form, but should capture the most common cases.\\n        return element.hasAttribute(\\'disabled\\');\\n    };\\n    /**\\n     * Gets whether an element is visible for the purposes of interactivity.\\n     *\\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\\n     *\\n     * @param {?} element\\n     * @return {?} Whether the element is visible.\\n     */\\n    InteractivityChecker.prototype.isVisible = function (element) {\\n        return hasGeometry(element) && getComputedStyle(element).visibility === \\'visible\\';\\n    };\\n    /**\\n     * Gets whether an element can be reached via Tab key.\\n     * Assumes that the element has already been checked with isFocusable.\\n     *\\n     * @param {?} element Element to be checked.\\n     * @return {?} Whether the element is tabbable.\\n     */\\n    InteractivityChecker.prototype.isTabbable = function (element) {\\n        // Nothing is tabbable on the the server 😎\\n        if (!this._platform.isBrowser) {\\n            return false;\\n        }\\n        var /** @type {?} */ frameElement = (getWindow(element).frameElement);\\n        if (frameElement) {\\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\\n            // Frame elements inherit their tabindex onto all child elements.\\n            if (getTabIndexValue(frameElement) === -1) {\\n                return false;\\n            }\\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === \\'object\\') {\\n                return false;\\n            }\\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\\n                return false;\\n            }\\n        }\\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\\n        if (element.hasAttribute(\\'contenteditable\\')) {\\n            return tabIndexValue !== -1;\\n        }\\n        if (nodeName === \\'iframe\\') {\\n            // The frames may be tabbable depending on content, but it\\'s not possibly to reliably\\n            // investigate the content of the frames.\\n            return false;\\n        }\\n        if (nodeName === \\'audio\\') {\\n            if (!element.hasAttribute(\\'controls\\')) {\\n                // By default an <audio> element without the controls enabled is not tabbable.\\n                return false;\\n            }\\n            else if (this._platform.BLINK) {\\n                // In Blink <audio controls> elements are always tabbable.\\n                return true;\\n            }\\n        }\\n        if (nodeName === \\'video\\') {\\n            if (!element.hasAttribute(\\'controls\\') && this._platform.TRIDENT) {\\n                // In Trident a <video> element without the controls enabled is not tabbable.\\n                return false;\\n            }\\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\\n                // In Chrome and Firefox <video controls> elements are always tabbable.\\n                return true;\\n            }\\n        }\\n        if (nodeName === \\'object\\' && (this._platform.BLINK || this._platform.WEBKIT)) {\\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\\n            return false;\\n        }\\n        // In iOS the browser only considers some specific elements as tabbable.\\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\\n            return false;\\n        }\\n        return element.tabIndex >= 0;\\n    };\\n    /**\\n     * Gets whether an element can be focused by the user.\\n     *\\n     * @param {?} element Element to be checked.\\n     * @return {?} Whether the element is focusable.\\n     */\\n    InteractivityChecker.prototype.isFocusable = function (element) {\\n        // Perform checks in order of left to most expensive.\\n        // Again, naive approach that does not capture many edge cases and browser quirks.\\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\\n    };\\n    return InteractivityChecker;\\n}());\\nInteractivityChecker.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nInteractivityChecker.ctorParameters = function () { return [\\n    { type: Platform, },\\n]; };\\n/**\\n * Checks whether the specified element has any geometry / rectangles.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction hasGeometry(element) {\\n    // Use logic from jQuery to check for an invisible element.\\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\\n    return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\\n}\\n/**\\n * Gets whether an element\\'s\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isNativeFormElement(element) {\\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\\n    return nodeName === \\'input\\' ||\\n        nodeName === \\'select\\' ||\\n        nodeName === \\'button\\' ||\\n        nodeName === \\'textarea\\';\\n}\\n/**\\n * Gets whether an element is an <input type=\"hidden\">.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isHiddenInput(element) {\\n    return isInputElement(element) && element.type == \\'hidden\\';\\n}\\n/**\\n * Gets whether an element is an anchor that has an href attribute.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isAnchorWithHref(element) {\\n    return isAnchorElement(element) && element.hasAttribute(\\'href\\');\\n}\\n/**\\n * Gets whether an element is an input element.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isInputElement(element) {\\n    return element.nodeName.toLowerCase() == \\'input\\';\\n}\\n/**\\n * Gets whether an element is an anchor element.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isAnchorElement(element) {\\n    return element.nodeName.toLowerCase() == \\'a\\';\\n}\\n/**\\n * Gets whether an element has a valid tabindex.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction hasValidTabIndex(element) {\\n    if (!element.hasAttribute(\\'tabindex\\') || element.tabIndex === undefined) {\\n        return false;\\n    }\\n    var /** @type {?} */ tabIndex = element.getAttribute(\\'tabindex\\');\\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\\n    if (tabIndex == \\'-32768\\') {\\n        return false;\\n    }\\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\\n}\\n/**\\n * Returns the parsed tabindex from the element attributes instead of returning the\\n * evaluated tabindex from the browsers defaults.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction getTabIndexValue(element) {\\n    if (!hasValidTabIndex(element)) {\\n        return null;\\n    }\\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute(\\'tabindex\\') || \\'\\', 10);\\n    return isNaN(tabIndex) ? -1 : tabIndex;\\n}\\n/**\\n * Checks whether the specified element is potentially tabbable on iOS\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isPotentiallyTabbableIOS(element) {\\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\\n    var /** @type {?} */ inputType = nodeName === \\'input\\' && ((element)).type;\\n    return inputType === \\'text\\'\\n        || inputType === \\'password\\'\\n        || nodeName === \\'select\\'\\n        || nodeName === \\'textarea\\';\\n}\\n/**\\n * Gets whether an element is potentially focusable without taking current visible/disabled state\\n * into account.\\n * @param {?} element\\n * @return {?}\\n */\\nfunction isPotentiallyFocusable(element) {\\n    // Inputs are potentially focusable *unless* they\\'re type=\"hidden\".\\n    if (isHiddenInput(element)) {\\n        return false;\\n    }\\n    return isNativeFormElement(element) ||\\n        isAnchorWithHref(element) ||\\n        element.hasAttribute(\\'contenteditable\\') ||\\n        hasValidTabIndex(element);\\n}\\n/**\\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\\n * @param {?} node\\n * @return {?}\\n */\\nfunction getWindow(node) {\\n    return node.ownerDocument.defaultView || window;\\n}\\n/**\\n * Utility class used to chain RxJS operators.\\n *\\n * This class is the concrete implementation, but the type used by the user when chaining\\n * is StrictRxChain. The strict chain enforces types on the operators to the same level as\\n * the prototype-added equivalents.\\n */\\nvar RxChain = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _context\\n     */\\n    function RxChain(_context) {\\n        this._context = _context;\\n    }\\n    /**\\n     * Starts a new chain and specifies the initial `this` value.\\n     * @template T\\n     * @param {?} context Initial `this` value for the chain.\\n     * @return {?}\\n     */\\n    RxChain.from = function (context) {\\n        return new RxChain(context);\\n    };\\n    /**\\n     * Invokes an RxJS operator as a part of the chain.\\n     * @param {?} operator Operator to be invoked.\\n     * @param {...?} args Arguments to be passed to the operator.\\n     * @return {?}\\n     */\\n    RxChain.prototype.call = function (operator) {\\n        var args = [];\\n        for (var _i = 1; _i < arguments.length; _i++) {\\n            args[_i - 1] = arguments[_i];\\n        }\\n        this._context = operator.call.apply(operator, [this._context].concat(args));\\n        return this;\\n    };\\n    /**\\n     * Subscribes to the result of the chain.\\n     * @param {?} fn Callback to be invoked when the result emits a value.\\n     * @return {?}\\n     */\\n    RxChain.prototype.subscribe = function (fn) {\\n        return this._context.subscribe(fn);\\n    };\\n    /**\\n     * Returns the result of the chain.\\n     * @return {?}\\n     */\\n    RxChain.prototype.result = function () {\\n        return this._context;\\n    };\\n    return RxChain;\\n}());\\nvar FinallyBrand = /*@__PURE__*/(function () {\\n    function FinallyBrand() {\\n    }\\n    return FinallyBrand;\\n}());\\nvar CatchBrand = /*@__PURE__*/(function () {\\n    function CatchBrand() {\\n    }\\n    return CatchBrand;\\n}());\\nvar DoBrand = /*@__PURE__*/(function () {\\n    function DoBrand() {\\n    }\\n    return DoBrand;\\n}());\\nvar MapBrand = /*@__PURE__*/(function () {\\n    function MapBrand() {\\n    }\\n    return MapBrand;\\n}());\\nvar FilterBrand = /*@__PURE__*/(function () {\\n    function FilterBrand() {\\n    }\\n    return FilterBrand;\\n}());\\nvar ShareBrand = /*@__PURE__*/(function () {\\n    function ShareBrand() {\\n    }\\n    return ShareBrand;\\n}());\\nvar FirstBrand = /*@__PURE__*/(function () {\\n    function FirstBrand() {\\n    }\\n    return FirstBrand;\\n}());\\nvar SwitchMapBrand = /*@__PURE__*/(function () {\\n    function SwitchMapBrand() {\\n    }\\n    return SwitchMapBrand;\\n}());\\nvar StartWithBrand = /*@__PURE__*/(function () {\\n    function StartWithBrand() {\\n    }\\n    return StartWithBrand;\\n}());\\nvar DebounceTimeBrand = /*@__PURE__*/(function () {\\n    function DebounceTimeBrand() {\\n    }\\n    return DebounceTimeBrand;\\n}());\\nvar AuditTimeBrand = /*@__PURE__*/(function () {\\n    function AuditTimeBrand() {\\n    }\\n    return AuditTimeBrand;\\n}());\\nvar TakeUntilBrand = /*@__PURE__*/(function () {\\n    function TakeUntilBrand() {\\n    }\\n    return TakeUntilBrand;\\n}());\\n// We add `Function` to the type intersection to make this nomically different from\\n// `finallyOperatorType` while still being structurally the same. Without this, TypeScript tries to\\n// reduce `typeof _finallyOperator & FinallyBrand` to `finallyOperatorType<T>` and then fails\\n// because `T` isn\\'t known.\\nvar finallyOperator = (__WEBPACK_IMPORTED_MODULE_2_rxjs_operator_finally__[\"_finally\"]);\\nvar catchOperator = (__WEBPACK_IMPORTED_MODULE_3_rxjs_operator_catch__[\"_catch\"]);\\nvar doOperator = (__WEBPACK_IMPORTED_MODULE_4_rxjs_operator_do__[\"_do\"]);\\nvar map$1 = (__WEBPACK_IMPORTED_MODULE_5_rxjs_operator_map__[\"map\"]);\\nvar filter$1 = (__WEBPACK_IMPORTED_MODULE_6_rxjs_operator_filter__[\"filter\"]);\\nvar share$1 = (__WEBPACK_IMPORTED_MODULE_7_rxjs_operator_share__[\"share\"]);\\nvar first$1 = (__WEBPACK_IMPORTED_MODULE_8_rxjs_operator_first__[\"first\"]);\\nvar switchMap$1 = (__WEBPACK_IMPORTED_MODULE_9_rxjs_operator_switchMap__[\"switchMap\"]);\\nvar startWith$1 = (__WEBPACK_IMPORTED_MODULE_10_rxjs_operator_startWith__[\"startWith\"]);\\nvar debounceTime$1 = (__WEBPACK_IMPORTED_MODULE_11_rxjs_operator_debounceTime__[\"debounceTime\"]);\\nvar auditTime$1 = (__WEBPACK_IMPORTED_MODULE_12_rxjs_operator_auditTime__[\"auditTime\"]);\\nvar takeUntil$1 = (__WEBPACK_IMPORTED_MODULE_13_rxjs_operator_takeUntil__[\"takeUntil\"]);\\n/**\\n * Class that allows for trapping focus within a DOM element.\\n *\\n * NOTE: This class currently uses a very simple (naive) approach to focus trapping.\\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\\n * This will be replaced with a more intelligent solution before the library is considered stable.\\n */\\nvar FocusTrap = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _element\\n     * @param {?} _platform\\n     * @param {?} _checker\\n     * @param {?} _ngZone\\n     * @param {?=} deferAnchors\\n     */\\n    function FocusTrap(_element, _platform, _checker, _ngZone, deferAnchors) {\\n        if (deferAnchors === void 0) { deferAnchors = false; }\\n        this._element = _element;\\n        this._platform = _platform;\\n        this._checker = _checker;\\n        this._ngZone = _ngZone;\\n        this._enabled = true;\\n        if (!deferAnchors) {\\n            this.attachAnchors();\\n        }\\n    }\\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\\n        /**\\n         * Whether the focus trap is active.\\n         * @return {?}\\n         */\\n        get: function () { return this._enabled; },\\n        /**\\n         * @param {?} val\\n         * @return {?}\\n         */\\n        set: function (val) {\\n            this._enabled = val;\\n            if (this._startAnchor && this._endAnchor) {\\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Destroys the focus trap by cleaning up the anchors.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.destroy = function () {\\n        if (this._startAnchor && this._startAnchor.parentNode) {\\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\\n        }\\n        if (this._endAnchor && this._endAnchor.parentNode) {\\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\\n        }\\n        this._startAnchor = this._endAnchor = null;\\n    };\\n    /**\\n     * Inserts the anchors into the DOM. This is usually done automatically\\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.attachAnchors = function () {\\n        var _this = this;\\n        // If we\\'re not on the browser, there can be no focus to trap.\\n        if (!this._platform.isBrowser) {\\n            return;\\n        }\\n        if (!this._startAnchor) {\\n            this._startAnchor = this._createAnchor();\\n        }\\n        if (!this._endAnchor) {\\n            this._endAnchor = this._createAnchor();\\n        }\\n        this._ngZone.runOutsideAngular(function () {\\n            ((_this._startAnchor)).addEventListener(\\'focus\\', function () { return _this.focusLastTabbableElement(); }); /** @type {?} */\\n            ((_this._endAnchor)).addEventListener(\\'focus\\', function () { return _this.focusFirstTabbableElement(); });\\n            if (_this._element.parentNode) {\\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\\n            }\\n        });\\n    };\\n    /**\\n     * Waits for the zone to stabilize, then either focuses the first element that the\\n     * user specified, or the first tabbable element..\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusInitialElementWhenReady = function () {\\n        var _this = this;\\n        this._executeOnStable(function () { return _this.focusInitialElement(); });\\n    };\\n    /**\\n     * Waits for the zone to stabilize, then focuses\\n     * the first tabbable element within the focus trap region.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = function () {\\n        var _this = this;\\n        this._executeOnStable(function () { return _this.focusFirstTabbableElement(); });\\n    };\\n    /**\\n     * Waits for the zone to stabilize, then focuses\\n     * the last tabbable element within the focus trap region.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = function () {\\n        var _this = this;\\n        this._executeOnStable(function () { return _this.focusLastTabbableElement(); });\\n    };\\n    /**\\n     * Get the specified boundary element of the trapped region.\\n     * @param {?} bound The boundary to get (start or end of trapped region).\\n     * @return {?} The boundary element.\\n     */\\n    FocusTrap.prototype._getRegionBoundary = function (bound) {\\n        // Contains the deprecated version of selector, for temporary backwards comparability.\\n        var /** @type {?} */ markers = (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\\n            (\"[cdk-focus-\" + bound + \"]\")));\\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\\n                console.warn(\"Found use of deprecated attribute \\'cdk-focus-\" + bound + \"\\',\" +\\n                    (\" use \\'cdk-focus-region-\" + bound + \"\\' instead.\"), markers[i]);\\n            }\\n        }\\n        if (bound == \\'start\\') {\\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\\n        }\\n        return markers.length ?\\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\\n    };\\n    /**\\n     * Focuses the element that should be focused when the focus trap is initialized.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusInitialElement = function () {\\n        var /** @type {?} */ redirectToElement = (this._element.querySelector(\\'[cdk-focus-initial]\\'));\\n        if (redirectToElement) {\\n            redirectToElement.focus();\\n        }\\n        else {\\n            this.focusFirstTabbableElement();\\n        }\\n    };\\n    /**\\n     * Focuses the first tabbable element within the focus trap region.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusFirstTabbableElement = function () {\\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary(\\'start\\');\\n        if (redirectToElement) {\\n            redirectToElement.focus();\\n        }\\n    };\\n    /**\\n     * Focuses the last tabbable element within the focus trap region.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype.focusLastTabbableElement = function () {\\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary(\\'end\\');\\n        if (redirectToElement) {\\n            redirectToElement.focus();\\n        }\\n    };\\n    /**\\n     * Get the first tabbable element from a DOM subtree (inclusive).\\n     * @param {?} root\\n     * @return {?}\\n     */\\n    FocusTrap.prototype._getFirstTabbableElement = function (root) {\\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\\n            return root;\\n        }\\n        // Iterate in DOM order. Note that IE doesn\\'t have `children` for SVG so we fall\\n        // back to `childNodes` which includes text nodes, comments etc.\\n        var /** @type {?} */ children = root.children || root.childNodes;\\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\\n                null;\\n            if (tabbableChild) {\\n                return tabbableChild;\\n            }\\n        }\\n        return null;\\n    };\\n    /**\\n     * Get the last tabbable element from a DOM subtree (inclusive).\\n     * @param {?} root\\n     * @return {?}\\n     */\\n    FocusTrap.prototype._getLastTabbableElement = function (root) {\\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\\n            return root;\\n        }\\n        // Iterate in reverse DOM order.\\n        var /** @type {?} */ children = root.children || root.childNodes;\\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\\n            var /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\\n                null;\\n            if (tabbableChild) {\\n                return tabbableChild;\\n            }\\n        }\\n        return null;\\n    };\\n    /**\\n     * Creates an anchor element.\\n     * @return {?}\\n     */\\n    FocusTrap.prototype._createAnchor = function () {\\n        var /** @type {?} */ anchor = document.createElement(\\'div\\');\\n        anchor.tabIndex = this._enabled ? 0 : -1;\\n        anchor.classList.add(\\'cdk-visually-hidden\\');\\n        anchor.classList.add(\\'cdk-focus-trap-anchor\\');\\n        return anchor;\\n    };\\n    /**\\n     * Executes a function when the zone is stable.\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    FocusTrap.prototype._executeOnStable = function (fn) {\\n        if (this._ngZone.isStable) {\\n            fn();\\n        }\\n        else {\\n            first$1.call(this._ngZone.onStable).subscribe(fn);\\n        }\\n    };\\n    return FocusTrap;\\n}());\\n/**\\n * Factory that allows easy instantiation of focus traps.\\n */\\nvar FocusTrapFactory = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _checker\\n     * @param {?} _platform\\n     * @param {?} _ngZone\\n     */\\n    function FocusTrapFactory(_checker, _platform, _ngZone) {\\n        this._checker = _checker;\\n        this._platform = _platform;\\n        this._ngZone = _ngZone;\\n    }\\n    /**\\n     * @param {?} element\\n     * @param {?=} deferAnchors\\n     * @return {?}\\n     */\\n    FocusTrapFactory.prototype.create = function (element, deferAnchors) {\\n        if (deferAnchors === void 0) { deferAnchors = false; }\\n        return new FocusTrap(element, this._platform, this._checker, this._ngZone, deferAnchors);\\n    };\\n    return FocusTrapFactory;\\n}());\\nFocusTrapFactory.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nFocusTrapFactory.ctorParameters = function () { return [\\n    { type: InteractivityChecker, },\\n    { type: Platform, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgZone\"], },\\n]; };\\n/**\\n * Directive for trapping focus within a region.\\n * @deprecated\\n */\\nvar FocusTrapDeprecatedDirective = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _focusTrapFactory\\n     */\\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\\n        this._elementRef = _elementRef;\\n        this._focusTrapFactory = _focusTrapFactory;\\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\\n    }\\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\\n        /**\\n         * Whether the focus trap is active.\\n         * @return {?}\\n         */\\n        get: function () { return !this.focusTrap.enabled; },\\n        /**\\n         * @param {?} val\\n         * @return {?}\\n         */\\n        set: function (val) {\\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = function () {\\n        this.focusTrap.destroy();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = function () {\\n        this.focusTrap.attachAnchors();\\n    };\\n    return FocusTrapDeprecatedDirective;\\n}());\\nFocusTrapDeprecatedDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'cdk-focus-trap\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nFocusTrapDeprecatedDirective.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusTrapFactory, },\\n]; };\\nFocusTrapDeprecatedDirective.propDecorators = {\\n    \\'disabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\n/**\\n * Directive for trapping focus within a region.\\n */\\nvar FocusTrapDirective = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _elementRef\\n     * @param {?} _focusTrapFactory\\n     */\\n    function FocusTrapDirective(_elementRef, _focusTrapFactory) {\\n        this._elementRef = _elementRef;\\n        this._focusTrapFactory = _focusTrapFactory;\\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\\n    }\\n    Object.defineProperty(FocusTrapDirective.prototype, \"enabled\", {\\n        /**\\n         * Whether the focus trap is active.\\n         * @return {?}\\n         */\\n        get: function () { return this.focusTrap.enabled; },\\n        /**\\n         * @param {?} value\\n         * @return {?}\\n         */\\n        set: function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    FocusTrapDirective.prototype.ngOnDestroy = function () {\\n        this.focusTrap.destroy();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    FocusTrapDirective.prototype.ngAfterContentInit = function () {\\n        this.focusTrap.attachAnchors();\\n    };\\n    return FocusTrapDirective;\\n}());\\nFocusTrapDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdkTrapFocus]\\',\\n                exportAs: \\'cdkTrapFocus\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nFocusTrapDirective.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: FocusTrapFactory, },\\n]; };\\nFocusTrapDirective.propDecorators = {\\n    \\'enabled\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'cdkTrapFocus\\',] },],\\n};\\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'liveAnnouncerElement\\');\\nvar LiveAnnouncer = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} elementToken\\n     * @param {?} platform\\n     */\\n    function LiveAnnouncer(elementToken, platform) {\\n        // Only do anything if we\\'re on the browser platform.\\n        if (platform.isBrowser) {\\n            // We inject the live element as `any` because the constructor signature cannot reference\\n            // browser globals (HTMLElement) on non-browser environments, since having a class decorator\\n            // causes TypeScript to preserve the constructor signature types.\\n            this._liveElement = elementToken || this._createLiveElement();\\n        }\\n    }\\n    /**\\n     * Announces a message to screenreaders.\\n     * @param {?} message Message to be announced to the screenreader\\n     * @param {?=} politeness The politeness of the announcer element\\n     * @return {?}\\n     */\\n    LiveAnnouncer.prototype.announce = function (message, politeness) {\\n        var _this = this;\\n        if (politeness === void 0) { politeness = \\'polite\\'; }\\n        this._liveElement.textContent = \\'\\';\\n        // TODO: ensure changing the politeness works on all environments we support.\\n        this._liveElement.setAttribute(\\'aria-live\\', politeness);\\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won\\'t be read a\\n        //   second time without clearing and then using a non-zero delay.\\n        // (using JAWS 17 at time of this writing).\\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\\n    };\\n    /**\\n     * Removes the aria-live element from the DOM.\\n     * @return {?}\\n     */\\n    LiveAnnouncer.prototype._removeLiveElement = function () {\\n        if (this._liveElement && this._liveElement.parentNode) {\\n            this._liveElement.parentNode.removeChild(this._liveElement);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    LiveAnnouncer.prototype._createLiveElement = function () {\\n        var /** @type {?} */ liveEl = document.createElement(\\'div\\');\\n        liveEl.classList.add(\\'cdk-visually-hidden\\');\\n        liveEl.setAttribute(\\'aria-atomic\\', \\'true\\');\\n        liveEl.setAttribute(\\'aria-live\\', \\'polite\\');\\n        document.body.appendChild(liveEl);\\n        return liveEl;\\n    };\\n    return LiveAnnouncer;\\n}());\\nLiveAnnouncer.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nLiveAnnouncer.ctorParameters = function () { return [\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\\n    { type: Platform, },\\n]; };\\n/**\\n * @param {?} parentDispatcher\\n * @param {?} liveElement\\n * @param {?} platform\\n * @return {?}\\n */\\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, platform) {\\n    return parentDispatcher || new LiveAnnouncer(liveElement, platform);\\n}\\nvar LIVE_ANNOUNCER_PROVIDER = {\\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\\n    provide: LiveAnnouncer,\\n    deps: [\\n        [new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), LiveAnnouncer],\\n        [new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"](LIVE_ANNOUNCER_ELEMENT_TOKEN)],\\n        Platform,\\n    ],\\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\\n};\\n/**\\n * Cached result Set of input types support by the current browser.\\n */\\nvar supportedInputTypes;\\n/**\\n * Types of <input> that *might* be supported.\\n */\\nvar candidateInputTypes = [\\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\\n    // first changing it to something else:\\n    // The specified value \"\" does not conform to the required format.\\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\\n    \\'color\\',\\n    \\'button\\',\\n    \\'checkbox\\',\\n    \\'date\\',\\n    \\'datetime-local\\',\\n    \\'email\\',\\n    \\'file\\',\\n    \\'hidden\\',\\n    \\'image\\',\\n    \\'month\\',\\n    \\'number\\',\\n    \\'password\\',\\n    \\'radio\\',\\n    \\'range\\',\\n    \\'reset\\',\\n    \\'search\\',\\n    \\'submit\\',\\n    \\'tel\\',\\n    \\'text\\',\\n    \\'time\\',\\n    \\'url\\',\\n    \\'week\\',\\n];\\n/**\\n * @return {?} The input types supported by this browser.\\n */\\nfunction getSupportedInputTypes() {\\n    // Result is cached.\\n    if (supportedInputTypes) {\\n        return supportedInputTypes;\\n    }\\n    // We can\\'t check if an input type is not supported until we\\'re on the browser, so say that\\n    // everything is supported when not on the browser. We don\\'t use `Platform` here since it\\'s\\n    // just a helper function and can\\'t inject it.\\n    if (typeof document !== \\'object\\' || !document) {\\n        supportedInputTypes = new Set(candidateInputTypes);\\n        return supportedInputTypes;\\n    }\\n    var /** @type {?} */ featureTestInput = document.createElement(\\'input\\');\\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\\n        featureTestInput.setAttribute(\\'type\\', value);\\n        return featureTestInput.type === value;\\n    }));\\n    return supportedInputTypes;\\n}\\nvar PlatformModule = /*@__PURE__*/(function () {\\n    function PlatformModule() {\\n    }\\n    return PlatformModule;\\n}());\\nPlatformModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                providers: [Platform]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nPlatformModule.ctorParameters = function () { return []; };\\n/**\\n * Screenreaders will often fire fake mousedown events when a focusable element\\n * is activated using the keyboard. We can typically distinguish between these faked\\n * mousedown events and real mousedown events using the \"buttons\" property. While\\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\\n * the left mouse button), faked mousedowns will usually set the property value to 0.\\n * @param {?} event\\n * @return {?}\\n */\\nfunction isFakeMousedownFromScreenReader(event) {\\n    return event.buttons === 0;\\n}\\nvar UP_ARROW = 38;\\nvar DOWN_ARROW = 40;\\nvar RIGHT_ARROW = 39;\\nvar LEFT_ARROW = 37;\\nvar PAGE_UP = 33;\\nvar PAGE_DOWN = 34;\\nvar HOME = 36;\\nvar END = 35;\\nvar ENTER = 13;\\nvar SPACE = 32;\\nvar TAB = 9;\\nvar ESCAPE = 27;\\nvar BACKSPACE = 8;\\nvar DELETE = 46;\\n/**\\n * This class manages keyboard events for selectable lists. If you pass it a query list\\n * of items, it will set the active item correctly when arrow events occur.\\n */\\nvar ListKeyManager = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _items\\n     */\\n    function ListKeyManager(_items) {\\n        this._items = _items;\\n        this._activeItemIndex = -1;\\n        this._tabOut = new __WEBPACK_IMPORTED_MODULE_15_rxjs_Subject__[\"Subject\"]();\\n        this._wrap = false;\\n    }\\n    /**\\n     * Turns on wrapping mode, which ensures that the active item will wrap to\\n     * the other end of list when there are no more items in the given direction.\\n     *\\n     * @return {?} The ListKeyManager that the method was called on.\\n     */\\n    ListKeyManager.prototype.withWrap = function () {\\n        this._wrap = true;\\n        return this;\\n    };\\n    /**\\n     * Sets the active item to the item at the index specified.\\n     *\\n     * @param {?} index The index of the item to be set as active.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.setActiveItem = function (index) {\\n        this._activeItemIndex = index;\\n        this._activeItem = this._items.toArray()[index];\\n    };\\n    /**\\n     * Sets the active item depending on the key event passed in.\\n     * @param {?} event Keyboard event to be used for determining which element should be active.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.onKeydown = function (event) {\\n        switch (event.keyCode) {\\n            case DOWN_ARROW:\\n                this.setNextItemActive();\\n                break;\\n            case UP_ARROW:\\n                this.setPreviousItemActive();\\n                break;\\n            case TAB:\\n                // Note that we shouldn\\'t prevent the default action on tab.\\n                this._tabOut.next();\\n                return;\\n            default:\\n                return;\\n        }\\n        event.preventDefault();\\n    };\\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\\n        /**\\n         * Index of the currently active item.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._activeItemIndex;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\\n        /**\\n         * The active item.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._activeItem;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the active item to the first enabled item in the list.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.setFirstItemActive = function () {\\n        this._setActiveItemByIndex(0, 1);\\n    };\\n    /**\\n     * Sets the active item to the last enabled item in the list.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.setLastItemActive = function () {\\n        this._setActiveItemByIndex(this._items.length - 1, -1);\\n    };\\n    /**\\n     * Sets the active item to the next enabled item in the list.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.setNextItemActive = function () {\\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\\n    };\\n    /**\\n     * Sets the active item to a previous enabled item in the list.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.setPreviousItemActive = function () {\\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\\n            : this._setActiveItemByDelta(-1);\\n    };\\n    /**\\n     * Allows setting of the activeItemIndex without any other effects.\\n     * @param {?} index The new activeItemIndex.\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype.updateActiveItemIndex = function (index) {\\n        this._activeItemIndex = index;\\n    };\\n    Object.defineProperty(ListKeyManager.prototype, \"tabOut\", {\\n        /**\\n         * Observable that emits any time the TAB key is pressed, so components can react\\n         * when focus is shifted off of the list.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._tabOut.asObservable();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * This method sets the active item, given a list of items and the delta between the\\n     * currently active item and the new active item. It will calculate differently\\n     * depending on whether wrap mode is turned on.\\n     * @param {?} delta\\n     * @param {?=} items\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype._setActiveItemByDelta = function (delta, items) {\\n        if (items === void 0) { items = this._items.toArray(); }\\n        this._wrap ? this._setActiveInWrapMode(delta, items)\\n            : this._setActiveInDefaultMode(delta, items);\\n    };\\n    /**\\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\\n     * down the list until it finds an item that is not disabled, and it will wrap if it\\n     * encounters either end of the list.\\n     * @param {?} delta\\n     * @param {?} items\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype._setActiveInWrapMode = function (delta, items) {\\n        // when active item would leave menu, wrap to beginning or end\\n        this._activeItemIndex =\\n            (this._activeItemIndex + delta + items.length) % items.length;\\n        // skip all disabled menu items recursively until an enabled one is reached\\n        if (items[this._activeItemIndex].disabled) {\\n            this._setActiveInWrapMode(delta, items);\\n        }\\n        else {\\n            this.setActiveItem(this._activeItemIndex);\\n        }\\n    };\\n    /**\\n     * Sets the active item properly given the default mode. In other words, it will\\n     * continue to move down the list until it finds an item that is not disabled. If\\n     * it encounters either end of the list, it will stop and not wrap.\\n     * @param {?} delta\\n     * @param {?} items\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype._setActiveInDefaultMode = function (delta, items) {\\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\\n    };\\n    /**\\n     * Sets the active item to the first enabled item starting at the index specified. If the\\n     * item is disabled, it will move in the fallbackDelta direction until it either\\n     * finds an enabled item or encounters the end of the list.\\n     * @param {?} index\\n     * @param {?} fallbackDelta\\n     * @param {?=} items\\n     * @return {?}\\n     */\\n    ListKeyManager.prototype._setActiveItemByIndex = function (index, fallbackDelta, items) {\\n        if (items === void 0) { items = this._items.toArray(); }\\n        if (!items[index]) {\\n            return;\\n        }\\n        while (items[index].disabled) {\\n            index += fallbackDelta;\\n            if (!items[index]) {\\n                return;\\n            }\\n        }\\n        this.setActiveItem(index);\\n    };\\n    return ListKeyManager;\\n}());\\nvar ActiveDescendantKeyManager = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ActiveDescendantKeyManager, _super);\\n    function ActiveDescendantKeyManager() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    /**\\n     * This method sets the active item to the item at the specified index.\\n     * It also adds active styles to the newly active item and removes active\\n     * styles from the previously active item.\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    ActiveDescendantKeyManager.prototype.setActiveItem = function (index) {\\n        var _this = this;\\n        Promise.resolve().then(function () {\\n            if (_this.activeItem) {\\n                _this.activeItem.setInactiveStyles();\\n            }\\n            _super.prototype.setActiveItem.call(_this, index);\\n            if (_this.activeItem) {\\n                _this.activeItem.setActiveStyles();\\n            }\\n        });\\n    };\\n    return ActiveDescendantKeyManager;\\n}(ListKeyManager));\\nvar FocusKeyManager = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](FocusKeyManager, _super);\\n    /**\\n     * @param {?} items\\n     */\\n    function FocusKeyManager(items) {\\n        return _super.call(this, items) || this;\\n    }\\n    /**\\n     * This method sets the active item to the item at the specified index.\\n     * It also adds focuses the newly active item.\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    FocusKeyManager.prototype.setActiveItem = function (index) {\\n        _super.prototype.setActiveItem.call(this, index);\\n        if (this.activeItem) {\\n            this.activeItem.focus();\\n        }\\n    };\\n    return FocusKeyManager;\\n}(ListKeyManager));\\nvar A11yModule = /*@__PURE__*/(function () {\\n    function A11yModule() {\\n    }\\n    return A11yModule;\\n}());\\nA11yModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_14__angular_common__[\"CommonModule\"], PlatformModule],\\n                declarations: [FocusTrapDirective, FocusTrapDeprecatedDirective],\\n                exports: [FocusTrapDirective, FocusTrapDeprecatedDirective],\\n                providers: [InteractivityChecker, FocusTrapFactory, LIVE_ANNOUNCER_PROVIDER]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nA11yModule.ctorParameters = function () { return []; };\\n/**\\n * Injection token used to inject the document into Directionality.\\n * This is used so that the value can be faked in tests.\\n *\\n * We can\\'t use the real document in tests because changing the real `dir` causes geometry-based\\n * tests in Safari to fail.\\n *\\n * We also can\\'t re-provide the DOCUMENT token from platform-brower because the unit tests\\n * themselves use things like `querySelector` in test code.\\n */\\nvar DIR_DOCUMENT = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"InjectionToken\"](\\'md-dir-doc\\');\\n/**\\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\\n * Exposes the current direction and a stream of direction changes.\\n */\\nvar Directionality = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?=} _document\\n     */\\n    function Directionality(_document) {\\n        this.value = \\'ltr\\';\\n        this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        if (_document) {\\n            // TODO: handle \\'auto\\' value -\\n            // We still need to account for dir=\"auto\".\\n            // It looks like HTMLElemenet.dir is also \"auto\" when that\\'s set to the attribute,\\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\\n            var bodyDir = _document.body ? _document.body.dir : null;\\n            var htmlDir = _document.documentElement ? _document.documentElement.dir : null;\\n            this.value = (bodyDir || htmlDir || \\'ltr\\');\\n        }\\n    }\\n    return Directionality;\\n}());\\nDirectionality.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nDirectionality.ctorParameters = function () { return [\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"], args: [DIR_DOCUMENT,] },] },\\n]; };\\n/**\\n * @param {?} parentDirectionality\\n * @param {?} _document\\n * @return {?}\\n */\\nfunction DIRECTIONALITY_PROVIDER_FACTORY(parentDirectionality, _document) {\\n    return parentDirectionality || new Directionality(_document);\\n}\\nvar DIRECTIONALITY_PROVIDER = {\\n    // If there is already a Directionality available, use that. Otherwise, provide a new one.\\n    provide: Directionality,\\n    deps: [[new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"SkipSelf\"](), Directionality], [new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Optional\"](), __WEBPACK_IMPORTED_MODULE_16__angular_platform_browser__[\"DOCUMENT\"]]],\\n    useFactory: DIRECTIONALITY_PROVIDER_FACTORY\\n};\\n/**\\n * Directive to listen for changes of direction of part of the DOM.\\n *\\n * Would provide itself in case a component looks for the Directionality service\\n */\\nvar Dir = /*@__PURE__*/(function () {\\n    function Dir() {\\n        /**\\n         * Layout direction of the element.\\n         */\\n        this._dir = \\'ltr\\';\\n        /**\\n         * Whether the `value` has been set to its initial value.\\n         */\\n        this._isInitialized = false;\\n        /**\\n         * Event emitted when the direction changes.\\n         */\\n        this.change = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n    }\\n    Object.defineProperty(Dir.prototype, \"dir\", {\\n        /**\\n         * \\\\@docs-private\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._dir;\\n        },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) {\\n            var /** @type {?} */ old = this._dir;\\n            this._dir = v;\\n            if (old !== this._dir && this._isInitialized) {\\n                this.change.emit();\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(Dir.prototype, \"value\", {\\n        /**\\n         * Current layout direction of the element.\\n         * @return {?}\\n         */\\n        get: function () { return this.dir; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.dir = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Initialize once default value has been set.\\n     * @return {?}\\n     */\\n    Dir.prototype.ngAfterContentInit = function () {\\n        this._isInitialized = true;\\n    };\\n    return Dir;\\n}());\\nDir.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[dir]\\',\\n                // TODO(hansl): maybe `$implicit` isn\\'t the best option here, but for now that\\'s the best we got.\\n                exportAs: \\'$implicit\\',\\n                providers: [\\n                    { provide: Directionality, useExisting: Dir }\\n                ]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nDir.ctorParameters = function () { return []; };\\nDir.propDecorators = {\\n    \\'change\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'dirChange\\',] },],\\n    \\'dir\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"HostBinding\"], args: [\\'attr.dir\\',] }, { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'dir\\',] },],\\n};\\nvar BidiModule = /*@__PURE__*/(function () {\\n    function BidiModule() {\\n    }\\n    return BidiModule;\\n}());\\nBidiModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                exports: [Dir],\\n                declarations: [Dir],\\n                providers: [\\n                    { provide: DIR_DOCUMENT, useExisting: __WEBPACK_IMPORTED_MODULE_16__angular_platform_browser__[\"DOCUMENT\"] },\\n                    Directionality,\\n                ]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nBidiModule.ctorParameters = function () { return []; };\\n/**\\n * Coerces a data-bound value (typically a string) to a number.\\n * @param {?} value\\n * @param {?=} fallbackValue\\n * @return {?}\\n */\\nfunction coerceNumberProperty(value, fallbackValue) {\\n    if (fallbackValue === void 0) { fallbackValue = 0; }\\n    // parseFloat(value) handles most of the cases we\\'re interested in (it treats null, empty string,\\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\\n    // \\'123hello\\' to be a valid number. Therefore we also check if Number(value) is NaN.\\n    return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);\\n}\\n/**\\n * The row template that can be used by the md-table. Should not be used outside of the\\n * material library.\\n */\\nvar CDK_ROW_TEMPLATE = \"<ng-container cdkCellOutlet></ng-container>\";\\n/**\\n * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs\\n * for changes and notifying the table.\\n * @abstract\\n */\\nvar BaseRowDef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} template\\n     * @param {?} _differs\\n     */\\n    function BaseRowDef(template, _differs) {\\n        this.template = template;\\n        this._differs = _differs;\\n        /**\\n         * Event stream that emits when changes are made to the columns.\\n         */\\n        this.columnsChange = new __WEBPACK_IMPORTED_MODULE_15_rxjs_Subject__[\"Subject\"]();\\n        this.viewInitialized = false;\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    BaseRowDef.prototype.ngAfterViewInit = function () {\\n        this.viewInitialized = true;\\n    };\\n    /**\\n     * @param {?} changes\\n     * @return {?}\\n     */\\n    BaseRowDef.prototype.ngOnChanges = function (changes) {\\n        // Create a new columns differ if one does not yet exist. Initialize it based on initial value\\n        // of the columns property.\\n        if (!this._columnsDiffer && changes[\\'columns\\'].currentValue) {\\n            this._columnsDiffer = this._differs.find(changes[\\'columns\\'].currentValue).create();\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    BaseRowDef.prototype.ngDoCheck = function () {\\n        if (!this.viewInitialized || !this._columnsDiffer || !this.columns) {\\n            return;\\n        }\\n        // Notify the table if there are any changes to the columns.\\n        var /** @type {?} */ changes = this._columnsDiffer.diff(this.columns);\\n        if (changes) {\\n            this.columnsChange.next();\\n        }\\n    };\\n    return BaseRowDef;\\n}());\\n/**\\n * Header row definition for the CDK table.\\n * Captures the header row\\'s template and other header properties such as the columns to display.\\n */\\nvar CdkHeaderRowDef = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CdkHeaderRowDef, _super);\\n    /**\\n     * @param {?} template\\n     * @param {?} _differs\\n     */\\n    function CdkHeaderRowDef(template, _differs) {\\n        return _super.call(this, template, _differs) || this;\\n    }\\n    return CdkHeaderRowDef;\\n}(BaseRowDef));\\nCdkHeaderRowDef.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdkHeaderRowDef]\\',\\n                inputs: [\\'columns: cdkHeaderRowDef\\'],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkHeaderRowDef.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"IterableDiffers\"], },\\n]; };\\n/**\\n * Data row definition for the CDK table.\\n * Captures the header row\\'s template and other row properties such as the columns to display.\\n */\\nvar CdkRowDef = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](CdkRowDef, _super);\\n    /**\\n     * @param {?} template\\n     * @param {?} _differs\\n     */\\n    function CdkRowDef(template, _differs) {\\n        return _super.call(this, template, _differs) || this;\\n    }\\n    return CdkRowDef;\\n}(BaseRowDef));\\nCdkRowDef.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdkRowDef]\\',\\n                inputs: [\\'columns: cdkRowDefColumns\\'],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkRowDef.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"IterableDiffers\"], },\\n]; };\\n/**\\n * Outlet for rendering cells inside of a row or header row.\\n * \\\\@docs-private\\n */\\nvar CdkCellOutlet = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _viewContainer\\n     */\\n    function CdkCellOutlet(_viewContainer) {\\n        this._viewContainer = _viewContainer;\\n        CdkCellOutlet.mostRecentCellOutlet = this;\\n    }\\n    return CdkCellOutlet;\\n}());\\nCdkCellOutlet.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: \\'[cdkCellOutlet]\\' },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkCellOutlet.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\n/**\\n * Header template container that contains the cell outlet. Adds the right class and role.\\n */\\nvar CdkHeaderRow = /*@__PURE__*/(function () {\\n    function CdkHeaderRow() {\\n    }\\n    return CdkHeaderRow;\\n}());\\nCdkHeaderRow.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{\\n                selector: \\'cdk-header-row\\',\\n                template: CDK_ROW_TEMPLATE,\\n                host: {\\n                    \\'class\\': \\'cdk-header-row\\',\\n                    \\'role\\': \\'row\\',\\n                },\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkHeaderRow.ctorParameters = function () { return []; };\\n/**\\n * Data row template container that contains the cell outlet. Adds the right class and role.\\n */\\nvar CdkRow = /*@__PURE__*/(function () {\\n    function CdkRow() {\\n    }\\n    return CdkRow;\\n}());\\nCdkRow.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{\\n                selector: \\'cdk-row\\',\\n                template: CDK_ROW_TEMPLATE,\\n                host: {\\n                    \\'class\\': \\'cdk-row\\',\\n                    \\'role\\': \\'row\\',\\n                },\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkRow.ctorParameters = function () { return []; };\\n/**\\n * Cell definition for a CDK table.\\n * Captures the template of a column\\'s data row cell as well as cell-specific properties.\\n */\\nvar CdkCellDef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} template\\n     */\\n    function CdkCellDef(template) {\\n        this.template = template;\\n    }\\n    return CdkCellDef;\\n}());\\nCdkCellDef.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: \\'[cdkCellDef]\\' },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkCellDef.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"], },\\n]; };\\n/**\\n * Header cell definition for a CDK table.\\n * Captures the template of a column\\'s header cell and as well as cell-specific properties.\\n */\\nvar CdkHeaderCellDef = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} template\\n     */\\n    function CdkHeaderCellDef(template) {\\n        this.template = template;\\n    }\\n    return CdkHeaderCellDef;\\n}());\\nCdkHeaderCellDef.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: \\'[cdkHeaderCellDef]\\' },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkHeaderCellDef.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"], },\\n]; };\\n/**\\n * Column definition for the CDK table.\\n * Defines a set of cells available for a table column.\\n */\\nvar CdkColumnDef = /*@__PURE__*/(function () {\\n    function CdkColumnDef() {\\n    }\\n    return CdkColumnDef;\\n}());\\nCdkColumnDef.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: \\'[cdkColumnDef]\\' },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkColumnDef.ctorParameters = function () { return []; };\\nCdkColumnDef.propDecorators = {\\n    \\'name\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'cdkColumnDef\\',] },],\\n    \\'cell\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [CdkCellDef,] },],\\n    \\'headerCell\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [CdkHeaderCellDef,] },],\\n};\\n/**\\n * Header cell template container that adds the right classes and role.\\n */\\nvar CdkHeaderCell = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} columnDef\\n     * @param {?} elementRef\\n     * @param {?} renderer\\n     */\\n    function CdkHeaderCell(columnDef, elementRef, renderer) {\\n        this.columnDef = columnDef;\\n        this.elementRef = elementRef;\\n        this.renderer = renderer;\\n        this.renderer.addClass(elementRef.nativeElement, \"cdk-column-\" + columnDef.name);\\n    }\\n    return CdkHeaderCell;\\n}());\\nCdkHeaderCell.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'cdk-header-cell\\',\\n                host: {\\n                    \\'class\\': \\'cdk-header-cell\\',\\n                    \\'role\\': \\'columnheader\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkHeaderCell.ctorParameters = function () { return [\\n    { type: CdkColumnDef, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\n/**\\n * Cell template container that adds the right classes and role.\\n */\\nvar CdkCell = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} columnDef\\n     * @param {?} elementRef\\n     * @param {?} renderer\\n     */\\n    function CdkCell(columnDef, elementRef, renderer) {\\n        this.columnDef = columnDef;\\n        this.elementRef = elementRef;\\n        this.renderer = renderer;\\n        this.renderer.addClass(elementRef.nativeElement, \"cdk-column-\" + columnDef.name);\\n    }\\n    return CdkCell;\\n}());\\nCdkCell.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'cdk-cell\\',\\n                host: {\\n                    \\'class\\': \\'cdk-cell\\',\\n                    \\'role\\': \\'gridcell\\',\\n                },\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkCell.ctorParameters = function () { return [\\n    { type: CdkColumnDef, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n]; };\\n/**\\n * Returns an error to be thrown when attempting to find an unexisting column.\\n * \\\\@docs-private\\n * @param {?} id Id whose lookup failed.\\n * @return {?}\\n */\\nfunction getTableUnknownColumnError(id) {\\n    return new Error(\"cdk-table: Could not find column with id \\\\\"\" + id + \"\\\\\".\");\\n}\\n/**\\n * Provides a handle for the table to grab the view container\\'s ng-container to insert data rows.\\n * \\\\@docs-private\\n */\\nvar RowPlaceholder = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} viewContainer\\n     */\\n    function RowPlaceholder(viewContainer) {\\n        this.viewContainer = viewContainer;\\n    }\\n    return RowPlaceholder;\\n}());\\nRowPlaceholder.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: \\'[rowPlaceholder]\\' },] },\\n];\\n/**\\n * @nocollapse\\n */\\nRowPlaceholder.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\n/**\\n * Provides a handle for the table to grab the view container\\'s ng-container to insert the header.\\n * \\\\@docs-private\\n */\\nvar HeaderRowPlaceholder = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} viewContainer\\n     */\\n    function HeaderRowPlaceholder(viewContainer) {\\n        this.viewContainer = viewContainer;\\n    }\\n    return HeaderRowPlaceholder;\\n}());\\nHeaderRowPlaceholder.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{ selector: \\'[headerRowPlaceholder]\\' },] },\\n];\\n/**\\n * @nocollapse\\n */\\nHeaderRowPlaceholder.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\n/**\\n * The table template that can be used by the md-table. Should not be used outside of the\\n * material library.\\n */\\nvar CDK_TABLE_TEMPLATE = \"\\\\n  <ng-container headerRowPlaceholder></ng-container>\\\\n  <ng-container rowPlaceholder></ng-container>\";\\n/**\\n * A data table that connects with a data source to retrieve data of type T and renders\\n * a header row and data rows. Updates the rows when new data is provided by the data source.\\n */\\nvar CdkTable = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _differs\\n     * @param {?} _changeDetectorRef\\n     * @param {?} elementRef\\n     * @param {?} renderer\\n     * @param {?} role\\n     */\\n    function CdkTable(_differs, _changeDetectorRef, elementRef, renderer, role) {\\n        this._differs = _differs;\\n        this._changeDetectorRef = _changeDetectorRef;\\n        /**\\n         * Subject that emits when the component has been destroyed.\\n         */\\n        this._onDestroy = new __WEBPACK_IMPORTED_MODULE_15_rxjs_Subject__[\"Subject\"]();\\n        /**\\n         * Flag set to true after the component has been initialized.\\n         */\\n        this._isViewInitialized = false;\\n        /**\\n         * Latest data provided by the data source through the connect interface.\\n         */\\n        this._data = [];\\n        /**\\n         * Map of all the user\\'s defined columns identified by name.\\n         * Contains the header and data-cell templates.\\n         */\\n        this._columnDefinitionsByName = new Map();\\n        /**\\n         * Stream containing the latest information on what rows are being displayed on screen.\\n         * Can be used by the data source to as a heuristic of what data should be provided.\\n         */\\n        this.viewChange = new __WEBPACK_IMPORTED_MODULE_18_rxjs_BehaviorSubject__[\"BehaviorSubject\"]({ start: 0, end: Number.MAX_VALUE });\\n        if (!role) {\\n            renderer.setAttribute(elementRef.nativeElement, \\'role\\', \\'grid\\');\\n        }\\n    }\\n    Object.defineProperty(CdkTable.prototype, \"trackBy\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () { return this._trackByFn; },\\n        /**\\n         * Tracking function that will be used to check the differences in data changes. Used similarly\\n         * to ngFor trackBy function. Optimize row operations by identifying a row based on its data\\n         * relative to the function to know if a row should be added/removed/moved.\\n         * Accepts a function that takes two parameters, `index` and `item`.\\n         * @param {?} fn\\n         * @return {?}\\n         */\\n        set: function (fn) {\\n            if (__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"isDevMode\"]() &&\\n                fn != null && typeof fn !== \\'function\\' && (console) && (console.warn)) {\\n                console.warn(\"trackBy must be a function, but received \" + JSON.stringify(fn) + \".\");\\n            }\\n            this._trackByFn = fn;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(CdkTable.prototype, \"dataSource\", {\\n        /**\\n         * Provides a stream containing the latest data array to render. Influenced by the table\\'s\\n         * stream of view window (what rows are currently on screen).\\n         * @return {?}\\n         */\\n        get: function () { return this._dataSource; },\\n        /**\\n         * @param {?} dataSource\\n         * @return {?}\\n         */\\n        set: function (dataSource) {\\n            if (this._dataSource !== dataSource) {\\n                this._switchDataSource(dataSource);\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    CdkTable.prototype.ngOnDestroy = function () {\\n        this._onDestroy.next();\\n        this._onDestroy.complete();\\n        if (this.dataSource) {\\n            this.dataSource.disconnect(this);\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    CdkTable.prototype.ngOnInit = function () {\\n        // TODO(andrewseguin): Setup a listener for scroll events\\n        //   and emit the calculated view to this.viewChange\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    CdkTable.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        // TODO(andrewseguin): Throw an error if two columns share the same name\\n        this._columnDefinitions.forEach(function (columnDef) {\\n            _this._columnDefinitionsByName.set(columnDef.name, columnDef);\\n        });\\n        // Re-render the rows if any of their columns change.\\n        // TODO(andrewseguin): Determine how to only re-render the rows that have their columns changed.\\n        var /** @type {?} */ columnChangeEvents = this._rowDefinitions.map(function (rowDef) { return rowDef.columnsChange; });\\n        __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_takeUntil__[\"takeUntil\"].call(__WEBPACK_IMPORTED_MODULE_17_rxjs_observable_merge__[\"merge\"].apply(void 0, columnChangeEvents), this._onDestroy).subscribe(function () {\\n            // Reset the data to an empty array so that renderRowChanges will re-render all new rows.\\n            _this._rowPlaceholder.viewContainer.clear();\\n            _this._dataDiffer.diff([]);\\n            _this._renderRowChanges();\\n        });\\n        // Re-render the header row if the columns change\\n        __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_takeUntil__[\"takeUntil\"].call(this._headerDefinition.columnsChange, this._onDestroy).subscribe(function () {\\n            _this._headerRowPlaceholder.viewContainer.clear();\\n            _this._renderHeaderRow();\\n        });\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    CdkTable.prototype.ngAfterViewInit = function () {\\n        // Find and construct an iterable differ that can be used to find the diff in an array.\\n        this._dataDiffer = this._differs.find([]).create(this._trackByFn);\\n        this._isViewInitialized = true;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    CdkTable.prototype.ngDoCheck = function () {\\n        if (this._isViewInitialized && this.dataSource && !this._renderChangeSubscription) {\\n            this._renderHeaderRow();\\n            if (this.dataSource && !this._renderChangeSubscription) {\\n                this._observeRenderChanges();\\n            }\\n        }\\n    };\\n    /**\\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\\n     * render change subscription if one exists. If the data source is null, interpret this by\\n     * clearing the row placeholder. Otherwise start listening for new data.\\n     * @param {?} dataSource\\n     * @return {?}\\n     */\\n    CdkTable.prototype._switchDataSource = function (dataSource) {\\n        this._data = [];\\n        if (this._dataSource) {\\n            this.dataSource.disconnect(this);\\n        }\\n        this._dataSource = dataSource;\\n        if (this._isViewInitialized) {\\n            if (this._renderChangeSubscription) {\\n                this._renderChangeSubscription.unsubscribe();\\n            }\\n            if (this._dataSource) {\\n                this._observeRenderChanges();\\n            }\\n            else {\\n                this._rowPlaceholder.viewContainer.clear();\\n            }\\n        }\\n    };\\n    /**\\n     * Set up a subscription for the data provided by the data source.\\n     * @return {?}\\n     */\\n    CdkTable.prototype._observeRenderChanges = function () {\\n        var _this = this;\\n        this._renderChangeSubscription = __WEBPACK_IMPORTED_MODULE_13_rxjs_operator_takeUntil__[\"takeUntil\"].call(this.dataSource.connect(this), this._onDestroy)\\n            .subscribe(function (data) {\\n            _this._data = data;\\n            _this._renderRowChanges();\\n        });\\n    };\\n    /**\\n     * Create the embedded view for the header template and place it in the header row view container.\\n     * @return {?}\\n     */\\n    CdkTable.prototype._renderHeaderRow = function () {\\n        var /** @type {?} */ cells = this._getHeaderCellTemplatesForRow(this._headerDefinition);\\n        if (!cells.length) {\\n            return;\\n        }\\n        // TODO(andrewseguin): add some code to enforce that exactly\\n        //   one CdkCellOutlet was instantiated as a result\\n        //   of `createEmbeddedView`.\\n        this._headerRowPlaceholder.viewContainer\\n            .createEmbeddedView(this._headerDefinition.template, { cells: cells });\\n        cells.forEach(function (cell) {\\n            CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cell.template, {});\\n        });\\n        this._changeDetectorRef.markForCheck();\\n    };\\n    /**\\n     * Check for changes made in the data and render each change (row added/removed/moved).\\n     * @return {?}\\n     */\\n    CdkTable.prototype._renderRowChanges = function () {\\n        var _this = this;\\n        var /** @type {?} */ changes = this._dataDiffer.diff(this._data);\\n        if (!changes) {\\n            return;\\n        }\\n        var /** @type {?} */ viewContainer = this._rowPlaceholder.viewContainer;\\n        changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {\\n            if (item.previousIndex == null) {\\n                _this._insertRow(_this._data[currentIndex], currentIndex);\\n            }\\n            else if (currentIndex == null) {\\n                viewContainer.remove(adjustedPreviousIndex);\\n            }\\n            else {\\n                var /** @type {?} */ view = viewContainer.get(adjustedPreviousIndex);\\n                viewContainer.move(/** @type {?} */ ((view)), currentIndex);\\n            }\\n        });\\n        this._updateRowContext();\\n    };\\n    /**\\n     * Create the embedded view for the data row template and place it in the correct index location\\n     * within the data row view container.\\n     * @param {?} rowData\\n     * @param {?} index\\n     * @return {?}\\n     */\\n    CdkTable.prototype._insertRow = function (rowData, index) {\\n        // TODO(andrewseguin): Add when predicates to the row definitions\\n        //   to find the right template to used based on\\n        //   the data rather than choosing the first row definition.\\n        var /** @type {?} */ row = this._rowDefinitions.first;\\n        // Row context that will be provided to both the created embedded row view and its cells.\\n        var /** @type {?} */ context = { $implicit: rowData };\\n        // TODO(andrewseguin): add some code to enforce that exactly one\\n        //   CdkCellOutlet was instantiated as a result  of `createEmbeddedView`.\\n        this._rowPlaceholder.viewContainer.createEmbeddedView(row.template, context, index);\\n        // Insert empty cells if there is no data to improve rendering time.\\n        var /** @type {?} */ cells = rowData ? this._getCellTemplatesForRow(row) : [];\\n        cells.forEach(function (cell) {\\n            CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cell.template, context);\\n        });\\n        this._changeDetectorRef.markForCheck();\\n    };\\n    /**\\n     * Updates the context for each row to reflect any data changes that may have caused\\n     * rows to be added, removed, or moved. The view container contains the same context\\n     * that was provided to each of its cells.\\n     * @return {?}\\n     */\\n    CdkTable.prototype._updateRowContext = function () {\\n        var /** @type {?} */ viewContainer = this._rowPlaceholder.viewContainer;\\n        for (var /** @type {?} */ index = 0, /** @type {?} */ count = viewContainer.length; index < count; index++) {\\n            var /** @type {?} */ viewRef = (viewContainer.get(index));\\n            viewRef.context.index = index;\\n            viewRef.context.count = count;\\n            viewRef.context.first = index === 0;\\n            viewRef.context.last = index === count - 1;\\n            viewRef.context.even = index % 2 === 0;\\n            viewRef.context.odd = index % 2 !== 0;\\n        }\\n    };\\n    /**\\n     * Returns the cell template definitions to insert into the header\\n     * as defined by its list of columns to display.\\n     * @param {?} headerDef\\n     * @return {?}\\n     */\\n    CdkTable.prototype._getHeaderCellTemplatesForRow = function (headerDef) {\\n        var _this = this;\\n        if (!headerDef.columns) {\\n            return [];\\n        }\\n        return headerDef.columns.map(function (columnId) {\\n            var /** @type {?} */ column = _this._columnDefinitionsByName.get(columnId);\\n            if (!column) {\\n                throw getTableUnknownColumnError(columnId);\\n            }\\n            return column.headerCell;\\n        });\\n    };\\n    /**\\n     * Returns the cell template definitions to insert in the provided row\\n     * as defined by its list of columns to display.\\n     * @param {?} rowDef\\n     * @return {?}\\n     */\\n    CdkTable.prototype._getCellTemplatesForRow = function (rowDef) {\\n        var _this = this;\\n        if (!rowDef.columns) {\\n            return [];\\n        }\\n        return rowDef.columns.map(function (columnId) {\\n            var /** @type {?} */ column = _this._columnDefinitionsByName.get(columnId);\\n            if (!column) {\\n                throw getTableUnknownColumnError(columnId);\\n            }\\n            return column.cell;\\n        });\\n    };\\n    return CdkTable;\\n}());\\nCdkTable.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Component\"], args: [{\\n                selector: \\'cdk-table\\',\\n                template: CDK_TABLE_TEMPLATE,\\n                host: {\\n                    \\'class\\': \\'cdk-table\\',\\n                },\\n                encapsulation: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewEncapsulation\"].None,\\n                changeDetection: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectionStrategy\"].OnPush,\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkTable.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"IterableDiffers\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ChangeDetectorRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Renderer2\"], },\\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Attribute\"], args: [\\'role\\',] },] },\\n]; };\\nCdkTable.propDecorators = {\\n    \\'trackBy\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'dataSource\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n    \\'_rowPlaceholder\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [RowPlaceholder,] },],\\n    \\'_headerRowPlaceholder\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewChild\"], args: [HeaderRowPlaceholder,] },],\\n    \\'_columnDefinitions\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [CdkColumnDef,] },],\\n    \\'_headerDefinition\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChild\"], args: [CdkHeaderRowDef,] },],\\n    \\'_rowDefinitions\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ContentChildren\"], args: [CdkRowDef,] },],\\n};\\n/**\\n * @abstract\\n */\\nvar DataSource = /*@__PURE__*/(function () {\\n    function DataSource() {\\n    }\\n    /**\\n     * Connects a collection viewer (such as a data-table) to this data source.\\n     * @abstract\\n     * @param {?} collectionViewer The component that exposes a view over the data provided by this\\n     *     data source.\\n     * @return {?} Observable that emits a new value when the data changes.\\n     */\\n    DataSource.prototype.connect = function (collectionViewer) { };\\n    /**\\n     * Disconnects a collection viewer (such as a data-table) from this data source. Can be used\\n     * to perform any clean-up or tear-down operations when a view is being destroyed.\\n     *\\n     * @abstract\\n     * @param {?} collectionViewer The component that exposes a view over the data provided by this\\n     *     data source.\\n     * @return {?}\\n     */\\n    DataSource.prototype.disconnect = function (collectionViewer) { };\\n    return DataSource;\\n}());\\nvar EXPORTED_DECLARATIONS = [\\n    CdkTable,\\n    CdkRowDef,\\n    CdkCellDef,\\n    CdkCellOutlet,\\n    CdkHeaderCellDef,\\n    CdkColumnDef,\\n    CdkCell,\\n    CdkRow,\\n    CdkHeaderCell,\\n    CdkHeaderRow,\\n    CdkHeaderRowDef,\\n    RowPlaceholder,\\n    HeaderRowPlaceholder,\\n];\\nvar CdkTableModule = /*@__PURE__*/(function () {\\n    function CdkTableModule() {\\n    }\\n    return CdkTableModule;\\n}());\\nCdkTableModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                imports: [__WEBPACK_IMPORTED_MODULE_14__angular_common__[\"CommonModule\"]],\\n                exports: [EXPORTED_DECLARATIONS],\\n                declarations: [EXPORTED_DECLARATIONS]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nCdkTableModule.ctorParameters = function () { return []; };\\n/**\\n * Throws an exception when attempting to attach a null portal to a host.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwNullPortalError() {\\n    throw Error(\\'Must provide a portal to attach\\');\\n}\\n/**\\n * Throws an exception when attempting to attach a portal to a host that is already attached.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwPortalAlreadyAttachedError() {\\n    throw Error(\\'Host already has a portal attached\\');\\n}\\n/**\\n * Throws an exception when attempting to attach a portal to an already-disposed host.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwPortalHostAlreadyDisposedError() {\\n    throw Error(\\'This PortalHost has already been disposed\\');\\n}\\n/**\\n * Throws an exception when attempting to attach an unknown portal type.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwUnknownPortalTypeError() {\\n    throw Error(\\'Attempting to attach an unknown Portal type. BasePortalHost accepts either\\' +\\n        \\'a ComponentPortal or a TemplatePortal.\\');\\n}\\n/**\\n * Throws an exception when attempting to attach a portal to a null host.\\n * \\\\@docs-private\\n * @return {?}\\n */\\nfunction throwNullPortalHostError() {\\n    throw Error(\\'Attempting to attach a portal to a null PortalHost\\');\\n}\\n/**\\n * Throws an exception when attempting to detach a portal that is not attached.\\n * \\\\@docs-privatew\\n * @return {?}\\n */\\nfunction throwNoPortalAttachedError() {\\n    throw Error(\\'Attempting to detach a portal that is not attached to a host\\');\\n}\\n/**\\n * A `Portal` is something that you want to render somewhere else.\\n * It can be attach to / detached from a `PortalHost`.\\n * @abstract\\n */\\nvar Portal = /*@__PURE__*/(function () {\\n    function Portal() {\\n    }\\n    /**\\n     * Attach this portal to a host.\\n     * @param {?} host\\n     * @return {?}\\n     */\\n    Portal.prototype.attach = function (host) {\\n        if (host == null) {\\n            throwNullPortalHostError();\\n        }\\n        if (host.hasAttached()) {\\n            throwPortalAlreadyAttachedError();\\n        }\\n        this._attachedHost = host;\\n        return (host.attach(this));\\n    };\\n    /**\\n     * Detach this portal from its host\\n     * @return {?}\\n     */\\n    Portal.prototype.detach = function () {\\n        var /** @type {?} */ host = this._attachedHost;\\n        if (host == null) {\\n            throwNoPortalAttachedError();\\n        }\\n        else {\\n            this._attachedHost = null;\\n            host.detach();\\n        }\\n    };\\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\\n        /**\\n         * Whether this portal is attached to a host.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._attachedHost != null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Sets the PortalHost reference without performing `attach()`. This is used directly by\\n     * the PortalHost when it is performing an `attach()` or `detach()`.\\n     * @param {?} host\\n     * @return {?}\\n     */\\n    Portal.prototype.setAttachedHost = function (host) {\\n        this._attachedHost = host;\\n    };\\n    return Portal;\\n}());\\n/**\\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\\n */\\nvar ComponentPortal = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](ComponentPortal, _super);\\n    /**\\n     * @param {?} component\\n     * @param {?=} viewContainerRef\\n     * @param {?=} injector\\n     */\\n    function ComponentPortal(component, viewContainerRef, injector) {\\n        var _this = _super.call(this) || this;\\n        _this.component = component;\\n        _this.viewContainerRef = viewContainerRef;\\n        _this.injector = injector;\\n        return _this;\\n    }\\n    return ComponentPortal;\\n}(Portal));\\n/**\\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\\n */\\nvar TemplatePortal = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](TemplatePortal, _super);\\n    /**\\n     * @param {?} template\\n     * @param {?} viewContainerRef\\n     */\\n    function TemplatePortal(template, viewContainerRef) {\\n        var _this = _super.call(this) || this;\\n        /**\\n         * Additional locals for the instantiated embedded view.\\n         * These locals can be seen as \"exports\" for the template, such as how ngFor has\\n         * index / event / odd.\\n         * See https://angular.io/docs/ts/latest/api/core/EmbeddedViewRef-class.html\\n         */\\n        _this.locals = new Map();\\n        _this.templateRef = template;\\n        _this.viewContainerRef = viewContainerRef;\\n        return _this;\\n    }\\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\\n        /**\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this.templateRef.elementRef;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @param {?} host\\n     * @param {?=} locals\\n     * @return {?}\\n     */\\n    TemplatePortal.prototype.attach = function (host, locals) {\\n        this.locals = locals == null ? new Map() : locals;\\n        return _super.prototype.attach.call(this, host);\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    TemplatePortal.prototype.detach = function () {\\n        this.locals = new Map();\\n        return _super.prototype.detach.call(this);\\n    };\\n    return TemplatePortal;\\n}(Portal));\\n/**\\n * Partial implementation of PortalHost that only deals with attaching either a\\n * ComponentPortal or a TemplatePortal.\\n * @abstract\\n */\\nvar BasePortalHost = /*@__PURE__*/(function () {\\n    function BasePortalHost() {\\n        /**\\n         * Whether this host has already been permanently disposed.\\n         */\\n        this._isDisposed = false;\\n    }\\n    /**\\n     * Whether this host has an attached portal.\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.hasAttached = function () {\\n        return !!this._attachedPortal;\\n    };\\n    /**\\n     * @param {?} portal\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.attach = function (portal) {\\n        if (!portal) {\\n            throwNullPortalError();\\n        }\\n        if (this.hasAttached()) {\\n            throwPortalAlreadyAttachedError();\\n        }\\n        if (this._isDisposed) {\\n            throwPortalHostAlreadyDisposedError();\\n        }\\n        if (portal instanceof ComponentPortal) {\\n            this._attachedPortal = portal;\\n            return this.attachComponentPortal(portal);\\n        }\\n        else if (portal instanceof TemplatePortal) {\\n            this._attachedPortal = portal;\\n            return this.attachTemplatePortal(portal);\\n        }\\n        throwUnknownPortalTypeError();\\n    };\\n    /**\\n     * @abstract\\n     * @template T\\n     * @param {?} portal\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.attachComponentPortal = function (portal) { };\\n    /**\\n     * @abstract\\n     * @param {?} portal\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.attachTemplatePortal = function (portal) { };\\n    /**\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.detach = function () {\\n        if (this._attachedPortal) {\\n            this._attachedPortal.setAttachedHost(null);\\n            this._attachedPortal = null;\\n        }\\n        this._invokeDisposeFn();\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.dispose = function () {\\n        if (this.hasAttached()) {\\n            this.detach();\\n        }\\n        this._invokeDisposeFn();\\n        this._isDisposed = true;\\n    };\\n    /**\\n     * @param {?} fn\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype.setDisposeFn = function (fn) {\\n        this._disposeFn = fn;\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    BasePortalHost.prototype._invokeDisposeFn = function () {\\n        if (this._disposeFn) {\\n            this._disposeFn();\\n            this._disposeFn = null;\\n        }\\n    };\\n    return BasePortalHost;\\n}());\\n/**\\n * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular\\n * application context.\\n *\\n * This is the only part of the portal core that directly touches the DOM.\\n */\\nvar DomPortalHost = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](DomPortalHost, _super);\\n    /**\\n     * @param {?} _hostDomElement\\n     * @param {?} _componentFactoryResolver\\n     * @param {?} _appRef\\n     * @param {?} _defaultInjector\\n     */\\n    function DomPortalHost(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {\\n        var _this = _super.call(this) || this;\\n        _this._hostDomElement = _hostDomElement;\\n        _this._componentFactoryResolver = _componentFactoryResolver;\\n        _this._appRef = _appRef;\\n        _this._defaultInjector = _defaultInjector;\\n        return _this;\\n    }\\n    /**\\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\\n     * @template T\\n     * @param {?} portal Portal to be attached\\n     * @return {?}\\n     */\\n    DomPortalHost.prototype.attachComponentPortal = function (portal) {\\n        var _this = this;\\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\\n        var /** @type {?} */ componentRef;\\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\\n        // for the component (in terms of Angular\\'s component tree, not rendering).\\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\\n        // and then manually attach the view to the application.\\n        if (portal.viewContainerRef) {\\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\\n            this.setDisposeFn(function () { return componentRef.destroy(); });\\n        }\\n        else {\\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\\n            this._appRef.attachView(componentRef.hostView);\\n            this.setDisposeFn(function () {\\n                _this._appRef.detachView(componentRef.hostView);\\n                componentRef.destroy();\\n            });\\n        }\\n        // At this point the component has been instantiated, so we move it to the location in the DOM\\n        // where we want it to be rendered.\\n        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\\n        return componentRef;\\n    };\\n    /**\\n     * Attaches a template portal to the DOM as an embedded view.\\n     * @param {?} portal Portal to be attached.\\n     * @return {?}\\n     */\\n    DomPortalHost.prototype.attachTemplatePortal = function (portal) {\\n        var _this = this;\\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef);\\n        viewRef.detectChanges();\\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\\n        // But for the DomPortalHost the view can be added everywhere in the DOM (e.g Overlay Container)\\n        // To move the view to the specified host element. We just re-append the existing root nodes.\\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\\n        this.setDisposeFn((function () {\\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\\n            if (index !== -1) {\\n                viewContainer.remove(index);\\n            }\\n        }));\\n        // TODO(jelbourn): Return locals from view.\\n        return new Map();\\n    };\\n    /**\\n     * Clears out a portal from the DOM.\\n     * @return {?}\\n     */\\n    DomPortalHost.prototype.dispose = function () {\\n        _super.prototype.dispose.call(this);\\n        if (this._hostDomElement.parentNode != null) {\\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\\n        }\\n    };\\n    /**\\n     * Gets the root HTMLElement for an instantiated component.\\n     * @param {?} componentRef\\n     * @return {?}\\n     */\\n    DomPortalHost.prototype._getComponentRootNode = function (componentRef) {\\n        return (((componentRef.hostView)).rootNodes[0]);\\n    };\\n    return DomPortalHost;\\n}(BasePortalHost));\\n/**\\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\\n *\\n * Usage:\\n * <ng-template portal #greeting>\\n *   <p> Hello {{name}} </p>\\n * </ng-template>\\n */\\nvar TemplatePortalDirective = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](TemplatePortalDirective, _super);\\n    /**\\n     * @param {?} templateRef\\n     * @param {?} viewContainerRef\\n     */\\n    function TemplatePortalDirective(templateRef, viewContainerRef) {\\n        return _super.call(this, templateRef, viewContainerRef) || this;\\n    }\\n    return TemplatePortalDirective;\\n}(TemplatePortal));\\nTemplatePortalDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdk-portal], [cdkPortal], [portal]\\',\\n                exportAs: \\'cdkPortal\\',\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nTemplatePortalDirective.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"TemplateRef\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\n/**\\n * Directive version of a PortalHost. Because the directive *is* a PortalHost, portals can be\\n * directly attached to it, enabling declarative use.\\n *\\n * Usage:\\n * <ng-template [cdkPortalHost]=\"greeting\"></ng-template>\\n */\\nvar PortalHostDirective = /*@__PURE__*/(function (_super) {\\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"a\" /* __extends */](PortalHostDirective, _super);\\n    /**\\n     * @param {?} _componentFactoryResolver\\n     * @param {?} _viewContainerRef\\n     */\\n    function PortalHostDirective(_componentFactoryResolver, _viewContainerRef) {\\n        var _this = _super.call(this) || this;\\n        _this._componentFactoryResolver = _componentFactoryResolver;\\n        _this._viewContainerRef = _viewContainerRef;\\n        /**\\n         * The attached portal.\\n         */\\n        _this._portal = null;\\n        return _this;\\n    }\\n    Object.defineProperty(PortalHostDirective.prototype, \"_deprecatedPortal\", {\\n        /**\\n         * @deprecated\\n         * @return {?}\\n         */\\n        get: function () { return this.portal; },\\n        /**\\n         * @param {?} v\\n         * @return {?}\\n         */\\n        set: function (v) { this.portal = v; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(PortalHostDirective.prototype, \"portal\", {\\n        /**\\n         * Portal associated with the Portal host.\\n         * @return {?}\\n         */\\n        get: function () {\\n            return this._portal;\\n        },\\n        /**\\n         * @param {?} portal\\n         * @return {?}\\n         */\\n        set: function (portal) {\\n            if (this.hasAttached()) {\\n                _super.prototype.detach.call(this);\\n            }\\n            if (portal) {\\n                _super.prototype.attach.call(this, portal);\\n            }\\n            this._portal = portal;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @return {?}\\n     */\\n    PortalHostDirective.prototype.ngOnDestroy = function () {\\n        _super.prototype.dispose.call(this);\\n        this._portal = null;\\n    };\\n    /**\\n     * Attach the given ComponentPortal to this PortalHost using the ComponentFactoryResolver.\\n     *\\n     * @template T\\n     * @param {?} portal Portal to be attached to the portal host.\\n     * @return {?}\\n     */\\n    PortalHostDirective.prototype.attachComponentPortal = function (portal) {\\n        portal.setAttachedHost(this);\\n        // If the portal specifies an origin, use that as the logical location of the component\\n        // in the application tree. Otherwise use the location of this PortalHost.\\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\\n            portal.viewContainerRef :\\n            this._viewContainerRef;\\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\\n        this._portal = portal;\\n        return ref;\\n    };\\n    /**\\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\\n     * @param {?} portal Portal to be attached.\\n     * @return {?}\\n     */\\n    PortalHostDirective.prototype.attachTemplatePortal = function (portal) {\\n        var _this = this;\\n        portal.setAttachedHost(this);\\n        this._viewContainerRef.createEmbeddedView(portal.templateRef);\\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\\n        this._portal = portal;\\n        // TODO(jelbourn): return locals from view\\n        return new Map();\\n    };\\n    return PortalHostDirective;\\n}(BasePortalHost));\\nPortalHostDirective.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdkPortalHost], [portalHost]\\',\\n                inputs: [\\'portal: cdkPortalHost\\']\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nPortalHostDirective.ctorParameters = function () { return [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ComponentFactoryResolver\"], },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ViewContainerRef\"], },\\n]; };\\nPortalHostDirective.propDecorators = {\\n    \\'_deprecatedPortal\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"], args: [\\'portalHost\\',] },],\\n};\\nvar PortalModule = /*@__PURE__*/(function () {\\n    function PortalModule() {\\n    }\\n    return PortalModule;\\n}());\\nPortalModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                exports: [TemplatePortalDirective, PortalHostDirective],\\n                declarations: [TemplatePortalDirective, PortalHostDirective],\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nPortalModule.ctorParameters = function () { return []; };\\n/**\\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\\n * \\\\@docs-private\\n */\\nvar MdMutationObserverFactory = /*@__PURE__*/(function () {\\n    function MdMutationObserverFactory() {\\n    }\\n    /**\\n     * @param {?} callback\\n     * @return {?}\\n     */\\n    MdMutationObserverFactory.prototype.create = function (callback) {\\n        return typeof MutationObserver === \\'undefined\\' ? null : new MutationObserver(callback);\\n    };\\n    return MdMutationObserverFactory;\\n}());\\nMdMutationObserverFactory.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\\n];\\n/**\\n * @nocollapse\\n */\\nMdMutationObserverFactory.ctorParameters = function () { return []; };\\n/**\\n * Directive that triggers a callback whenever the content of\\n * its associated element has changed.\\n */\\nvar ObserveContent = /*@__PURE__*/(function () {\\n    /**\\n     * @param {?} _mutationObserverFactory\\n     * @param {?} _elementRef\\n     */\\n    function ObserveContent(_mutationObserverFactory, _elementRef) {\\n        this._mutationObserverFactory = _mutationObserverFactory;\\n        this._elementRef = _elementRef;\\n        /**\\n         * Event emitted for each change in the element\\'s content.\\n         */\\n        this.event = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"EventEmitter\"]();\\n        /**\\n         * Used for debouncing the emitted values to the observeContent event.\\n         */\\n        this._debouncer = new __WEBPACK_IMPORTED_MODULE_15_rxjs_Subject__[\"Subject\"]();\\n    }\\n    /**\\n     * @return {?}\\n     */\\n    ObserveContent.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        if (this.debounce > 0) {\\n            RxChain.from(this._debouncer)\\n                .call(debounceTime$1, this.debounce)\\n                .subscribe(function (mutations) { return _this.event.emit(mutations); });\\n        }\\n        else {\\n            this._debouncer.subscribe(function (mutations) { return _this.event.emit(mutations); });\\n        }\\n        this._observer = this._mutationObserverFactory.create(function (mutations) {\\n            _this._debouncer.next(mutations);\\n        });\\n        if (this._observer) {\\n            this._observer.observe(this._elementRef.nativeElement, {\\n                characterData: true,\\n                childList: true,\\n                subtree: true\\n            });\\n        }\\n    };\\n    /**\\n     * @return {?}\\n     */\\n    ObserveContent.prototype.ngOnDestroy = function () {\\n        if (this._observer) {\\n            this._observer.disconnect();\\n            this._debouncer.complete();\\n        }\\n    };\\n    return ObserveContent;\\n}());\\nObserveContent.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Directive\"], args: [{\\n                selector: \\'[cdkObserveContent]\\'\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nObserveContent.ctorParameters = function () { return [\\n    { type: MdMutationObserverFactory, },\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ElementRef\"], },\\n]; };\\nObserveContent.propDecorators = {\\n    \\'event\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Output\"], args: [\\'cdkObserveContent\\',] },],\\n    \\'debounce\\': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Input\"] },],\\n};\\nvar ObserveContentModule = /*@__PURE__*/(function () {\\n    function ObserveContentModule() {\\n    }\\n    return ObserveContentModule;\\n}());\\nObserveContentModule.decorators = [\\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"], args: [{\\n                exports: [ObserveContent],\\n                declarations: [ObserveContent],\\n                providers: [MdMutationObserverFactory]\\n            },] },\\n];\\n/**\\n * @nocollapse\\n */\\nObserveContentModule.ctorParameters = function () { return []; };\\n/**\\n * Generated bundle index. Do not edit.\\n */\\n\\n//# sourceMappingURL=cdk.es5.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jZGsvQGFuZ3VsYXIvY2RrLmVzNS5qcz81ZmI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBBdHRyaWJ1dGUsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIElucHV0LCBJdGVyYWJsZURpZmZlcnMsIE5nTW9kdWxlLCBOZ1pvbmUsIE9wdGlvbmFsLCBPdXRwdXQsIFJlbmRlcmVyMiwgU2tpcFNlbGYsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQsIFZpZXdDb250YWluZXJSZWYsIFZpZXdFbmNhcHN1bGF0aW9uLCBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IF9maW5hbGx5IH0gZnJvbSAncnhqcy9vcGVyYXRvci9maW5hbGx5JztcbmltcG9ydCB7IF9jYXRjaCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvY2F0Y2gnO1xuaW1wb3J0IHsgX2RvIH0gZnJvbSAncnhqcy9vcGVyYXRvci9kbyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9yL21hcCc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9yL2ZpbHRlcic7XG5pbXBvcnQgeyBzaGFyZSB9IGZyb20gJ3J4anMvb3BlcmF0b3Ivc2hhcmUnO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdyeGpzL29wZXJhdG9yL2ZpcnN0JztcbmltcG9ydCB7IHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwJztcbmltcG9ydCB7IHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3Ivc3RhcnRXaXRoJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZGVib3VuY2VUaW1lJztcbmltcG9ydCB7IGF1ZGl0VGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3IvYXVkaXRUaW1lJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvdGFrZVVudGlsJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9tZXJnZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG4vKipcbiAqIENvZXJjZXMgYSBkYXRhLWJvdW5kIHZhbHVlICh0eXBpY2FsbHkgYSBzdHJpbmcpIHRvIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIFwiXCIgKyB2YWx1ZSAhPT0gJ2ZhbHNlJztcbn1cbi8vIFdoZXRoZXIgdGhlIGN1cnJlbnQgcGxhdGZvcm0gc3VwcG9ydHMgdGhlIFY4IEJyZWFrIEl0ZXJhdG9yLiBUaGUgVjggY2hlY2tcbi8vIGlzIG5lY2Vzc2FyeSB0byBkZXRlY3QgYWxsIEJsaW5rIGJhc2VkIGJyb3dzZXJzLlxudmFyIGhhc1Y4QnJlYWtJdGVyYXRvciA9ICh0eXBlb2YgKEludGwpICE9PSAndW5kZWZpbmVkJyAmJiAoKEludGwpKS52OEJyZWFrSXRlcmF0b3IpO1xuLyoqXG4gKiBTZXJ2aWNlIHRvIGRldGVjdCB0aGUgY3VycmVudCBwbGF0Zm9ybSBieSBjb21wYXJpbmcgdGhlIHVzZXJBZ2VudCBzdHJpbmdzIGFuZFxuICogY2hlY2tpbmcgYnJvd3Nlci1zcGVjaWZpYyBnbG9iYWwgcHJvcGVydGllcy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgUGxhdGZvcm0gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybSgpIHtcbiAgICAgICAgdGhpcy5pc0Jyb3dzZXIgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnICYmICEhZG9jdW1lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMYXlvdXQgRW5naW5lc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5FREdFID0gdGhpcy5pc0Jyb3dzZXIgJiYgLyhlZGdlKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIHRoaXMuVFJJREVOVCA9IHRoaXMuaXNCcm93c2VyICYmIC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIC8vIEVkZ2VIVE1MIGFuZCBUcmlkZW50IG1vY2sgQmxpbmsgc3BlY2lmaWMgdGhpbmdzIGFuZCBuZWVkIHRvIGJlIGV4Y2x1ZGVkIGZyb20gdGhpcyBjaGVjay5cbiAgICAgICAgdGhpcy5CTElOSyA9IHRoaXMuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAoISEoKCh3aW5kb3cpKS5jaHJvbWUgfHwgaGFzVjhCcmVha0l0ZXJhdG9yKSAmJiAhIUNTUyAmJiAhdGhpcy5FREdFICYmICF0aGlzLlRSSURFTlQpO1xuICAgICAgICAvLyBXZWJraXQgaXMgcGFydCBvZiB0aGUgdXNlckFnZW50IGluIEVkZ2VIVE1MLCBCbGluayBhbmQgVHJpZGVudC4gVGhlcmVmb3JlIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgV2Via2l0IHJ1bnMgc3RhbmRhbG9uZSBhbmQgaXMgbm90IHVzZWQgYXMgYW5vdGhlciBlbmdpbmUncyBiYXNlLlxuICAgICAgICB0aGlzLldFQktJVCA9IHRoaXMuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAvQXBwbGVXZWJLaXQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF0aGlzLkJMSU5LICYmICF0aGlzLkVER0UgJiYgIXRoaXMuVFJJREVOVDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb3dzZXJzIGFuZCBQbGF0Zm9ybSBUeXBlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5JT1MgPSB0aGlzLmlzQnJvd3NlciAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuICAgICAgICAvLyBJdCdzIGRpZmZpY3VsdCB0byBkZXRlY3QgdGhlIHBsYWluIEdlY2tvIGVuZ2luZSwgYmVjYXVzZSBtb3N0IG9mIHRoZSBicm93c2VycyBpZGVudGlmeVxuICAgICAgICAvLyB0aGVtIHNlbGYgYXMgR2Vja28tbGlrZSBicm93c2VycyBhbmQgbW9kaWZ5IHRoZSB1c2VyQWdlbnQncyBhY2NvcmRpbmcgdG8gdGhhdC5cbiAgICAgICAgLy8gU2luY2Ugd2Ugb25seSBjb3ZlciBvbmUgZXhwbGljaXQgRmlyZWZveCBjYXNlLCB3ZSBjYW4gc2ltcGx5IGNoZWNrIGZvciBGaXJlZm94XG4gICAgICAgIC8vIGluc3RlYWQgb2YgaGF2aW5nIGFuIHVuc3RhYmxlIGNoZWNrIGZvciBHZWNrby5cbiAgICAgICAgdGhpcy5GSVJFRk9YID0gdGhpcy5pc0Jyb3dzZXIgJiYgLyhmaXJlZm94fG1pbmVmaWVsZCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAvLyBUcmlkZW50IG9uIG1vYmlsZSBhZGRzIHRoZSBhbmRyb2lkIHBsYXRmb3JtIHRvIHRoZSB1c2VyQWdlbnQgdG8gdHJpY2sgZGV0ZWN0aW9ucy5cbiAgICAgICAgdGhpcy5BTkRST0lEID0gdGhpcy5pc0Jyb3dzZXIgJiYgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF0aGlzLlRSSURFTlQ7XG4gICAgICAgIC8vIFNhZmFyaSBicm93c2VycyB3aWxsIGluY2x1ZGUgdGhlIFNhZmFyaSBrZXl3b3JkIGluIHRoZWlyIHVzZXJBZ2VudC4gU29tZSBicm93c2VycyBtYXkgZmFrZVxuICAgICAgICAvLyB0aGlzIGFuZCBqdXN0IHBsYWNlIHRoZSBTYWZhcmkga2V5d29yZCBpbiB0aGUgdXNlckFnZW50LiBUbyBiZSBtb3JlIHNhZmUgYWJvdXQgU2FmYXJpIGV2ZXJ5XG4gICAgICAgIC8vIFNhZmFyaSBicm93c2VyIHNob3VsZCBhbHNvIHVzZSBXZWJraXQgYXMgaXRzIGxheW91dCBlbmdpbmUuXG4gICAgICAgIHRoaXMuU0FGQVJJID0gdGhpcy5pc0Jyb3dzZXIgJiYgL3NhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgdGhpcy5XRUJLSVQ7XG4gICAgfVxuICAgIHJldHVybiBQbGF0Zm9ybTtcbn0oKSk7XG5QbGF0Zm9ybS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuUGxhdGZvcm0uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogVXRpbGl0eSBmb3IgY2hlY2tpbmcgdGhlIGludGVyYWN0aXZpdHkgb2YgYW4gZWxlbWVudCwgc3VjaCBhcyB3aGV0aGVyIGlzIGlzIGZvY3VzYWJsZSBvclxuICogdGFiYmFibGUuXG4gKi9cbnZhciBJbnRlcmFjdGl2aXR5Q2hlY2tlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3BsYXRmb3JtXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW50ZXJhY3Rpdml0eUNoZWNrZXIoX3BsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gX3BsYXRmb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7P30gV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBJbnRlcmFjdGl2aXR5Q2hlY2tlci5wcm90b3R5cGUuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIFRoaXMgZG9lcyBub3QgY2FwdHVyZSBzb21lIGNhc2VzLCBzdWNoIGFzIGEgbm9uLWZvcm0gY29udHJvbCB3aXRoIGEgZGlzYWJsZWQgYXR0cmlidXRlIG9yXG4gICAgICAgIC8vIGEgZm9ybSBjb250cm9sIGluc2lkZSBvZiBhIGRpc2FibGVkIGZvcm0sIGJ1dCBzaG91bGQgY2FwdHVyZSB0aGUgbW9zdCBjb21tb24gY2FzZXMuXG4gICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIHZpc2libGUgZm9yIHRoZSBwdXJwb3NlcyBvZiBpbnRlcmFjdGl2aXR5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGNhcHR1cmUgc3RhdGVzIGxpa2UgYGRpc3BsYXk6IG5vbmVgIGFuZCBgdmlzaWJpbGl0eTogaGlkZGVuYCwgYnV0IG5vdCB0aGluZ3MgbGlrZVxuICAgICAqIGJlaW5nIGNsaXBwZWQgYnkgYW4gYG92ZXJmbG93OiBoaWRkZW5gIHBhcmVudCBvciBiZWluZyBvdXRzaWRlIHRoZSB2aWV3cG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99IFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBJbnRlcmFjdGl2aXR5Q2hlY2tlci5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGhhc0dlb21ldHJ5KGVsZW1lbnQpICYmIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudmlzaWJpbGl0eSA9PT0gJ3Zpc2libGUnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgY2FuIGJlIHJlYWNoZWQgdmlhIFRhYiBrZXkuXG4gICAgICogQXNzdW1lcyB0aGF0IHRoZSBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZCB3aXRoIGlzRm9jdXNhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50IEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHs/fSBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHRhYmJhYmxlLlxuICAgICAqL1xuICAgIEludGVyYWN0aXZpdHlDaGVja2VyLnByb3RvdHlwZS5pc1RhYmJhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gTm90aGluZyBpcyB0YWJiYWJsZSBvbiB0aGUgdGhlIHNlcnZlciDwn5iOXG4gICAgICAgIGlmICghdGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnJhbWVFbGVtZW50ID0gKGdldFdpbmRvdyhlbGVtZW50KS5mcmFtZUVsZW1lbnQpO1xuICAgICAgICBpZiAoZnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmcmFtZVR5cGUgPSBmcmFtZUVsZW1lbnQgJiYgZnJhbWVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAvLyBGcmFtZSBlbGVtZW50cyBpbmhlcml0IHRoZWlyIHRhYmluZGV4IG9udG8gYWxsIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgICAgICAgaWYgKGdldFRhYkluZGV4VmFsdWUoZnJhbWVFbGVtZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZWJraXQgYW5kIEJsaW5rIGNvbnNpZGVyIGFueXRoaW5nIGluc2lkZSBvZiBhbiA8b2JqZWN0PiBlbGVtZW50IGFzIG5vbi10YWJiYWJsZS5cbiAgICAgICAgICAgIGlmICgodGhpcy5fcGxhdGZvcm0uQkxJTksgfHwgdGhpcy5fcGxhdGZvcm0uV0VCS0lUKSAmJiBmcmFtZVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Via2l0IGFuZCBCbGluayBkaXNhYmxlIHRhYmJpbmcgdG8gYW4gZWxlbWVudCBpbnNpZGUgb2YgYW4gaW52aXNpYmxlIGZyYW1lLlxuICAgICAgICAgICAgaWYgKCh0aGlzLl9wbGF0Zm9ybS5CTElOSyB8fCB0aGlzLl9wbGF0Zm9ybS5XRUJLSVQpICYmICF0aGlzLmlzVmlzaWJsZShmcmFtZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWJJbmRleFZhbHVlID0gZ2V0VGFiSW5kZXhWYWx1ZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhYkluZGV4VmFsdWUgIT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ2lmcmFtZScpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmcmFtZXMgbWF5IGJlIHRhYmJhYmxlIGRlcGVuZGluZyBvbiBjb250ZW50LCBidXQgaXQncyBub3QgcG9zc2libHkgdG8gcmVsaWFibHlcbiAgICAgICAgICAgIC8vIGludmVzdGlnYXRlIHRoZSBjb250ZW50IG9mIHRoZSBmcmFtZXMuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpKSB7XG4gICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCBhbiA8YXVkaW8+IGVsZW1lbnQgd2l0aG91dCB0aGUgY29udHJvbHMgZW5hYmxlZCBpcyBub3QgdGFiYmFibGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGxhdGZvcm0uQkxJTkspIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBCbGluayA8YXVkaW8gY29udHJvbHM+IGVsZW1lbnRzIGFyZSBhbHdheXMgdGFiYmFibGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpICYmIHRoaXMuX3BsYXRmb3JtLlRSSURFTlQpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBUcmlkZW50IGEgPHZpZGVvPiBlbGVtZW50IHdpdGhvdXQgdGhlIGNvbnRyb2xzIGVuYWJsZWQgaXMgbm90IHRhYmJhYmxlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BsYXRmb3JtLkJMSU5LIHx8IHRoaXMuX3BsYXRmb3JtLkZJUkVGT1gpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBDaHJvbWUgYW5kIEZpcmVmb3ggPHZpZGVvIGNvbnRyb2xzPiBlbGVtZW50cyBhcmUgYWx3YXlzIHRhYmJhYmxlLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ29iamVjdCcgJiYgKHRoaXMuX3BsYXRmb3JtLkJMSU5LIHx8IHRoaXMuX3BsYXRmb3JtLldFQktJVCkpIHtcbiAgICAgICAgICAgIC8vIEluIGFsbCBCbGluayBhbmQgV2ViS2l0IGJhc2VkIGJyb3dzZXJzIDxvYmplY3Q+IGVsZW1lbnRzIGFyZSBuZXZlciB0YWJiYWJsZS5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBpT1MgdGhlIGJyb3dzZXIgb25seSBjb25zaWRlcnMgc29tZSBzcGVjaWZpYyBlbGVtZW50cyBhcyB0YWJiYWJsZS5cbiAgICAgICAgaWYgKHRoaXMuX3BsYXRmb3JtLldFQktJVCAmJiB0aGlzLl9wbGF0Zm9ybS5JT1MgJiYgIWlzUG90ZW50aWFsbHlUYWJiYWJsZUlPUyhlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50LnRhYkluZGV4ID49IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBjYW4gYmUgZm9jdXNlZCBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7P30gV2hldGhlciB0aGUgZWxlbWVudCBpcyBmb2N1c2FibGUuXG4gICAgICovXG4gICAgSW50ZXJhY3Rpdml0eUNoZWNrZXIucHJvdG90eXBlLmlzRm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBjaGVja3MgaW4gb3JkZXIgb2YgbGVmdCB0byBtb3N0IGV4cGVuc2l2ZS5cbiAgICAgICAgLy8gQWdhaW4sIG5haXZlIGFwcHJvYWNoIHRoYXQgZG9lcyBub3QgY2FwdHVyZSBtYW55IGVkZ2UgY2FzZXMgYW5kIGJyb3dzZXIgcXVpcmtzLlxuICAgICAgICByZXR1cm4gaXNQb3RlbnRpYWxseUZvY3VzYWJsZShlbGVtZW50KSAmJiAhdGhpcy5pc0Rpc2FibGVkKGVsZW1lbnQpICYmIHRoaXMuaXNWaXNpYmxlKGVsZW1lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVyYWN0aXZpdHlDaGVja2VyO1xufSgpKTtcbkludGVyYWN0aXZpdHlDaGVja2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5JbnRlcmFjdGl2aXR5Q2hlY2tlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCB9LFxuXTsgfTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBlbGVtZW50IGhhcyBhbnkgZ2VvbWV0cnkgLyByZWN0YW5nbGVzLlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBoYXNHZW9tZXRyeShlbGVtZW50KSB7XG4gICAgLy8gVXNlIGxvZ2ljIGZyb20galF1ZXJ5IHRvIGNoZWNrIGZvciBhbiBpbnZpc2libGUgZWxlbWVudC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2Nzcy9oaWRkZW5WaXNpYmxlU2VsZWN0b3JzLmpzI0wxMlxuICAgIHJldHVybiAhIShlbGVtZW50Lm9mZnNldFdpZHRoIHx8IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCdzXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlRm9ybUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSA9PT0gJ2lucHV0JyB8fFxuICAgICAgICBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgbm9kZU5hbWUgPT09ICdidXR0b24nIHx8XG4gICAgICAgIG5vZGVOYW1lID09PSAndGV4dGFyZWEnO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhbiA8aW5wdXQgdHlwZT1cImhpZGRlblwiPi5cbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNIaWRkZW5JbnB1dChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGlzSW5wdXRFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQudHlwZSA9PSAnaGlkZGVuJztcbn1cbi8qKlxuICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgYW4gYW5jaG9yIHRoYXQgaGFzIGFuIGhyZWYgYXR0cmlidXRlLlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0FuY2hvcldpdGhIcmVmKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gaXNBbmNob3JFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdocmVmJyk7XG59XG4vKipcbiAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIGlucHV0IGVsZW1lbnQuXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09ICdpbnB1dCc7XG59XG4vKipcbiAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIGFuY2hvciBlbGVtZW50LlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0FuY2hvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2EnO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBoYXMgYSB2YWxpZCB0YWJpbmRleC5cbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaGFzVmFsaWRUYWJJbmRleChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCBlbGVtZW50LnRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIC8vIElFMTEgcGFyc2VzIHRhYmluZGV4PVwiXCIgYXMgdGhlIHZhbHVlIFwiLTMyNzY4XCJcbiAgICBpZiAodGFiSW5kZXggPT0gJy0zMjc2OCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gISEodGFiSW5kZXggJiYgIWlzTmFOKHBhcnNlSW50KHRhYkluZGV4LCAxMCkpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyc2VkIHRhYmluZGV4IGZyb20gdGhlIGVsZW1lbnQgYXR0cmlidXRlcyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVcbiAqIGV2YWx1YXRlZCB0YWJpbmRleCBmcm9tIHRoZSBicm93c2VycyBkZWZhdWx0cy5cbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0VGFiSW5kZXhWYWx1ZShlbGVtZW50KSB7XG4gICAgaWYgKCFoYXNWYWxpZFRhYkluZGV4KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTZWUgYnJvd3NlciBpc3N1ZSBpbiBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFiSW5kZXggPSBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAnJywgMTApO1xuICAgIHJldHVybiBpc05hTih0YWJJbmRleCkgPyAtMSA6IHRhYkluZGV4O1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaXMgcG90ZW50aWFsbHkgdGFiYmFibGUgb24gaU9TXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzUG90ZW50aWFsbHlUYWJiYWJsZUlPUyhlbGVtZW50KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXRUeXBlID0gbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgKChlbGVtZW50KSkudHlwZTtcbiAgICByZXR1cm4gaW5wdXRUeXBlID09PSAndGV4dCdcbiAgICAgICAgfHwgaW5wdXRUeXBlID09PSAncGFzc3dvcmQnXG4gICAgICAgIHx8IG5vZGVOYW1lID09PSAnc2VsZWN0J1xuICAgICAgICB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJztcbn1cbi8qKlxuICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgcG90ZW50aWFsbHkgZm9jdXNhYmxlIHdpdGhvdXQgdGFraW5nIGN1cnJlbnQgdmlzaWJsZS9kaXNhYmxlZCBzdGF0ZVxuICogaW50byBhY2NvdW50LlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1BvdGVudGlhbGx5Rm9jdXNhYmxlKGVsZW1lbnQpIHtcbiAgICAvLyBJbnB1dHMgYXJlIHBvdGVudGlhbGx5IGZvY3VzYWJsZSAqdW5sZXNzKiB0aGV5J3JlIHR5cGU9XCJoaWRkZW5cIi5cbiAgICBpZiAoaXNIaWRkZW5JbnB1dChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc05hdGl2ZUZvcm1FbGVtZW50KGVsZW1lbnQpIHx8XG4gICAgICAgIGlzQW5jaG9yV2l0aEhyZWYoZWxlbWVudCkgfHxcbiAgICAgICAgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpIHx8XG4gICAgICAgIGhhc1ZhbGlkVGFiSW5kZXgoZWxlbWVudCk7XG59XG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB3aW5kb3cgb2YgYSBET00gbm9kZSB3aXRoIHJlZ2FyZHMgb2YgYmVpbmcgaW5zaWRlIG9mIGFuIGlmcmFtZS5cbiAqIEBwYXJhbSB7P30gbm9kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn1cbi8qKlxuICogVXRpbGl0eSBjbGFzcyB1c2VkIHRvIGNoYWluIFJ4SlMgb3BlcmF0b3JzLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgdGhlIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uLCBidXQgdGhlIHR5cGUgdXNlZCBieSB0aGUgdXNlciB3aGVuIGNoYWluaW5nXG4gKiBpcyBTdHJpY3RSeENoYWluLiBUaGUgc3RyaWN0IGNoYWluIGVuZm9yY2VzIHR5cGVzIG9uIHRoZSBvcGVyYXRvcnMgdG8gdGhlIHNhbWUgbGV2ZWwgYXNcbiAqIHRoZSBwcm90b3R5cGUtYWRkZWQgZXF1aXZhbGVudHMuXG4gKi9cbnZhciBSeENoYWluID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfY29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJ4Q2hhaW4oX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IF9jb250ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgY2hhaW4gYW5kIHNwZWNpZmllcyB0aGUgaW5pdGlhbCBgdGhpc2AgdmFsdWUuXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHQgSW5pdGlhbCBgdGhpc2AgdmFsdWUgZm9yIHRoZSBjaGFpbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJ4Q2hhaW4uZnJvbSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUnhDaGFpbihjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludm9rZXMgYW4gUnhKUyBvcGVyYXRvciBhcyBhIHBhcnQgb2YgdGhlIGNoYWluLlxuICAgICAqIEBwYXJhbSB7P30gb3BlcmF0b3IgT3BlcmF0b3IgdG8gYmUgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0gey4uLj99IGFyZ3MgQXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgb3BlcmF0b3IuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSeENoYWluLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBvcGVyYXRvci5jYWxsLmFwcGx5KG9wZXJhdG9yLCBbdGhpcy5fY29udGV4dF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHRoZSByZXN1bHQgb2YgdGhlIGNoYWluLlxuICAgICAqIEBwYXJhbSB7P30gZm4gQ2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSByZXN1bHQgZW1pdHMgYSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJ4Q2hhaW4ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5zdWJzY3JpYmUoZm4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBjaGFpbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJ4Q2hhaW4ucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gUnhDaGFpbjtcbn0oKSk7XG52YXIgRmluYWxseUJyYW5kID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmluYWxseUJyYW5kKCkge1xuICAgIH1cbiAgICByZXR1cm4gRmluYWxseUJyYW5kO1xufSgpKTtcbnZhciBDYXRjaEJyYW5kID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0Y2hCcmFuZCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIENhdGNoQnJhbmQ7XG59KCkpO1xudmFyIERvQnJhbmQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb0JyYW5kKCkge1xuICAgIH1cbiAgICByZXR1cm4gRG9CcmFuZDtcbn0oKSk7XG52YXIgTWFwQnJhbmQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBCcmFuZCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1hcEJyYW5kO1xufSgpKTtcbnZhciBGaWx0ZXJCcmFuZCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbHRlckJyYW5kKCkge1xuICAgIH1cbiAgICByZXR1cm4gRmlsdGVyQnJhbmQ7XG59KCkpO1xudmFyIFNoYXJlQnJhbmQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaGFyZUJyYW5kKCkge1xuICAgIH1cbiAgICByZXR1cm4gU2hhcmVCcmFuZDtcbn0oKSk7XG52YXIgRmlyc3RCcmFuZCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpcnN0QnJhbmQoKSB7XG4gICAgfVxuICAgIHJldHVybiBGaXJzdEJyYW5kO1xufSgpKTtcbnZhciBTd2l0Y2hNYXBCcmFuZCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcEJyYW5kKCkge1xuICAgIH1cbiAgICByZXR1cm4gU3dpdGNoTWFwQnJhbmQ7XG59KCkpO1xudmFyIFN0YXJ0V2l0aEJyYW5kID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhcnRXaXRoQnJhbmQoKSB7XG4gICAgfVxuICAgIHJldHVybiBTdGFydFdpdGhCcmFuZDtcbn0oKSk7XG52YXIgRGVib3VuY2VUaW1lQnJhbmQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZVRpbWVCcmFuZCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIERlYm91bmNlVGltZUJyYW5kO1xufSgpKTtcbnZhciBBdWRpdFRpbWVCcmFuZCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1ZGl0VGltZUJyYW5kKCkge1xuICAgIH1cbiAgICByZXR1cm4gQXVkaXRUaW1lQnJhbmQ7XG59KCkpO1xudmFyIFRha2VVbnRpbEJyYW5kID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFrZVVudGlsQnJhbmQoKSB7XG4gICAgfVxuICAgIHJldHVybiBUYWtlVW50aWxCcmFuZDtcbn0oKSk7XG4vLyBXZSBhZGQgYEZ1bmN0aW9uYCB0byB0aGUgdHlwZSBpbnRlcnNlY3Rpb24gdG8gbWFrZSB0aGlzIG5vbWljYWxseSBkaWZmZXJlbnQgZnJvbVxuLy8gYGZpbmFsbHlPcGVyYXRvclR5cGVgIHdoaWxlIHN0aWxsIGJlaW5nIHN0cnVjdHVyYWxseSB0aGUgc2FtZS4gV2l0aG91dCB0aGlzLCBUeXBlU2NyaXB0IHRyaWVzIHRvXG4vLyByZWR1Y2UgYHR5cGVvZiBfZmluYWxseU9wZXJhdG9yICYgRmluYWxseUJyYW5kYCB0byBgZmluYWxseU9wZXJhdG9yVHlwZTxUPmAgYW5kIHRoZW4gZmFpbHNcbi8vIGJlY2F1c2UgYFRgIGlzbid0IGtub3duLlxudmFyIGZpbmFsbHlPcGVyYXRvciA9IChfZmluYWxseSk7XG52YXIgY2F0Y2hPcGVyYXRvciA9IChfY2F0Y2gpO1xudmFyIGRvT3BlcmF0b3IgPSAoX2RvKTtcbnZhciBtYXAkMSA9IChtYXApO1xudmFyIGZpbHRlciQxID0gKGZpbHRlcik7XG52YXIgc2hhcmUkMSA9IChzaGFyZSk7XG52YXIgZmlyc3QkMSA9IChmaXJzdCk7XG52YXIgc3dpdGNoTWFwJDEgPSAoc3dpdGNoTWFwKTtcbnZhciBzdGFydFdpdGgkMSA9IChzdGFydFdpdGgpO1xudmFyIGRlYm91bmNlVGltZSQxID0gKGRlYm91bmNlVGltZSk7XG52YXIgYXVkaXRUaW1lJDEgPSAoYXVkaXRUaW1lKTtcbnZhciB0YWtlVW50aWwkMSA9ICh0YWtlVW50aWwpO1xuLyoqXG4gKiBDbGFzcyB0aGF0IGFsbG93cyBmb3IgdHJhcHBpbmcgZm9jdXMgd2l0aGluIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBjdXJyZW50bHkgdXNlcyBhIHZlcnkgc2ltcGxlIChuYWl2ZSkgYXBwcm9hY2ggdG8gZm9jdXMgdHJhcHBpbmcuXG4gKiBJdCBhc3N1bWVzIHRoYXQgdGhlIHRhYiBvcmRlciBpcyB0aGUgc2FtZSBhcyBET00gb3JkZXIsIHdoaWNoIGlzIG5vdCBuZWNlc3NhcmlseSB0cnVlLlxuICogVGhpbmdzIGxpa2UgdGFiSW5kZXggPiAwLCBmbGV4IGBvcmRlcmAsIGFuZCBzaGFkb3cgcm9vdHMgY2FuIGNhdXNlIHRvIHR3byB0byBtaXNhbGlnbi5cbiAqIFRoaXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgbW9yZSBpbnRlbGxpZ2VudCBzb2x1dGlvbiBiZWZvcmUgdGhlIGxpYnJhcnkgaXMgY29uc2lkZXJlZCBzdGFibGUuXG4gKi9cbnZhciBGb2N1c1RyYXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBfcGxhdGZvcm1cbiAgICAgKiBAcGFyYW0gez99IF9jaGVja2VyXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/PX0gZGVmZXJBbmNob3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRm9jdXNUcmFwKF9lbGVtZW50LCBfcGxhdGZvcm0sIF9jaGVja2VyLCBfbmdab25lLCBkZWZlckFuY2hvcnMpIHtcbiAgICAgICAgaWYgKGRlZmVyQW5jaG9ycyA9PT0gdm9pZCAwKSB7IGRlZmVyQW5jaG9ycyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIHRoaXMuX2NoZWNrZXIgPSBfY2hlY2tlcjtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGlmICghZGVmZXJBbmNob3JzKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaEFuY2hvcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9jdXNUcmFwLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGZvY3VzIHRyYXAgaXMgYWN0aXZlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbmFibGVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHZhbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydEFuY2hvciAmJiB0aGlzLl9lbmRBbmNob3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEFuY2hvci50YWJJbmRleCA9IHRoaXMuX2VuZEFuY2hvci50YWJJbmRleCA9IHRoaXMuX2VuYWJsZWQgPyAwIDogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBmb2N1cyB0cmFwIGJ5IGNsZWFuaW5nIHVwIHRoZSBhbmNob3JzLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNUcmFwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhcnRBbmNob3IgJiYgdGhpcy5fc3RhcnRBbmNob3IucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRBbmNob3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9zdGFydEFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2VuZEFuY2hvciAmJiB0aGlzLl9lbmRBbmNob3IucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fZW5kQW5jaG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZW5kQW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGFydEFuY2hvciA9IHRoaXMuX2VuZEFuY2hvciA9IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHRoZSBhbmNob3JzIGludG8gdGhlIERPTS4gVGhpcyBpcyB1c3VhbGx5IGRvbmUgYXV0b21hdGljYWxseVxuICAgICAqIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGNhbiBiZSBkZWZlcnJlZCBmb3IgY2FzZXMgbGlrZSBkaXJlY3RpdmVzIHdpdGggYCpuZ0lmYC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuYXR0YWNoQW5jaG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IG9uIHRoZSBicm93c2VyLCB0aGVyZSBjYW4gYmUgbm8gZm9jdXMgdG8gdHJhcC5cbiAgICAgICAgaWYgKCF0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0QW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydEFuY2hvciA9IHRoaXMuX2NyZWF0ZUFuY2hvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW5kQW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmRBbmNob3IgPSB0aGlzLl9jcmVhdGVBbmNob3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgKChfdGhpcy5fc3RhcnRBbmNob3IpKS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudCgpOyB9KTsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgKChfdGhpcy5fZW5kQW5jaG9yKSkuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5mb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50KCk7IH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgvKiogQHR5cGUgez99ICovICgoX3RoaXMuX3N0YXJ0QW5jaG9yKSksIF90aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgvKiogQHR5cGUgez99ICovICgoX3RoaXMuX2VuZEFuY2hvcikpLCBfdGhpcy5fZWxlbWVudC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIHRoZSB6b25lIHRvIHN0YWJpbGl6ZSwgdGhlbiBlaXRoZXIgZm9jdXNlcyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHRoZVxuICAgICAqIHVzZXIgc3BlY2lmaWVkLCBvciB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudC4uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzSW5pdGlhbEVsZW1lbnRXaGVuUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2V4ZWN1dGVPblN0YWJsZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5mb2N1c0luaXRpYWxFbGVtZW50KCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIHRoZSB6b25lIHRvIHN0YWJpbGl6ZSwgdGhlbiBmb2N1c2VzXG4gICAgICogdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBmb2N1cyB0cmFwIHJlZ2lvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudFdoZW5SZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZXhlY3V0ZU9uU3RhYmxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIHpvbmUgdG8gc3RhYmlsaXplLCB0aGVuIGZvY3VzZXNcbiAgICAgKiB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudFdoZW5SZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZXhlY3V0ZU9uU3RhYmxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3BlY2lmaWVkIGJvdW5kYXJ5IGVsZW1lbnQgb2YgdGhlIHRyYXBwZWQgcmVnaW9uLlxuICAgICAqIEBwYXJhbSB7P30gYm91bmQgVGhlIGJvdW5kYXJ5IHRvIGdldCAoc3RhcnQgb3IgZW5kIG9mIHRyYXBwZWQgcmVnaW9uKS5cbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgYm91bmRhcnkgZWxlbWVudC5cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLl9nZXRSZWdpb25Cb3VuZGFyeSA9IGZ1bmN0aW9uIChib3VuZCkge1xuICAgICAgICAvLyBDb250YWlucyB0aGUgZGVwcmVjYXRlZCB2ZXJzaW9uIG9mIHNlbGVjdG9yLCBmb3IgdGVtcG9yYXJ5IGJhY2t3YXJkcyBjb21wYXJhYmlsaXR5LlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXJrZXJzID0gKHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltjZGstZm9jdXMtcmVnaW9uLVwiICsgYm91bmQgKyBcIl0sIFwiICtcbiAgICAgICAgICAgIChcIltjZGstZm9jdXMtXCIgKyBib3VuZCArIFwiXVwiKSkpO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcmtlcnNbaV0uaGFzQXR0cmlidXRlKFwiY2RrLWZvY3VzLVwiICsgYm91bmQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRm91bmQgdXNlIG9mIGRlcHJlY2F0ZWQgYXR0cmlidXRlICdjZGstZm9jdXMtXCIgKyBib3VuZCArIFwiJyxcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIiB1c2UgJ2Nkay1mb2N1cy1yZWdpb24tXCIgKyBib3VuZCArIFwiJyBpbnN0ZWFkLlwiKSwgbWFya2Vyc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdW5kID09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJzLmxlbmd0aCA/IG1hcmtlcnNbMF0gOiB0aGlzLl9nZXRGaXJzdFRhYmJhYmxlRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya2Vycy5sZW5ndGggP1xuICAgICAgICAgICAgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdIDogdGhpcy5fZ2V0TGFzdFRhYmJhYmxlRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgZm9jdXNlZCB3aGVuIHRoZSBmb2N1cyB0cmFwIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNUcmFwLnByb3RvdHlwZS5mb2N1c0luaXRpYWxFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWRpcmVjdFRvRWxlbWVudCA9ICh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tjZGstZm9jdXMtaW5pdGlhbF0nKSk7XG4gICAgICAgIGlmIChyZWRpcmVjdFRvRWxlbWVudCkge1xuICAgICAgICAgICAgcmVkaXJlY3RUb0VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZGlyZWN0VG9FbGVtZW50ID0gdGhpcy5fZ2V0UmVnaW9uQm91bmRhcnkoJ3N0YXJ0Jyk7XG4gICAgICAgIGlmIChyZWRpcmVjdFRvRWxlbWVudCkge1xuICAgICAgICAgICAgcmVkaXJlY3RUb0VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVkaXJlY3RUb0VsZW1lbnQgPSB0aGlzLl9nZXRSZWdpb25Cb3VuZGFyeSgnZW5kJyk7XG4gICAgICAgIGlmIChyZWRpcmVjdFRvRWxlbWVudCkge1xuICAgICAgICAgICAgcmVkaXJlY3RUb0VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IGZyb20gYSBET00gc3VidHJlZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0gez99IHJvb3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuX2dldEZpcnN0VGFiYmFibGVFbGVtZW50ID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrZXIuaXNGb2N1c2FibGUocm9vdCkgJiYgdGhpcy5fY2hlY2tlci5pc1RhYmJhYmxlKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRlIGluIERPTSBvcmRlci4gTm90ZSB0aGF0IElFIGRvZXNuJ3QgaGF2ZSBgY2hpbGRyZW5gIGZvciBTVkcgc28gd2UgZmFsbFxuICAgICAgICAvLyBiYWNrIHRvIGBjaGlsZE5vZGVzYCB3aGljaCBpbmNsdWRlcyB0ZXh0IG5vZGVzLCBjb21tZW50cyBldGMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbiB8fCByb290LmNoaWxkTm9kZXM7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFiYmFibGVDaGlsZCA9IGNoaWxkcmVuW2ldLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Rmlyc3RUYWJiYWJsZUVsZW1lbnQoLyoqIEB0eXBlIHs/fSAqLyAoY2hpbGRyZW5baV0pKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIGlmICh0YWJiYWJsZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmJhYmxlQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxhc3QgdGFiYmFibGUgZWxlbWVudCBmcm9tIGEgRE9NIHN1YnRyZWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHs/fSByb290XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLl9nZXRMYXN0VGFiYmFibGVFbGVtZW50ID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrZXIuaXNGb2N1c2FibGUocm9vdCkgJiYgdGhpcy5fY2hlY2tlci5pc1RhYmJhYmxlKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRlIGluIHJldmVyc2UgRE9NIG9yZGVyLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHJvb3QuY2hpbGRyZW4gfHwgcm9vdC5jaGlsZE5vZGVzO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFiYmFibGVDaGlsZCA9IGNoaWxkcmVuW2ldLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0TGFzdFRhYmJhYmxlRWxlbWVudCgvKiogQHR5cGUgez99ICovIChjaGlsZHJlbltpXSkpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFiYmFibGVDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5jaG9yIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLl9jcmVhdGVBbmNob3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhbmNob3IudGFiSW5kZXggPSB0aGlzLl9lbmFibGVkID8gMCA6IC0xO1xuICAgICAgICBhbmNob3IuY2xhc3NMaXN0LmFkZCgnY2RrLXZpc3VhbGx5LWhpZGRlbicpO1xuICAgICAgICBhbmNob3IuY2xhc3NMaXN0LmFkZCgnY2RrLWZvY3VzLXRyYXAtYW5jaG9yJyk7XG4gICAgICAgIHJldHVybiBhbmNob3I7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIGZ1bmN0aW9uIHdoZW4gdGhlIHpvbmUgaXMgc3RhYmxlLlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuX2V4ZWN1dGVPblN0YWJsZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodGhpcy5fbmdab25lLmlzU3RhYmxlKSB7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlyc3QkMS5jYWxsKHRoaXMuX25nWm9uZS5vblN0YWJsZSkuc3Vic2NyaWJlKGZuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZvY3VzVHJhcDtcbn0oKSk7XG4vKipcbiAqIEZhY3RvcnkgdGhhdCBhbGxvd3MgZWFzeSBpbnN0YW50aWF0aW9uIG9mIGZvY3VzIHRyYXBzLlxuICovXG52YXIgRm9jdXNUcmFwRmFjdG9yeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2NoZWNrZXJcbiAgICAgKiBAcGFyYW0gez99IF9wbGF0Zm9ybVxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZvY3VzVHJhcEZhY3RvcnkoX2NoZWNrZXIsIF9wbGF0Zm9ybSwgX25nWm9uZSkge1xuICAgICAgICB0aGlzLl9jaGVja2VyID0gX2NoZWNrZXI7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gX3BsYXRmb3JtO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBkZWZlckFuY2hvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBkZWZlckFuY2hvcnMpIHtcbiAgICAgICAgaWYgKGRlZmVyQW5jaG9ycyA9PT0gdm9pZCAwKSB7IGRlZmVyQW5jaG9ycyA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBuZXcgRm9jdXNUcmFwKGVsZW1lbnQsIHRoaXMuX3BsYXRmb3JtLCB0aGlzLl9jaGVja2VyLCB0aGlzLl9uZ1pvbmUsIGRlZmVyQW5jaG9ycyk7XG4gICAgfTtcbiAgICByZXR1cm4gRm9jdXNUcmFwRmFjdG9yeTtcbn0oKSk7XG5Gb2N1c1RyYXBGYWN0b3J5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Gb2N1c1RyYXBGYWN0b3J5LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogSW50ZXJhY3Rpdml0eUNoZWNrZXIsIH0sXG4gICAgeyB0eXBlOiBQbGF0Zm9ybSwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbl07IH07XG4vKipcbiAqIERpcmVjdGl2ZSBmb3IgdHJhcHBpbmcgZm9jdXMgd2l0aGluIGEgcmVnaW9uLlxuICogQGRlcHJlY2F0ZWRcbiAqL1xudmFyIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBfZm9jdXNUcmFwRmFjdG9yeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUoX2VsZW1lbnRSZWYsIF9mb2N1c1RyYXBGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fZm9jdXNUcmFwRmFjdG9yeSA9IF9mb2N1c1RyYXBGYWN0b3J5O1xuICAgICAgICB0aGlzLmZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb2N1c1RyYXBEZXByZWNhdGVkRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBmb2N1cyB0cmFwIGlzIGFjdGl2ZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuZm9jdXNUcmFwLmVuYWJsZWQ7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5lbmFibGVkID0gIWNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvY3VzVHJhcC5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAuYXR0YWNoQW5jaG9ycygpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmU7XG59KCkpO1xuRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnY2RrLWZvY3VzLXRyYXAnLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Gb2N1c1RyYXBEZXByZWNhdGVkRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IEZvY3VzVHJhcEZhY3RvcnksIH0sXG5dOyB9O1xuRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgZm9yIHRyYXBwaW5nIGZvY3VzIHdpdGhpbiBhIHJlZ2lvbi5cbiAqL1xudmFyIEZvY3VzVHJhcERpcmVjdGl2ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c1RyYXBGYWN0b3J5XG4gICAgICovXG4gICAgZnVuY3Rpb24gRm9jdXNUcmFwRGlyZWN0aXZlKF9lbGVtZW50UmVmLCBfZm9jdXNUcmFwRmFjdG9yeSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkgPSBfZm9jdXNUcmFwRmFjdG9yeTtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAgPSB0aGlzLl9mb2N1c1RyYXBGYWN0b3J5LmNyZWF0ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRydWUpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9jdXNUcmFwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGZvY3VzIHRyYXAgaXMgYWN0aXZlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvY3VzVHJhcC5lbmFibGVkOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5mb2N1c1RyYXAuZW5hYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRm9jdXNUcmFwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAuZGVzdHJveSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c1RyYXBEaXJlY3RpdmUucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAuYXR0YWNoQW5jaG9ycygpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvY3VzVHJhcERpcmVjdGl2ZTtcbn0oKSk7XG5Gb2N1c1RyYXBEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGtUcmFwRm9jdXNdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ2Nka1RyYXBGb2N1cycsXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkZvY3VzVHJhcERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgeyB0eXBlOiBGb2N1c1RyYXBGYWN0b3J5LCB9LFxuXTsgfTtcbkZvY3VzVHJhcERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnZW5hYmxlZCc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2Nka1RyYXBGb2N1cycsXSB9LF0sXG59O1xudmFyIExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ2xpdmVBbm5vdW5jZXJFbGVtZW50Jyk7XG52YXIgTGl2ZUFubm91bmNlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFRva2VuXG4gICAgICogQHBhcmFtIHs/fSBwbGF0Zm9ybVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdmVBbm5vdW5jZXIoZWxlbWVudFRva2VuLCBwbGF0Zm9ybSkge1xuICAgICAgICAvLyBPbmx5IGRvIGFueXRoaW5nIGlmIHdlJ3JlIG9uIHRoZSBicm93c2VyIHBsYXRmb3JtLlxuICAgICAgICBpZiAocGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAvLyBXZSBpbmplY3QgdGhlIGxpdmUgZWxlbWVudCBhcyBgYW55YCBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBzaWduYXR1cmUgY2Fubm90IHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gYnJvd3NlciBnbG9iYWxzIChIVE1MRWxlbWVudCkgb24gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLCBzaW5jZSBoYXZpbmcgYSBjbGFzcyBkZWNvcmF0b3JcbiAgICAgICAgICAgIC8vIGNhdXNlcyBUeXBlU2NyaXB0IHRvIHByZXNlcnZlIHRoZSBjb25zdHJ1Y3RvciBzaWduYXR1cmUgdHlwZXMuXG4gICAgICAgICAgICB0aGlzLl9saXZlRWxlbWVudCA9IGVsZW1lbnRUb2tlbiB8fCB0aGlzLl9jcmVhdGVMaXZlRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFubm91bmNlcyBhIG1lc3NhZ2UgdG8gc2NyZWVucmVhZGVycy5cbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2UgTWVzc2FnZSB0byBiZSBhbm5vdW5jZWQgdG8gdGhlIHNjcmVlbnJlYWRlclxuICAgICAqIEBwYXJhbSB7Pz19IHBvbGl0ZW5lc3MgVGhlIHBvbGl0ZW5lc3Mgb2YgdGhlIGFubm91bmNlciBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXZlQW5ub3VuY2VyLnByb3RvdHlwZS5hbm5vdW5jZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwb2xpdGVuZXNzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChwb2xpdGVuZXNzID09PSB2b2lkIDApIHsgcG9saXRlbmVzcyA9ICdwb2xpdGUnOyB9XG4gICAgICAgIHRoaXMuX2xpdmVFbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgIC8vIFRPRE86IGVuc3VyZSBjaGFuZ2luZyB0aGUgcG9saXRlbmVzcyB3b3JrcyBvbiBhbGwgZW52aXJvbm1lbnRzIHdlIHN1cHBvcnQuXG4gICAgICAgIHRoaXMuX2xpdmVFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgcG9saXRlbmVzcyk7XG4gICAgICAgIC8vIFRoaXMgMTAwbXMgdGltZW91dCBpcyBuZWNlc3NhcnkgZm9yIHNvbWUgYnJvd3NlciArIHNjcmVlbi1yZWFkZXIgY29tYmluYXRpb25zOlxuICAgICAgICAvLyAtIEJvdGggSkFXUyBhbmQgTlZEQSBvdmVyIElFMTEgd2lsbCBub3QgYW5ub3VuY2UgYW55dGhpbmcgd2l0aG91dCBhIG5vbi16ZXJvIHRpbWVvdXQuXG4gICAgICAgIC8vIC0gV2l0aCBDaHJvbWUgYW5kIElFMTEgd2l0aCBOVkRBIG9yIEpBV1MsIGEgcmVwZWF0ZWQgKGlkZW50aWNhbCkgbWVzc2FnZSB3b24ndCBiZSByZWFkIGFcbiAgICAgICAgLy8gICBzZWNvbmQgdGltZSB3aXRob3V0IGNsZWFyaW5nIGFuZCB0aGVuIHVzaW5nIGEgbm9uLXplcm8gZGVsYXkuXG4gICAgICAgIC8vICh1c2luZyBKQVdTIDE3IGF0IHRpbWUgb2YgdGhpcyB3cml0aW5nKS5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbGl2ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlOyB9LCAxMDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgYXJpYS1saXZlIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl2ZUFubm91bmNlci5wcm90b3R5cGUuX3JlbW92ZUxpdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGl2ZUVsZW1lbnQgJiYgdGhpcy5fbGl2ZUVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbGl2ZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9saXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl2ZUFubm91bmNlci5wcm90b3R5cGUuX2NyZWF0ZUxpdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXZlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbGl2ZUVsLmNsYXNzTGlzdC5hZGQoJ2Nkay12aXN1YWxseS1oaWRkZW4nKTtcbiAgICAgICAgbGl2ZUVsLnNldEF0dHJpYnV0ZSgnYXJpYS1hdG9taWMnLCAndHJ1ZScpO1xuICAgICAgICBsaXZlRWwuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGl2ZUVsKTtcbiAgICAgICAgcmV0dXJuIGxpdmVFbDtcbiAgICB9O1xuICAgIHJldHVybiBMaXZlQW5ub3VuY2VyO1xufSgpKTtcbkxpdmVBbm5vdW5jZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkxpdmVBbm5vdW5jZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTixdIH0sXSB9LFxuICAgIHsgdHlwZTogUGxhdGZvcm0sIH0sXG5dOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHBhcmVudERpc3BhdGNoZXJcbiAqIEBwYXJhbSB7P30gbGl2ZUVsZW1lbnRcbiAqIEBwYXJhbSB7P30gcGxhdGZvcm1cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSX0ZBQ1RPUlkocGFyZW50RGlzcGF0Y2hlciwgbGl2ZUVsZW1lbnQsIHBsYXRmb3JtKSB7XG4gICAgcmV0dXJuIHBhcmVudERpc3BhdGNoZXIgfHwgbmV3IExpdmVBbm5vdW5jZXIobGl2ZUVsZW1lbnQsIHBsYXRmb3JtKTtcbn1cbnZhciBMSVZFX0FOTk9VTkNFUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgTGl2ZUFubm91bmNlciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IExpdmVBbm5vdW5jZXIsXG4gICAgZGVwczogW1xuICAgICAgICBbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBMaXZlQW5ub3VuY2VyXSxcbiAgICAgICAgW25ldyBPcHRpb25hbCgpLCBuZXcgSW5qZWN0KExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4pXSxcbiAgICAgICAgUGxhdGZvcm0sXG4gICAgXSxcbiAgICB1c2VGYWN0b3J5OiBMSVZFX0FOTk9VTkNFUl9QUk9WSURFUl9GQUNUT1JZXG59O1xuLyoqXG4gKiBDYWNoZWQgcmVzdWx0IFNldCBvZiBpbnB1dCB0eXBlcyBzdXBwb3J0IGJ5IHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xuLyoqXG4gKiBUeXBlcyBvZiA8aW5wdXQ+IHRoYXQgKm1pZ2h0KiBiZSBzdXBwb3J0ZWQuXG4gKi9cbnZhciBjYW5kaWRhdGVJbnB1dFR5cGVzID0gW1xuICAgIC8vIGBjb2xvcmAgbXVzdCBjb21lIGZpcnN0LiBDaHJvbWUgNTYgc2hvd3MgYSB3YXJuaW5nIGlmIHdlIGNoYW5nZSB0aGUgdHlwZSB0byBgY29sb3JgIGFmdGVyXG4gICAgLy8gZmlyc3QgY2hhbmdpbmcgaXQgdG8gc29tZXRoaW5nIGVsc2U6XG4gICAgLy8gVGhlIHNwZWNpZmllZCB2YWx1ZSBcIlwiIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIHJlcXVpcmVkIGZvcm1hdC5cbiAgICAvLyBUaGUgZm9ybWF0IGlzIFwiI3JyZ2diYlwiIHdoZXJlIHJyLCBnZywgYmIgYXJlIHR3by1kaWdpdCBoZXhhZGVjaW1hbCBudW1iZXJzLlxuICAgICdjb2xvcicsXG4gICAgJ2J1dHRvbicsXG4gICAgJ2NoZWNrYm94JyxcbiAgICAnZGF0ZScsXG4gICAgJ2RhdGV0aW1lLWxvY2FsJyxcbiAgICAnZW1haWwnLFxuICAgICdmaWxlJyxcbiAgICAnaGlkZGVuJyxcbiAgICAnaW1hZ2UnLFxuICAgICdtb250aCcsXG4gICAgJ251bWJlcicsXG4gICAgJ3Bhc3N3b3JkJyxcbiAgICAncmFkaW8nLFxuICAgICdyYW5nZScsXG4gICAgJ3Jlc2V0JyxcbiAgICAnc2VhcmNoJyxcbiAgICAnc3VibWl0JyxcbiAgICAndGVsJyxcbiAgICAndGV4dCcsXG4gICAgJ3RpbWUnLFxuICAgICd1cmwnLFxuICAgICd3ZWVrJyxcbl07XG4vKipcbiAqIEByZXR1cm4gez99IFRoZSBpbnB1dCB0eXBlcyBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRJbnB1dFR5cGVzKCkge1xuICAgIC8vIFJlc3VsdCBpcyBjYWNoZWQuXG4gICAgaWYgKHN1cHBvcnRlZElucHV0VHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZElucHV0VHlwZXM7XG4gICAgfVxuICAgIC8vIFdlIGNhbid0IGNoZWNrIGlmIGFuIGlucHV0IHR5cGUgaXMgbm90IHN1cHBvcnRlZCB1bnRpbCB3ZSdyZSBvbiB0aGUgYnJvd3Nlciwgc28gc2F5IHRoYXRcbiAgICAvLyBldmVyeXRoaW5nIGlzIHN1cHBvcnRlZCB3aGVuIG5vdCBvbiB0aGUgYnJvd3Nlci4gV2UgZG9uJ3QgdXNlIGBQbGF0Zm9ybWAgaGVyZSBzaW5jZSBpdCdzXG4gICAgLy8ganVzdCBhIGhlbHBlciBmdW5jdGlvbiBhbmQgY2FuJ3QgaW5qZWN0IGl0LlxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICdvYmplY3QnIHx8ICFkb2N1bWVudCkge1xuICAgICAgICBzdXBwb3J0ZWRJbnB1dFR5cGVzID0gbmV3IFNldChjYW5kaWRhdGVJbnB1dFR5cGVzKTtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZElucHV0VHlwZXM7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZlYXR1cmVUZXN0SW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHN1cHBvcnRlZElucHV0VHlwZXMgPSBuZXcgU2V0KGNhbmRpZGF0ZUlucHV0VHlwZXMuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBmZWF0dXJlVGVzdElucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVUZXN0SW5wdXQudHlwZSA9PT0gdmFsdWU7XG4gICAgfSkpO1xuICAgIHJldHVybiBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xufVxudmFyIFBsYXRmb3JtTW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhdGZvcm1Nb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBQbGF0Zm9ybU1vZHVsZTtcbn0oKSk7XG5QbGF0Zm9ybU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUGxhdGZvcm1dXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblBsYXRmb3JtTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFNjcmVlbnJlYWRlcnMgd2lsbCBvZnRlbiBmaXJlIGZha2UgbW91c2Vkb3duIGV2ZW50cyB3aGVuIGEgZm9jdXNhYmxlIGVsZW1lbnRcbiAqIGlzIGFjdGl2YXRlZCB1c2luZyB0aGUga2V5Ym9hcmQuIFdlIGNhbiB0eXBpY2FsbHkgZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVzZSBmYWtlZFxuICogbW91c2Vkb3duIGV2ZW50cyBhbmQgcmVhbCBtb3VzZWRvd24gZXZlbnRzIHVzaW5nIHRoZSBcImJ1dHRvbnNcIiBwcm9wZXJ0eS4gV2hpbGVcbiAqIHJlYWwgbW91c2Vkb3ducyB3aWxsIGluZGljYXRlIHRoZSBtb3VzZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZCAoZS5nLiBcIjFcIiBmb3JcbiAqIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiksIGZha2VkIG1vdXNlZG93bnMgd2lsbCB1c3VhbGx5IHNldCB0aGUgcHJvcGVydHkgdmFsdWUgdG8gMC5cbiAqIEBwYXJhbSB7P30gZXZlbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuYnV0dG9ucyA9PT0gMDtcbn1cbnZhciBVUF9BUlJPVyA9IDM4O1xudmFyIERPV05fQVJST1cgPSA0MDtcbnZhciBSSUdIVF9BUlJPVyA9IDM5O1xudmFyIExFRlRfQVJST1cgPSAzNztcbnZhciBQQUdFX1VQID0gMzM7XG52YXIgUEFHRV9ET1dOID0gMzQ7XG52YXIgSE9NRSA9IDM2O1xudmFyIEVORCA9IDM1O1xudmFyIEVOVEVSID0gMTM7XG52YXIgU1BBQ0UgPSAzMjtcbnZhciBUQUIgPSA5O1xudmFyIEVTQ0FQRSA9IDI3O1xudmFyIEJBQ0tTUEFDRSA9IDg7XG52YXIgREVMRVRFID0gNDY7XG4vKipcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBrZXlib2FyZCBldmVudHMgZm9yIHNlbGVjdGFibGUgbGlzdHMuIElmIHlvdSBwYXNzIGl0IGEgcXVlcnkgbGlzdFxuICogb2YgaXRlbXMsIGl0IHdpbGwgc2V0IHRoZSBhY3RpdmUgaXRlbSBjb3JyZWN0bHkgd2hlbiBhcnJvdyBldmVudHMgb2NjdXIuXG4gKi9cbnZhciBMaXN0S2V5TWFuYWdlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2l0ZW1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdEtleU1hbmFnZXIoX2l0ZW1zKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gX2l0ZW1zO1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fdGFiT3V0ID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5fd3JhcCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUdXJucyBvbiB3cmFwcGluZyBtb2RlLCB3aGljaCBlbnN1cmVzIHRoYXQgdGhlIGFjdGl2ZSBpdGVtIHdpbGwgd3JhcCB0b1xuICAgICAqIHRoZSBvdGhlciBlbmQgb2YgbGlzdCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGl0ZW1zIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgTGlzdEtleU1hbmFnZXIgdGhhdCB0aGUgbWV0aG9kIHdhcyBjYWxsZWQgb24uXG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLndpdGhXcmFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl93cmFwID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgaXRlbSBhdCB0aGUgaW5kZXggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gdG8gYmUgc2V0IGFzIGFjdGl2ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS5zZXRBY3RpdmVJdGVtID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtID0gdGhpcy5faXRlbXMudG9BcnJheSgpW2luZGV4XTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIGRlcGVuZGluZyBvbiB0aGUga2V5IGV2ZW50IHBhc3NlZCBpbi5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50IEtleWJvYXJkIGV2ZW50IHRvIGJlIHVzZWQgZm9yIGRldGVybWluaW5nIHdoaWNoIGVsZW1lbnQgc2hvdWxkIGJlIGFjdGl2ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS5vbktleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROZXh0SXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBVUF9BUlJPVzpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByZXZpb3VzSXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUQUI6XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIHNob3VsZG4ndCBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiBvbiB0YWIuXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFiT3V0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZSwgXCJhY3RpdmVJdGVtSW5kZXhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kZXggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgaXRlbS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZSwgXCJhY3RpdmVJdGVtXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3RpdmUgaXRlbS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUl0ZW07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBmaXJzdCBlbmFibGVkIGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0Rmlyc3RJdGVtQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtQnlJbmRleCgwLCAxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBsYXN0IGVuYWJsZWQgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS5zZXRMYXN0SXRlbUFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlSXRlbUJ5SW5kZXgodGhpcy5faXRlbXMubGVuZ3RoIC0gMSwgLTEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIG5leHQgZW5hYmxlZCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLnNldE5leHRJdGVtQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPCAwID8gdGhpcy5zZXRGaXJzdEl0ZW1BY3RpdmUoKSA6IHRoaXMuX3NldEFjdGl2ZUl0ZW1CeURlbHRhKDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gYSBwcmV2aW91cyBlbmFibGVkIGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0UHJldmlvdXNJdGVtQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPCAwICYmIHRoaXMuX3dyYXAgPyB0aGlzLnNldExhc3RJdGVtQWN0aXZlKClcbiAgICAgICAgICAgIDogdGhpcy5fc2V0QWN0aXZlSXRlbUJ5RGVsdGEoLTEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHNldHRpbmcgb2YgdGhlIGFjdGl2ZUl0ZW1JbmRleCB3aXRob3V0IGFueSBvdGhlciBlZmZlY3RzLlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXggVGhlIG5ldyBhY3RpdmVJdGVtSW5kZXguXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUudXBkYXRlQWN0aXZlSXRlbUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZSwgXCJ0YWJPdXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFueSB0aW1lIHRoZSBUQUIga2V5IGlzIHByZXNzZWQsIHNvIGNvbXBvbmVudHMgY2FuIHJlYWN0XG4gICAgICAgICAqIHdoZW4gZm9jdXMgaXMgc2hpZnRlZCBvZmYgb2YgdGhlIGxpc3QuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YWJPdXQuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGFjdGl2ZSBpdGVtLCBnaXZlbiBhIGxpc3Qgb2YgaXRlbXMgYW5kIHRoZSBkZWx0YSBiZXR3ZWVuIHRoZVxuICAgICAqIGN1cnJlbnRseSBhY3RpdmUgaXRlbSBhbmQgdGhlIG5ldyBhY3RpdmUgaXRlbS4gSXQgd2lsbCBjYWxjdWxhdGUgZGlmZmVyZW50bHlcbiAgICAgKiBkZXBlbmRpbmcgb24gd2hldGhlciB3cmFwIG1vZGUgaXMgdHVybmVkIG9uLlxuICAgICAqIEBwYXJhbSB7P30gZGVsdGFcbiAgICAgKiBAcGFyYW0gez89fSBpdGVtc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLl9zZXRBY3RpdmVJdGVtQnlEZWx0YSA9IGZ1bmN0aW9uIChkZWx0YSwgaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSB0aGlzLl9pdGVtcy50b0FycmF5KCk7IH1cbiAgICAgICAgdGhpcy5fd3JhcCA/IHRoaXMuX3NldEFjdGl2ZUluV3JhcE1vZGUoZGVsdGEsIGl0ZW1zKVxuICAgICAgICAgICAgOiB0aGlzLl9zZXRBY3RpdmVJbkRlZmF1bHRNb2RlKGRlbHRhLCBpdGVtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSBwcm9wZXJseSBnaXZlbiBcIndyYXBcIiBtb2RlLiBJbiBvdGhlciB3b3JkcywgaXQgd2lsbCBjb250aW51ZSB0byBtb3ZlXG4gICAgICogZG93biB0aGUgbGlzdCB1bnRpbCBpdCBmaW5kcyBhbiBpdGVtIHRoYXQgaXMgbm90IGRpc2FibGVkLCBhbmQgaXQgd2lsbCB3cmFwIGlmIGl0XG4gICAgICogZW5jb3VudGVycyBlaXRoZXIgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7P30gZGVsdGFcbiAgICAgKiBAcGFyYW0gez99IGl0ZW1zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuX3NldEFjdGl2ZUluV3JhcE1vZGUgPSBmdW5jdGlvbiAoZGVsdGEsIGl0ZW1zKSB7XG4gICAgICAgIC8vIHdoZW4gYWN0aXZlIGl0ZW0gd291bGQgbGVhdmUgbWVudSwgd3JhcCB0byBiZWdpbm5pbmcgb3IgZW5kXG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9XG4gICAgICAgICAgICAodGhpcy5fYWN0aXZlSXRlbUluZGV4ICsgZGVsdGEgKyBpdGVtcy5sZW5ndGgpICUgaXRlbXMubGVuZ3RoO1xuICAgICAgICAvLyBza2lwIGFsbCBkaXNhYmxlZCBtZW51IGl0ZW1zIHJlY3Vyc2l2ZWx5IHVudGlsIGFuIGVuYWJsZWQgb25lIGlzIHJlYWNoZWRcbiAgICAgICAgaWYgKGl0ZW1zW3RoaXMuX2FjdGl2ZUl0ZW1JbmRleF0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZUluV3JhcE1vZGUoZGVsdGEsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlSXRlbSh0aGlzLl9hY3RpdmVJdGVtSW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSBwcm9wZXJseSBnaXZlbiB0aGUgZGVmYXVsdCBtb2RlLiBJbiBvdGhlciB3b3JkcywgaXQgd2lsbFxuICAgICAqIGNvbnRpbnVlIHRvIG1vdmUgZG93biB0aGUgbGlzdCB1bnRpbCBpdCBmaW5kcyBhbiBpdGVtIHRoYXQgaXMgbm90IGRpc2FibGVkLiBJZlxuICAgICAqIGl0IGVuY291bnRlcnMgZWl0aGVyIGVuZCBvZiB0aGUgbGlzdCwgaXQgd2lsbCBzdG9wIGFuZCBub3Qgd3JhcC5cbiAgICAgKiBAcGFyYW0gez99IGRlbHRhXG4gICAgICogQHBhcmFtIHs/fSBpdGVtc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLl9zZXRBY3RpdmVJbkRlZmF1bHRNb2RlID0gZnVuY3Rpb24gKGRlbHRhLCBpdGVtcykge1xuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtQnlJbmRleCh0aGlzLl9hY3RpdmVJdGVtSW5kZXggKyBkZWx0YSwgZGVsdGEsIGl0ZW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBmaXJzdCBlbmFibGVkIGl0ZW0gc3RhcnRpbmcgYXQgdGhlIGluZGV4IHNwZWNpZmllZC4gSWYgdGhlXG4gICAgICogaXRlbSBpcyBkaXNhYmxlZCwgaXQgd2lsbCBtb3ZlIGluIHRoZSBmYWxsYmFja0RlbHRhIGRpcmVjdGlvbiB1bnRpbCBpdCBlaXRoZXJcbiAgICAgKiBmaW5kcyBhbiBlbmFibGVkIGl0ZW0gb3IgZW5jb3VudGVycyB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcGFyYW0gez99IGZhbGxiYWNrRGVsdGFcbiAgICAgKiBAcGFyYW0gez89fSBpdGVtc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLl9zZXRBY3RpdmVJdGVtQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgZmFsbGJhY2tEZWx0YSwgaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSB0aGlzLl9pdGVtcy50b0FycmF5KCk7IH1cbiAgICAgICAgaWYgKCFpdGVtc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXRlbXNbaW5kZXhdLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpbmRleCArPSBmYWxsYmFja0RlbHRhO1xuICAgICAgICAgICAgaWYgKCFpdGVtc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXN0S2V5TWFuYWdlcjtcbn0oKSk7XG52YXIgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEl0IGFsc28gYWRkcyBhY3RpdmUgc3R5bGVzIHRvIHRoZSBuZXdseSBhY3RpdmUgaXRlbSBhbmQgcmVtb3ZlcyBhY3RpdmVcbiAgICAgKiBzdHlsZXMgZnJvbSB0aGUgcHJldmlvdXNseSBhY3RpdmUgaXRlbS5cbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlSXRlbS5zZXRJbmFjdGl2ZVN0eWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXRBY3RpdmVJdGVtLmNhbGwoX3RoaXMsIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlSXRlbS5zZXRBY3RpdmVTdHlsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXI7XG59KExpc3RLZXlNYW5hZ2VyKSk7XG52YXIgRm9jdXNLZXlNYW5hZ2VyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRm9jdXNLZXlNYW5hZ2VyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXRlbXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGb2N1c0tleU1hbmFnZXIoaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGl0ZW1zKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEl0IGFsc28gYWRkcyBmb2N1c2VzIHRoZSBuZXdseSBhY3RpdmUgaXRlbS5cbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGb2N1c0tleU1hbmFnZXIucHJvdG90eXBlLnNldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXRBY3RpdmVJdGVtLmNhbGwodGhpcywgaW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZvY3VzS2V5TWFuYWdlcjtcbn0oTGlzdEtleU1hbmFnZXIpKTtcbnZhciBBMTF5TW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQTExeU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEExMXlNb2R1bGU7XG59KCkpO1xuQTExeU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgUGxhdGZvcm1Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0ZvY3VzVHJhcERpcmVjdGl2ZSwgRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW0ZvY3VzVHJhcERpcmVjdGl2ZSwgRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbSW50ZXJhY3Rpdml0eUNoZWNrZXIsIEZvY3VzVHJhcEZhY3RvcnksIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5BMTF5TW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEluamVjdGlvbiB0b2tlbiB1c2VkIHRvIGluamVjdCB0aGUgZG9jdW1lbnQgaW50byBEaXJlY3Rpb25hbGl0eS5cbiAqIFRoaXMgaXMgdXNlZCBzbyB0aGF0IHRoZSB2YWx1ZSBjYW4gYmUgZmFrZWQgaW4gdGVzdHMuXG4gKlxuICogV2UgY2FuJ3QgdXNlIHRoZSByZWFsIGRvY3VtZW50IGluIHRlc3RzIGJlY2F1c2UgY2hhbmdpbmcgdGhlIHJlYWwgYGRpcmAgY2F1c2VzIGdlb21ldHJ5LWJhc2VkXG4gKiB0ZXN0cyBpbiBTYWZhcmkgdG8gZmFpbC5cbiAqXG4gKiBXZSBhbHNvIGNhbid0IHJlLXByb3ZpZGUgdGhlIERPQ1VNRU5UIHRva2VuIGZyb20gcGxhdGZvcm0tYnJvd2VyIGJlY2F1c2UgdGhlIHVuaXQgdGVzdHNcbiAqIHRoZW1zZWx2ZXMgdXNlIHRoaW5ncyBsaWtlIGBxdWVyeVNlbGVjdG9yYCBpbiB0ZXN0IGNvZGUuXG4gKi9cbnZhciBESVJfRE9DVU1FTlQgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ21kLWRpci1kb2MnKTtcbi8qKlxuICogVGhlIGRpcmVjdGlvbmFsaXR5IChMVFIgLyBSVEwpIGNvbnRleHQgZm9yIHRoZSBhcHBsaWNhdGlvbiAob3IgYSBzdWJ0cmVlIG9mIGl0KS5cbiAqIEV4cG9zZXMgdGhlIGN1cnJlbnQgZGlyZWN0aW9uIGFuZCBhIHN0cmVhbSBvZiBkaXJlY3Rpb24gY2hhbmdlcy5cbiAqL1xudmFyIERpcmVjdGlvbmFsaXR5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX2RvY3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlyZWN0aW9uYWxpdHkoX2RvY3VtZW50KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSAnbHRyJztcbiAgICAgICAgdGhpcy5jaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGlmIChfZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSAnYXV0bycgdmFsdWUgLVxuICAgICAgICAgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBhY2NvdW50IGZvciBkaXI9XCJhdXRvXCIuXG4gICAgICAgICAgICAvLyBJdCBsb29rcyBsaWtlIEhUTUxFbGVtZW5ldC5kaXIgaXMgYWxzbyBcImF1dG9cIiB3aGVuIHRoYXQncyBzZXQgdG8gdGhlIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgIC8vIGJ1dCBnZXRDb21wdXRlZFN0eWxlIHJldHVybiBlaXRoZXIgXCJsdHJcIiBvciBcInJ0bFwiLiBhdm9pZGluZyBnZXRDb21wdXRlZFN0eWxlIGZvciBub3dcbiAgICAgICAgICAgIHZhciBib2R5RGlyID0gX2RvY3VtZW50LmJvZHkgPyBfZG9jdW1lbnQuYm9keS5kaXIgOiBudWxsO1xuICAgICAgICAgICAgdmFyIGh0bWxEaXIgPSBfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IChib2R5RGlyIHx8IGh0bWxEaXIgfHwgJ2x0cicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBEaXJlY3Rpb25hbGl0eTtcbn0oKSk7XG5EaXJlY3Rpb25hbGl0eS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuRGlyZWN0aW9uYWxpdHkuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbRElSX0RPQ1VNRU5ULF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHBhcmVudERpcmVjdGlvbmFsaXR5XG4gKiBAcGFyYW0gez99IF9kb2N1bWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gRElSRUNUSU9OQUxJVFlfUFJPVklERVJfRkFDVE9SWShwYXJlbnREaXJlY3Rpb25hbGl0eSwgX2RvY3VtZW50KSB7XG4gICAgcmV0dXJuIHBhcmVudERpcmVjdGlvbmFsaXR5IHx8IG5ldyBEaXJlY3Rpb25hbGl0eShfZG9jdW1lbnQpO1xufVxudmFyIERJUkVDVElPTkFMSVRZX1BST1ZJREVSID0ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBEaXJlY3Rpb25hbGl0eSBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IERpcmVjdGlvbmFsaXR5LFxuICAgIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBEaXJlY3Rpb25hbGl0eV0sIFtuZXcgT3B0aW9uYWwoKSwgRE9DVU1FTlRdXSxcbiAgICB1c2VGYWN0b3J5OiBESVJFQ1RJT05BTElUWV9QUk9WSURFUl9GQUNUT1JZXG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgdG8gbGlzdGVuIGZvciBjaGFuZ2VzIG9mIGRpcmVjdGlvbiBvZiBwYXJ0IG9mIHRoZSBET00uXG4gKlxuICogV291bGQgcHJvdmlkZSBpdHNlbGYgaW4gY2FzZSBhIGNvbXBvbmVudCBsb29rcyBmb3IgdGhlIERpcmVjdGlvbmFsaXR5IHNlcnZpY2VcbiAqL1xudmFyIERpciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheW91dCBkaXJlY3Rpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaXIgPSAnbHRyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGB2YWx1ZWAgaGFzIGJlZW4gc2V0IHRvIGl0cyBpbml0aWFsIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBkaXJlY3Rpb24gY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyLnByb3RvdHlwZSwgXCJkaXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAZG9jcy1wcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZCA9IHRoaXMuX2RpcjtcbiAgICAgICAgICAgIHRoaXMuX2RpciA9IHY7XG4gICAgICAgICAgICBpZiAob2xkICE9PSB0aGlzLl9kaXIgJiYgdGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBsYXlvdXQgZGlyZWN0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpcjsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLmRpciA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgb25jZSBkZWZhdWx0IHZhbHVlIGhhcyBiZWVuIHNldC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpci5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBEaXI7XG59KCkpO1xuRGlyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbZGlyXScsXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhoYW5zbCk6IG1heWJlIGAkaW1wbGljaXRgIGlzbid0IHRoZSBiZXN0IG9wdGlvbiBoZXJlLCBidXQgZm9yIG5vdyB0aGF0J3MgdGhlIGJlc3Qgd2UgZ290LlxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnJGltcGxpY2l0JyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBEaXJlY3Rpb25hbGl0eSwgdXNlRXhpc3Rpbmc6IERpciB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5EaXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbkRpci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnY2hhbmdlJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2RpckNoYW5nZScsXSB9LF0sXG4gICAgJ2Rpcic6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuZGlyJyxdIH0sIHsgdHlwZTogSW5wdXQsIGFyZ3M6IFsnZGlyJyxdIH0sXSxcbn07XG52YXIgQmlkaU1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpZGlNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBCaWRpTW9kdWxlO1xufSgpKTtcbkJpZGlNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtEaXJdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0Rpcl0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogRElSX0RPQ1VNRU5ULCB1c2VFeGlzdGluZzogRE9DVU1FTlQgfSxcbiAgICAgICAgICAgICAgICAgICAgRGlyZWN0aW9uYWxpdHksXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5CaWRpTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIENvZXJjZXMgYSBkYXRhLWJvdW5kIHZhbHVlICh0eXBpY2FsbHkgYSBzdHJpbmcpIHRvIGEgbnVtYmVyLlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHBhcmFtIHs/PX0gZmFsbGJhY2tWYWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29lcmNlTnVtYmVyUHJvcGVydHkodmFsdWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgICBpZiAoZmFsbGJhY2tWYWx1ZSA9PT0gdm9pZCAwKSB7IGZhbGxiYWNrVmFsdWUgPSAwOyB9XG4gICAgLy8gcGFyc2VGbG9hdCh2YWx1ZSkgaGFuZGxlcyBtb3N0IG9mIHRoZSBjYXNlcyB3ZSdyZSBpbnRlcmVzdGVkIGluIChpdCB0cmVhdHMgbnVsbCwgZW1wdHkgc3RyaW5nLFxuICAgIC8vIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcyBhcyBOYU4sIHdoZXJlIE51bWJlciBqdXN0IHVzZXMgMCkgYnV0IGl0IGNvbnNpZGVycyB0aGUgc3RyaW5nXG4gICAgLy8gJzEyM2hlbGxvJyB0byBiZSBhIHZhbGlkIG51bWJlci4gVGhlcmVmb3JlIHdlIGFsc28gY2hlY2sgaWYgTnVtYmVyKHZhbHVlKSBpcyBOYU4uXG4gICAgcmV0dXJuIGlzTmFOKHBhcnNlRmxvYXQoLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpKSkgfHwgaXNOYU4oTnVtYmVyKHZhbHVlKSkgPyBmYWxsYmFja1ZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbn1cbi8qKlxuICogVGhlIHJvdyB0ZW1wbGF0ZSB0aGF0IGNhbiBiZSB1c2VkIGJ5IHRoZSBtZC10YWJsZS4gU2hvdWxkIG5vdCBiZSB1c2VkIG91dHNpZGUgb2YgdGhlXG4gKiBtYXRlcmlhbCBsaWJyYXJ5LlxuICovXG52YXIgQ0RLX1JPV19URU1QTEFURSA9IFwiPG5nLWNvbnRhaW5lciBjZGtDZWxsT3V0bGV0PjwvbmctY29udGFpbmVyPlwiO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciB0aGUgQ2RrSGVhZGVyUm93RGVmIGFuZCBDZGtSb3dEZWYgdGhhdCBoYW5kbGVzIGNoZWNraW5nIHRoZWlyIGNvbHVtbnMgaW5wdXRzXG4gKiBmb3IgY2hhbmdlcyBhbmQgbm90aWZ5aW5nIHRoZSB0YWJsZS5cbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQmFzZVJvd0RlZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gez99IF9kaWZmZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQmFzZVJvd0RlZih0ZW1wbGF0ZSwgX2RpZmZlcnMpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLl9kaWZmZXJzID0gX2RpZmZlcnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBzdHJlYW0gdGhhdCBlbWl0cyB3aGVuIGNoYW5nZXMgYXJlIG1hZGUgdG8gdGhlIGNvbHVtbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtbnNDaGFuZ2UgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnZpZXdJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VSb3dEZWYucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3SW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlUm93RGVmLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb2x1bW5zIGRpZmZlciBpZiBvbmUgZG9lcyBub3QgeWV0IGV4aXN0LiBJbml0aWFsaXplIGl0IGJhc2VkIG9uIGluaXRpYWwgdmFsdWVcbiAgICAgICAgLy8gb2YgdGhlIGNvbHVtbnMgcHJvcGVydHkuXG4gICAgICAgIGlmICghdGhpcy5fY29sdW1uc0RpZmZlciAmJiBjaGFuZ2VzWydjb2x1bW5zJ10uY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW5zRGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKGNoYW5nZXNbJ2NvbHVtbnMnXS5jdXJyZW50VmFsdWUpLmNyZWF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VSb3dEZWYucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdJbml0aWFsaXplZCB8fCAhdGhpcy5fY29sdW1uc0RpZmZlciB8fCAhdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90aWZ5IHRoZSB0YWJsZSBpZiB0aGVyZSBhcmUgYW55IGNoYW5nZXMgdG8gdGhlIGNvbHVtbnMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoYW5nZXMgPSB0aGlzLl9jb2x1bW5zRGlmZmVyLmRpZmYodGhpcy5jb2x1bW5zKTtcbiAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc0NoYW5nZS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCYXNlUm93RGVmO1xufSgpKTtcbi8qKlxuICogSGVhZGVyIHJvdyBkZWZpbml0aW9uIGZvciB0aGUgQ0RLIHRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIGhlYWRlciByb3cncyB0ZW1wbGF0ZSBhbmQgb3RoZXIgaGVhZGVyIHByb3BlcnRpZXMgc3VjaCBhcyB0aGUgY29sdW1ucyB0byBkaXNwbGF5LlxuICovXG52YXIgQ2RrSGVhZGVyUm93RGVmID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2RrSGVhZGVyUm93RGVmLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gez99IF9kaWZmZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2RrSGVhZGVyUm93RGVmKHRlbXBsYXRlLCBfZGlmZmVycykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdGVtcGxhdGUsIF9kaWZmZXJzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2RrSGVhZGVyUm93RGVmO1xufShCYXNlUm93RGVmKSk7XG5DZGtIZWFkZXJSb3dEZWYuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGtIZWFkZXJSb3dEZWZdJyxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sdW1uczogY2RrSGVhZGVyUm93RGVmJ10sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNka0hlYWRlclJvd0RlZi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCB9LFxuICAgIHsgdHlwZTogSXRlcmFibGVEaWZmZXJzLCB9LFxuXTsgfTtcbi8qKlxuICogRGF0YSByb3cgZGVmaW5pdGlvbiBmb3IgdGhlIENESyB0YWJsZS5cbiAqIENhcHR1cmVzIHRoZSBoZWFkZXIgcm93J3MgdGVtcGxhdGUgYW5kIG90aGVyIHJvdyBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGhlIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAqL1xudmFyIENka1Jvd0RlZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENka1Jvd0RlZiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSBfZGlmZmVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENka1Jvd0RlZih0ZW1wbGF0ZSwgX2RpZmZlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRlbXBsYXRlLCBfZGlmZmVycykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENka1Jvd0RlZjtcbn0oQmFzZVJvd0RlZikpO1xuQ2RrUm93RGVmLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrUm93RGVmXScsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2NvbHVtbnM6IGNka1Jvd0RlZkNvbHVtbnMnXSxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQ2RrUm93RGVmLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIH0sXG4gICAgeyB0eXBlOiBJdGVyYWJsZURpZmZlcnMsIH0sXG5dOyB9O1xuLyoqXG4gKiBPdXRsZXQgZm9yIHJlbmRlcmluZyBjZWxscyBpbnNpZGUgb2YgYSByb3cgb3IgaGVhZGVyIHJvdy5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgQ2RrQ2VsbE91dGxldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdDb250YWluZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDZGtDZWxsT3V0bGV0KF92aWV3Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcbiAgICAgICAgQ2RrQ2VsbE91dGxldC5tb3N0UmVjZW50Q2VsbE91dGxldCA9IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDZGtDZWxsT3V0bGV0O1xufSgpKTtcbkNka0NlbGxPdXRsZXQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbY2RrQ2VsbE91dGxldF0nIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQ2RrQ2VsbE91dGxldC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG5dOyB9O1xuLyoqXG4gKiBIZWFkZXIgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhlIGNlbGwgb3V0bGV0LiBBZGRzIHRoZSByaWdodCBjbGFzcyBhbmQgcm9sZS5cbiAqL1xudmFyIENka0hlYWRlclJvdyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENka0hlYWRlclJvdygpIHtcbiAgICB9XG4gICAgcmV0dXJuIENka0hlYWRlclJvdztcbn0oKSk7XG5DZGtIZWFkZXJSb3cuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2Nkay1oZWFkZXItcm93JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogQ0RLX1JPV19URU1QTEFURSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdjZGstaGVhZGVyLXJvdycsXG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3JvdycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQ2RrSGVhZGVyUm93LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIERhdGEgcm93IHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoZSBjZWxsIG91dGxldC4gQWRkcyB0aGUgcmlnaHQgY2xhc3MgYW5kIHJvbGUuXG4gKi9cbnZhciBDZGtSb3cgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZGtSb3coKSB7XG4gICAgfVxuICAgIHJldHVybiBDZGtSb3c7XG59KCkpO1xuQ2RrUm93LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdjZGstcm93JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogQ0RLX1JPV19URU1QTEFURSxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdjZGstcm93JyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncm93JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5DZGtSb3cuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQ2VsbCBkZWZpbml0aW9uIGZvciBhIENESyB0YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGRhdGEgcm93IGNlbGwgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDZGtDZWxsRGVmID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENka0NlbGxEZWYodGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICByZXR1cm4gQ2RrQ2VsbERlZjtcbn0oKSk7XG5DZGtDZWxsRGVmLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Nka0NlbGxEZWZdJyB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNka0NlbGxEZWYuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgfSxcbl07IH07XG4vKipcbiAqIEhlYWRlciBjZWxsIGRlZmluaXRpb24gZm9yIGEgQ0RLIHRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIHRlbXBsYXRlIG9mIGEgY29sdW1uJ3MgaGVhZGVyIGNlbGwgYW5kIGFzIHdlbGwgYXMgY2VsbC1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ2RrSGVhZGVyQ2VsbERlZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDZGtIZWFkZXJDZWxsRGVmKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIENka0hlYWRlckNlbGxEZWY7XG59KCkpO1xuQ2RrSGVhZGVyQ2VsbERlZi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tjZGtIZWFkZXJDZWxsRGVmXScgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5DZGtIZWFkZXJDZWxsRGVmLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIH0sXG5dOyB9O1xuLyoqXG4gKiBDb2x1bW4gZGVmaW5pdGlvbiBmb3IgdGhlIENESyB0YWJsZS5cbiAqIERlZmluZXMgYSBzZXQgb2YgY2VsbHMgYXZhaWxhYmxlIGZvciBhIHRhYmxlIGNvbHVtbi5cbiAqL1xudmFyIENka0NvbHVtbkRlZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENka0NvbHVtbkRlZigpIHtcbiAgICB9XG4gICAgcmV0dXJuIENka0NvbHVtbkRlZjtcbn0oKSk7XG5DZGtDb2x1bW5EZWYuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbY2RrQ29sdW1uRGVmXScgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5DZGtDb2x1bW5EZWYuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbkNka0NvbHVtbkRlZi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2Nka0NvbHVtbkRlZicsXSB9LF0sXG4gICAgJ2NlbGwnOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtDZGtDZWxsRGVmLF0gfSxdLFxuICAgICdoZWFkZXJDZWxsJzogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbQ2RrSGVhZGVyQ2VsbERlZixdIH0sXSxcbn07XG4vKipcbiAqIEhlYWRlciBjZWxsIHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGFkZHMgdGhlIHJpZ2h0IGNsYXNzZXMgYW5kIHJvbGUuXG4gKi9cbnZhciBDZGtIZWFkZXJDZWxsID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb2x1bW5EZWZcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2RrSGVhZGVyQ2VsbChjb2x1bW5EZWYsIGVsZW1lbnRSZWYsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuY29sdW1uRGVmID0gY29sdW1uRGVmO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcImNkay1jb2x1bW4tXCIgKyBjb2x1bW5EZWYubmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBDZGtIZWFkZXJDZWxsO1xufSgpKTtcbkNka0hlYWRlckNlbGwuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2Nkay1oZWFkZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnY2RrLWhlYWRlci1jZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnY29sdW1uaGVhZGVyJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5DZGtIZWFkZXJDZWxsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ2RrQ29sdW1uRGVmLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbl07IH07XG4vKipcbiAqIENlbGwgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgYWRkcyB0aGUgcmlnaHQgY2xhc3NlcyBhbmQgcm9sZS5cbiAqL1xudmFyIENka0NlbGwgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbHVtbkRlZlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDZGtDZWxsKGNvbHVtbkRlZiwgZWxlbWVudFJlZiwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5EZWYgPSBjb2x1bW5EZWY7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwiY2RrLWNvbHVtbi1cIiArIGNvbHVtbkRlZi5uYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIENka0NlbGw7XG59KCkpO1xuQ2RrQ2VsbC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnY2RrLWNlbGwnLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2Nkay1jZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNka0NlbGwuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDZGtDb2x1bW5EZWYsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuXTsgfTtcbi8qKlxuICogUmV0dXJucyBhbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGZpbmQgYW4gdW5leGlzdGluZyBjb2x1bW4uXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEBwYXJhbSB7P30gaWQgSWQgd2hvc2UgbG9va3VwIGZhaWxlZC5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldFRhYmxlVW5rbm93bkNvbHVtbkVycm9yKGlkKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcImNkay10YWJsZTogQ291bGQgbm90IGZpbmQgY29sdW1uIHdpdGggaWQgXFxcIlwiICsgaWQgKyBcIlxcXCIuXCIpO1xufVxuLyoqXG4gKiBQcm92aWRlcyBhIGhhbmRsZSBmb3IgdGhlIHRhYmxlIHRvIGdyYWIgdGhlIHZpZXcgY29udGFpbmVyJ3MgbmctY29udGFpbmVyIHRvIGluc2VydCBkYXRhIHJvd3MuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFJvd1BsYWNlaG9sZGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aWV3Q29udGFpbmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gUm93UGxhY2Vob2xkZXIodmlld0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXIgPSB2aWV3Q29udGFpbmVyO1xuICAgIH1cbiAgICByZXR1cm4gUm93UGxhY2Vob2xkZXI7XG59KCkpO1xuUm93UGxhY2Vob2xkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbcm93UGxhY2Vob2xkZXJdJyB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblJvd1BsYWNlaG9sZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbl07IH07XG4vKipcbiAqIFByb3ZpZGVzIGEgaGFuZGxlIGZvciB0aGUgdGFibGUgdG8gZ3JhYiB0aGUgdmlldyBjb250YWluZXIncyBuZy1jb250YWluZXIgdG8gaW5zZXJ0IHRoZSBoZWFkZXIuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIEhlYWRlclJvd1BsYWNlaG9sZGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aWV3Q29udGFpbmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGVhZGVyUm93UGxhY2Vob2xkZXIodmlld0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXIgPSB2aWV3Q29udGFpbmVyO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGVyUm93UGxhY2Vob2xkZXI7XG59KCkpO1xuSGVhZGVyUm93UGxhY2Vob2xkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbaGVhZGVyUm93UGxhY2Vob2xkZXJdJyB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkhlYWRlclJvd1BsYWNlaG9sZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbl07IH07XG4vKipcbiAqIFRoZSB0YWJsZSB0ZW1wbGF0ZSB0aGF0IGNhbiBiZSB1c2VkIGJ5IHRoZSBtZC10YWJsZS4gU2hvdWxkIG5vdCBiZSB1c2VkIG91dHNpZGUgb2YgdGhlXG4gKiBtYXRlcmlhbCBsaWJyYXJ5LlxuICovXG52YXIgQ0RLX1RBQkxFX1RFTVBMQVRFID0gXCJcXG4gIDxuZy1jb250YWluZXIgaGVhZGVyUm93UGxhY2Vob2xkZXI+PC9uZy1jb250YWluZXI+XFxuICA8bmctY29udGFpbmVyIHJvd1BsYWNlaG9sZGVyPjwvbmctY29udGFpbmVyPlwiO1xuLyoqXG4gKiBBIGRhdGEgdGFibGUgdGhhdCBjb25uZWN0cyB3aXRoIGEgZGF0YSBzb3VyY2UgdG8gcmV0cmlldmUgZGF0YSBvZiB0eXBlIFQgYW5kIHJlbmRlcnNcbiAqIGEgaGVhZGVyIHJvdyBhbmQgZGF0YSByb3dzLiBVcGRhdGVzIHRoZSByb3dzIHdoZW4gbmV3IGRhdGEgaXMgcHJvdmlkZWQgYnkgdGhlIGRhdGEgc291cmNlLlxuICovXG52YXIgQ2RrVGFibGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kaWZmZXJzXG4gICAgICogQHBhcmFtIHs/fSBfY2hhbmdlRGV0ZWN0b3JSZWZcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSByb2xlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2RrVGFibGUoX2RpZmZlcnMsIF9jaGFuZ2VEZXRlY3RvclJlZiwgZWxlbWVudFJlZiwgcmVuZGVyZXIsIHJvbGUpIHtcbiAgICAgICAgdGhpcy5fZGlmZmVycyA9IF9kaWZmZXJzO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YmplY3QgdGhhdCBlbWl0cyB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gZGVzdHJveWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25EZXN0cm95ID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgc2V0IHRvIHRydWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzVmlld0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMYXRlc3QgZGF0YSBwcm92aWRlZCBieSB0aGUgZGF0YSBzb3VyY2UgdGhyb3VnaCB0aGUgY29ubmVjdCBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb2YgYWxsIHRoZSB1c2VyJ3MgZGVmaW5lZCBjb2x1bW5zIGlkZW50aWZpZWQgYnkgbmFtZS5cbiAgICAgICAgICogQ29udGFpbnMgdGhlIGhlYWRlciBhbmQgZGF0YS1jZWxsIHRlbXBsYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvbHVtbkRlZmluaXRpb25zQnlOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RyZWFtIGNvbnRhaW5pbmcgdGhlIGxhdGVzdCBpbmZvcm1hdGlvbiBvbiB3aGF0IHJvd3MgYXJlIGJlaW5nIGRpc3BsYXllZCBvbiBzY3JlZW4uXG4gICAgICAgICAqIENhbiBiZSB1c2VkIGJ5IHRoZSBkYXRhIHNvdXJjZSB0byBhcyBhIGhldXJpc3RpYyBvZiB3aGF0IGRhdGEgc2hvdWxkIGJlIHByb3ZpZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3Q2hhbmdlID0gbmV3IEJlaGF2aW9yU3ViamVjdCh7IHN0YXJ0OiAwLCBlbmQ6IE51bWJlci5NQVhfVkFMVUUgfSk7XG4gICAgICAgIGlmICghcm9sZSkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0QXR0cmlidXRlKGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3JvbGUnLCAnZ3JpZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDZGtUYWJsZS5wcm90b3R5cGUsIFwidHJhY2tCeVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90cmFja0J5Rm47IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja2luZyBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBjaGVjayB0aGUgZGlmZmVyZW5jZXMgaW4gZGF0YSBjaGFuZ2VzLiBVc2VkIHNpbWlsYXJseVxuICAgICAgICAgKiB0byBuZ0ZvciB0cmFja0J5IGZ1bmN0aW9uLiBPcHRpbWl6ZSByb3cgb3BlcmF0aW9ucyBieSBpZGVudGlmeWluZyBhIHJvdyBiYXNlZCBvbiBpdHMgZGF0YVxuICAgICAgICAgKiByZWxhdGl2ZSB0byB0aGUgZnVuY3Rpb24gdG8ga25vdyBpZiBhIHJvdyBzaG91bGQgYmUgYWRkZWQvcmVtb3ZlZC9tb3ZlZC5cbiAgICAgICAgICogQWNjZXB0cyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdHdvIHBhcmFtZXRlcnMsIGBpbmRleGAgYW5kIGBpdGVtYC5cbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGlmIChpc0Rldk1vZGUoKSAmJlxuICAgICAgICAgICAgICAgIGZuICE9IG51bGwgJiYgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nICYmIChjb25zb2xlKSAmJiAoY29uc29sZS53YXJuKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInRyYWNrQnkgbXVzdCBiZSBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeShmbikgKyBcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90cmFja0J5Rm4gPSBmbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENka1RhYmxlLnByb3RvdHlwZSwgXCJkYXRhU291cmNlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGVzIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIGxhdGVzdCBkYXRhIGFycmF5IHRvIHJlbmRlci4gSW5mbHVlbmNlZCBieSB0aGUgdGFibGUnc1xuICAgICAgICAgKiBzdHJlYW0gb2YgdmlldyB3aW5kb3cgKHdoYXQgcm93cyBhcmUgY3VycmVudGx5IG9uIHNjcmVlbikuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGFTb3VyY2U7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRhdGFTb3VyY2VcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhU291cmNlICE9PSBkYXRhU291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3dpdGNoRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDZGtUYWJsZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGlzY29ubmVjdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDZGtUYWJsZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE8oYW5kcmV3c2VndWluKTogU2V0dXAgYSBsaXN0ZW5lciBmb3Igc2Nyb2xsIGV2ZW50c1xuICAgICAgICAvLyAgIGFuZCBlbWl0IHRoZSBjYWxjdWxhdGVkIHZpZXcgdG8gdGhpcy52aWV3Q2hhbmdlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENka1RhYmxlLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFRPRE8oYW5kcmV3c2VndWluKTogVGhyb3cgYW4gZXJyb3IgaWYgdHdvIGNvbHVtbnMgc2hhcmUgdGhlIHNhbWUgbmFtZVxuICAgICAgICB0aGlzLl9jb2x1bW5EZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW5EZWYpIHtcbiAgICAgICAgICAgIF90aGlzLl9jb2x1bW5EZWZpbml0aW9uc0J5TmFtZS5zZXQoY29sdW1uRGVmLm5hbWUsIGNvbHVtbkRlZik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZS1yZW5kZXIgdGhlIHJvd3MgaWYgYW55IG9mIHRoZWlyIGNvbHVtbnMgY2hhbmdlLlxuICAgICAgICAvLyBUT0RPKGFuZHJld3NlZ3Vpbik6IERldGVybWluZSBob3cgdG8gb25seSByZS1yZW5kZXIgdGhlIHJvd3MgdGhhdCBoYXZlIHRoZWlyIGNvbHVtbnMgY2hhbmdlZC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29sdW1uQ2hhbmdlRXZlbnRzID0gdGhpcy5fcm93RGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uIChyb3dEZWYpIHsgcmV0dXJuIHJvd0RlZi5jb2x1bW5zQ2hhbmdlOyB9KTtcbiAgICAgICAgdGFrZVVudGlsLmNhbGwobWVyZ2UuYXBwbHkodm9pZCAwLCBjb2x1bW5DaGFuZ2VFdmVudHMpLCB0aGlzLl9vbkRlc3Ryb3kpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZGF0YSB0byBhbiBlbXB0eSBhcnJheSBzbyB0aGF0IHJlbmRlclJvd0NoYW5nZXMgd2lsbCByZS1yZW5kZXIgYWxsIG5ldyByb3dzLlxuICAgICAgICAgICAgX3RoaXMuX3Jvd1BsYWNlaG9sZGVyLnZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIF90aGlzLl9kYXRhRGlmZmVyLmRpZmYoW10pO1xuICAgICAgICAgICAgX3RoaXMuX3JlbmRlclJvd0NoYW5nZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlLXJlbmRlciB0aGUgaGVhZGVyIHJvdyBpZiB0aGUgY29sdW1ucyBjaGFuZ2VcbiAgICAgICAgdGFrZVVudGlsLmNhbGwodGhpcy5faGVhZGVyRGVmaW5pdGlvbi5jb2x1bW5zQ2hhbmdlLCB0aGlzLl9vbkRlc3Ryb3kpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5faGVhZGVyUm93UGxhY2Vob2xkZXIudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgICAgX3RoaXMuX3JlbmRlckhlYWRlclJvdygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2RrVGFibGUucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRmluZCBhbmQgY29uc3RydWN0IGFuIGl0ZXJhYmxlIGRpZmZlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIGRpZmYgaW4gYW4gYXJyYXkuXG4gICAgICAgIHRoaXMuX2RhdGFEaWZmZXIgPSB0aGlzLl9kaWZmZXJzLmZpbmQoW10pLmNyZWF0ZSh0aGlzLl90cmFja0J5Rm4pO1xuICAgICAgICB0aGlzLl9pc1ZpZXdJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENka1RhYmxlLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1ZpZXdJbml0aWFsaXplZCAmJiB0aGlzLmRhdGFTb3VyY2UgJiYgIXRoaXMuX3JlbmRlckNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVySGVhZGVyUm93KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlICYmICF0aGlzLl9yZW5kZXJDaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vYnNlcnZlUmVuZGVyQ2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggdG8gdGhlIHByb3ZpZGVkIGRhdGEgc291cmNlIGJ5IHJlc2V0dGluZyB0aGUgZGF0YSBhbmQgdW5zdWJzY3JpYmluZyBmcm9tIHRoZSBjdXJyZW50XG4gICAgICogcmVuZGVyIGNoYW5nZSBzdWJzY3JpcHRpb24gaWYgb25lIGV4aXN0cy4gSWYgdGhlIGRhdGEgc291cmNlIGlzIG51bGwsIGludGVycHJldCB0aGlzIGJ5XG4gICAgICogY2xlYXJpbmcgdGhlIHJvdyBwbGFjZWhvbGRlci4gT3RoZXJ3aXNlIHN0YXJ0IGxpc3RlbmluZyBmb3IgbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHs/fSBkYXRhU291cmNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDZGtUYWJsZS5wcm90b3R5cGUuX3N3aXRjaERhdGFTb3VyY2UgPSBmdW5jdGlvbiAoZGF0YVNvdXJjZSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgICAgIGlmICh0aGlzLl9kYXRhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGlzY29ubmVjdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmlld0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29ic2VydmVSZW5kZXJDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3dQbGFjZWhvbGRlci52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB1cCBhIHN1YnNjcmlwdGlvbiBmb3IgdGhlIGRhdGEgcHJvdmlkZWQgYnkgdGhlIGRhdGEgc291cmNlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2RrVGFibGUucHJvdG90eXBlLl9vYnNlcnZlUmVuZGVyQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhbmdlU3Vic2NyaXB0aW9uID0gdGFrZVVudGlsLmNhbGwodGhpcy5kYXRhU291cmNlLmNvbm5lY3QodGhpcyksIHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIF90aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIF90aGlzLl9yZW5kZXJSb3dDaGFuZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBlbWJlZGRlZCB2aWV3IGZvciB0aGUgaGVhZGVyIHRlbXBsYXRlIGFuZCBwbGFjZSBpdCBpbiB0aGUgaGVhZGVyIHJvdyB2aWV3IGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENka1RhYmxlLnByb3RvdHlwZS5fcmVuZGVySGVhZGVyUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjZWxscyA9IHRoaXMuX2dldEhlYWRlckNlbGxUZW1wbGF0ZXNGb3JSb3codGhpcy5faGVhZGVyRGVmaW5pdGlvbik7XG4gICAgICAgIGlmICghY2VsbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhhbmRyZXdzZWd1aW4pOiBhZGQgc29tZSBjb2RlIHRvIGVuZm9yY2UgdGhhdCBleGFjdGx5XG4gICAgICAgIC8vICAgb25lIENka0NlbGxPdXRsZXQgd2FzIGluc3RhbnRpYXRlZCBhcyBhIHJlc3VsdFxuICAgICAgICAvLyAgIG9mIGBjcmVhdGVFbWJlZGRlZFZpZXdgLlxuICAgICAgICB0aGlzLl9oZWFkZXJSb3dQbGFjZWhvbGRlci52aWV3Q29udGFpbmVyXG4gICAgICAgICAgICAuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX2hlYWRlckRlZmluaXRpb24udGVtcGxhdGUsIHsgY2VsbHM6IGNlbGxzIH0pO1xuICAgICAgICBjZWxscy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICBDZGtDZWxsT3V0bGV0Lm1vc3RSZWNlbnRDZWxsT3V0bGV0Ll92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhjZWxsLnRlbXBsYXRlLCB7fSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBjaGFuZ2VzIG1hZGUgaW4gdGhlIGRhdGEgYW5kIHJlbmRlciBlYWNoIGNoYW5nZSAocm93IGFkZGVkL3JlbW92ZWQvbW92ZWQpLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2RrVGFibGUucHJvdG90eXBlLl9yZW5kZXJSb3dDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFuZ2VzID0gdGhpcy5fZGF0YURpZmZlci5kaWZmKHRoaXMuX2RhdGEpO1xuICAgICAgICBpZiAoIWNoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3Q29udGFpbmVyID0gdGhpcy5fcm93UGxhY2Vob2xkZXIudmlld0NvbnRhaW5lcjtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoT3BlcmF0aW9uKGZ1bmN0aW9uIChpdGVtLCBhZGp1c3RlZFByZXZpb3VzSW5kZXgsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucHJldmlvdXNJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2luc2VydFJvdyhfdGhpcy5fZGF0YVtjdXJyZW50SW5kZXhdLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2aWV3Q29udGFpbmVyLnJlbW92ZShhZGp1c3RlZFByZXZpb3VzSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlldyA9IHZpZXdDb250YWluZXIuZ2V0KGFkanVzdGVkUHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICAgICAgdmlld0NvbnRhaW5lci5tb3ZlKC8qKiBAdHlwZSB7P30gKi8gKCh2aWV3KSksIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl91cGRhdGVSb3dDb250ZXh0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGVtYmVkZGVkIHZpZXcgZm9yIHRoZSBkYXRhIHJvdyB0ZW1wbGF0ZSBhbmQgcGxhY2UgaXQgaW4gdGhlIGNvcnJlY3QgaW5kZXggbG9jYXRpb25cbiAgICAgKiB3aXRoaW4gdGhlIGRhdGEgcm93IHZpZXcgY29udGFpbmVyLlxuICAgICAqIEBwYXJhbSB7P30gcm93RGF0YVxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENka1RhYmxlLnByb3RvdHlwZS5faW5zZXJ0Um93ID0gZnVuY3Rpb24gKHJvd0RhdGEsIGluZGV4KSB7XG4gICAgICAgIC8vIFRPRE8oYW5kcmV3c2VndWluKTogQWRkIHdoZW4gcHJlZGljYXRlcyB0byB0aGUgcm93IGRlZmluaXRpb25zXG4gICAgICAgIC8vICAgdG8gZmluZCB0aGUgcmlnaHQgdGVtcGxhdGUgdG8gdXNlZCBiYXNlZCBvblxuICAgICAgICAvLyAgIHRoZSBkYXRhIHJhdGhlciB0aGFuIGNob29zaW5nIHRoZSBmaXJzdCByb3cgZGVmaW5pdGlvbi5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm93ID0gdGhpcy5fcm93RGVmaW5pdGlvbnMuZmlyc3Q7XG4gICAgICAgIC8vIFJvdyBjb250ZXh0IHRoYXQgd2lsbCBiZSBwcm92aWRlZCB0byBib3RoIHRoZSBjcmVhdGVkIGVtYmVkZGVkIHJvdyB2aWV3IGFuZCBpdHMgY2VsbHMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHQgPSB7ICRpbXBsaWNpdDogcm93RGF0YSB9O1xuICAgICAgICAvLyBUT0RPKGFuZHJld3NlZ3Vpbik6IGFkZCBzb21lIGNvZGUgdG8gZW5mb3JjZSB0aGF0IGV4YWN0bHkgb25lXG4gICAgICAgIC8vICAgQ2RrQ2VsbE91dGxldCB3YXMgaW5zdGFudGlhdGVkIGFzIGEgcmVzdWx0ICBvZiBgY3JlYXRlRW1iZWRkZWRWaWV3YC5cbiAgICAgICAgdGhpcy5fcm93UGxhY2Vob2xkZXIudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcocm93LnRlbXBsYXRlLCBjb250ZXh0LCBpbmRleCk7XG4gICAgICAgIC8vIEluc2VydCBlbXB0eSBjZWxscyBpZiB0aGVyZSBpcyBubyBkYXRhIHRvIGltcHJvdmUgcmVuZGVyaW5nIHRpbWUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNlbGxzID0gcm93RGF0YSA/IHRoaXMuX2dldENlbGxUZW1wbGF0ZXNGb3JSb3cocm93KSA6IFtdO1xuICAgICAgICBjZWxscy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICBDZGtDZWxsT3V0bGV0Lm1vc3RSZWNlbnRDZWxsT3V0bGV0Ll92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhjZWxsLnRlbXBsYXRlLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29udGV4dCBmb3IgZWFjaCByb3cgdG8gcmVmbGVjdCBhbnkgZGF0YSBjaGFuZ2VzIHRoYXQgbWF5IGhhdmUgY2F1c2VkXG4gICAgICogcm93cyB0byBiZSBhZGRlZCwgcmVtb3ZlZCwgb3IgbW92ZWQuIFRoZSB2aWV3IGNvbnRhaW5lciBjb250YWlucyB0aGUgc2FtZSBjb250ZXh0XG4gICAgICogdGhhdCB3YXMgcHJvdmlkZWQgdG8gZWFjaCBvZiBpdHMgY2VsbHMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDZGtUYWJsZS5wcm90b3R5cGUuX3VwZGF0ZVJvd0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdDb250YWluZXIgPSB0aGlzLl9yb3dQbGFjZWhvbGRlci52aWV3Q29udGFpbmVyO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gMCwgLyoqIEB0eXBlIHs/fSAqLyBjb3VudCA9IHZpZXdDb250YWluZXIubGVuZ3RoOyBpbmRleCA8IGNvdW50OyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UmVmID0gKHZpZXdDb250YWluZXIuZ2V0KGluZGV4KSk7XG4gICAgICAgICAgICB2aWV3UmVmLmNvbnRleHQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHZpZXdSZWYuY29udGV4dC5jb3VudCA9IGNvdW50O1xuICAgICAgICAgICAgdmlld1JlZi5jb250ZXh0LmZpcnN0ID0gaW5kZXggPT09IDA7XG4gICAgICAgICAgICB2aWV3UmVmLmNvbnRleHQubGFzdCA9IGluZGV4ID09PSBjb3VudCAtIDE7XG4gICAgICAgICAgICB2aWV3UmVmLmNvbnRleHQuZXZlbiA9IGluZGV4ICUgMiA9PT0gMDtcbiAgICAgICAgICAgIHZpZXdSZWYuY29udGV4dC5vZGQgPSBpbmRleCAlIDIgIT09IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNlbGwgdGVtcGxhdGUgZGVmaW5pdGlvbnMgdG8gaW5zZXJ0IGludG8gdGhlIGhlYWRlclxuICAgICAqIGFzIGRlZmluZWQgYnkgaXRzIGxpc3Qgb2YgY29sdW1ucyB0byBkaXNwbGF5LlxuICAgICAqIEBwYXJhbSB7P30gaGVhZGVyRGVmXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDZGtUYWJsZS5wcm90b3R5cGUuX2dldEhlYWRlckNlbGxUZW1wbGF0ZXNGb3JSb3cgPSBmdW5jdGlvbiAoaGVhZGVyRGVmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaGVhZGVyRGVmLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVyRGVmLmNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW5JZCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29sdW1uID0gX3RoaXMuX2NvbHVtbkRlZmluaXRpb25zQnlOYW1lLmdldChjb2x1bW5JZCk7XG4gICAgICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgICAgIHRocm93IGdldFRhYmxlVW5rbm93bkNvbHVtbkVycm9yKGNvbHVtbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4uaGVhZGVyQ2VsbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjZWxsIHRlbXBsYXRlIGRlZmluaXRpb25zIHRvIGluc2VydCBpbiB0aGUgcHJvdmlkZWQgcm93XG4gICAgICogYXMgZGVmaW5lZCBieSBpdHMgbGlzdCBvZiBjb2x1bW5zIHRvIGRpc3BsYXkuXG4gICAgICogQHBhcmFtIHs/fSByb3dEZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENka1RhYmxlLnByb3RvdHlwZS5fZ2V0Q2VsbFRlbXBsYXRlc0ZvclJvdyA9IGZ1bmN0aW9uIChyb3dEZWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFyb3dEZWYuY29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dEZWYuY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbklkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2x1bW4gPSBfdGhpcy5fY29sdW1uRGVmaW5pdGlvbnNCeU5hbWUuZ2V0KGNvbHVtbklkKTtcbiAgICAgICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZ2V0VGFibGVVbmtub3duQ29sdW1uRXJyb3IoY29sdW1uSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5jZWxsO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDZGtUYWJsZTtcbn0oKSk7XG5DZGtUYWJsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnY2RrLXRhYmxlJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogQ0RLX1RBQkxFX1RFTVBMQVRFLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2Nkay10YWJsZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5DZGtUYWJsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEl0ZXJhYmxlRGlmZmVycywgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogQXR0cmlidXRlLCBhcmdzOiBbJ3JvbGUnLF0gfSxdIH0sXG5dOyB9O1xuQ2RrVGFibGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3RyYWNrQnknOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ2RhdGFTb3VyY2UnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgJ19yb3dQbGFjZWhvbGRlcic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW1Jvd1BsYWNlaG9sZGVyLF0gfSxdLFxuICAgICdfaGVhZGVyUm93UGxhY2Vob2xkZXInOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtIZWFkZXJSb3dQbGFjZWhvbGRlcixdIH0sXSxcbiAgICAnX2NvbHVtbkRlZmluaXRpb25zJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbQ2RrQ29sdW1uRGVmLF0gfSxdLFxuICAgICdfaGVhZGVyRGVmaW5pdGlvbic6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0Nka0hlYWRlclJvd0RlZixdIH0sXSxcbiAgICAnX3Jvd0RlZmluaXRpb25zJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbQ2RrUm93RGVmLF0gfSxdLFxufTtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBEYXRhU291cmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YVNvdXJjZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgYSBjb2xsZWN0aW9uIHZpZXdlciAoc3VjaCBhcyBhIGRhdGEtdGFibGUpIHRvIHRoaXMgZGF0YSBzb3VyY2UuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBjb2xsZWN0aW9uVmlld2VyIFRoZSBjb21wb25lbnQgdGhhdCBleHBvc2VzIGEgdmlldyBvdmVyIHRoZSBkYXRhIHByb3ZpZGVkIGJ5IHRoaXNcbiAgICAgKiAgICAgZGF0YSBzb3VyY2UuXG4gICAgICogQHJldHVybiB7P30gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgbmV3IHZhbHVlIHdoZW4gdGhlIGRhdGEgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBEYXRhU291cmNlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGNvbGxlY3Rpb25WaWV3ZXIpIHsgfTtcbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyBhIGNvbGxlY3Rpb24gdmlld2VyIChzdWNoIGFzIGEgZGF0YS10YWJsZSkgZnJvbSB0aGlzIGRhdGEgc291cmNlLiBDYW4gYmUgdXNlZFxuICAgICAqIHRvIHBlcmZvcm0gYW55IGNsZWFuLXVwIG9yIHRlYXItZG93biBvcGVyYXRpb25zIHdoZW4gYSB2aWV3IGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gY29sbGVjdGlvblZpZXdlciBUaGUgY29tcG9uZW50IHRoYXQgZXhwb3NlcyBhIHZpZXcgb3ZlciB0aGUgZGF0YSBwcm92aWRlZCBieSB0aGlzXG4gICAgICogICAgIGRhdGEgc291cmNlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVNvdXJjZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uVmlld2VyKSB7IH07XG4gICAgcmV0dXJuIERhdGFTb3VyY2U7XG59KCkpO1xudmFyIEVYUE9SVEVEX0RFQ0xBUkFUSU9OUyA9IFtcbiAgICBDZGtUYWJsZSxcbiAgICBDZGtSb3dEZWYsXG4gICAgQ2RrQ2VsbERlZixcbiAgICBDZGtDZWxsT3V0bGV0LFxuICAgIENka0hlYWRlckNlbGxEZWYsXG4gICAgQ2RrQ29sdW1uRGVmLFxuICAgIENka0NlbGwsXG4gICAgQ2RrUm93LFxuICAgIENka0hlYWRlckNlbGwsXG4gICAgQ2RrSGVhZGVyUm93LFxuICAgIENka0hlYWRlclJvd0RlZixcbiAgICBSb3dQbGFjZWhvbGRlcixcbiAgICBIZWFkZXJSb3dQbGFjZWhvbGRlcixcbl07XG52YXIgQ2RrVGFibGVNb2R1bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZGtUYWJsZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIENka1RhYmxlTW9kdWxlO1xufSgpKTtcbkNka1RhYmxlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbRVhQT1JURURfREVDTEFSQVRJT05TXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtFWFBPUlRFRF9ERUNMQVJBVElPTlNdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNka1RhYmxlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIG51bGwgcG9ydGFsIHRvIGEgaG9zdC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGhyb3dOdWxsUG9ydGFsRXJyb3IoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ011c3QgcHJvdmlkZSBhIHBvcnRhbCB0byBhdHRhY2gnKTtcbn1cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGEgcG9ydGFsIHRvIGEgaG9zdCB0aGF0IGlzIGFscmVhZHkgYXR0YWNoZWQuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRocm93UG9ydGFsQWxyZWFkeUF0dGFjaGVkRXJyb3IoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0hvc3QgYWxyZWFkeSBoYXMgYSBwb3J0YWwgYXR0YWNoZWQnKTtcbn1cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGEgcG9ydGFsIHRvIGFuIGFscmVhZHktZGlzcG9zZWQgaG9zdC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGhyb3dQb3J0YWxIb3N0QWxyZWFkeURpc3Bvc2VkRXJyb3IoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1RoaXMgUG9ydGFsSG9zdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkJyk7XG59XG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhbiB1bmtub3duIHBvcnRhbCB0eXBlLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0aHJvd1Vua25vd25Qb3J0YWxUeXBlRXJyb3IoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gYXR0YWNoIGFuIHVua25vd24gUG9ydGFsIHR5cGUuIEJhc2VQb3J0YWxIb3N0IGFjY2VwdHMgZWl0aGVyJyArXG4gICAgICAgICdhIENvbXBvbmVudFBvcnRhbCBvciBhIFRlbXBsYXRlUG9ydGFsLicpO1xufVxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gYXR0ZW1wdGluZyB0byBhdHRhY2ggYSBwb3J0YWwgdG8gYSBudWxsIGhvc3QuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRocm93TnVsbFBvcnRhbEhvc3RFcnJvcigpIHtcbiAgICB0aHJvdyBFcnJvcignQXR0ZW1wdGluZyB0byBhdHRhY2ggYSBwb3J0YWwgdG8gYSBudWxsIFBvcnRhbEhvc3QnKTtcbn1cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGF0dGVtcHRpbmcgdG8gZGV0YWNoIGEgcG9ydGFsIHRoYXQgaXMgbm90IGF0dGFjaGVkLlxuICogXFxAZG9jcy1wcml2YXRld1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGhyb3dOb1BvcnRhbEF0dGFjaGVkRXJyb3IoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gZGV0YWNoIGEgcG9ydGFsIHRoYXQgaXMgbm90IGF0dGFjaGVkIHRvIGEgaG9zdCcpO1xufVxuLyoqXG4gKiBBIGBQb3J0YWxgIGlzIHNvbWV0aGluZyB0aGF0IHlvdSB3YW50IHRvIHJlbmRlciBzb21ld2hlcmUgZWxzZS5cbiAqIEl0IGNhbiBiZSBhdHRhY2ggdG8gLyBkZXRhY2hlZCBmcm9tIGEgYFBvcnRhbEhvc3RgLlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBQb3J0YWwgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3J0YWwoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGlzIHBvcnRhbCB0byBhIGhvc3QuXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQb3J0YWwucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgIGlmIChob3N0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93TnVsbFBvcnRhbEhvc3RFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93UG9ydGFsQWxyZWFkeUF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRhY2hlZEhvc3QgPSBob3N0O1xuICAgICAgICByZXR1cm4gKGhvc3QuYXR0YWNoKHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGlzIHBvcnRhbCBmcm9tIGl0cyBob3N0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQb3J0YWwucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdCA9IHRoaXMuX2F0dGFjaGVkSG9zdDtcbiAgICAgICAgaWYgKGhvc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dOb1BvcnRhbEF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaGVkSG9zdCA9IG51bGw7XG4gICAgICAgICAgICBob3N0LmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9ydGFsLnByb3RvdHlwZSwgXCJpc0F0dGFjaGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBwb3J0YWwgaXMgYXR0YWNoZWQgdG8gYSBob3N0LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNoZWRIb3N0ICE9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFBvcnRhbEhvc3QgcmVmZXJlbmNlIHdpdGhvdXQgcGVyZm9ybWluZyBgYXR0YWNoKClgLiBUaGlzIGlzIHVzZWQgZGlyZWN0bHkgYnlcbiAgICAgKiB0aGUgUG9ydGFsSG9zdCB3aGVuIGl0IGlzIHBlcmZvcm1pbmcgYW4gYGF0dGFjaCgpYCBvciBgZGV0YWNoKClgLlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUG9ydGFsLnByb3RvdHlwZS5zZXRBdHRhY2hlZEhvc3QgPSBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgICB0aGlzLl9hdHRhY2hlZEhvc3QgPSBob3N0O1xuICAgIH07XG4gICAgcmV0dXJuIFBvcnRhbDtcbn0oKSk7XG4vKipcbiAqIEEgYENvbXBvbmVudFBvcnRhbGAgaXMgYSBwb3J0YWwgdGhhdCBpbnN0YW50aWF0ZXMgc29tZSBDb21wb25lbnQgdXBvbiBhdHRhY2htZW50LlxuICovXG52YXIgQ29tcG9uZW50UG9ydGFsID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29tcG9uZW50UG9ydGFsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHs/PX0gdmlld0NvbnRhaW5lclJlZlxuICAgICAqIEBwYXJhbSB7Pz19IGluamVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50UG9ydGFsKGNvbXBvbmVudCwgdmlld0NvbnRhaW5lclJlZiwgaW5qZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICBfdGhpcy52aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgX3RoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcG9uZW50UG9ydGFsO1xufShQb3J0YWwpKTtcbi8qKlxuICogQSBgVGVtcGxhdGVQb3J0YWxgIGlzIGEgcG9ydGFsIHRoYXQgcmVwcmVzZW50cyBzb21lIGVtYmVkZGVkIHRlbXBsYXRlIChUZW1wbGF0ZVJlZikuXG4gKi9cbnZhciBUZW1wbGF0ZVBvcnRhbCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRlbXBsYXRlUG9ydGFsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDb250YWluZXJSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBvcnRhbCh0ZW1wbGF0ZSwgdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCBsb2NhbHMgZm9yIHRoZSBpbnN0YW50aWF0ZWQgZW1iZWRkZWQgdmlldy5cbiAgICAgICAgICogVGhlc2UgbG9jYWxzIGNhbiBiZSBzZWVuIGFzIFwiZXhwb3J0c1wiIGZvciB0aGUgdGVtcGxhdGUsIHN1Y2ggYXMgaG93IG5nRm9yIGhhc1xuICAgICAgICAgKiBpbmRleCAvIGV2ZW50IC8gb2RkLlxuICAgICAgICAgKiBTZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2RvY3MvdHMvbGF0ZXN0L2FwaS9jb3JlL0VtYmVkZGVkVmlld1JlZi1jbGFzcy5odG1sXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5sb2NhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGU7XG4gICAgICAgIF90aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW1wbGF0ZVBvcnRhbC5wcm90b3R5cGUsIFwib3JpZ2luXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlUmVmLmVsZW1lbnRSZWY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7Pz19IGxvY2Fsc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQb3J0YWwucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChob3N0LCBsb2NhbHMpIHtcbiAgICAgICAgdGhpcy5sb2NhbHMgPSBsb2NhbHMgPT0gbnVsbCA/IG5ldyBNYXAoKSA6IGxvY2FscztcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYXR0YWNoLmNhbGwodGhpcywgaG9zdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUG9ydGFsLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9jYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kZXRhY2guY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBUZW1wbGF0ZVBvcnRhbDtcbn0oUG9ydGFsKSk7XG4vKipcbiAqIFBhcnRpYWwgaW1wbGVtZW50YXRpb24gb2YgUG9ydGFsSG9zdCB0aGF0IG9ubHkgZGVhbHMgd2l0aCBhdHRhY2hpbmcgZWl0aGVyIGFcbiAqIENvbXBvbmVudFBvcnRhbCBvciBhIFRlbXBsYXRlUG9ydGFsLlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBCYXNlUG9ydGFsSG9zdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VQb3J0YWxIb3N0KCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIGhvc3QgaGFzIGFscmVhZHkgYmVlbiBwZXJtYW5lbnRseSBkaXNwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGhvc3QgaGFzIGFuIGF0dGFjaGVkIHBvcnRhbC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5oYXNBdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYXR0YWNoZWRQb3J0YWw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBvcnRhbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZVBvcnRhbEhvc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgaWYgKCFwb3J0YWwpIHtcbiAgICAgICAgICAgIHRocm93TnVsbFBvcnRhbEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhyb3dQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvd1BvcnRhbEhvc3RBbHJlYWR5RGlzcG9zZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3J0YWwgaW5zdGFuY2VvZiBDb21wb25lbnRQb3J0YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaGVkUG9ydGFsID0gcG9ydGFsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoQ29tcG9uZW50UG9ydGFsKHBvcnRhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9ydGFsIGluc3RhbmNlb2YgVGVtcGxhdGVQb3J0YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaGVkUG9ydGFsID0gcG9ydGFsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoVGVtcGxhdGVQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvd1Vua25vd25Qb3J0YWxUeXBlRXJyb3IoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBwb3J0YWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5hdHRhY2hDb21wb25lbnRQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBwb3J0YWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5hdHRhY2hUZW1wbGF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRhY2hlZFBvcnRhbCkge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWRQb3J0YWwuc2V0QXR0YWNoZWRIb3N0KG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWRQb3J0YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludm9rZURpc3Bvc2VGbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnZva2VEaXNwb3NlRm4oKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuc2V0RGlzcG9zZUZuID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VGbiA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuX2ludm9rZURpc3Bvc2VGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VGbikge1xuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUZuKCk7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlRm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZVBvcnRhbEhvc3Q7XG59KCkpO1xuLyoqXG4gKiBBIFBvcnRhbEhvc3QgZm9yIGF0dGFjaGluZyBwb3J0YWxzIHRvIGFuIGFyYml0cmFyeSBET00gZWxlbWVudCBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyXG4gKiBhcHBsaWNhdGlvbiBjb250ZXh0LlxuICpcbiAqIFRoaXMgaXMgdGhlIG9ubHkgcGFydCBvZiB0aGUgcG9ydGFsIGNvcmUgdGhhdCBkaXJlY3RseSB0b3VjaGVzIHRoZSBET00uXG4gKi9cbnZhciBEb21Qb3J0YWxIb3N0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRG9tUG9ydGFsSG9zdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9ob3N0RG9tRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX2FwcFJlZlxuICAgICAqIEBwYXJhbSB7P30gX2RlZmF1bHRJbmplY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERvbVBvcnRhbEhvc3QoX2hvc3REb21FbGVtZW50LCBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBfYXBwUmVmLCBfZGVmYXVsdEluamVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9ob3N0RG9tRWxlbWVudCA9IF9ob3N0RG9tRWxlbWVudDtcbiAgICAgICAgX3RoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgIF90aGlzLl9hcHBSZWYgPSBfYXBwUmVmO1xuICAgICAgICBfdGhpcy5fZGVmYXVsdEluamVjdG9yID0gX2RlZmF1bHRJbmplY3RvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggdGhlIGdpdmVuIENvbXBvbmVudFBvcnRhbCB0byBET00gZWxlbWVudCB1c2luZyB0aGUgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBwb3J0YWwgUG9ydGFsIHRvIGJlIGF0dGFjaGVkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21Qb3J0YWxIb3N0LnByb3RvdHlwZS5hdHRhY2hDb21wb25lbnRQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkocG9ydGFsLmNvbXBvbmVudCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudFJlZjtcbiAgICAgICAgLy8gSWYgdGhlIHBvcnRhbCBzcGVjaWZpZXMgYSBWaWV3Q29udGFpbmVyUmVmLCB3ZSB3aWxsIHVzZSB0aGF0IGFzIHRoZSBhdHRhY2htZW50IHBvaW50XG4gICAgICAgIC8vIGZvciB0aGUgY29tcG9uZW50IChpbiB0ZXJtcyBvZiBBbmd1bGFyJ3MgY29tcG9uZW50IHRyZWUsIG5vdCByZW5kZXJpbmcpLlxuICAgICAgICAvLyBXaGVuIHRoZSBWaWV3Q29udGFpbmVyUmVmIGlzIG1pc3NpbmcsIHdlIHVzZSB0aGUgZmFjdG9yeSB0byBjcmVhdGUgdGhlIGNvbXBvbmVudCBkaXJlY3RseVxuICAgICAgICAvLyBhbmQgdGhlbiBtYW51YWxseSBhdHRhY2ggdGhlIHZpZXcgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAgICBpZiAocG9ydGFsLnZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFJlZiA9IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChjb21wb25lbnRGYWN0b3J5LCBwb3J0YWwudmlld0NvbnRhaW5lclJlZi5sZW5ndGgsIHBvcnRhbC5pbmplY3RvciB8fCBwb3J0YWwudmlld0NvbnRhaW5lclJlZi5wYXJlbnRJbmplY3Rvcik7XG4gICAgICAgICAgICB0aGlzLnNldERpc3Bvc2VGbihmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnRSZWYuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudEZhY3RvcnkuY3JlYXRlKHBvcnRhbC5pbmplY3RvciB8fCB0aGlzLl9kZWZhdWx0SW5qZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5fYXBwUmVmLmF0dGFjaFZpZXcoY29tcG9uZW50UmVmLmhvc3RWaWV3KTtcbiAgICAgICAgICAgIHRoaXMuc2V0RGlzcG9zZUZuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYXBwUmVmLmRldGFjaFZpZXcoY29tcG9uZW50UmVmLmhvc3RWaWV3KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRSZWYuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGluc3RhbnRpYXRlZCwgc28gd2UgbW92ZSBpdCB0byB0aGUgbG9jYXRpb24gaW4gdGhlIERPTVxuICAgICAgICAvLyB3aGVyZSB3ZSB3YW50IGl0IHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICB0aGlzLl9ob3N0RG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9nZXRDb21wb25lbnRSb290Tm9kZShjb21wb25lbnRSZWYpKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgdGVtcGxhdGUgcG9ydGFsIHRvIHRoZSBET00gYXMgYW4gZW1iZWRkZWQgdmlldy5cbiAgICAgKiBAcGFyYW0gez99IHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21Qb3J0YWxIb3N0LnByb3RvdHlwZS5hdHRhY2hUZW1wbGF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0NvbnRhaW5lciA9IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UmVmID0gdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcocG9ydGFsLnRlbXBsYXRlUmVmKTtcbiAgICAgICAgdmlld1JlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIC8vIFRoZSBtZXRob2QgYGNyZWF0ZUVtYmVkZGVkVmlld2Agd2lsbCBhZGQgdGhlIHZpZXcgYXMgYSBjaGlsZCBvZiB0aGUgdmlld0NvbnRhaW5lci5cbiAgICAgICAgLy8gQnV0IGZvciB0aGUgRG9tUG9ydGFsSG9zdCB0aGUgdmlldyBjYW4gYmUgYWRkZWQgZXZlcnl3aGVyZSBpbiB0aGUgRE9NIChlLmcgT3ZlcmxheSBDb250YWluZXIpXG4gICAgICAgIC8vIFRvIG1vdmUgdGhlIHZpZXcgdG8gdGhlIHNwZWNpZmllZCBob3N0IGVsZW1lbnQuIFdlIGp1c3QgcmUtYXBwZW5kIHRoZSBleGlzdGluZyByb290IG5vZGVzLlxuICAgICAgICB2aWV3UmVmLnJvb3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb290Tm9kZSkgeyByZXR1cm4gX3RoaXMuX2hvc3REb21FbGVtZW50LmFwcGVuZENoaWxkKHJvb3ROb2RlKTsgfSk7XG4gICAgICAgIHRoaXMuc2V0RGlzcG9zZUZuKChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHZpZXdDb250YWluZXIuaW5kZXhPZih2aWV3UmVmKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2aWV3Q29udGFpbmVyLnJlbW92ZShpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IFJldHVybiBsb2NhbHMgZnJvbSB2aWV3LlxuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIG91dCBhIHBvcnRhbCBmcm9tIHRoZSBET00uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21Qb3J0YWxIb3N0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2hvc3REb21FbGVtZW50LnBhcmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faG9zdERvbUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9ob3N0RG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvb3QgSFRNTEVsZW1lbnQgZm9yIGFuIGluc3RhbnRpYXRlZCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRSZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbVBvcnRhbEhvc3QucHJvdG90eXBlLl9nZXRDb21wb25lbnRSb290Tm9kZSA9IGZ1bmN0aW9uIChjb21wb25lbnRSZWYpIHtcbiAgICAgICAgcmV0dXJuICgoKGNvbXBvbmVudFJlZi5ob3N0VmlldykpLnJvb3ROb2Rlc1swXSk7XG4gICAgfTtcbiAgICByZXR1cm4gRG9tUG9ydGFsSG9zdDtcbn0oQmFzZVBvcnRhbEhvc3QpKTtcbi8qKlxuICogRGlyZWN0aXZlIHZlcnNpb24gb2YgYSBgVGVtcGxhdGVQb3J0YWxgLiBCZWNhdXNlIHRoZSBkaXJlY3RpdmUgKmlzKiBhIFRlbXBsYXRlUG9ydGFsLFxuICogdGhlIGRpcmVjdGl2ZSBpbnN0YW5jZSBpdHNlbGYgY2FuIGJlIGF0dGFjaGVkIHRvIGEgaG9zdCwgZW5hYmxpbmcgZGVjbGFyYXRpdmUgdXNlIG9mIHBvcnRhbHMuXG4gKlxuICogVXNhZ2U6XG4gKiA8bmctdGVtcGxhdGUgcG9ydGFsICNncmVldGluZz5cbiAqICAgPHA+IEhlbGxvIHt7bmFtZX19IDwvcD5cbiAqIDwvbmctdGVtcGxhdGU+XG4gKi9cbnZhciBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVSZWZcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDb250YWluZXJSZWZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSh0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZTtcbn0oVGVtcGxhdGVQb3J0YWwpKTtcblRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrLXBvcnRhbF0sIFtjZGtQb3J0YWxdLCBbcG9ydGFsXScsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdjZGtQb3J0YWwnLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5UZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCB9LFxuICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbl07IH07XG4vKipcbiAqIERpcmVjdGl2ZSB2ZXJzaW9uIG9mIGEgUG9ydGFsSG9zdC4gQmVjYXVzZSB0aGUgZGlyZWN0aXZlICppcyogYSBQb3J0YWxIb3N0LCBwb3J0YWxzIGNhbiBiZVxuICogZGlyZWN0bHkgYXR0YWNoZWQgdG8gaXQsIGVuYWJsaW5nIGRlY2xhcmF0aXZlIHVzZS5cbiAqXG4gKiBVc2FnZTpcbiAqIDxuZy10ZW1wbGF0ZSBbY2RrUG9ydGFsSG9zdF09XCJncmVldGluZ1wiPjwvbmctdGVtcGxhdGU+XG4gKi9cbnZhciBQb3J0YWxIb3N0RGlyZWN0aXZlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUG9ydGFsSG9zdERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IF92aWV3Q29udGFpbmVyUmVmXG4gICAgICovXG4gICAgZnVuY3Rpb24gUG9ydGFsSG9zdERpcmVjdGl2ZShfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBfdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgX3RoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhdHRhY2hlZCBwb3J0YWwuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fcG9ydGFsID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiX2RlcHJlY2F0ZWRQb3J0YWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wb3J0YWw7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5wb3J0YWwgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicG9ydGFsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvcnRhbCBhc3NvY2lhdGVkIHdpdGggdGhlIFBvcnRhbCBob3N0LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwb3J0YWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9ydGFsKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hdHRhY2guY2FsbCh0aGlzLCBwb3J0YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcG9ydGFsID0gcG9ydGFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBvcnRhbEhvc3REaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcG9ydGFsID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgZ2l2ZW4gQ29tcG9uZW50UG9ydGFsIHRvIHRoaXMgUG9ydGFsSG9zdCB1c2luZyB0aGUgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHBvcnRhbCBob3N0LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUuYXR0YWNoQ29tcG9uZW50UG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICBwb3J0YWwuc2V0QXR0YWNoZWRIb3N0KHRoaXMpO1xuICAgICAgICAvLyBJZiB0aGUgcG9ydGFsIHNwZWNpZmllcyBhbiBvcmlnaW4sIHVzZSB0aGF0IGFzIHRoZSBsb2dpY2FsIGxvY2F0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaW4gdGhlIGFwcGxpY2F0aW9uIHRyZWUuIE90aGVyd2lzZSB1c2UgdGhlIGxvY2F0aW9uIG9mIHRoaXMgUG9ydGFsSG9zdC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0NvbnRhaW5lclJlZiA9IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmICE9IG51bGwgP1xuICAgICAgICAgICAgcG9ydGFsLnZpZXdDb250YWluZXJSZWYgOlxuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShwb3J0YWwuY29tcG9uZW50KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmID0gdmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50RmFjdG9yeSwgdmlld0NvbnRhaW5lclJlZi5sZW5ndGgsIHBvcnRhbC5pbmplY3RvciB8fCB2aWV3Q29udGFpbmVyUmVmLnBhcmVudEluamVjdG9yKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXREaXNwb3NlRm4uY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZWYuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgdGhpcy5fcG9ydGFsID0gcG9ydGFsO1xuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBnaXZlbiBUZW1wbGF0ZVBvcnRhbCB0byB0aGlzIFBvcnRsSG9zdCBhcyBhbiBlbWJlZGRlZCBWaWV3LlxuICAgICAqIEBwYXJhbSB7P30gcG9ydGFsIFBvcnRhbCB0byBiZSBhdHRhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBvcnRhbEhvc3REaXJlY3RpdmUucHJvdG90eXBlLmF0dGFjaFRlbXBsYXRlUG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwb3J0YWwuc2V0QXR0YWNoZWRIb3N0KHRoaXMpO1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhwb3J0YWwudGVtcGxhdGVSZWYpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldERpc3Bvc2VGbi5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7IH0pO1xuICAgICAgICB0aGlzLl9wb3J0YWwgPSBwb3J0YWw7XG4gICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiByZXR1cm4gbG9jYWxzIGZyb20gdmlld1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcnRhbEhvc3REaXJlY3RpdmU7XG59KEJhc2VQb3J0YWxIb3N0KSk7XG5Qb3J0YWxIb3N0RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrUG9ydGFsSG9zdF0sIFtwb3J0YWxIb3N0XScsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ3BvcnRhbDogY2RrUG9ydGFsSG9zdCddXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblBvcnRhbEhvc3REaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuXTsgfTtcblBvcnRhbEhvc3REaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ19kZXByZWNhdGVkUG9ydGFsJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsncG9ydGFsSG9zdCcsXSB9LF0sXG59O1xudmFyIFBvcnRhbE1vZHVsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvcnRhbE1vZHVsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFBvcnRhbE1vZHVsZTtcbn0oKSk7XG5Qb3J0YWxNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSwgUG9ydGFsSG9zdERpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUsIFBvcnRhbEhvc3REaXJlY3RpdmVdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Qb3J0YWxNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogRmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBuZXcgTXV0YXRpb25PYnNlcnZlciBhbmQgYWxsb3dzIHVzIHRvIHN0dWIgaXQgb3V0IGluIHVuaXQgdGVzdHMuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTXV0YXRpb25PYnNlcnZlckZhY3RvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE11dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZE11dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRNdXRhdGlvbk9ic2VydmVyRmFjdG9yeTtcbn0oKSk7XG5NZE11dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5NZE11dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IHRyaWdnZXJzIGEgY2FsbGJhY2sgd2hlbmV2ZXIgdGhlIGNvbnRlbnQgb2ZcbiAqIGl0cyBhc3NvY2lhdGVkIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbnZhciBPYnNlcnZlQ29udGVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX211dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5XG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmVDb250ZW50KF9tdXRhdGlvbk9ic2VydmVyRmFjdG9yeSwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlckZhY3RvcnkgPSBfbXV0YXRpb25PYnNlcnZlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgZm9yIGVhY2ggY2hhbmdlIGluIHRoZSBlbGVtZW50J3MgY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGZvciBkZWJvdW5jaW5nIHRoZSBlbWl0dGVkIHZhbHVlcyB0byB0aGUgb2JzZXJ2ZUNvbnRlbnQgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kZWJvdW5jZXIgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE9ic2VydmVDb250ZW50LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlID4gMCkge1xuICAgICAgICAgICAgUnhDaGFpbi5mcm9tKHRoaXMuX2RlYm91bmNlcilcbiAgICAgICAgICAgICAgICAuY2FsbChkZWJvdW5jZVRpbWUkMSwgdGhpcy5kZWJvdW5jZSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHsgcmV0dXJuIF90aGlzLmV2ZW50LmVtaXQobXV0YXRpb25zKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJvdW5jZXIuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHsgcmV0dXJuIF90aGlzLmV2ZW50LmVtaXQobXV0YXRpb25zKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSB0aGlzLl9tdXRhdGlvbk9ic2VydmVyRmFjdG9yeS5jcmVhdGUoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgICAgICAgX3RoaXMuX2RlYm91bmNlci5uZXh0KG11dGF0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgT2JzZXJ2ZUNvbnRlbnQucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuX2RlYm91bmNlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZUNvbnRlbnQ7XG59KCkpO1xuT2JzZXJ2ZUNvbnRlbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGtPYnNlcnZlQ29udGVudF0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk9ic2VydmVDb250ZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTWRNdXRhdGlvbk9ic2VydmVyRmFjdG9yeSwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG5dOyB9O1xuT2JzZXJ2ZUNvbnRlbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2V2ZW50JzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ2Nka09ic2VydmVDb250ZW50JyxdIH0sXSxcbiAgICAnZGVib3VuY2UnOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG59O1xudmFyIE9ic2VydmVDb250ZW50TW9kdWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZUNvbnRlbnRNb2R1bGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZlQ29udGVudE1vZHVsZTtcbn0oKSk7XG5PYnNlcnZlQ29udGVudE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0czogW09ic2VydmVDb250ZW50XSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtPYnNlcnZlQ29udGVudF0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWRNdXRhdGlvbk9ic2VydmVyRmFjdG9yeV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuT2JzZXJ2ZUNvbnRlbnRNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cbmV4cG9ydCB7IEExMXlNb2R1bGUsIExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4sIExpdmVBbm5vdW5jZXIsIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSX0ZBQ1RPUlksIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSLCBpc0Zha2VNb3VzZWRvd25Gcm9tU2NyZWVuUmVhZGVyLCBGb2N1c1RyYXAsIEZvY3VzVHJhcEZhY3RvcnksIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUsIEZvY3VzVHJhcERpcmVjdGl2ZSwgSW50ZXJhY3Rpdml0eUNoZWNrZXIsIExpc3RLZXlNYW5hZ2VyLCBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciwgRm9jdXNLZXlNYW5hZ2VyLCBEaXJlY3Rpb25hbGl0eSwgRElSRUNUSU9OQUxJVFlfUFJPVklERVJfRkFDVE9SWSwgRElSRUNUSU9OQUxJVFlfUFJPVklERVIsIERJUl9ET0NVTUVOVCwgRGlyLCBCaWRpTW9kdWxlLCBjb2VyY2VCb29sZWFuUHJvcGVydHksIGNvZXJjZU51bWJlclByb3BlcnR5LCBDZGtUYWJsZU1vZHVsZSwgRGF0YVNvdXJjZSwgZ2V0VGFibGVVbmtub3duQ29sdW1uRXJyb3IsIFJvd1BsYWNlaG9sZGVyLCBIZWFkZXJSb3dQbGFjZWhvbGRlciwgQ0RLX1RBQkxFX1RFTVBMQVRFLCBDZGtUYWJsZSwgQ2RrQ2VsbERlZiwgQ2RrSGVhZGVyQ2VsbERlZiwgQ2RrQ29sdW1uRGVmLCBDZGtIZWFkZXJDZWxsLCBDZGtDZWxsLCBDREtfUk9XX1RFTVBMQVRFLCBCYXNlUm93RGVmLCBDZGtIZWFkZXJSb3dEZWYsIENka1Jvd0RlZiwgQ2RrQ2VsbE91dGxldCwgQ2RrSGVhZGVyUm93LCBDZGtSb3csIFBsYXRmb3JtTW9kdWxlLCBQbGF0Zm9ybSwgZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcywgUG9ydGFsLCBDb21wb25lbnRQb3J0YWwsIFRlbXBsYXRlUG9ydGFsLCBCYXNlUG9ydGFsSG9zdCwgRG9tUG9ydGFsSG9zdCwgVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUsIFBvcnRhbEhvc3REaXJlY3RpdmUsIFBvcnRhbE1vZHVsZSwgUnhDaGFpbiwgRmluYWxseUJyYW5kLCBDYXRjaEJyYW5kLCBEb0JyYW5kLCBNYXBCcmFuZCwgRmlsdGVyQnJhbmQsIFNoYXJlQnJhbmQsIEZpcnN0QnJhbmQsIFN3aXRjaE1hcEJyYW5kLCBTdGFydFdpdGhCcmFuZCwgRGVib3VuY2VUaW1lQnJhbmQsIEF1ZGl0VGltZUJyYW5kLCBUYWtlVW50aWxCcmFuZCwgZmluYWxseU9wZXJhdG9yLCBjYXRjaE9wZXJhdG9yLCBkb09wZXJhdG9yLCBtYXAkMSBhcyBtYXAsIGZpbHRlciQxIGFzIGZpbHRlciwgc2hhcmUkMSBhcyBzaGFyZSwgZmlyc3QkMSBhcyBmaXJzdCwgc3dpdGNoTWFwJDEgYXMgc3dpdGNoTWFwLCBzdGFydFdpdGgkMSBhcyBzdGFydFdpdGgsIGRlYm91bmNlVGltZSQxIGFzIGRlYm91bmNlVGltZSwgYXVkaXRUaW1lJDEgYXMgYXVkaXRUaW1lLCB0YWtlVW50aWwkMSBhcyB0YWtlVW50aWwsIE1kTXV0YXRpb25PYnNlcnZlckZhY3RvcnksIE9ic2VydmVDb250ZW50LCBPYnNlcnZlQ29udGVudE1vZHVsZSwgVVBfQVJST1csIERPV05fQVJST1csIFJJR0hUX0FSUk9XLCBMRUZUX0FSUk9XLCBQQUdFX1VQLCBQQUdFX0RPV04sIEhPTUUsIEVORCwgRU5URVIsIFNQQUNFLCBUQUIsIEVTQ0FQRSwgQkFDS1NQQUNFLCBERUxFVEUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNkay5lczUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jZGsvQGFuZ3VsYXIvY2RrLmVzNS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1245\\n')\n},1246:function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n// 引入核心模块\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar router_1 = __webpack_require__(173);\\r\\nvar login_1 = __webpack_require__(477);\\r\\nvar home_1 = __webpack_require__(478);\\r\\nvar datav_1 = __webpack_require__(479);\\r\\nvar blog_list_1 = __webpack_require__(480);\\r\\nvar blog_edit_1 = __webpack_require__(481);\\r\\nvar routes = [\\r\\n    { path: 'login', component: login_1.LoginComponent },\\r\\n    { path: 'datav', component: datav_1.DatavComponent },\\r\\n    { path: 'bloglist', component: blog_list_1.BlogListComponent },\\r\\n    { path: 'blogedit', component: blog_edit_1.BlogEditComponent },\\r\\n    { path: '', component: home_1.HomeComponent },\\r\\n    { path: '', redirectTo: '', pathMatch: 'full' },\\r\\n];\\r\\nvar AppRoutingModule = (function () {\\r\\n    function AppRoutingModule() {\\r\\n    }\\r\\n    AppRoutingModule = __decorate([\\r\\n        core_1.NgModule({\\r\\n            imports: [\\r\\n                router_1.RouterModule.forRoot(routes)\\r\\n            ],\\r\\n            exports: [router_1.RouterModule]\\r\\n        })\\r\\n    ], AppRoutingModule);\\r\\n    return AppRoutingModule;\\r\\n}());\\r\\nexports.AppRoutingModule = AppRoutingModule;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLXJvdXRpbmcubW9kdWxlLnRzPzE3MWEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyDlvJXlhaXmoLjlv4PmqKHlnZdcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXJNb2R1bGUsIFJvdXRlcyB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbmltcG9ydCB7IExvZ2luQ29tcG9uZW50IH0gZnJvbSAnLi9sb2dpbic7XG5pbXBvcnQgeyBIb21lQ29tcG9uZW50IH0gZnJvbSAnLi9ob21lJztcbmltcG9ydCB7IERhdGF2Q29tcG9uZW50IH0gZnJvbSAnLi9kYXRhdic7XG5pbXBvcnQgeyBCbG9nTGlzdENvbXBvbmVudCB9IGZyb20gJy4vYmxvZy1saXN0JztcbmltcG9ydCB7IEJsb2dFZGl0Q29tcG9uZW50IH0gZnJvbSAnLi9ibG9nLWVkaXQnO1xuXG5jb25zdCByb3V0ZXM6IFJvdXRlcyA9IFtcbiAge3BhdGg6ICdsb2dpbicsIGNvbXBvbmVudDogTG9naW5Db21wb25lbnR9LFxuICB7cGF0aDogJ2RhdGF2JywgY29tcG9uZW50OiBEYXRhdkNvbXBvbmVudH0sXG4gIHtwYXRoOiAnYmxvZ2xpc3QnLCBjb21wb25lbnQ6IEJsb2dMaXN0Q29tcG9uZW50fSxcbiAge3BhdGg6ICdibG9nZWRpdCcsIGNvbXBvbmVudDogQmxvZ0VkaXRDb21wb25lbnR9LFxuICB7cGF0aDogJycsIGNvbXBvbmVudDogSG9tZUNvbXBvbmVudH0sXG4gIHsgcGF0aDogJycsIHJlZGlyZWN0VG86ICcnLCBwYXRoTWF0Y2g6ICdmdWxsJ30sXG4gIC8vIHsgcGF0aDogJyoqJywgY29tcG9uZW50OiBQYWdlTm90Rm91bmRDb21wb25lbnQgfVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIFJvdXRlck1vZHVsZS5mb3JSb290KHJvdXRlcylcbiAgXSxcbiAgZXhwb3J0czogW1JvdXRlck1vZHVsZV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBBcHBSb3V0aW5nTW9kdWxlIHsgfVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyPz9yZWYtLTAtMCEuL3NyYy9hcHAvYXBwLXJvdXRpbmcubW9kdWxlLnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBU0E7QUFBQTtBQUFBO0FBQUE7QUFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1246\\n\")},1247:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar core_1 = __webpack_require__(4);\\r\\n// import {\\r\\n//   LoginService\\r\\n// } from \\'./login.service\\';\\r\\nvar LoginComponent = (function () {\\r\\n    function LoginComponent() {\\r\\n    }\\r\\n    // constructor(private loginService: LoginService) {}\\r\\n    LoginComponent.prototype.ngOnInit = function () {\\r\\n        // this.getData();\\r\\n    };\\r\\n    LoginComponent = __decorate([\\r\\n        core_1.Component({\\r\\n            selector: \\'cv-login\\',\\r\\n            template: __webpack_require__(1248),\\r\\n            styles: [__webpack_require__(1249)],\\r\\n        })\\r\\n    ], LoginComponent);\\r\\n    return LoginComponent;\\r\\n}());\\r\\nexports.LoginComponent = LoginComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvbG9naW4vbG9naW4uY29tcG9uZW50LnRzPzc1ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8vIGltcG9ydCB7XG4vLyAgIExvZ2luU2VydmljZVxuLy8gfSBmcm9tICcuL2xvZ2luLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjdi1sb2dpbicsXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL2xvZ2luLmNvbXBvbmVudC5odG1sJyksXG4gIHN0eWxlczogW3JlcXVpcmUoJy4vbG9naW4uY29tcG9uZW50LnNjc3MnKV0sXG4gIC8vIHByb3ZpZGVyczogW0xvZ2luU2VydmljZV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBMb2dpbkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgLy8gY29uc3RydWN0b3IocHJpdmF0ZSBsb2dpblNlcnZpY2U6IExvZ2luU2VydmljZSkge31cblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgLy8gdGhpcy5nZXREYXRhKCk7XG4gIH1cblxuICAvLyBwcml2YXRlIGdldERhdGEoKSB7XG4gIC8vICAgdGhpcy5sb2dpblNlcnZpY2UuZ2V0SlNPTigpLnN1YnNjcmliZShcbiAgLy8gICAgIChyZXN1bHRzOiBhbnkpID0+IHtcbiAgLy8gICAgICAgY29uc29sZS53YXJuKHJlc3VsdHMpO1xuICAvLyAgICAgfSxcbiAgLy8gICAgIChlcnJvcjogYW55KSA9PiB7XG4gIC8vICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gIC8vICAgICB9XG4gIC8vICAgKTtcbiAgLy8gfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvdHNsaW50LWxvYWRlcj8/cmVmLS0wLTAhLi9zcmMvYXBwL2xvZ2luL2xvZ2luLmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQVNBO0FBQUE7QUFrQkE7QUFoQkE7QUFFQTtBQUNBO0FBQ0E7QUFOQTtBQVBBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQWtCQTtBQUFBO0FBbEJBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1247\\n')},1248:function(module,exports){eval('module.exports = \"<section class=\\\\\"containerX\\\\\">\\\\n  <div class=\\\\\"container\\\\\">\\\\n    <div class=\\\\\"margin-top-40 margin-bottom-40\\\\\" fxFlex fxLayoutAlign=\\\\\"center center\\\\\">\\\\n      <md-card class=\\\\\"box-shadow-dark-3\\\\\" fxFlex=\\\\\"60%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxLayout=\\\\\"row\\\\\" fxLayout.sm=\\\\\"column\\\\\" fxLayout.xs=\\\\\"column\\\\\">\\\\n\\\\n        <div class=\\\\\"login-bg\\\\\" fxFlex=\\\\\"50%\\\\\">\\\\n          \\x3c!--<img src=\\\\\"/src/assets/images/usercenter/login_bg_2.jpg\\\\\" alt=\\\\\"\\\\\">--\\x3e\\\\n          <div class=\\\\\"starme\\\\\">\\\\n            <a href=\\\\\"https://github.com/TaylorPzreal/curriculum-vitae\\\\\" target=\\\\\"_blank\\\\\" rel=\\\\\"noopener noreferrer\\\\\" md-button>Star CV</a>\\\\n          </div>\\\\n        </div>\\\\n\\\\n        <div class=\\\\\"relative padding-bottom-24 padding-16\\\\\" fxFlex=\\\\\"50%\\\\\">\\\\n          <md-card-header>\\\\n            <md-card-title>Welcome To CV</md-card-title>\\\\n          </md-card-header>\\\\n\\\\n          <md-card-content>\\\\n            <form>\\\\n              <div fxLayout=\\\\\"column\\\\\">\\\\n                <md-input-container fxFlex=\\\\\"100%\\\\\">\\\\n                  <input type=\\\\\"text\\\\\" name=\\\\\"\\\\\" value=\\\\\"\\\\\" mdInput placeholder=\\\\\"Name\\\\\">\\\\n                </md-input-container>\\\\n                <md-input-container fxFlex=\\\\\"100%\\\\\">\\\\n                  <input type=\\\\\"text\\\\\" mdInput placeholder=\\\\\"Password\\\\\">\\\\n                </md-input-container>\\\\n              </div>\\\\n            </form>\\\\n          </md-card-content>\\\\n\\\\n          <md-card-actions fxLayoutAlign=\\\\\"center center\\\\\">\\\\n            <button md-raised-button class=\\\\\"mat-default\\\\\"><i class=\\\\\"fa fa-github mat-primary\\\\\"></i> Log in with Github</button>\\\\n            <button type=\\\\\"\\\\\" class=\\\\\"mat-primary\\\\\" md-raised-button><md-icon>arrow_forward</md-icon>Log In</button>\\\\n          </md-card-actions>\\\\n\\\\n          <md-card-footer>\\\\n            <button md-button fxFlex fxFlexAlign=\\\\\"start\\\\\">Sign Up</button>\\\\n            <button md-button fxFlex fxFlexAlign=\\\\\"end\\\\\">Forget Password?</button>\\\\n          </md-card-footer>\\\\n\\\\n        </div>\\\\n      </md-card>\\\\n    </div>\\\\n  </div>\\\\n\\\\n</section>\";//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvbG9naW4vbG9naW4uY29tcG9uZW50Lmh0bWw/N2IxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPHNlY3Rpb24gY2xhc3M9XFxcImNvbnRhaW5lclhcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibWFyZ2luLXRvcC00MCBtYXJnaW4tYm90dG9tLTQwXFxcIiBmeEZsZXggZnhMYXlvdXRBbGlnbj1cXFwiY2VudGVyIGNlbnRlclxcXCI+XFxuICAgICAgPG1kLWNhcmQgY2xhc3M9XFxcImJveC1zaGFkb3ctZGFyay0zXFxcIiBmeEZsZXg9XFxcIjYwJVxcXCIgZnhGbGV4Lmx0LXNtPVxcXCIxMDAlXFxcIiBmeExheW91dD1cXFwicm93XFxcIiBmeExheW91dC5zbT1cXFwiY29sdW1uXFxcIiBmeExheW91dC54cz1cXFwiY29sdW1uXFxcIj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxvZ2luLWJnXFxcIiBmeEZsZXg9XFxcIjUwJVxcXCI+XFxuICAgICAgICAgIDwhLS08aW1nIHNyYz1cXFwiL3NyYy9hc3NldHMvaW1hZ2VzL3VzZXJjZW50ZXIvbG9naW5fYmdfMi5qcGdcXFwiIGFsdD1cXFwiXFxcIj4tLT5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwic3Rhcm1lXFxcIj5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCJodHRwczovL2dpdGh1Yi5jb20vVGF5bG9yUHpyZWFsL2N1cnJpY3VsdW0tdml0YWVcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiByZWw9XFxcIm5vb3BlbmVyIG5vcmVmZXJyZXJcXFwiIG1kLWJ1dHRvbj5TdGFyIENWPC9hPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVsYXRpdmUgcGFkZGluZy1ib3R0b20tMjQgcGFkZGluZy0xNlxcXCIgZnhGbGV4PVxcXCI1MCVcXFwiPlxcbiAgICAgICAgICA8bWQtY2FyZC1oZWFkZXI+XFxuICAgICAgICAgICAgPG1kLWNhcmQtdGl0bGU+V2VsY29tZSBUbyBDVjwvbWQtY2FyZC10aXRsZT5cXG4gICAgICAgICAgPC9tZC1jYXJkLWhlYWRlcj5cXG5cXG4gICAgICAgICAgPG1kLWNhcmQtY29udGVudD5cXG4gICAgICAgICAgICA8Zm9ybT5cXG4gICAgICAgICAgICAgIDxkaXYgZnhMYXlvdXQ9XFxcImNvbHVtblxcXCI+XFxuICAgICAgICAgICAgICAgIDxtZC1pbnB1dC1jb250YWluZXIgZnhGbGV4PVxcXCIxMDAlXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwiXFxcIiB2YWx1ZT1cXFwiXFxcIiBtZElucHV0IHBsYWNlaG9sZGVyPVxcXCJOYW1lXFxcIj5cXG4gICAgICAgICAgICAgICAgPC9tZC1pbnB1dC1jb250YWluZXI+XFxuICAgICAgICAgICAgICAgIDxtZC1pbnB1dC1jb250YWluZXIgZnhGbGV4PVxcXCIxMDAlXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgbWRJbnB1dCBwbGFjZWhvbGRlcj1cXFwiUGFzc3dvcmRcXFwiPlxcbiAgICAgICAgICAgICAgICA8L21kLWlucHV0LWNvbnRhaW5lcj5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZm9ybT5cXG4gICAgICAgICAgPC9tZC1jYXJkLWNvbnRlbnQ+XFxuXFxuICAgICAgICAgIDxtZC1jYXJkLWFjdGlvbnMgZnhMYXlvdXRBbGlnbj1cXFwiY2VudGVyIGNlbnRlclxcXCI+XFxuICAgICAgICAgICAgPGJ1dHRvbiBtZC1yYWlzZWQtYnV0dG9uIGNsYXNzPVxcXCJtYXQtZGVmYXVsdFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWdpdGh1YiBtYXQtcHJpbWFyeVxcXCI+PC9pPiBMb2cgaW4gd2l0aCBHaXRodWI8L2J1dHRvbj5cXG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcIlxcXCIgY2xhc3M9XFxcIm1hdC1wcmltYXJ5XFxcIiBtZC1yYWlzZWQtYnV0dG9uPjxtZC1pY29uPmFycm93X2ZvcndhcmQ8L21kLWljb24+TG9nIEluPC9idXR0b24+XFxuICAgICAgICAgIDwvbWQtY2FyZC1hY3Rpb25zPlxcblxcbiAgICAgICAgICA8bWQtY2FyZC1mb290ZXI+XFxuICAgICAgICAgICAgPGJ1dHRvbiBtZC1idXR0b24gZnhGbGV4IGZ4RmxleEFsaWduPVxcXCJzdGFydFxcXCI+U2lnbiBVcDwvYnV0dG9uPlxcbiAgICAgICAgICAgIDxidXR0b24gbWQtYnV0dG9uIGZ4RmxleCBmeEZsZXhBbGlnbj1cXFwiZW5kXFxcIj5Gb3JnZXQgUGFzc3dvcmQ/PC9idXR0b24+XFxuICAgICAgICAgIDwvbWQtY2FyZC1mb290ZXI+XFxuXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L21kLWNhcmQ+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXFxuPC9zZWN0aW9uPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9sb2dpbi9sb2dpbi5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTI0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1248\\n')},1249:function(module,exports){eval('module.exports = \".login-bg {\\\\n  background-color: #222831;\\\\n  background-image: url(\\\\\"src/assets/images/usercenter/login_bg_2.jpg\\\\\");\\\\n  background-repeat: no-repeat;\\\\n  background-position: center center;\\\\n  background-size: cover;\\\\n  overflow: hidden; }\\\\n\\\\n.mat-card-header .mat-card-title {\\\\n  font-family: \\'Dancing Script\\', cursive;\\\\n  font-size: 2.8rem; }\\\\n\\\\n.mat-card {\\\\n  box-shadow: 0.3rem 0.3rem 0.3rem #222831, 0.3rem -0.3rem 0.3rem #222831, -0.3rem -0.3rem 0.3rem #222831, -0.3rem 0.3rem 0.3rem #222831;\\\\n  padding: 0; }\\\\n\\\\n.starme {\\\\n  position: relative; }\\\\n  .starme a {\\\\n    color: #fff;\\\\n    background-color: #b83b5e;\\\\n    padding-left: 3rem;\\\\n    padding-right: 3rem;\\\\n    position: absolute;\\\\n    left: -2.4rem;\\\\n    top: 1rem;\\\\n    transform: rotate(-45deg);\\\\n    transition-delay: 1s;\\\\n    font-family: \\\\\"Abel\\\\\", sans-serif; }\\\\n\"//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvbG9naW4vbG9naW4uY29tcG9uZW50LnNjc3M/NzkzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLmxvZ2luLWJnIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyMjI4MzE7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcInNyYy9hc3NldHMvaW1hZ2VzL3VzZXJjZW50ZXIvbG9naW5fYmdfMi5qcGdcXFwiKTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyO1xcbiAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG5cXG4ubWF0LWNhcmQtaGVhZGVyIC5tYXQtY2FyZC10aXRsZSB7XFxuICBmb250LWZhbWlseTogJ0RhbmNpbmcgU2NyaXB0JywgY3Vyc2l2ZTtcXG4gIGZvbnQtc2l6ZTogMi44cmVtOyB9XFxuXFxuLm1hdC1jYXJkIHtcXG4gIGJveC1zaGFkb3c6IDAuM3JlbSAwLjNyZW0gMC4zcmVtICMyMjI4MzEsIDAuM3JlbSAtMC4zcmVtIDAuM3JlbSAjMjIyODMxLCAtMC4zcmVtIC0wLjNyZW0gMC4zcmVtICMyMjI4MzEsIC0wLjNyZW0gMC4zcmVtIDAuM3JlbSAjMjIyODMxO1xcbiAgcGFkZGluZzogMDsgfVxcblxcbi5zdGFybWUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAuc3Rhcm1lIGEge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2I4M2I1ZTtcXG4gICAgcGFkZGluZy1sZWZ0OiAzcmVtO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAzcmVtO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGxlZnQ6IC0yLjRyZW07XFxuICAgIHRvcDogMXJlbTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTtcXG4gICAgdHJhbnNpdGlvbi1kZWxheTogMXM7XFxuICAgIGZvbnQtZmFtaWx5OiBcXFwiQWJlbFxcXCIsIHNhbnMtc2VyaWY7IH1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9sb2dpbi9sb2dpbi5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1249\\n')},1250:function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar THREE = __webpack_require__(187);\\r\\nvar OrbitControls = __webpack_require__(1251);\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar HomeComponent = (function () {\\r\\n    function HomeComponent() {\\r\\n    }\\r\\n    HomeComponent.prototype.ngOnInit = function () {\\r\\n        this.initHoneyThree();\\r\\n    };\\r\\n    HomeComponent.prototype.initHoneyThree = function () {\\r\\n        console.warn('投影');\\r\\n        var scene;\\r\\n        var camera;\\r\\n        var renderer;\\r\\n        // let material: THREE.MeshLambertMaterial;\\r\\n        // let rocks: Rock;\\r\\n        var angle = 0;\\r\\n        var width = document.body.clientWidth;\\r\\n        var height = window.innerHeight;\\r\\n        function initScene() {\\r\\n            scene = new THREE.Scene();\\r\\n            camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);\\r\\n            camera.position.set(0, 30, 50);\\r\\n            camera.lookAt(new THREE.Vector3(0, 15, 0));\\r\\n            renderer = new THREE.WebGLRenderer({\\r\\n                antialias: true\\r\\n            });\\r\\n            renderer.setSize(width, height);\\r\\n            renderer.setClearColor(0x393e46);\\r\\n            renderer.shadowMap.enabled = true;\\r\\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\\r\\n            document.getElementById('honeythree').appendChild(renderer.domElement);\\r\\n        }\\r\\n        function initLights() {\\r\\n            var ambientLight = new THREE.AmbientLight(0xffffff, 0.2);\\r\\n            // light.position.set(300, 300, 0);\\r\\n            scene.add(ambientLight);\\r\\n            var pointLight = new THREE.PointLight(0xffffff, 1);\\r\\n            pointLight.position.set(25, 50, 25);\\r\\n            pointLight.castShadow = true;\\r\\n            pointLight.shadow.mapSize.width = 1024;\\r\\n            pointLight.shadow.mapSize.height = 1024;\\r\\n            scene.add(pointLight);\\r\\n        }\\r\\n        function initMesh() {\\r\\n            var shadowMaterisl = new THREE.ShadowMaterial(0xeeeeee);\\r\\n            shadowMaterisl.opacity = 0.5;\\r\\n            var groundMesh = new THREE.Mesh(new THREE.BoxGeometry(100, .1, 100), shadowMaterisl);\\r\\n            groundMesh.receiveShadow = true;\\r\\n            scene.add(groundMesh);\\r\\n        }\\r\\n        function generateShapes() {\\r\\n            // A simple geometric shape with a flat material\\r\\n            var shapeOne = new THREE.Mesh(new THREE.OctahedronGeometry(10, 1), new THREE.MeshStandardMaterial({\\r\\n                color: 0xff0051,\\r\\n                shading: THREE.FlatShading,\\r\\n                metalness: 0,\\r\\n                roughness: 0.8\\r\\n            }));\\r\\n            shapeOne.position.y += 10;\\r\\n            shapeOne.rotateZ(Math.PI / 3);\\r\\n            shapeOne.castShadow = true;\\r\\n            scene.add(shapeOne);\\r\\n            // Add a second shape\\r\\n            var shapeTwo = new THREE.Mesh(new THREE.OctahedronGeometry(5, 1), new THREE.MeshStandardMaterial({\\r\\n                color: 0x47689b,\\r\\n                shading: THREE.FlatShading,\\r\\n                metalness: 0,\\r\\n                roughness: 0.8\\r\\n            }));\\r\\n            shapeTwo.position.y += 5;\\r\\n            shapeTwo.position.x += 15;\\r\\n            shapeTwo.rotateZ(Math.PI / 5);\\r\\n            shapeTwo.castShadow = true;\\r\\n            scene.add(shapeTwo);\\r\\n        }\\r\\n        function render() {\\r\\n            // requestAnimationFrame(render);\\r\\n            renderer.render(scene, camera);\\r\\n            // updateCamPosition();\\r\\n        }\\r\\n        function updateCamPosition() {\\r\\n            angle += 0.005;\\r\\n            var z = 50 * Math.cos(angle);\\r\\n            var y = 50 * Math.sin(angle);\\r\\n            // camera.position.z = z;\\r\\n            camera.position.y = y;\\r\\n            // camera.rotation.x = z * 0.02;\\r\\n        }\\r\\n        // function resize() {\\r\\n        //   // camera.aspect = width / height;\\r\\n        //   camera.updateMatrix();\\r\\n        //   renderer.setSize(width, height);\\r\\n        // }\\r\\n        // window.addEventListener('resize', resize);\\r\\n        function initControls() {\\r\\n            var controls = new OrbitControls(camera, renderer.domElement);\\r\\n            controls.target = new THREE.Vector3(0, 15, 0);\\r\\n            controls.maxPolarAngle = Math.PI / 2;\\r\\n            controls.addEventListener('change', function () {\\r\\n                renderer.render(scene, camera);\\r\\n            });\\r\\n        }\\r\\n        initScene();\\r\\n        initLights();\\r\\n        initMesh();\\r\\n        generateShapes();\\r\\n        initControls();\\r\\n        render();\\r\\n    };\\r\\n    HomeComponent = __decorate([\\r\\n        core_1.Component({\\r\\n            selector: 'cv-home',\\r\\n            template: __webpack_require__(1252),\\r\\n            styles: [__webpack_require__(1253)]\\r\\n        })\\r\\n    ], HomeComponent);\\r\\n    return HomeComponent;\\r\\n}());\\r\\nexports.HomeComponent = HomeComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC50cz8xNjI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmNvbnN0IE9yYml0Q29udHJvbHMgPSByZXF1aXJlKCd0aHJlZS1vcmJpdGNvbnRyb2xzJyk7XG5cbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjdi1ob21lJyxcbiAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vaG9tZS5jb21wb25lbnQuaHRtbCcpLFxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL2hvbWUuY29tcG9uZW50LnNjc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBIb21lQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG5cbiAgICB0aGlzLmluaXRIb25leVRocmVlKCk7XG4gIH1cblxuICBwdWJsaWMgaW5pdEhvbmV5VGhyZWUoKTogdm9pZCB7XG4gICAgY29uc29sZS53YXJuKCfmipXlvbEnKTtcblxuICAgIGxldCBzY2VuZTogVEhSRUUuU2NlbmU7XG4gICAgbGV0IGNhbWVyYTogVEhSRUUuQ2FtZXJhO1xuICAgIGxldCByZW5kZXJlcjogVEhSRUUuV2ViR0xSZW5kZXJlcjtcbiAgICAvLyBsZXQgbWF0ZXJpYWw6IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWw7XG4gICAgLy8gbGV0IHJvY2tzOiBSb2NrO1xuICAgIGxldCBhbmdsZTogbnVtYmVyID0gMDtcblxuICAgIGNvbnN0IHdpZHRoID0gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICBmdW5jdGlvbiBpbml0U2NlbmUoKSB7XG4gICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDYwLCB3aWR0aCAvIGhlaWdodCwgMC4xLCAxMDAwKTtcbiAgICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMzAsIDUwKTtcbiAgICAgIGNhbWVyYS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoMCwgMTUsIDApKTtcbiAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgICBhbnRpYWxpYXM6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHgzOTNlNDYpO1xuICAgICAgcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgcmVuZGVyZXIuc2hhZG93TWFwLnR5cGUgPSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwO1xuXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaG9uZXl0aHJlZScpLmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRMaWdodHMoKSB7XG4gICAgICBjb25zdCBhbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4ZmZmZmZmLCAwLjIpO1xuICAgICAgLy8gbGlnaHQucG9zaXRpb24uc2V0KDMwMCwgMzAwLCAwKTtcbiAgICAgIHNjZW5lLmFkZChhbWJpZW50TGlnaHQpO1xuXG4gICAgICBjb25zdCBwb2ludExpZ2h0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoMHhmZmZmZmYsIDEpO1xuICAgICAgcG9pbnRMaWdodC5wb3NpdGlvbi5zZXQoMjUsIDUwLCAyNSk7XG4gICAgICBwb2ludExpZ2h0LmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgcG9pbnRMaWdodC5zaGFkb3cubWFwU2l6ZS53aWR0aCA9IDEwMjQ7XG4gICAgICBwb2ludExpZ2h0LnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IDEwMjQ7XG4gICAgICBzY2VuZS5hZGQocG9pbnRMaWdodCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdE1lc2goKSB7XG4gICAgICBjb25zdCBzaGFkb3dNYXRlcmlzbCA9IG5ldyBUSFJFRS5TaGFkb3dNYXRlcmlhbCgweGVlZWVlZSk7XG4gICAgICBzaGFkb3dNYXRlcmlzbC5vcGFjaXR5ID0gMC41O1xuICAgICAgY29uc3QgZ3JvdW5kTWVzaCA9IG5ldyBUSFJFRS5NZXNoKFxuICAgICAgICBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMTAwLCAuMSwgMTAwKSxcbiAgICAgICAgc2hhZG93TWF0ZXJpc2xcbiAgICAgICk7XG4gICAgICBncm91bmRNZXNoLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgICAgc2NlbmUuYWRkKGdyb3VuZE1lc2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlU2hhcGVzKCkge1xuICAgICAgLy8gQSBzaW1wbGUgZ2VvbWV0cmljIHNoYXBlIHdpdGggYSBmbGF0IG1hdGVyaWFsXG4gICAgICBjb25zdCBzaGFwZU9uZSA9IG5ldyBUSFJFRS5NZXNoKFxuICAgICAgICBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KDEwLCAxKSxcbiAgICAgICAgbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgICAgICBjb2xvcjogMHhmZjAwNTEsXG4gICAgICAgICAgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsXG4gICAgICAgICAgbWV0YWxuZXNzOiAwLFxuICAgICAgICAgIHJvdWdobmVzczogMC44XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgc2hhcGVPbmUucG9zaXRpb24ueSArPSAxMDtcbiAgICAgIHNoYXBlT25lLnJvdGF0ZVooTWF0aC5QSSAvIDMpO1xuICAgICAgc2hhcGVPbmUuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICBzY2VuZS5hZGQoc2hhcGVPbmUpO1xuXG4gICAgICAvLyBBZGQgYSBzZWNvbmQgc2hhcGVcbiAgICAgIGNvbnN0IHNoYXBlVHdvID0gbmV3IFRIUkVFLk1lc2goXG4gICAgICAgIG5ldyBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkoNSwgMSksXG4gICAgICAgIG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICAgICAgY29sb3I6IDB4NDc2ODliLFxuICAgICAgICAgIHNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nLFxuICAgICAgICAgIG1ldGFsbmVzczogMCxcbiAgICAgICAgICByb3VnaG5lc3M6IDAuOFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHNoYXBlVHdvLnBvc2l0aW9uLnkgKz0gNTtcbiAgICAgIHNoYXBlVHdvLnBvc2l0aW9uLnggKz0gMTU7XG4gICAgICBzaGFwZVR3by5yb3RhdGVaKE1hdGguUEkgLyA1KTtcbiAgICAgIHNoYXBlVHdvLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgc2NlbmUuYWRkKHNoYXBlVHdvKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcblxuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuXG4gICAgICAvLyB1cGRhdGVDYW1Qb3NpdGlvbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbVBvc2l0aW9uKCkge1xuICAgICAgYW5nbGUgKz0gMC4wMDU7XG4gICAgICBjb25zdCB6ID0gNTAgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICBjb25zdCB5ID0gNTAgKiBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgIC8vIGNhbWVyYS5wb3NpdGlvbi56ID0gejtcbiAgICAgIGNhbWVyYS5wb3NpdGlvbi55ID0geTtcbiAgICAgIC8vIGNhbWVyYS5yb3RhdGlvbi54ID0geiAqIDAuMDI7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gcmVzaXplKCkge1xuICAgIC8vICAgLy8gY2FtZXJhLmFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIC8vICAgY2FtZXJhLnVwZGF0ZU1hdHJpeCgpO1xuICAgIC8vICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAvLyB9XG5cbiAgICAvLyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplKTtcblxuICAgIGZ1bmN0aW9uIGluaXRDb250cm9scygpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xzID0gIG5ldyBPcmJpdENvbnRyb2xzKFxuICAgICAgICBjYW1lcmEsIHJlbmRlcmVyLmRvbUVsZW1lbnRcbiAgICAgICk7XG4gICAgICBjb250cm9scy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAxNSwgMCk7XG4gICAgICBjb250cm9scy5tYXhQb2xhckFuZ2xlID0gTWF0aC5QSSAvIDI7XG4gICAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGluaXRTY2VuZSgpO1xuICAgIGluaXRMaWdodHMoKTtcbiAgICBpbml0TWVzaCgpO1xuICAgIGdlbmVyYXRlU2hhcGVzKCk7XG4gICAgaW5pdENvbnRyb2xzKCk7XG4gICAgcmVuZGVyKCk7XG5cbiAgfVxuXG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50LnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQVdBO0FBQUE7QUE0SUE7QUExSUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQXpJQTtBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQTRJQTtBQUFBO0FBNUlBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1250\\n\")},1251:function(module,exports,__webpack_require__){\neval(\"var THREE = __webpack_require__(187)\\n\\n/**\\n * @author qiao / https://github.com/qiao\\n * @author mrdoob / http://mrdoob.com\\n * @author alteredq / http://alteredqualia.com/\\n * @author WestLangley / http://github.com/WestLangley\\n * @author erich666 / http://erichaines.com\\n */\\n\\n// This set of controls performs orbiting, dollying (zooming), and panning.\\n// Unlike TrackballControls, it maintains the \\\"up\\\" direction object.up (+Y by default).\\n//\\n//    Orbit - left mouse / touch: one finger move\\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\\n//    Pan - right mouse, or arrow keys / touch: three finger swipe\\n\\nfunction OrbitControls ( object, domElement ) {\\n\\n\\tthis.object = object;\\n\\n\\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\\n\\n\\t// Set to false to disable this control\\n\\tthis.enabled = true;\\n\\n\\t// \\\"target\\\" sets the location of focus, where the object orbits around\\n\\tthis.target = new THREE.Vector3();\\n\\n\\t// How far you can dolly in and out ( PerspectiveCamera only )\\n\\tthis.minDistance = 0;\\n\\tthis.maxDistance = Infinity;\\n\\n\\t// How far you can zoom in and out ( OrthographicCamera only )\\n\\tthis.minZoom = 0;\\n\\tthis.maxZoom = Infinity;\\n\\n\\t// How far you can orbit vertically, upper and lower limits.\\n\\t// Range is 0 to Math.PI radians.\\n\\tthis.minPolarAngle = 0; // radians\\n\\tthis.maxPolarAngle = Math.PI; // radians\\n\\n\\t// How far you can orbit horizontally, upper and lower limits.\\n\\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\\n\\tthis.minAzimuthAngle = - Infinity; // radians\\n\\tthis.maxAzimuthAngle = Infinity; // radians\\n\\n\\t// Set to true to enable damping (inertia)\\n\\t// If damping is enabled, you must call controls.update() in your animation loop\\n\\tthis.enableDamping = false;\\n\\tthis.dampingFactor = 0.25;\\n\\n\\t// This option actually enables dollying in and out; left as \\\"zoom\\\" for backwards compatibility.\\n\\t// Set to false to disable zooming\\n\\tthis.enableZoom = true;\\n\\tthis.zoomSpeed = 1.0;\\n\\n\\t// Set to false to disable rotating\\n\\tthis.enableRotate = true;\\n\\tthis.rotateSpeed = 1.0;\\n\\n\\t// Set to false to disable panning\\n\\tthis.enablePan = true;\\n\\tthis.keyPanSpeed = 7.0;\\t// pixels moved per arrow key push\\n\\n\\t// Set to true to automatically rotate around the target\\n\\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\\n\\tthis.autoRotate = false;\\n\\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\\n\\n\\t// Set to false to disable use of the keys\\n\\tthis.enableKeys = true;\\n\\n\\t// The four arrow keys\\n\\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\\n\\n\\t// Mouse buttons\\n\\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\\n\\n\\t// for reset\\n\\tthis.target0 = this.target.clone();\\n\\tthis.position0 = this.object.position.clone();\\n\\tthis.zoom0 = this.object.zoom;\\n\\n\\t//\\n\\t// public methods\\n\\t//\\n\\n\\tthis.getPolarAngle = function () {\\n\\n\\t\\treturn spherical.phi;\\n\\n\\t};\\n\\n\\tthis.getAzimuthalAngle = function () {\\n\\n\\t\\treturn spherical.theta;\\n\\n\\t};\\n\\n\\tthis.saveState = function () {\\n\\n\\t\\tscope.target0.copy( scope.target );\\n\\t\\tscope.position0.copy( scope.object.position );\\n\\t\\tscope.zoom0 = scope.object.zoom;\\n\\n\\t};\\n\\n\\tthis.reset = function () {\\n\\n\\t\\tscope.target.copy( scope.target0 );\\n\\t\\tscope.object.position.copy( scope.position0 );\\n\\t\\tscope.object.zoom = scope.zoom0;\\n\\n\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\tscope.update();\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t};\\n\\n\\t// this method is exposed, but perhaps it would be better if we can make it private...\\n\\tthis.update = function () {\\n\\n\\t\\tvar offset = new THREE.Vector3();\\n\\n\\t\\t// so camera.up is the orbit axis\\n\\t\\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\\n\\t\\tvar quatInverse = quat.clone().inverse();\\n\\n\\t\\tvar lastPosition = new THREE.Vector3();\\n\\t\\tvar lastQuaternion = new THREE.Quaternion();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tvar position = scope.object.position;\\n\\n\\t\\t\\toffset.copy( position ).sub( scope.target );\\n\\n\\t\\t\\t// rotate offset to \\\"y-axis-is-up\\\" space\\n\\t\\t\\toffset.applyQuaternion( quat );\\n\\n\\t\\t\\t// angle from z-axis around y-axis\\n\\t\\t\\tspherical.setFromVector3( offset );\\n\\n\\t\\t\\tif ( scope.autoRotate && state === STATE.NONE ) {\\n\\n\\t\\t\\t\\trotateLeft( getAutoRotationAngle() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tspherical.theta += sphericalDelta.theta;\\n\\t\\t\\tspherical.phi += sphericalDelta.phi;\\n\\n\\t\\t\\t// restrict theta to be between desired limits\\n\\t\\t\\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\\n\\n\\t\\t\\t// restrict phi to be between desired limits\\n\\t\\t\\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\\n\\n\\t\\t\\tspherical.makeSafe();\\n\\n\\n\\t\\t\\tspherical.radius *= scale;\\n\\n\\t\\t\\t// restrict radius to be between desired limits\\n\\t\\t\\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\\n\\n\\t\\t\\t// move target to panned location\\n\\t\\t\\tscope.target.add( panOffset );\\n\\n\\t\\t\\toffset.setFromSpherical( spherical );\\n\\n\\t\\t\\t// rotate offset back to \\\"camera-up-vector-is-up\\\" space\\n\\t\\t\\toffset.applyQuaternion( quatInverse );\\n\\n\\t\\t\\tposition.copy( scope.target ).add( offset );\\n\\n\\t\\t\\tscope.object.lookAt( scope.target );\\n\\n\\t\\t\\tif ( scope.enableDamping === true ) {\\n\\n\\t\\t\\t\\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\\n\\t\\t\\t\\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tsphericalDelta.set( 0, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscale = 1;\\n\\t\\t\\tpanOffset.set( 0, 0, 0 );\\n\\n\\t\\t\\t// update condition is:\\n\\t\\t\\t// min(camera displacement, camera rotation in radians)^2 > EPS\\n\\t\\t\\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\\n\\n\\t\\t\\tif ( zoomChanged ||\\n\\t\\t\\t\\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\\n\\t\\t\\t\\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\\n\\n\\t\\t\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\t\\t\\tlastPosition.copy( scope.object.position );\\n\\t\\t\\t\\tlastQuaternion.copy( scope.object.quaternion );\\n\\t\\t\\t\\tzoomChanged = false;\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tthis.dispose = function () {\\n\\n\\t\\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\\n\\t\\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\\n\\t\\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\\n\\n\\t\\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\\n\\t\\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\\n\\t\\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\\n\\n\\t\\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\\n\\n\\t\\twindow.removeEventListener( 'keydown', onKeyDown, false );\\n\\n\\t\\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\\n\\n\\t};\\n\\n\\t//\\n\\t// internals\\n\\t//\\n\\n\\tvar scope = this;\\n\\n\\tvar changeEvent = { type: 'change' };\\n\\tvar startEvent = { type: 'start' };\\n\\tvar endEvent = { type: 'end' };\\n\\n\\tvar STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\\n\\n\\tvar state = STATE.NONE;\\n\\n\\tvar EPS = 0.000001;\\n\\n\\t// current position in spherical coordinates\\n\\tvar spherical = new THREE.Spherical();\\n\\tvar sphericalDelta = new THREE.Spherical();\\n\\n\\tvar scale = 1;\\n\\tvar panOffset = new THREE.Vector3();\\n\\tvar zoomChanged = false;\\n\\n\\tvar rotateStart = new THREE.Vector2();\\n\\tvar rotateEnd = new THREE.Vector2();\\n\\tvar rotateDelta = new THREE.Vector2();\\n\\n\\tvar panStart = new THREE.Vector2();\\n\\tvar panEnd = new THREE.Vector2();\\n\\tvar panDelta = new THREE.Vector2();\\n\\n\\tvar dollyStart = new THREE.Vector2();\\n\\tvar dollyEnd = new THREE.Vector2();\\n\\tvar dollyDelta = new THREE.Vector2();\\n\\n\\tfunction getAutoRotationAngle() {\\n\\n\\t\\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\\n\\n\\t}\\n\\n\\tfunction getZoomScale() {\\n\\n\\t\\treturn Math.pow( 0.95, scope.zoomSpeed );\\n\\n\\t}\\n\\n\\tfunction rotateLeft( angle ) {\\n\\n\\t\\tsphericalDelta.theta -= angle;\\n\\n\\t}\\n\\n\\tfunction rotateUp( angle ) {\\n\\n\\t\\tsphericalDelta.phi -= angle;\\n\\n\\t}\\n\\n\\tvar panLeft = function () {\\n\\n\\t\\tvar v = new THREE.Vector3();\\n\\n\\t\\treturn function panLeft( distance, objectMatrix ) {\\n\\n\\t\\t\\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\\n\\t\\t\\tv.multiplyScalar( - distance );\\n\\n\\t\\t\\tpanOffset.add( v );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tvar panUp = function () {\\n\\n\\t\\tvar v = new THREE.Vector3();\\n\\n\\t\\treturn function panUp( distance, objectMatrix ) {\\n\\n\\t\\t\\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\\n\\t\\t\\tv.multiplyScalar( distance );\\n\\n\\t\\t\\tpanOffset.add( v );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t// deltaX and deltaY are in pixels; right and down are positive\\n\\tvar pan = function () {\\n\\n\\t\\tvar offset = new THREE.Vector3();\\n\\n\\t\\treturn function pan( deltaX, deltaY ) {\\n\\n\\t\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t\\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\\n\\n\\t\\t\\t\\t// perspective\\n\\t\\t\\t\\tvar position = scope.object.position;\\n\\t\\t\\t\\toffset.copy( position ).sub( scope.target );\\n\\t\\t\\t\\tvar targetDistance = offset.length();\\n\\n\\t\\t\\t\\t// half of the fov is center to top of screen\\n\\t\\t\\t\\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\\n\\n\\t\\t\\t\\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\\n\\t\\t\\t\\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\\n\\t\\t\\t\\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\\n\\n\\t\\t\\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\\n\\n\\t\\t\\t\\t// orthographic\\n\\t\\t\\t\\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\\n\\t\\t\\t\\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// camera neither orthographic nor perspective\\n\\t\\t\\t\\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\\n\\t\\t\\t\\tscope.enablePan = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tfunction dollyIn( dollyScale ) {\\n\\n\\t\\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\\n\\n\\t\\t\\tscale /= dollyScale;\\n\\n\\t\\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\\n\\n\\t\\t\\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\\n\\t\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\t\\tzoomChanged = true;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\\n\\t\\t\\tscope.enableZoom = false;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction dollyOut( dollyScale ) {\\n\\n\\t\\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\\n\\n\\t\\t\\tscale *= dollyScale;\\n\\n\\t\\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\\n\\n\\t\\t\\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\\n\\t\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\t\\tzoomChanged = true;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\\n\\t\\t\\tscope.enableZoom = false;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t//\\n\\t// event callbacks - update the object state\\n\\t//\\n\\n\\tfunction handleMouseDownRotate( event ) {\\n\\n\\t\\t//console.log( 'handleMouseDownRotate' );\\n\\n\\t\\trotateStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseDownDolly( event ) {\\n\\n\\t\\t//console.log( 'handleMouseDownDolly' );\\n\\n\\t\\tdollyStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseDownPan( event ) {\\n\\n\\t\\t//console.log( 'handleMouseDownPan' );\\n\\n\\t\\tpanStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseMoveRotate( event ) {\\n\\n\\t\\t//console.log( 'handleMouseMoveRotate' );\\n\\n\\t\\trotateEnd.set( event.clientX, event.clientY );\\n\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\n\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseMoveDolly( event ) {\\n\\n\\t\\t//console.log( 'handleMouseMoveDolly' );\\n\\n\\t\\tdollyEnd.set( event.clientX, event.clientY );\\n\\n\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t} else if ( dollyDelta.y < 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseMovePan( event ) {\\n\\n\\t\\t//console.log( 'handleMouseMovePan' );\\n\\n\\t\\tpanEnd.set( event.clientX, event.clientY );\\n\\n\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\n\\t\\tpan( panDelta.x, panDelta.y );\\n\\n\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseUp( event ) {\\n\\n\\t\\t// console.log( 'handleMouseUp' );\\n\\n\\t}\\n\\n\\tfunction handleMouseWheel( event ) {\\n\\n\\t\\t// console.log( 'handleMouseWheel' );\\n\\n\\t\\tif ( event.deltaY < 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t} else if ( event.deltaY > 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleKeyDown( event ) {\\n\\n\\t\\t//console.log( 'handleKeyDown' );\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\n\\t\\t\\tcase scope.keys.UP:\\n\\t\\t\\t\\tpan( 0, scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.BOTTOM:\\n\\t\\t\\t\\tpan( 0, - scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.LEFT:\\n\\t\\t\\t\\tpan( scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.RIGHT:\\n\\t\\t\\t\\tpan( - scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction handleTouchStartRotate( event ) {\\n\\n\\t\\t//console.log( 'handleTouchStartRotate' );\\n\\n\\t\\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t}\\n\\n\\tfunction handleTouchStartDolly( event ) {\\n\\n\\t\\t//console.log( 'handleTouchStartDolly' );\\n\\n\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\n\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\tdollyStart.set( 0, distance );\\n\\n\\t}\\n\\n\\tfunction handleTouchStartPan( event ) {\\n\\n\\t\\t//console.log( 'handleTouchStartPan' );\\n\\n\\t\\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t}\\n\\n\\tfunction handleTouchMoveRotate( event ) {\\n\\n\\t\\t//console.log( 'handleTouchMoveRotate' );\\n\\n\\t\\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\n\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchMoveDolly( event ) {\\n\\n\\t\\t//console.log( 'handleTouchMoveDolly' );\\n\\n\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\n\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\tdollyEnd.set( 0, distance );\\n\\n\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t} else if ( dollyDelta.y < 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchMovePan( event ) {\\n\\n\\t\\t//console.log( 'handleTouchMovePan' );\\n\\n\\t\\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\n\\t\\tpan( panDelta.x, panDelta.y );\\n\\n\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchEnd( event ) {\\n\\n\\t\\t//console.log( 'handleTouchEnd' );\\n\\n\\t}\\n\\n\\t//\\n\\t// event handlers - FSM: listen for events and reset state\\n\\t//\\n\\n\\tfunction onMouseDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tswitch ( event.button ) {\\n\\n\\t\\t\\tcase scope.mouseButtons.ORBIT:\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownRotate( event );\\n\\n\\t\\t\\t\\tstate = STATE.ROTATE;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.mouseButtons.ZOOM:\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownDolly( event );\\n\\n\\t\\t\\t\\tstate = STATE.DOLLY;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.mouseButtons.PAN:\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownPan( event );\\n\\n\\t\\t\\t\\tstate = STATE.PAN;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t\\tif ( state !== STATE.NONE ) {\\n\\n\\t\\t\\tdocument.addEventListener( 'mousemove', onMouseMove, false );\\n\\t\\t\\tdocument.addEventListener( 'mouseup', onMouseUp, false );\\n\\n\\t\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onMouseMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tswitch ( state ) {\\n\\n\\t\\t\\tcase STATE.ROTATE:\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMoveRotate( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase STATE.DOLLY:\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMoveDolly( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase STATE.PAN:\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMovePan( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onMouseUp( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\thandleMouseUp( event );\\n\\n\\t\\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\\n\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onMouseWheel( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\thandleMouseWheel( event );\\n\\n\\t\\tscope.dispatchEvent( startEvent ); // not sure why these are here...\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t}\\n\\n\\tfunction onKeyDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\\n\\n\\t\\thandleKeyDown( event );\\n\\n\\t}\\n\\n\\tfunction onTouchStart( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\t// one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartRotate( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_ROTATE;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\t// two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartDolly( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_DOLLY;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartPan( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_PAN;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t\\tif ( state !== STATE.NONE ) {\\n\\n\\t\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onTouchMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1: // one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMoveRotate( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2: // two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMoveDolly( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMovePan( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onTouchEnd( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\thandleTouchEnd( event );\\n\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onContextMenu( event ) {\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t}\\n\\n\\t//\\n\\n\\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\\n\\n\\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\\n\\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\\n\\n\\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\\n\\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\\n\\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\\n\\n\\twindow.addEventListener( 'keydown', onKeyDown, false );\\n\\n\\t// force an update at start\\n\\n\\tthis.update();\\n\\n};\\n\\nOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\\nOrbitControls.prototype.constructor = OrbitControls;\\n\\nObject.defineProperties( OrbitControls.prototype, {\\n\\n\\tcenter: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\\n\\t\\t\\treturn this.target;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// backward compatibility\\n\\n\\tnoZoom: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\\n\\t\\t\\treturn ! this.enableZoom;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\\n\\t\\t\\tthis.enableZoom = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoRotate: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\\n\\t\\t\\treturn ! this.enableRotate;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\\n\\t\\t\\tthis.enableRotate = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoPan: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\\n\\t\\t\\treturn ! this.enablePan;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\\n\\t\\t\\tthis.enablePan = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoKeys: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\\n\\t\\t\\treturn ! this.enableKeys;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\\n\\t\\t\\tthis.enableKeys = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tstaticMoving: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\\n\\t\\t\\treturn ! this.enableDamping;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\\n\\t\\t\\tthis.enableDamping = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tdynamicDampingFactor: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\\n\\t\\t\\treturn this.dampingFactor;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\\n\\t\\t\\tthis.dampingFactor = value;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n} );\\n\\nmodule.exports = OrbitControls\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aHJlZS1vcmJpdGNvbnRyb2xzL09yYml0Q29udHJvbHMuanM/YzE1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpXG5cbi8qKlxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgZXJpY2g2NjYgLyBodHRwOi8vZXJpY2hhaW5lcy5jb21cbiAqL1xuXG4vLyBUaGlzIHNldCBvZiBjb250cm9scyBwZXJmb3JtcyBvcmJpdGluZywgZG9sbHlpbmcgKHpvb21pbmcpLCBhbmQgcGFubmluZy5cbi8vIFVubGlrZSBUcmFja2JhbGxDb250cm9scywgaXQgbWFpbnRhaW5zIHRoZSBcInVwXCIgZGlyZWN0aW9uIG9iamVjdC51cCAoK1kgYnkgZGVmYXVsdCkuXG4vL1xuLy8gICAgT3JiaXQgLSBsZWZ0IG1vdXNlIC8gdG91Y2g6IG9uZSBmaW5nZXIgbW92ZVxuLy8gICAgWm9vbSAtIG1pZGRsZSBtb3VzZSwgb3IgbW91c2V3aGVlbCAvIHRvdWNoOiB0d28gZmluZ2VyIHNwcmVhZCBvciBzcXVpc2hcbi8vICAgIFBhbiAtIHJpZ2h0IG1vdXNlLCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IHRocmVlIGZpbmdlciBzd2lwZVxuXG5mdW5jdGlvbiBPcmJpdENvbnRyb2xzICggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XG5cblx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cblx0Ly8gXCJ0YXJnZXRcIiBzZXRzIHRoZSBsb2NhdGlvbiBvZiBmb2N1cywgd2hlcmUgdGhlIG9iamVjdCBvcmJpdHMgYXJvdW5kXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHQvLyBIb3cgZmFyIHlvdSBjYW4gZG9sbHkgaW4gYW5kIG91dCAoIFBlcnNwZWN0aXZlQ2FtZXJhIG9ubHkgKVxuXHR0aGlzLm1pbkRpc3RhbmNlID0gMDtcblx0dGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuXG5cdC8vIEhvdyBmYXIgeW91IGNhbiB6b29tIGluIGFuZCBvdXQgKCBPcnRob2dyYXBoaWNDYW1lcmEgb25seSApXG5cdHRoaXMubWluWm9vbSA9IDA7XG5cdHRoaXMubWF4Wm9vbSA9IEluZmluaXR5O1xuXG5cdC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCB2ZXJ0aWNhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuXHQvLyBSYW5nZSBpcyAwIHRvIE1hdGguUEkgcmFkaWFucy5cblx0dGhpcy5taW5Qb2xhckFuZ2xlID0gMDsgLy8gcmFkaWFuc1xuXHR0aGlzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJOyAvLyByYWRpYW5zXG5cblx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IGhvcml6b250YWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cblx0Ly8gSWYgc2V0LCBtdXN0IGJlIGEgc3ViLWludGVydmFsIG9mIHRoZSBpbnRlcnZhbCBbIC0gTWF0aC5QSSwgTWF0aC5QSSBdLlxuXHR0aGlzLm1pbkF6aW11dGhBbmdsZSA9IC0gSW5maW5pdHk7IC8vIHJhZGlhbnNcblx0dGhpcy5tYXhBemltdXRoQW5nbGUgPSBJbmZpbml0eTsgLy8gcmFkaWFuc1xuXG5cdC8vIFNldCB0byB0cnVlIHRvIGVuYWJsZSBkYW1waW5nIChpbmVydGlhKVxuXHQvLyBJZiBkYW1waW5nIGlzIGVuYWJsZWQsIHlvdSBtdXN0IGNhbGwgY29udHJvbHMudXBkYXRlKCkgaW4geW91ciBhbmltYXRpb24gbG9vcFxuXHR0aGlzLmVuYWJsZURhbXBpbmcgPSBmYWxzZTtcblx0dGhpcy5kYW1waW5nRmFjdG9yID0gMC4yNTtcblxuXHQvLyBUaGlzIG9wdGlvbiBhY3R1YWxseSBlbmFibGVzIGRvbGx5aW5nIGluIGFuZCBvdXQ7IGxlZnQgYXMgXCJ6b29tXCIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB6b29taW5nXG5cdHRoaXMuZW5hYmxlWm9vbSA9IHRydWU7XG5cdHRoaXMuem9vbVNwZWVkID0gMS4wO1xuXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHJvdGF0aW5nXG5cdHRoaXMuZW5hYmxlUm90YXRlID0gdHJ1ZTtcblx0dGhpcy5yb3RhdGVTcGVlZCA9IDEuMDtcblxuXHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBwYW5uaW5nXG5cdHRoaXMuZW5hYmxlUGFuID0gdHJ1ZTtcblx0dGhpcy5rZXlQYW5TcGVlZCA9IDcuMDtcdC8vIHBpeGVscyBtb3ZlZCBwZXIgYXJyb3cga2V5IHB1c2hcblxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IHJvdGF0ZSBhcm91bmQgdGhlIHRhcmdldFxuXHQvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3Bcblx0dGhpcy5hdXRvUm90YXRlID0gZmFsc2U7XG5cdHRoaXMuYXV0b1JvdGF0ZVNwZWVkID0gMi4wOyAvLyAzMCBzZWNvbmRzIHBlciByb3VuZCB3aGVuIGZwcyBpcyA2MFxuXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHVzZSBvZiB0aGUga2V5c1xuXHR0aGlzLmVuYWJsZUtleXMgPSB0cnVlO1xuXG5cdC8vIFRoZSBmb3VyIGFycm93IGtleXNcblx0dGhpcy5rZXlzID0geyBMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIEJPVFRPTTogNDAgfTtcblxuXHQvLyBNb3VzZSBidXR0b25zXG5cdHRoaXMubW91c2VCdXR0b25zID0geyBPUkJJVDogVEhSRUUuTU9VU0UuTEVGVCwgWk9PTTogVEhSRUUuTU9VU0UuTUlERExFLCBQQU46IFRIUkVFLk1PVVNFLlJJR0hUIH07XG5cblx0Ly8gZm9yIHJlc2V0XG5cdHRoaXMudGFyZ2V0MCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XG5cdHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcblx0dGhpcy56b29tMCA9IHRoaXMub2JqZWN0Lnpvb207XG5cblx0Ly9cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0Ly9cblxuXHR0aGlzLmdldFBvbGFyQW5nbGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJpY2FsLnBoaTtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0QXppbXV0aGFsQW5nbGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJpY2FsLnRoZXRhO1xuXG5cdH07XG5cblx0dGhpcy5zYXZlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRzY29wZS50YXJnZXQwLmNvcHkoIHNjb3BlLnRhcmdldCApO1xuXHRcdHNjb3BlLnBvc2l0aW9uMC5jb3B5KCBzY29wZS5vYmplY3QucG9zaXRpb24gKTtcblx0XHRzY29wZS56b29tMCA9IHNjb3BlLm9iamVjdC56b29tO1xuXG5cdH07XG5cblx0dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHNjb3BlLnRhcmdldC5jb3B5KCBzY29wZS50YXJnZXQwICk7XG5cdFx0c2NvcGUub2JqZWN0LnBvc2l0aW9uLmNvcHkoIHNjb3BlLnBvc2l0aW9uMCApO1xuXHRcdHNjb3BlLm9iamVjdC56b29tID0gc2NvcGUuem9vbTA7XG5cblx0XHRzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGNoYW5nZUV2ZW50ICk7XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHR9O1xuXG5cdC8vIHRoaXMgbWV0aG9kIGlzIGV4cG9zZWQsIGJ1dCBwZXJoYXBzIGl0IHdvdWxkIGJlIGJldHRlciBpZiB3ZSBjYW4gbWFrZSBpdCBwcml2YXRlLi4uXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHQvLyBzbyBjYW1lcmEudXAgaXMgdGhlIG9yYml0IGF4aXNcblx0XHR2YXIgcXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKCBvYmplY3QudXAsIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcblx0XHR2YXIgcXVhdEludmVyc2UgPSBxdWF0LmNsb25lKCkuaW52ZXJzZSgpO1xuXG5cdFx0dmFyIGxhc3RQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIGxhc3RRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHRcdHZhciBwb3NpdGlvbiA9IHNjb3BlLm9iamVjdC5wb3NpdGlvbjtcblxuXHRcdFx0b2Zmc2V0LmNvcHkoIHBvc2l0aW9uICkuc3ViKCBzY29wZS50YXJnZXQgKTtcblxuXHRcdFx0Ly8gcm90YXRlIG9mZnNldCB0byBcInktYXhpcy1pcy11cFwiIHNwYWNlXG5cdFx0XHRvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ICk7XG5cblx0XHRcdC8vIGFuZ2xlIGZyb20gei1heGlzIGFyb3VuZCB5LWF4aXNcblx0XHRcdHNwaGVyaWNhbC5zZXRGcm9tVmVjdG9yMyggb2Zmc2V0ICk7XG5cblx0XHRcdGlmICggc2NvcGUuYXV0b1JvdGF0ZSAmJiBzdGF0ZSA9PT0gU1RBVEUuTk9ORSApIHtcblxuXHRcdFx0XHRyb3RhdGVMZWZ0KCBnZXRBdXRvUm90YXRpb25BbmdsZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c3BoZXJpY2FsLnRoZXRhICs9IHNwaGVyaWNhbERlbHRhLnRoZXRhO1xuXHRcdFx0c3BoZXJpY2FsLnBoaSArPSBzcGhlcmljYWxEZWx0YS5waGk7XG5cblx0XHRcdC8vIHJlc3RyaWN0IHRoZXRhIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcblx0XHRcdHNwaGVyaWNhbC50aGV0YSA9IE1hdGgubWF4KCBzY29wZS5taW5BemltdXRoQW5nbGUsIE1hdGgubWluKCBzY29wZS5tYXhBemltdXRoQW5nbGUsIHNwaGVyaWNhbC50aGV0YSApICk7XG5cblx0XHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cdFx0XHRzcGhlcmljYWwucGhpID0gTWF0aC5tYXgoIHNjb3BlLm1pblBvbGFyQW5nbGUsIE1hdGgubWluKCBzY29wZS5tYXhQb2xhckFuZ2xlLCBzcGhlcmljYWwucGhpICkgKTtcblxuXHRcdFx0c3BoZXJpY2FsLm1ha2VTYWZlKCk7XG5cblxuXHRcdFx0c3BoZXJpY2FsLnJhZGl1cyAqPSBzY2FsZTtcblxuXHRcdFx0Ly8gcmVzdHJpY3QgcmFkaXVzIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcblx0XHRcdHNwaGVyaWNhbC5yYWRpdXMgPSBNYXRoLm1heCggc2NvcGUubWluRGlzdGFuY2UsIE1hdGgubWluKCBzY29wZS5tYXhEaXN0YW5jZSwgc3BoZXJpY2FsLnJhZGl1cyApICk7XG5cblx0XHRcdC8vIG1vdmUgdGFyZ2V0IHRvIHBhbm5lZCBsb2NhdGlvblxuXHRcdFx0c2NvcGUudGFyZ2V0LmFkZCggcGFuT2Zmc2V0ICk7XG5cblx0XHRcdG9mZnNldC5zZXRGcm9tU3BoZXJpY2FsKCBzcGhlcmljYWwgKTtcblxuXHRcdFx0Ly8gcm90YXRlIG9mZnNldCBiYWNrIHRvIFwiY2FtZXJhLXVwLXZlY3Rvci1pcy11cFwiIHNwYWNlXG5cdFx0XHRvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0SW52ZXJzZSApO1xuXG5cdFx0XHRwb3NpdGlvbi5jb3B5KCBzY29wZS50YXJnZXQgKS5hZGQoIG9mZnNldCApO1xuXG5cdFx0XHRzY29wZS5vYmplY3QubG9va0F0KCBzY29wZS50YXJnZXQgKTtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVEYW1waW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHNwaGVyaWNhbERlbHRhLnRoZXRhICo9ICggMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3IgKTtcblx0XHRcdFx0c3BoZXJpY2FsRGVsdGEucGhpICo9ICggMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3IgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzcGhlcmljYWxEZWx0YS5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzY2FsZSA9IDE7XG5cdFx0XHRwYW5PZmZzZXQuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdC8vIHVwZGF0ZSBjb25kaXRpb24gaXM6XG5cdFx0XHQvLyBtaW4oY2FtZXJhIGRpc3BsYWNlbWVudCwgY2FtZXJhIHJvdGF0aW9uIGluIHJhZGlhbnMpXjIgPiBFUFNcblx0XHRcdC8vIHVzaW5nIHNtYWxsLWFuZ2xlIGFwcHJveGltYXRpb24gY29zKHgvMikgPSAxIC0geF4yIC8gOFxuXG5cdFx0XHRpZiAoIHpvb21DaGFuZ2VkIHx8XG5cdFx0XHRcdGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggc2NvcGUub2JqZWN0LnBvc2l0aW9uICkgPiBFUFMgfHxcblx0XHRcdFx0OCAqICggMSAtIGxhc3RRdWF0ZXJuaW9uLmRvdCggc2NvcGUub2JqZWN0LnF1YXRlcm5pb24gKSApID4gRVBTICkge1xuXG5cdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGNoYW5nZUV2ZW50ICk7XG5cblx0XHRcdFx0bGFzdFBvc2l0aW9uLmNvcHkoIHNjb3BlLm9iamVjdC5wb3NpdGlvbiApO1xuXHRcdFx0XHRsYXN0UXVhdGVybmlvbi5jb3B5KCBzY29wZS5vYmplY3QucXVhdGVybmlvbiApO1xuXHRcdFx0XHR6b29tQ2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3aGVlbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UgKTtcblxuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlICk7XG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSApO1xuXG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSApO1xuXG5cdFx0Ly9zY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7IC8vIHNob3VsZCB0aGlzIGJlIGFkZGVkIGhlcmU/XG5cblx0fTtcblxuXHQvL1xuXHQvLyBpbnRlcm5hbHNcblx0Ly9cblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciBjaGFuZ2VFdmVudCA9IHsgdHlwZTogJ2NoYW5nZScgfTtcblx0dmFyIHN0YXJ0RXZlbnQgPSB7IHR5cGU6ICdzdGFydCcgfTtcblx0dmFyIGVuZEV2ZW50ID0geyB0eXBlOiAnZW5kJyB9O1xuXG5cdHZhciBTVEFURSA9IHsgTk9ORTogLSAxLCBST1RBVEU6IDAsIERPTExZOiAxLCBQQU46IDIsIFRPVUNIX1JPVEFURTogMywgVE9VQ0hfRE9MTFk6IDQsIFRPVUNIX1BBTjogNSB9O1xuXG5cdHZhciBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuXG5cdC8vIGN1cnJlbnQgcG9zaXRpb24gaW4gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG5cdHZhciBzcGhlcmljYWwgPSBuZXcgVEhSRUUuU3BoZXJpY2FsKCk7XG5cdHZhciBzcGhlcmljYWxEZWx0YSA9IG5ldyBUSFJFRS5TcGhlcmljYWwoKTtcblxuXHR2YXIgc2NhbGUgPSAxO1xuXHR2YXIgcGFuT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIHpvb21DaGFuZ2VkID0gZmFsc2U7XG5cblx0dmFyIHJvdGF0ZVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHJvdGF0ZUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciByb3RhdGVEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0dmFyIHBhblN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHBhbkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciBwYW5EZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0dmFyIGRvbGx5U3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgZG9sbHlFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgZG9sbHlEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0ZnVuY3Rpb24gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSB7XG5cblx0XHRyZXR1cm4gMiAqIE1hdGguUEkgLyA2MCAvIDYwICogc2NvcGUuYXV0b1JvdGF0ZVNwZWVkO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRab29tU2NhbGUoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5wb3coIDAuOTUsIHNjb3BlLnpvb21TcGVlZCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByb3RhdGVMZWZ0KCBhbmdsZSApIHtcblxuXHRcdHNwaGVyaWNhbERlbHRhLnRoZXRhIC09IGFuZ2xlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByb3RhdGVVcCggYW5nbGUgKSB7XG5cblx0XHRzcGhlcmljYWxEZWx0YS5waGkgLT0gYW5nbGU7XG5cblx0fVxuXG5cdHZhciBwYW5MZWZ0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHBhbkxlZnQoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XG5cblx0XHRcdHYuc2V0RnJvbU1hdHJpeENvbHVtbiggb2JqZWN0TWF0cml4LCAwICk7IC8vIGdldCBYIGNvbHVtbiBvZiBvYmplY3RNYXRyaXhcblx0XHRcdHYubXVsdGlwbHlTY2FsYXIoIC0gZGlzdGFuY2UgKTtcblxuXHRcdFx0cGFuT2Zmc2V0LmFkZCggdiApO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0dmFyIHBhblVwID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHBhblVwKCBkaXN0YW5jZSwgb2JqZWN0TWF0cml4ICkge1xuXG5cdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMSApOyAvLyBnZXQgWSBjb2x1bW4gb2Ygb2JqZWN0TWF0cml4XG5cdFx0XHR2Lm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApO1xuXG5cdFx0XHRwYW5PZmZzZXQuYWRkKCB2ICk7XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHQvLyBkZWx0YVggYW5kIGRlbHRhWSBhcmUgaW4gcGl4ZWxzOyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcblx0dmFyIHBhbiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBvZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHBhbiggZGVsdGFYLCBkZWx0YVkgKSB7XG5cblx0XHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0XHRpZiAoIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdC8vIHBlcnNwZWN0aXZlXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IHNjb3BlLm9iamVjdC5wb3NpdGlvbjtcblx0XHRcdFx0b2Zmc2V0LmNvcHkoIHBvc2l0aW9uICkuc3ViKCBzY29wZS50YXJnZXQgKTtcblx0XHRcdFx0dmFyIHRhcmdldERpc3RhbmNlID0gb2Zmc2V0Lmxlbmd0aCgpO1xuXG5cdFx0XHRcdC8vIGhhbGYgb2YgdGhlIGZvdiBpcyBjZW50ZXIgdG8gdG9wIG9mIHNjcmVlblxuXHRcdFx0XHR0YXJnZXREaXN0YW5jZSAqPSBNYXRoLnRhbiggKCBzY29wZS5vYmplY3QuZm92IC8gMiApICogTWF0aC5QSSAvIDE4MC4wICk7XG5cblx0XHRcdFx0Ly8gd2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHNjcmVlbldpZHRoLCBzaW5jZSBwZXJzcGVjdGl2ZSBjYW1lcmEgaXMgZml4ZWQgdG8gc2NyZWVuIGhlaWdodFxuXHRcdFx0XHRwYW5MZWZ0KCAyICogZGVsdGFYICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXHRcdFx0XHRwYW5VcCggMiAqIGRlbHRhWSAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblxuXHRcdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdC8vIG9ydGhvZ3JhcGhpY1xuXHRcdFx0XHRwYW5MZWZ0KCBkZWx0YVggKiAoIHNjb3BlLm9iamVjdC5yaWdodCAtIHNjb3BlLm9iamVjdC5sZWZ0ICkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50V2lkdGgsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblx0XHRcdFx0cGFuVXAoIGRlbHRhWSAqICggc2NvcGUub2JqZWN0LnRvcCAtIHNjb3BlLm9iamVjdC5ib3R0b20gKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBjYW1lcmEgbmVpdGhlciBvcnRob2dyYXBoaWMgbm9yIHBlcnNwZWN0aXZlXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHBhbiBkaXNhYmxlZC4nICk7XG5cdFx0XHRcdHNjb3BlLmVuYWJsZVBhbiA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHRmdW5jdGlvbiBkb2xseUluKCBkb2xseVNjYWxlICkge1xuXG5cdFx0aWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuXHRcdFx0c2NhbGUgLz0gZG9sbHlTY2FsZTtcblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heCggc2NvcGUubWluWm9vbSwgTWF0aC5taW4oIHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tICogZG9sbHlTY2FsZSApICk7XG5cdFx0XHRzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdFx0em9vbUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC4nICk7XG5cdFx0XHRzY29wZS5lbmFibGVab29tID0gZmFsc2U7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRvbGx5T3V0KCBkb2xseVNjYWxlICkge1xuXG5cdFx0aWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuXHRcdFx0c2NhbGUgKj0gZG9sbHlTY2FsZTtcblxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heCggc2NvcGUubWluWm9vbSwgTWF0aC5taW4oIHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tIC8gZG9sbHlTY2FsZSApICk7XG5cdFx0XHRzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdFx0em9vbUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC4nICk7XG5cdFx0XHRzY29wZS5lbmFibGVab29tID0gZmFsc2U7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vXG5cdC8vIGV2ZW50IGNhbGxiYWNrcyAtIHVwZGF0ZSB0aGUgb2JqZWN0IHN0YXRlXG5cdC8vXG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duUm90YXRlKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZURvd25Sb3RhdGUnICk7XG5cblx0XHRyb3RhdGVTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duRG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlRG93bkRvbGx5JyApO1xuXG5cdFx0ZG9sbHlTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duUGFuKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZURvd25QYW4nICk7XG5cblx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlUm90YXRlKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZU1vdmVSb3RhdGUnICk7XG5cblx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApO1xuXG5cdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cblx0XHQvLyByb3RhdGluZyBhY3Jvc3Mgd2hvbGUgc2NyZWVuIGdvZXMgMzYwIGRlZ3JlZXMgYXJvdW5kXG5cdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHQvLyByb3RhdGluZyB1cCBhbmQgZG93biBhbG9uZyB3aG9sZSBzY3JlZW4gYXR0ZW1wdHMgdG8gZ28gMzYwLCBidXQgbGltaXRlZCB0byAxODBcblx0XHRyb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlRG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlTW92ZURvbGx5JyApO1xuXG5cdFx0ZG9sbHlFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XG5cblx0XHRpZiAoIGRvbGx5RGVsdGEueSA+IDAgKSB7XG5cblx0XHRcdGRvbGx5SW4oIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHR9IGVsc2UgaWYgKCBkb2xseURlbHRhLnkgPCAwICkge1xuXG5cdFx0XHRkb2xseU91dCggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdH1cblxuXHRcdGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVQYW4oIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlTW92ZVBhbicgKTtcblxuXHRcdHBhbkVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcblxuXHRcdHBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG5cdFx0cGFuU3RhcnQuY29weSggcGFuRW5kICk7XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VVcCggZXZlbnQgKSB7XG5cblx0XHQvLyBjb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlVXAnICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICdoYW5kbGVNb3VzZVdoZWVsJyApO1xuXG5cdFx0aWYgKCBldmVudC5kZWx0YVkgPCAwICkge1xuXG5cdFx0XHRkb2xseU91dCggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGV2ZW50LmRlbHRhWSA+IDAgKSB7XG5cblx0XHRcdGRvbGx5SW4oIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHR9XG5cblx0XHRzY29wZS51cGRhdGUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlS2V5RG93biggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlS2V5RG93bicgKTtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5VUDpcblx0XHRcdFx0cGFuKCAwLCBzY29wZS5rZXlQYW5TcGVlZCApO1xuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5CT1RUT006XG5cdFx0XHRcdHBhbiggMCwgLSBzY29wZS5rZXlQYW5TcGVlZCApO1xuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5MRUZUOlxuXHRcdFx0XHRwYW4oIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLlJJR0hUOlxuXHRcdFx0XHRwYW4oIC0gc2NvcGUua2V5UGFuU3BlZWQsIDAgKTtcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaFN0YXJ0Um90YXRlJyApO1xuXG5cdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoU3RhcnREb2xseScgKTtcblxuXHRcdHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcblx0XHR2YXIgZHkgPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVk7XG5cblx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG5cblx0XHRkb2xseVN0YXJ0LnNldCggMCwgZGlzdGFuY2UgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydFBhbiggZXZlbnQgKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hTdGFydFBhbicgKTtcblxuXHRcdHBhblN0YXJ0LnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUm90YXRlKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaE1vdmVSb3RhdGUnICk7XG5cblx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXHRcdHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcblxuXHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0Ly8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuXHRcdHJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0Ly8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXG5cdFx0cm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQgKTtcblxuXHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaE1vdmVEb2xseScgKTtcblxuXHRcdHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcblx0XHR2YXIgZHkgPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVk7XG5cblx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG5cblx0XHRkb2xseUVuZC5zZXQoIDAsIGRpc3RhbmNlICk7XG5cblx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XG5cblx0XHRpZiAoIGRvbGx5RGVsdGEueSA+IDAgKSB7XG5cblx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0fSBlbHNlIGlmICggZG9sbHlEZWx0YS55IDwgMCApIHtcblxuXHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdH1cblxuXHRcdGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVQYW4oIGV2ZW50ICkge1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoTW92ZVBhbicgKTtcblxuXHRcdHBhbkVuZC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cblx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICk7XG5cblx0XHRwYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcblxuXHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKCBldmVudCApIHtcblxuXHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaEVuZCcgKTtcblxuXHR9XG5cblx0Ly9cblx0Ly8gZXZlbnQgaGFuZGxlcnMgLSBGU006IGxpc3RlbiBmb3IgZXZlbnRzIGFuZCByZXNldCBzdGF0ZVxuXHQvL1xuXG5cdGZ1bmN0aW9uIG9uTW91c2VEb3duKCBldmVudCApIHtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0c3dpdGNoICggZXZlbnQuYnV0dG9uICkge1xuXG5cdFx0XHRjYXNlIHNjb3BlLm1vdXNlQnV0dG9ucy5PUkJJVDpcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VEb3duUm90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIHNjb3BlLm1vdXNlQnV0dG9ucy5aT09NOlxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VEb3duRG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5ET0xMWTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBzY29wZS5tb3VzZUJ1dHRvbnMuUEFOOlxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5QQU47XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcblxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlTW92ZSggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdHN3aXRjaCAoIHN0YXRlICkge1xuXG5cdFx0XHRjYXNlIFNUQVRFLlJPVEFURTpcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlUm90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFNUQVRFLkRPTExZOlxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlRG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgU1RBVEUuUEFOOlxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVNb3VzZU1vdmVQYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uTW91c2VVcCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0aGFuZGxlTW91c2VVcCggZXZlbnQgKTtcblxuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcblxuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG5cblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlIHx8ICggc3RhdGUgIT09IFNUQVRFLk5PTkUgJiYgc3RhdGUgIT09IFNUQVRFLlJPVEFURSApICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdGhhbmRsZU1vdXNlV2hlZWwoIGV2ZW50ICk7XG5cblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7IC8vIG5vdCBzdXJlIHdoeSB0aGVzZSBhcmUgaGVyZS4uLlxuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uS2V5RG93biggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZUtleXMgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRoYW5kbGVLZXlEb3duKCBldmVudCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoICkge1xuXG5cdFx0XHRjYXNlIDE6XHQvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDI6XHQvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnRQYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHtcblxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBvblRvdWNoTW92ZSggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoICkge1xuXG5cdFx0XHRjYXNlIDE6IC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ST1RBVEUgKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxuXG5cdFx0XHRcdGhhbmRsZVRvdWNoTW92ZVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfRE9MTFkgKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxuXG5cdFx0XHRcdGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1BBTiApIHJldHVybjsgLy8gaXMgdGhpcyBuZWVkZWQ/Li4uXG5cblx0XHRcdFx0aGFuZGxlVG91Y2hNb3ZlUGFuKCBldmVudCApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gb25Ub3VjaEVuZCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0aGFuZGxlVG91Y2hFbmQoIGV2ZW50ICk7XG5cblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbkNvbnRleHRNZW51KCBldmVudCApIHtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0fVxuXG5cdC8vXG5cblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51LCBmYWxzZSApO1xuXG5cdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCBmYWxzZSApO1xuXHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd3aGVlbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UgKTtcblxuXHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBmYWxzZSApO1xuXHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlICk7XG5cdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSApO1xuXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UgKTtcblxuXHQvLyBmb3JjZSBhbiB1cGRhdGUgYXQgc3RhcnRcblxuXHR0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5PcmJpdENvbnRyb2xzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKTtcbk9yYml0Q29udHJvbHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JiaXRDb250cm9scztcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE9yYml0Q29udHJvbHMucHJvdG90eXBlLCB7XG5cblx0Y2VudGVyOiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLmNlbnRlciBoYXMgYmVlbiByZW5hbWVkIHRvIC50YXJnZXQnICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50YXJnZXQ7XG5cblx0XHR9XG5cblx0fSxcblxuXHQvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cblx0bm9ab29tOiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vWm9vbSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVpvb20gaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZVpvb207XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9ab29tIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlWm9vbSBpbnN0ZWFkLicgKTtcblx0XHRcdHRoaXMuZW5hYmxlWm9vbSA9ICEgdmFsdWU7XG5cblx0XHR9XG5cblx0fSxcblxuXHRub1JvdGF0ZToge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1JvdGF0ZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVJvdGF0ZSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiAhIHRoaXMuZW5hYmxlUm90YXRlO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vUm90YXRlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUm90YXRlIGluc3RlYWQuJyApO1xuXHRcdFx0dGhpcy5lbmFibGVSb3RhdGUgPSAhIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0bm9QYW46IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9QYW4gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVQYW4gaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZVBhbjtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1BhbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVBhbiBpbnN0ZWFkLicgKTtcblx0XHRcdHRoaXMuZW5hYmxlUGFuID0gISB2YWx1ZTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdG5vS2V5czoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub0tleXMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVLZXlzIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVLZXlzO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vS2V5cyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZUtleXMgaW5zdGVhZC4nICk7XG5cdFx0XHR0aGlzLmVuYWJsZUtleXMgPSAhIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0c3RhdGljTW92aW5nOiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLnN0YXRpY01vdmluZyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZURhbXBpbmcgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZURhbXBpbmc7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAuc3RhdGljTW92aW5nIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlRGFtcGluZyBpbnN0ZWFkLicgKTtcblx0XHRcdHRoaXMuZW5hYmxlRGFtcGluZyA9ICEgdmFsdWU7XG5cblx0XHR9XG5cblx0fSxcblxuXHRkeW5hbWljRGFtcGluZ0ZhY3Rvcjoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5keW5hbWljRGFtcGluZ0ZhY3RvciBoYXMgYmVlbiByZW5hbWVkLiBVc2UgLmRhbXBpbmdGYWN0b3IgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYW1waW5nRmFjdG9yO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLmR5bmFtaWNEYW1waW5nRmFjdG9yIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSAuZGFtcGluZ0ZhY3RvciBpbnN0ZWFkLicgKTtcblx0XHRcdHRoaXMuZGFtcGluZ0ZhY3RvciA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdH1cblxufSApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9yYml0Q29udHJvbHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RocmVlLW9yYml0Y29udHJvbHMvT3JiaXRDb250cm9scy5qc1xuLy8gbW9kdWxlIGlkID0gMTI1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1251\\n\")\n},1252:function(module,exports){eval('module.exports = \"<section class=\\\\\"padding-top-20\\\\\">\\\\n  <div id=\\\\\"honeythree\\\\\"></div>\\\\n  <div id=\\\\\"container\\\\\"><br><br><br><br><br>Generating World</div>\\\\n</section>\";//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC5odG1sP2NjYzUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjxzZWN0aW9uIGNsYXNzPVxcXCJwYWRkaW5nLXRvcC0yMFxcXCI+XFxuICA8ZGl2IGlkPVxcXCJob25leXRocmVlXFxcIj48L2Rpdj5cXG4gIDxkaXYgaWQ9XFxcImNvbnRhaW5lclxcXCI+PGJyPjxicj48YnI+PGJyPjxicj5HZW5lcmF0aW5nIFdvcmxkPC9kaXY+XFxuPC9zZWN0aW9uPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDEyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1252\\n')},1253:function(module,exports){eval('module.exports = \"body {\\\\n  color: #61443e;\\\\n  font-family: monospace;\\\\n  font-size: 13px;\\\\n  text-align: center;\\\\n  background-color: #fff;\\\\n  margin: auto;\\\\n  overflow: hidden; }\\\\n\\\\na {\\\\n  color: #a06851; }\\\\n\\\\n#info {\\\\n  position: absolute;\\\\n  top: 0;\\\\n  width: 100%;\\\\n  padding: 5px; }\\\\n\\\\n#oldie {\\\\n  background: #640000;\\\\n  color: #fff;\\\\n  margin-top: 10em; }\\\\n\\\\n#oldie a {\\\\n  color: #fff; }\\\\n\"//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC5zY3NzP2M3MWEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImJvZHkge1xcbiAgY29sb3I6ICM2MTQ0M2U7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIG1hcmdpbjogYXV0bztcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG5cXG5hIHtcXG4gIGNvbG9yOiAjYTA2ODUxOyB9XFxuXFxuI2luZm8ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBwYWRkaW5nOiA1cHg7IH1cXG5cXG4jb2xkaWUge1xcbiAgYmFja2dyb3VuZDogIzY0MDAwMDtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgbWFyZ2luLXRvcDogMTBlbTsgfVxcblxcbiNvbGRpZSBhIHtcXG4gIGNvbG9yOiAjZmZmOyB9XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1253\\n')},1254:function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar PIXI = __webpack_require__(312);\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar DatavComponent = (function () {\\r\\n    function DatavComponent() {\\r\\n        this.width = document.body.clientWidth - 120;\\r\\n        this.height = document.body.offsetHeight;\\r\\n        this.bgc = {\\r\\n            backgroundColor: 0x1099bb\\r\\n        };\\r\\n        // public initKnowledge(): void {\\r\\n        //   // SVG 图形大小\\r\\n        //   const width = document.body.clientWidth;\\r\\n        //   const height = document.body.clientHeight;\\r\\n        //   const svg = d3.select('#knowledge').append('svg')\\r\\n        //     .attr('width', width - 120)\\r\\n        //     .attr('height', height);\\r\\n        //   const g = svg.append('g')\\r\\n        //     .attr('transform', `translate(${width / 2}, ${height / 2})`);\\r\\n        //   const tree = d3.tree()\\r\\n        //     .size([360, 500])\\r\\n        //     .separation((a, b) => {\\r\\n        //       return (a.parent === b.parent ? 1 : 2) / a.depth;\\r\\n        //     });\\r\\n        //   const JsonData = {\\r\\n        //     name: '我的大前端',\\r\\n        //     children: [{\\r\\n        //       name: 'JavaScript',\\r\\n        //       children: [{\\r\\n        //         name: 'jQuery'\\r\\n        //       }, {\\r\\n        //         name: 'Angularjs'\\r\\n        //       }, {\\r\\n        //         name: 'Angular'\\r\\n        //       }]\\r\\n        //     }, {\\r\\n        //       name: 'HTML5',\\r\\n        //       children: [{\\r\\n        //           name: 'SVG'\\r\\n        //         },\\r\\n        //         {\\r\\n        //           name: 'Canvas'\\r\\n        //         }\\r\\n        //       ]\\r\\n        //     }, {\\r\\n        //       name: 'CSS3',\\r\\n        //       children: [{\\r\\n        //         name: 'Sass'\\r\\n        //       }, {\\r\\n        //         name: 'postCss'\\r\\n        //       }]\\r\\n        //     }]\\r\\n        //   };\\r\\n        //   // const stratify = d3.stratify()\\r\\n        //   //     .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(\\\".\\\")); });\\r\\n        //   const root = d3.hierarchy(JsonData);\\r\\n        //   // root.sum((d) => (d.value)).sort((a, b) => b.value - a.value);\\r\\n        //   tree(root);\\r\\n        //   function project(x: number, y: number) {\\r\\n        //     const angle = (x - 90) / 180 * Math.PI;\\r\\n        //     const radius = y;\\r\\n        //     return [radius * Math.cos(angle), radius * Math.sin(angle)];\\r\\n        //   }\\r\\n        //   // const link = g.selectAll('.link')\\r\\n        //   //   .data(root.descendants().slice(1))\\r\\n        //   //   .enter().append('path')\\r\\n        //   //   .attr('class', 'link')\\r\\n        //   //   .attr('d', (d) => {\\r\\n        //   //     return 'M' + project(d.x, d.y) +\\r\\n        //   //       'C' + project(d.x, (d.y + d.parent.y) / 2) +\\r\\n        //   //       ' ' + project(d.parent.x, (d.y + d.parent.y) / 2) +\\r\\n        //   //       ' ' + project(d.parent.x, d.parent.y);\\r\\n        //   //   });\\r\\n        //   const node = g.selectAll('.node')\\r\\n        //     .data(root.descendants())\\r\\n        //     .enter().append('g')\\r\\n        //     .attr('class', (d) => {\\r\\n        //       return 'node' + (d.children ? ' node--internal' : ' node--leaf');\\r\\n        //     })\\r\\n        //     .attr('transform', (d) => {\\r\\n        //       return 'translate(' + project(d.x, d.y) + ')';\\r\\n        //     });\\r\\n        //   node.append('circle')\\r\\n        //     .attr('r', 2.5);\\r\\n        //   node.append('text')\\r\\n        //     .attr('dy', '.31em')\\r\\n        //     .attr('x', (d) => {\\r\\n        //       return d.x < 180 === !d.children ? 6 : -6;\\r\\n        //     })\\r\\n        //     .style('text-anchor', (d) => {\\r\\n        //       return d.x < 180 === !d.children ? 'start' : 'end';\\r\\n        //     })\\r\\n        //     .attr('transform', (d) => {\\r\\n        //       return 'rotate(' + (d.x < 180 ? d.x - 90 : d.x + 90) + ')';\\r\\n        //     })\\r\\n        //     .text((d) => {\\r\\n        //       return d.data.name;\\r\\n        //     });\\r\\n        // }\\r\\n    }\\r\\n    DatavComponent.prototype.ngOnInit = function () {\\r\\n        // this.initKnowledge();\\r\\n        this.initPIXI();\\r\\n        this.initPIXITexture();\\r\\n    };\\r\\n    DatavComponent.prototype.initPIXI = function () {\\r\\n        var app = new PIXI.Application(this.width, this.height, this.bgc);\\r\\n        document.getElementById('knowledge').appendChild(app.view);\\r\\n        var style = new PIXI.TextStyle({\\r\\n            fontFamily: 'Arial',\\r\\n            fontSize: 36,\\r\\n            fontStyle: 'italic',\\r\\n            fontWeight: 'bold',\\r\\n            fill: ['#ffffff', '#00ff99'],\\r\\n            stroke: '#4a1850',\\r\\n            strokeThickness: 5,\\r\\n            dropShadow: true,\\r\\n            dropShadowColor: '#000000',\\r\\n            dropShadowBlur: 4,\\r\\n            dropShadowAngle: Math.PI / 6,\\r\\n            dropShadowDistance: 6,\\r\\n            wordWrap: true,\\r\\n            wordWrapWidth: 440\\r\\n        });\\r\\n        var richText = new PIXI.Text('开启H5英雄之路', style);\\r\\n        richText.x = 30;\\r\\n        richText.y = 50;\\r\\n        // Scale mode for all textures, will retain pixelation\\r\\n        PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;\\r\\n        var bg = PIXI.Sprite.fromImage('src/assets/images/usercenter/login_bg_1.jpg');\\r\\n        app.stage.addChild(bg);\\r\\n        var cells = PIXI.Sprite.fromImage('src/assets/images/magic/flowerup.jpg');\\r\\n        cells.scale.set(1);\\r\\n        var mask = PIXI.Sprite.fromImage('src/assets/images/magic/fly_person2.png');\\r\\n        mask.anchor.set(0.2);\\r\\n        mask.width = 100;\\r\\n        mask.height = 100;\\r\\n        mask.x = this.width / 2;\\r\\n        mask.y = this.height / 2;\\r\\n        cells.mask = mask;\\r\\n        app.stage.addChild(mask, cells);\\r\\n        var target = new PIXI.Point();\\r\\n        reset();\\r\\n        function reset() {\\r\\n            target.x = Math.floor(Math.random() * 600);\\r\\n            target.y = Math.floor(Math.random() * 600);\\r\\n        }\\r\\n        app.ticker.add(function () {\\r\\n            mask.x += (target.x - mask.x) * 0.1;\\r\\n            mask.y += (target.y - mask.y) * 0.1;\\r\\n            if (Math.abs(mask.x - target.x) < 1) {\\r\\n                reset();\\r\\n            }\\r\\n        });\\r\\n        app.stage.addChild(richText);\\r\\n    };\\r\\n    /**\\r\\n     * 初始化移动布局\\r\\n     * ...\\r\\n     * @memberof DatavComponent\\r\\n     */\\r\\n    DatavComponent.prototype.initPIXITexture = function () {\\r\\n        var app = new PIXI.Application(this.width, this.height, this.bgc);\\r\\n        document.getElementById('texture').appendChild(app.view);\\r\\n        var texture = PIXI.Texture.fromImage('src/assets/images/magic/fly_person2.png');\\r\\n        // Scale mode for pixelation\\r\\n        texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\\r\\n        for (var i = 0; i < 10; i++) {\\r\\n            createBunny(Math.floor(Math.random() * app.renderer.width), Math.floor(Math.random() * app.renderer.height));\\r\\n        }\\r\\n        function createBunny(x, y) {\\r\\n            // create our little bunny friend..\\r\\n            var bunny = new PIXI.Sprite(texture);\\r\\n            // enable the bunny to be interactive... this will allow it to respond to mouse and touch events\\r\\n            bunny.interactive = true;\\r\\n            // this button mode will mean the hand cursor appears when you roll over the bunny with your mouse\\r\\n            bunny.buttonMode = true;\\r\\n            // center the bunny's anchor point\\r\\n            bunny.anchor.set(0.5);\\r\\n            // make it a bit bigger, so it's easier to grab\\r\\n            bunny.scale.set(0.2);\\r\\n            // setup events for mouse + touch using\\r\\n            // the pointer events\\r\\n            bunny\\r\\n                .on('pointerdown', onDragStart)\\r\\n                .on('pointerup', onDragEnd)\\r\\n                .on('pointerupoutside', onDragEnd)\\r\\n                .on('pointermove', onDragMove);\\r\\n            // For mouse-only events\\r\\n            // .on('mousedown', onDragStart)\\r\\n            // .on('mouseup', onDragEnd)\\r\\n            // .on('mouseupoutside', onDragEnd)\\r\\n            // .on('mousemove', onDragMove);\\r\\n            // For touch-only events\\r\\n            // .on('touchstart', onDragStart)\\r\\n            // .on('touchend', onDragEnd)\\r\\n            // .on('touchendoutside', onDragEnd)\\r\\n            // .on('touchmove', onDragMove);\\r\\n            // move the sprite to its designated position\\r\\n            bunny.x = x;\\r\\n            bunny.y = y;\\r\\n            // add it to the stage\\r\\n            app.stage.addChild(bunny);\\r\\n        }\\r\\n        function onDragStart(event) {\\r\\n            // store a reference to the data\\r\\n            // the reason for this is because of multitouch\\r\\n            // we want to track the movement of this particular touch\\r\\n            this.data = event.data;\\r\\n            this.alpha = 0.5;\\r\\n            this.dragging = true;\\r\\n        }\\r\\n        function onDragEnd() {\\r\\n            this.alpha = 1;\\r\\n            this.dragging = false;\\r\\n            // set the interaction data to null\\r\\n            this.data = null;\\r\\n        }\\r\\n        function onDragMove() {\\r\\n            if (this.dragging) {\\r\\n                var newPosition = this.data.getLocalPosition(this.parent);\\r\\n                this.x = newPosition.x;\\r\\n                this.y = newPosition.y;\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n    DatavComponent = __decorate([\\r\\n        core_1.Component({\\r\\n            selector: 'datav',\\r\\n            template: __webpack_require__(1255),\\r\\n            styles: [__webpack_require__(1256)]\\r\\n        })\\r\\n    ], DatavComponent);\\r\\n    return DatavComponent;\\r\\n}());\\r\\nexports.DatavComponent = DatavComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZGF0YXYvZGF0YXYuY29tcG9uZW50LnRzPzc5ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0ICogYXMgUElYSSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdkYXRhdicsXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL2RhdGF2LmNvbXBvbmVudC5odG1sJyksXG4gIHN0eWxlczogW3JlcXVpcmUoJy4vZGF0YXYuY29tcG9uZW50LnNjc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBEYXRhdkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIHByaXZhdGUgd2lkdGggPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIC0gMTIwO1xuICBwcml2YXRlIGhlaWdodCA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuICBwcml2YXRlIGJnYyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IDB4MTA5OWJiXG4gIH07XG5cbiAgcHVibGljIG5nT25Jbml0KCkge1xuXG4gICAgLy8gdGhpcy5pbml0S25vd2xlZGdlKCk7XG5cbiAgICB0aGlzLmluaXRQSVhJKCk7XG4gICAgdGhpcy5pbml0UElYSVRleHR1cmUoKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0UElYSSgpOiB2b2lkIHtcblxuICAgIGNvbnN0IGFwcCA9IG5ldyBQSVhJLkFwcGxpY2F0aW9uKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmJnYyk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna25vd2xlZGdlJykuYXBwZW5kQ2hpbGQoYXBwLnZpZXcpO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBuZXcgUElYSS5UZXh0U3R5bGUoe1xuICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgIGZvbnRTaXplOiAzNixcbiAgICAgIGZvbnRTdHlsZTogJ2l0YWxpYycsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICBmaWxsOiBbJyNmZmZmZmYnLCAnIzAwZmY5OSddLCAvLyBncmFkaWVudFxuICAgICAgc3Ryb2tlOiAnIzRhMTg1MCcsXG4gICAgICBzdHJva2VUaGlja25lc3M6IDUsXG4gICAgICBkcm9wU2hhZG93OiB0cnVlLFxuICAgICAgZHJvcFNoYWRvd0NvbG9yOiAnIzAwMDAwMCcsXG4gICAgICBkcm9wU2hhZG93Qmx1cjogNCxcbiAgICAgIGRyb3BTaGFkb3dBbmdsZTogTWF0aC5QSSAvIDYsXG4gICAgICBkcm9wU2hhZG93RGlzdGFuY2U6IDYsXG4gICAgICB3b3JkV3JhcDogdHJ1ZSxcbiAgICAgIHdvcmRXcmFwV2lkdGg6IDQ0MFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmljaFRleHQgPSBuZXcgUElYSS5UZXh0KCflvIDlkK9INeiLsembhOS5i+i3rycsIHN0eWxlKTtcbiAgICByaWNoVGV4dC54ID0gMzA7XG4gICAgcmljaFRleHQueSA9IDUwO1xuXG4gICAgLy8gU2NhbGUgbW9kZSBmb3IgYWxsIHRleHR1cmVzLCB3aWxsIHJldGFpbiBwaXhlbGF0aW9uXG4gICAgUElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFID0gUElYSS5TQ0FMRV9NT0RFUy5ORUFSRVNUO1xuXG4gICAgY29uc3QgYmcgPSBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoJ3NyYy9hc3NldHMvaW1hZ2VzL3VzZXJjZW50ZXIvbG9naW5fYmdfMS5qcGcnKTtcbiAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQoYmcpO1xuXG4gICAgY29uc3QgY2VsbHMgPSBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoJ3NyYy9hc3NldHMvaW1hZ2VzL21hZ2ljL2Zsb3dlcnVwLmpwZycpO1xuICAgIGNlbGxzLnNjYWxlLnNldCgxKTtcblxuICAgIGNvbnN0IG1hc2sgPSBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoJ3NyYy9hc3NldHMvaW1hZ2VzL21hZ2ljL2ZseV9wZXJzb24yLnBuZycpO1xuICAgIG1hc2suYW5jaG9yLnNldCgwLjIpO1xuICAgIG1hc2sud2lkdGggPSAxMDA7XG4gICAgbWFzay5oZWlnaHQgPSAxMDA7XG4gICAgbWFzay54ID0gdGhpcy53aWR0aCAvIDI7XG4gICAgbWFzay55ID0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgY2VsbHMubWFzayA9IG1hc2s7XG4gICAgYXBwLnN0YWdlLmFkZENoaWxkKG1hc2ssIGNlbGxzKTtcblxuICAgIGNvbnN0IHRhcmdldCA9IG5ldyBQSVhJLlBvaW50KCk7XG5cbiAgICByZXNldCgpO1xuXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0YXJnZXQueCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDYwMCk7XG4gICAgICB0YXJnZXQueSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDYwMCk7XG4gICAgfVxuXG4gICAgYXBwLnRpY2tlci5hZGQoKCkgPT4ge1xuXG4gICAgICBtYXNrLnggKz0gKHRhcmdldC54IC0gbWFzay54KSAqIDAuMTtcbiAgICAgIG1hc2sueSArPSAodGFyZ2V0LnkgLSBtYXNrLnkpICogMC4xO1xuXG4gICAgICBpZiAoTWF0aC5hYnMobWFzay54IC0gdGFyZ2V0LngpIDwgMSkge1xuICAgICAgICByZXNldCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXBwLnN0YWdlLmFkZENoaWxkKHJpY2hUZXh0KTtcblxuXG4gIH1cblxuICAvKipcbiAgICog5Yid5aeL5YyW56e75Yqo5biD5bGAXG4gICAqIC4uLlxuICAgKiBAbWVtYmVyb2YgRGF0YXZDb21wb25lbnRcbiAgICovXG4gIHB1YmxpYyBpbml0UElYSVRleHR1cmUoKTogdm9pZCB7XG4gICAgY29uc3QgYXBwID0gbmV3IFBJWEkuQXBwbGljYXRpb24odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuYmdjKTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXh0dXJlJykuYXBwZW5kQ2hpbGQoYXBwLnZpZXcpO1xuXG4gICAgY29uc3QgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoJ3NyYy9hc3NldHMvaW1hZ2VzL21hZ2ljL2ZseV9wZXJzb24yLnBuZycpO1xuXG4gICAgLy8gU2NhbGUgbW9kZSBmb3IgcGl4ZWxhdGlvblxuICAgIHRleHR1cmUuYmFzZVRleHR1cmUuc2NhbGVNb2RlID0gUElYSS5TQ0FMRV9NT0RFUy5ORUFSRVNUO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICBjcmVhdGVCdW5ueShcbiAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXBwLnJlbmRlcmVyLndpZHRoKSxcbiAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXBwLnJlbmRlcmVyLmhlaWdodClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQnVubnkoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcblxuICAgICAgLy8gY3JlYXRlIG91ciBsaXR0bGUgYnVubnkgZnJpZW5kLi5cbiAgICAgIGNvbnN0IGJ1bm55ID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xuXG4gICAgICAvLyBlbmFibGUgdGhlIGJ1bm55IHRvIGJlIGludGVyYWN0aXZlLi4uIHRoaXMgd2lsbCBhbGxvdyBpdCB0byByZXNwb25kIHRvIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcbiAgICAgIGJ1bm55LmludGVyYWN0aXZlID0gdHJ1ZTtcblxuICAgICAgLy8gdGhpcyBidXR0b24gbW9kZSB3aWxsIG1lYW4gdGhlIGhhbmQgY3Vyc29yIGFwcGVhcnMgd2hlbiB5b3Ugcm9sbCBvdmVyIHRoZSBidW5ueSB3aXRoIHlvdXIgbW91c2VcbiAgICAgIGJ1bm55LmJ1dHRvbk1vZGUgPSB0cnVlO1xuXG4gICAgICAvLyBjZW50ZXIgdGhlIGJ1bm55J3MgYW5jaG9yIHBvaW50XG4gICAgICBidW5ueS5hbmNob3Iuc2V0KDAuNSk7XG5cbiAgICAgIC8vIG1ha2UgaXQgYSBiaXQgYmlnZ2VyLCBzbyBpdCdzIGVhc2llciB0byBncmFiXG4gICAgICBidW5ueS5zY2FsZS5zZXQoMC4yKTtcblxuICAgICAgLy8gc2V0dXAgZXZlbnRzIGZvciBtb3VzZSArIHRvdWNoIHVzaW5nXG4gICAgICAvLyB0aGUgcG9pbnRlciBldmVudHNcbiAgICAgIGJ1bm55XG4gICAgICAgIC5vbigncG9pbnRlcmRvd24nLCBvbkRyYWdTdGFydClcbiAgICAgICAgLm9uKCdwb2ludGVydXAnLCBvbkRyYWdFbmQpXG4gICAgICAgIC5vbigncG9pbnRlcnVwb3V0c2lkZScsIG9uRHJhZ0VuZClcbiAgICAgICAgLm9uKCdwb2ludGVybW92ZScsIG9uRHJhZ01vdmUpO1xuXG4gICAgICAvLyBGb3IgbW91c2Utb25seSBldmVudHNcbiAgICAgIC8vIC5vbignbW91c2Vkb3duJywgb25EcmFnU3RhcnQpXG4gICAgICAvLyAub24oJ21vdXNldXAnLCBvbkRyYWdFbmQpXG4gICAgICAvLyAub24oJ21vdXNldXBvdXRzaWRlJywgb25EcmFnRW5kKVxuICAgICAgLy8gLm9uKCdtb3VzZW1vdmUnLCBvbkRyYWdNb3ZlKTtcblxuICAgICAgLy8gRm9yIHRvdWNoLW9ubHkgZXZlbnRzXG4gICAgICAvLyAub24oJ3RvdWNoc3RhcnQnLCBvbkRyYWdTdGFydClcbiAgICAgIC8vIC5vbigndG91Y2hlbmQnLCBvbkRyYWdFbmQpXG4gICAgICAvLyAub24oJ3RvdWNoZW5kb3V0c2lkZScsIG9uRHJhZ0VuZClcbiAgICAgIC8vIC5vbigndG91Y2htb3ZlJywgb25EcmFnTW92ZSk7XG5cbiAgICAgIC8vIG1vdmUgdGhlIHNwcml0ZSB0byBpdHMgZGVzaWduYXRlZCBwb3NpdGlvblxuICAgICAgYnVubnkueCA9IHg7XG4gICAgICBidW5ueS55ID0geTtcblxuICAgICAgLy8gYWRkIGl0IHRvIHRoZSBzdGFnZVxuICAgICAgYXBwLnN0YWdlLmFkZENoaWxkKGJ1bm55KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdTdGFydChldmVudDogYW55KSB7XG4gICAgICAvLyBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgZGF0YVxuICAgICAgLy8gdGhlIHJlYXNvbiBmb3IgdGhpcyBpcyBiZWNhdXNlIG9mIG11bHRpdG91Y2hcbiAgICAgIC8vIHdlIHdhbnQgdG8gdHJhY2sgdGhlIG1vdmVtZW50IG9mIHRoaXMgcGFydGljdWxhciB0b3VjaFxuICAgICAgdGhpcy5kYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgIHRoaXMuYWxwaGEgPSAwLjU7XG4gICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdFbmQoKSB7XG4gICAgICB0aGlzLmFscGhhID0gMTtcbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIC8vIHNldCB0aGUgaW50ZXJhY3Rpb24gZGF0YSB0byBudWxsXG4gICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZ01vdmUoKSB7XG4gICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHRoaXMuZGF0YS5nZXRMb2NhbFBvc2l0aW9uKHRoaXMucGFyZW50KTtcbiAgICAgICAgdGhpcy54ID0gbmV3UG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy55ID0gbmV3UG9zaXRpb24ueTtcbiAgICAgIH1cbiAgICB9XG5cblxuICB9XG5cbiAgLy8gcHVibGljIGluaXRLbm93bGVkZ2UoKTogdm9pZCB7XG5cbiAgLy8gICAvLyBTVkcg5Zu+5b2i5aSn5bCPXG4gIC8vICAgY29uc3Qgd2lkdGggPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xuICAvLyAgIGNvbnN0IGhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O1xuXG4gIC8vICAgY29uc3Qgc3ZnID0gZDMuc2VsZWN0KCcja25vd2xlZGdlJykuYXBwZW5kKCdzdmcnKVxuICAvLyAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGggLSAxMjApXG4gIC8vICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcblxuICAvLyAgIGNvbnN0IGcgPSBzdmcuYXBwZW5kKCdnJylcbiAgLy8gICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7d2lkdGggLyAyfSwgJHtoZWlnaHQgLyAyfSlgKTtcblxuICAvLyAgIGNvbnN0IHRyZWUgPSBkMy50cmVlKClcbiAgLy8gICAgIC5zaXplKFszNjAsIDUwMF0pXG4gIC8vICAgICAuc2VwYXJhdGlvbigoYSwgYikgPT4ge1xuICAvLyAgICAgICByZXR1cm4gKGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyKSAvIGEuZGVwdGg7XG4gIC8vICAgICB9KTtcblxuICAvLyAgIGNvbnN0IEpzb25EYXRhID0ge1xuICAvLyAgICAgbmFtZTogJ+aIkeeahOWkp+WJjeerrycsXG4gIC8vICAgICBjaGlsZHJlbjogW3tcbiAgLy8gICAgICAgbmFtZTogJ0phdmFTY3JpcHQnLFxuICAvLyAgICAgICBjaGlsZHJlbjogW3tcbiAgLy8gICAgICAgICBuYW1lOiAnalF1ZXJ5J1xuICAvLyAgICAgICB9LCB7XG4gIC8vICAgICAgICAgbmFtZTogJ0FuZ3VsYXJqcydcbiAgLy8gICAgICAgfSwge1xuICAvLyAgICAgICAgIG5hbWU6ICdBbmd1bGFyJ1xuICAvLyAgICAgICB9XVxuICAvLyAgICAgfSwge1xuICAvLyAgICAgICBuYW1lOiAnSFRNTDUnLFxuICAvLyAgICAgICBjaGlsZHJlbjogW3tcbiAgLy8gICAgICAgICAgIG5hbWU6ICdTVkcnXG4gIC8vICAgICAgICAgfSxcbiAgLy8gICAgICAgICB7XG4gIC8vICAgICAgICAgICBuYW1lOiAnQ2FudmFzJ1xuICAvLyAgICAgICAgIH1cbiAgLy8gICAgICAgXVxuICAvLyAgICAgfSwge1xuICAvLyAgICAgICBuYW1lOiAnQ1NTMycsXG4gIC8vICAgICAgIGNoaWxkcmVuOiBbe1xuICAvLyAgICAgICAgIG5hbWU6ICdTYXNzJ1xuICAvLyAgICAgICB9LCB7XG4gIC8vICAgICAgICAgbmFtZTogJ3Bvc3RDc3MnXG4gIC8vICAgICAgIH1dXG4gIC8vICAgICB9XVxuICAvLyAgIH07XG5cbiAgLy8gICAvLyBjb25zdCBzdHJhdGlmeSA9IGQzLnN0cmF0aWZ5KClcbiAgLy8gICAvLyAgICAgLnBhcmVudElkKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaWQuc3Vic3RyaW5nKDAsIGQuaWQubGFzdEluZGV4T2YoXCIuXCIpKTsgfSk7XG5cbiAgLy8gICBjb25zdCByb290ID0gZDMuaGllcmFyY2h5KEpzb25EYXRhKTtcbiAgLy8gICAvLyByb290LnN1bSgoZCkgPT4gKGQudmFsdWUpKS5zb3J0KChhLCBiKSA9PiBiLnZhbHVlIC0gYS52YWx1ZSk7XG4gIC8vICAgdHJlZShyb290KTtcblxuICAvLyAgIGZ1bmN0aW9uIHByb2plY3QoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcbiAgLy8gICAgIGNvbnN0IGFuZ2xlID0gKHggLSA5MCkgLyAxODAgKiBNYXRoLlBJO1xuICAvLyAgICAgY29uc3QgcmFkaXVzID0geTtcbiAgLy8gICAgIHJldHVybiBbcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLCByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSldO1xuICAvLyAgIH1cblxuICAvLyAgIC8vIGNvbnN0IGxpbmsgPSBnLnNlbGVjdEFsbCgnLmxpbmsnKVxuICAvLyAgIC8vICAgLmRhdGEocm9vdC5kZXNjZW5kYW50cygpLnNsaWNlKDEpKVxuICAvLyAgIC8vICAgLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcbiAgLy8gICAvLyAgIC5hdHRyKCdjbGFzcycsICdsaW5rJylcbiAgLy8gICAvLyAgIC5hdHRyKCdkJywgKGQpID0+IHtcbiAgLy8gICAvLyAgICAgcmV0dXJuICdNJyArIHByb2plY3QoZC54LCBkLnkpICtcbiAgLy8gICAvLyAgICAgICAnQycgKyBwcm9qZWN0KGQueCwgKGQueSArIGQucGFyZW50LnkpIC8gMikgK1xuICAvLyAgIC8vICAgICAgICcgJyArIHByb2plY3QoZC5wYXJlbnQueCwgKGQueSArIGQucGFyZW50LnkpIC8gMikgK1xuICAvLyAgIC8vICAgICAgICcgJyArIHByb2plY3QoZC5wYXJlbnQueCwgZC5wYXJlbnQueSk7XG4gIC8vICAgLy8gICB9KTtcblxuXG4gIC8vICAgY29uc3Qgbm9kZSA9IGcuc2VsZWN0QWxsKCcubm9kZScpXG4gIC8vICAgICAuZGF0YShyb290LmRlc2NlbmRhbnRzKCkpXG4gIC8vICAgICAuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAvLyAgICAgLmF0dHIoJ2NsYXNzJywgKGQpID0+IHtcbiAgLy8gICAgICAgcmV0dXJuICdub2RlJyArIChkLmNoaWxkcmVuID8gJyBub2RlLS1pbnRlcm5hbCcgOiAnIG5vZGUtLWxlYWYnKTtcbiAgLy8gICAgIH0pXG4gIC8vICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQpID0+IHtcbiAgLy8gICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHByb2plY3QoZC54LCBkLnkpICsgJyknO1xuICAvLyAgICAgfSk7XG5cbiAgLy8gICBub2RlLmFwcGVuZCgnY2lyY2xlJylcbiAgLy8gICAgIC5hdHRyKCdyJywgMi41KTtcblxuICAvLyAgIG5vZGUuYXBwZW5kKCd0ZXh0JylcbiAgLy8gICAgIC5hdHRyKCdkeScsICcuMzFlbScpXG4gIC8vICAgICAuYXR0cigneCcsIChkKSA9PiB7XG4gIC8vICAgICAgIHJldHVybiBkLnggPCAxODAgPT09ICFkLmNoaWxkcmVuID8gNiA6IC02O1xuICAvLyAgICAgfSlcbiAgLy8gICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAoZCkgPT4ge1xuICAvLyAgICAgICByZXR1cm4gZC54IDwgMTgwID09PSAhZC5jaGlsZHJlbiA/ICdzdGFydCcgOiAnZW5kJztcbiAgLy8gICAgIH0pXG4gIC8vICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQpID0+IHtcbiAgLy8gICAgICAgcmV0dXJuICdyb3RhdGUoJyArIChkLnggPCAxODAgPyBkLnggLSA5MCA6IGQueCArIDkwKSArICcpJztcbiAgLy8gICAgIH0pXG4gIC8vICAgICAudGV4dCgoZCkgPT4ge1xuICAvLyAgICAgICByZXR1cm4gZC5kYXRhLm5hbWU7XG4gIC8vICAgICB9KTtcbiAgLy8gfVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyPz9yZWYtLTAtMCEuL3NyYy9hcHAvZGF0YXYvZGF0YXYuY29tcG9uZW50LnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBO0FBQ0E7QUFXQTtBQU5BO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQThLQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFuUkE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBakxBO0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBMFJBO0FBQUE7QUExUkE7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1254\\n\")},1255:function(module,exports){eval('module.exports = \"\\x3c!--数据可视化展示--\\x3e\\\\n<section class=\\\\\"container\\\\\">\\\\n  <div class=\\\\\"padding-16\\\\\" fxLayout=\\\\\"column\\\\\">\\\\n    <md-card fxFlex=\\\\\"100%\\\\\"  fxLayoutAlign=\\\\\"center center\\\\\">\\\\n      <div id=\\\\\"knowledge\\\\\" class=\\\\\"\\\\\"></div>\\\\n    </md-card>\\\\n    \\\\n    <md-card class=\\\\\"margin-top-24\\\\\" fxFlex=\\\\\"100%\\\\\" fxLayoutAlign=\\\\\"center center\\\\\">\\\\n      <div id=\\\\\"texture\\\\\"></div>\\\\n    </md-card>\\\\n  </div>\\\\n</section>\";//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZGF0YXYvZGF0YXYuY29tcG9uZW50Lmh0bWw/ZjQyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPCEtLeaVsOaNruWPr+inhuWMluWxleekui0tPlxcbjxzZWN0aW9uIGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicGFkZGluZy0xNlxcXCIgZnhMYXlvdXQ9XFxcImNvbHVtblxcXCI+XFxuICAgIDxtZC1jYXJkIGZ4RmxleD1cXFwiMTAwJVxcXCIgIGZ4TGF5b3V0QWxpZ249XFxcImNlbnRlciBjZW50ZXJcXFwiPlxcbiAgICAgIDxkaXYgaWQ9XFxcImtub3dsZWRnZVxcXCIgY2xhc3M9XFxcIlxcXCI+PC9kaXY+XFxuICAgIDwvbWQtY2FyZD5cXG4gICAgXFxuICAgIDxtZC1jYXJkIGNsYXNzPVxcXCJtYXJnaW4tdG9wLTI0XFxcIiBmeEZsZXg9XFxcIjEwMCVcXFwiIGZ4TGF5b3V0QWxpZ249XFxcImNlbnRlciBjZW50ZXJcXFwiPlxcbiAgICAgIDxkaXYgaWQ9XFxcInRleHR1cmVcXFwiPjwvZGl2PlxcbiAgICA8L21kLWNhcmQ+XFxuICA8L2Rpdj5cXG48L3NlY3Rpb24+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2RhdGF2L2RhdGF2LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMjU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1255\\n')},1256:function(module,exports){eval('module.exports = \".node circle {\\\\n  fill: #999; }\\\\n\\\\n.node text {\\\\n  font: 10px sans-serif; }\\\\n\\\\n.node--internal circle {\\\\n  fill: #555; }\\\\n\\\\n.node--internal text {\\\\n  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff; }\\\\n\\\\n.link {\\\\n  fill: none;\\\\n  stroke: #555;\\\\n  stroke-opacity: 0.4;\\\\n  stroke-width: 1.5px; }\\\\n\"//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZGF0YXYvZGF0YXYuY29tcG9uZW50LnNjc3M/N2ZlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLm5vZGUgY2lyY2xlIHtcXG4gIGZpbGw6ICM5OTk7IH1cXG5cXG4ubm9kZSB0ZXh0IHtcXG4gIGZvbnQ6IDEwcHggc2Fucy1zZXJpZjsgfVxcblxcbi5ub2RlLS1pbnRlcm5hbCBjaXJjbGUge1xcbiAgZmlsbDogIzU1NTsgfVxcblxcbi5ub2RlLS1pbnRlcm5hbCB0ZXh0IHtcXG4gIHRleHQtc2hhZG93OiAwIDFweCAwICNmZmYsIDAgLTFweCAwICNmZmYsIDFweCAwIDAgI2ZmZiwgLTFweCAwIDAgI2ZmZjsgfVxcblxcbi5saW5rIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICM1NTU7XFxuICBzdHJva2Utb3BhY2l0eTogMC40O1xcbiAgc3Ryb2tlLXdpZHRoOiAxLjVweDsgfVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2RhdGF2L2RhdGF2LmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1256\\n')},1257:function(module,exports,__webpack_require__){\"use strict\"\n;eval('\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\n__webpack_require__(1258);\\r\\nvar jQuery = __webpack_require__(1259);\\r\\nvar hljs = __webpack_require__(476);\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar BlogListComponent = (function () {\\r\\n    function BlogListComponent() {\\r\\n        this.cardhtml = \"\\\\n<div class=\\\\\"containerX\\\\\">\\\\n  <div class=\\\\\"container\\\\\">\\\\n    <div fxFlex fxLayout=\\\\\"space-around stretch\\\\\">\\\\n        <md-card class=\\\\\"box-shadow-dark-3\\\\\" fxFlex=\\\\\"32%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxLayout=\\\\\"column\\\\\">\\\\n          <md-card-header>\\\\n            <md-card-title>Card\\\\u5E03\\\\u5C40</md-card-title>\\\\n          </md-card-header>\\\\n\\\\n          <md-card-content>\\\\n            content\\\\n          </md-card-content>\\\\n        </md-card>\\\\n    </div>\\\\n  </div>\\\\n</div>\";\\r\\n        this.cssGradienst = \"\\\\n $color1: rgba(142, 246, 228, .9);\\\\n $color2: rgba(51, 204, 204, .9);\\\\n\\\\n .css-gradient {\\\\n   background: linear-gradient(to bottom left, $color1, $color2);\\\\n }\";\\r\\n    }\\r\\n    BlogListComponent.prototype.ngOnInit = function () {\\r\\n        // hljs.initHighlightingOnLoad();\\r\\n        jQuery(document).ready(function () {\\r\\n            jQuery(\\'pre code\\').each(function (i, block) {\\r\\n                hljs.highlightBlock(block);\\r\\n            });\\r\\n        });\\r\\n        // this.initBlogList();\\r\\n    };\\r\\n    BlogListComponent.prototype.initBlogList = function () {\\r\\n        console.warn(\\'blog list\\');\\r\\n    };\\r\\n    BlogListComponent = __decorate([\\r\\n        core_1.Component({\\r\\n            selector: \\'blog-list\\',\\r\\n            template: __webpack_require__(1260),\\r\\n            styles: [__webpack_require__(1261)]\\r\\n        })\\r\\n    ], BlogListComponent);\\r\\n    return BlogListComponent;\\r\\n}());\\r\\nexports.BlogListComponent = BlogListComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYmxvZy1saXN0L2Jsb2ctbGlzdC5jb21wb25lbnQudHM/NWVmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ2hpZ2hsaWdodC5qcy9zdHlsZXMvYXRvbS1vbmUtZGFyay5jc3MnO1xuaW1wb3J0ICogYXMgalF1ZXJ5IGZyb20gJ2pxdWVyeSc7XG5cbmltcG9ydCAqIGFzIGhsanMgZnJvbSAnaGlnaGxpZ2h0LmpzJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdibG9nLWxpc3QnLFxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9ibG9nLWxpc3QuY29tcG9uZW50Lmh0bWwnKSxcbiAgc3R5bGVzOiBbcmVxdWlyZSgnLi9ibG9nLWxpc3QuY29tcG9uZW50LnNjc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBCbG9nTGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIHB1YmxpYyBjYXJkaHRtbDogc3RyaW5nID0gYFxuPGRpdiBjbGFzcz1cImNvbnRhaW5lclhcIj5cbiAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgIDxkaXYgZnhGbGV4IGZ4TGF5b3V0PVwic3BhY2UtYXJvdW5kIHN0cmV0Y2hcIj5cbiAgICAgICAgPG1kLWNhcmQgY2xhc3M9XCJib3gtc2hhZG93LWRhcmstM1wiIGZ4RmxleD1cIjMyJVwiIGZ4RmxleC5sdC1zbT1cIjEwMCVcIiBmeExheW91dD1cImNvbHVtblwiPlxuICAgICAgICAgIDxtZC1jYXJkLWhlYWRlcj5cbiAgICAgICAgICAgIDxtZC1jYXJkLXRpdGxlPkNhcmTluIPlsYA8L21kLWNhcmQtdGl0bGU+XG4gICAgICAgICAgPC9tZC1jYXJkLWhlYWRlcj5cblxuICAgICAgICAgIDxtZC1jYXJkLWNvbnRlbnQ+XG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgPC9tZC1jYXJkLWNvbnRlbnQ+XG4gICAgICAgIDwvbWQtY2FyZD5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5gO1xuXG5cbiAgcHVibGljIGNzc0dyYWRpZW5zdDogc3RyaW5nID0gYFxuICRjb2xvcjE6IHJnYmEoMTQyLCAyNDYsIDIyOCwgLjkpO1xuICRjb2xvcjI6IHJnYmEoNTEsIDIwNCwgMjA0LCAuOSk7XG5cbiAuY3NzLWdyYWRpZW50IHtcbiAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20gbGVmdCwgJGNvbG9yMSwgJGNvbG9yMik7XG4gfWA7XG5cblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG5cbiAgICAvLyBobGpzLmluaXRIaWdobGlnaHRpbmdPbkxvYWQoKTtcblxuICAgIGpRdWVyeShkb2N1bWVudCkucmVhZHkoKCkgPT4ge1xuICAgICAgalF1ZXJ5KCdwcmUgY29kZScpLmVhY2goKGksIGJsb2NrKSA9PiB7XG4gICAgICAgIGhsanMuaGlnaGxpZ2h0QmxvY2soYmxvY2spO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyB0aGlzLmluaXRCbG9nTGlzdCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0QmxvZ0xpc3QoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oJ2Jsb2cgbGlzdCcpO1xuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9ibG9nLWxpc3QvYmxvZy1saXN0LmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQVdBO0FBTkE7QUFPQTtBQWtCQTtBQTJCQTtBQWxCQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUE1Q0E7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUE4Q0E7QUFBQTtBQTlDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1257\\n')},1258:function(module,exports){eval(\"// removed by extract-text-webpack-plugin//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvc3R5bGVzL2F0b20tb25lLWRhcmsuY3NzP2M2NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvc3R5bGVzL2F0b20tb25lLWRhcmsuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMjU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1258\\n\")},1259:function(module,exports,__webpack_require__){\neval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n * jQuery JavaScript Library v3.2.1\\n * https://jquery.com/\\n *\\n * Includes Sizzle.js\\n * https://sizzlejs.com/\\n *\\n * Copyright JS Foundation and other contributors\\n * Released under the MIT license\\n * https://jquery.org/license\\n *\\n * Date: 2017-03-20T18:59Z\\n */\\n( function( global, factory ) {\\n\\n\\t\"use strict\";\\n\\n\\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\\n\\n\\t\\t// For CommonJS and CommonJS-like environments where a proper `window`\\n\\t\\t// is present, execute the factory and get jQuery.\\n\\t\\t// For environments that do not have a `window` with a `document`\\n\\t\\t// (such as Node.js), expose a factory as module.exports.\\n\\t\\t// This accentuates the need for the creation of a real `window`.\\n\\t\\t// e.g. var jQuery = require(\"jquery\")(window);\\n\\t\\t// See ticket #14549 for more info.\\n\\t\\tmodule.exports = global.document ?\\n\\t\\t\\tfactory( global, true ) :\\n\\t\\t\\tfunction( w ) {\\n\\t\\t\\t\\tif ( !w.document ) {\\n\\t\\t\\t\\t\\tthrow new Error( \"jQuery requires a window with a document\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn factory( w );\\n\\t\\t\\t};\\n\\t} else {\\n\\t\\tfactory( global );\\n\\t}\\n\\n// Pass this if window is not defined yet\\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\\n\\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\\n// enough that all such attempts are guarded in a try block.\\n\"use strict\";\\n\\nvar arr = [];\\n\\nvar document = window.document;\\n\\nvar getProto = Object.getPrototypeOf;\\n\\nvar slice = arr.slice;\\n\\nvar concat = arr.concat;\\n\\nvar push = arr.push;\\n\\nvar indexOf = arr.indexOf;\\n\\nvar class2type = {};\\n\\nvar toString = class2type.toString;\\n\\nvar hasOwn = class2type.hasOwnProperty;\\n\\nvar fnToString = hasOwn.toString;\\n\\nvar ObjectFunctionString = fnToString.call( Object );\\n\\nvar support = {};\\n\\n\\n\\n\\tfunction DOMEval( code, doc ) {\\n\\t\\tdoc = doc || document;\\n\\n\\t\\tvar script = doc.createElement( \"script\" );\\n\\n\\t\\tscript.text = code;\\n\\t\\tdoc.head.appendChild( script ).parentNode.removeChild( script );\\n\\t}\\n/* global Symbol */\\n// Defining this global in .eslintrc.json would create a danger of using the global\\n// unguarded in another place, it seems safer to define global only for this module\\n\\n\\n\\nvar\\n\\tversion = \"3.2.1\",\\n\\n\\t// Define a local copy of jQuery\\n\\tjQuery = function( selector, context ) {\\n\\n\\t\\t// The jQuery object is actually just the init constructor \\'enhanced\\'\\n\\t\\t// Need init if jQuery is called (just allow error to be thrown if not included)\\n\\t\\treturn new jQuery.fn.init( selector, context );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\t// Make sure we trim BOM and NBSP\\n\\trtrim = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g,\\n\\n\\t// Matches dashed string for camelizing\\n\\trmsPrefix = /^-ms-/,\\n\\trdashAlpha = /-([a-z])/g,\\n\\n\\t// Used by jQuery.camelCase as callback to replace()\\n\\tfcamelCase = function( all, letter ) {\\n\\t\\treturn letter.toUpperCase();\\n\\t};\\n\\njQuery.fn = jQuery.prototype = {\\n\\n\\t// The current version of jQuery being used\\n\\tjquery: version,\\n\\n\\tconstructor: jQuery,\\n\\n\\t// The default length of a jQuery object is 0\\n\\tlength: 0,\\n\\n\\ttoArray: function() {\\n\\t\\treturn slice.call( this );\\n\\t},\\n\\n\\t// Get the Nth element in the matched element set OR\\n\\t// Get the whole matched element set as a clean array\\n\\tget: function( num ) {\\n\\n\\t\\t// Return all the elements in a clean array\\n\\t\\tif ( num == null ) {\\n\\t\\t\\treturn slice.call( this );\\n\\t\\t}\\n\\n\\t\\t// Return just the one element from the set\\n\\t\\treturn num < 0 ? this[ num + this.length ] : this[ num ];\\n\\t},\\n\\n\\t// Take an array of elements and push it onto the stack\\n\\t// (returning the new matched element set)\\n\\tpushStack: function( elems ) {\\n\\n\\t\\t// Build a new jQuery matched element set\\n\\t\\tvar ret = jQuery.merge( this.constructor(), elems );\\n\\n\\t\\t// Add the old object onto the stack (as a reference)\\n\\t\\tret.prevObject = this;\\n\\n\\t\\t// Return the newly-formed element set\\n\\t\\treturn ret;\\n\\t},\\n\\n\\t// Execute a callback for every element in the matched set.\\n\\teach: function( callback ) {\\n\\t\\treturn jQuery.each( this, callback );\\n\\t},\\n\\n\\tmap: function( callback ) {\\n\\t\\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\\n\\t\\t\\treturn callback.call( elem, i, elem );\\n\\t\\t} ) );\\n\\t},\\n\\n\\tslice: function() {\\n\\t\\treturn this.pushStack( slice.apply( this, arguments ) );\\n\\t},\\n\\n\\tfirst: function() {\\n\\t\\treturn this.eq( 0 );\\n\\t},\\n\\n\\tlast: function() {\\n\\t\\treturn this.eq( -1 );\\n\\t},\\n\\n\\teq: function( i ) {\\n\\t\\tvar len = this.length,\\n\\t\\t\\tj = +i + ( i < 0 ? len : 0 );\\n\\t\\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\\n\\t},\\n\\n\\tend: function() {\\n\\t\\treturn this.prevObject || this.constructor();\\n\\t},\\n\\n\\t// For internal use only.\\n\\t// Behaves like an Array\\'s method, not like a jQuery method.\\n\\tpush: push,\\n\\tsort: arr.sort,\\n\\tsplice: arr.splice\\n};\\n\\njQuery.extend = jQuery.fn.extend = function() {\\n\\tvar options, name, src, copy, copyIsArray, clone,\\n\\t\\ttarget = arguments[ 0 ] || {},\\n\\t\\ti = 1,\\n\\t\\tlength = arguments.length,\\n\\t\\tdeep = false;\\n\\n\\t// Handle a deep copy situation\\n\\tif ( typeof target === \"boolean\" ) {\\n\\t\\tdeep = target;\\n\\n\\t\\t// Skip the boolean and the target\\n\\t\\ttarget = arguments[ i ] || {};\\n\\t\\ti++;\\n\\t}\\n\\n\\t// Handle case when target is a string or something (possible in deep copy)\\n\\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\\n\\t\\ttarget = {};\\n\\t}\\n\\n\\t// Extend jQuery itself if only one argument is passed\\n\\tif ( i === length ) {\\n\\t\\ttarget = this;\\n\\t\\ti--;\\n\\t}\\n\\n\\tfor ( ; i < length; i++ ) {\\n\\n\\t\\t// Only deal with non-null/undefined values\\n\\t\\tif ( ( options = arguments[ i ] ) != null ) {\\n\\n\\t\\t\\t// Extend the base object\\n\\t\\t\\tfor ( name in options ) {\\n\\t\\t\\t\\tsrc = target[ name ];\\n\\t\\t\\t\\tcopy = options[ name ];\\n\\n\\t\\t\\t\\t// Prevent never-ending loop\\n\\t\\t\\t\\tif ( target === copy ) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Recurse if we\\'re merging plain objects or arrays\\n\\t\\t\\t\\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\\n\\t\\t\\t\\t\\t( copyIsArray = Array.isArray( copy ) ) ) ) {\\n\\n\\t\\t\\t\\t\\tif ( copyIsArray ) {\\n\\t\\t\\t\\t\\t\\tcopyIsArray = false;\\n\\t\\t\\t\\t\\t\\tclone = src && Array.isArray( src ) ? src : [];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tclone = src && jQuery.isPlainObject( src ) ? src : {};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Never move original objects, clone them\\n\\t\\t\\t\\t\\ttarget[ name ] = jQuery.extend( deep, clone, copy );\\n\\n\\t\\t\\t\\t// Don\\'t bring in undefined values\\n\\t\\t\\t\\t} else if ( copy !== undefined ) {\\n\\t\\t\\t\\t\\ttarget[ name ] = copy;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the modified object\\n\\treturn target;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Unique for each copy of jQuery on the page\\n\\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\\\D/g, \"\" ),\\n\\n\\t// Assume jQuery is ready without the ready module\\n\\tisReady: true,\\n\\n\\terror: function( msg ) {\\n\\t\\tthrow new Error( msg );\\n\\t},\\n\\n\\tnoop: function() {},\\n\\n\\tisFunction: function( obj ) {\\n\\t\\treturn jQuery.type( obj ) === \"function\";\\n\\t},\\n\\n\\tisWindow: function( obj ) {\\n\\t\\treturn obj != null && obj === obj.window;\\n\\t},\\n\\n\\tisNumeric: function( obj ) {\\n\\n\\t\\t// As of jQuery 3.0, isNumeric is limited to\\n\\t\\t// strings and numbers (primitives or objects)\\n\\t\\t// that can be coerced to finite numbers (gh-2662)\\n\\t\\tvar type = jQuery.type( obj );\\n\\t\\treturn ( type === \"number\" || type === \"string\" ) &&\\n\\n\\t\\t\\t// parseFloat NaNs numeric-cast false positives (\"\")\\n\\t\\t\\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\\n\\t\\t\\t// subtraction forces infinities to NaN\\n\\t\\t\\t!isNaN( obj - parseFloat( obj ) );\\n\\t},\\n\\n\\tisPlainObject: function( obj ) {\\n\\t\\tvar proto, Ctor;\\n\\n\\t\\t// Detect obvious negatives\\n\\t\\t// Use toString instead of jQuery.type to catch host objects\\n\\t\\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tproto = getProto( obj );\\n\\n\\t\\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\\n\\t\\tif ( !proto ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Objects with prototype are plain iff they were constructed by a global Object function\\n\\t\\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\\n\\t\\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\\n\\t},\\n\\n\\tisEmptyObject: function( obj ) {\\n\\n\\t\\t/* eslint-disable no-unused-vars */\\n\\t\\t// See https://github.com/eslint/eslint/issues/6125\\n\\t\\tvar name;\\n\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t},\\n\\n\\ttype: function( obj ) {\\n\\t\\tif ( obj == null ) {\\n\\t\\t\\treturn obj + \"\";\\n\\t\\t}\\n\\n\\t\\t// Support: Android <=2.3 only (functionish RegExp)\\n\\t\\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\\n\\t\\t\\tclass2type[ toString.call( obj ) ] || \"object\" :\\n\\t\\t\\ttypeof obj;\\n\\t},\\n\\n\\t// Evaluates a script in a global context\\n\\tglobalEval: function( code ) {\\n\\t\\tDOMEval( code );\\n\\t},\\n\\n\\t// Convert dashed to camelCase; used by the css and data modules\\n\\t// Support: IE <=9 - 11, Edge 12 - 13\\n\\t// Microsoft forgot to hump their vendor prefix (#9572)\\n\\tcamelCase: function( string ) {\\n\\t\\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\\n\\t},\\n\\n\\teach: function( obj, callback ) {\\n\\t\\tvar length, i = 0;\\n\\n\\t\\tif ( isArrayLike( obj ) ) {\\n\\t\\t\\tlength = obj.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in obj ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn obj;\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\ttrim: function( text ) {\\n\\t\\treturn text == null ?\\n\\t\\t\\t\"\" :\\n\\t\\t\\t( text + \"\" ).replace( rtrim, \"\" );\\n\\t},\\n\\n\\t// results is for internal usage only\\n\\tmakeArray: function( arr, results ) {\\n\\t\\tvar ret = results || [];\\n\\n\\t\\tif ( arr != null ) {\\n\\t\\t\\tif ( isArrayLike( Object( arr ) ) ) {\\n\\t\\t\\t\\tjQuery.merge( ret,\\n\\t\\t\\t\\t\\ttypeof arr === \"string\" ?\\n\\t\\t\\t\\t\\t[ arr ] : arr\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.call( ret, arr );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n\\t},\\n\\n\\tinArray: function( elem, arr, i ) {\\n\\t\\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\tmerge: function( first, second ) {\\n\\t\\tvar len = +second.length,\\n\\t\\t\\tj = 0,\\n\\t\\t\\ti = first.length;\\n\\n\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\tfirst[ i++ ] = second[ j ];\\n\\t\\t}\\n\\n\\t\\tfirst.length = i;\\n\\n\\t\\treturn first;\\n\\t},\\n\\n\\tgrep: function( elems, callback, invert ) {\\n\\t\\tvar callbackInverse,\\n\\t\\t\\tmatches = [],\\n\\t\\t\\ti = 0,\\n\\t\\t\\tlength = elems.length,\\n\\t\\t\\tcallbackExpect = !invert;\\n\\n\\t\\t// Go through the array, only saving the items\\n\\t\\t// that pass the validator function\\n\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\tcallbackInverse = !callback( elems[ i ], i );\\n\\t\\t\\tif ( callbackInverse !== callbackExpect ) {\\n\\t\\t\\t\\tmatches.push( elems[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn matches;\\n\\t},\\n\\n\\t// arg is for internal usage only\\n\\tmap: function( elems, callback, arg ) {\\n\\t\\tvar length, value,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tret = [];\\n\\n\\t\\t// Go through the array, translating each of the items to their new values\\n\\t\\tif ( isArrayLike( elems ) ) {\\n\\t\\t\\tlength = elems.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Go through every key on the object,\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in elems ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Flatten any nested arrays\\n\\t\\treturn concat.apply( [], ret );\\n\\t},\\n\\n\\t// A global GUID counter for objects\\n\\tguid: 1,\\n\\n\\t// Bind a function to a context, optionally partially applying any\\n\\t// arguments.\\n\\tproxy: function( fn, context ) {\\n\\t\\tvar tmp, args, proxy;\\n\\n\\t\\tif ( typeof context === \"string\" ) {\\n\\t\\t\\ttmp = fn[ context ];\\n\\t\\t\\tcontext = fn;\\n\\t\\t\\tfn = tmp;\\n\\t\\t}\\n\\n\\t\\t// Quick check to determine if target is callable, in the spec\\n\\t\\t// this throws a TypeError, but we will just return undefined.\\n\\t\\tif ( !jQuery.isFunction( fn ) ) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\n\\t\\t// Simulated bind\\n\\t\\targs = slice.call( arguments, 2 );\\n\\t\\tproxy = function() {\\n\\t\\t\\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\\n\\t\\t};\\n\\n\\t\\t// Set the guid of unique handler to the same of original handler, so it can be removed\\n\\t\\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\\n\\n\\t\\treturn proxy;\\n\\t},\\n\\n\\tnow: Date.now,\\n\\n\\t// jQuery.support is not used in Core but other projects attach their\\n\\t// properties to it so it needs to exist.\\n\\tsupport: support\\n} );\\n\\nif ( typeof Symbol === \"function\" ) {\\n\\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\\n}\\n\\n// Populate the class2type map\\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\\nfunction( i, name ) {\\n\\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\\n} );\\n\\nfunction isArrayLike( obj ) {\\n\\n\\t// Support: real iOS 8.2 only (not reproducible in simulator)\\n\\t// `in` check used to prevent JIT error (gh-2145)\\n\\t// hasOwn isn\\'t used here due to false negatives\\n\\t// regarding Nodelist length in IE\\n\\tvar length = !!obj && \"length\" in obj && obj.length,\\n\\t\\ttype = jQuery.type( obj );\\n\\n\\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn type === \"array\" || length === 0 ||\\n\\t\\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\\n}\\nvar Sizzle =\\n/*!\\n * Sizzle CSS Selector Engine v2.3.3\\n * https://sizzlejs.com/\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2016-08-08\\n */\\n(function( window ) {\\n\\nvar i,\\n\\tsupport,\\n\\tExpr,\\n\\tgetText,\\n\\tisXML,\\n\\ttokenize,\\n\\tcompile,\\n\\tselect,\\n\\toutermostContext,\\n\\tsortInput,\\n\\thasDuplicate,\\n\\n\\t// Local document vars\\n\\tsetDocument,\\n\\tdocument,\\n\\tdocElem,\\n\\tdocumentIsHTML,\\n\\trbuggyQSA,\\n\\trbuggyMatches,\\n\\tmatches,\\n\\tcontains,\\n\\n\\t// Instance-specific data\\n\\texpando = \"sizzle\" + 1 * new Date(),\\n\\tpreferredDoc = window.document,\\n\\tdirruns = 0,\\n\\tdone = 0,\\n\\tclassCache = createCache(),\\n\\ttokenCache = createCache(),\\n\\tcompilerCache = createCache(),\\n\\tsortOrder = function( a, b ) {\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t},\\n\\n\\t// Instance methods\\n\\thasOwn = ({}).hasOwnProperty,\\n\\tarr = [],\\n\\tpop = arr.pop,\\n\\tpush_native = arr.push,\\n\\tpush = arr.push,\\n\\tslice = arr.slice,\\n\\t// Use a stripped-down indexOf as it\\'s faster than native\\n\\t// https://jsperf.com/thor-indexof-vs-for/5\\n\\tindexOf = function( list, elem ) {\\n\\t\\tvar i = 0,\\n\\t\\t\\tlen = list.length;\\n\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\tif ( list[i] === elem ) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t},\\n\\n\\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\\n\\n\\t// Regular expressions\\n\\n\\t// http://www.w3.org/TR/css3-selectors/#whitespace\\n\\twhitespace = \"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\",\\n\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\\n\\tidentifier = \"(?:\\\\\\\\\\\\\\\\.|[\\\\\\\\w-]|[^\\\\0-\\\\\\\\xa0])+\",\\n\\n\\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\\n\\tattributes = \"\\\\\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\\n\\t\\t// Operator (capture 2)\\n\\t\\t\"*([*^$|!~]?=)\" + whitespace +\\n\\t\\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\\n\\t\\t\"*(?:\\'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\'])*)\\'|\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\"|(\" + identifier + \"))|)\" + whitespace +\\n\\t\\t\"*\\\\\\\\]\",\\n\\n\\tpseudos = \":(\" + identifier + \")(?:\\\\\\\\((\" +\\n\\t\\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\\n\\t\\t// 1. quoted (capture 3; capture 4 or capture 5)\\n\\t\\t\"(\\'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\'])*)\\'|\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\")|\" +\\n\\t\\t// 2. simple (capture 6)\\n\\t\\t\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\" + attributes + \")*)|\" +\\n\\t\\t// 3. anything else (capture 2)\\n\\t\\t\".*\" +\\n\\t\\t\")\\\\\\\\)|)\",\\n\\n\\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\\n\\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\\n\\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\\n\\n\\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\\n\\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\\n\\n\\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\\\\\]\\'\\\\\"]*?)\" + whitespace + \"*\\\\\\\\]\", \"g\" ),\\n\\n\\trpseudo = new RegExp( pseudos ),\\n\\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\\n\\n\\tmatchExpr = {\\n\\t\\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\\n\\t\\t\"CLASS\": new RegExp( \"^\\\\\\\\.(\" + identifier + \")\" ),\\n\\t\\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\\n\\t\\t\"ATTR\": new RegExp( \"^\" + attributes ),\\n\\t\\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\\n\\t\\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\" + whitespace +\\n\\t\\t\\t\"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\\n\\t\\t\\t\"*(\\\\\\\\d+)|))\" + whitespace + \"*\\\\\\\\)|)\", \"i\" ),\\n\\t\\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\\n\\t\\t// For use in libraries implementing .is()\\n\\t\\t// We use this for POS matching in `select`\\n\\t\\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\" +\\n\\t\\t\\twhitespace + \"*((?:-\\\\\\\\d)?\\\\\\\\d*)\" + whitespace + \"*\\\\\\\\)|)(?=[^-]|$)\", \"i\" )\\n\\t},\\n\\n\\trinputs = /^(?:input|select|textarea|button)$/i,\\n\\trheader = /^h\\\\d$/i,\\n\\n\\trnative = /^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,\\n\\n\\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\\n\\trquickExpr = /^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,\\n\\n\\trsibling = /[+~]/,\\n\\n\\t// CSS escapes\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\\n\\trunescape = new RegExp( \"\\\\\\\\\\\\\\\\([\\\\\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\\n\\tfunescape = function( _, escaped, escapedWhitespace ) {\\n\\t\\tvar high = \"0x\" + escaped - 0x10000;\\n\\t\\t// NaN means non-codepoint\\n\\t\\t// Support: Firefox<24\\n\\t\\t// Workaround erroneous numeric interpretation of +\"0x\"\\n\\t\\treturn high !== high || escapedWhitespace ?\\n\\t\\t\\tescaped :\\n\\t\\t\\thigh < 0 ?\\n\\t\\t\\t\\t// BMP codepoint\\n\\t\\t\\t\\tString.fromCharCode( high + 0x10000 ) :\\n\\t\\t\\t\\t// Supplemental Plane codepoint (surrogate pair)\\n\\t\\t\\t\\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\\n\\t},\\n\\n\\t// CSS string/identifier serialization\\n\\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\\n\\trcssescape = /([\\\\0-\\\\x1f\\\\x7f]|^-?\\\\d)|^-$|[^\\\\0-\\\\x1f\\\\x7f-\\\\uFFFF\\\\w-]/g,\\n\\tfcssescape = function( ch, asCodePoint ) {\\n\\t\\tif ( asCodePoint ) {\\n\\n\\t\\t\\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\\n\\t\\t\\tif ( ch === \"\\\\0\" ) {\\n\\t\\t\\t\\treturn \"\\\\uFFFD\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Control characters and (dependent upon position) numbers get escaped as code points\\n\\t\\t\\treturn ch.slice( 0, -1 ) + \"\\\\\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\\n\\t\\t}\\n\\n\\t\\t// Other potentially-special ASCII characters get backslash-escaped\\n\\t\\treturn \"\\\\\\\\\" + ch;\\n\\t},\\n\\n\\t// Used for iframes\\n\\t// See setDocument()\\n\\t// Removing the function wrapper causes a \"Permission Denied\"\\n\\t// error in IE\\n\\tunloadHandler = function() {\\n\\t\\tsetDocument();\\n\\t},\\n\\n\\tdisabledAncestor = addCombinator(\\n\\t\\tfunction( elem ) {\\n\\t\\t\\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\\n\\t\\t},\\n\\t\\t{ dir: \"parentNode\", next: \"legend\" }\\n\\t);\\n\\n// Optimize for push.apply( _, NodeList )\\ntry {\\n\\tpush.apply(\\n\\t\\t(arr = slice.call( preferredDoc.childNodes )),\\n\\t\\tpreferredDoc.childNodes\\n\\t);\\n\\t// Support: Android<4.0\\n\\t// Detect silently failing push.apply\\n\\tarr[ preferredDoc.childNodes.length ].nodeType;\\n} catch ( e ) {\\n\\tpush = { apply: arr.length ?\\n\\n\\t\\t// Leverage slice if possible\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tpush_native.apply( target, slice.call(els) );\\n\\t\\t} :\\n\\n\\t\\t// Support: IE<9\\n\\t\\t// Otherwise append directly\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tvar j = target.length,\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t// Can\\'t trust NodeList.length\\n\\t\\t\\twhile ( (target[j++] = els[i++]) ) {}\\n\\t\\t\\ttarget.length = j - 1;\\n\\t\\t}\\n\\t};\\n}\\n\\nfunction Sizzle( selector, context, results, seed ) {\\n\\tvar m, i, elem, nid, match, groups, newSelector,\\n\\t\\tnewContext = context && context.ownerDocument,\\n\\n\\t\\t// nodeType defaults to 9, since context defaults to document\\n\\t\\tnodeType = context ? context.nodeType : 9;\\n\\n\\tresults = results || [];\\n\\n\\t// Return early from calls with invalid selector or context\\n\\tif ( typeof selector !== \"string\" || !selector ||\\n\\t\\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\\n\\n\\t\\treturn results;\\n\\t}\\n\\n\\t// Try to shortcut find operations (as opposed to filters) in HTML documents\\n\\tif ( !seed ) {\\n\\n\\t\\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\\n\\t\\t\\tsetDocument( context );\\n\\t\\t}\\n\\t\\tcontext = context || document;\\n\\n\\t\\tif ( documentIsHTML ) {\\n\\n\\t\\t\\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\\n\\t\\t\\t// (excepting DocumentFragment context, where the methods don\\'t exist)\\n\\t\\t\\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\\n\\n\\t\\t\\t\\t// ID selector\\n\\t\\t\\t\\tif ( (m = match[1]) ) {\\n\\n\\t\\t\\t\\t\\t// Document context\\n\\t\\t\\t\\t\\tif ( nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = context.getElementById( m )) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\t\\tif ( elem.id === m ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Element context\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\tif ( newContext && (elem = newContext.getElementById( m )) &&\\n\\t\\t\\t\\t\\t\\t\\tcontains( context, elem ) &&\\n\\t\\t\\t\\t\\t\\t\\telem.id === m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Type selector\\n\\t\\t\\t\\t} else if ( match[2] ) {\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByTagName( selector ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t\\t// Class selector\\n\\t\\t\\t\\t} else if ( (m = match[3]) && support.getElementsByClassName &&\\n\\t\\t\\t\\t\\tcontext.getElementsByClassName ) {\\n\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByClassName( m ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Take advantage of querySelectorAll\\n\\t\\t\\tif ( support.qsa &&\\n\\t\\t\\t\\t!compilerCache[ selector + \" \" ] &&\\n\\t\\t\\t\\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\\n\\n\\t\\t\\t\\tif ( nodeType !== 1 ) {\\n\\t\\t\\t\\t\\tnewContext = context;\\n\\t\\t\\t\\t\\tnewSelector = selector;\\n\\n\\t\\t\\t\\t// qSA looks outside Element context, which is not what we want\\n\\t\\t\\t\\t// Thanks to Andrew Dupont for this workaround technique\\n\\t\\t\\t\\t// Support: IE <=8\\n\\t\\t\\t\\t// Exclude object elements\\n\\t\\t\\t\\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\\n\\n\\t\\t\\t\\t\\t// Capture the context ID, setting it first if necessary\\n\\t\\t\\t\\t\\tif ( (nid = context.getAttribute( \"id\" )) ) {\\n\\t\\t\\t\\t\\t\\tnid = nid.replace( rcssescape, fcssescape );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcontext.setAttribute( \"id\", (nid = expando) );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prefix every selector in the list\\n\\t\\t\\t\\t\\tgroups = tokenize( selector );\\n\\t\\t\\t\\t\\ti = groups.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnewSelector = groups.join( \",\" );\\n\\n\\t\\t\\t\\t\\t// Expand context for sibling selectors\\n\\t\\t\\t\\t\\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\\n\\t\\t\\t\\t\\t\\tcontext;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( newSelector ) {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tpush.apply( results,\\n\\t\\t\\t\\t\\t\\t\\tnewContext.querySelectorAll( newSelector )\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t} catch ( qsaError ) {\\n\\t\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\t\\tif ( nid === expando ) {\\n\\t\\t\\t\\t\\t\\t\\tcontext.removeAttribute( \"id\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// All others\\n\\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\\n}\\n\\n/**\\n * Create key-value caches of limited size\\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\\n *\\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\\n *\\tdeleting the oldest entry\\n */\\nfunction createCache() {\\n\\tvar keys = [];\\n\\n\\tfunction cache( key, value ) {\\n\\t\\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\\n\\t\\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\\n\\t\\t\\t// Only keep the most recent entries\\n\\t\\t\\tdelete cache[ keys.shift() ];\\n\\t\\t}\\n\\t\\treturn (cache[ key + \" \" ] = value);\\n\\t}\\n\\treturn cache;\\n}\\n\\n/**\\n * Mark a function for special use by Sizzle\\n * @param {Function} fn The function to mark\\n */\\nfunction markFunction( fn ) {\\n\\tfn[ expando ] = true;\\n\\treturn fn;\\n}\\n\\n/**\\n * Support testing using an element\\n * @param {Function} fn Passed the created element and returns a boolean result\\n */\\nfunction assert( fn ) {\\n\\tvar el = document.createElement(\"fieldset\");\\n\\n\\ttry {\\n\\t\\treturn !!fn( el );\\n\\t} catch (e) {\\n\\t\\treturn false;\\n\\t} finally {\\n\\t\\t// Remove from its parent by default\\n\\t\\tif ( el.parentNode ) {\\n\\t\\t\\tel.parentNode.removeChild( el );\\n\\t\\t}\\n\\t\\t// release memory in IE\\n\\t\\tel = null;\\n\\t}\\n}\\n\\n/**\\n * Adds the same handler for all of the specified attrs\\n * @param {String} attrs Pipe-separated list of attributes\\n * @param {Function} handler The method that will be applied\\n */\\nfunction addHandle( attrs, handler ) {\\n\\tvar arr = attrs.split(\"|\"),\\n\\t\\ti = arr.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tExpr.attrHandle[ arr[i] ] = handler;\\n\\t}\\n}\\n\\n/**\\n * Checks document order of two siblings\\n * @param {Element} a\\n * @param {Element} b\\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\\n */\\nfunction siblingCheck( a, b ) {\\n\\tvar cur = b && a,\\n\\t\\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\\n\\t\\t\\ta.sourceIndex - b.sourceIndex;\\n\\n\\t// Use IE sourceIndex if available on both nodes\\n\\tif ( diff ) {\\n\\t\\treturn diff;\\n\\t}\\n\\n\\t// Check if b follows a\\n\\tif ( cur ) {\\n\\t\\twhile ( (cur = cur.nextSibling) ) {\\n\\t\\t\\tif ( cur === b ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn a ? 1 : -1;\\n}\\n\\n/**\\n * Returns a function to use in pseudos for input types\\n * @param {String} type\\n */\\nfunction createInputPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn name === \"input\" && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for buttons\\n * @param {String} type\\n */\\nfunction createButtonPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn (name === \"input\" || name === \"button\") && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for :enabled/:disabled\\n * @param {Boolean} disabled true for :disabled; false for :enabled\\n */\\nfunction createDisabledPseudo( disabled ) {\\n\\n\\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\\n\\treturn function( elem ) {\\n\\n\\t\\t// Only certain elements can match :enabled or :disabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\\n\\t\\tif ( \"form\" in elem ) {\\n\\n\\t\\t\\t// Check for inherited disabledness on relevant non-disabled elements:\\n\\t\\t\\t// * listed form-associated elements in a disabled fieldset\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\\n\\t\\t\\t// * option elements in a disabled optgroup\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\\n\\t\\t\\t// All such elements have a \"form\" property.\\n\\t\\t\\tif ( elem.parentNode && elem.disabled === false ) {\\n\\n\\t\\t\\t\\t// Option elements defer to a parent optgroup if present\\n\\t\\t\\t\\tif ( \"label\" in elem ) {\\n\\t\\t\\t\\t\\tif ( \"label\" in elem.parentNode ) {\\n\\t\\t\\t\\t\\t\\treturn elem.parentNode.disabled === disabled;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: IE 6 - 11\\n\\t\\t\\t\\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\\n\\t\\t\\t\\treturn elem.isDisabled === disabled ||\\n\\n\\t\\t\\t\\t\\t// Where there is no isDisabled, check manually\\n\\t\\t\\t\\t\\t/* jshint -W018 */\\n\\t\\t\\t\\t\\telem.isDisabled !== !disabled &&\\n\\t\\t\\t\\t\\t\\tdisabledAncestor( elem ) === disabled;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\n\\t\\t// Try to winnow out elements that can\\'t be disabled before trusting the disabled property.\\n\\t\\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn\\'t\\n\\t\\t// even exist on them, let alone have a boolean value.\\n\\t\\t} else if ( \"label\" in elem ) {\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t}\\n\\n\\t\\t// Remaining elements are neither :enabled nor :disabled\\n\\t\\treturn false;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for positionals\\n * @param {Function} fn\\n */\\nfunction createPositionalPseudo( fn ) {\\n\\treturn markFunction(function( argument ) {\\n\\t\\targument = +argument;\\n\\t\\treturn markFunction(function( seed, matches ) {\\n\\t\\t\\tvar j,\\n\\t\\t\\t\\tmatchIndexes = fn( [], seed.length, argument ),\\n\\t\\t\\t\\ti = matchIndexes.length;\\n\\n\\t\\t\\t// Match elements found at the specified indexes\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( seed[ (j = matchIndexes[i]) ] ) {\\n\\t\\t\\t\\t\\tseed[j] = !(matches[j] = seed[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\n/**\\n * Checks a node for validity as a Sizzle context\\n * @param {Element|Object=} context\\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\\n */\\nfunction testContext( context ) {\\n\\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\\n}\\n\\n// Expose support vars for convenience\\nsupport = Sizzle.support = {};\\n\\n/**\\n * Detects XML nodes\\n * @param {Element|Object} elem An element or a document\\n * @returns {Boolean} True iff elem is a non-HTML XML node\\n */\\nisXML = Sizzle.isXML = function( elem ) {\\n\\t// documentElement is verified for cases where it doesn\\'t yet exist\\n\\t// (such as loading iframes in IE - #4833)\\n\\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\\n\\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\\n};\\n\\n/**\\n * Sets document-related variables once based on the current document\\n * @param {Element|Object} [doc] An element or document object to use to set the document\\n * @returns {Object} Returns the current document\\n */\\nsetDocument = Sizzle.setDocument = function( node ) {\\n\\tvar hasCompare, subWindow,\\n\\t\\tdoc = node ? node.ownerDocument || node : preferredDoc;\\n\\n\\t// Return early if doc is invalid or already selected\\n\\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\\n\\t\\treturn document;\\n\\t}\\n\\n\\t// Update global variables\\n\\tdocument = doc;\\n\\tdocElem = document.documentElement;\\n\\tdocumentIsHTML = !isXML( document );\\n\\n\\t// Support: IE 9-11, Edge\\n\\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\\n\\tif ( preferredDoc !== document &&\\n\\t\\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\\n\\n\\t\\t// Support: IE 11, Edge\\n\\t\\tif ( subWindow.addEventListener ) {\\n\\t\\t\\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\\n\\n\\t\\t// Support: IE 9 - 10 only\\n\\t\\t} else if ( subWindow.attachEvent ) {\\n\\t\\t\\tsubWindow.attachEvent( \"onunload\", unloadHandler );\\n\\t\\t}\\n\\t}\\n\\n\\t/* Attributes\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Support: IE<8\\n\\t// Verify that getAttribute really returns attributes and not properties\\n\\t// (excepting IE8 booleans)\\n\\tsupport.attributes = assert(function( el ) {\\n\\t\\tel.className = \"i\";\\n\\t\\treturn !el.getAttribute(\"className\");\\n\\t});\\n\\n\\t/* getElement(s)By*\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Check if getElementsByTagName(\"*\") returns only elements\\n\\tsupport.getElementsByTagName = assert(function( el ) {\\n\\t\\tel.appendChild( document.createComment(\"\") );\\n\\t\\treturn !el.getElementsByTagName(\"*\").length;\\n\\t});\\n\\n\\t// Support: IE<9\\n\\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\\n\\n\\t// Support: IE<10\\n\\t// Check if getElementById returns elements by name\\n\\t// The broken getElementById methods don\\'t pick up programmatically-set names,\\n\\t// so use a roundabout getElementsByName test\\n\\tsupport.getById = assert(function( el ) {\\n\\t\\tdocElem.appendChild( el ).id = expando;\\n\\t\\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\\n\\t});\\n\\n\\t// ID filter and find\\n\\tif ( support.getById ) {\\n\\t\\tExpr.filter[\"ID\"] = function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn elem.getAttribute(\"id\") === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\tExpr.find[\"ID\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar elem = context.getElementById( id );\\n\\t\\t\\t\\treturn elem ? [ elem ] : [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} else {\\n\\t\\tExpr.filter[\"ID\"] =  function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\\n\\t\\t\\t\\t\\telem.getAttributeNode(\"id\");\\n\\t\\t\\t\\treturn node && node.value === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\t// Support: IE 6 - 7 only\\n\\t\\t// getElementById is not reliable as a find shortcut\\n\\t\\tExpr.find[\"ID\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar node, i, elems,\\n\\t\\t\\t\\t\\telem = context.getElementById( id );\\n\\n\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t// Verify the id attribute\\n\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\"id\");\\n\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Fall back on getElementsByName\\n\\t\\t\\t\\t\\telems = context.getElementsByName( id );\\n\\t\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\t\\twhile ( (elem = elems[i++]) ) {\\n\\t\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\"id\");\\n\\t\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t// Tag\\n\\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\\n\\t\\t\\t\\treturn context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// DocumentFragment nodes don\\'t have gEBTN\\n\\t\\t\\t} else if ( support.qsa ) {\\n\\t\\t\\t\\treturn context.querySelectorAll( tag );\\n\\t\\t\\t}\\n\\t\\t} :\\n\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tvar elem,\\n\\t\\t\\t\\ttmp = [],\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\\n\\t\\t\\t\\tresults = context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// Filter out possible comments\\n\\t\\t\\tif ( tag === \"*\" ) {\\n\\t\\t\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\ttmp.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t};\\n\\n\\t// Class\\n\\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\\n\\t\\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\\n\\t\\t\\treturn context.getElementsByClassName( className );\\n\\t\\t}\\n\\t};\\n\\n\\t/* QSA/matchesSelector\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// QSA and matchesSelector support\\n\\n\\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\\n\\trbuggyMatches = [];\\n\\n\\t// qSa(:focus) reports false when true (Chrome 21)\\n\\t// We allow this because of a bug in IE8/9 that throws an error\\n\\t// whenever `document.activeElement` is accessed on an iframe\\n\\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\\n\\t// See https://bugs.jquery.com/ticket/13378\\n\\trbuggyQSA = [];\\n\\n\\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\\n\\t\\t// Build QSA regex\\n\\t\\t// Regex strategy adopted from Diego Perini\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Select is set to empty string on purpose\\n\\t\\t\\t// This is to test IE\\'s treatment of not explicitly\\n\\t\\t\\t// setting a boolean content attribute,\\n\\t\\t\\t// since its presence should be enough\\n\\t\\t\\t// https://bugs.jquery.com/ticket/12359\\n\\t\\t\\tdocElem.appendChild( el ).innerHTML = \"<a id=\\'\" + expando + \"\\'></a>\" +\\n\\t\\t\\t\\t\"<select id=\\'\" + expando + \"-\\\\r\\\\\\\\\\' msallowcapture=\\'\\'>\" +\\n\\t\\t\\t\\t\"<option selected=\\'\\'></option></select>\";\\n\\n\\t\\t\\t// Support: IE8, Opera 11-12.16\\n\\t\\t\\t// Nothing should be selected when empty strings follow ^= or $= or *=\\n\\t\\t\\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\\n\\t\\t\\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\\n\\t\\t\\tif ( el.querySelectorAll(\"[msallowcapture^=\\'\\']\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:\\'\\'|\\\\\"\\\\\")\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Boolean attributes and \"value\" are not treated correctly\\n\\t\\t\\tif ( !el.querySelectorAll(\"[selected]\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \"\\\\\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\\n\\t\\t\\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\"~=\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Webkit/Opera - :checked should return selected option elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( !el.querySelectorAll(\":checked\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\":checked\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Safari 8+, iOS 8+\\n\\t\\t\\t// https://bugs.webkit.org/show_bug.cgi?id=136851\\n\\t\\t\\t// In-page `selector#id sibling-combinator selector` fails\\n\\t\\t\\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\".#.+[+~]\");\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\tel.innerHTML = \"<a href=\\'\\' disabled=\\'disabled\\'></a>\" +\\n\\t\\t\\t\\t\"<select disabled=\\'disabled\\'><option/></select>\";\\n\\n\\t\\t\\t// Support: Windows 8 Native Apps\\n\\t\\t\\t// The type and name attributes are restricted during .innerHTML assignment\\n\\t\\t\\tvar input = document.createElement(\"input\");\\n\\t\\t\\tinput.setAttribute( \"type\", \"hidden\" );\\n\\t\\t\\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Enforce case-sensitivity of name attribute\\n\\t\\t\\tif ( el.querySelectorAll(\"[name=d]\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \":enabled\", \":disabled\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE9-11+\\n\\t\\t\\t// IE\\'s :disabled selector does not pick up the children of disabled fieldsets\\n\\t\\t\\tdocElem.appendChild( el ).disabled = true;\\n\\t\\t\\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \":enabled\", \":disabled\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Opera 10-11 does not throw on post-comma invalid pseudos\\n\\t\\t\\tel.querySelectorAll(\"*,:x\");\\n\\t\\t\\trbuggyQSA.push(\",.*:\");\\n\\t\\t});\\n\\t}\\n\\n\\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\\n\\t\\tdocElem.webkitMatchesSelector ||\\n\\t\\tdocElem.mozMatchesSelector ||\\n\\t\\tdocElem.oMatchesSelector ||\\n\\t\\tdocElem.msMatchesSelector) )) ) {\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Check to see if it\\'s possible to do matchesSelector\\n\\t\\t\\t// on a disconnected node (IE 9)\\n\\t\\t\\tsupport.disconnectedMatch = matches.call( el, \"*\" );\\n\\n\\t\\t\\t// This should fail with an exception\\n\\t\\t\\t// Gecko does not error, returns false instead\\n\\t\\t\\tmatches.call( el, \"[s!=\\'\\']:x\" );\\n\\t\\t\\trbuggyMatches.push( \"!=\", pseudos );\\n\\t\\t});\\n\\t}\\n\\n\\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\\n\\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\\n\\n\\t/* Contains\\n\\t---------------------------------------------------------------------- */\\n\\thasCompare = rnative.test( docElem.compareDocumentPosition );\\n\\n\\t// Element contains another\\n\\t// Purposefully self-exclusive\\n\\t// As in, an element does not contain itself\\n\\tcontains = hasCompare || rnative.test( docElem.contains ) ?\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tvar adown = a.nodeType === 9 ? a.documentElement : a,\\n\\t\\t\\t\\tbup = b && b.parentNode;\\n\\t\\t\\treturn a === bup || !!( bup && bup.nodeType === 1 && (\\n\\t\\t\\t\\tadown.contains ?\\n\\t\\t\\t\\t\\tadown.contains( bup ) :\\n\\t\\t\\t\\t\\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\\n\\t\\t\\t));\\n\\t\\t} :\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tif ( b ) {\\n\\t\\t\\t\\twhile ( (b = b.parentNode) ) {\\n\\t\\t\\t\\t\\tif ( b === a ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t/* Sorting\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Document order sorting\\n\\tsortOrder = hasCompare ?\\n\\tfunction( a, b ) {\\n\\n\\t\\t// Flag for duplicate removal\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// Sort on method existence if only one input has compareDocumentPosition\\n\\t\\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\\n\\t\\tif ( compare ) {\\n\\t\\t\\treturn compare;\\n\\t\\t}\\n\\n\\t\\t// Calculate position if both inputs belong to the same document\\n\\t\\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\\n\\t\\t\\ta.compareDocumentPosition( b ) :\\n\\n\\t\\t\\t// Otherwise we know they are disconnected\\n\\t\\t\\t1;\\n\\n\\t\\t// Disconnected nodes\\n\\t\\tif ( compare & 1 ||\\n\\t\\t\\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\\n\\n\\t\\t\\t// Choose the first element that is related to our preferred document\\n\\t\\t\\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Maintain original order\\n\\t\\t\\treturn sortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\t\\t}\\n\\n\\t\\treturn compare & 4 ? -1 : 1;\\n\\t} :\\n\\tfunction( a, b ) {\\n\\t\\t// Exit early if the nodes are identical\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\taup = a.parentNode,\\n\\t\\t\\tbup = b.parentNode,\\n\\t\\t\\tap = [ a ],\\n\\t\\t\\tbp = [ b ];\\n\\n\\t\\t// Parentless nodes are either documents or disconnected\\n\\t\\tif ( !aup || !bup ) {\\n\\t\\t\\treturn a === document ? -1 :\\n\\t\\t\\t\\tb === document ? 1 :\\n\\t\\t\\t\\taup ? -1 :\\n\\t\\t\\t\\tbup ? 1 :\\n\\t\\t\\t\\tsortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\n\\t\\t// If the nodes are siblings, we can do a quick check\\n\\t\\t} else if ( aup === bup ) {\\n\\t\\t\\treturn siblingCheck( a, b );\\n\\t\\t}\\n\\n\\t\\t// Otherwise we need full lists of their ancestors for comparison\\n\\t\\tcur = a;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tap.unshift( cur );\\n\\t\\t}\\n\\t\\tcur = b;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tbp.unshift( cur );\\n\\t\\t}\\n\\n\\t\\t// Walk down the tree looking for a discrepancy\\n\\t\\twhile ( ap[i] === bp[i] ) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn i ?\\n\\t\\t\\t// Do a sibling check if the nodes have a common ancestor\\n\\t\\t\\tsiblingCheck( ap[i], bp[i] ) :\\n\\n\\t\\t\\t// Otherwise nodes in our document sort first\\n\\t\\t\\tap[i] === preferredDoc ? -1 :\\n\\t\\t\\tbp[i] === preferredDoc ? 1 :\\n\\t\\t\\t0;\\n\\t};\\n\\n\\treturn document;\\n};\\n\\nSizzle.matches = function( expr, elements ) {\\n\\treturn Sizzle( expr, null, null, elements );\\n};\\n\\nSizzle.matchesSelector = function( elem, expr ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\t// Make sure that attribute selectors are quoted\\n\\texpr = expr.replace( rattributeQuotes, \"=\\'$1\\']\" );\\n\\n\\tif ( support.matchesSelector && documentIsHTML &&\\n\\t\\t!compilerCache[ expr + \" \" ] &&\\n\\t\\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\\n\\t\\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\\n\\n\\t\\ttry {\\n\\t\\t\\tvar ret = matches.call( elem, expr );\\n\\n\\t\\t\\t// IE 9\\'s matchesSelector returns false on disconnected nodes\\n\\t\\t\\tif ( ret || support.disconnectedMatch ||\\n\\t\\t\\t\\t\\t// As well, disconnected nodes are said to be in a document\\n\\t\\t\\t\\t\\t// fragment in IE 9\\n\\t\\t\\t\\t\\telem.document && elem.document.nodeType !== 11 ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {}\\n\\t}\\n\\n\\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\\n};\\n\\nSizzle.contains = function( context, elem ) {\\n\\t// Set document vars if needed\\n\\tif ( ( context.ownerDocument || context ) !== document ) {\\n\\t\\tsetDocument( context );\\n\\t}\\n\\treturn contains( context, elem );\\n};\\n\\nSizzle.attr = function( elem, name ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\\n\\t\\t// Don\\'t get fooled by Object.prototype properties (jQuery #13807)\\n\\t\\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\\n\\t\\t\\tfn( elem, name, !documentIsHTML ) :\\n\\t\\t\\tundefined;\\n\\n\\treturn val !== undefined ?\\n\\t\\tval :\\n\\t\\tsupport.attributes || !documentIsHTML ?\\n\\t\\t\\telem.getAttribute( name ) :\\n\\t\\t\\t(val = elem.getAttributeNode(name)) && val.specified ?\\n\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n};\\n\\nSizzle.escape = function( sel ) {\\n\\treturn (sel + \"\").replace( rcssescape, fcssescape );\\n};\\n\\nSizzle.error = function( msg ) {\\n\\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\\n};\\n\\n/**\\n * Document sorting and removing duplicates\\n * @param {ArrayLike} results\\n */\\nSizzle.uniqueSort = function( results ) {\\n\\tvar elem,\\n\\t\\tduplicates = [],\\n\\t\\tj = 0,\\n\\t\\ti = 0;\\n\\n\\t// Unless we *know* we can detect duplicates, assume their presence\\n\\thasDuplicate = !support.detectDuplicates;\\n\\tsortInput = !support.sortStable && results.slice( 0 );\\n\\tresults.sort( sortOrder );\\n\\n\\tif ( hasDuplicate ) {\\n\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\tif ( elem === results[ i ] ) {\\n\\t\\t\\t\\tj = duplicates.push( i );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile ( j-- ) {\\n\\t\\t\\tresults.splice( duplicates[ j ], 1 );\\n\\t\\t}\\n\\t}\\n\\n\\t// Clear input after sorting to release objects\\n\\t// See https://github.com/jquery/sizzle/pull/225\\n\\tsortInput = null;\\n\\n\\treturn results;\\n};\\n\\n/**\\n * Utility function for retrieving the text value of an array of DOM nodes\\n * @param {Array|Element} elem\\n */\\ngetText = Sizzle.getText = function( elem ) {\\n\\tvar node,\\n\\t\\tret = \"\",\\n\\t\\ti = 0,\\n\\t\\tnodeType = elem.nodeType;\\n\\n\\tif ( !nodeType ) {\\n\\t\\t// If no nodeType, this is expected to be an array\\n\\t\\twhile ( (node = elem[i++]) ) {\\n\\t\\t\\t// Do not traverse comment nodes\\n\\t\\t\\tret += getText( node );\\n\\t\\t}\\n\\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\\n\\t\\t// Use textContent for elements\\n\\t\\t// innerText usage removed for consistency of new lines (jQuery #11153)\\n\\t\\tif ( typeof elem.textContent === \"string\" ) {\\n\\t\\t\\treturn elem.textContent;\\n\\t\\t} else {\\n\\t\\t\\t// Traverse its children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tret += getText( elem );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if ( nodeType === 3 || nodeType === 4 ) {\\n\\t\\treturn elem.nodeValue;\\n\\t}\\n\\t// Do not include comment or processing instruction nodes\\n\\n\\treturn ret;\\n};\\n\\nExpr = Sizzle.selectors = {\\n\\n\\t// Can be adjusted by the user\\n\\tcacheLength: 50,\\n\\n\\tcreatePseudo: markFunction,\\n\\n\\tmatch: matchExpr,\\n\\n\\tattrHandle: {},\\n\\n\\tfind: {},\\n\\n\\trelative: {\\n\\t\\t\">\": { dir: \"parentNode\", first: true },\\n\\t\\t\" \": { dir: \"parentNode\" },\\n\\t\\t\"+\": { dir: \"previousSibling\", first: true },\\n\\t\\t\"~\": { dir: \"previousSibling\" }\\n\\t},\\n\\n\\tpreFilter: {\\n\\t\\t\"ATTR\": function( match ) {\\n\\t\\t\\tmatch[1] = match[1].replace( runescape, funescape );\\n\\n\\t\\t\\t// Move the given value to match[3] whether quoted or unquoted\\n\\t\\t\\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\\n\\n\\t\\t\\tif ( match[2] === \"~=\" ) {\\n\\t\\t\\t\\tmatch[3] = \" \" + match[3] + \" \";\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match.slice( 0, 4 );\\n\\t\\t},\\n\\n\\t\\t\"CHILD\": function( match ) {\\n\\t\\t\\t/* matches from matchExpr[\"CHILD\"]\\n\\t\\t\\t\\t1 type (only|nth|...)\\n\\t\\t\\t\\t2 what (child|of-type)\\n\\t\\t\\t\\t3 argument (even|odd|\\\\d*|\\\\d*n([+-]\\\\d+)?|...)\\n\\t\\t\\t\\t4 xn-component of xn+y argument ([+-]?\\\\d*n|)\\n\\t\\t\\t\\t5 sign of xn-component\\n\\t\\t\\t\\t6 x of xn-component\\n\\t\\t\\t\\t7 sign of y-component\\n\\t\\t\\t\\t8 y of y-component\\n\\t\\t\\t*/\\n\\t\\t\\tmatch[1] = match[1].toLowerCase();\\n\\n\\t\\t\\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\\n\\t\\t\\t\\t// nth-* requires argument\\n\\t\\t\\t\\tif ( !match[3] ) {\\n\\t\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// numeric x and y parameters for Expr.filter.CHILD\\n\\t\\t\\t\\t// remember that false/true cast respectively to 0/1\\n\\t\\t\\t\\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\\n\\t\\t\\t\\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\\n\\n\\t\\t\\t// other types prohibit arguments\\n\\t\\t\\t} else if ( match[3] ) {\\n\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match;\\n\\t\\t},\\n\\n\\t\\t\"PSEUDO\": function( match ) {\\n\\t\\t\\tvar excess,\\n\\t\\t\\t\\tunquoted = !match[6] && match[2];\\n\\n\\t\\t\\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Accept quoted arguments as-is\\n\\t\\t\\tif ( match[3] ) {\\n\\t\\t\\t\\tmatch[2] = match[4] || match[5] || \"\";\\n\\n\\t\\t\\t// Strip excess characters from unquoted arguments\\n\\t\\t\\t} else if ( unquoted && rpseudo.test( unquoted ) &&\\n\\t\\t\\t\\t// Get excess from tokenize (recursively)\\n\\t\\t\\t\\t(excess = tokenize( unquoted, true )) &&\\n\\t\\t\\t\\t// advance to the next closing parenthesis\\n\\t\\t\\t\\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\\n\\n\\t\\t\\t\\t// excess is a negative index\\n\\t\\t\\t\\tmatch[0] = match[0].slice( 0, excess );\\n\\t\\t\\t\\tmatch[2] = unquoted.slice( 0, excess );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Return only captures needed by the pseudo filter method (type and argument)\\n\\t\\t\\treturn match.slice( 0, 3 );\\n\\t\\t}\\n\\t},\\n\\n\\tfilter: {\\n\\n\\t\\t\"TAG\": function( nodeNameSelector ) {\\n\\t\\t\\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn nodeNameSelector === \"*\" ?\\n\\t\\t\\t\\tfunction() { return true; } :\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\"CLASS\": function( className ) {\\n\\t\\t\\tvar pattern = classCache[ className + \" \" ];\\n\\n\\t\\t\\treturn pattern ||\\n\\t\\t\\t\\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\\n\\t\\t\\t\\tclassCache( className, function( elem ) {\\n\\t\\t\\t\\t\\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\\n\\t\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\t\"ATTR\": function( name, operator, check ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar result = Sizzle.attr( elem, name );\\n\\n\\t\\t\\t\\tif ( result == null ) {\\n\\t\\t\\t\\t\\treturn operator === \"!=\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !operator ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult += \"\";\\n\\n\\t\\t\\t\\treturn operator === \"=\" ? result === check :\\n\\t\\t\\t\\t\\toperator === \"!=\" ? result !== check :\\n\\t\\t\\t\\t\\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\\n\\t\\t\\t\\t\\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\\n\\t\\t\\t\\t\\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\\n\\t\\t\\t\\t\\tfalse;\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\"CHILD\": function( type, what, argument, first, last ) {\\n\\t\\t\\tvar simple = type.slice( 0, 3 ) !== \"nth\",\\n\\t\\t\\t\\tforward = type.slice( -4 ) !== \"last\",\\n\\t\\t\\t\\tofType = what === \"of-type\";\\n\\n\\t\\t\\treturn first === 1 && last === 0 ?\\n\\n\\t\\t\\t\\t// Shortcut for :nth-*(n)\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn !!elem.parentNode;\\n\\t\\t\\t\\t} :\\n\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\\n\\t\\t\\t\\t\\t\\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\\n\\t\\t\\t\\t\\t\\tparent = elem.parentNode,\\n\\t\\t\\t\\t\\t\\tname = ofType && elem.nodeName.toLowerCase(),\\n\\t\\t\\t\\t\\t\\tuseCache = !xml && !ofType,\\n\\t\\t\\t\\t\\t\\tdiff = false;\\n\\n\\t\\t\\t\\t\\tif ( parent ) {\\n\\n\\t\\t\\t\\t\\t\\t// :(first|last|only)-(child|of-type)\\n\\t\\t\\t\\t\\t\\tif ( simple ) {\\n\\t\\t\\t\\t\\t\\t\\twhile ( dir ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = node[ dir ]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t// Reverse direction for :only-* (if we haven\\'t yet done so)\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = dir = type === \"only\" && !start && \"nextSibling\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tstart = [ forward ? parent.firstChild : parent.lastChild ];\\n\\n\\t\\t\\t\\t\\t\\t// non-xml :nth-child(...) stores cache data on `parent`\\n\\t\\t\\t\\t\\t\\tif ( forward && useCache ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Seek `elem` from a previously-cached index\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\tnode = parent;\\n\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex && cache[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Fallback to seeking `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// When found, cache indexes on `parent` and break\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( node.nodeType === 1 && ++diff && node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Use previously-cached element index if available\\n\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// xml :nth-child(...)\\n\\t\\t\\t\\t\\t\\t\\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\\n\\t\\t\\t\\t\\t\\t\\tif ( diff === false ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Use the same loop as above to seek `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++diff ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Cache the index of each encountered element\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Incorporate the offset, then check against cycle size\\n\\t\\t\\t\\t\\t\\tdiff -= last;\\n\\t\\t\\t\\t\\t\\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\"PSEUDO\": function( pseudo, argument ) {\\n\\t\\t\\t// pseudo-class names are case-insensitive\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#pseudo-classes\\n\\t\\t\\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\\n\\t\\t\\t// Remember that setFilters inherits from pseudos\\n\\t\\t\\tvar args,\\n\\t\\t\\t\\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\\n\\t\\t\\t\\t\\tSizzle.error( \"unsupported pseudo: \" + pseudo );\\n\\n\\t\\t\\t// The user may use createPseudo to indicate that\\n\\t\\t\\t// arguments are needed to create the filter function\\n\\t\\t\\t// just as Sizzle does\\n\\t\\t\\tif ( fn[ expando ] ) {\\n\\t\\t\\t\\treturn fn( argument );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// But maintain support for old signatures\\n\\t\\t\\tif ( fn.length > 1 ) {\\n\\t\\t\\t\\targs = [ pseudo, pseudo, \"\", argument ];\\n\\t\\t\\t\\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\\n\\t\\t\\t\\t\\tmarkFunction(function( seed, matches ) {\\n\\t\\t\\t\\t\\t\\tvar idx,\\n\\t\\t\\t\\t\\t\\t\\tmatched = fn( seed, argument ),\\n\\t\\t\\t\\t\\t\\t\\ti = matched.length;\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tidx = indexOf( seed, matched[i] );\\n\\t\\t\\t\\t\\t\\t\\tseed[ idx ] = !( matches[ idx ] = matched[i] );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}) :\\n\\t\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\t\\treturn fn( elem, 0, args );\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn fn;\\n\\t\\t}\\n\\t},\\n\\n\\tpseudos: {\\n\\t\\t// Potentially complex pseudos\\n\\t\\t\"not\": markFunction(function( selector ) {\\n\\t\\t\\t// Trim the selector passed to compile\\n\\t\\t\\t// to avoid treating leading and trailing\\n\\t\\t\\t// spaces as combinators\\n\\t\\t\\tvar input = [],\\n\\t\\t\\t\\tresults = [],\\n\\t\\t\\t\\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\\n\\n\\t\\t\\treturn matcher[ expando ] ?\\n\\t\\t\\t\\tmarkFunction(function( seed, matches, context, xml ) {\\n\\t\\t\\t\\t\\tvar elem,\\n\\t\\t\\t\\t\\t\\tunmatched = matcher( seed, null, xml, [] ),\\n\\t\\t\\t\\t\\t\\ti = seed.length;\\n\\n\\t\\t\\t\\t\\t// Match elements unmatched by `matcher`\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\tseed[i] = !(matches[i] = elem);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}) :\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tinput[0] = elem;\\n\\t\\t\\t\\t\\tmatcher( input, null, xml, results );\\n\\t\\t\\t\\t\\t// Don\\'t keep the element (issue #299)\\n\\t\\t\\t\\t\\tinput[0] = null;\\n\\t\\t\\t\\t\\treturn !results.pop();\\n\\t\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\"has\": markFunction(function( selector ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn Sizzle( selector, elem ).length > 0;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\"contains\": markFunction(function( text ) {\\n\\t\\t\\ttext = text.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// \"Whether an element is represented by a :lang() selector\\n\\t\\t// is based solely on the element\\'s language value\\n\\t\\t// being equal to the identifier C,\\n\\t\\t// or beginning with the identifier C immediately followed by \"-\".\\n\\t\\t// The matching of C against the element\\'s language value is performed case-insensitively.\\n\\t\\t// The identifier C does not have to be a valid language name.\"\\n\\t\\t// http://www.w3.org/TR/selectors/#lang-pseudo\\n\\t\\t\"lang\": markFunction( function( lang ) {\\n\\t\\t\\t// lang value must be a valid identifier\\n\\t\\t\\tif ( !ridentifier.test(lang || \"\") ) {\\n\\t\\t\\t\\tSizzle.error( \"unsupported lang: \" + lang );\\n\\t\\t\\t}\\n\\t\\t\\tlang = lang.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar elemLang;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tif ( (elemLang = documentIsHTML ?\\n\\t\\t\\t\\t\\t\\telem.lang :\\n\\t\\t\\t\\t\\t\\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\\n\\n\\t\\t\\t\\t\\t\\telemLang = elemLang.toLowerCase();\\n\\t\\t\\t\\t\\t\\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// Miscellaneous\\n\\t\\t\"target\": function( elem ) {\\n\\t\\t\\tvar hash = window.location && window.location.hash;\\n\\t\\t\\treturn hash && hash.slice( 1 ) === elem.id;\\n\\t\\t},\\n\\n\\t\\t\"root\": function( elem ) {\\n\\t\\t\\treturn elem === docElem;\\n\\t\\t},\\n\\n\\t\\t\"focus\": function( elem ) {\\n\\t\\t\\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\\n\\t\\t},\\n\\n\\t\\t// Boolean properties\\n\\t\\t\"enabled\": createDisabledPseudo( false ),\\n\\t\\t\"disabled\": createDisabledPseudo( true ),\\n\\n\\t\\t\"checked\": function( elem ) {\\n\\t\\t\\t// In CSS3, :checked should return both checked and selected elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\tvar nodeName = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\\n\\t\\t},\\n\\n\\t\\t\"selected\": function( elem ) {\\n\\t\\t\\t// Accessing this property makes selected-by-default\\n\\t\\t\\t// options in Safari work properly\\n\\t\\t\\tif ( elem.parentNode ) {\\n\\t\\t\\t\\telem.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.selected === true;\\n\\t\\t},\\n\\n\\t\\t// Contents\\n\\t\\t\"empty\": function( elem ) {\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#empty-pseudo\\n\\t\\t\\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\\n\\t\\t\\t//   but not by others (comment: 8; processing instruction: 7; etc.)\\n\\t\\t\\t// nodeType < 6 works because attributes (2) do not appear as children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tif ( elem.nodeType < 6 ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\t\"parent\": function( elem ) {\\n\\t\\t\\treturn !Expr.pseudos[\"empty\"]( elem );\\n\\t\\t},\\n\\n\\t\\t// Element/input types\\n\\t\\t\"header\": function( elem ) {\\n\\t\\t\\treturn rheader.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\"input\": function( elem ) {\\n\\t\\t\\treturn rinputs.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\"button\": function( elem ) {\\n\\t\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\\n\\t\\t},\\n\\n\\t\\t\"text\": function( elem ) {\\n\\t\\t\\tvar attr;\\n\\t\\t\\treturn elem.nodeName.toLowerCase() === \"input\" &&\\n\\t\\t\\t\\telem.type === \"text\" &&\\n\\n\\t\\t\\t\\t// Support: IE<8\\n\\t\\t\\t\\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\\n\\t\\t\\t\\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\\n\\t\\t},\\n\\n\\t\\t// Position-in-collection\\n\\t\\t\"first\": createPositionalPseudo(function() {\\n\\t\\t\\treturn [ 0 ];\\n\\t\\t}),\\n\\n\\t\\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\treturn [ length - 1 ];\\n\\t\\t}),\\n\\n\\t\\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\treturn [ argument < 0 ? argument + length : argument ];\\n\\t\\t}),\\n\\n\\t\\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 1;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; --i >= 0; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; ++i < length; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t})\\n\\t}\\n};\\n\\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\\n\\n// Add button/input type pseudos\\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\\n\\tExpr.pseudos[ i ] = createInputPseudo( i );\\n}\\nfor ( i in { submit: true, reset: true } ) {\\n\\tExpr.pseudos[ i ] = createButtonPseudo( i );\\n}\\n\\n// Easy API for creating new setFilters\\nfunction setFilters() {}\\nsetFilters.prototype = Expr.filters = Expr.pseudos;\\nExpr.setFilters = new setFilters();\\n\\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\\n\\tvar matched, match, tokens, type,\\n\\t\\tsoFar, groups, preFilters,\\n\\t\\tcached = tokenCache[ selector + \" \" ];\\n\\n\\tif ( cached ) {\\n\\t\\treturn parseOnly ? 0 : cached.slice( 0 );\\n\\t}\\n\\n\\tsoFar = selector;\\n\\tgroups = [];\\n\\tpreFilters = Expr.preFilter;\\n\\n\\twhile ( soFar ) {\\n\\n\\t\\t// Comma and first run\\n\\t\\tif ( !matched || (match = rcomma.exec( soFar )) ) {\\n\\t\\t\\tif ( match ) {\\n\\t\\t\\t\\t// Don\\'t consume trailing commas as valid\\n\\t\\t\\t\\tsoFar = soFar.slice( match[0].length ) || soFar;\\n\\t\\t\\t}\\n\\t\\t\\tgroups.push( (tokens = []) );\\n\\t\\t}\\n\\n\\t\\tmatched = false;\\n\\n\\t\\t// Combinators\\n\\t\\tif ( (match = rcombinators.exec( soFar )) ) {\\n\\t\\t\\tmatched = match.shift();\\n\\t\\t\\ttokens.push({\\n\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t// Cast descendant combinators to space\\n\\t\\t\\t\\ttype: match[0].replace( rtrim, \" \" )\\n\\t\\t\\t});\\n\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t}\\n\\n\\t\\t// Filters\\n\\t\\tfor ( type in Expr.filter ) {\\n\\t\\t\\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\\n\\t\\t\\t\\t(match = preFilters[ type ]( match ))) ) {\\n\\t\\t\\t\\tmatched = match.shift();\\n\\t\\t\\t\\ttokens.push({\\n\\t\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\t\\tmatches: match\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( !matched ) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the length of the invalid excess\\n\\t// if we\\'re just parsing\\n\\t// Otherwise, throw an error or return tokens\\n\\treturn parseOnly ?\\n\\t\\tsoFar.length :\\n\\t\\tsoFar ?\\n\\t\\t\\tSizzle.error( selector ) :\\n\\t\\t\\t// Cache the tokens\\n\\t\\t\\ttokenCache( selector, groups ).slice( 0 );\\n};\\n\\nfunction toSelector( tokens ) {\\n\\tvar i = 0,\\n\\t\\tlen = tokens.length,\\n\\t\\tselector = \"\";\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tselector += tokens[i].value;\\n\\t}\\n\\treturn selector;\\n}\\n\\nfunction addCombinator( matcher, combinator, base ) {\\n\\tvar dir = combinator.dir,\\n\\t\\tskip = combinator.next,\\n\\t\\tkey = skip || dir,\\n\\t\\tcheckNonElements = base && key === \"parentNode\",\\n\\t\\tdoneName = done++;\\n\\n\\treturn combinator.first ?\\n\\t\\t// Check against closest ancestor/preceding element\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\treturn matcher( elem, context, xml );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t} :\\n\\n\\t\\t// Check against all ancestor/preceding elements\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar oldCache, uniqueCache, outerCache,\\n\\t\\t\\t\\tnewCache = [ dirruns, doneName ];\\n\\n\\t\\t\\t// We can\\'t set arbitrary data on XML nodes, so they don\\'t benefit from combinator caching\\n\\t\\t\\tif ( xml ) {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\touterCache = elem[ expando ] || (elem[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\\n\\t\\t\\t\\t\\t\\t\\telem = elem[ dir ] || elem;\\n\\t\\t\\t\\t\\t\\t} else if ( (oldCache = uniqueCache[ key ]) &&\\n\\t\\t\\t\\t\\t\\t\\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Assign to newCache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\treturn (newCache[ 2 ] = oldCache[ 2 ]);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Reuse newcache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache[ key ] = newCache;\\n\\n\\t\\t\\t\\t\\t\\t\\t// A match means we\\'re done; a fail means we have to keep checking\\n\\t\\t\\t\\t\\t\\t\\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n}\\n\\nfunction elementMatcher( matchers ) {\\n\\treturn matchers.length > 1 ?\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar i = matchers.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( !matchers[i]( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} :\\n\\t\\tmatchers[0];\\n}\\n\\nfunction multipleContexts( selector, contexts, results ) {\\n\\tvar i = 0,\\n\\t\\tlen = contexts.length;\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tSizzle( selector, contexts[i], results );\\n\\t}\\n\\treturn results;\\n}\\n\\nfunction condense( unmatched, map, filter, context, xml ) {\\n\\tvar elem,\\n\\t\\tnewUnmatched = [],\\n\\t\\ti = 0,\\n\\t\\tlen = unmatched.length,\\n\\t\\tmapped = map != null;\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\tif ( !filter || filter( elem, context, xml ) ) {\\n\\t\\t\\t\\tnewUnmatched.push( elem );\\n\\t\\t\\t\\tif ( mapped ) {\\n\\t\\t\\t\\t\\tmap.push( i );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn newUnmatched;\\n}\\n\\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\\n\\tif ( postFilter && !postFilter[ expando ] ) {\\n\\t\\tpostFilter = setMatcher( postFilter );\\n\\t}\\n\\tif ( postFinder && !postFinder[ expando ] ) {\\n\\t\\tpostFinder = setMatcher( postFinder, postSelector );\\n\\t}\\n\\treturn markFunction(function( seed, results, context, xml ) {\\n\\t\\tvar temp, i, elem,\\n\\t\\t\\tpreMap = [],\\n\\t\\t\\tpostMap = [],\\n\\t\\t\\tpreexisting = results.length,\\n\\n\\t\\t\\t// Get initial elements from seed or context\\n\\t\\t\\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\\n\\n\\t\\t\\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\\n\\t\\t\\tmatcherIn = preFilter && ( seed || !selector ) ?\\n\\t\\t\\t\\tcondense( elems, preMap, preFilter, context, xml ) :\\n\\t\\t\\t\\telems,\\n\\n\\t\\t\\tmatcherOut = matcher ?\\n\\t\\t\\t\\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\\n\\t\\t\\t\\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\\n\\n\\t\\t\\t\\t\\t// ...intermediate processing is necessary\\n\\t\\t\\t\\t\\t[] :\\n\\n\\t\\t\\t\\t\\t// ...otherwise use results directly\\n\\t\\t\\t\\t\\tresults :\\n\\t\\t\\t\\tmatcherIn;\\n\\n\\t\\t// Find primary matches\\n\\t\\tif ( matcher ) {\\n\\t\\t\\tmatcher( matcherIn, matcherOut, context, xml );\\n\\t\\t}\\n\\n\\t\\t// Apply postFilter\\n\\t\\tif ( postFilter ) {\\n\\t\\t\\ttemp = condense( matcherOut, postMap );\\n\\t\\t\\tpostFilter( temp, [], context, xml );\\n\\n\\t\\t\\t// Un-match failing elements by moving them back to matcherIn\\n\\t\\t\\ti = temp.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( (elem = temp[i]) ) {\\n\\t\\t\\t\\t\\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( seed ) {\\n\\t\\t\\tif ( postFinder || preFilter ) {\\n\\t\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\t\\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\\n\\t\\t\\t\\t\\ttemp = [];\\n\\t\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t// Restore matcherIn since elem is not yet a final match\\n\\t\\t\\t\\t\\t\\t\\ttemp.push( (matcherIn[i] = elem) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpostFinder( null, (matcherOut = []), temp, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Move matched elements from seed to results to keep them synchronized\\n\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) &&\\n\\t\\t\\t\\t\\t\\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\\n\\n\\t\\t\\t\\t\\t\\tseed[temp] = !(results[temp] = elem);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Add elements to results, through postFinder if defined\\n\\t\\t} else {\\n\\t\\t\\tmatcherOut = condense(\\n\\t\\t\\t\\tmatcherOut === results ?\\n\\t\\t\\t\\t\\tmatcherOut.splice( preexisting, matcherOut.length ) :\\n\\t\\t\\t\\t\\tmatcherOut\\n\\t\\t\\t);\\n\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\tpostFinder( null, results, matcherOut, xml );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.apply( results, matcherOut );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n}\\n\\nfunction matcherFromTokens( tokens ) {\\n\\tvar checkContext, matcher, j,\\n\\t\\tlen = tokens.length,\\n\\t\\tleadingRelative = Expr.relative[ tokens[0].type ],\\n\\t\\timplicitRelative = leadingRelative || Expr.relative[\" \"],\\n\\t\\ti = leadingRelative ? 1 : 0,\\n\\n\\t\\t// The foundational matcher ensures that elements are reachable from top-level context(s)\\n\\t\\tmatchContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn elem === checkContext;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchAnyContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn indexOf( checkContext, elem ) > -1;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchers = [ function( elem, context, xml ) {\\n\\t\\t\\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\\n\\t\\t\\t\\t(checkContext = context).nodeType ?\\n\\t\\t\\t\\t\\tmatchContext( elem, context, xml ) :\\n\\t\\t\\t\\t\\tmatchAnyContext( elem, context, xml ) );\\n\\t\\t\\t// Avoid hanging onto element (issue #299)\\n\\t\\t\\tcheckContext = null;\\n\\t\\t\\treturn ret;\\n\\t\\t} ];\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\\n\\t\\t\\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\\n\\t\\t} else {\\n\\t\\t\\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\\n\\n\\t\\t\\t// Return special upon seeing a positional matcher\\n\\t\\t\\tif ( matcher[ expando ] ) {\\n\\t\\t\\t\\t// Find the next relative operator (if any) for proper handling\\n\\t\\t\\t\\tj = ++i;\\n\\t\\t\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\t\\t\\tif ( Expr.relative[ tokens[j].type ] ) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn setMatcher(\\n\\t\\t\\t\\t\\ti > 1 && elementMatcher( matchers ),\\n\\t\\t\\t\\t\\ti > 1 && toSelector(\\n\\t\\t\\t\\t\\t\\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\\n\\t\\t\\t\\t\\t\\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\\n\\t\\t\\t\\t\\t).replace( rtrim, \"$1\" ),\\n\\t\\t\\t\\t\\tmatcher,\\n\\t\\t\\t\\t\\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\\n\\t\\t\\t\\t\\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\\n\\t\\t\\t\\t\\tj < len && toSelector( tokens )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tmatchers.push( matcher );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elementMatcher( matchers );\\n}\\n\\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\\n\\tvar bySet = setMatchers.length > 0,\\n\\t\\tbyElement = elementMatchers.length > 0,\\n\\t\\tsuperMatcher = function( seed, context, xml, results, outermost ) {\\n\\t\\t\\tvar elem, j, matcher,\\n\\t\\t\\t\\tmatchedCount = 0,\\n\\t\\t\\t\\ti = \"0\",\\n\\t\\t\\t\\tunmatched = seed && [],\\n\\t\\t\\t\\tsetMatched = [],\\n\\t\\t\\t\\tcontextBackup = outermostContext,\\n\\t\\t\\t\\t// We must always have either seed elements or outermost context\\n\\t\\t\\t\\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\\n\\t\\t\\t\\t// Use integer dirruns iff this is the outermost matcher\\n\\t\\t\\t\\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\\n\\t\\t\\t\\tlen = elems.length;\\n\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\toutermostContext = context === document || context || outermost;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add elements passing elementMatchers directly to results\\n\\t\\t\\t// Support: IE<9, Safari\\n\\t\\t\\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\\n\\t\\t\\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\\n\\t\\t\\t\\tif ( byElement && elem ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\tif ( !context && elem.ownerDocument !== document ) {\\n\\t\\t\\t\\t\\t\\tsetDocument( elem );\\n\\t\\t\\t\\t\\t\\txml = !documentIsHTML;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile ( (matcher = elementMatchers[j++]) ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context || document, xml) ) {\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Track unmatched elements for set filters\\n\\t\\t\\t\\tif ( bySet ) {\\n\\t\\t\\t\\t\\t// They will have gone through all possible matchers\\n\\t\\t\\t\\t\\tif ( (elem = !matcher && elem) ) {\\n\\t\\t\\t\\t\\t\\tmatchedCount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Lengthen the array for every element, matched or not\\n\\t\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t\\tunmatched.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\\n\\t\\t\\t// makes the latter nonnegative.\\n\\t\\t\\tmatchedCount += i;\\n\\n\\t\\t\\t// Apply set filters to unmatched elements\\n\\t\\t\\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\\n\\t\\t\\t// equals `i`), unless we didn\\'t visit _any_ elements in the above loop because we have\\n\\t\\t\\t// no element matchers and no seed.\\n\\t\\t\\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\\n\\t\\t\\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\\n\\t\\t\\t// numerically zero.\\n\\t\\t\\tif ( bySet && i !== matchedCount ) {\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\twhile ( (matcher = setMatchers[j++]) ) {\\n\\t\\t\\t\\t\\tmatcher( unmatched, setMatched, context, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t// Reintegrate element matches to eliminate the need for sorting\\n\\t\\t\\t\\t\\tif ( matchedCount > 0 ) {\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( !(unmatched[i] || setMatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tsetMatched[i] = pop.call( results );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Discard index placeholder values to get only actual matches\\n\\t\\t\\t\\t\\tsetMatched = condense( setMatched );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Add matches to results\\n\\t\\t\\t\\tpush.apply( results, setMatched );\\n\\n\\t\\t\\t\\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\\n\\t\\t\\t\\tif ( outermost && !seed && setMatched.length > 0 &&\\n\\t\\t\\t\\t\\t( matchedCount + setMatchers.length ) > 1 ) {\\n\\n\\t\\t\\t\\t\\tSizzle.uniqueSort( results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Override manipulation of globals by nested matchers\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\toutermostContext = contextBackup;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unmatched;\\n\\t\\t};\\n\\n\\treturn bySet ?\\n\\t\\tmarkFunction( superMatcher ) :\\n\\t\\tsuperMatcher;\\n}\\n\\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\\n\\tvar i,\\n\\t\\tsetMatchers = [],\\n\\t\\telementMatchers = [],\\n\\t\\tcached = compilerCache[ selector + \" \" ];\\n\\n\\tif ( !cached ) {\\n\\t\\t// Generate a function of recursive functions that can be used to check each element\\n\\t\\tif ( !match ) {\\n\\t\\t\\tmatch = tokenize( selector );\\n\\t\\t}\\n\\t\\ti = match.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tcached = matcherFromTokens( match[i] );\\n\\t\\t\\tif ( cached[ expando ] ) {\\n\\t\\t\\t\\tsetMatchers.push( cached );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telementMatchers.push( cached );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Cache the compiled function\\n\\t\\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\\n\\n\\t\\t// Save selector and tokenization\\n\\t\\tcached.selector = selector;\\n\\t}\\n\\treturn cached;\\n};\\n\\n/**\\n * A low-level selection function that works with Sizzle\\'s compiled\\n *  selector functions\\n * @param {String|Function} selector A selector or a pre-compiled\\n *  selector function built with Sizzle.compile\\n * @param {Element} context\\n * @param {Array} [results]\\n * @param {Array} [seed] A set of elements to match against\\n */\\nselect = Sizzle.select = function( selector, context, results, seed ) {\\n\\tvar i, tokens, token, type, find,\\n\\t\\tcompiled = typeof selector === \"function\" && selector,\\n\\t\\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\\n\\n\\tresults = results || [];\\n\\n\\t// Try to minimize operations if there is only one selector in the list and no seed\\n\\t// (the latter of which guarantees us context)\\n\\tif ( match.length === 1 ) {\\n\\n\\t\\t// Reduce context if the leading compound selector is an ID\\n\\t\\ttokens = match[0] = match[0].slice( 0 );\\n\\t\\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\\n\\t\\t\\t\\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\\n\\n\\t\\t\\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\\n\\t\\t\\tif ( !context ) {\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t// Precompiled matchers will still verify ancestry, so step up a level\\n\\t\\t\\t} else if ( compiled ) {\\n\\t\\t\\t\\tcontext = context.parentNode;\\n\\t\\t\\t}\\n\\n\\t\\t\\tselector = selector.slice( tokens.shift().value.length );\\n\\t\\t}\\n\\n\\t\\t// Fetch a seed set for right-to-left matching\\n\\t\\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttoken = tokens[i];\\n\\n\\t\\t\\t// Abort if we hit a combinator\\n\\t\\t\\tif ( Expr.relative[ (type = token.type) ] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( (find = Expr.find[ type ]) ) {\\n\\t\\t\\t\\t// Search, expanding context for leading sibling combinators\\n\\t\\t\\t\\tif ( (seed = find(\\n\\t\\t\\t\\t\\ttoken.matches[0].replace( runescape, funescape ),\\n\\t\\t\\t\\t\\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\\n\\t\\t\\t\\t)) ) {\\n\\n\\t\\t\\t\\t\\t// If seed is empty or no tokens remain, we can return early\\n\\t\\t\\t\\t\\ttokens.splice( i, 1 );\\n\\t\\t\\t\\t\\tselector = seed.length && toSelector( tokens );\\n\\t\\t\\t\\t\\tif ( !selector ) {\\n\\t\\t\\t\\t\\t\\tpush.apply( results, seed );\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Compile and execute a filtering function if one is not provided\\n\\t// Provide `match` to avoid retokenization if we modified the selector above\\n\\t( compiled || compile( selector, match ) )(\\n\\t\\tseed,\\n\\t\\tcontext,\\n\\t\\t!documentIsHTML,\\n\\t\\tresults,\\n\\t\\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\\n\\t);\\n\\treturn results;\\n};\\n\\n// One-time assignments\\n\\n// Sort stability\\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\\n\\n// Support: Chrome 14-35+\\n// Always assume duplicates if they aren\\'t passed to the comparison function\\nsupport.detectDuplicates = !!hasDuplicate;\\n\\n// Initialize against the default document\\nsetDocument();\\n\\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\\n// Detached nodes confoundingly follow *each other*\\nsupport.sortDetached = assert(function( el ) {\\n\\t// Should return 1, but returns 4 (following)\\n\\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\\n});\\n\\n// Support: IE<8\\n// Prevent attribute/property \"interpolation\"\\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\\nif ( !assert(function( el ) {\\n\\tel.innerHTML = \"<a href=\\'#\\'></a>\";\\n\\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\\n}) ) {\\n\\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use defaultValue in place of getAttribute(\"value\")\\nif ( !support.attributes || !assert(function( el ) {\\n\\tel.innerHTML = \"<input/>\";\\n\\tel.firstChild.setAttribute( \"value\", \"\" );\\n\\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\\n}) ) {\\n\\taddHandle( \"value\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\\n\\t\\t\\treturn elem.defaultValue;\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use getAttributeNode to fetch booleans when getAttribute lies\\nif ( !assert(function( el ) {\\n\\treturn el.getAttribute(\"disabled\") == null;\\n}) ) {\\n\\taddHandle( booleans, function( elem, name, isXML ) {\\n\\t\\tvar val;\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem[ name ] === true ? name.toLowerCase() :\\n\\t\\t\\t\\t\\t(val = elem.getAttributeNode( name )) && val.specified ?\\n\\t\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n\\t\\t}\\n\\t});\\n}\\n\\nreturn Sizzle;\\n\\n})( window );\\n\\n\\n\\njQuery.find = Sizzle;\\njQuery.expr = Sizzle.selectors;\\n\\n// Deprecated\\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\\njQuery.text = Sizzle.getText;\\njQuery.isXMLDoc = Sizzle.isXML;\\njQuery.contains = Sizzle.contains;\\njQuery.escapeSelector = Sizzle.escape;\\n\\n\\n\\n\\nvar dir = function( elem, dir, until ) {\\n\\tvar matched = [],\\n\\t\\ttruncate = until !== undefined;\\n\\n\\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\\n\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\tif ( truncate && jQuery( elem ).is( until ) ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tmatched.push( elem );\\n\\t\\t}\\n\\t}\\n\\treturn matched;\\n};\\n\\n\\nvar siblings = function( n, elem ) {\\n\\tvar matched = [];\\n\\n\\tfor ( ; n; n = n.nextSibling ) {\\n\\t\\tif ( n.nodeType === 1 && n !== elem ) {\\n\\t\\t\\tmatched.push( n );\\n\\t\\t}\\n\\t}\\n\\n\\treturn matched;\\n};\\n\\n\\nvar rneedsContext = jQuery.expr.match.needsContext;\\n\\n\\n\\nfunction nodeName( elem, name ) {\\n\\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\\n\\n};\\nvar rsingleTag = ( /^<([a-z][^\\\\/\\\\0>:\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[\\\\x20\\\\t\\\\r\\\\n\\\\f]*\\\\/?>(?:<\\\\/\\\\1>|)$/i );\\n\\n\\n\\nvar risSimple = /^.[^:#\\\\[\\\\.,]*$/;\\n\\n// Implement the identical functionality for filter and not\\nfunction winnow( elements, qualifier, not ) {\\n\\tif ( jQuery.isFunction( qualifier ) ) {\\n\\t\\treturn jQuery.grep( elements, function( elem, i ) {\\n\\t\\t\\treturn !!qualifier.call( elem, i, elem ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Single element\\n\\tif ( qualifier.nodeType ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( elem === qualifier ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Arraylike of elements (jQuery, arguments, Array)\\n\\tif ( typeof qualifier !== \"string\" ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Simple selector that can be filtered directly, removing non-Elements\\n\\tif ( risSimple.test( qualifier ) ) {\\n\\t\\treturn jQuery.filter( qualifier, elements, not );\\n\\t}\\n\\n\\t// Complex selector, compare the two sets, removing non-Elements\\n\\tqualifier = jQuery.filter( qualifier, elements );\\n\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\\n\\t} );\\n}\\n\\njQuery.filter = function( expr, elems, not ) {\\n\\tvar elem = elems[ 0 ];\\n\\n\\tif ( not ) {\\n\\t\\texpr = \":not(\" + expr + \")\";\\n\\t}\\n\\n\\tif ( elems.length === 1 && elem.nodeType === 1 ) {\\n\\t\\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\\n\\t}\\n\\n\\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\\n\\t\\treturn elem.nodeType === 1;\\n\\t} ) );\\n};\\n\\njQuery.fn.extend( {\\n\\tfind: function( selector ) {\\n\\t\\tvar i, ret,\\n\\t\\t\\tlen = this.length,\\n\\t\\t\\tself = this;\\n\\n\\t\\tif ( typeof selector !== \"string\" ) {\\n\\t\\t\\treturn this.pushStack( jQuery( selector ).filter( function() {\\n\\t\\t\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\t\\t\\tif ( jQuery.contains( self[ i ], this ) ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} ) );\\n\\t\\t}\\n\\n\\t\\tret = this.pushStack( [] );\\n\\n\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\tjQuery.find( selector, self[ i ], ret );\\n\\t\\t}\\n\\n\\t\\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\\n\\t},\\n\\tfilter: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], false ) );\\n\\t},\\n\\tnot: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], true ) );\\n\\t},\\n\\tis: function( selector ) {\\n\\t\\treturn !!winnow(\\n\\t\\t\\tthis,\\n\\n\\t\\t\\t// If this is a positional/relative selector, check membership in the returned set\\n\\t\\t\\t// so $(\"p:first\").is(\"p:last\") won\\'t return true for a doc with two \"p\".\\n\\t\\t\\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\\n\\t\\t\\t\\tjQuery( selector ) :\\n\\t\\t\\t\\tselector || [],\\n\\t\\t\\tfalse\\n\\t\\t).length;\\n\\t}\\n} );\\n\\n\\n// Initialize a jQuery object\\n\\n\\n// A central reference to the root jQuery(document)\\nvar rootjQuery,\\n\\n\\t// A simple way to check for HTML strings\\n\\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\\n\\t// Strict HTML recognition (#11290: must start with <)\\n\\t// Shortcut simple #id case for speed\\n\\trquickExpr = /^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]+))$/,\\n\\n\\tinit = jQuery.fn.init = function( selector, context, root ) {\\n\\t\\tvar match, elem;\\n\\n\\t\\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\\n\\t\\tif ( !selector ) {\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\t// Method init() accepts an alternate rootjQuery\\n\\t\\t// so migrate can support jQuery.sub (gh-2101)\\n\\t\\troot = root || rootjQuery;\\n\\n\\t\\t// Handle HTML strings\\n\\t\\tif ( typeof selector === \"string\" ) {\\n\\t\\t\\tif ( selector[ 0 ] === \"<\" &&\\n\\t\\t\\t\\tselector[ selector.length - 1 ] === \">\" &&\\n\\t\\t\\t\\tselector.length >= 3 ) {\\n\\n\\t\\t\\t\\t// Assume that strings that start and end with <> are HTML and skip the regex check\\n\\t\\t\\t\\tmatch = [ null, selector, null ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmatch = rquickExpr.exec( selector );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Match html or make sure no context is specified for #id\\n\\t\\t\\tif ( match && ( match[ 1 ] || !context ) ) {\\n\\n\\t\\t\\t\\t// HANDLE: $(html) -> $(array)\\n\\t\\t\\t\\tif ( match[ 1 ] ) {\\n\\t\\t\\t\\t\\tcontext = context instanceof jQuery ? context[ 0 ] : context;\\n\\n\\t\\t\\t\\t\\t// Option to run scripts is true for back-compat\\n\\t\\t\\t\\t\\t// Intentionally let the error be thrown if parseHTML is not present\\n\\t\\t\\t\\t\\tjQuery.merge( this, jQuery.parseHTML(\\n\\t\\t\\t\\t\\t\\tmatch[ 1 ],\\n\\t\\t\\t\\t\\t\\tcontext && context.nodeType ? context.ownerDocument || context : document,\\n\\t\\t\\t\\t\\t\\ttrue\\n\\t\\t\\t\\t\\t) );\\n\\n\\t\\t\\t\\t\\t// HANDLE: $(html, props)\\n\\t\\t\\t\\t\\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\\n\\t\\t\\t\\t\\t\\tfor ( match in context ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Properties of context are called as methods if possible\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( this[ match ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis[ match ]( context[ match ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...and otherwise set as attributes\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.attr( match, context[ match ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t// HANDLE: $(#id)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\telem = document.getElementById( match[ 2 ] );\\n\\n\\t\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t\\t// Inject the element directly into the jQuery object\\n\\t\\t\\t\\t\\t\\tthis[ 0 ] = elem;\\n\\t\\t\\t\\t\\t\\tthis.length = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// HANDLE: $(expr, $(...))\\n\\t\\t\\t} else if ( !context || context.jquery ) {\\n\\t\\t\\t\\treturn ( context || root ).find( selector );\\n\\n\\t\\t\\t// HANDLE: $(expr, context)\\n\\t\\t\\t// (which is just equivalent to: $(context).find(expr)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this.constructor( context ).find( selector );\\n\\t\\t\\t}\\n\\n\\t\\t// HANDLE: $(DOMElement)\\n\\t\\t} else if ( selector.nodeType ) {\\n\\t\\t\\tthis[ 0 ] = selector;\\n\\t\\t\\tthis.length = 1;\\n\\t\\t\\treturn this;\\n\\n\\t\\t// HANDLE: $(function)\\n\\t\\t// Shortcut for document ready\\n\\t\\t} else if ( jQuery.isFunction( selector ) ) {\\n\\t\\t\\treturn root.ready !== undefined ?\\n\\t\\t\\t\\troot.ready( selector ) :\\n\\n\\t\\t\\t\\t// Execute immediately if ready is not present\\n\\t\\t\\t\\tselector( jQuery );\\n\\t\\t}\\n\\n\\t\\treturn jQuery.makeArray( selector, this );\\n\\t};\\n\\n// Give the init function the jQuery prototype for later instantiation\\ninit.prototype = jQuery.fn;\\n\\n// Initialize central reference\\nrootjQuery = jQuery( document );\\n\\n\\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\\n\\n\\t// Methods guaranteed to produce a unique set when starting from a unique set\\n\\tguaranteedUnique = {\\n\\t\\tchildren: true,\\n\\t\\tcontents: true,\\n\\t\\tnext: true,\\n\\t\\tprev: true\\n\\t};\\n\\njQuery.fn.extend( {\\n\\thas: function( target ) {\\n\\t\\tvar targets = jQuery( target, this ),\\n\\t\\t\\tl = targets.length;\\n\\n\\t\\treturn this.filter( function() {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tif ( jQuery.contains( this, targets[ i ] ) ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tclosest: function( selectors, context ) {\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tl = this.length,\\n\\t\\t\\tmatched = [],\\n\\t\\t\\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\\n\\n\\t\\t// Positional selectors never match, since there\\'s no _selection_ context\\n\\t\\tif ( !rneedsContext.test( selectors ) ) {\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\\n\\n\\t\\t\\t\\t\\t// Always skip document fragments\\n\\t\\t\\t\\t\\tif ( cur.nodeType < 11 && ( targets ?\\n\\t\\t\\t\\t\\t\\ttargets.index( cur ) > -1 :\\n\\n\\t\\t\\t\\t\\t\\t// Don\\'t pass non-elements to Sizzle\\n\\t\\t\\t\\t\\t\\tcur.nodeType === 1 &&\\n\\t\\t\\t\\t\\t\\t\\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tmatched.push( cur );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\\n\\t},\\n\\n\\t// Determine the position of an element within the set\\n\\tindex: function( elem ) {\\n\\n\\t\\t// No argument, return index in parent\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\\n\\t\\t}\\n\\n\\t\\t// Index in selector\\n\\t\\tif ( typeof elem === \"string\" ) {\\n\\t\\t\\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\\n\\t\\t}\\n\\n\\t\\t// Locate the position of the desired element\\n\\t\\treturn indexOf.call( this,\\n\\n\\t\\t\\t// If it receives a jQuery object, the first element is used\\n\\t\\t\\telem.jquery ? elem[ 0 ] : elem\\n\\t\\t);\\n\\t},\\n\\n\\tadd: function( selector, context ) {\\n\\t\\treturn this.pushStack(\\n\\t\\t\\tjQuery.uniqueSort(\\n\\t\\t\\t\\tjQuery.merge( this.get(), jQuery( selector, context ) )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t},\\n\\n\\taddBack: function( selector ) {\\n\\t\\treturn this.add( selector == null ?\\n\\t\\t\\tthis.prevObject : this.prevObject.filter( selector )\\n\\t\\t);\\n\\t}\\n} );\\n\\nfunction sibling( cur, dir ) {\\n\\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\\n\\treturn cur;\\n}\\n\\njQuery.each( {\\n\\tparent: function( elem ) {\\n\\t\\tvar parent = elem.parentNode;\\n\\t\\treturn parent && parent.nodeType !== 11 ? parent : null;\\n\\t},\\n\\tparents: function( elem ) {\\n\\t\\treturn dir( elem, \"parentNode\" );\\n\\t},\\n\\tparentsUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \"parentNode\", until );\\n\\t},\\n\\tnext: function( elem ) {\\n\\t\\treturn sibling( elem, \"nextSibling\" );\\n\\t},\\n\\tprev: function( elem ) {\\n\\t\\treturn sibling( elem, \"previousSibling\" );\\n\\t},\\n\\tnextAll: function( elem ) {\\n\\t\\treturn dir( elem, \"nextSibling\" );\\n\\t},\\n\\tprevAll: function( elem ) {\\n\\t\\treturn dir( elem, \"previousSibling\" );\\n\\t},\\n\\tnextUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \"nextSibling\", until );\\n\\t},\\n\\tprevUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \"previousSibling\", until );\\n\\t},\\n\\tsiblings: function( elem ) {\\n\\t\\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\\n\\t},\\n\\tchildren: function( elem ) {\\n\\t\\treturn siblings( elem.firstChild );\\n\\t},\\n\\tcontents: function( elem ) {\\n        if ( nodeName( elem, \"iframe\" ) ) {\\n            return elem.contentDocument;\\n        }\\n\\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\\n        // Treat the template element as a regular one in browsers that\\n        // don\\'t support it.\\n        if ( nodeName( elem, \"template\" ) ) {\\n            elem = elem.content || elem;\\n        }\\n\\n        return jQuery.merge( [], elem.childNodes );\\n\\t}\\n}, function( name, fn ) {\\n\\tjQuery.fn[ name ] = function( until, selector ) {\\n\\t\\tvar matched = jQuery.map( this, fn, until );\\n\\n\\t\\tif ( name.slice( -5 ) !== \"Until\" ) {\\n\\t\\t\\tselector = until;\\n\\t\\t}\\n\\n\\t\\tif ( selector && typeof selector === \"string\" ) {\\n\\t\\t\\tmatched = jQuery.filter( selector, matched );\\n\\t\\t}\\n\\n\\t\\tif ( this.length > 1 ) {\\n\\n\\t\\t\\t// Remove duplicates\\n\\t\\t\\tif ( !guaranteedUnique[ name ] ) {\\n\\t\\t\\t\\tjQuery.uniqueSort( matched );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reverse order for parents* and prev-derivatives\\n\\t\\t\\tif ( rparentsprev.test( name ) ) {\\n\\t\\t\\t\\tmatched.reverse();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched );\\n\\t};\\n} );\\nvar rnothtmlwhite = ( /[^\\\\x20\\\\t\\\\r\\\\n\\\\f]+/g );\\n\\n\\n\\n// Convert String-formatted options into Object-formatted ones\\nfunction createOptions( options ) {\\n\\tvar object = {};\\n\\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\\n\\t\\tobject[ flag ] = true;\\n\\t} );\\n\\treturn object;\\n}\\n\\n/*\\n * Create a callback list using the following parameters:\\n *\\n *\\toptions: an optional list of space-separated options that will change how\\n *\\t\\t\\tthe callback list behaves or a more traditional option object\\n *\\n * By default a callback list will act like an event callback list and can be\\n * \"fired\" multiple times.\\n *\\n * Possible options:\\n *\\n *\\tonce:\\t\\t\\twill ensure the callback list can only be fired once (like a Deferred)\\n *\\n *\\tmemory:\\t\\t\\twill keep track of previous values and will call any callback added\\n *\\t\\t\\t\\t\\tafter the list has been fired right away with the latest \"memorized\"\\n *\\t\\t\\t\\t\\tvalues (like a Deferred)\\n *\\n *\\tunique:\\t\\t\\twill ensure a callback can only be added once (no duplicate in the list)\\n *\\n *\\tstopOnFalse:\\tinterrupt callings when a callback returns false\\n *\\n */\\njQuery.Callbacks = function( options ) {\\n\\n\\t// Convert options from String-formatted to Object-formatted if needed\\n\\t// (we check in cache first)\\n\\toptions = typeof options === \"string\" ?\\n\\t\\tcreateOptions( options ) :\\n\\t\\tjQuery.extend( {}, options );\\n\\n\\tvar // Flag to know if list is currently firing\\n\\t\\tfiring,\\n\\n\\t\\t// Last fire value for non-forgettable lists\\n\\t\\tmemory,\\n\\n\\t\\t// Flag to know if list was already fired\\n\\t\\tfired,\\n\\n\\t\\t// Flag to prevent firing\\n\\t\\tlocked,\\n\\n\\t\\t// Actual callback list\\n\\t\\tlist = [],\\n\\n\\t\\t// Queue of execution data for repeatable lists\\n\\t\\tqueue = [],\\n\\n\\t\\t// Index of currently firing callback (modified by add/remove as needed)\\n\\t\\tfiringIndex = -1,\\n\\n\\t\\t// Fire callbacks\\n\\t\\tfire = function() {\\n\\n\\t\\t\\t// Enforce single-firing\\n\\t\\t\\tlocked = locked || options.once;\\n\\n\\t\\t\\t// Execute callbacks for all pending executions,\\n\\t\\t\\t// respecting firingIndex overrides and runtime changes\\n\\t\\t\\tfired = firing = true;\\n\\t\\t\\tfor ( ; queue.length; firingIndex = -1 ) {\\n\\t\\t\\t\\tmemory = queue.shift();\\n\\t\\t\\t\\twhile ( ++firingIndex < list.length ) {\\n\\n\\t\\t\\t\\t\\t// Run callback and check for early termination\\n\\t\\t\\t\\t\\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\\n\\t\\t\\t\\t\\t\\toptions.stopOnFalse ) {\\n\\n\\t\\t\\t\\t\\t\\t// Jump to end and forget the data so .add doesn\\'t re-fire\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length;\\n\\t\\t\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Forget the data if we\\'re done with it\\n\\t\\t\\tif ( !options.memory ) {\\n\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfiring = false;\\n\\n\\t\\t\\t// Clean up if we\\'re done firing for good\\n\\t\\t\\tif ( locked ) {\\n\\n\\t\\t\\t\\t// Keep an empty list if we have data for future add calls\\n\\t\\t\\t\\tif ( memory ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\n\\t\\t\\t\\t// Otherwise, this object is spent\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlist = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Actual Callbacks object\\n\\t\\tself = {\\n\\n\\t\\t\\t// Add a callback or a collection of callbacks to the list\\n\\t\\t\\tadd: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\n\\t\\t\\t\\t\\t// If we have memory from a past run, we should fire after adding\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length - 1;\\n\\t\\t\\t\\t\\t\\tqueue.push( memory );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t( function add( args ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( args, function( _, arg ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( !options.unique || !self.has( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlist.push( arg );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Inspect recursively\\n\\t\\t\\t\\t\\t\\t\\t\\tadd( arg );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t} )( arguments );\\n\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove a callback from the list\\n\\t\\t\\tremove: function() {\\n\\t\\t\\t\\tjQuery.each( arguments, function( _, arg ) {\\n\\t\\t\\t\\t\\tvar index;\\n\\t\\t\\t\\t\\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\\n\\t\\t\\t\\t\\t\\tlist.splice( index, 1 );\\n\\n\\t\\t\\t\\t\\t\\t// Handle firing indexes\\n\\t\\t\\t\\t\\t\\tif ( index <= firingIndex ) {\\n\\t\\t\\t\\t\\t\\t\\tfiringIndex--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Check if a given callback is in the list.\\n\\t\\t\\t// If no argument is given, return whether or not list has callbacks attached.\\n\\t\\t\\thas: function( fn ) {\\n\\t\\t\\t\\treturn fn ?\\n\\t\\t\\t\\t\\tjQuery.inArray( fn, list ) > -1 :\\n\\t\\t\\t\\t\\tlist.length > 0;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove all callbacks from the list\\n\\t\\t\\tempty: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire and .add\\n\\t\\t\\t// Abort any current/pending executions\\n\\t\\t\\t// Clear all callbacks and values\\n\\t\\t\\tdisable: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tlist = memory = \"\";\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tdisabled: function() {\\n\\t\\t\\t\\treturn !list;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire\\n\\t\\t\\t// Also disable .add unless we have memory (since it would have no effect)\\n\\t\\t\\t// Abort any pending executions\\n\\t\\t\\tlock: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tif ( !memory && !firing ) {\\n\\t\\t\\t\\t\\tlist = memory = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tlocked: function() {\\n\\t\\t\\t\\treturn !!locked;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all callbacks with the given context and arguments\\n\\t\\t\\tfireWith: function( context, args ) {\\n\\t\\t\\t\\tif ( !locked ) {\\n\\t\\t\\t\\t\\targs = args || [];\\n\\t\\t\\t\\t\\targs = [ context, args.slice ? args.slice() : args ];\\n\\t\\t\\t\\t\\tqueue.push( args );\\n\\t\\t\\t\\t\\tif ( !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all the callbacks with the given arguments\\n\\t\\t\\tfire: function() {\\n\\t\\t\\t\\tself.fireWith( this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// To know if the callbacks have already been called at least once\\n\\t\\t\\tfired: function() {\\n\\t\\t\\t\\treturn !!fired;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\treturn self;\\n};\\n\\n\\nfunction Identity( v ) {\\n\\treturn v;\\n}\\nfunction Thrower( ex ) {\\n\\tthrow ex;\\n}\\n\\nfunction adoptValue( value, resolve, reject, noValue ) {\\n\\tvar method;\\n\\n\\ttry {\\n\\n\\t\\t// Check for promise aspect first to privilege synchronous behavior\\n\\t\\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\\n\\t\\t\\tmethod.call( value ).done( resolve ).fail( reject );\\n\\n\\t\\t// Other thenables\\n\\t\\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\\n\\t\\t\\tmethod.call( value, resolve, reject );\\n\\n\\t\\t// Other non-thenables\\n\\t\\t} else {\\n\\n\\t\\t\\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\\n\\t\\t\\t// * false: [ value ].slice( 0 ) => resolve( value )\\n\\t\\t\\t// * true: [ value ].slice( 1 ) => resolve()\\n\\t\\t\\tresolve.apply( undefined, [ value ].slice( noValue ) );\\n\\t\\t}\\n\\n\\t// For Promises/A+, convert exceptions into rejections\\n\\t// Since jQuery.when doesn\\'t unwrap thenables, we can skip the extra checks appearing in\\n\\t// Deferred#then to conditionally suppress rejection.\\n\\t} catch ( value ) {\\n\\n\\t\\t// Support: Android 4.0 only\\n\\t\\t// Strict mode functions invoked without .call/.apply get global-object context\\n\\t\\treject.apply( undefined, [ value ] );\\n\\t}\\n}\\n\\njQuery.extend( {\\n\\n\\tDeferred: function( func ) {\\n\\t\\tvar tuples = [\\n\\n\\t\\t\\t\\t// action, add listener, callbacks,\\n\\t\\t\\t\\t// ... .then handlers, argument index, [final state]\\n\\t\\t\\t\\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \"memory\" ), 2 ],\\n\\t\\t\\t\\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\\n\\t\\t\\t\\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\\n\\t\\t\\t],\\n\\t\\t\\tstate = \"pending\",\\n\\t\\t\\tpromise = {\\n\\t\\t\\t\\tstate: function() {\\n\\t\\t\\t\\t\\treturn state;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\talways: function() {\\n\\t\\t\\t\\t\\tdeferred.done( arguments ).fail( arguments );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"catch\": function( fn ) {\\n\\t\\t\\t\\t\\treturn promise.then( null, fn );\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Keep pipe for back-compat\\n\\t\\t\\t\\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\\n\\t\\t\\t\\t\\tvar fns = arguments;\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\\n\\t\\t\\t\\t\\t\\t\\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\\n\\t\\t\\t\\t\\t\\t\\tdeferred[ tuple[ 1 ] ]( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar returned = fn && fn.apply( this, arguments );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( returned && jQuery.isFunction( returned.promise ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.promise()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.progress( newDefer.notify )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.done( newDefer.resolve )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.fail( newDefer.reject );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnewDefer[ tuple[ 0 ] + \"With\" ](\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfn ? [ returned ] : arguments\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\tfns = null;\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tthen: function( onFulfilled, onRejected, onProgress ) {\\n\\t\\t\\t\\t\\tvar maxDepth = 0;\\n\\t\\t\\t\\t\\tfunction resolve( depth, deferred, handler, special ) {\\n\\t\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\t\\tvar that = this,\\n\\t\\t\\t\\t\\t\\t\\t\\targs = arguments,\\n\\t\\t\\t\\t\\t\\t\\t\\tmightThrow = function() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar returned, then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-59\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore double-resolution attempts\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth < maxDepth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned = handler.apply( that, args );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-48\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( returned === deferred.promise() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthrow new TypeError( \"Thenable self-resolution\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ sections 2.3.3.1, 3.5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-54\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-75\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Retrieve `then` only once\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthen = returned &&\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-64\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only check objects and functions for thenability\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( typeof returned === \"object\" ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof returned === \"function\" ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle a returned thenable\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.isFunction( then ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Special processors (notify) just wait for resolution\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( special ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Normal processors (resolve) also hook into progress\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// ...and disregard older resolution values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmaxDepth++;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.notifyWith )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle all other returned values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Identity ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ returned ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Process the value(s)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Default process is resolve\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( special || deferred.resolveWith )( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Only normal processors (resolve) catch and reject exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess = special ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.exceptionHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tjQuery.Deferred.exceptionHook( e,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.4.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-61\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore post-resolution exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth + 1 >= maxDepth ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Thrower ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ e ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.rejectWith( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.1\\n\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-57\\n\\t\\t\\t\\t\\t\\t\\t// Re-resolve promises immediately to dodge false rejection from\\n\\t\\t\\t\\t\\t\\t\\t// subsequent errors\\n\\t\\t\\t\\t\\t\\t\\tif ( depth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess();\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Call an optional hook to record the stack, in case of exception\\n\\t\\t\\t\\t\\t\\t\\t\\t// since it\\'s otherwise lost when execution goes async\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.getStackHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace = jQuery.Deferred.getStackHook();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( process );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\n\\t\\t\\t\\t\\t\\t// progress_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onProgress ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonProgress :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer.notifyWith\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// fulfilled_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 1 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onFulfilled ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonFulfilled :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// rejected_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 2 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.isFunction( onRejected ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonRejected :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tThrower\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Get a promise for this deferred\\n\\t\\t\\t\\t// If obj is provided, the promise aspect is added to the object\\n\\t\\t\\t\\tpromise: function( obj ) {\\n\\t\\t\\t\\t\\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdeferred = {};\\n\\n\\t\\t// Add list-specific methods\\n\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\t\\t\\tvar list = tuple[ 2 ],\\n\\t\\t\\t\\tstateString = tuple[ 5 ];\\n\\n\\t\\t\\t// promise.progress = list.add\\n\\t\\t\\t// promise.done = list.add\\n\\t\\t\\t// promise.fail = list.add\\n\\t\\t\\tpromise[ tuple[ 1 ] ] = list.add;\\n\\n\\t\\t\\t// Handle state\\n\\t\\t\\tif ( stateString ) {\\n\\t\\t\\t\\tlist.add(\\n\\t\\t\\t\\t\\tfunction() {\\n\\n\\t\\t\\t\\t\\t\\t// state = \"resolved\" (i.e., fulfilled)\\n\\t\\t\\t\\t\\t\\t// state = \"rejected\"\\n\\t\\t\\t\\t\\t\\tstate = stateString;\\n\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t// rejected_callbacks.disable\\n\\t\\t\\t\\t\\t// fulfilled_callbacks.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 2 ].disable,\\n\\n\\t\\t\\t\\t\\t// progress_callbacks.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 2 ].lock\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// progress_handlers.fire\\n\\t\\t\\t// fulfilled_handlers.fire\\n\\t\\t\\t// rejected_handlers.fire\\n\\t\\t\\tlist.add( tuple[ 3 ].fire );\\n\\n\\t\\t\\t// deferred.notify = function() { deferred.notifyWith(...) }\\n\\t\\t\\t// deferred.resolve = function() { deferred.resolveWith(...) }\\n\\t\\t\\t// deferred.reject = function() { deferred.rejectWith(...) }\\n\\t\\t\\tdeferred[ tuple[ 0 ] ] = function() {\\n\\t\\t\\t\\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t};\\n\\n\\t\\t\\t// deferred.notifyWith = list.fireWith\\n\\t\\t\\t// deferred.resolveWith = list.fireWith\\n\\t\\t\\t// deferred.rejectWith = list.fireWith\\n\\t\\t\\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\\n\\t\\t} );\\n\\n\\t\\t// Make the deferred a promise\\n\\t\\tpromise.promise( deferred );\\n\\n\\t\\t// Call given func if any\\n\\t\\tif ( func ) {\\n\\t\\t\\tfunc.call( deferred, deferred );\\n\\t\\t}\\n\\n\\t\\t// All done!\\n\\t\\treturn deferred;\\n\\t},\\n\\n\\t// Deferred helper\\n\\twhen: function( singleValue ) {\\n\\t\\tvar\\n\\n\\t\\t\\t// count of uncompleted subordinates\\n\\t\\t\\tremaining = arguments.length,\\n\\n\\t\\t\\t// count of unprocessed arguments\\n\\t\\t\\ti = remaining,\\n\\n\\t\\t\\t// subordinate fulfillment data\\n\\t\\t\\tresolveContexts = Array( i ),\\n\\t\\t\\tresolveValues = slice.call( arguments ),\\n\\n\\t\\t\\t// the master Deferred\\n\\t\\t\\tmaster = jQuery.Deferred(),\\n\\n\\t\\t\\t// subordinate callback factory\\n\\t\\t\\tupdateFunc = function( i ) {\\n\\t\\t\\t\\treturn function( value ) {\\n\\t\\t\\t\\t\\tresolveContexts[ i ] = this;\\n\\t\\t\\t\\t\\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\\n\\t\\t\\t\\t\\tif ( !( --remaining ) ) {\\n\\t\\t\\t\\t\\t\\tmaster.resolveWith( resolveContexts, resolveValues );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\t};\\n\\n\\t\\t// Single- and empty arguments are adopted like Promise.resolve\\n\\t\\tif ( remaining <= 1 ) {\\n\\t\\t\\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\\n\\t\\t\\t\\t!remaining );\\n\\n\\t\\t\\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\\n\\t\\t\\tif ( master.state() === \"pending\" ||\\n\\t\\t\\t\\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\\n\\n\\t\\t\\t\\treturn master.then();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Multiple arguments are aggregated like Promise.all array elements\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\\n\\t\\t}\\n\\n\\t\\treturn master.promise();\\n\\t}\\n} );\\n\\n\\n// These usually indicate a programmer mistake during development,\\n// warn about them ASAP rather than swallowing them by default.\\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\\n\\njQuery.Deferred.exceptionHook = function( error, stack ) {\\n\\n\\t// Support: IE 8 - 9 only\\n\\t// Console exists when dev tools are open, which can happen at any time\\n\\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\\n\\t\\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\\n\\t}\\n};\\n\\n\\n\\n\\njQuery.readyException = function( error ) {\\n\\twindow.setTimeout( function() {\\n\\t\\tthrow error;\\n\\t} );\\n};\\n\\n\\n\\n\\n// The deferred used on DOM ready\\nvar readyList = jQuery.Deferred();\\n\\njQuery.fn.ready = function( fn ) {\\n\\n\\treadyList\\n\\t\\t.then( fn )\\n\\n\\t\\t// Wrap jQuery.readyException in a function so that the lookup\\n\\t\\t// happens at the time of error handling instead of callback\\n\\t\\t// registration.\\n\\t\\t.catch( function( error ) {\\n\\t\\t\\tjQuery.readyException( error );\\n\\t\\t} );\\n\\n\\treturn this;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Is the DOM ready to be used? Set to true once it occurs.\\n\\tisReady: false,\\n\\n\\t// A counter to track how many items to wait for before\\n\\t// the ready event fires. See #6781\\n\\treadyWait: 1,\\n\\n\\t// Handle when the DOM is ready\\n\\tready: function( wait ) {\\n\\n\\t\\t// Abort if there are pending holds or we\\'re already ready\\n\\t\\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Remember that the DOM is ready\\n\\t\\tjQuery.isReady = true;\\n\\n\\t\\t// If a normal DOM Ready event fired, decrement, and wait if need be\\n\\t\\tif ( wait !== true && --jQuery.readyWait > 0 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// If there are functions bound, to execute\\n\\t\\treadyList.resolveWith( document, [ jQuery ] );\\n\\t}\\n} );\\n\\njQuery.ready.then = readyList.then;\\n\\n// The ready event handler and self cleanup method\\nfunction completed() {\\n\\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\\n\\twindow.removeEventListener( \"load\", completed );\\n\\tjQuery.ready();\\n}\\n\\n// Catch cases where $(document).ready() is called\\n// after the browser event has already occurred.\\n// Support: IE <=9 - 10 only\\n// Older IE sometimes signals \"interactive\" too soon\\nif ( document.readyState === \"complete\" ||\\n\\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\\n\\n\\t// Handle it asynchronously to allow scripts the opportunity to delay ready\\n\\twindow.setTimeout( jQuery.ready );\\n\\n} else {\\n\\n\\t// Use the handy event callback\\n\\tdocument.addEventListener( \"DOMContentLoaded\", completed );\\n\\n\\t// A fallback to window.onload, that will always work\\n\\twindow.addEventListener( \"load\", completed );\\n}\\n\\n\\n\\n\\n// Multifunctional method to get and set values of a collection\\n// The value/s can optionally be executed if it\\'s a function\\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\\n\\tvar i = 0,\\n\\t\\tlen = elems.length,\\n\\t\\tbulk = key == null;\\n\\n\\t// Sets many values\\n\\tif ( jQuery.type( key ) === \"object\" ) {\\n\\t\\tchainable = true;\\n\\t\\tfor ( i in key ) {\\n\\t\\t\\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\\n\\t\\t}\\n\\n\\t// Sets one value\\n\\t} else if ( value !== undefined ) {\\n\\t\\tchainable = true;\\n\\n\\t\\tif ( !jQuery.isFunction( value ) ) {\\n\\t\\t\\traw = true;\\n\\t\\t}\\n\\n\\t\\tif ( bulk ) {\\n\\n\\t\\t\\t// Bulk operations run against the entire set\\n\\t\\t\\tif ( raw ) {\\n\\t\\t\\t\\tfn.call( elems, value );\\n\\t\\t\\t\\tfn = null;\\n\\n\\t\\t\\t// ...except when executing function values\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbulk = fn;\\n\\t\\t\\t\\tfn = function( elem, key, value ) {\\n\\t\\t\\t\\t\\treturn bulk.call( jQuery( elem ), value );\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\tfn(\\n\\t\\t\\t\\t\\telems[ i ], key, raw ?\\n\\t\\t\\t\\t\\tvalue :\\n\\t\\t\\t\\t\\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( chainable ) {\\n\\t\\treturn elems;\\n\\t}\\n\\n\\t// Gets\\n\\tif ( bulk ) {\\n\\t\\treturn fn.call( elems );\\n\\t}\\n\\n\\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\\n};\\nvar acceptData = function( owner ) {\\n\\n\\t// Accepts only:\\n\\t//  - Node\\n\\t//    - Node.ELEMENT_NODE\\n\\t//    - Node.DOCUMENT_NODE\\n\\t//  - Object\\n\\t//    - Any\\n\\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\\n};\\n\\n\\n\\n\\nfunction Data() {\\n\\tthis.expando = jQuery.expando + Data.uid++;\\n}\\n\\nData.uid = 1;\\n\\nData.prototype = {\\n\\n\\tcache: function( owner ) {\\n\\n\\t\\t// Check if the owner object already has a cache\\n\\t\\tvar value = owner[ this.expando ];\\n\\n\\t\\t// If not, create one\\n\\t\\tif ( !value ) {\\n\\t\\t\\tvalue = {};\\n\\n\\t\\t\\t// We can accept data for non-element nodes in modern browsers,\\n\\t\\t\\t// but we should not, see #8335.\\n\\t\\t\\t// Always return an empty object.\\n\\t\\t\\tif ( acceptData( owner ) ) {\\n\\n\\t\\t\\t\\t// If it is a node unlikely to be stringify-ed or looped over\\n\\t\\t\\t\\t// use plain assignment\\n\\t\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\t\\towner[ this.expando ] = value;\\n\\n\\t\\t\\t\\t// Otherwise secure it in a non-enumerable property\\n\\t\\t\\t\\t// configurable must be true to allow the property to be\\n\\t\\t\\t\\t// deleted when data is removed\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty( owner, this.expando, {\\n\\t\\t\\t\\t\\t\\tvalue: value,\\n\\t\\t\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t},\\n\\tset: function( owner, data, value ) {\\n\\t\\tvar prop,\\n\\t\\t\\tcache = this.cache( owner );\\n\\n\\t\\t// Handle: [ owner, key, value ] args\\n\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\tif ( typeof data === \"string\" ) {\\n\\t\\t\\tcache[ jQuery.camelCase( data ) ] = value;\\n\\n\\t\\t// Handle: [ owner, { properties } ] args\\n\\t\\t} else {\\n\\n\\t\\t\\t// Copy the properties one-by-one to the cache object\\n\\t\\t\\tfor ( prop in data ) {\\n\\t\\t\\t\\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cache;\\n\\t},\\n\\tget: function( owner, key ) {\\n\\t\\treturn key === undefined ?\\n\\t\\t\\tthis.cache( owner ) :\\n\\n\\t\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\t\\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\\n\\t},\\n\\taccess: function( owner, key, value ) {\\n\\n\\t\\t// In cases where either:\\n\\t\\t//\\n\\t\\t//   1. No key was specified\\n\\t\\t//   2. A string key was specified, but no value provided\\n\\t\\t//\\n\\t\\t// Take the \"read\" path and allow the get method to determine\\n\\t\\t// which value to return, respectively either:\\n\\t\\t//\\n\\t\\t//   1. The entire cache object\\n\\t\\t//   2. The data stored at the key\\n\\t\\t//\\n\\t\\tif ( key === undefined ||\\n\\t\\t\\t\\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\\n\\n\\t\\t\\treturn this.get( owner, key );\\n\\t\\t}\\n\\n\\t\\t// When the key is not a string, or both a key and value\\n\\t\\t// are specified, set or extend (existing objects) with either:\\n\\t\\t//\\n\\t\\t//   1. An object of properties\\n\\t\\t//   2. A key and value\\n\\t\\t//\\n\\t\\tthis.set( owner, key, value );\\n\\n\\t\\t// Since the \"set\" path can have two possible entry points\\n\\t\\t// return the expected data based on which path was taken[*]\\n\\t\\treturn value !== undefined ? value : key;\\n\\t},\\n\\tremove: function( owner, key ) {\\n\\t\\tvar i,\\n\\t\\t\\tcache = owner[ this.expando ];\\n\\n\\t\\tif ( cache === undefined ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key !== undefined ) {\\n\\n\\t\\t\\t// Support array or space separated string of keys\\n\\t\\t\\tif ( Array.isArray( key ) ) {\\n\\n\\t\\t\\t\\t// If key is an array of keys...\\n\\t\\t\\t\\t// We always set camelCase keys, so remove that.\\n\\t\\t\\t\\tkey = key.map( jQuery.camelCase );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tkey = jQuery.camelCase( key );\\n\\n\\t\\t\\t\\t// If a key with the spaces exists, use it.\\n\\t\\t\\t\\t// Otherwise, create an array by matching non-whitespace\\n\\t\\t\\t\\tkey = key in cache ?\\n\\t\\t\\t\\t\\t[ key ] :\\n\\t\\t\\t\\t\\t( key.match( rnothtmlwhite ) || [] );\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = key.length;\\n\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tdelete cache[ key[ i ] ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove the expando if there\\'s no more data\\n\\t\\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\\n\\n\\t\\t\\t// Support: Chrome <=35 - 45\\n\\t\\t\\t// Webkit & Blink performance suffers when deleting properties\\n\\t\\t\\t// from DOM nodes, so set to undefined instead\\n\\t\\t\\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\\n\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\towner[ this.expando ] = undefined;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete owner[ this.expando ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\thasData: function( owner ) {\\n\\t\\tvar cache = owner[ this.expando ];\\n\\t\\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\\n\\t}\\n};\\nvar dataPriv = new Data();\\n\\nvar dataUser = new Data();\\n\\n\\n\\n//\\tImplementation Summary\\n//\\n//\\t1. Enforce API surface and semantic compatibility with 1.9.x branch\\n//\\t2. Improve the module\\'s maintainability by reducing the storage\\n//\\t\\tpaths to a single mechanism.\\n//\\t3. Use the same single mechanism to support \"private\" and \"user\" data.\\n//\\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\\n//\\t5. Avoid exposing implementation details on user objects (eg. expando properties)\\n//\\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\\n\\nvar rbrace = /^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,\\n\\trmultiDash = /[A-Z]/g;\\n\\nfunction getData( data ) {\\n\\tif ( data === \"true\" ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif ( data === \"false\" ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif ( data === \"null\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Only convert to a number if it doesn\\'t change the string\\n\\tif ( data === +data + \"\" ) {\\n\\t\\treturn +data;\\n\\t}\\n\\n\\tif ( rbrace.test( data ) ) {\\n\\t\\treturn JSON.parse( data );\\n\\t}\\n\\n\\treturn data;\\n}\\n\\nfunction dataAttr( elem, key, data ) {\\n\\tvar name;\\n\\n\\t// If nothing was found internally, try to fetch any\\n\\t// data from the HTML5 data-* attribute\\n\\tif ( data === undefined && elem.nodeType === 1 ) {\\n\\t\\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\\n\\t\\tdata = elem.getAttribute( name );\\n\\n\\t\\tif ( typeof data === \"string\" ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = getData( data );\\n\\t\\t\\t} catch ( e ) {}\\n\\n\\t\\t\\t// Make sure we set the data so it isn\\'t changed later\\n\\t\\t\\tdataUser.set( elem, key, data );\\n\\t\\t} else {\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\t}\\n\\treturn data;\\n}\\n\\njQuery.extend( {\\n\\thasData: function( elem ) {\\n\\t\\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\\n\\t},\\n\\n\\tdata: function( elem, name, data ) {\\n\\t\\treturn dataUser.access( elem, name, data );\\n\\t},\\n\\n\\tremoveData: function( elem, name ) {\\n\\t\\tdataUser.remove( elem, name );\\n\\t},\\n\\n\\t// TODO: Now that all calls to _data and _removeData have been replaced\\n\\t// with direct calls to dataPriv methods, these can be deprecated.\\n\\t_data: function( elem, name, data ) {\\n\\t\\treturn dataPriv.access( elem, name, data );\\n\\t},\\n\\n\\t_removeData: function( elem, name ) {\\n\\t\\tdataPriv.remove( elem, name );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdata: function( key, value ) {\\n\\t\\tvar i, name, data,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tattrs = elem && elem.attributes;\\n\\n\\t\\t// Gets all values\\n\\t\\tif ( key === undefined ) {\\n\\t\\t\\tif ( this.length ) {\\n\\t\\t\\t\\tdata = dataUser.get( elem );\\n\\n\\t\\t\\t\\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\\n\\t\\t\\t\\t\\ti = attrs.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t\\t\\t\\t// The attrs elements can be null (#14894)\\n\\t\\t\\t\\t\\t\\tif ( attrs[ i ] ) {\\n\\t\\t\\t\\t\\t\\t\\tname = attrs[ i ].name;\\n\\t\\t\\t\\t\\t\\t\\tif ( name.indexOf( \"data-\" ) === 0 ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tname = jQuery.camelCase( name.slice( 5 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tdataAttr( elem, name, data[ name ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdataPriv.set( elem, \"hasDataAttrs\", true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\t\\t}\\n\\n\\t\\t// Sets multiple values\\n\\t\\tif ( typeof key === \"object\" ) {\\n\\t\\t\\treturn this.each( function() {\\n\\t\\t\\t\\tdataUser.set( this, key );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar data;\\n\\n\\t\\t\\t// The calling jQuery object (element matches) is not empty\\n\\t\\t\\t// (and therefore has an element appears at this[ 0 ]) and the\\n\\t\\t\\t// `value` parameter was not undefined. An empty jQuery object\\n\\t\\t\\t// will result in `undefined` for elem = this[ 0 ] which will\\n\\t\\t\\t// throw an exception if an attempt to read a data cache is made.\\n\\t\\t\\tif ( elem && value === undefined ) {\\n\\n\\t\\t\\t\\t// Attempt to get data from the cache\\n\\t\\t\\t\\t// The key will always be camelCased in Data\\n\\t\\t\\t\\tdata = dataUser.get( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Attempt to \"discover\" the data in\\n\\t\\t\\t\\t// HTML5 custom data-* attrs\\n\\t\\t\\t\\tdata = dataAttr( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// We tried really hard, but the data doesn\\'t exist.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the data...\\n\\t\\t\\tthis.each( function() {\\n\\n\\t\\t\\t\\t// We always store the camelCased key\\n\\t\\t\\t\\tdataUser.set( this, key, value );\\n\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length > 1, null, true );\\n\\t},\\n\\n\\tremoveData: function( key ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdataUser.remove( this, key );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\njQuery.extend( {\\n\\tqueue: function( elem, type, data ) {\\n\\t\\tvar queue;\\n\\n\\t\\tif ( elem ) {\\n\\t\\t\\ttype = ( type || \"fx\" ) + \"queue\";\\n\\t\\t\\tqueue = dataPriv.get( elem, type );\\n\\n\\t\\t\\t// Speed up dequeue by getting out quickly if this is just a lookup\\n\\t\\t\\tif ( data ) {\\n\\t\\t\\t\\tif ( !queue || Array.isArray( data ) ) {\\n\\t\\t\\t\\t\\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tqueue.push( data );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn queue || [];\\n\\t\\t}\\n\\t},\\n\\n\\tdequeue: function( elem, type ) {\\n\\t\\ttype = type || \"fx\";\\n\\n\\t\\tvar queue = jQuery.queue( elem, type ),\\n\\t\\t\\tstartLength = queue.length,\\n\\t\\t\\tfn = queue.shift(),\\n\\t\\t\\thooks = jQuery._queueHooks( elem, type ),\\n\\t\\t\\tnext = function() {\\n\\t\\t\\t\\tjQuery.dequeue( elem, type );\\n\\t\\t\\t};\\n\\n\\t\\t// If the fx queue is dequeued, always remove the progress sentinel\\n\\t\\tif ( fn === \"inprogress\" ) {\\n\\t\\t\\tfn = queue.shift();\\n\\t\\t\\tstartLength--;\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\n\\t\\t\\t// Add a progress sentinel to prevent the fx queue from being\\n\\t\\t\\t// automatically dequeued\\n\\t\\t\\tif ( type === \"fx\" ) {\\n\\t\\t\\t\\tqueue.unshift( \"inprogress\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Clear up the last queue stop function\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tfn.call( elem, next, hooks );\\n\\t\\t}\\n\\n\\t\\tif ( !startLength && hooks ) {\\n\\t\\t\\thooks.empty.fire();\\n\\t\\t}\\n\\t},\\n\\n\\t// Not public - generate a queueHooks object, or return the current one\\n\\t_queueHooks: function( elem, type ) {\\n\\t\\tvar key = type + \"queueHooks\";\\n\\t\\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\\n\\t\\t\\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\\n\\t\\t\\t\\tdataPriv.remove( elem, [ type + \"queue\", key ] );\\n\\t\\t\\t} )\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tqueue: function( type, data ) {\\n\\t\\tvar setter = 2;\\n\\n\\t\\tif ( typeof type !== \"string\" ) {\\n\\t\\t\\tdata = type;\\n\\t\\t\\ttype = \"fx\";\\n\\t\\t\\tsetter--;\\n\\t\\t}\\n\\n\\t\\tif ( arguments.length < setter ) {\\n\\t\\t\\treturn jQuery.queue( this[ 0 ], type );\\n\\t\\t}\\n\\n\\t\\treturn data === undefined ?\\n\\t\\t\\tthis :\\n\\t\\t\\tthis.each( function() {\\n\\t\\t\\t\\tvar queue = jQuery.queue( this, type, data );\\n\\n\\t\\t\\t\\t// Ensure a hooks for this queue\\n\\t\\t\\t\\tjQuery._queueHooks( this, type );\\n\\n\\t\\t\\t\\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\\n\\t\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t},\\n\\tdequeue: function( type ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t} );\\n\\t},\\n\\tclearQueue: function( type ) {\\n\\t\\treturn this.queue( type || \"fx\", [] );\\n\\t},\\n\\n\\t// Get a promise resolved when queues of a certain type\\n\\t// are emptied (fx is the type by default)\\n\\tpromise: function( type, obj ) {\\n\\t\\tvar tmp,\\n\\t\\t\\tcount = 1,\\n\\t\\t\\tdefer = jQuery.Deferred(),\\n\\t\\t\\telements = this,\\n\\t\\t\\ti = this.length,\\n\\t\\t\\tresolve = function() {\\n\\t\\t\\t\\tif ( !( --count ) ) {\\n\\t\\t\\t\\t\\tdefer.resolveWith( elements, [ elements ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\tif ( typeof type !== \"string\" ) {\\n\\t\\t\\tobj = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\ttype = type || \"fx\";\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\\n\\t\\t\\tif ( tmp && tmp.empty ) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\ttmp.empty.add( resolve );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresolve();\\n\\t\\treturn defer.promise( obj );\\n\\t}\\n} );\\nvar pnum = ( /[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/ ).source;\\n\\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\\n\\n\\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\\n\\nvar isHiddenWithinTree = function( elem, el ) {\\n\\n\\t\\t// isHiddenWithinTree might be called from jQuery#filter function;\\n\\t\\t// in that case, element will be second argument\\n\\t\\telem = el || elem;\\n\\n\\t\\t// Inline style trumps all\\n\\t\\treturn elem.style.display === \"none\" ||\\n\\t\\t\\telem.style.display === \"\" &&\\n\\n\\t\\t\\t// Otherwise, check computed style\\n\\t\\t\\t// Support: Firefox <=43 - 45\\n\\t\\t\\t// Disconnected elements can have computed display: none, so first confirm that elem is\\n\\t\\t\\t// in the document.\\n\\t\\t\\tjQuery.contains( elem.ownerDocument, elem ) &&\\n\\n\\t\\t\\tjQuery.css( elem, \"display\" ) === \"none\";\\n\\t};\\n\\nvar swap = function( elem, options, callback, args ) {\\n\\tvar ret, name,\\n\\t\\told = {};\\n\\n\\t// Remember the old values, and insert the new ones\\n\\tfor ( name in options ) {\\n\\t\\told[ name ] = elem.style[ name ];\\n\\t\\telem.style[ name ] = options[ name ];\\n\\t}\\n\\n\\tret = callback.apply( elem, args || [] );\\n\\n\\t// Revert the old values\\n\\tfor ( name in options ) {\\n\\t\\telem.style[ name ] = old[ name ];\\n\\t}\\n\\n\\treturn ret;\\n};\\n\\n\\n\\n\\nfunction adjustCSS( elem, prop, valueParts, tween ) {\\n\\tvar adjusted,\\n\\t\\tscale = 1,\\n\\t\\tmaxIterations = 20,\\n\\t\\tcurrentValue = tween ?\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn tween.cur();\\n\\t\\t\\t} :\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn jQuery.css( elem, prop, \"\" );\\n\\t\\t\\t},\\n\\t\\tinitial = currentValue(),\\n\\t\\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\\n\\n\\t\\t// Starting value computation is required for potential unit mismatches\\n\\t\\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\\n\\t\\t\\trcssNum.exec( jQuery.css( elem, prop ) );\\n\\n\\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\\n\\n\\t\\t// Trust units reported by jQuery.css\\n\\t\\tunit = unit || initialInUnit[ 3 ];\\n\\n\\t\\t// Make sure we update the tween properties later on\\n\\t\\tvalueParts = valueParts || [];\\n\\n\\t\\t// Iteratively approximate from a nonzero starting point\\n\\t\\tinitialInUnit = +initial || 1;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\t// If previous iteration zeroed out, double until we get *something*.\\n\\t\\t\\t// Use string for doubling so we don\\'t accidentally see scale as unchanged below\\n\\t\\t\\tscale = scale || \".5\";\\n\\n\\t\\t\\t// Adjust and apply\\n\\t\\t\\tinitialInUnit = initialInUnit / scale;\\n\\t\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\n\\t\\t// Update scale, tolerating zero or NaN from tween.cur()\\n\\t\\t// Break the loop if scale is unchanged or perfect, or if we\\'ve just had enough.\\n\\t\\t} while (\\n\\t\\t\\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\\n\\t\\t);\\n\\t}\\n\\n\\tif ( valueParts ) {\\n\\t\\tinitialInUnit = +initialInUnit || +initial || 0;\\n\\n\\t\\t// Apply relative offset (+=/-=) if specified\\n\\t\\tadjusted = valueParts[ 1 ] ?\\n\\t\\t\\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\\n\\t\\t\\t+valueParts[ 2 ];\\n\\t\\tif ( tween ) {\\n\\t\\t\\ttween.unit = unit;\\n\\t\\t\\ttween.start = initialInUnit;\\n\\t\\t\\ttween.end = adjusted;\\n\\t\\t}\\n\\t}\\n\\treturn adjusted;\\n}\\n\\n\\nvar defaultDisplayMap = {};\\n\\nfunction getDefaultDisplay( elem ) {\\n\\tvar temp,\\n\\t\\tdoc = elem.ownerDocument,\\n\\t\\tnodeName = elem.nodeName,\\n\\t\\tdisplay = defaultDisplayMap[ nodeName ];\\n\\n\\tif ( display ) {\\n\\t\\treturn display;\\n\\t}\\n\\n\\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\\n\\tdisplay = jQuery.css( temp, \"display\" );\\n\\n\\ttemp.parentNode.removeChild( temp );\\n\\n\\tif ( display === \"none\" ) {\\n\\t\\tdisplay = \"block\";\\n\\t}\\n\\tdefaultDisplayMap[ nodeName ] = display;\\n\\n\\treturn display;\\n}\\n\\nfunction showHide( elements, show ) {\\n\\tvar display, elem,\\n\\t\\tvalues = [],\\n\\t\\tindex = 0,\\n\\t\\tlength = elements.length;\\n\\n\\t// Determine new display value for elements that need to change\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\telem = elements[ index ];\\n\\t\\tif ( !elem.style ) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tdisplay = elem.style.display;\\n\\t\\tif ( show ) {\\n\\n\\t\\t\\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\\n\\t\\t\\t// check is required in this first loop unless we have a nonempty display value (either\\n\\t\\t\\t// inline or about-to-be-restored)\\n\\t\\t\\tif ( display === \"none\" ) {\\n\\t\\t\\t\\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\\n\\t\\t\\t\\tif ( !values[ index ] ) {\\n\\t\\t\\t\\t\\telem.style.display = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\\n\\t\\t\\t\\tvalues[ index ] = getDefaultDisplay( elem );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif ( display !== \"none\" ) {\\n\\t\\t\\t\\tvalues[ index ] = \"none\";\\n\\n\\t\\t\\t\\t// Remember what we\\'re overwriting\\n\\t\\t\\t\\tdataPriv.set( elem, \"display\", display );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Set the display of the elements in a second loop to avoid constant reflow\\n\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\tif ( values[ index ] != null ) {\\n\\t\\t\\telements[ index ].style.display = values[ index ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn elements;\\n}\\n\\njQuery.fn.extend( {\\n\\tshow: function() {\\n\\t\\treturn showHide( this, true );\\n\\t},\\n\\thide: function() {\\n\\t\\treturn showHide( this );\\n\\t},\\n\\ttoggle: function( state ) {\\n\\t\\tif ( typeof state === \"boolean\" ) {\\n\\t\\t\\treturn state ? this.show() : this.hide();\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tif ( isHiddenWithinTree( this ) ) {\\n\\t\\t\\t\\tjQuery( this ).show();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tjQuery( this ).hide();\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\\n\\nvar rtagName = ( /<([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]+)/i );\\n\\nvar rscriptType = ( /^$|\\\\/(?:java|ecma)script/i );\\n\\n\\n\\n// We have to close these tags to support XHTML (#13200)\\nvar wrapMap = {\\n\\n\\t// Support: IE <=9 only\\n\\toption: [ 1, \"<select multiple=\\'multiple\\'>\", \"</select>\" ],\\n\\n\\t// XHTML parsers do not magically insert elements in the\\n\\t// same way that tag soup parsers do. So we cannot shorten\\n\\t// this by omitting <tbody> or other required elements.\\n\\tthead: [ 1, \"<table>\", \"</table>\" ],\\n\\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\\n\\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\\n\\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\\n\\n\\t_default: [ 0, \"\", \"\" ]\\n};\\n\\n// Support: IE <=9 only\\nwrapMap.optgroup = wrapMap.option;\\n\\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\\nwrapMap.th = wrapMap.td;\\n\\n\\nfunction getAll( context, tag ) {\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\\n\\tvar ret;\\n\\n\\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\\n\\t\\tret = context.getElementsByTagName( tag || \"*\" );\\n\\n\\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\\n\\t\\tret = context.querySelectorAll( tag || \"*\" );\\n\\n\\t} else {\\n\\t\\tret = [];\\n\\t}\\n\\n\\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\\n\\t\\treturn jQuery.merge( [ context ], ret );\\n\\t}\\n\\n\\treturn ret;\\n}\\n\\n\\n// Mark scripts as having already been evaluated\\nfunction setGlobalEval( elems, refElements ) {\\n\\tvar i = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\tdataPriv.set(\\n\\t\\t\\telems[ i ],\\n\\t\\t\\t\"globalEval\",\\n\\t\\t\\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\\n\\t\\t);\\n\\t}\\n}\\n\\n\\nvar rhtml = /<|&#?\\\\w+;/;\\n\\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\\n\\tvar elem, tmp, tag, wrap, contains, j,\\n\\t\\tfragment = context.createDocumentFragment(),\\n\\t\\tnodes = [],\\n\\t\\ti = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\telem = elems[ i ];\\n\\n\\t\\tif ( elem || elem === 0 ) {\\n\\n\\t\\t\\t// Add nodes directly\\n\\t\\t\\tif ( jQuery.type( elem ) === \"object\" ) {\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\\n\\n\\t\\t\\t// Convert non-html into a text node\\n\\t\\t\\t} else if ( !rhtml.test( elem ) ) {\\n\\t\\t\\t\\tnodes.push( context.createTextNode( elem ) );\\n\\n\\t\\t\\t// Convert html into DOM nodes\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\\n\\n\\t\\t\\t\\t// Deserialize a standard representation\\n\\t\\t\\t\\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\\n\\t\\t\\t\\twrap = wrapMap[ tag ] || wrapMap._default;\\n\\t\\t\\t\\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\\n\\n\\t\\t\\t\\t// Descend through wrappers to the right content\\n\\t\\t\\t\\tj = wrap[ 0 ];\\n\\t\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\t\\ttmp = tmp.lastChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, tmp.childNodes );\\n\\n\\t\\t\\t\\t// Remember the top-level container\\n\\t\\t\\t\\ttmp = fragment.firstChild;\\n\\n\\t\\t\\t\\t// Ensure the created nodes are orphaned (#12392)\\n\\t\\t\\t\\ttmp.textContent = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Remove wrapper from fragment\\n\\tfragment.textContent = \"\";\\n\\n\\ti = 0;\\n\\twhile ( ( elem = nodes[ i++ ] ) ) {\\n\\n\\t\\t// Skip elements already in the context collection (trac-4087)\\n\\t\\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\\n\\t\\t\\tif ( ignored ) {\\n\\t\\t\\t\\tignored.push( elem );\\n\\t\\t\\t}\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tcontains = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Append to fragment\\n\\t\\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tif ( contains ) {\\n\\t\\t\\tsetGlobalEval( tmp );\\n\\t\\t}\\n\\n\\t\\t// Capture executables\\n\\t\\tif ( scripts ) {\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( elem = tmp[ j++ ] ) ) {\\n\\t\\t\\t\\tif ( rscriptType.test( elem.type || \"\" ) ) {\\n\\t\\t\\t\\t\\tscripts.push( elem );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn fragment;\\n}\\n\\n\\n( function() {\\n\\tvar fragment = document.createDocumentFragment(),\\n\\t\\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\\n\\t\\tinput = document.createElement( \"input\" );\\n\\n\\t// Support: Android 4.0 - 4.3 only\\n\\t// Check state lost if the name is set (#11217)\\n\\t// Support: Windows Web Apps (WWA)\\n\\t// `name` and `type` must use .setAttribute for WWA (#14901)\\n\\tinput.setAttribute( \"type\", \"radio\" );\\n\\tinput.setAttribute( \"checked\", \"checked\" );\\n\\tinput.setAttribute( \"name\", \"t\" );\\n\\n\\tdiv.appendChild( input );\\n\\n\\t// Support: Android <=4.1 only\\n\\t// Older WebKit doesn\\'t clone checked state correctly in fragments\\n\\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\\n\\n\\t// Support: IE <=11 only\\n\\t// Make sure textarea (and checkbox) defaultValue is properly cloned\\n\\tdiv.innerHTML = \"<textarea>x</textarea>\";\\n\\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\\n} )();\\nvar documentElement = document.documentElement;\\n\\n\\n\\nvar\\n\\trkeyEvent = /^key/,\\n\\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\\n\\trtypenamespace = /^([^.]*)(?:\\\\.(.+)|)/;\\n\\nfunction returnTrue() {\\n\\treturn true;\\n}\\n\\nfunction returnFalse() {\\n\\treturn false;\\n}\\n\\n// Support: IE <=9 only\\n// See #13393 for more info\\nfunction safeActiveElement() {\\n\\ttry {\\n\\t\\treturn document.activeElement;\\n\\t} catch ( err ) { }\\n}\\n\\nfunction on( elem, types, selector, data, fn, one ) {\\n\\tvar origFn, type;\\n\\n\\t// Types can be a map of types/handlers\\n\\tif ( typeof types === \"object\" ) {\\n\\n\\t\\t// ( types-Object, selector, data )\\n\\t\\tif ( typeof selector !== \"string\" ) {\\n\\n\\t\\t\\t// ( types-Object, data )\\n\\t\\t\\tdata = data || selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tfor ( type in types ) {\\n\\t\\t\\ton( elem, type, selector, data, types[ type ], one );\\n\\t\\t}\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( data == null && fn == null ) {\\n\\n\\t\\t// ( types, fn )\\n\\t\\tfn = selector;\\n\\t\\tdata = selector = undefined;\\n\\t} else if ( fn == null ) {\\n\\t\\tif ( typeof selector === \"string\" ) {\\n\\n\\t\\t\\t// ( types, selector, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t} else {\\n\\n\\t\\t\\t// ( types, data, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t}\\n\\tif ( fn === false ) {\\n\\t\\tfn = returnFalse;\\n\\t} else if ( !fn ) {\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( one === 1 ) {\\n\\t\\torigFn = fn;\\n\\t\\tfn = function( event ) {\\n\\n\\t\\t\\t// Can use an empty set, since event contains the info\\n\\t\\t\\tjQuery().off( event );\\n\\t\\t\\treturn origFn.apply( this, arguments );\\n\\t\\t};\\n\\n\\t\\t// Use same guid so caller can remove using origFn\\n\\t\\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\\n\\t}\\n\\treturn elem.each( function() {\\n\\t\\tjQuery.event.add( this, types, fn, data, selector );\\n\\t} );\\n}\\n\\n/*\\n * Helper functions for managing events -- not part of the public interface.\\n * Props to Dean Edwards\\' addEvent library for many of the ideas.\\n */\\njQuery.event = {\\n\\n\\tglobal: {},\\n\\n\\tadd: function( elem, types, handler, data, selector ) {\\n\\n\\t\\tvar handleObjIn, eventHandle, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.get( elem );\\n\\n\\t\\t// Don\\'t attach events to noData or text/comment nodes (but allow plain objects)\\n\\t\\tif ( !elemData ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Caller can pass in an object of custom data in lieu of the handler\\n\\t\\tif ( handler.handler ) {\\n\\t\\t\\thandleObjIn = handler;\\n\\t\\t\\thandler = handleObjIn.handler;\\n\\t\\t\\tselector = handleObjIn.selector;\\n\\t\\t}\\n\\n\\t\\t// Ensure that invalid selectors throw exceptions at attach time\\n\\t\\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\\n\\t\\tif ( selector ) {\\n\\t\\t\\tjQuery.find.matchesSelector( documentElement, selector );\\n\\t\\t}\\n\\n\\t\\t// Make sure that the handler has a unique ID, used to find/remove it later\\n\\t\\tif ( !handler.guid ) {\\n\\t\\t\\thandler.guid = jQuery.guid++;\\n\\t\\t}\\n\\n\\t\\t// Init the element\\'s event structure and main handler, if this is the first\\n\\t\\tif ( !( events = elemData.events ) ) {\\n\\t\\t\\tevents = elemData.events = {};\\n\\t\\t}\\n\\t\\tif ( !( eventHandle = elemData.handle ) ) {\\n\\t\\t\\teventHandle = elemData.handle = function( e ) {\\n\\n\\t\\t\\t\\t// Discard the second event of a jQuery.event.trigger() and\\n\\t\\t\\t\\t// when an event is called after a page has unloaded\\n\\t\\t\\t\\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\\n\\t\\t\\t\\t\\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Handle multiple events separated by a space\\n\\t\\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\\n\\n\\t\\t\\t// There *must* be a type, no attaching namespace-only handlers\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If event changes its type, use the special event handlers for the changed type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// If selector defined, determine special event api type, otherwise given type\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\n\\t\\t\\t// Update special based on newly reset type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// handleObj is passed to all event handlers\\n\\t\\t\\thandleObj = jQuery.extend( {\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\torigType: origType,\\n\\t\\t\\t\\tdata: data,\\n\\t\\t\\t\\thandler: handler,\\n\\t\\t\\t\\tguid: handler.guid,\\n\\t\\t\\t\\tselector: selector,\\n\\t\\t\\t\\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\\n\\t\\t\\t\\tnamespace: namespaces.join( \".\" )\\n\\t\\t\\t}, handleObjIn );\\n\\n\\t\\t\\t// Init the event handler queue if we\\'re the first\\n\\t\\t\\tif ( !( handlers = events[ type ] ) ) {\\n\\t\\t\\t\\thandlers = events[ type ] = [];\\n\\t\\t\\t\\thandlers.delegateCount = 0;\\n\\n\\t\\t\\t\\t// Only use addEventListener if the special events handler returns false\\n\\t\\t\\t\\tif ( !special.setup ||\\n\\t\\t\\t\\t\\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\\n\\n\\t\\t\\t\\t\\tif ( elem.addEventListener ) {\\n\\t\\t\\t\\t\\t\\telem.addEventListener( type, eventHandle );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( special.add ) {\\n\\t\\t\\t\\tspecial.add.call( elem, handleObj );\\n\\n\\t\\t\\t\\tif ( !handleObj.handler.guid ) {\\n\\t\\t\\t\\t\\thandleObj.handler.guid = handler.guid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add to the element\\'s handler list, delegates in front\\n\\t\\t\\tif ( selector ) {\\n\\t\\t\\t\\thandlers.splice( handlers.delegateCount++, 0, handleObj );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thandlers.push( handleObj );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Keep track of which events have ever been used, for event optimization\\n\\t\\t\\tjQuery.event.global[ type ] = true;\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// Detach an event or set of events from an element\\n\\tremove: function( elem, types, handler, selector, mappedTypes ) {\\n\\n\\t\\tvar j, origCount, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\\n\\n\\t\\tif ( !elemData || !( events = elemData.events ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Once for each type.namespace in types; type may be omitted\\n\\t\\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\\n\\n\\t\\t\\t// Unbind all events (on this namespace, if provided) for the element\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\t\\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\t\\t\\thandlers = events[ type ] || [];\\n\\t\\t\\ttmp = tmp[ 2 ] &&\\n\\t\\t\\t\\tnew RegExp( \"(^|\\\\\\\\.)\" + namespaces.join( \"\\\\\\\\.(?:.*\\\\\\\\.|)\" ) + \"(\\\\\\\\.|$)\" );\\n\\n\\t\\t\\t// Remove matching events\\n\\t\\t\\torigCount = j = handlers.length;\\n\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\thandleObj = handlers[ j ];\\n\\n\\t\\t\\t\\tif ( ( mappedTypes || origType === handleObj.origType ) &&\\n\\t\\t\\t\\t\\t( !handler || handler.guid === handleObj.guid ) &&\\n\\t\\t\\t\\t\\t( !tmp || tmp.test( handleObj.namespace ) ) &&\\n\\t\\t\\t\\t\\t( !selector || selector === handleObj.selector ||\\n\\t\\t\\t\\t\\t\\tselector === \"**\" && handleObj.selector ) ) {\\n\\t\\t\\t\\t\\thandlers.splice( j, 1 );\\n\\n\\t\\t\\t\\t\\tif ( handleObj.selector ) {\\n\\t\\t\\t\\t\\t\\thandlers.delegateCount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( special.remove ) {\\n\\t\\t\\t\\t\\t\\tspecial.remove.call( elem, handleObj );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove generic event handler if we removed something and no more handlers exist\\n\\t\\t\\t// (avoids potential for endless recursion during removal of special event handlers)\\n\\t\\t\\tif ( origCount && !handlers.length ) {\\n\\t\\t\\t\\tif ( !special.teardown ||\\n\\t\\t\\t\\t\\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\\n\\n\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, elemData.handle );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete events[ type ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove data and the expando if it\\'s no longer used\\n\\t\\tif ( jQuery.isEmptyObject( events ) ) {\\n\\t\\t\\tdataPriv.remove( elem, \"handle events\" );\\n\\t\\t}\\n\\t},\\n\\n\\tdispatch: function( nativeEvent ) {\\n\\n\\t\\t// Make a writable jQuery.Event from the native event object\\n\\t\\tvar event = jQuery.event.fix( nativeEvent );\\n\\n\\t\\tvar i, j, ret, matched, handleObj, handlerQueue,\\n\\t\\t\\targs = new Array( arguments.length ),\\n\\t\\t\\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\\n\\t\\t\\tspecial = jQuery.event.special[ event.type ] || {};\\n\\n\\t\\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\\n\\t\\targs[ 0 ] = event;\\n\\n\\t\\tfor ( i = 1; i < arguments.length; i++ ) {\\n\\t\\t\\targs[ i ] = arguments[ i ];\\n\\t\\t}\\n\\n\\t\\tevent.delegateTarget = this;\\n\\n\\t\\t// Call the preDispatch hook for the mapped type, and let it bail if desired\\n\\t\\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine handlers\\n\\t\\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\\n\\n\\t\\t// Run delegates first; they may want to stop propagation beneath us\\n\\t\\ti = 0;\\n\\t\\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tevent.currentTarget = matched.elem;\\n\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\\n\\t\\t\\t\\t!event.isImmediatePropagationStopped() ) {\\n\\n\\t\\t\\t\\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\\n\\t\\t\\t\\t// a subset or equal to those in the bound event (both can have no namespace).\\n\\t\\t\\t\\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\\n\\n\\t\\t\\t\\t\\tevent.handleObj = handleObj;\\n\\t\\t\\t\\t\\tevent.data = handleObj.data;\\n\\n\\t\\t\\t\\t\\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\\n\\t\\t\\t\\t\\t\\thandleObj.handler ).apply( matched.elem, args );\\n\\n\\t\\t\\t\\t\\tif ( ret !== undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ( event.result = ret ) === false ) {\\n\\t\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\t\\tevent.stopPropagation();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Call the postDispatch hook for the mapped type\\n\\t\\tif ( special.postDispatch ) {\\n\\t\\t\\tspecial.postDispatch.call( this, event );\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\thandlers: function( event, handlers ) {\\n\\t\\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\\n\\t\\t\\thandlerQueue = [],\\n\\t\\t\\tdelegateCount = handlers.delegateCount,\\n\\t\\t\\tcur = event.target;\\n\\n\\t\\t// Find delegate handlers\\n\\t\\tif ( delegateCount &&\\n\\n\\t\\t\\t// Support: IE <=9\\n\\t\\t\\t// Black-hole SVG <use> instance trees (trac-13180)\\n\\t\\t\\tcur.nodeType &&\\n\\n\\t\\t\\t// Support: Firefox <=42\\n\\t\\t\\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\\n\\t\\t\\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\\n\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\\n\\t\\t\\t!( event.type === \"click\" && event.button >= 1 ) ) {\\n\\n\\t\\t\\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\\n\\n\\t\\t\\t\\t// Don\\'t check non-elements (#13208)\\n\\t\\t\\t\\t// Don\\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\\n\\t\\t\\t\\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\\n\\t\\t\\t\\t\\tmatchedHandlers = [];\\n\\t\\t\\t\\t\\tmatchedSelectors = {};\\n\\t\\t\\t\\t\\tfor ( i = 0; i < delegateCount; i++ ) {\\n\\t\\t\\t\\t\\t\\thandleObj = handlers[ i ];\\n\\n\\t\\t\\t\\t\\t\\t// Don\\'t conflict with Object.prototype properties (#13203)\\n\\t\\t\\t\\t\\t\\tsel = handleObj.selector + \" \";\\n\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] === undefined ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedSelectors[ sel ] = handleObj.needsContext ?\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery( sel, this ).index( cur ) > -1 :\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.find( sel, this, null, [ cur ] ).length;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedHandlers.push( handleObj );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( matchedHandlers.length ) {\\n\\t\\t\\t\\t\\t\\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Add the remaining (directly-bound) handlers\\n\\t\\tcur = this;\\n\\t\\tif ( delegateCount < handlers.length ) {\\n\\t\\t\\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\\n\\t\\t}\\n\\n\\t\\treturn handlerQueue;\\n\\t},\\n\\n\\taddProp: function( name, hook ) {\\n\\t\\tObject.defineProperty( jQuery.Event.prototype, name, {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tconfigurable: true,\\n\\n\\t\\t\\tget: jQuery.isFunction( hook ) ?\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn hook( this.originalEvent );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} :\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn this.originalEvent[ name ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\tset: function( value ) {\\n\\t\\t\\t\\tObject.defineProperty( this, name, {\\n\\t\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\t\\tconfigurable: true,\\n\\t\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\t\\tvalue: value\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tfix: function( originalEvent ) {\\n\\t\\treturn originalEvent[ jQuery.expando ] ?\\n\\t\\t\\toriginalEvent :\\n\\t\\t\\tnew jQuery.Event( originalEvent );\\n\\t},\\n\\n\\tspecial: {\\n\\t\\tload: {\\n\\n\\t\\t\\t// Prevent triggered image.load events from bubbling to window.load\\n\\t\\t\\tnoBubble: true\\n\\t\\t},\\n\\t\\tfocus: {\\n\\n\\t\\t\\t// Fire native event if possible so blur/focus sequence is correct\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this !== safeActiveElement() && this.focus ) {\\n\\t\\t\\t\\t\\tthis.focus();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \"focusin\"\\n\\t\\t},\\n\\t\\tblur: {\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this === safeActiveElement() && this.blur ) {\\n\\t\\t\\t\\t\\tthis.blur();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \"focusout\"\\n\\t\\t},\\n\\t\\tclick: {\\n\\n\\t\\t\\t// For checkbox, fire native event so checked state will be right\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\\n\\t\\t\\t\\t\\tthis.click();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\t// For cross-browser consistency, don\\'t fire native .click() on links\\n\\t\\t\\t_default: function( event ) {\\n\\t\\t\\t\\treturn nodeName( event.target, \"a\" );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tbeforeunload: {\\n\\t\\t\\tpostDispatch: function( event ) {\\n\\n\\t\\t\\t\\t// Support: Firefox 20+\\n\\t\\t\\t\\t// Firefox doesn\\'t alert if the returnValue field is not set.\\n\\t\\t\\t\\tif ( event.result !== undefined && event.originalEvent ) {\\n\\t\\t\\t\\t\\tevent.originalEvent.returnValue = event.result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.removeEvent = function( elem, type, handle ) {\\n\\n\\t// This \"if\" is needed for plain objects\\n\\tif ( elem.removeEventListener ) {\\n\\t\\telem.removeEventListener( type, handle );\\n\\t}\\n};\\n\\njQuery.Event = function( src, props ) {\\n\\n\\t// Allow instantiation without the \\'new\\' keyword\\n\\tif ( !( this instanceof jQuery.Event ) ) {\\n\\t\\treturn new jQuery.Event( src, props );\\n\\t}\\n\\n\\t// Event object\\n\\tif ( src && src.type ) {\\n\\t\\tthis.originalEvent = src;\\n\\t\\tthis.type = src.type;\\n\\n\\t\\t// Events bubbling up the document may have been marked as prevented\\n\\t\\t// by a handler lower down the tree; reflect the correct value.\\n\\t\\tthis.isDefaultPrevented = src.defaultPrevented ||\\n\\t\\t\\t\\tsrc.defaultPrevented === undefined &&\\n\\n\\t\\t\\t\\t// Support: Android <=2.3 only\\n\\t\\t\\t\\tsrc.returnValue === false ?\\n\\t\\t\\treturnTrue :\\n\\t\\t\\treturnFalse;\\n\\n\\t\\t// Create target properties\\n\\t\\t// Support: Safari <=6 - 7 only\\n\\t\\t// Target should not be a text node (#504, #13143)\\n\\t\\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\\n\\t\\t\\tsrc.target.parentNode :\\n\\t\\t\\tsrc.target;\\n\\n\\t\\tthis.currentTarget = src.currentTarget;\\n\\t\\tthis.relatedTarget = src.relatedTarget;\\n\\n\\t// Event type\\n\\t} else {\\n\\t\\tthis.type = src;\\n\\t}\\n\\n\\t// Put explicitly provided properties onto the event object\\n\\tif ( props ) {\\n\\t\\tjQuery.extend( this, props );\\n\\t}\\n\\n\\t// Create a timestamp if incoming event doesn\\'t have one\\n\\tthis.timeStamp = src && src.timeStamp || jQuery.now();\\n\\n\\t// Mark it as fixed\\n\\tthis[ jQuery.expando ] = true;\\n};\\n\\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\\njQuery.Event.prototype = {\\n\\tconstructor: jQuery.Event,\\n\\tisDefaultPrevented: returnFalse,\\n\\tisPropagationStopped: returnFalse,\\n\\tisImmediatePropagationStopped: returnFalse,\\n\\tisSimulated: false,\\n\\n\\tpreventDefault: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isDefaultPrevented = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.preventDefault();\\n\\t\\t}\\n\\t},\\n\\tstopPropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isPropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopPropagation();\\n\\t\\t}\\n\\t},\\n\\tstopImmediatePropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isImmediatePropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopImmediatePropagation();\\n\\t\\t}\\n\\n\\t\\tthis.stopPropagation();\\n\\t}\\n};\\n\\n// Includes all common event props including KeyEvent and MouseEvent specific props\\njQuery.each( {\\n\\taltKey: true,\\n\\tbubbles: true,\\n\\tcancelable: true,\\n\\tchangedTouches: true,\\n\\tctrlKey: true,\\n\\tdetail: true,\\n\\teventPhase: true,\\n\\tmetaKey: true,\\n\\tpageX: true,\\n\\tpageY: true,\\n\\tshiftKey: true,\\n\\tview: true,\\n\\t\"char\": true,\\n\\tcharCode: true,\\n\\tkey: true,\\n\\tkeyCode: true,\\n\\tbutton: true,\\n\\tbuttons: true,\\n\\tclientX: true,\\n\\tclientY: true,\\n\\toffsetX: true,\\n\\toffsetY: true,\\n\\tpointerId: true,\\n\\tpointerType: true,\\n\\tscreenX: true,\\n\\tscreenY: true,\\n\\ttargetTouches: true,\\n\\ttoElement: true,\\n\\ttouches: true,\\n\\n\\twhich: function( event ) {\\n\\t\\tvar button = event.button;\\n\\n\\t\\t// Add which for key events\\n\\t\\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\\n\\t\\t\\treturn event.charCode != null ? event.charCode : event.keyCode;\\n\\t\\t}\\n\\n\\t\\t// Add which for click: 1 === left; 2 === middle; 3 === right\\n\\t\\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\\n\\t\\t\\tif ( button & 1 ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 2 ) {\\n\\t\\t\\t\\treturn 3;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 4 ) {\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn event.which;\\n\\t}\\n}, jQuery.event.addProp );\\n\\n// Create mouseenter/leave events using mouseover/out and event-time checks\\n// so that event delegation works in jQuery.\\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\\n//\\n// Support: Safari 7 only\\n// Safari sends mouseenter too often; see:\\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\\n// for the description of the bug (it existed in older Chrome versions as well).\\njQuery.each( {\\n\\tmouseenter: \"mouseover\",\\n\\tmouseleave: \"mouseout\",\\n\\tpointerenter: \"pointerover\",\\n\\tpointerleave: \"pointerout\"\\n}, function( orig, fix ) {\\n\\tjQuery.event.special[ orig ] = {\\n\\t\\tdelegateType: fix,\\n\\t\\tbindType: fix,\\n\\n\\t\\thandle: function( event ) {\\n\\t\\t\\tvar ret,\\n\\t\\t\\t\\ttarget = this,\\n\\t\\t\\t\\trelated = event.relatedTarget,\\n\\t\\t\\t\\thandleObj = event.handleObj;\\n\\n\\t\\t\\t// For mouseenter/leave call the handler if related is outside the target.\\n\\t\\t\\t// NB: No relatedTarget if the mouse left/entered the browser window\\n\\t\\t\\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\\n\\t\\t\\t\\tevent.type = handleObj.origType;\\n\\t\\t\\t\\tret = handleObj.handler.apply( this, arguments );\\n\\t\\t\\t\\tevent.type = fix;\\n\\t\\t\\t}\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ton: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn );\\n\\t},\\n\\tone: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn, 1 );\\n\\t},\\n\\toff: function( types, selector, fn ) {\\n\\t\\tvar handleObj, type;\\n\\t\\tif ( types && types.preventDefault && types.handleObj ) {\\n\\n\\t\\t\\t// ( event )  dispatched jQuery.Event\\n\\t\\t\\thandleObj = types.handleObj;\\n\\t\\t\\tjQuery( types.delegateTarget ).off(\\n\\t\\t\\t\\thandleObj.namespace ?\\n\\t\\t\\t\\t\\thandleObj.origType + \".\" + handleObj.namespace :\\n\\t\\t\\t\\t\\thandleObj.origType,\\n\\t\\t\\t\\thandleObj.selector,\\n\\t\\t\\t\\thandleObj.handler\\n\\t\\t\\t);\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( typeof types === \"object\" ) {\\n\\n\\t\\t\\t// ( types-object [, selector] )\\n\\t\\t\\tfor ( type in types ) {\\n\\t\\t\\t\\tthis.off( type, selector, types[ type ] );\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( selector === false || typeof selector === \"function\" ) {\\n\\n\\t\\t\\t// ( types [, fn] )\\n\\t\\t\\tfn = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tif ( fn === false ) {\\n\\t\\t\\tfn = returnFalse;\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.remove( this, types, fn, selector );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\nvar\\n\\n\\t/* eslint-disable max-len */\\n\\n\\t// See https://github.com/eslint/eslint/issues/3229\\n\\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[^>]*)\\\\/>/gi,\\n\\n\\t/* eslint-enable */\\n\\n\\t// Support: IE <=10 - 11, Edge 12 - 13\\n\\t// In IE/Edge using regex groups here causes severe slowdowns.\\n\\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\\n\\trnoInnerhtml = /<script|<style|<link/i,\\n\\n\\t// checked=\"checked\" or checked\\n\\trchecked = /checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,\\n\\trscriptTypeMasked = /^true\\\\/(.*)/,\\n\\trcleanScript = /^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g;\\n\\n// Prefer a tbody over its parent table for containing new rows\\nfunction manipulationTarget( elem, content ) {\\n\\tif ( nodeName( elem, \"table\" ) &&\\n\\t\\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\\n\\n\\t\\treturn jQuery( \">tbody\", elem )[ 0 ] || elem;\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\n// Replace/restore the type attribute of script elements for safe DOM manipulation\\nfunction disableScript( elem ) {\\n\\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\\n\\treturn elem;\\n}\\nfunction restoreScript( elem ) {\\n\\tvar match = rscriptTypeMasked.exec( elem.type );\\n\\n\\tif ( match ) {\\n\\t\\telem.type = match[ 1 ];\\n\\t} else {\\n\\t\\telem.removeAttribute( \"type\" );\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\nfunction cloneCopyEvent( src, dest ) {\\n\\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\\n\\n\\tif ( dest.nodeType !== 1 ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// 1. Copy private data: events, handlers, etc.\\n\\tif ( dataPriv.hasData( src ) ) {\\n\\t\\tpdataOld = dataPriv.access( src );\\n\\t\\tpdataCur = dataPriv.set( dest, pdataOld );\\n\\t\\tevents = pdataOld.events;\\n\\n\\t\\tif ( events ) {\\n\\t\\t\\tdelete pdataCur.handle;\\n\\t\\t\\tpdataCur.events = {};\\n\\n\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tjQuery.event.add( dest, type, events[ type ][ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// 2. Copy user data\\n\\tif ( dataUser.hasData( src ) ) {\\n\\t\\tudataOld = dataUser.access( src );\\n\\t\\tudataCur = jQuery.extend( {}, udataOld );\\n\\n\\t\\tdataUser.set( dest, udataCur );\\n\\t}\\n}\\n\\n// Fix IE bugs, see support tests\\nfunction fixInput( src, dest ) {\\n\\tvar nodeName = dest.nodeName.toLowerCase();\\n\\n\\t// Fails to persist the checked state of a cloned checkbox or radio button.\\n\\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\\n\\t\\tdest.checked = src.checked;\\n\\n\\t// Fails to return the selected option to the default selected state when cloning options\\n\\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\\n\\t\\tdest.defaultValue = src.defaultValue;\\n\\t}\\n}\\n\\nfunction domManip( collection, args, callback, ignored ) {\\n\\n\\t// Flatten any nested arrays\\n\\targs = concat.apply( [], args );\\n\\n\\tvar fragment, first, scripts, hasScripts, node, doc,\\n\\t\\ti = 0,\\n\\t\\tl = collection.length,\\n\\t\\tiNoClone = l - 1,\\n\\t\\tvalue = args[ 0 ],\\n\\t\\tisFunction = jQuery.isFunction( value );\\n\\n\\t// We can\\'t cloneNode fragments that contain checked, in WebKit\\n\\tif ( isFunction ||\\n\\t\\t\\t( l > 1 && typeof value === \"string\" &&\\n\\t\\t\\t\\t!support.checkClone && rchecked.test( value ) ) ) {\\n\\t\\treturn collection.each( function( index ) {\\n\\t\\t\\tvar self = collection.eq( index );\\n\\t\\t\\tif ( isFunction ) {\\n\\t\\t\\t\\targs[ 0 ] = value.call( this, index, self.html() );\\n\\t\\t\\t}\\n\\t\\t\\tdomManip( self, args, callback, ignored );\\n\\t\\t} );\\n\\t}\\n\\n\\tif ( l ) {\\n\\t\\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\\n\\t\\tfirst = fragment.firstChild;\\n\\n\\t\\tif ( fragment.childNodes.length === 1 ) {\\n\\t\\t\\tfragment = first;\\n\\t\\t}\\n\\n\\t\\t// Require either new content or an interest in ignored elements to invoke the callback\\n\\t\\tif ( first || ignored ) {\\n\\t\\t\\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\\n\\t\\t\\thasScripts = scripts.length;\\n\\n\\t\\t\\t// Use the original fragment for the last item\\n\\t\\t\\t// instead of the first because it can end up\\n\\t\\t\\t// being emptied incorrectly in certain situations (#8070).\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tnode = fragment;\\n\\n\\t\\t\\t\\tif ( i !== iNoClone ) {\\n\\t\\t\\t\\t\\tnode = jQuery.clone( node, true, true );\\n\\n\\t\\t\\t\\t\\t// Keep references to cloned scripts for later restoration\\n\\t\\t\\t\\t\\tif ( hasScripts ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\t\\t\\tjQuery.merge( scripts, getAll( node, \"script\" ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcallback.call( collection[ i ], node, i );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasScripts ) {\\n\\t\\t\\t\\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\\n\\n\\t\\t\\t\\t// Reenable scripts\\n\\t\\t\\t\\tjQuery.map( scripts, restoreScript );\\n\\n\\t\\t\\t\\t// Evaluate executable scripts on first document insertion\\n\\t\\t\\t\\tfor ( i = 0; i < hasScripts; i++ ) {\\n\\t\\t\\t\\t\\tnode = scripts[ i ];\\n\\t\\t\\t\\t\\tif ( rscriptType.test( node.type || \"\" ) &&\\n\\t\\t\\t\\t\\t\\t!dataPriv.access( node, \"globalEval\" ) &&\\n\\t\\t\\t\\t\\t\\tjQuery.contains( doc, node ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( node.src ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Optional AJAX dependency, but won\\'t run scripts if not present\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery._evalUrl ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery._evalUrl( node.src );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn collection;\\n}\\n\\nfunction remove( elem, selector, keepData ) {\\n\\tvar node,\\n\\t\\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\\n\\t\\ti = 0;\\n\\n\\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\\n\\t\\tif ( !keepData && node.nodeType === 1 ) {\\n\\t\\t\\tjQuery.cleanData( getAll( node ) );\\n\\t\\t}\\n\\n\\t\\tif ( node.parentNode ) {\\n\\t\\t\\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\\n\\t\\t\\t\\tsetGlobalEval( getAll( node, \"script\" ) );\\n\\t\\t\\t}\\n\\t\\t\\tnode.parentNode.removeChild( node );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\njQuery.extend( {\\n\\thtmlPrefilter: function( html ) {\\n\\t\\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\\n\\t},\\n\\n\\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\\n\\t\\tvar i, l, srcElements, destElements,\\n\\t\\t\\tclone = elem.cloneNode( true ),\\n\\t\\t\\tinPage = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Fix IE cloning issues\\n\\t\\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\\n\\t\\t\\t\\t!jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\\n\\t\\t\\tdestElements = getAll( clone );\\n\\t\\t\\tsrcElements = getAll( elem );\\n\\n\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\tfixInput( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Copy the events from the original to the clone\\n\\t\\tif ( dataAndEvents ) {\\n\\t\\t\\tif ( deepDataAndEvents ) {\\n\\t\\t\\t\\tsrcElements = srcElements || getAll( elem );\\n\\t\\t\\t\\tdestElements = destElements || getAll( clone );\\n\\n\\t\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcloneCopyEvent( elem, clone );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tdestElements = getAll( clone, \"script\" );\\n\\t\\tif ( destElements.length > 0 ) {\\n\\t\\t\\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\\n\\t\\t}\\n\\n\\t\\t// Return the cloned set\\n\\t\\treturn clone;\\n\\t},\\n\\n\\tcleanData: function( elems ) {\\n\\t\\tvar data, elem, type,\\n\\t\\t\\tspecial = jQuery.event.special,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\\n\\t\\t\\tif ( acceptData( elem ) ) {\\n\\t\\t\\t\\tif ( ( data = elem[ dataPriv.expando ] ) ) {\\n\\t\\t\\t\\t\\tif ( data.events ) {\\n\\t\\t\\t\\t\\t\\tfor ( type in data.events ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( special[ type ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.event.remove( elem, type );\\n\\n\\t\\t\\t\\t\\t\\t\\t// This is a shortcut to avoid jQuery.event.remove\\'s overhead\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, data.handle );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataPriv.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( elem[ dataUser.expando ] ) {\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataUser.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdetach: function( selector ) {\\n\\t\\treturn remove( this, selector, true );\\n\\t},\\n\\n\\tremove: function( selector ) {\\n\\t\\treturn remove( this, selector );\\n\\t},\\n\\n\\ttext: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\treturn value === undefined ?\\n\\t\\t\\t\\tjQuery.text( this ) :\\n\\t\\t\\t\\tthis.empty().each( function() {\\n\\t\\t\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tthis.textContent = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\tappend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.appendChild( elem );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tprepend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.insertBefore( elem, target.firstChild );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tbefore: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tafter: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this.nextSibling );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tempty: function() {\\n\\t\\tvar elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\\n\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Prevent memory leaks\\n\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\n\\t\\t\\t\\t// Remove any remaining nodes\\n\\t\\t\\t\\telem.textContent = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tclone: function( dataAndEvents, deepDataAndEvents ) {\\n\\t\\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\\n\\t\\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\\n\\n\\t\\treturn this.map( function() {\\n\\t\\t\\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\\n\\t\\t} );\\n\\t},\\n\\n\\thtml: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar elem = this[ 0 ] || {},\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\tl = this.length;\\n\\n\\t\\t\\tif ( value === undefined && elem.nodeType === 1 ) {\\n\\t\\t\\t\\treturn elem.innerHTML;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// See if we can take a shortcut and just use innerHTML\\n\\t\\t\\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\\n\\t\\t\\t\\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\\n\\n\\t\\t\\t\\tvalue = jQuery.htmlPrefilter( value );\\n\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\telem = this[ i ] || {};\\n\\n\\t\\t\\t\\t\\t\\t// Remove element nodes and prevent memory leaks\\n\\t\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\t\\t\\t\\t\\t\\t\\telem.innerHTML = value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem = 0;\\n\\n\\t\\t\\t\\t// If using innerHTML throws an exception, use the fallback method\\n\\t\\t\\t\\t} catch ( e ) {}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\tthis.empty().append( value );\\n\\t\\t\\t}\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\treplaceWith: function() {\\n\\t\\tvar ignored = [];\\n\\n\\t\\t// Make the changes, replacing each non-ignored context element with the new content\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tvar parent = this.parentNode;\\n\\n\\t\\t\\tif ( jQuery.inArray( this, ignored ) < 0 ) {\\n\\t\\t\\t\\tjQuery.cleanData( getAll( this ) );\\n\\t\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\t\\tparent.replaceChild( elem, this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Force callback invocation\\n\\t\\t}, ignored );\\n\\t}\\n} );\\n\\njQuery.each( {\\n\\tappendTo: \"append\",\\n\\tprependTo: \"prepend\",\\n\\tinsertBefore: \"before\",\\n\\tinsertAfter: \"after\",\\n\\treplaceAll: \"replaceWith\"\\n}, function( name, original ) {\\n\\tjQuery.fn[ name ] = function( selector ) {\\n\\t\\tvar elems,\\n\\t\\t\\tret = [],\\n\\t\\t\\tinsert = jQuery( selector ),\\n\\t\\t\\tlast = insert.length - 1,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; i <= last; i++ ) {\\n\\t\\t\\telems = i === last ? this : this.clone( true );\\n\\t\\t\\tjQuery( insert[ i ] )[ original ]( elems );\\n\\n\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\tpush.apply( ret, elems.get() );\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( ret );\\n\\t};\\n} );\\nvar rmargin = ( /^margin/ );\\n\\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\\n\\nvar getStyles = function( elem ) {\\n\\n\\t\\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\\n\\t\\t// IE throws on elements created in popups\\n\\t\\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\\n\\t\\tvar view = elem.ownerDocument.defaultView;\\n\\n\\t\\tif ( !view || !view.opener ) {\\n\\t\\t\\tview = window;\\n\\t\\t}\\n\\n\\t\\treturn view.getComputedStyle( elem );\\n\\t};\\n\\n\\n\\n( function() {\\n\\n\\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\\n\\t// so they\\'re executed at the same time to save the second computation.\\n\\tfunction computeStyleTests() {\\n\\n\\t\\t// This is a singleton, we need to execute it only once\\n\\t\\tif ( !div ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tdiv.style.cssText =\\n\\t\\t\\t\"box-sizing:border-box;\" +\\n\\t\\t\\t\"position:relative;display:block;\" +\\n\\t\\t\\t\"margin:auto;border:1px;padding:1px;\" +\\n\\t\\t\\t\"top:1%;width:50%\";\\n\\t\\tdiv.innerHTML = \"\";\\n\\t\\tdocumentElement.appendChild( container );\\n\\n\\t\\tvar divStyle = window.getComputedStyle( div );\\n\\t\\tpixelPositionVal = divStyle.top !== \"1%\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\\n\\t\\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\\n\\t\\tboxSizingReliableVal = divStyle.width === \"4px\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only\\n\\t\\t// Some styles come back with percentage values, even though they shouldn\\'t\\n\\t\\tdiv.style.marginRight = \"50%\";\\n\\t\\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\\n\\n\\t\\tdocumentElement.removeChild( container );\\n\\n\\t\\t// Nullify the div so it wouldn\\'t be stored in the memory and\\n\\t\\t// it will also be a sign that checks already performed\\n\\t\\tdiv = null;\\n\\t}\\n\\n\\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\\n\\t\\tcontainer = document.createElement( \"div\" ),\\n\\t\\tdiv = document.createElement( \"div\" );\\n\\n\\t// Finish early in limited (non-browser) environments\\n\\tif ( !div.style ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Style of cloned element affects source element cloned (#8908)\\n\\tdiv.style.backgroundClip = \"content-box\";\\n\\tdiv.cloneNode( true ).style.backgroundClip = \"\";\\n\\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\\n\\n\\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\\n\\t\\t\"padding:0;margin-top:1px;position:absolute\";\\n\\tcontainer.appendChild( div );\\n\\n\\tjQuery.extend( support, {\\n\\t\\tpixelPosition: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelPositionVal;\\n\\t\\t},\\n\\t\\tboxSizingReliable: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn boxSizingReliableVal;\\n\\t\\t},\\n\\t\\tpixelMarginRight: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelMarginRightVal;\\n\\t\\t},\\n\\t\\treliableMarginLeft: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn reliableMarginLeftVal;\\n\\t\\t}\\n\\t} );\\n} )();\\n\\n\\nfunction curCSS( elem, name, computed ) {\\n\\tvar width, minWidth, maxWidth, ret,\\n\\n\\t\\t// Support: Firefox 51+\\n\\t\\t// Retrieving style before computed somehow\\n\\t\\t// fixes an issue with getting wrong values\\n\\t\\t// on detached elements\\n\\t\\tstyle = elem.style;\\n\\n\\tcomputed = computed || getStyles( elem );\\n\\n\\t// getPropertyValue is needed for:\\n\\t//   .css(\\'filter\\') (IE 9 only, #12537)\\n\\t//   .css(\\'--customProperty) (#3144)\\n\\tif ( computed ) {\\n\\t\\tret = computed.getPropertyValue( name ) || computed[ name ];\\n\\n\\t\\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\\n\\t\\t\\tret = jQuery.style( elem, name );\\n\\t\\t}\\n\\n\\t\\t// A tribute to the \"awesome hack by Dean Edwards\"\\n\\t\\t// Android Browser returns percentage for some values,\\n\\t\\t// but width seems to be reliably pixels.\\n\\t\\t// This is against the CSSOM draft spec:\\n\\t\\t// https://drafts.csswg.org/cssom/#resolved-values\\n\\t\\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\\n\\n\\t\\t\\t// Remember the original values\\n\\t\\t\\twidth = style.width;\\n\\t\\t\\tminWidth = style.minWidth;\\n\\t\\t\\tmaxWidth = style.maxWidth;\\n\\n\\t\\t\\t// Put in the new values to get a computed value out\\n\\t\\t\\tstyle.minWidth = style.maxWidth = style.width = ret;\\n\\t\\t\\tret = computed.width;\\n\\n\\t\\t\\t// Revert the changed values\\n\\t\\t\\tstyle.width = width;\\n\\t\\t\\tstyle.minWidth = minWidth;\\n\\t\\t\\tstyle.maxWidth = maxWidth;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret !== undefined ?\\n\\n\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t// IE returns zIndex value as an integer.\\n\\t\\tret + \"\" :\\n\\t\\tret;\\n}\\n\\n\\nfunction addGetHookIf( conditionFn, hookFn ) {\\n\\n\\t// Define the hook, we\\'ll check on the first run if it\\'s really needed.\\n\\treturn {\\n\\t\\tget: function() {\\n\\t\\t\\tif ( conditionFn() ) {\\n\\n\\t\\t\\t\\t// Hook not needed (or it\\'s not possible to use it due\\n\\t\\t\\t\\t// to missing dependency), remove it.\\n\\t\\t\\t\\tdelete this.get;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Hook needed; redefine it so that the support test is not executed again.\\n\\t\\t\\treturn ( this.get = hookFn ).apply( this, arguments );\\n\\t\\t}\\n\\t};\\n}\\n\\n\\nvar\\n\\n\\t// Swappable if display is none or starts with table\\n\\t// except \"table\", \"table-cell\", or \"table-caption\"\\n\\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\\n\\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\\n\\trcustomProp = /^--/,\\n\\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\\n\\tcssNormalTransform = {\\n\\t\\tletterSpacing: \"0\",\\n\\t\\tfontWeight: \"400\"\\n\\t},\\n\\n\\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\\n\\temptyStyle = document.createElement( \"div\" ).style;\\n\\n// Return a css property mapped to a potentially vendor prefixed property\\nfunction vendorPropName( name ) {\\n\\n\\t// Shortcut for names that are not vendor prefixed\\n\\tif ( name in emptyStyle ) {\\n\\t\\treturn name;\\n\\t}\\n\\n\\t// Check for vendor prefixed names\\n\\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\\n\\t\\ti = cssPrefixes.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tname = cssPrefixes[ i ] + capName;\\n\\t\\tif ( name in emptyStyle ) {\\n\\t\\t\\treturn name;\\n\\t\\t}\\n\\t}\\n}\\n\\n// Return a property mapped along what jQuery.cssProps suggests or to\\n// a vendor prefixed property.\\nfunction finalPropName( name ) {\\n\\tvar ret = jQuery.cssProps[ name ];\\n\\tif ( !ret ) {\\n\\t\\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\\n\\t}\\n\\treturn ret;\\n}\\n\\nfunction setPositiveNumber( elem, value, subtract ) {\\n\\n\\t// Any relative (+/-) values have already been\\n\\t// normalized at this point\\n\\tvar matches = rcssNum.exec( value );\\n\\treturn matches ?\\n\\n\\t\\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\\n\\t\\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\\n\\t\\tvalue;\\n}\\n\\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\\n\\tvar i,\\n\\t\\tval = 0;\\n\\n\\t// If we already have the right measurement, avoid augmentation\\n\\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\\n\\t\\ti = 4;\\n\\n\\t// Otherwise initialize for horizontal or vertical properties\\n\\t} else {\\n\\t\\ti = name === \"width\" ? 1 : 0;\\n\\t}\\n\\n\\tfor ( ; i < 4; i += 2 ) {\\n\\n\\t\\t// Both box models exclude margin, so add it if we want it\\n\\t\\tif ( extra === \"margin\" ) {\\n\\t\\t\\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\\n\\t\\t}\\n\\n\\t\\tif ( isBorderBox ) {\\n\\n\\t\\t\\t// border-box includes padding, so remove it if we want content\\n\\t\\t\\tif ( extra === \"content\" ) {\\n\\t\\t\\t\\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// At this point, extra isn\\'t border nor margin, so remove border\\n\\t\\t\\tif ( extra !== \"margin\" ) {\\n\\t\\t\\t\\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\n\\t\\t\\t// At this point, extra isn\\'t content, so add padding\\n\\t\\t\\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\\n\\n\\t\\t\\t// At this point, extra isn\\'t content nor padding, so add border\\n\\t\\t\\tif ( extra !== \"padding\" ) {\\n\\t\\t\\t\\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn val;\\n}\\n\\nfunction getWidthOrHeight( elem, name, extra ) {\\n\\n\\t// Start with computed style\\n\\tvar valueIsBorderBox,\\n\\t\\tstyles = getStyles( elem ),\\n\\t\\tval = curCSS( elem, name, styles ),\\n\\t\\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\\n\\n\\t// Computed unit is not pixels. Stop here and return.\\n\\tif ( rnumnonpx.test( val ) ) {\\n\\t\\treturn val;\\n\\t}\\n\\n\\t// Check for style in case a browser which returns unreliable values\\n\\t// for getComputedStyle silently falls back to the reliable elem.style\\n\\tvalueIsBorderBox = isBorderBox &&\\n\\t\\t( support.boxSizingReliable() || val === elem.style[ name ] );\\n\\n\\t// Fall back to offsetWidth/Height when value is \"auto\"\\n\\t// This happens for inline elements with no explicit setting (gh-3571)\\n\\tif ( val === \"auto\" ) {\\n\\t\\tval = elem[ \"offset\" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];\\n\\t}\\n\\n\\t// Normalize \"\", auto, and prepare for extra\\n\\tval = parseFloat( val ) || 0;\\n\\n\\t// Use the active box-sizing model to add/subtract irrelevant styles\\n\\treturn ( val +\\n\\t\\taugmentWidthOrHeight(\\n\\t\\t\\telem,\\n\\t\\t\\tname,\\n\\t\\t\\textra || ( isBorderBox ? \"border\" : \"content\" ),\\n\\t\\t\\tvalueIsBorderBox,\\n\\t\\t\\tstyles\\n\\t\\t)\\n\\t) + \"px\";\\n}\\n\\njQuery.extend( {\\n\\n\\t// Add in style property hooks for overriding the default\\n\\t// behavior of getting and setting a style property\\n\\tcssHooks: {\\n\\t\\topacity: {\\n\\t\\t\\tget: function( elem, computed ) {\\n\\t\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t\\t// We should always get a number back from opacity\\n\\t\\t\\t\\t\\tvar ret = curCSS( elem, \"opacity\" );\\n\\t\\t\\t\\t\\treturn ret === \"\" ? \"1\" : ret;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// Don\\'t automatically add \"px\" to these possibly-unitless properties\\n\\tcssNumber: {\\n\\t\\t\"animationIterationCount\": true,\\n\\t\\t\"columnCount\": true,\\n\\t\\t\"fillOpacity\": true,\\n\\t\\t\"flexGrow\": true,\\n\\t\\t\"flexShrink\": true,\\n\\t\\t\"fontWeight\": true,\\n\\t\\t\"lineHeight\": true,\\n\\t\\t\"opacity\": true,\\n\\t\\t\"order\": true,\\n\\t\\t\"orphans\": true,\\n\\t\\t\"widows\": true,\\n\\t\\t\"zIndex\": true,\\n\\t\\t\"zoom\": true\\n\\t},\\n\\n\\t// Add in properties whose names you wish to fix before\\n\\t// setting or getting the value\\n\\tcssProps: {\\n\\t\\t\"float\": \"cssFloat\"\\n\\t},\\n\\n\\t// Get and set the style property on a DOM Node\\n\\tstyle: function( elem, name, value, extra ) {\\n\\n\\t\\t// Don\\'t set styles on text and comment nodes\\n\\t\\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Make sure that we\\'re working with the right name\\n\\t\\tvar ret, type, hooks,\\n\\t\\t\\torigName = jQuery.camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name ),\\n\\t\\t\\tstyle = elem.style;\\n\\n\\t\\t// Make sure that we\\'re working with the right name. We don\\'t\\n\\t\\t// want to query the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Gets hook for the prefixed version, then unprefixed version\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// Check if we\\'re setting a value\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\ttype = typeof value;\\n\\n\\t\\t\\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\\n\\t\\t\\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\\n\\t\\t\\t\\tvalue = adjustCSS( elem, name, ret );\\n\\n\\t\\t\\t\\t// Fixes bug #9237\\n\\t\\t\\t\\ttype = \"number\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make sure that null and NaN values aren\\'t set (#7116)\\n\\t\\t\\tif ( value == null || value !== value ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a number was passed in, add the unit (except for certain CSS properties)\\n\\t\\t\\tif ( type === \"number\" ) {\\n\\t\\t\\t\\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// background-* props affect original clone\\'s values\\n\\t\\t\\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\\n\\t\\t\\t\\tstyle[ name ] = \"inherit\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a hook was provided, use that value, otherwise just set the specified value\\n\\t\\t\\tif ( !hooks || !( \"set\" in hooks ) ||\\n\\t\\t\\t\\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\tif ( isCustomProp ) {\\n\\t\\t\\t\\t\\tstyle.setProperty( name, value );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstyle[ name ] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// If a hook was provided get the non-computed value from there\\n\\t\\t\\tif ( hooks && \"get\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Otherwise just get the value from the style object\\n\\t\\t\\treturn style[ name ];\\n\\t\\t}\\n\\t},\\n\\n\\tcss: function( elem, name, extra, styles ) {\\n\\t\\tvar val, num, hooks,\\n\\t\\t\\torigName = jQuery.camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name );\\n\\n\\t\\t// Make sure that we\\'re working with the right name. We don\\'t\\n\\t\\t// want to modify the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Try prefixed name followed by the unprefixed name\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// If a hook was provided get the computed value from there\\n\\t\\tif ( hooks && \"get\" in hooks ) {\\n\\t\\t\\tval = hooks.get( elem, true, extra );\\n\\t\\t}\\n\\n\\t\\t// Otherwise, if a way to get the computed value exists, use that\\n\\t\\tif ( val === undefined ) {\\n\\t\\t\\tval = curCSS( elem, name, styles );\\n\\t\\t}\\n\\n\\t\\t// Convert \"normal\" to computed value\\n\\t\\tif ( val === \"normal\" && name in cssNormalTransform ) {\\n\\t\\t\\tval = cssNormalTransform[ name ];\\n\\t\\t}\\n\\n\\t\\t// Make numeric if forced or a qualifier was provided and val looks numeric\\n\\t\\tif ( extra === \"\" || extra ) {\\n\\t\\t\\tnum = parseFloat( val );\\n\\t\\t\\treturn extra === true || isFinite( num ) ? num || 0 : val;\\n\\t\\t}\\n\\n\\t\\treturn val;\\n\\t}\\n} );\\n\\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\\n\\tjQuery.cssHooks[ name ] = {\\n\\t\\tget: function( elem, computed, extra ) {\\n\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t// Certain elements can have dimension info if we invisibly show them\\n\\t\\t\\t\\t// but it must have a current display style that would benefit\\n\\t\\t\\t\\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\\n\\n\\t\\t\\t\\t\\t// Support: Safari 8+\\n\\t\\t\\t\\t\\t// Table columns in Safari have non-zero offsetWidth & zero\\n\\t\\t\\t\\t\\t// getBoundingClientRect().width unless display is changed.\\n\\t\\t\\t\\t\\t// Support: IE <=11 only\\n\\t\\t\\t\\t\\t// Running getBoundingClientRect on a disconnected node\\n\\t\\t\\t\\t\\t// in IE throws an error.\\n\\t\\t\\t\\t\\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\\n\\t\\t\\t\\t\\t\\tswap( elem, cssShow, function() {\\n\\t\\t\\t\\t\\t\\t\\treturn getWidthOrHeight( elem, name, extra );\\n\\t\\t\\t\\t\\t\\t} ) :\\n\\t\\t\\t\\t\\t\\tgetWidthOrHeight( elem, name, extra );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tset: function( elem, value, extra ) {\\n\\t\\t\\tvar matches,\\n\\t\\t\\t\\tstyles = extra && getStyles( elem ),\\n\\t\\t\\t\\tsubtract = extra && augmentWidthOrHeight(\\n\\t\\t\\t\\t\\telem,\\n\\t\\t\\t\\t\\tname,\\n\\t\\t\\t\\t\\textra,\\n\\t\\t\\t\\t\\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\\n\\t\\t\\t\\t\\tstyles\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t// Convert to pixels if value adjustment is needed\\n\\t\\t\\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\\n\\t\\t\\t\\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\\n\\n\\t\\t\\t\\telem.style[ name ] = value;\\n\\t\\t\\t\\tvalue = jQuery.css( elem, name );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn setPositiveNumber( elem, value, subtract );\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\\n\\tfunction( elem, computed ) {\\n\\t\\tif ( computed ) {\\n\\t\\t\\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\\n\\t\\t\\t\\telem.getBoundingClientRect().left -\\n\\t\\t\\t\\t\\tswap( elem, { marginLeft: 0 }, function() {\\n\\t\\t\\t\\t\\t\\treturn elem.getBoundingClientRect().left;\\n\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t) + \"px\";\\n\\t\\t}\\n\\t}\\n);\\n\\n// These hooks are used by animate to expand properties\\njQuery.each( {\\n\\tmargin: \"\",\\n\\tpadding: \"\",\\n\\tborder: \"Width\"\\n}, function( prefix, suffix ) {\\n\\tjQuery.cssHooks[ prefix + suffix ] = {\\n\\t\\texpand: function( value ) {\\n\\t\\t\\tvar i = 0,\\n\\t\\t\\t\\texpanded = {},\\n\\n\\t\\t\\t\\t// Assumes a single number if not a string\\n\\t\\t\\t\\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\\n\\n\\t\\t\\tfor ( ; i < 4; i++ ) {\\n\\t\\t\\t\\texpanded[ prefix + cssExpand[ i ] + suffix ] =\\n\\t\\t\\t\\t\\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn expanded;\\n\\t\\t}\\n\\t};\\n\\n\\tif ( !rmargin.test( prefix ) ) {\\n\\t\\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tcss: function( name, value ) {\\n\\t\\treturn access( this, function( elem, name, value ) {\\n\\t\\t\\tvar styles, len,\\n\\t\\t\\t\\tmap = {},\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tif ( Array.isArray( name ) ) {\\n\\t\\t\\t\\tstyles = getStyles( elem );\\n\\t\\t\\t\\tlen = name.length;\\n\\n\\t\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\t\\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn map;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value !== undefined ?\\n\\t\\t\\t\\tjQuery.style( elem, name, value ) :\\n\\t\\t\\t\\tjQuery.css( elem, name );\\n\\t\\t}, name, value, arguments.length > 1 );\\n\\t}\\n} );\\n\\n\\nfunction Tween( elem, options, prop, end, easing ) {\\n\\treturn new Tween.prototype.init( elem, options, prop, end, easing );\\n}\\njQuery.Tween = Tween;\\n\\nTween.prototype = {\\n\\tconstructor: Tween,\\n\\tinit: function( elem, options, prop, end, easing, unit ) {\\n\\t\\tthis.elem = elem;\\n\\t\\tthis.prop = prop;\\n\\t\\tthis.easing = easing || jQuery.easing._default;\\n\\t\\tthis.options = options;\\n\\t\\tthis.start = this.now = this.cur();\\n\\t\\tthis.end = end;\\n\\t\\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\\n\\t},\\n\\tcur: function() {\\n\\t\\tvar hooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\treturn hooks && hooks.get ?\\n\\t\\t\\thooks.get( this ) :\\n\\t\\t\\tTween.propHooks._default.get( this );\\n\\t},\\n\\trun: function( percent ) {\\n\\t\\tvar eased,\\n\\t\\t\\thooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\tif ( this.options.duration ) {\\n\\t\\t\\tthis.pos = eased = jQuery.easing[ this.easing ](\\n\\t\\t\\t\\tpercent, this.options.duration * percent, 0, 1, this.options.duration\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tthis.pos = eased = percent;\\n\\t\\t}\\n\\t\\tthis.now = ( this.end - this.start ) * eased + this.start;\\n\\n\\t\\tif ( this.options.step ) {\\n\\t\\t\\tthis.options.step.call( this.elem, this.now, this );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && hooks.set ) {\\n\\t\\t\\thooks.set( this );\\n\\t\\t} else {\\n\\t\\t\\tTween.propHooks._default.set( this );\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n};\\n\\nTween.prototype.init.prototype = Tween.prototype;\\n\\nTween.propHooks = {\\n\\t_default: {\\n\\t\\tget: function( tween ) {\\n\\t\\t\\tvar result;\\n\\n\\t\\t\\t// Use a property on the element directly when it is not a DOM element,\\n\\t\\t\\t// or when there is no matching style property that exists.\\n\\t\\t\\tif ( tween.elem.nodeType !== 1 ||\\n\\t\\t\\t\\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\\n\\t\\t\\t\\treturn tween.elem[ tween.prop ];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Passing an empty string as a 3rd parameter to .css will automatically\\n\\t\\t\\t// attempt a parseFloat and fallback to a string if the parse fails.\\n\\t\\t\\t// Simple values such as \"10px\" are parsed to Float;\\n\\t\\t\\t// complex values such as \"rotate(1rad)\" are returned as-is.\\n\\t\\t\\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\\n\\n\\t\\t\\t// Empty strings, null, undefined and \"auto\" are converted to 0.\\n\\t\\t\\treturn !result || result === \"auto\" ? 0 : result;\\n\\t\\t},\\n\\t\\tset: function( tween ) {\\n\\n\\t\\t\\t// Use step hook for back compat.\\n\\t\\t\\t// Use cssHook if its there.\\n\\t\\t\\t// Use .style if available and use plain properties where available.\\n\\t\\t\\tif ( jQuery.fx.step[ tween.prop ] ) {\\n\\t\\t\\t\\tjQuery.fx.step[ tween.prop ]( tween );\\n\\t\\t\\t} else if ( tween.elem.nodeType === 1 &&\\n\\t\\t\\t\\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\\n\\t\\t\\t\\t\\tjQuery.cssHooks[ tween.prop ] ) ) {\\n\\t\\t\\t\\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n// Support: IE <=9 only\\n// Panic based approach to setting things on disconnected nodes\\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\\n\\tset: function( tween ) {\\n\\t\\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\\n\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.easing = {\\n\\tlinear: function( p ) {\\n\\t\\treturn p;\\n\\t},\\n\\tswing: function( p ) {\\n\\t\\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\\n\\t},\\n\\t_default: \"swing\"\\n};\\n\\njQuery.fx = Tween.prototype.init;\\n\\n// Back compat <1.8 extension point\\njQuery.fx.step = {};\\n\\n\\n\\n\\nvar\\n\\tfxNow, inProgress,\\n\\trfxtypes = /^(?:toggle|show|hide)$/,\\n\\trrun = /queueHooks$/;\\n\\nfunction schedule() {\\n\\tif ( inProgress ) {\\n\\t\\tif ( document.hidden === false && window.requestAnimationFrame ) {\\n\\t\\t\\twindow.requestAnimationFrame( schedule );\\n\\t\\t} else {\\n\\t\\t\\twindow.setTimeout( schedule, jQuery.fx.interval );\\n\\t\\t}\\n\\n\\t\\tjQuery.fx.tick();\\n\\t}\\n}\\n\\n// Animations created synchronously will run synchronously\\nfunction createFxNow() {\\n\\twindow.setTimeout( function() {\\n\\t\\tfxNow = undefined;\\n\\t} );\\n\\treturn ( fxNow = jQuery.now() );\\n}\\n\\n// Generate parameters to create a standard animation\\nfunction genFx( type, includeWidth ) {\\n\\tvar which,\\n\\t\\ti = 0,\\n\\t\\tattrs = { height: type };\\n\\n\\t// If we include width, step value is 1 to do all cssExpand values,\\n\\t// otherwise step value is 2 to skip over Left and Right\\n\\tincludeWidth = includeWidth ? 1 : 0;\\n\\tfor ( ; i < 4; i += 2 - includeWidth ) {\\n\\t\\twhich = cssExpand[ i ];\\n\\t\\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\\n\\t}\\n\\n\\tif ( includeWidth ) {\\n\\t\\tattrs.opacity = attrs.width = type;\\n\\t}\\n\\n\\treturn attrs;\\n}\\n\\nfunction createTween( value, prop, animation ) {\\n\\tvar tween,\\n\\t\\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\\n\\t\\tindex = 0,\\n\\t\\tlength = collection.length;\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\\n\\n\\t\\t\\t// We\\'re done with this property\\n\\t\\t\\treturn tween;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction defaultPrefilter( elem, props, opts ) {\\n\\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\\n\\t\\tisBox = \"width\" in props || \"height\" in props,\\n\\t\\tanim = this,\\n\\t\\torig = {},\\n\\t\\tstyle = elem.style,\\n\\t\\thidden = elem.nodeType && isHiddenWithinTree( elem ),\\n\\t\\tdataShow = dataPriv.get( elem, \"fxshow\" );\\n\\n\\t// Queue-skipping animations hijack the fx hooks\\n\\tif ( !opts.queue ) {\\n\\t\\thooks = jQuery._queueHooks( elem, \"fx\" );\\n\\t\\tif ( hooks.unqueued == null ) {\\n\\t\\t\\thooks.unqueued = 0;\\n\\t\\t\\toldfire = hooks.empty.fire;\\n\\t\\t\\thooks.empty.fire = function() {\\n\\t\\t\\t\\tif ( !hooks.unqueued ) {\\n\\t\\t\\t\\t\\toldfire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\thooks.unqueued++;\\n\\n\\t\\tanim.always( function() {\\n\\n\\t\\t\\t// Ensure the complete handler is called before this completes\\n\\t\\t\\tanim.always( function() {\\n\\t\\t\\t\\thooks.unqueued--;\\n\\t\\t\\t\\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\\n\\t\\t\\t\\t\\thooks.empty.fire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\t// Detect show/hide animations\\n\\tfor ( prop in props ) {\\n\\t\\tvalue = props[ prop ];\\n\\t\\tif ( rfxtypes.test( value ) ) {\\n\\t\\t\\tdelete props[ prop ];\\n\\t\\t\\ttoggle = toggle || value === \"toggle\";\\n\\t\\t\\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\\n\\n\\t\\t\\t\\t// Pretend to be hidden if this is a \"show\" and\\n\\t\\t\\t\\t// there is still data from a stopped show/hide\\n\\t\\t\\t\\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\\n\\t\\t\\t\\t\\thidden = true;\\n\\n\\t\\t\\t\\t// Ignore all other no-op show/hide data\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\\n\\t\\t}\\n\\t}\\n\\n\\t// Bail out if this is a no-op like .hide().hide()\\n\\tpropTween = !jQuery.isEmptyObject( props );\\n\\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Restrict \"overflow\" and \"display\" styles during box animations\\n\\tif ( isBox && elem.nodeType === 1 ) {\\n\\n\\t\\t// Support: IE <=9 - 11, Edge 12 - 13\\n\\t\\t// Record all 3 overflow attributes because IE does not infer the shorthand\\n\\t\\t// from identically-valued overflowX and overflowY\\n\\t\\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\\n\\n\\t\\t// Identify a display type, preferring old show/hide data over the CSS cascade\\n\\t\\trestoreDisplay = dataShow && dataShow.display;\\n\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\trestoreDisplay = dataPriv.get( elem, \"display\" );\\n\\t\\t}\\n\\t\\tdisplay = jQuery.css( elem, \"display\" );\\n\\t\\tif ( display === \"none\" ) {\\n\\t\\t\\tif ( restoreDisplay ) {\\n\\t\\t\\t\\tdisplay = restoreDisplay;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Get nonempty value(s) by temporarily forcing visibility\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t\\trestoreDisplay = elem.style.display || restoreDisplay;\\n\\t\\t\\t\\tdisplay = jQuery.css( elem, \"display\" );\\n\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Animate inline elements as inline-block\\n\\t\\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\\n\\t\\t\\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\\n\\n\\t\\t\\t\\t// Restore the original display value at the end of pure show/hide animations\\n\\t\\t\\t\\tif ( !propTween ) {\\n\\t\\t\\t\\t\\tanim.done( function() {\\n\\t\\t\\t\\t\\t\\tstyle.display = restoreDisplay;\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\t\\t\\t\\tdisplay = style.display;\\n\\t\\t\\t\\t\\t\\trestoreDisplay = display === \"none\" ? \"\" : display;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstyle.display = \"inline-block\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( opts.overflow ) {\\n\\t\\tstyle.overflow = \"hidden\";\\n\\t\\tanim.always( function() {\\n\\t\\t\\tstyle.overflow = opts.overflow[ 0 ];\\n\\t\\t\\tstyle.overflowX = opts.overflow[ 1 ];\\n\\t\\t\\tstyle.overflowY = opts.overflow[ 2 ];\\n\\t\\t} );\\n\\t}\\n\\n\\t// Implement show/hide animations\\n\\tpropTween = false;\\n\\tfor ( prop in orig ) {\\n\\n\\t\\t// General show/hide setup for this element animation\\n\\t\\tif ( !propTween ) {\\n\\t\\t\\tif ( dataShow ) {\\n\\t\\t\\t\\tif ( \"hidden\" in dataShow ) {\\n\\t\\t\\t\\t\\thidden = dataShow.hidden;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\\n\\t\\t\\tif ( toggle ) {\\n\\t\\t\\t\\tdataShow.hidden = !hidden;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Show elements before animating them\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* eslint-disable no-loop-func */\\n\\n\\t\\t\\tanim.done( function() {\\n\\n\\t\\t\\t/* eslint-enable no-loop-func */\\n\\n\\t\\t\\t\\t// The final step of a \"hide\" animation is actually hiding the element\\n\\t\\t\\t\\tif ( !hidden ) {\\n\\t\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.remove( elem, \"fxshow\" );\\n\\t\\t\\t\\tfor ( prop in orig ) {\\n\\t\\t\\t\\t\\tjQuery.style( elem, prop, orig[ prop ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\t// Per-property setup\\n\\t\\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\\n\\t\\tif ( !( prop in dataShow ) ) {\\n\\t\\t\\tdataShow[ prop ] = propTween.start;\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tpropTween.end = propTween.start;\\n\\t\\t\\t\\tpropTween.start = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction propFilter( props, specialEasing ) {\\n\\tvar index, name, easing, value, hooks;\\n\\n\\t// camelCase, specialEasing and expand cssHook pass\\n\\tfor ( index in props ) {\\n\\t\\tname = jQuery.camelCase( index );\\n\\t\\teasing = specialEasing[ name ];\\n\\t\\tvalue = props[ index ];\\n\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\teasing = value[ 1 ];\\n\\t\\t\\tvalue = props[ index ] = value[ 0 ];\\n\\t\\t}\\n\\n\\t\\tif ( index !== name ) {\\n\\t\\t\\tprops[ name ] = value;\\n\\t\\t\\tdelete props[ index ];\\n\\t\\t}\\n\\n\\t\\thooks = jQuery.cssHooks[ name ];\\n\\t\\tif ( hooks && \"expand\" in hooks ) {\\n\\t\\t\\tvalue = hooks.expand( value );\\n\\t\\t\\tdelete props[ name ];\\n\\n\\t\\t\\t// Not quite $.extend, this won\\'t overwrite existing keys.\\n\\t\\t\\t// Reusing \\'index\\' because we have the correct \"name\"\\n\\t\\t\\tfor ( index in value ) {\\n\\t\\t\\t\\tif ( !( index in props ) ) {\\n\\t\\t\\t\\t\\tprops[ index ] = value[ index ];\\n\\t\\t\\t\\t\\tspecialEasing[ index ] = easing;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tspecialEasing[ name ] = easing;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction Animation( elem, properties, options ) {\\n\\tvar result,\\n\\t\\tstopped,\\n\\t\\tindex = 0,\\n\\t\\tlength = Animation.prefilters.length,\\n\\t\\tdeferred = jQuery.Deferred().always( function() {\\n\\n\\t\\t\\t// Don\\'t match elem in the :animated selector\\n\\t\\t\\tdelete tick.elem;\\n\\t\\t} ),\\n\\t\\ttick = function() {\\n\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tvar currentTime = fxNow || createFxNow(),\\n\\t\\t\\t\\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\\n\\n\\t\\t\\t\\t// Support: Android 2.3 only\\n\\t\\t\\t\\t// Archaic crash bug won\\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\\n\\t\\t\\t\\ttemp = remaining / animation.duration || 0,\\n\\t\\t\\t\\tpercent = 1 - temp,\\n\\t\\t\\t\\tindex = 0,\\n\\t\\t\\t\\tlength = animation.tweens.length;\\n\\n\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\tanimation.tweens[ index ].run( percent );\\n\\t\\t\\t}\\n\\n\\t\\t\\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\\n\\n\\t\\t\\t// If there\\'s more to do, yield\\n\\t\\t\\tif ( percent < 1 && length ) {\\n\\t\\t\\t\\treturn remaining;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If this was an empty animation, synthesize a final progress notification\\n\\t\\t\\tif ( !length ) {\\n\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Resolve the animation and report its conclusion\\n\\t\\t\\tdeferred.resolveWith( elem, [ animation ] );\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tanimation = deferred.promise( {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tprops: jQuery.extend( {}, properties ),\\n\\t\\t\\topts: jQuery.extend( true, {\\n\\t\\t\\t\\tspecialEasing: {},\\n\\t\\t\\t\\teasing: jQuery.easing._default\\n\\t\\t\\t}, options ),\\n\\t\\t\\toriginalProperties: properties,\\n\\t\\t\\toriginalOptions: options,\\n\\t\\t\\tstartTime: fxNow || createFxNow(),\\n\\t\\t\\tduration: options.duration,\\n\\t\\t\\ttweens: [],\\n\\t\\t\\tcreateTween: function( prop, end ) {\\n\\t\\t\\t\\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\\n\\t\\t\\t\\t\\t\\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\\n\\t\\t\\t\\tanimation.tweens.push( tween );\\n\\t\\t\\t\\treturn tween;\\n\\t\\t\\t},\\n\\t\\t\\tstop: function( gotoEnd ) {\\n\\t\\t\\t\\tvar index = 0,\\n\\n\\t\\t\\t\\t\\t// If we are going to the end, we want to run all the tweens\\n\\t\\t\\t\\t\\t// otherwise we skip this part\\n\\t\\t\\t\\t\\tlength = gotoEnd ? animation.tweens.length : 0;\\n\\t\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstopped = true;\\n\\t\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\t\\tanimation.tweens[ index ].run( 1 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Resolve when we played the last frame; otherwise, reject\\n\\t\\t\\t\\tif ( gotoEnd ) {\\n\\t\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t\\t\\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t} ),\\n\\t\\tprops = animation.props;\\n\\n\\tpropFilter( props, animation.opts.specialEasing );\\n\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\\n\\t\\tif ( result ) {\\n\\t\\t\\tif ( jQuery.isFunction( result.stop ) ) {\\n\\t\\t\\t\\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\\n\\t\\t\\t\\t\\tjQuery.proxy( result.stop, result );\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\n\\tjQuery.map( props, createTween, animation );\\n\\n\\tif ( jQuery.isFunction( animation.opts.start ) ) {\\n\\t\\tanimation.opts.start.call( elem, animation );\\n\\t}\\n\\n\\t// Attach callbacks from options\\n\\tanimation\\n\\t\\t.progress( animation.opts.progress )\\n\\t\\t.done( animation.opts.done, animation.opts.complete )\\n\\t\\t.fail( animation.opts.fail )\\n\\t\\t.always( animation.opts.always );\\n\\n\\tjQuery.fx.timer(\\n\\t\\tjQuery.extend( tick, {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tanim: animation,\\n\\t\\t\\tqueue: animation.opts.queue\\n\\t\\t} )\\n\\t);\\n\\n\\treturn animation;\\n}\\n\\njQuery.Animation = jQuery.extend( Animation, {\\n\\n\\ttweeners: {\\n\\t\\t\"*\": [ function( prop, value ) {\\n\\t\\t\\tvar tween = this.createTween( prop, value );\\n\\t\\t\\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\\n\\t\\t\\treturn tween;\\n\\t\\t} ]\\n\\t},\\n\\n\\ttweener: function( props, callback ) {\\n\\t\\tif ( jQuery.isFunction( props ) ) {\\n\\t\\t\\tcallback = props;\\n\\t\\t\\tprops = [ \"*\" ];\\n\\t\\t} else {\\n\\t\\t\\tprops = props.match( rnothtmlwhite );\\n\\t\\t}\\n\\n\\t\\tvar prop,\\n\\t\\t\\tindex = 0,\\n\\t\\t\\tlength = props.length;\\n\\n\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\tprop = props[ index ];\\n\\t\\t\\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\\n\\t\\t\\tAnimation.tweeners[ prop ].unshift( callback );\\n\\t\\t}\\n\\t},\\n\\n\\tprefilters: [ defaultPrefilter ],\\n\\n\\tprefilter: function( callback, prepend ) {\\n\\t\\tif ( prepend ) {\\n\\t\\t\\tAnimation.prefilters.unshift( callback );\\n\\t\\t} else {\\n\\t\\t\\tAnimation.prefilters.push( callback );\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.speed = function( speed, easing, fn ) {\\n\\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\\n\\t\\tcomplete: fn || !fn && easing ||\\n\\t\\t\\tjQuery.isFunction( speed ) && speed,\\n\\t\\tduration: speed,\\n\\t\\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\\n\\t};\\n\\n\\t// Go to the end state if fx are off\\n\\tif ( jQuery.fx.off ) {\\n\\t\\topt.duration = 0;\\n\\n\\t} else {\\n\\t\\tif ( typeof opt.duration !== \"number\" ) {\\n\\t\\t\\tif ( opt.duration in jQuery.fx.speeds ) {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds[ opt.duration ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds._default;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Normalize opt.queue - true/undefined/null -> \"fx\"\\n\\tif ( opt.queue == null || opt.queue === true ) {\\n\\t\\topt.queue = \"fx\";\\n\\t}\\n\\n\\t// Queueing\\n\\topt.old = opt.complete;\\n\\n\\topt.complete = function() {\\n\\t\\tif ( jQuery.isFunction( opt.old ) ) {\\n\\t\\t\\topt.old.call( this );\\n\\t\\t}\\n\\n\\t\\tif ( opt.queue ) {\\n\\t\\t\\tjQuery.dequeue( this, opt.queue );\\n\\t\\t}\\n\\t};\\n\\n\\treturn opt;\\n};\\n\\njQuery.fn.extend( {\\n\\tfadeTo: function( speed, to, easing, callback ) {\\n\\n\\t\\t// Show any hidden elements after setting opacity to 0\\n\\t\\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\\n\\n\\t\\t\\t// Animate to the value specified\\n\\t\\t\\t.end().animate( { opacity: to }, speed, easing, callback );\\n\\t},\\n\\tanimate: function( prop, speed, easing, callback ) {\\n\\t\\tvar empty = jQuery.isEmptyObject( prop ),\\n\\t\\t\\toptall = jQuery.speed( speed, easing, callback ),\\n\\t\\t\\tdoAnimation = function() {\\n\\n\\t\\t\\t\\t// Operate on a copy of prop so per-property easing won\\'t be lost\\n\\t\\t\\t\\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\\n\\n\\t\\t\\t\\t// Empty animations, or finishing resolves immediately\\n\\t\\t\\t\\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\\n\\t\\t\\t\\t\\tanim.stop( true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tdoAnimation.finish = doAnimation;\\n\\n\\t\\treturn empty || optall.queue === false ?\\n\\t\\t\\tthis.each( doAnimation ) :\\n\\t\\t\\tthis.queue( optall.queue, doAnimation );\\n\\t},\\n\\tstop: function( type, clearQueue, gotoEnd ) {\\n\\t\\tvar stopQueue = function( hooks ) {\\n\\t\\t\\tvar stop = hooks.stop;\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tstop( gotoEnd );\\n\\t\\t};\\n\\n\\t\\tif ( typeof type !== \"string\" ) {\\n\\t\\t\\tgotoEnd = clearQueue;\\n\\t\\t\\tclearQueue = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\tif ( clearQueue && type !== false ) {\\n\\t\\t\\tthis.queue( type || \"fx\", [] );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar dequeue = true,\\n\\t\\t\\t\\tindex = type != null && type + \"queueHooks\",\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tdata = dataPriv.get( this );\\n\\n\\t\\t\\tif ( index ) {\\n\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop ) {\\n\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor ( index in data ) {\\n\\t\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\\n\\t\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this &&\\n\\t\\t\\t\\t\\t( type == null || timers[ index ].queue === type ) ) {\\n\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( gotoEnd );\\n\\t\\t\\t\\t\\tdequeue = false;\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Start the next in the queue if the last step wasn\\'t forced.\\n\\t\\t\\t// Timers currently will call their complete callbacks, which\\n\\t\\t\\t// will dequeue but only if they were gotoEnd.\\n\\t\\t\\tif ( dequeue || !gotoEnd ) {\\n\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\tfinish: function( type ) {\\n\\t\\tif ( type !== false ) {\\n\\t\\t\\ttype = type || \"fx\";\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar index,\\n\\t\\t\\t\\tdata = dataPriv.get( this ),\\n\\t\\t\\t\\tqueue = data[ type + \"queue\" ],\\n\\t\\t\\t\\thooks = data[ type + \"queueHooks\" ],\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tlength = queue ? queue.length : 0;\\n\\n\\t\\t\\t// Enable finishing flag on private data\\n\\t\\t\\tdata.finish = true;\\n\\n\\t\\t\\t// Empty the queue first\\n\\t\\t\\tjQuery.queue( this, type, [] );\\n\\n\\t\\t\\tif ( hooks && hooks.stop ) {\\n\\t\\t\\t\\thooks.stop.call( this, true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any active animations, and finish them\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( true );\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any animations in the old queue and finish them\\n\\t\\t\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\t\\t\\tif ( queue[ index ] && queue[ index ].finish ) {\\n\\t\\t\\t\\t\\tqueue[ index ].finish.call( this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Turn off finishing flag\\n\\t\\t\\tdelete data.finish;\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\\n\\tvar cssFn = jQuery.fn[ name ];\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn speed == null || typeof speed === \"boolean\" ?\\n\\t\\t\\tcssFn.apply( this, arguments ) :\\n\\t\\t\\tthis.animate( genFx( name, true ), speed, easing, callback );\\n\\t};\\n} );\\n\\n// Generate shortcuts for custom animations\\njQuery.each( {\\n\\tslideDown: genFx( \"show\" ),\\n\\tslideUp: genFx( \"hide\" ),\\n\\tslideToggle: genFx( \"toggle\" ),\\n\\tfadeIn: { opacity: \"show\" },\\n\\tfadeOut: { opacity: \"hide\" },\\n\\tfadeToggle: { opacity: \"toggle\" }\\n}, function( name, props ) {\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn this.animate( props, speed, easing, callback );\\n\\t};\\n} );\\n\\njQuery.timers = [];\\njQuery.fx.tick = function() {\\n\\tvar timer,\\n\\t\\ti = 0,\\n\\t\\ttimers = jQuery.timers;\\n\\n\\tfxNow = jQuery.now();\\n\\n\\tfor ( ; i < timers.length; i++ ) {\\n\\t\\ttimer = timers[ i ];\\n\\n\\t\\t// Run the timer and safely remove it when done (allowing for external removal)\\n\\t\\tif ( !timer() && timers[ i ] === timer ) {\\n\\t\\t\\ttimers.splice( i--, 1 );\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !timers.length ) {\\n\\t\\tjQuery.fx.stop();\\n\\t}\\n\\tfxNow = undefined;\\n};\\n\\njQuery.fx.timer = function( timer ) {\\n\\tjQuery.timers.push( timer );\\n\\tjQuery.fx.start();\\n};\\n\\njQuery.fx.interval = 13;\\njQuery.fx.start = function() {\\n\\tif ( inProgress ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tinProgress = true;\\n\\tschedule();\\n};\\n\\njQuery.fx.stop = function() {\\n\\tinProgress = null;\\n};\\n\\njQuery.fx.speeds = {\\n\\tslow: 600,\\n\\tfast: 200,\\n\\n\\t// Default speed\\n\\t_default: 400\\n};\\n\\n\\n// Based off of the plugin by Clint Helfers, with permission.\\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\\njQuery.fn.delay = function( time, type ) {\\n\\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\\n\\ttype = type || \"fx\";\\n\\n\\treturn this.queue( type, function( next, hooks ) {\\n\\t\\tvar timeout = window.setTimeout( next, time );\\n\\t\\thooks.stop = function() {\\n\\t\\t\\twindow.clearTimeout( timeout );\\n\\t\\t};\\n\\t} );\\n};\\n\\n\\n( function() {\\n\\tvar input = document.createElement( \"input\" ),\\n\\t\\tselect = document.createElement( \"select\" ),\\n\\t\\topt = select.appendChild( document.createElement( \"option\" ) );\\n\\n\\tinput.type = \"checkbox\";\\n\\n\\t// Support: Android <=4.3 only\\n\\t// Default value for a checkbox should be \"on\"\\n\\tsupport.checkOn = input.value !== \"\";\\n\\n\\t// Support: IE <=11 only\\n\\t// Must access selectedIndex to make default options select\\n\\tsupport.optSelected = opt.selected;\\n\\n\\t// Support: IE <=11 only\\n\\t// An input loses its value after becoming a radio\\n\\tinput = document.createElement( \"input\" );\\n\\tinput.value = \"t\";\\n\\tinput.type = \"radio\";\\n\\tsupport.radioValue = input.value === \"t\";\\n} )();\\n\\n\\nvar boolHook,\\n\\tattrHandle = jQuery.expr.attrHandle;\\n\\njQuery.fn.extend( {\\n\\tattr: function( name, value ) {\\n\\t\\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveAttr: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.removeAttr( this, name );\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tattr: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don\\'t get/set attributes on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Fallback to prop when attributes are not supported\\n\\t\\tif ( typeof elem.getAttribute === \"undefined\" ) {\\n\\t\\t\\treturn jQuery.prop( elem, name, value );\\n\\t\\t}\\n\\n\\t\\t// Attribute hooks are determined by the lowercase version\\n\\t\\t// Grab necessary hook if one is defined\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\t\\t\\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\\n\\t\\t\\t\\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( value === null ) {\\n\\t\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hooks && \"set\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\telem.setAttribute( name, value + \"\" );\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\tret = jQuery.find.attr( elem, name );\\n\\n\\t\\t// Non-existent attributes return null, we normalize to undefined\\n\\t\\treturn ret == null ? undefined : ret;\\n\\t},\\n\\n\\tattrHooks: {\\n\\t\\ttype: {\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tif ( !support.radioValue && value === \"radio\" &&\\n\\t\\t\\t\\t\\tnodeName( elem, \"input\" ) ) {\\n\\t\\t\\t\\t\\tvar val = elem.value;\\n\\t\\t\\t\\t\\telem.setAttribute( \"type\", value );\\n\\t\\t\\t\\t\\tif ( val ) {\\n\\t\\t\\t\\t\\t\\telem.value = val;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tremoveAttr: function( elem, value ) {\\n\\t\\tvar name,\\n\\t\\t\\ti = 0,\\n\\n\\t\\t\\t// Attribute names can contain non-HTML whitespace characters\\n\\t\\t\\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\\n\\t\\t\\tattrNames = value && value.match( rnothtmlwhite );\\n\\n\\t\\tif ( attrNames && elem.nodeType === 1 ) {\\n\\t\\t\\twhile ( ( name = attrNames[ i++ ] ) ) {\\n\\t\\t\\t\\telem.removeAttribute( name );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Hooks for boolean attributes\\nboolHook = {\\n\\tset: function( elem, value, name ) {\\n\\t\\tif ( value === false ) {\\n\\n\\t\\t\\t// Remove boolean attributes when set to false\\n\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t} else {\\n\\t\\t\\telem.setAttribute( name, name );\\n\\t\\t}\\n\\t\\treturn name;\\n\\t}\\n};\\n\\njQuery.each( jQuery.expr.match.bool.source.match( /\\\\w+/g ), function( i, name ) {\\n\\tvar getter = attrHandle[ name ] || jQuery.find.attr;\\n\\n\\tattrHandle[ name ] = function( elem, name, isXML ) {\\n\\t\\tvar ret, handle,\\n\\t\\t\\tlowercaseName = name.toLowerCase();\\n\\n\\t\\tif ( !isXML ) {\\n\\n\\t\\t\\t// Avoid an infinite loop by temporarily removing this function from the getter\\n\\t\\t\\thandle = attrHandle[ lowercaseName ];\\n\\t\\t\\tattrHandle[ lowercaseName ] = ret;\\n\\t\\t\\tret = getter( elem, name, isXML ) != null ?\\n\\t\\t\\t\\tlowercaseName :\\n\\t\\t\\t\\tnull;\\n\\t\\t\\tattrHandle[ lowercaseName ] = handle;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t};\\n} );\\n\\n\\n\\n\\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\\n\\trclickable = /^(?:a|area)$/i;\\n\\njQuery.fn.extend( {\\n\\tprop: function( name, value ) {\\n\\t\\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveProp: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdelete this[ jQuery.propFix[ name ] || name ];\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tprop: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don\\'t get/set properties on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// Fix name and attach hooks\\n\\t\\t\\tname = jQuery.propFix[ name ] || name;\\n\\t\\t\\thooks = jQuery.propHooks[ name ];\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( hooks && \"set\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( elem[ name ] = value );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\treturn elem[ name ];\\n\\t},\\n\\n\\tpropHooks: {\\n\\t\\ttabIndex: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t\\t\\t// elem.tabIndex doesn\\'t always return the\\n\\t\\t\\t\\t// correct value when it hasn\\'t been explicitly set\\n\\t\\t\\t\\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\\n\\t\\t\\t\\t// Use proper attribute retrieval(#12072)\\n\\t\\t\\t\\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\\n\\n\\t\\t\\t\\tif ( tabindex ) {\\n\\t\\t\\t\\t\\treturn parseInt( tabindex, 10 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\trfocusable.test( elem.nodeName ) ||\\n\\t\\t\\t\\t\\trclickable.test( elem.nodeName ) &&\\n\\t\\t\\t\\t\\telem.href\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tpropFix: {\\n\\t\\t\"for\": \"htmlFor\",\\n\\t\\t\"class\": \"className\"\\n\\t}\\n} );\\n\\n// Support: IE <=11 only\\n// Accessing the selectedIndex property\\n// forces the browser to respect setting selected\\n// on the option\\n// The getter ensures a default option is selected\\n// when in an optgroup\\n// eslint rule \"no-unused-expressions\" is disabled for this code\\n// since it considers such accessions noop\\nif ( !support.optSelected ) {\\n\\tjQuery.propHooks.selected = {\\n\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \"off\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent && parent.parentNode ) {\\n\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tset: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \"off\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\tparent.selectedIndex;\\n\\n\\t\\t\\t\\tif ( parent.parentNode ) {\\n\\t\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\njQuery.each( [\\n\\t\"tabIndex\",\\n\\t\"readOnly\",\\n\\t\"maxLength\",\\n\\t\"cellSpacing\",\\n\\t\"cellPadding\",\\n\\t\"rowSpan\",\\n\\t\"colSpan\",\\n\\t\"useMap\",\\n\\t\"frameBorder\",\\n\\t\"contentEditable\"\\n], function() {\\n\\tjQuery.propFix[ this.toLowerCase() ] = this;\\n} );\\n\\n\\n\\n\\n\\t// Strip and collapse whitespace according to HTML spec\\n\\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\\n\\tfunction stripAndCollapse( value ) {\\n\\t\\tvar tokens = value.match( rnothtmlwhite ) || [];\\n\\t\\treturn tokens.join( \" \" );\\n\\t}\\n\\n\\nfunction getClass( elem ) {\\n\\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\\n}\\n\\njQuery.fn.extend( {\\n\\taddClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( typeof value === \"string\" && value ) {\\n\\t\\t\\tclasses = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\t\\t\\t\\t\\t\\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur += clazz + \" \";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \"class\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tremoveClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\treturn this.attr( \"class\", \"\" );\\n\\t\\t}\\n\\n\\t\\tif ( typeof value === \"string\" && value ) {\\n\\t\\t\\tclasses = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\n\\t\\t\\t\\t// This expression is here for better compressibility (see addClass)\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Remove *all* instances\\n\\t\\t\\t\\t\\t\\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \"class\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\ttoggleClass: function( value, stateVal ) {\\n\\t\\tvar type = typeof value;\\n\\n\\t\\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\\n\\t\\t\\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\\n\\t\\t}\\n\\n\\t\\tif ( jQuery.isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).toggleClass(\\n\\t\\t\\t\\t\\tvalue.call( this, i, getClass( this ), stateVal ),\\n\\t\\t\\t\\t\\tstateVal\\n\\t\\t\\t\\t);\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar className, i, self, classNames;\\n\\n\\t\\t\\tif ( type === \"string\" ) {\\n\\n\\t\\t\\t\\t// Toggle individual class names\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\tself = jQuery( this );\\n\\t\\t\\t\\tclassNames = value.match( rnothtmlwhite ) || [];\\n\\n\\t\\t\\t\\twhile ( ( className = classNames[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t// Check each className given, space separated list\\n\\t\\t\\t\\t\\tif ( self.hasClass( className ) ) {\\n\\t\\t\\t\\t\\t\\tself.removeClass( className );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tself.addClass( className );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// Toggle whole class name\\n\\t\\t\\t} else if ( value === undefined || type === \"boolean\" ) {\\n\\t\\t\\t\\tclassName = getClass( this );\\n\\t\\t\\t\\tif ( className ) {\\n\\n\\t\\t\\t\\t\\t// Store className if set\\n\\t\\t\\t\\t\\tdataPriv.set( this, \"__className__\", className );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the element has a class name or if we\\'re passed `false`,\\n\\t\\t\\t\\t// then remove the whole classname (if there was one, the above saved it).\\n\\t\\t\\t\\t// Otherwise bring back whatever was previously saved (if anything),\\n\\t\\t\\t\\t// falling back to the empty string if nothing was stored.\\n\\t\\t\\t\\tif ( this.setAttribute ) {\\n\\t\\t\\t\\t\\tthis.setAttribute( \"class\",\\n\\t\\t\\t\\t\\t\\tclassName || value === false ?\\n\\t\\t\\t\\t\\t\\t\"\" :\\n\\t\\t\\t\\t\\t\\tdataPriv.get( this, \"__className__\" ) || \"\"\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\thasClass: function( selector ) {\\n\\t\\tvar className, elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tclassName = \" \" + selector + \" \";\\n\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\tif ( elem.nodeType === 1 &&\\n\\t\\t\\t\\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n} );\\n\\n\\n\\n\\nvar rreturn = /\\\\r/g;\\n\\njQuery.fn.extend( {\\n\\tval: function( value ) {\\n\\t\\tvar hooks, ret, isFunction,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\thooks = jQuery.valHooks[ elem.type ] ||\\n\\t\\t\\t\\t\\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t\\tif ( hooks &&\\n\\t\\t\\t\\t\\t\"get\" in hooks &&\\n\\t\\t\\t\\t\\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tret = elem.value;\\n\\n\\t\\t\\t\\t// Handle most common string cases\\n\\t\\t\\t\\tif ( typeof ret === \"string\" ) {\\n\\t\\t\\t\\t\\treturn ret.replace( rreturn, \"\" );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Handle cases where value is null/undef or number\\n\\t\\t\\t\\treturn ret == null ? \"\" : ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tisFunction = jQuery.isFunction( value );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tvar val;\\n\\n\\t\\t\\tif ( this.nodeType !== 1 ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isFunction ) {\\n\\t\\t\\t\\tval = value.call( this, i, jQuery( this ).val() );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tval = value;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Treat null/undefined as \"\"; convert numbers to string\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\tval = \"\";\\n\\n\\t\\t\\t} else if ( typeof val === \"number\" ) {\\n\\t\\t\\t\\tval += \"\";\\n\\n\\t\\t\\t} else if ( Array.isArray( val ) ) {\\n\\t\\t\\t\\tval = jQuery.map( val, function( value ) {\\n\\t\\t\\t\\t\\treturn value == null ? \"\" : value + \"\";\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t// If set returns undefined, fall back to normal setting\\n\\t\\t\\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\\n\\t\\t\\t\\tthis.value = val;\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tvalHooks: {\\n\\t\\toption: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\tvar val = jQuery.find.attr( elem, \"value\" );\\n\\t\\t\\t\\treturn val != null ?\\n\\t\\t\\t\\t\\tval :\\n\\n\\t\\t\\t\\t\\t// Support: IE <=10 - 11 only\\n\\t\\t\\t\\t\\t// option.text throws exceptions (#14686, #14858)\\n\\t\\t\\t\\t\\t// Strip and collapse whitespace\\n\\t\\t\\t\\t\\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\\n\\t\\t\\t\\t\\tstripAndCollapse( jQuery.text( elem ) );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tselect: {\\n\\t\\t\\tget: function( elem ) {\\n\\t\\t\\t\\tvar value, option, i,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tindex = elem.selectedIndex,\\n\\t\\t\\t\\t\\tone = elem.type === \"select-one\",\\n\\t\\t\\t\\t\\tvalues = one ? null : [],\\n\\t\\t\\t\\t\\tmax = one ? index + 1 : options.length;\\n\\n\\t\\t\\t\\tif ( index < 0 ) {\\n\\t\\t\\t\\t\\ti = max;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ti = one ? index : 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Loop through all the selected options\\n\\t\\t\\t\\tfor ( ; i < max; i++ ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t// IE8-9 doesn\\'t update selected after form reset (#2551)\\n\\t\\t\\t\\t\\tif ( ( option.selected || i === index ) &&\\n\\n\\t\\t\\t\\t\\t\\t\\t// Don\\'t return options that are disabled or in a disabled optgroup\\n\\t\\t\\t\\t\\t\\t\\t!option.disabled &&\\n\\t\\t\\t\\t\\t\\t\\t( !option.parentNode.disabled ||\\n\\t\\t\\t\\t\\t\\t\\t\\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Get the specific value for the option\\n\\t\\t\\t\\t\\t\\tvalue = jQuery( option ).val();\\n\\n\\t\\t\\t\\t\\t\\t// We don\\'t need an array for one selects\\n\\t\\t\\t\\t\\t\\tif ( one ) {\\n\\t\\t\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Multi-Selects return an array\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tvar optionSet, option,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tvalues = jQuery.makeArray( value ),\\n\\t\\t\\t\\t\\ti = options.length;\\n\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t/* eslint-disable no-cond-assign */\\n\\n\\t\\t\\t\\t\\tif ( option.selected =\\n\\t\\t\\t\\t\\t\\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\toptionSet = true;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t/* eslint-enable no-cond-assign */\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Force browsers to behave consistently when non-matching value is set\\n\\t\\t\\t\\tif ( !optionSet ) {\\n\\t\\t\\t\\t\\telem.selectedIndex = -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Radios and checkboxes getter/setter\\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\\n\\tjQuery.valHooks[ this ] = {\\n\\t\\tset: function( elem, value ) {\\n\\t\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\t\\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tif ( !support.checkOn ) {\\n\\t\\tjQuery.valHooks[ this ].get = function( elem ) {\\n\\t\\t\\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Return jQuery for attributes-only inclusion\\n\\n\\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\\n\\njQuery.extend( jQuery.event, {\\n\\n\\ttrigger: function( event, data, elem, onlyHandlers ) {\\n\\n\\t\\tvar i, cur, tmp, bubbleType, ontype, handle, special,\\n\\t\\t\\teventPath = [ elem || document ],\\n\\t\\t\\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\\n\\t\\t\\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\\n\\n\\t\\tcur = tmp = elem = elem || document;\\n\\n\\t\\t// Don\\'t do events on text and comment nodes\\n\\t\\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// focus/blur morphs to focusin/out; ensure we\\'re not firing them right now\\n\\t\\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( type.indexOf( \".\" ) > -1 ) {\\n\\n\\t\\t\\t// Namespaced trigger; create a regexp to match event type in handle()\\n\\t\\t\\tnamespaces = type.split( \".\" );\\n\\t\\t\\ttype = namespaces.shift();\\n\\t\\t\\tnamespaces.sort();\\n\\t\\t}\\n\\t\\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\\n\\n\\t\\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\\n\\t\\tevent = event[ jQuery.expando ] ?\\n\\t\\t\\tevent :\\n\\t\\t\\tnew jQuery.Event( type, typeof event === \"object\" && event );\\n\\n\\t\\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\\n\\t\\tevent.isTrigger = onlyHandlers ? 2 : 3;\\n\\t\\tevent.namespace = namespaces.join( \".\" );\\n\\t\\tevent.rnamespace = event.namespace ?\\n\\t\\t\\tnew RegExp( \"(^|\\\\\\\\.)\" + namespaces.join( \"\\\\\\\\.(?:.*\\\\\\\\.|)\" ) + \"(\\\\\\\\.|$)\" ) :\\n\\t\\t\\tnull;\\n\\n\\t\\t// Clean up the event in case it is being reused\\n\\t\\tevent.result = undefined;\\n\\t\\tif ( !event.target ) {\\n\\t\\t\\tevent.target = elem;\\n\\t\\t}\\n\\n\\t\\t// Clone any incoming data and prepend the event, creating the handler arg list\\n\\t\\tdata = data == null ?\\n\\t\\t\\t[ event ] :\\n\\t\\t\\tjQuery.makeArray( data, [ event ] );\\n\\n\\t\\t// Allow special events to draw outside the lines\\n\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\t\\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\\n\\t\\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\tbubbleType = special.delegateType || type;\\n\\t\\t\\tif ( !rfocusMorph.test( bubbleType + type ) ) {\\n\\t\\t\\t\\tcur = cur.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( ; cur; cur = cur.parentNode ) {\\n\\t\\t\\t\\teventPath.push( cur );\\n\\t\\t\\t\\ttmp = cur;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\\n\\t\\t\\tif ( tmp === ( elem.ownerDocument || document ) ) {\\n\\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Fire handlers on the event path\\n\\t\\ti = 0;\\n\\t\\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\n\\t\\t\\tevent.type = i > 1 ?\\n\\t\\t\\t\\tbubbleType :\\n\\t\\t\\t\\tspecial.bindType || type;\\n\\n\\t\\t\\t// jQuery handler\\n\\t\\t\\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\\n\\t\\t\\t\\tdataPriv.get( cur, \"handle\" );\\n\\t\\t\\tif ( handle ) {\\n\\t\\t\\t\\thandle.apply( cur, data );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Native handler\\n\\t\\t\\thandle = ontype && cur[ ontype ];\\n\\t\\t\\tif ( handle && handle.apply && acceptData( cur ) ) {\\n\\t\\t\\t\\tevent.result = handle.apply( cur, data );\\n\\t\\t\\t\\tif ( event.result === false ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tevent.type = type;\\n\\n\\t\\t// If nobody prevented the default action, do it now\\n\\t\\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\\n\\n\\t\\t\\tif ( ( !special._default ||\\n\\t\\t\\t\\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\\n\\t\\t\\t\\tacceptData( elem ) ) {\\n\\n\\t\\t\\t\\t// Call a native DOM method on the target with the same name as the event.\\n\\t\\t\\t\\t// Don\\'t do default actions on window, that\\'s where global variables be (#6170)\\n\\t\\t\\t\\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// Don\\'t re-trigger an onFOO event when we call its FOO() method\\n\\t\\t\\t\\t\\ttmp = elem[ ontype ];\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prevent re-triggering of the same event, since we already bubbled it above\\n\\t\\t\\t\\t\\tjQuery.event.triggered = type;\\n\\t\\t\\t\\t\\telem[ type ]();\\n\\t\\t\\t\\t\\tjQuery.event.triggered = undefined;\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = tmp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\t// Piggyback on a donor event to simulate a different one\\n\\t// Used only for `focus(in | out)` events\\n\\tsimulate: function( type, elem, event ) {\\n\\t\\tvar e = jQuery.extend(\\n\\t\\t\\tnew jQuery.Event(),\\n\\t\\t\\tevent,\\n\\t\\t\\t{\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tisSimulated: true\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\tjQuery.event.trigger( e, null, elem );\\n\\t}\\n\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ttrigger: function( type, data ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.trigger( type, data, this );\\n\\t\\t} );\\n\\t},\\n\\ttriggerHandler: function( type, data ) {\\n\\t\\tvar elem = this[ 0 ];\\n\\t\\tif ( elem ) {\\n\\t\\t\\treturn jQuery.event.trigger( type, data, elem, true );\\n\\t\\t}\\n\\t}\\n} );\\n\\n\\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\\n\\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\\n\\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\\n\\tfunction( i, name ) {\\n\\n\\t// Handle event binding\\n\\tjQuery.fn[ name ] = function( data, fn ) {\\n\\t\\treturn arguments.length > 0 ?\\n\\t\\t\\tthis.on( name, null, data, fn ) :\\n\\t\\t\\tthis.trigger( name );\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\thover: function( fnOver, fnOut ) {\\n\\t\\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\\n\\t}\\n} );\\n\\n\\n\\n\\nsupport.focusin = \"onfocusin\" in window;\\n\\n\\n// Support: Firefox <=44\\n// Firefox doesn\\'t have focus(in | out) events\\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\\n//\\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\\n// focus(in | out) events fire after focus & blur events,\\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\\nif ( !support.focusin ) {\\n\\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\\n\\n\\t\\t// Attach a single capturing handler on the document while someone wants focusin/focusout\\n\\t\\tvar handler = function( event ) {\\n\\t\\t\\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\\n\\t\\t};\\n\\n\\t\\tjQuery.event.special[ fix ] = {\\n\\t\\t\\tsetup: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix );\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.addEventListener( orig, handler, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\\n\\t\\t\\t},\\n\\t\\t\\tteardown: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix ) - 1;\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.removeEventListener( orig, handler, true );\\n\\t\\t\\t\\t\\tdataPriv.remove( doc, fix );\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdataPriv.access( doc, fix, attaches );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} );\\n}\\nvar location = window.location;\\n\\nvar nonce = jQuery.now();\\n\\nvar rquery = ( /\\\\?/ );\\n\\n\\n\\n// Cross-browser xml parsing\\njQuery.parseXML = function( data ) {\\n\\tvar xml;\\n\\tif ( !data || typeof data !== \"string\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Support: IE 9 - 11 only\\n\\t// IE throws on parseFromString with invalid input.\\n\\ttry {\\n\\t\\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\\n\\t} catch ( e ) {\\n\\t\\txml = undefined;\\n\\t}\\n\\n\\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\\n\\t\\tjQuery.error( \"Invalid XML: \" + data );\\n\\t}\\n\\treturn xml;\\n};\\n\\n\\nvar\\n\\trbracket = /\\\\[\\\\]$/,\\n\\trCRLF = /\\\\r?\\\\n/g,\\n\\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\\n\\trsubmittable = /^(?:input|select|textarea|keygen)/i;\\n\\nfunction buildParams( prefix, obj, traditional, add ) {\\n\\tvar name;\\n\\n\\tif ( Array.isArray( obj ) ) {\\n\\n\\t\\t// Serialize array item.\\n\\t\\tjQuery.each( obj, function( i, v ) {\\n\\t\\t\\tif ( traditional || rbracket.test( prefix ) ) {\\n\\n\\t\\t\\t\\t// Treat each array item as a scalar.\\n\\t\\t\\t\\tadd( prefix, v );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Item is non-scalar (array or object), encode its numeric index.\\n\\t\\t\\t\\tbuildParams(\\n\\t\\t\\t\\t\\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\\n\\t\\t\\t\\t\\tv,\\n\\t\\t\\t\\t\\ttraditional,\\n\\t\\t\\t\\t\\tadd\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\\n\\n\\t\\t// Serialize object item.\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\\n\\t\\t}\\n\\n\\t} else {\\n\\n\\t\\t// Serialize scalar item.\\n\\t\\tadd( prefix, obj );\\n\\t}\\n}\\n\\n// Serialize an array of form elements or a set of\\n// key/values into a query string\\njQuery.param = function( a, traditional ) {\\n\\tvar prefix,\\n\\t\\ts = [],\\n\\t\\tadd = function( key, valueOrFunction ) {\\n\\n\\t\\t\\t// If value is a function, invoke it and use its return value\\n\\t\\t\\tvar value = jQuery.isFunction( valueOrFunction ) ?\\n\\t\\t\\t\\tvalueOrFunction() :\\n\\t\\t\\t\\tvalueOrFunction;\\n\\n\\t\\t\\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\\n\\t\\t\\t\\tencodeURIComponent( value == null ? \"\" : value );\\n\\t\\t};\\n\\n\\t// If an array was passed in, assume that it is an array of form elements.\\n\\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\\n\\n\\t\\t// Serialize the form elements\\n\\t\\tjQuery.each( a, function() {\\n\\t\\t\\tadd( this.name, this.value );\\n\\t\\t} );\\n\\n\\t} else {\\n\\n\\t\\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\\n\\t\\t// did it), otherwise encode params recursively.\\n\\t\\tfor ( prefix in a ) {\\n\\t\\t\\tbuildParams( prefix, a[ prefix ], traditional, add );\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the resulting serialization\\n\\treturn s.join( \"&\" );\\n};\\n\\njQuery.fn.extend( {\\n\\tserialize: function() {\\n\\t\\treturn jQuery.param( this.serializeArray() );\\n\\t},\\n\\tserializeArray: function() {\\n\\t\\treturn this.map( function() {\\n\\n\\t\\t\\t// Can add propHook for \"elements\" to filter or add form elements\\n\\t\\t\\tvar elements = jQuery.prop( this, \"elements\" );\\n\\t\\t\\treturn elements ? jQuery.makeArray( elements ) : this;\\n\\t\\t} )\\n\\t\\t.filter( function() {\\n\\t\\t\\tvar type = this.type;\\n\\n\\t\\t\\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\\n\\t\\t\\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\\n\\t\\t\\t\\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\\n\\t\\t\\t\\t( this.checked || !rcheckableType.test( type ) );\\n\\t\\t} )\\n\\t\\t.map( function( i, elem ) {\\n\\t\\t\\tvar val = jQuery( this ).val();\\n\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( Array.isArray( val ) ) {\\n\\t\\t\\t\\treturn jQuery.map( val, function( val ) {\\n\\t\\t\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \"\\\\r\\\\n\" ) };\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \"\\\\r\\\\n\" ) };\\n\\t\\t} ).get();\\n\\t}\\n} );\\n\\n\\nvar\\n\\tr20 = /%20/g,\\n\\trhash = /#.*$/,\\n\\trantiCache = /([?&])_=[^&]*/,\\n\\trheaders = /^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)$/mg,\\n\\n\\t// #7653, #8125, #8152: local protocol detection\\n\\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\\n\\trnoContent = /^(?:GET|HEAD)$/,\\n\\trprotocol = /^\\\\/\\\\//,\\n\\n\\t/* Prefilters\\n\\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\\n\\t * 2) These are called:\\n\\t *    - BEFORE asking for a transport\\n\\t *    - AFTER param serialization (s.data is a string if s.processData is true)\\n\\t * 3) key is the dataType\\n\\t * 4) the catchall symbol \"*\" can be used\\n\\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\\n\\t */\\n\\tprefilters = {},\\n\\n\\t/* Transports bindings\\n\\t * 1) key is the dataType\\n\\t * 2) the catchall symbol \"*\" can be used\\n\\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\\n\\t */\\n\\ttransports = {},\\n\\n\\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\\n\\tallTypes = \"*/\".concat( \"*\" ),\\n\\n\\t// Anchor tag for parsing the document origin\\n\\toriginAnchor = document.createElement( \"a\" );\\n\\toriginAnchor.href = location.href;\\n\\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\\nfunction addToPrefiltersOrTransports( structure ) {\\n\\n\\t// dataTypeExpression is optional and defaults to \"*\"\\n\\treturn function( dataTypeExpression, func ) {\\n\\n\\t\\tif ( typeof dataTypeExpression !== \"string\" ) {\\n\\t\\t\\tfunc = dataTypeExpression;\\n\\t\\t\\tdataTypeExpression = \"*\";\\n\\t\\t}\\n\\n\\t\\tvar dataType,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\\n\\n\\t\\tif ( jQuery.isFunction( func ) ) {\\n\\n\\t\\t\\t// For each dataType in the dataTypeExpression\\n\\t\\t\\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t// Prepend if requested\\n\\t\\t\\t\\tif ( dataType[ 0 ] === \"+\" ) {\\n\\t\\t\\t\\t\\tdataType = dataType.slice( 1 ) || \"*\";\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\\n\\n\\t\\t\\t\\t// Otherwise append\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\n// Base inspection function for prefilters and transports\\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\\n\\n\\tvar inspected = {},\\n\\t\\tseekingTransport = ( structure === transports );\\n\\n\\tfunction inspect( dataType ) {\\n\\t\\tvar selected;\\n\\t\\tinspected[ dataType ] = true;\\n\\t\\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\\n\\t\\t\\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\\n\\t\\t\\tif ( typeof dataTypeOrTransport === \"string\" &&\\n\\t\\t\\t\\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\\n\\n\\t\\t\\t\\toptions.dataTypes.unshift( dataTypeOrTransport );\\n\\t\\t\\t\\tinspect( dataTypeOrTransport );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if ( seekingTransport ) {\\n\\t\\t\\t\\treturn !( selected = dataTypeOrTransport );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\treturn selected;\\n\\t}\\n\\n\\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\\n}\\n\\n// A special extend for ajax options\\n// that takes \"flat\" options (not to be deep extended)\\n// Fixes #9887\\nfunction ajaxExtend( target, src ) {\\n\\tvar key, deep,\\n\\t\\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\\n\\n\\tfor ( key in src ) {\\n\\t\\tif ( src[ key ] !== undefined ) {\\n\\t\\t\\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\\n\\t\\t}\\n\\t}\\n\\tif ( deep ) {\\n\\t\\tjQuery.extend( true, target, deep );\\n\\t}\\n\\n\\treturn target;\\n}\\n\\n/* Handles responses to an ajax request:\\n * - finds the right dataType (mediates between content-type and expected dataType)\\n * - returns the corresponding response\\n */\\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\\n\\n\\tvar ct, type, finalDataType, firstDataType,\\n\\t\\tcontents = s.contents,\\n\\t\\tdataTypes = s.dataTypes;\\n\\n\\t// Remove auto dataType and get content-type in the process\\n\\twhile ( dataTypes[ 0 ] === \"*\" ) {\\n\\t\\tdataTypes.shift();\\n\\t\\tif ( ct === undefined ) {\\n\\t\\t\\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\\n\\t\\t}\\n\\t}\\n\\n\\t// Check if we\\'re dealing with a known content-type\\n\\tif ( ct ) {\\n\\t\\tfor ( type in contents ) {\\n\\t\\t\\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\\n\\t\\t\\t\\tdataTypes.unshift( type );\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Check to see if we have a response for the expected dataType\\n\\tif ( dataTypes[ 0 ] in responses ) {\\n\\t\\tfinalDataType = dataTypes[ 0 ];\\n\\t} else {\\n\\n\\t\\t// Try convertible dataTypes\\n\\t\\tfor ( type in responses ) {\\n\\t\\t\\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\\n\\t\\t\\t\\tfinalDataType = type;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( !firstDataType ) {\\n\\t\\t\\t\\tfirstDataType = type;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Or just use first one\\n\\t\\tfinalDataType = finalDataType || firstDataType;\\n\\t}\\n\\n\\t// If we found a dataType\\n\\t// We add the dataType to the list if needed\\n\\t// and return the corresponding response\\n\\tif ( finalDataType ) {\\n\\t\\tif ( finalDataType !== dataTypes[ 0 ] ) {\\n\\t\\t\\tdataTypes.unshift( finalDataType );\\n\\t\\t}\\n\\t\\treturn responses[ finalDataType ];\\n\\t}\\n}\\n\\n/* Chain conversions given the request and the original response\\n * Also sets the responseXXX fields on the jqXHR instance\\n */\\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\\n\\tvar conv2, current, conv, tmp, prev,\\n\\t\\tconverters = {},\\n\\n\\t\\t// Work with a copy of dataTypes in case we need to modify it for conversion\\n\\t\\tdataTypes = s.dataTypes.slice();\\n\\n\\t// Create converters map with lowercased keys\\n\\tif ( dataTypes[ 1 ] ) {\\n\\t\\tfor ( conv in s.converters ) {\\n\\t\\t\\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\\n\\t\\t}\\n\\t}\\n\\n\\tcurrent = dataTypes.shift();\\n\\n\\t// Convert to each sequential dataType\\n\\twhile ( current ) {\\n\\n\\t\\tif ( s.responseFields[ current ] ) {\\n\\t\\t\\tjqXHR[ s.responseFields[ current ] ] = response;\\n\\t\\t}\\n\\n\\t\\t// Apply the dataFilter if provided\\n\\t\\tif ( !prev && isSuccess && s.dataFilter ) {\\n\\t\\t\\tresponse = s.dataFilter( response, s.dataType );\\n\\t\\t}\\n\\n\\t\\tprev = current;\\n\\t\\tcurrent = dataTypes.shift();\\n\\n\\t\\tif ( current ) {\\n\\n\\t\\t\\t// There\\'s only work to do if current dataType is non-auto\\n\\t\\t\\tif ( current === \"*\" ) {\\n\\n\\t\\t\\t\\tcurrent = prev;\\n\\n\\t\\t\\t// Convert response if prev dataType is non-auto and differs from current\\n\\t\\t\\t} else if ( prev !== \"*\" && prev !== current ) {\\n\\n\\t\\t\\t\\t// Seek a direct converter\\n\\t\\t\\t\\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\\n\\n\\t\\t\\t\\t// If none found, seek a pair\\n\\t\\t\\t\\tif ( !conv ) {\\n\\t\\t\\t\\t\\tfor ( conv2 in converters ) {\\n\\n\\t\\t\\t\\t\\t\\t// If conv2 outputs current\\n\\t\\t\\t\\t\\t\\ttmp = conv2.split( \" \" );\\n\\t\\t\\t\\t\\t\\tif ( tmp[ 1 ] === current ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// If prev can be converted to accepted input\\n\\t\\t\\t\\t\\t\\t\\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tconverters[ \"* \" + tmp[ 0 ] ];\\n\\t\\t\\t\\t\\t\\t\\tif ( conv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Condense equivalence converters\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( conv === true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tconv = converters[ conv2 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Otherwise, insert the intermediate dataType\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if ( converters[ conv2 ] !== true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrent = tmp[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdataTypes.unshift( tmp[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Apply converter (if not an equivalence)\\n\\t\\t\\t\\tif ( conv !== true ) {\\n\\n\\t\\t\\t\\t\\t// Unless errors are allowed to bubble, catch and return them\\n\\t\\t\\t\\t\\tif ( conv && s.throws ) {\\n\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\tstate: \"parsererror\",\\n\\t\\t\\t\\t\\t\\t\\t\\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn { state: \"success\", data: response };\\n}\\n\\njQuery.extend( {\\n\\n\\t// Counter for holding the number of active queries\\n\\tactive: 0,\\n\\n\\t// Last-Modified header cache for next request\\n\\tlastModified: {},\\n\\tetag: {},\\n\\n\\tajaxSettings: {\\n\\t\\turl: location.href,\\n\\t\\ttype: \"GET\",\\n\\t\\tisLocal: rlocalProtocol.test( location.protocol ),\\n\\t\\tglobal: true,\\n\\t\\tprocessData: true,\\n\\t\\tasync: true,\\n\\t\\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\\n\\n\\t\\t/*\\n\\t\\ttimeout: 0,\\n\\t\\tdata: null,\\n\\t\\tdataType: null,\\n\\t\\tusername: null,\\n\\t\\tpassword: null,\\n\\t\\tcache: null,\\n\\t\\tthrows: false,\\n\\t\\ttraditional: false,\\n\\t\\theaders: {},\\n\\t\\t*/\\n\\n\\t\\taccepts: {\\n\\t\\t\\t\"*\": allTypes,\\n\\t\\t\\ttext: \"text/plain\",\\n\\t\\t\\thtml: \"text/html\",\\n\\t\\t\\txml: \"application/xml, text/xml\",\\n\\t\\t\\tjson: \"application/json, text/javascript\"\\n\\t\\t},\\n\\n\\t\\tcontents: {\\n\\t\\t\\txml: /\\\\bxml\\\\b/,\\n\\t\\t\\thtml: /\\\\bhtml/,\\n\\t\\t\\tjson: /\\\\bjson\\\\b/\\n\\t\\t},\\n\\n\\t\\tresponseFields: {\\n\\t\\t\\txml: \"responseXML\",\\n\\t\\t\\ttext: \"responseText\",\\n\\t\\t\\tjson: \"responseJSON\"\\n\\t\\t},\\n\\n\\t\\t// Data converters\\n\\t\\t// Keys separate source (or catchall \"*\") and destination types with a single space\\n\\t\\tconverters: {\\n\\n\\t\\t\\t// Convert anything to text\\n\\t\\t\\t\"* text\": String,\\n\\n\\t\\t\\t// Text to html (true = no transformation)\\n\\t\\t\\t\"text html\": true,\\n\\n\\t\\t\\t// Evaluate text as a json expression\\n\\t\\t\\t\"text json\": JSON.parse,\\n\\n\\t\\t\\t// Parse text as xml\\n\\t\\t\\t\"text xml\": jQuery.parseXML\\n\\t\\t},\\n\\n\\t\\t// For options that shouldn\\'t be deep extended:\\n\\t\\t// you can add your own custom options here if\\n\\t\\t// and when you create one that shouldn\\'t be\\n\\t\\t// deep extended (see ajaxExtend)\\n\\t\\tflatOptions: {\\n\\t\\t\\turl: true,\\n\\t\\t\\tcontext: true\\n\\t\\t}\\n\\t},\\n\\n\\t// Creates a full fledged settings object into target\\n\\t// with both ajaxSettings and settings fields.\\n\\t// If target is omitted, writes into ajaxSettings.\\n\\tajaxSetup: function( target, settings ) {\\n\\t\\treturn settings ?\\n\\n\\t\\t\\t// Building a settings object\\n\\t\\t\\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\\n\\n\\t\\t\\t// Extending ajaxSettings\\n\\t\\t\\tajaxExtend( jQuery.ajaxSettings, target );\\n\\t},\\n\\n\\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\\n\\tajaxTransport: addToPrefiltersOrTransports( transports ),\\n\\n\\t// Main method\\n\\tajax: function( url, options ) {\\n\\n\\t\\t// If url is an object, simulate pre-1.5 signature\\n\\t\\tif ( typeof url === \"object\" ) {\\n\\t\\t\\toptions = url;\\n\\t\\t\\turl = undefined;\\n\\t\\t}\\n\\n\\t\\t// Force options to be an object\\n\\t\\toptions = options || {};\\n\\n\\t\\tvar transport,\\n\\n\\t\\t\\t// URL without anti-cache param\\n\\t\\t\\tcacheURL,\\n\\n\\t\\t\\t// Response headers\\n\\t\\t\\tresponseHeadersString,\\n\\t\\t\\tresponseHeaders,\\n\\n\\t\\t\\t// timeout handle\\n\\t\\t\\ttimeoutTimer,\\n\\n\\t\\t\\t// Url cleanup var\\n\\t\\t\\turlAnchor,\\n\\n\\t\\t\\t// Request state (becomes false upon send and true upon completion)\\n\\t\\t\\tcompleted,\\n\\n\\t\\t\\t// To know if global events are to be dispatched\\n\\t\\t\\tfireGlobals,\\n\\n\\t\\t\\t// Loop variable\\n\\t\\t\\ti,\\n\\n\\t\\t\\t// uncached part of the url\\n\\t\\t\\tuncached,\\n\\n\\t\\t\\t// Create the final options object\\n\\t\\t\\ts = jQuery.ajaxSetup( {}, options ),\\n\\n\\t\\t\\t// Callbacks context\\n\\t\\t\\tcallbackContext = s.context || s,\\n\\n\\t\\t\\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\\n\\t\\t\\tglobalEventContext = s.context &&\\n\\t\\t\\t\\t( callbackContext.nodeType || callbackContext.jquery ) ?\\n\\t\\t\\t\\t\\tjQuery( callbackContext ) :\\n\\t\\t\\t\\t\\tjQuery.event,\\n\\n\\t\\t\\t// Deferreds\\n\\t\\t\\tdeferred = jQuery.Deferred(),\\n\\t\\t\\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tstatusCode = s.statusCode || {},\\n\\n\\t\\t\\t// Headers (they are sent all at once)\\n\\t\\t\\trequestHeaders = {},\\n\\t\\t\\trequestHeadersNames = {},\\n\\n\\t\\t\\t// Default abort message\\n\\t\\t\\tstrAbort = \"canceled\",\\n\\n\\t\\t\\t// Fake xhr\\n\\t\\t\\tjqXHR = {\\n\\t\\t\\t\\treadyState: 0,\\n\\n\\t\\t\\t\\t// Builds headers hashtable if needed\\n\\t\\t\\t\\tgetResponseHeader: function( key ) {\\n\\t\\t\\t\\t\\tvar match;\\n\\t\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\t\\tif ( !responseHeaders ) {\\n\\t\\t\\t\\t\\t\\t\\tresponseHeaders = {};\\n\\t\\t\\t\\t\\t\\t\\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmatch = responseHeaders[ key.toLowerCase() ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn match == null ? null : match;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Raw string\\n\\t\\t\\t\\tgetAllResponseHeaders: function() {\\n\\t\\t\\t\\t\\treturn completed ? responseHeadersString : null;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Caches the header\\n\\t\\t\\t\\tsetRequestHeader: function( name, value ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\tname = requestHeadersNames[ name.toLowerCase() ] =\\n\\t\\t\\t\\t\\t\\t\\trequestHeadersNames[ name.toLowerCase() ] || name;\\n\\t\\t\\t\\t\\t\\trequestHeaders[ name ] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Overrides response content-type header\\n\\t\\t\\t\\toverrideMimeType: function( type ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\ts.mimeType = type;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\t\\tstatusCode: function( map ) {\\n\\t\\t\\t\\t\\tvar code;\\n\\t\\t\\t\\t\\tif ( map ) {\\n\\t\\t\\t\\t\\t\\tif ( completed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Execute the appropriate callbacks\\n\\t\\t\\t\\t\\t\\t\\tjqXHR.always( map[ jqXHR.status ] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Lazy-add the new callbacks in a way that preserves old ones\\n\\t\\t\\t\\t\\t\\t\\tfor ( code in map ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Cancel the request\\n\\t\\t\\t\\tabort: function( statusText ) {\\n\\t\\t\\t\\t\\tvar finalText = statusText || strAbort;\\n\\t\\t\\t\\t\\tif ( transport ) {\\n\\t\\t\\t\\t\\t\\ttransport.abort( finalText );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdone( 0, finalText );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t// Attach deferreds\\n\\t\\tdeferred.promise( jqXHR );\\n\\n\\t\\t// Add protocol if not provided (prefilters might expect it)\\n\\t\\t// Handle falsy url in the settings object (#10093: consistency with old signature)\\n\\t\\t// We also use the url parameter if available\\n\\t\\ts.url = ( ( url || s.url || location.href ) + \"\" )\\n\\t\\t\\t.replace( rprotocol, location.protocol + \"//\" );\\n\\n\\t\\t// Alias method option to type as per ticket #12004\\n\\t\\ts.type = options.method || options.type || s.method || s.type;\\n\\n\\t\\t// Extract dataTypes list\\n\\t\\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\\n\\n\\t\\t// A cross-domain request is in order when the origin doesn\\'t match the current origin.\\n\\t\\tif ( s.crossDomain == null ) {\\n\\t\\t\\turlAnchor = document.createElement( \"a\" );\\n\\n\\t\\t\\t// Support: IE <=8 - 11, Edge 12 - 13\\n\\t\\t\\t// IE throws exception on accessing the href property if url is malformed,\\n\\t\\t\\t// e.g. http://example.com:80x/\\n\\t\\t\\ttry {\\n\\t\\t\\t\\turlAnchor.href = s.url;\\n\\n\\t\\t\\t\\t// Support: IE <=8 - 11 only\\n\\t\\t\\t\\t// Anchor\\'s host property isn\\'t correctly set when s.url is relative\\n\\t\\t\\t\\turlAnchor.href = urlAnchor.href;\\n\\t\\t\\t\\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\\n\\t\\t\\t\\t\\turlAnchor.protocol + \"//\" + urlAnchor.host;\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// If there is an error parsing the URL, assume it is crossDomain,\\n\\t\\t\\t\\t// it can be rejected by the transport if it is invalid\\n\\t\\t\\t\\ts.crossDomain = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Convert data if not already a string\\n\\t\\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\\n\\t\\t\\ts.data = jQuery.param( s.data, s.traditional );\\n\\t\\t}\\n\\n\\t\\t// Apply prefilters\\n\\t\\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\\n\\n\\t\\t// If request was aborted inside a prefilter, stop there\\n\\t\\tif ( completed ) {\\n\\t\\t\\treturn jqXHR;\\n\\t\\t}\\n\\n\\t\\t// We can fire global events as of now if asked to\\n\\t\\t// Don\\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\\n\\t\\tfireGlobals = jQuery.event && s.global;\\n\\n\\t\\t// Watch for a new set of requests\\n\\t\\tif ( fireGlobals && jQuery.active++ === 0 ) {\\n\\t\\t\\tjQuery.event.trigger( \"ajaxStart\" );\\n\\t\\t}\\n\\n\\t\\t// Uppercase the type\\n\\t\\ts.type = s.type.toUpperCase();\\n\\n\\t\\t// Determine if request has content\\n\\t\\ts.hasContent = !rnoContent.test( s.type );\\n\\n\\t\\t// Save the URL in case we\\'re toying with the If-Modified-Since\\n\\t\\t// and/or If-None-Match header later on\\n\\t\\t// Remove hash to simplify url manipulation\\n\\t\\tcacheURL = s.url.replace( rhash, \"\" );\\n\\n\\t\\t// More options handling for requests with no content\\n\\t\\tif ( !s.hasContent ) {\\n\\n\\t\\t\\t// Remember the hash so we can put it back\\n\\t\\t\\tuncached = s.url.slice( cacheURL.length );\\n\\n\\t\\t\\t// If data is available, append data to url\\n\\t\\t\\tif ( s.data ) {\\n\\t\\t\\t\\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\\n\\n\\t\\t\\t\\t// #9682: remove data so that it\\'s not used in an eventual retry\\n\\t\\t\\t\\tdelete s.data;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add or update anti-cache param if needed\\n\\t\\t\\tif ( s.cache === false ) {\\n\\t\\t\\t\\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\\n\\t\\t\\t\\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\\n\\t\\t\\ts.url = cacheURL + uncached;\\n\\n\\t\\t// Change \\'%20\\' to \\'+\\' if this is encoded form body content (gh-2658)\\n\\t\\t} else if ( s.data && s.processData &&\\n\\t\\t\\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\\n\\t\\t\\ts.data = s.data.replace( r20, \"+\" );\\n\\t\\t}\\n\\n\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\tif ( s.ifModified ) {\\n\\t\\t\\tif ( jQuery.lastModified[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t\\tif ( jQuery.etag[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Set the correct header, if data is being sent\\n\\t\\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\\n\\t\\t\\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\\n\\t\\t}\\n\\n\\t\\t// Set the Accepts header for the server, depending on the dataType\\n\\t\\tjqXHR.setRequestHeader(\\n\\t\\t\\t\"Accept\",\\n\\t\\t\\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\\n\\t\\t\\t\\ts.accepts[ s.dataTypes[ 0 ] ] +\\n\\t\\t\\t\\t\\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\\n\\t\\t\\t\\ts.accepts[ \"*\" ]\\n\\t\\t);\\n\\n\\t\\t// Check for headers option\\n\\t\\tfor ( i in s.headers ) {\\n\\t\\t\\tjqXHR.setRequestHeader( i, s.headers[ i ] );\\n\\t\\t}\\n\\n\\t\\t// Allow custom headers/mimetypes and early abort\\n\\t\\tif ( s.beforeSend &&\\n\\t\\t\\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\\n\\n\\t\\t\\t// Abort if not done already and return\\n\\t\\t\\treturn jqXHR.abort();\\n\\t\\t}\\n\\n\\t\\t// Aborting is no longer a cancellation\\n\\t\\tstrAbort = \"abort\";\\n\\n\\t\\t// Install callbacks on deferreds\\n\\t\\tcompleteDeferred.add( s.complete );\\n\\t\\tjqXHR.done( s.success );\\n\\t\\tjqXHR.fail( s.error );\\n\\n\\t\\t// Get transport\\n\\t\\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\\n\\n\\t\\t// If no transport, we auto-abort\\n\\t\\tif ( !transport ) {\\n\\t\\t\\tdone( -1, \"No Transport\" );\\n\\t\\t} else {\\n\\t\\t\\tjqXHR.readyState = 1;\\n\\n\\t\\t\\t// Send global event\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If request was aborted inside ajaxSend, stop there\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn jqXHR;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Timeout\\n\\t\\t\\tif ( s.async && s.timeout > 0 ) {\\n\\t\\t\\t\\ttimeoutTimer = window.setTimeout( function() {\\n\\t\\t\\t\\t\\tjqXHR.abort( \"timeout\" );\\n\\t\\t\\t\\t}, s.timeout );\\n\\t\\t\\t}\\n\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tcompleted = false;\\n\\t\\t\\t\\ttransport.send( requestHeaders, done );\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// Rethrow post-completion exceptions\\n\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Propagate others as results\\n\\t\\t\\t\\tdone( -1, e );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Callback for when everything is done\\n\\t\\tfunction done( status, nativeStatusText, responses, headers ) {\\n\\t\\t\\tvar isSuccess, success, error, response, modified,\\n\\t\\t\\t\\tstatusText = nativeStatusText;\\n\\n\\t\\t\\t// Ignore repeat invocations\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcompleted = true;\\n\\n\\t\\t\\t// Clear timeout if it exists\\n\\t\\t\\tif ( timeoutTimer ) {\\n\\t\\t\\t\\twindow.clearTimeout( timeoutTimer );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Dereference transport for early garbage collection\\n\\t\\t\\t// (no matter how long the jqXHR object will be used)\\n\\t\\t\\ttransport = undefined;\\n\\n\\t\\t\\t// Cache response headers\\n\\t\\t\\tresponseHeadersString = headers || \"\";\\n\\n\\t\\t\\t// Set readyState\\n\\t\\t\\tjqXHR.readyState = status > 0 ? 4 : 0;\\n\\n\\t\\t\\t// Determine if successful\\n\\t\\t\\tisSuccess = status >= 200 && status < 300 || status === 304;\\n\\n\\t\\t\\t// Get response data\\n\\t\\t\\tif ( responses ) {\\n\\t\\t\\t\\tresponse = ajaxHandleResponses( s, jqXHR, responses );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert no matter what (that way responseXXX fields are always set)\\n\\t\\t\\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\\n\\n\\t\\t\\t// If successful, handle type chaining\\n\\t\\t\\tif ( isSuccess ) {\\n\\n\\t\\t\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\t\\t\\tif ( s.ifModified ) {\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.lastModified[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \"etag\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.etag[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if no content\\n\\t\\t\\t\\tif ( status === 204 || s.type === \"HEAD\" ) {\\n\\t\\t\\t\\t\\tstatusText = \"nocontent\";\\n\\n\\t\\t\\t\\t// if not modified\\n\\t\\t\\t\\t} else if ( status === 304 ) {\\n\\t\\t\\t\\t\\tstatusText = \"notmodified\";\\n\\n\\t\\t\\t\\t// If we have data, let\\'s convert it\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstatusText = response.state;\\n\\t\\t\\t\\t\\tsuccess = response.data;\\n\\t\\t\\t\\t\\terror = response.error;\\n\\t\\t\\t\\t\\tisSuccess = !error;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Extract error from statusText and normalize for non-aborts\\n\\t\\t\\t\\terror = statusText;\\n\\t\\t\\t\\tif ( status || !statusText ) {\\n\\t\\t\\t\\t\\tstatusText = \"error\";\\n\\t\\t\\t\\t\\tif ( status < 0 ) {\\n\\t\\t\\t\\t\\t\\tstatus = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set data for the fake xhr object\\n\\t\\t\\tjqXHR.status = status;\\n\\t\\t\\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\\n\\n\\t\\t\\t// Success/Error\\n\\t\\t\\tif ( isSuccess ) {\\n\\t\\t\\t\\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tjqXHR.statusCode( statusCode );\\n\\t\\t\\tstatusCode = undefined;\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\\n\\t\\t\\t\\t\\t[ jqXHR, s, isSuccess ? success : error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Complete\\n\\t\\t\\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\\n\\n\\t\\t\\t\\t// Handle the global AJAX counter\\n\\t\\t\\t\\tif ( !( --jQuery.active ) ) {\\n\\t\\t\\t\\t\\tjQuery.event.trigger( \"ajaxStop\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn jqXHR;\\n\\t},\\n\\n\\tgetJSON: function( url, data, callback ) {\\n\\t\\treturn jQuery.get( url, data, callback, \"json\" );\\n\\t},\\n\\n\\tgetScript: function( url, callback ) {\\n\\t\\treturn jQuery.get( url, undefined, callback, \"script\" );\\n\\t}\\n} );\\n\\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\\n\\tjQuery[ method ] = function( url, data, callback, type ) {\\n\\n\\t\\t// Shift arguments if data argument was omitted\\n\\t\\tif ( jQuery.isFunction( data ) ) {\\n\\t\\t\\ttype = type || callback;\\n\\t\\t\\tcallback = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\n\\t\\t// The url can be an options object (which then must have .url)\\n\\t\\treturn jQuery.ajax( jQuery.extend( {\\n\\t\\t\\turl: url,\\n\\t\\t\\ttype: method,\\n\\t\\t\\tdataType: type,\\n\\t\\t\\tdata: data,\\n\\t\\t\\tsuccess: callback\\n\\t\\t}, jQuery.isPlainObject( url ) && url ) );\\n\\t};\\n} );\\n\\n\\njQuery._evalUrl = function( url ) {\\n\\treturn jQuery.ajax( {\\n\\t\\turl: url,\\n\\n\\t\\t// Make this explicit, since user can override this through ajaxSetup (#11264)\\n\\t\\ttype: \"GET\",\\n\\t\\tdataType: \"script\",\\n\\t\\tcache: true,\\n\\t\\tasync: false,\\n\\t\\tglobal: false,\\n\\t\\t\"throws\": true\\n\\t} );\\n};\\n\\n\\njQuery.fn.extend( {\\n\\twrapAll: function( html ) {\\n\\t\\tvar wrap;\\n\\n\\t\\tif ( this[ 0 ] ) {\\n\\t\\t\\tif ( jQuery.isFunction( html ) ) {\\n\\t\\t\\t\\thtml = html.call( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// The elements to wrap the target around\\n\\t\\t\\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\\n\\n\\t\\t\\tif ( this[ 0 ].parentNode ) {\\n\\t\\t\\t\\twrap.insertBefore( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\twrap.map( function() {\\n\\t\\t\\t\\tvar elem = this;\\n\\n\\t\\t\\t\\twhile ( elem.firstElementChild ) {\\n\\t\\t\\t\\t\\telem = elem.firstElementChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn elem;\\n\\t\\t\\t} ).append( this );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\twrapInner: function( html ) {\\n\\t\\tif ( jQuery.isFunction( html ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).wrapInner( html.call( this, i ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar self = jQuery( this ),\\n\\t\\t\\t\\tcontents = self.contents();\\n\\n\\t\\t\\tif ( contents.length ) {\\n\\t\\t\\t\\tcontents.wrapAll( html );\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tself.append( html );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\twrap: function( html ) {\\n\\t\\tvar isFunction = jQuery.isFunction( html );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\\n\\t\\t} );\\n\\t},\\n\\n\\tunwrap: function( selector ) {\\n\\t\\tthis.parent( selector ).not( \"body\" ).each( function() {\\n\\t\\t\\tjQuery( this ).replaceWith( this.childNodes );\\n\\t\\t} );\\n\\t\\treturn this;\\n\\t}\\n} );\\n\\n\\njQuery.expr.pseudos.hidden = function( elem ) {\\n\\treturn !jQuery.expr.pseudos.visible( elem );\\n};\\njQuery.expr.pseudos.visible = function( elem ) {\\n\\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\\n};\\n\\n\\n\\n\\njQuery.ajaxSettings.xhr = function() {\\n\\ttry {\\n\\t\\treturn new window.XMLHttpRequest();\\n\\t} catch ( e ) {}\\n};\\n\\nvar xhrSuccessStatus = {\\n\\n\\t\\t// File protocol always yields status code 0, assume 200\\n\\t\\t0: 200,\\n\\n\\t\\t// Support: IE <=9 only\\n\\t\\t// #1450: sometimes IE returns 1223 when it should be 204\\n\\t\\t1223: 204\\n\\t},\\n\\txhrSupported = jQuery.ajaxSettings.xhr();\\n\\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\\nsupport.ajax = xhrSupported = !!xhrSupported;\\n\\njQuery.ajaxTransport( function( options ) {\\n\\tvar callback, errorCallback;\\n\\n\\t// Cross domain only allowed if supported through XMLHttpRequest\\n\\tif ( support.cors || xhrSupported && !options.crossDomain ) {\\n\\t\\treturn {\\n\\t\\t\\tsend: function( headers, complete ) {\\n\\t\\t\\t\\tvar i,\\n\\t\\t\\t\\t\\txhr = options.xhr();\\n\\n\\t\\t\\t\\txhr.open(\\n\\t\\t\\t\\t\\toptions.type,\\n\\t\\t\\t\\t\\toptions.url,\\n\\t\\t\\t\\t\\toptions.async,\\n\\t\\t\\t\\t\\toptions.username,\\n\\t\\t\\t\\t\\toptions.password\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Apply custom fields if provided\\n\\t\\t\\t\\tif ( options.xhrFields ) {\\n\\t\\t\\t\\t\\tfor ( i in options.xhrFields ) {\\n\\t\\t\\t\\t\\t\\txhr[ i ] = options.xhrFields[ i ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Override mime type if needed\\n\\t\\t\\t\\tif ( options.mimeType && xhr.overrideMimeType ) {\\n\\t\\t\\t\\t\\txhr.overrideMimeType( options.mimeType );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// X-Requested-With header\\n\\t\\t\\t\\t// For cross-domain requests, seeing as conditions for a preflight are\\n\\t\\t\\t\\t// akin to a jigsaw puzzle, we simply never set it to be sure.\\n\\t\\t\\t\\t// (it can always be set on a per-request basis or even using ajaxSetup)\\n\\t\\t\\t\\t// For same-domain requests, won\\'t change header if already provided.\\n\\t\\t\\t\\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\\n\\t\\t\\t\\t\\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Set headers\\n\\t\\t\\t\\tfor ( i in headers ) {\\n\\t\\t\\t\\t\\txhr.setRequestHeader( i, headers[ i ] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Callback\\n\\t\\t\\t\\tcallback = function( type ) {\\n\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\tcallback = errorCallback = xhr.onload =\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( type === \"abort\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.abort();\\n\\t\\t\\t\\t\\t\\t\\t} else if ( type === \"error\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// On a manual native abort, IE9 throws\\n\\t\\t\\t\\t\\t\\t\\t\\t// errors on any property access that is not readyState\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( typeof xhr.status !== \"number\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete( 0, \"error\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// File: protocol always yields status 0; see #8605, #14207\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhrSuccessStatus[ xhr.status ] || xhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// IE9 has no XHR2 but throws on binary (trac-11426)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// For XHR2 non-text, let the caller handle it (gh-2498)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( xhr.responseType || \"text\" ) !== \"text\"  ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof xhr.responseText !== \"string\" ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ binary: xhr.response } :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ text: xhr.responseText },\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.getAllResponseHeaders()\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// Listen to events\\n\\t\\t\\t\\txhr.onload = callback();\\n\\t\\t\\t\\terrorCallback = xhr.onerror = callback( \"error\" );\\n\\n\\t\\t\\t\\t// Support: IE 9 only\\n\\t\\t\\t\\t// Use onreadystatechange to replace onabort\\n\\t\\t\\t\\t// to handle uncaught aborts\\n\\t\\t\\t\\tif ( xhr.onabort !== undefined ) {\\n\\t\\t\\t\\t\\txhr.onabort = errorCallback;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\txhr.onreadystatechange = function() {\\n\\n\\t\\t\\t\\t\\t\\t// Check readyState before timeout as it changes\\n\\t\\t\\t\\t\\t\\tif ( xhr.readyState === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Allow onerror to be called first,\\n\\t\\t\\t\\t\\t\\t\\t// but that will not handle a native abort\\n\\t\\t\\t\\t\\t\\t\\t// Also, save errorCallback to a variable\\n\\t\\t\\t\\t\\t\\t\\t// as xhr.onerror cannot be accessed\\n\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\terrorCallback();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Create the abort callback\\n\\t\\t\\t\\tcallback = callback( \"abort\" );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\t// Do send the request (this may raise an exception)\\n\\t\\t\\t\\t\\txhr.send( options.hasContent && options.data || null );\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t// #14683: Only rethrow if this hasn\\'t been notified as an error yet\\n\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\\njQuery.ajaxPrefilter( function( s ) {\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.contents.script = false;\\n\\t}\\n} );\\n\\n// Install script dataType\\njQuery.ajaxSetup( {\\n\\taccepts: {\\n\\t\\tscript: \"text/javascript, application/javascript, \" +\\n\\t\\t\\t\"application/ecmascript, application/x-ecmascript\"\\n\\t},\\n\\tcontents: {\\n\\t\\tscript: /\\\\b(?:java|ecma)script\\\\b/\\n\\t},\\n\\tconverters: {\\n\\t\\t\"text script\": function( text ) {\\n\\t\\t\\tjQuery.globalEval( text );\\n\\t\\t\\treturn text;\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Handle cache\\'s special case and crossDomain\\njQuery.ajaxPrefilter( \"script\", function( s ) {\\n\\tif ( s.cache === undefined ) {\\n\\t\\ts.cache = false;\\n\\t}\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.type = \"GET\";\\n\\t}\\n} );\\n\\n// Bind script tag hack transport\\njQuery.ajaxTransport( \"script\", function( s ) {\\n\\n\\t// This transport only deals with cross domain requests\\n\\tif ( s.crossDomain ) {\\n\\t\\tvar script, callback;\\n\\t\\treturn {\\n\\t\\t\\tsend: function( _, complete ) {\\n\\t\\t\\t\\tscript = jQuery( \"<script>\" ).prop( {\\n\\t\\t\\t\\t\\tcharset: s.scriptCharset,\\n\\t\\t\\t\\t\\tsrc: s.url\\n\\t\\t\\t\\t} ).on(\\n\\t\\t\\t\\t\\t\"load error\",\\n\\t\\t\\t\\t\\tcallback = function( evt ) {\\n\\t\\t\\t\\t\\t\\tscript.remove();\\n\\t\\t\\t\\t\\t\\tcallback = null;\\n\\t\\t\\t\\t\\t\\tif ( evt ) {\\n\\t\\t\\t\\t\\t\\t\\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Use native DOM manipulation to avoid our domManip AJAX trickery\\n\\t\\t\\t\\tdocument.head.appendChild( script[ 0 ] );\\n\\t\\t\\t},\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\nvar oldCallbacks = [],\\n\\trjsonp = /(=)\\\\?(?=&|$)|\\\\?\\\\?/;\\n\\n// Default jsonp settings\\njQuery.ajaxSetup( {\\n\\tjsonp: \"callback\",\\n\\tjsonpCallback: function() {\\n\\t\\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\\n\\t\\tthis[ callback ] = true;\\n\\t\\treturn callback;\\n\\t}\\n} );\\n\\n// Detect, normalize options and install callbacks for jsonp requests\\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\\n\\n\\tvar callbackName, overwritten, responseContainer,\\n\\t\\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\\n\\t\\t\\t\"url\" :\\n\\t\\t\\ttypeof s.data === \"string\" &&\\n\\t\\t\\t\\t( s.contentType || \"\" )\\n\\t\\t\\t\\t\\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\\n\\t\\t\\t\\trjsonp.test( s.data ) && \"data\"\\n\\t\\t);\\n\\n\\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\\n\\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\\n\\n\\t\\t// Get callback name, remembering preexisting value associated with it\\n\\t\\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\\n\\t\\t\\ts.jsonpCallback() :\\n\\t\\t\\ts.jsonpCallback;\\n\\n\\t\\t// Insert callback into url or form data\\n\\t\\tif ( jsonProp ) {\\n\\t\\t\\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\\n\\t\\t} else if ( s.jsonp !== false ) {\\n\\t\\t\\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\\n\\t\\t}\\n\\n\\t\\t// Use data converter to retrieve json after script execution\\n\\t\\ts.converters[ \"script json\" ] = function() {\\n\\t\\t\\tif ( !responseContainer ) {\\n\\t\\t\\t\\tjQuery.error( callbackName + \" was not called\" );\\n\\t\\t\\t}\\n\\t\\t\\treturn responseContainer[ 0 ];\\n\\t\\t};\\n\\n\\t\\t// Force json dataType\\n\\t\\ts.dataTypes[ 0 ] = \"json\";\\n\\n\\t\\t// Install callback\\n\\t\\toverwritten = window[ callbackName ];\\n\\t\\twindow[ callbackName ] = function() {\\n\\t\\t\\tresponseContainer = arguments;\\n\\t\\t};\\n\\n\\t\\t// Clean-up function (fires after converters)\\n\\t\\tjqXHR.always( function() {\\n\\n\\t\\t\\t// If previous value didn\\'t exist - remove it\\n\\t\\t\\tif ( overwritten === undefined ) {\\n\\t\\t\\t\\tjQuery( window ).removeProp( callbackName );\\n\\n\\t\\t\\t// Otherwise restore preexisting value\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twindow[ callbackName ] = overwritten;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save back as free\\n\\t\\t\\tif ( s[ callbackName ] ) {\\n\\n\\t\\t\\t\\t// Make sure that re-using the options doesn\\'t screw things around\\n\\t\\t\\t\\ts.jsonpCallback = originalSettings.jsonpCallback;\\n\\n\\t\\t\\t\\t// Save the callback name for future use\\n\\t\\t\\t\\toldCallbacks.push( callbackName );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Call if it was a function and we have a response\\n\\t\\t\\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\\n\\t\\t\\t\\toverwritten( responseContainer[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\tresponseContainer = overwritten = undefined;\\n\\t\\t} );\\n\\n\\t\\t// Delegate to script\\n\\t\\treturn \"script\";\\n\\t}\\n} );\\n\\n\\n\\n\\n// Support: Safari 8 only\\n// In Safari 8 documents created via document.implementation.createHTMLDocument\\n// collapse sibling forms: the second one becomes a child of the first one.\\n// Because of that, this security measure has to be disabled in Safari 8.\\n// https://bugs.webkit.org/show_bug.cgi?id=137337\\nsupport.createHTMLDocument = ( function() {\\n\\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\\n\\tbody.innerHTML = \"<form></form><form></form>\";\\n\\treturn body.childNodes.length === 2;\\n} )();\\n\\n\\n// Argument \"data\" should be string of html\\n// context (optional): If specified, the fragment will be created in this context,\\n// defaults to document\\n// keepScripts (optional): If true, will include scripts passed in the html string\\njQuery.parseHTML = function( data, context, keepScripts ) {\\n\\tif ( typeof data !== \"string\" ) {\\n\\t\\treturn [];\\n\\t}\\n\\tif ( typeof context === \"boolean\" ) {\\n\\t\\tkeepScripts = context;\\n\\t\\tcontext = false;\\n\\t}\\n\\n\\tvar base, parsed, scripts;\\n\\n\\tif ( !context ) {\\n\\n\\t\\t// Stop scripts or inline event handlers from being executed immediately\\n\\t\\t// by using document.implementation\\n\\t\\tif ( support.createHTMLDocument ) {\\n\\t\\t\\tcontext = document.implementation.createHTMLDocument( \"\" );\\n\\n\\t\\t\\t// Set the base href for the created document\\n\\t\\t\\t// so any parsed elements with URLs\\n\\t\\t\\t// are based on the document\\'s URL (gh-2965)\\n\\t\\t\\tbase = context.createElement( \"base\" );\\n\\t\\t\\tbase.href = document.location.href;\\n\\t\\t\\tcontext.head.appendChild( base );\\n\\t\\t} else {\\n\\t\\t\\tcontext = document;\\n\\t\\t}\\n\\t}\\n\\n\\tparsed = rsingleTag.exec( data );\\n\\tscripts = !keepScripts && [];\\n\\n\\t// Single tag\\n\\tif ( parsed ) {\\n\\t\\treturn [ context.createElement( parsed[ 1 ] ) ];\\n\\t}\\n\\n\\tparsed = buildFragment( [ data ], context, scripts );\\n\\n\\tif ( scripts && scripts.length ) {\\n\\t\\tjQuery( scripts ).remove();\\n\\t}\\n\\n\\treturn jQuery.merge( [], parsed.childNodes );\\n};\\n\\n\\n/**\\n * Load a url into a page\\n */\\njQuery.fn.load = function( url, params, callback ) {\\n\\tvar selector, type, response,\\n\\t\\tself = this,\\n\\t\\toff = url.indexOf( \" \" );\\n\\n\\tif ( off > -1 ) {\\n\\t\\tselector = stripAndCollapse( url.slice( off ) );\\n\\t\\turl = url.slice( 0, off );\\n\\t}\\n\\n\\t// If it\\'s a function\\n\\tif ( jQuery.isFunction( params ) ) {\\n\\n\\t\\t// We assume that it\\'s the callback\\n\\t\\tcallback = params;\\n\\t\\tparams = undefined;\\n\\n\\t// Otherwise, build a param string\\n\\t} else if ( params && typeof params === \"object\" ) {\\n\\t\\ttype = \"POST\";\\n\\t}\\n\\n\\t// If we have elements to modify, make the request\\n\\tif ( self.length > 0 ) {\\n\\t\\tjQuery.ajax( {\\n\\t\\t\\turl: url,\\n\\n\\t\\t\\t// If \"type\" variable is undefined, then \"GET\" method will be used.\\n\\t\\t\\t// Make value of this field explicit since\\n\\t\\t\\t// user can override it through ajaxSetup method\\n\\t\\t\\ttype: type || \"GET\",\\n\\t\\t\\tdataType: \"html\",\\n\\t\\t\\tdata: params\\n\\t\\t} ).done( function( responseText ) {\\n\\n\\t\\t\\t// Save response for use in complete callback\\n\\t\\t\\tresponse = arguments;\\n\\n\\t\\t\\tself.html( selector ?\\n\\n\\t\\t\\t\\t// If a selector was specified, locate the right elements in a dummy div\\n\\t\\t\\t\\t// Exclude scripts to avoid IE \\'Permission Denied\\' errors\\n\\t\\t\\t\\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\\n\\n\\t\\t\\t\\t// Otherwise use the full result\\n\\t\\t\\t\\tresponseText );\\n\\n\\t\\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\\n\\t\\t// but they are ignored because response was set above.\\n\\t\\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\\n\\t\\t} ).always( callback && function( jqXHR, status ) {\\n\\t\\t\\tself.each( function() {\\n\\t\\t\\t\\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\treturn this;\\n};\\n\\n\\n\\n\\n// Attach a bunch of functions for handling common AJAX events\\njQuery.each( [\\n\\t\"ajaxStart\",\\n\\t\"ajaxStop\",\\n\\t\"ajaxComplete\",\\n\\t\"ajaxError\",\\n\\t\"ajaxSuccess\",\\n\\t\"ajaxSend\"\\n], function( i, type ) {\\n\\tjQuery.fn[ type ] = function( fn ) {\\n\\t\\treturn this.on( type, fn );\\n\\t};\\n} );\\n\\n\\n\\n\\njQuery.expr.pseudos.animated = function( elem ) {\\n\\treturn jQuery.grep( jQuery.timers, function( fn ) {\\n\\t\\treturn elem === fn.elem;\\n\\t} ).length;\\n};\\n\\n\\n\\n\\njQuery.offset = {\\n\\tsetOffset: function( elem, options, i ) {\\n\\t\\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\\n\\t\\t\\tposition = jQuery.css( elem, \"position\" ),\\n\\t\\t\\tcurElem = jQuery( elem ),\\n\\t\\t\\tprops = {};\\n\\n\\t\\t// Set position first, in-case top/left are set even on static elem\\n\\t\\tif ( position === \"static\" ) {\\n\\t\\t\\telem.style.position = \"relative\";\\n\\t\\t}\\n\\n\\t\\tcurOffset = curElem.offset();\\n\\t\\tcurCSSTop = jQuery.css( elem, \"top\" );\\n\\t\\tcurCSSLeft = jQuery.css( elem, \"left\" );\\n\\t\\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\\n\\t\\t\\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\\n\\n\\t\\t// Need to be able to calculate position if either\\n\\t\\t// top or left is auto and position is either absolute or fixed\\n\\t\\tif ( calculatePosition ) {\\n\\t\\t\\tcurPosition = curElem.position();\\n\\t\\t\\tcurTop = curPosition.top;\\n\\t\\t\\tcurLeft = curPosition.left;\\n\\n\\t\\t} else {\\n\\t\\t\\tcurTop = parseFloat( curCSSTop ) || 0;\\n\\t\\t\\tcurLeft = parseFloat( curCSSLeft ) || 0;\\n\\t\\t}\\n\\n\\t\\tif ( jQuery.isFunction( options ) ) {\\n\\n\\t\\t\\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\\n\\t\\t\\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\\n\\t\\t}\\n\\n\\t\\tif ( options.top != null ) {\\n\\t\\t\\tprops.top = ( options.top - curOffset.top ) + curTop;\\n\\t\\t}\\n\\t\\tif ( options.left != null ) {\\n\\t\\t\\tprops.left = ( options.left - curOffset.left ) + curLeft;\\n\\t\\t}\\n\\n\\t\\tif ( \"using\" in options ) {\\n\\t\\t\\toptions.using.call( elem, props );\\n\\n\\t\\t} else {\\n\\t\\t\\tcurElem.css( props );\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.fn.extend( {\\n\\toffset: function( options ) {\\n\\n\\t\\t// Preserve chaining for setter\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\treturn options === undefined ?\\n\\t\\t\\t\\tthis :\\n\\t\\t\\t\\tthis.each( function( i ) {\\n\\t\\t\\t\\t\\tjQuery.offset.setOffset( this, options, i );\\n\\t\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tvar doc, docElem, rect, win,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\\n\\t\\t// Support: IE <=11 only\\n\\t\\t// Running getBoundingClientRect on a\\n\\t\\t// disconnected node in IE throws an error\\n\\t\\tif ( !elem.getClientRects().length ) {\\n\\t\\t\\treturn { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t\\trect = elem.getBoundingClientRect();\\n\\n\\t\\tdoc = elem.ownerDocument;\\n\\t\\tdocElem = doc.documentElement;\\n\\t\\twin = doc.defaultView;\\n\\n\\t\\treturn {\\n\\t\\t\\ttop: rect.top + win.pageYOffset - docElem.clientTop,\\n\\t\\t\\tleft: rect.left + win.pageXOffset - docElem.clientLeft\\n\\t\\t};\\n\\t},\\n\\n\\tposition: function() {\\n\\t\\tif ( !this[ 0 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar offsetParent, offset,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tparentOffset = { top: 0, left: 0 };\\n\\n\\t\\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\\n\\t\\t// because it is its only offset parent\\n\\t\\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\\n\\n\\t\\t\\t// Assume getBoundingClientRect is there when computed position is fixed\\n\\t\\t\\toffset = elem.getBoundingClientRect();\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// Get *real* offsetParent\\n\\t\\t\\toffsetParent = this.offsetParent();\\n\\n\\t\\t\\t// Get correct offsets\\n\\t\\t\\toffset = this.offset();\\n\\t\\t\\tif ( !nodeName( offsetParent[ 0 ], \"html\" ) ) {\\n\\t\\t\\t\\tparentOffset = offsetParent.offset();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add offsetParent borders\\n\\t\\t\\tparentOffset = {\\n\\t\\t\\t\\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\\n\\t\\t\\t\\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Subtract parent offsets and element margins\\n\\t\\treturn {\\n\\t\\t\\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\\n\\t\\t\\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\\n\\t\\t};\\n\\t},\\n\\n\\t// This method will return documentElement in the following cases:\\n\\t// 1) For the element inside the iframe without offsetParent, this method will return\\n\\t//    documentElement of the parent window\\n\\t// 2) For the hidden or detached element\\n\\t// 3) For body or html element, i.e. in case of the html node - it will return itself\\n\\t//\\n\\t// but those exceptions were never presented as a real life use-cases\\n\\t// and might be considered as more preferable results.\\n\\t//\\n\\t// This logic, however, is not guaranteed and can change at any point in the future\\n\\toffsetParent: function() {\\n\\t\\treturn this.map( function() {\\n\\t\\t\\tvar offsetParent = this.offsetParent;\\n\\n\\t\\t\\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\\n\\t\\t\\t\\toffsetParent = offsetParent.offsetParent;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn offsetParent || documentElement;\\n\\t\\t} );\\n\\t}\\n} );\\n\\n// Create scrollLeft and scrollTop methods\\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\\n\\tvar top = \"pageYOffset\" === prop;\\n\\n\\tjQuery.fn[ method ] = function( val ) {\\n\\t\\treturn access( this, function( elem, method, val ) {\\n\\n\\t\\t\\t// Coalesce documents and windows\\n\\t\\t\\tvar win;\\n\\t\\t\\tif ( jQuery.isWindow( elem ) ) {\\n\\t\\t\\t\\twin = elem;\\n\\t\\t\\t} else if ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\twin = elem.defaultView;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( val === undefined ) {\\n\\t\\t\\t\\treturn win ? win[ prop ] : elem[ method ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( win ) {\\n\\t\\t\\t\\twin.scrollTo(\\n\\t\\t\\t\\t\\t!top ? val : win.pageXOffset,\\n\\t\\t\\t\\t\\ttop ? val : win.pageYOffset\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telem[ method ] = val;\\n\\t\\t\\t}\\n\\t\\t}, method, val, arguments.length );\\n\\t};\\n} );\\n\\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\\n// Add the top/left cssHooks using jQuery.fn.position\\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\\n// getComputedStyle returns percent when specified for top/left/bottom/right;\\n// rather than make the css module depend on the offset module, just check for it here\\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\\n\\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\\n\\t\\tfunction( elem, computed ) {\\n\\t\\t\\tif ( computed ) {\\n\\t\\t\\t\\tcomputed = curCSS( elem, prop );\\n\\n\\t\\t\\t\\t// If curCSS returns percentage, fallback to offset\\n\\t\\t\\t\\treturn rnumnonpx.test( computed ) ?\\n\\t\\t\\t\\t\\tjQuery( elem ).position()[ prop ] + \"px\" :\\n\\t\\t\\t\\t\\tcomputed;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t);\\n} );\\n\\n\\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\\n\\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\\n\\t\\tfunction( defaultExtra, funcName ) {\\n\\n\\t\\t// Margin is only for outerHeight, outerWidth\\n\\t\\tjQuery.fn[ funcName ] = function( margin, value ) {\\n\\t\\t\\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\\n\\t\\t\\t\\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\\n\\n\\t\\t\\treturn access( this, function( elem, type, value ) {\\n\\t\\t\\t\\tvar doc;\\n\\n\\t\\t\\t\\tif ( jQuery.isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\\n\\t\\t\\t\\t\\treturn funcName.indexOf( \"outer\" ) === 0 ?\\n\\t\\t\\t\\t\\t\\telem[ \"inner\" + name ] :\\n\\t\\t\\t\\t\\t\\telem.document.documentElement[ \"client\" + name ];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Get document width or height\\n\\t\\t\\t\\tif ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\t\\tdoc = elem.documentElement;\\n\\n\\t\\t\\t\\t\\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\\n\\t\\t\\t\\t\\t// whichever is greatest\\n\\t\\t\\t\\t\\treturn Math.max(\\n\\t\\t\\t\\t\\t\\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\\n\\t\\t\\t\\t\\t\\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\\n\\t\\t\\t\\t\\t\\tdoc[ \"client\" + name ]\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn value === undefined ?\\n\\n\\t\\t\\t\\t\\t// Get width or height on the element, requesting but not forcing parseFloat\\n\\t\\t\\t\\t\\tjQuery.css( elem, type, extra ) :\\n\\n\\t\\t\\t\\t\\t// Set width or height on the element\\n\\t\\t\\t\\t\\tjQuery.style( elem, type, value, extra );\\n\\t\\t\\t}, type, chainable ? margin : undefined, chainable );\\n\\t\\t};\\n\\t} );\\n} );\\n\\n\\njQuery.fn.extend( {\\n\\n\\tbind: function( types, data, fn ) {\\n\\t\\treturn this.on( types, null, data, fn );\\n\\t},\\n\\tunbind: function( types, fn ) {\\n\\t\\treturn this.off( types, null, fn );\\n\\t},\\n\\n\\tdelegate: function( selector, types, data, fn ) {\\n\\t\\treturn this.on( types, selector, data, fn );\\n\\t},\\n\\tundelegate: function( selector, types, fn ) {\\n\\n\\t\\t// ( namespace ) or ( selector, types [, fn] )\\n\\t\\treturn arguments.length === 1 ?\\n\\t\\t\\tthis.off( selector, \"**\" ) :\\n\\t\\t\\tthis.off( types, selector || \"**\", fn );\\n\\t}\\n} );\\n\\njQuery.holdReady = function( hold ) {\\n\\tif ( hold ) {\\n\\t\\tjQuery.readyWait++;\\n\\t} else {\\n\\t\\tjQuery.ready( true );\\n\\t}\\n};\\njQuery.isArray = Array.isArray;\\njQuery.parseJSON = JSON.parse;\\njQuery.nodeName = nodeName;\\n\\n\\n\\n\\n// Register as a named AMD module, since jQuery can be concatenated with other\\n// files that may use define, but not via a proper concatenation script that\\n// understands anonymous AMD modules. A named AMD is safest and most robust\\n// way to register. Lowercase jquery is used because AMD module names are\\n// derived from file names, and jQuery is normally delivered in a lowercase\\n// file name. Do this after creating the global so that if an AMD module wants\\n// to call noConflict to hide this version of jQuery, it will work.\\n\\n// Note that for maximum portability, libraries that are not jQuery should\\n// declare themselves as anonymous modules, and avoid setting a global if an\\n// AMD loader is present. jQuery is a special case. For more information, see\\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\\n\\nif ( true ) {\\n\\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\\n\\t\\treturn jQuery;\\n\\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n}\\n\\n\\n\\n\\nvar\\n\\n\\t// Map over jQuery in case of overwrite\\n\\t_jQuery = window.jQuery,\\n\\n\\t// Map over the $ in case of overwrite\\n\\t_$ = window.$;\\n\\njQuery.noConflict = function( deep ) {\\n\\tif ( window.$ === jQuery ) {\\n\\t\\twindow.$ = _$;\\n\\t}\\n\\n\\tif ( deep && window.jQuery === jQuery ) {\\n\\t\\twindow.jQuery = _jQuery;\\n\\t}\\n\\n\\treturn jQuery;\\n};\\n\\n// Expose jQuery and $ identifiers, even in AMD\\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\\n// and CommonJS for browser emulators (#13566)\\nif ( !noGlobal ) {\\n\\twindow.jQuery = window.$ = jQuery;\\n}\\n\\n\\n\\n\\nreturn jQuery;\\n} );\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanM/ZWVkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMi4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wMy0yMFQxODo1OVpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMi4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZyxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdFx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHRcdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdFx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDgtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiAoXCJmb3JtXCIgaW4gZWxlbSB8fCBcImxhYmVsXCIgaW4gZWxlbSk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW1wbGUgc2VsZWN0b3IgdGhhdCBjYW4gYmUgZmlsdGVyZWQgZGlyZWN0bHksIHJlbW92aW5nIG5vbi1FbGVtZW50c1xuXHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdH1cblxuXHQvLyBDb21wbGV4IHNlbGVjdG9yLCBjb21wYXJlIHRoZSB0d28gc2V0cywgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG5cdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdCAmJiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgalF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsXG5cdFx0c2NhbGUgPSAxLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBqUXVlcnkuaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgbm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggXCI+dGJvZHlcIiwgZWxlbSApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ0b3A6MSU7d2lkdGg6NTAlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZGl2U3R5bGUubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCI7XG5cdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcHJvcGVydHkgbWFwcGVkIGFsb25nIHdoYXQgalF1ZXJ5LmNzc1Byb3BzIHN1Z2dlc3RzIG9yIHRvXG4vLyBhIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXTtcblx0aWYgKCAhcmV0ICkge1xuXHRcdHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xuXHR9XG5cdHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGksXG5cdFx0dmFsID0gMDtcblxuXHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0aWYgKCBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdGkgPSA0O1xuXG5cdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0fSBlbHNlIHtcblx0XHRpID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgdmFsdWVJc0JvcmRlckJveCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcblx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9IZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdGlmICggdmFsID09PSBcImF1dG9cIiApIHtcblx0XHR2YWwgPSBlbGVtWyBcIm9mZnNldFwiICsgbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICkgXTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRqUXVlcnkucHJveHkoIHJlc3VsdC5zdG9wLCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jLCBkb2NFbGVtLCByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdHdpbiA9IGRvYy5kZWZhdWx0VmlldztcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7XG5cdFx0XHRcdHRvcDogcGFyZW50T2Zmc2V0LnRvcCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKSxcblx0XHRcdFx0bGVmdDogcGFyZW50T2Zmc2V0LmxlZnQgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDEyNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1259\\n')\n},1260:function(module,exports){eval('module.exports = \"<section fxFlex=\\\\\"100%\\\\\" fxLayout=\\\\\"column\\\\\" fxLayoutAlign=\\\\\"start center\\\\\">\\\\n  <header class=\\\\\"container margin-top-20\\\\\">\\\\n    <a routerLink=\\\\\"/blogedit\\\\\" routerLinkActive=\\\\\"active\\\\\" class=\\\\\"text-shadow-dark-2\\\\\" md-button>\\\\n      <md-icon class=\\\\\"text-dark\\\\\">add</md-icon> Add Blog\\\\n    </a>\\\\n  </header>\\\\n\\\\n  <div class=\\\\\"containerX\\\\\" fxFlex=\\\\\"100%\\\\\" fxLayoutAlign=\\\\\"center center\\\\\">\\\\n    <div class=\\\\\"container\\\\\">\\\\n      <div class=\\\\\"margin-top-20 margin-bottom-20\\\\\" fxFlex=\\\\\"100%\\\\\" fxLayoutAlign=\\\\\"space-around stretch\\\\\">\\\\n\\\\n        <md-card class=\\\\\"box-shadow-dark-3 overflow-auto\\\\\" fxFlex=\\\\\"32%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxLayout=\\\\\"column\\\\\">\\\\n          <md-card-header>\\\\n            <md-card-title>CSS动画</md-card-title>2017-05-19 07:35:11\\\\n          </md-card-header>\\\\n\\\\n          <md-card-content>\\\\n            <div>\\\\n              Transform, Transtion, Animation\\\\n              <div class=\\\\\"css-animation\\\\\"></div>\\\\n              <pre>\\\\n              <code class=\\\\\"javascript\\\\\">\\\\nlet a = 2;\\\\n              </code>\\\\n            </pre>\\\\n            </div>\\\\n          </md-card-content>\\\\n        </md-card>\\\\n\\\\n        <md-card class=\\\\\"box-shadow-dark-3 css-gradient overflow-auto\\\\\" fxFlex=\\\\\"32%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxlayout=\\\\\"column\\\\\">\\\\n          <md-card-header>\\\\n            <md-card-title>CSS渐变</md-card-title>2017-05-19 07:35:21\\\\n          </md-card-header>\\\\n\\\\n          <md-card-content class=\\\\\"css-gradienst\\\\\">\\\\n            <pre>\\\\n              <code class=\\\\\"css\\\\\">\\\\n                {{cssGradienst}}\\\\n              </code>\\\\n            </pre>\\\\n          </md-card-content>\\\\n        </md-card>\\\\n\\\\n        <md-card class=\\\\\"box-shadow-dark-3 overflow-auto\\\\\" fxFlex=\\\\\"32%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxLayout=\\\\\"column\\\\\">\\\\n          <md-card-header>\\\\n            <md-card-title>Card布局</md-card-title>2017-05-19 07:35:24\\\\n          </md-card-header>\\\\n\\\\n          <md-card-content>\\\\n            <pre>\\\\n              <code class=\\\\\"html\\\\\">\\\\n                {{cardhtml}}\\\\n              </code>\\\\n            </pre>\\\\n          </md-card-content>\\\\n        </md-card>\\\\n      </div>\\\\n    </div>\\\\n  </div>\\\\n\\\\n</section>\";//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYmxvZy1saXN0L2Jsb2ctbGlzdC5jb21wb25lbnQuaHRtbD9hMjI3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8c2VjdGlvbiBmeEZsZXg9XFxcIjEwMCVcXFwiIGZ4TGF5b3V0PVxcXCJjb2x1bW5cXFwiIGZ4TGF5b3V0QWxpZ249XFxcInN0YXJ0IGNlbnRlclxcXCI+XFxuICA8aGVhZGVyIGNsYXNzPVxcXCJjb250YWluZXIgbWFyZ2luLXRvcC0yMFxcXCI+XFxuICAgIDxhIHJvdXRlckxpbms9XFxcIi9ibG9nZWRpdFxcXCIgcm91dGVyTGlua0FjdGl2ZT1cXFwiYWN0aXZlXFxcIiBjbGFzcz1cXFwidGV4dC1zaGFkb3ctZGFyay0yXFxcIiBtZC1idXR0b24+XFxuICAgICAgPG1kLWljb24gY2xhc3M9XFxcInRleHQtZGFya1xcXCI+YWRkPC9tZC1pY29uPiBBZGQgQmxvZ1xcbiAgICA8L2E+XFxuICA8L2hlYWRlcj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclhcXFwiIGZ4RmxleD1cXFwiMTAwJVxcXCIgZnhMYXlvdXRBbGlnbj1cXFwiY2VudGVyIGNlbnRlclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibWFyZ2luLXRvcC0yMCBtYXJnaW4tYm90dG9tLTIwXFxcIiBmeEZsZXg9XFxcIjEwMCVcXFwiIGZ4TGF5b3V0QWxpZ249XFxcInNwYWNlLWFyb3VuZCBzdHJldGNoXFxcIj5cXG5cXG4gICAgICAgIDxtZC1jYXJkIGNsYXNzPVxcXCJib3gtc2hhZG93LWRhcmstMyBvdmVyZmxvdy1hdXRvXFxcIiBmeEZsZXg9XFxcIjMyJVxcXCIgZnhGbGV4Lmx0LXNtPVxcXCIxMDAlXFxcIiBmeExheW91dD1cXFwiY29sdW1uXFxcIj5cXG4gICAgICAgICAgPG1kLWNhcmQtaGVhZGVyPlxcbiAgICAgICAgICAgIDxtZC1jYXJkLXRpdGxlPkNTU+WKqOeUuzwvbWQtY2FyZC10aXRsZT4yMDE3LTA1LTE5IDA3OjM1OjExXFxuICAgICAgICAgIDwvbWQtY2FyZC1oZWFkZXI+XFxuXFxuICAgICAgICAgIDxtZC1jYXJkLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPGRpdj5cXG4gICAgICAgICAgICAgIFRyYW5zZm9ybSwgVHJhbnN0aW9uLCBBbmltYXRpb25cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNzcy1hbmltYXRpb25cXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgPHByZT5cXG4gICAgICAgICAgICAgIDxjb2RlIGNsYXNzPVxcXCJqYXZhc2NyaXB0XFxcIj5cXG5sZXQgYSA9IDI7XFxuICAgICAgICAgICAgICA8L2NvZGU+XFxuICAgICAgICAgICAgPC9wcmU+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvbWQtY2FyZC1jb250ZW50PlxcbiAgICAgICAgPC9tZC1jYXJkPlxcblxcbiAgICAgICAgPG1kLWNhcmQgY2xhc3M9XFxcImJveC1zaGFkb3ctZGFyay0zIGNzcy1ncmFkaWVudCBvdmVyZmxvdy1hdXRvXFxcIiBmeEZsZXg9XFxcIjMyJVxcXCIgZnhGbGV4Lmx0LXNtPVxcXCIxMDAlXFxcIiBmeGxheW91dD1cXFwiY29sdW1uXFxcIj5cXG4gICAgICAgICAgPG1kLWNhcmQtaGVhZGVyPlxcbiAgICAgICAgICAgIDxtZC1jYXJkLXRpdGxlPkNTU+a4kOWPmDwvbWQtY2FyZC10aXRsZT4yMDE3LTA1LTE5IDA3OjM1OjIxXFxuICAgICAgICAgIDwvbWQtY2FyZC1oZWFkZXI+XFxuXFxuICAgICAgICAgIDxtZC1jYXJkLWNvbnRlbnQgY2xhc3M9XFxcImNzcy1ncmFkaWVuc3RcXFwiPlxcbiAgICAgICAgICAgIDxwcmU+XFxuICAgICAgICAgICAgICA8Y29kZSBjbGFzcz1cXFwiY3NzXFxcIj5cXG4gICAgICAgICAgICAgICAge3tjc3NHcmFkaWVuc3R9fVxcbiAgICAgICAgICAgICAgPC9jb2RlPlxcbiAgICAgICAgICAgIDwvcHJlPlxcbiAgICAgICAgICA8L21kLWNhcmQtY29udGVudD5cXG4gICAgICAgIDwvbWQtY2FyZD5cXG5cXG4gICAgICAgIDxtZC1jYXJkIGNsYXNzPVxcXCJib3gtc2hhZG93LWRhcmstMyBvdmVyZmxvdy1hdXRvXFxcIiBmeEZsZXg9XFxcIjMyJVxcXCIgZnhGbGV4Lmx0LXNtPVxcXCIxMDAlXFxcIiBmeExheW91dD1cXFwiY29sdW1uXFxcIj5cXG4gICAgICAgICAgPG1kLWNhcmQtaGVhZGVyPlxcbiAgICAgICAgICAgIDxtZC1jYXJkLXRpdGxlPkNhcmTluIPlsYA8L21kLWNhcmQtdGl0bGU+MjAxNy0wNS0xOSAwNzozNToyNFxcbiAgICAgICAgICA8L21kLWNhcmQtaGVhZGVyPlxcblxcbiAgICAgICAgICA8bWQtY2FyZC1jb250ZW50PlxcbiAgICAgICAgICAgIDxwcmU+XFxuICAgICAgICAgICAgICA8Y29kZSBjbGFzcz1cXFwiaHRtbFxcXCI+XFxuICAgICAgICAgICAgICAgIHt7Y2FyZGh0bWx9fVxcbiAgICAgICAgICAgICAgPC9jb2RlPlxcbiAgICAgICAgICAgIDwvcHJlPlxcbiAgICAgICAgICA8L21kLWNhcmQtY29udGVudD5cXG4gICAgICAgIDwvbWQtY2FyZD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG5cXG48L3NlY3Rpb24+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2Jsb2ctbGlzdC9ibG9nLWxpc3QuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDEyNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1260\\n')},1261:function(module,exports){eval('module.exports = \".css-gradient {\\\\n  background: linear-gradient(to bottom left, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9)); }\\\\n\\\\n.container {\\\\n  max-width: 1200px; }\\\\n\\\\n.overflow-auto {\\\\n  overflow: auto; }\\\\n\\\\n.css-animation {\\\\n  background: linear-gradient(to bottom left, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9));\\\\n  width: 100px;\\\\n  height: 100px;\\\\n  animation: cv-css-rotate 1s linear 3s infinite alternate; }\\\\n\\\\n@keyframes cv-css-rotate {\\\\n  0% {\\\\n    background: linear-gradient(to bottom right, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9));\\\\n    transform: rotate(0); }\\\\n  25% {\\\\n    background: linear-gradient(to bottom left, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9));\\\\n    transform: rotate(90deg); }\\\\n  50% {\\\\n    background: linear-gradient(to top left, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9));\\\\n    transform: rotate(180deg); }\\\\n  75% {\\\\n    transform: rotate(90deg);\\\\n    background: linear-gradient(to top right, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9)); }\\\\n  100% {\\\\n    transform: rotate(0deg);\\\\n    background: linear-gradient(to bottom right, rgba(142, 246, 228, 0.9), rgba(51, 204, 204, 0.9)); } }\\\\n\"//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYmxvZy1saXN0L2Jsb2ctbGlzdC5jb21wb25lbnQuc2Nzcz84MDhmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIuY3NzLWdyYWRpZW50IHtcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20gbGVmdCwgcmdiYSgxNDIsIDI0NiwgMjI4LCAwLjkpLCByZ2JhKDUxLCAyMDQsIDIwNCwgMC45KSk7IH1cXG5cXG4uY29udGFpbmVyIHtcXG4gIG1heC13aWR0aDogMTIwMHB4OyB9XFxuXFxuLm92ZXJmbG93LWF1dG8ge1xcbiAgb3ZlcmZsb3c6IGF1dG87IH1cXG5cXG4uY3NzLWFuaW1hdGlvbiB7XFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tIGxlZnQsIHJnYmEoMTQyLCAyNDYsIDIyOCwgMC45KSwgcmdiYSg1MSwgMjA0LCAyMDQsIDAuOSkpO1xcbiAgd2lkdGg6IDEwMHB4O1xcbiAgaGVpZ2h0OiAxMDBweDtcXG4gIGFuaW1hdGlvbjogY3YtY3NzLXJvdGF0ZSAxcyBsaW5lYXIgM3MgaW5maW5pdGUgYWx0ZXJuYXRlOyB9XFxuXFxuQGtleWZyYW1lcyBjdi1jc3Mtcm90YXRlIHtcXG4gIDAlIHtcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSByaWdodCwgcmdiYSgxNDIsIDI0NiwgMjI4LCAwLjkpLCByZ2JhKDUxLCAyMDQsIDIwNCwgMC45KSk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDApOyB9XFxuICAyNSUge1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tIGxlZnQsIHJnYmEoMTQyLCAyNDYsIDIyOCwgMC45KSwgcmdiYSg1MSwgMjA0LCAyMDQsIDAuOSkpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7IH1cXG4gIDUwJSB7XFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byB0b3AgbGVmdCwgcmdiYSgxNDIsIDI0NiwgMjI4LCAwLjkpLCByZ2JhKDUxLCAyMDQsIDIwNCwgMC45KSk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7IH1cXG4gIDc1JSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHRvcCByaWdodCwgcmdiYSgxNDIsIDI0NiwgMjI4LCAwLjkpLCByZ2JhKDUxLCAyMDQsIDIwNCwgMC45KSk7IH1cXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSByaWdodCwgcmdiYSgxNDIsIDI0NiwgMjI4LCAwLjkpLCByZ2JhKDUxLCAyMDQsIDIwNCwgMC45KSk7IH0gfVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2Jsb2ctbGlzdC9ibG9nLWxpc3QuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDEyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1261\\n')},1262:function(module,exports,__webpack_require__){\"use strict\";eval(\"\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \\\"object\\\" && typeof Reflect.decorate === \\\"function\\\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar Quill = __webpack_require__(360);\\r\\n__webpack_require__(1263);\\r\\nvar BlogEditComponent = (function () {\\r\\n    function BlogEditComponent() {\\r\\n    }\\r\\n    BlogEditComponent.prototype.ngOnInit = function () {\\r\\n        console.warn('edit');\\r\\n        this.initEditor();\\r\\n    };\\r\\n    BlogEditComponent.prototype.initEditor = function () {\\r\\n        var toolbarOptions = [\\r\\n            ['bold', 'italic', 'underline', 'strike'],\\r\\n            ['blockquote', 'code-block'],\\r\\n            [{\\r\\n                    header: 1\\r\\n                }, {\\r\\n                    header: 2\\r\\n                }],\\r\\n            [{\\r\\n                    list: 'ordered'\\r\\n                }, {\\r\\n                    list: 'bullet'\\r\\n                }],\\r\\n            [{\\r\\n                    script: 'sub'\\r\\n                }, {\\r\\n                    script: 'super'\\r\\n                }],\\r\\n            [{\\r\\n                    indent: '-1'\\r\\n                }, {\\r\\n                    indent: '+1'\\r\\n                }],\\r\\n            [{\\r\\n                    direction: 'rtl'\\r\\n                }],\\r\\n            [{\\r\\n                    size: ['small', false, 'large', 'huge']\\r\\n                }],\\r\\n            [{\\r\\n                    header: [1, 2, 3, 4, 5, 6, false]\\r\\n                }],\\r\\n            // [{\\r\\n            //   color: []\\r\\n            // }, {\\r\\n            //   background: []\\r\\n            // }], // dropdown with defaults from theme\\r\\n            // [{\\r\\n            //   font: []\\r\\n            // }],\\r\\n            // [{\\r\\n            //   align: []\\r\\n            // }],\\r\\n            ['clean'] // remove formatting button\\r\\n        ];\\r\\n        var options = {\\r\\n            formula: true,\\r\\n            syntax: true,\\r\\n            modules: {\\r\\n                toolbar: toolbarOptions\\r\\n            },\\r\\n            placeholder: '请输入...',\\r\\n            theme: 'snow'\\r\\n        };\\r\\n        var quill = new Quill('#editor', options);\\r\\n    };\\r\\n    BlogEditComponent = __decorate([\\r\\n        core_1.Component({\\r\\n            selector: 'blog-edit',\\r\\n            template: __webpack_require__(1264),\\r\\n            styles: [__webpack_require__(1265)]\\r\\n        })\\r\\n    ], BlogEditComponent);\\r\\n    return BlogEditComponent;\\r\\n}());\\r\\nexports.BlogEditComponent = BlogEditComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYmxvZy1lZGl0L2Jsb2ctZWRpdC5jb21wb25lbnQudHM/MzhmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIE9uSW5pdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIFF1aWxsIGZyb20gJ3F1aWxsJztcblxuaW1wb3J0ICcuLi8uLi8uLi9ub2RlX21vZHVsZXMvcXVpbGwvZGlzdC9xdWlsbC5zbm93LmNzcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Jsb2ctZWRpdCcsXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Jsb2ctZWRpdC5jb21wb25lbnQuaHRtbCcpLFxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL2Jsb2ctZWRpdC5jb21wb25lbnQuc2NzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIEJsb2dFZGl0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgY29uc29sZS53YXJuKCdlZGl0Jyk7XG5cbiAgICB0aGlzLmluaXRFZGl0b3IoKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdEVkaXRvcigpIHtcbiAgICBjb25zdCB0b29sYmFyT3B0aW9ucyA9IFtcbiAgICAgIFsnYm9sZCcsICdpdGFsaWMnLCAndW5kZXJsaW5lJywgJ3N0cmlrZSddLCAvLyB0b2dnbGVkIGJ1dHRvbnNcbiAgICAgIFsnYmxvY2txdW90ZScsICdjb2RlLWJsb2NrJ10sXG5cbiAgICAgIFt7XG4gICAgICAgIGhlYWRlcjogMVxuICAgICAgfSwge1xuICAgICAgICBoZWFkZXI6IDJcbiAgICAgIH1dLCAvLyBjdXN0b20gYnV0dG9uIHZhbHVlc1xuICAgICAgW3tcbiAgICAgICAgbGlzdDogJ29yZGVyZWQnXG4gICAgICB9LCB7XG4gICAgICAgIGxpc3Q6ICdidWxsZXQnXG4gICAgICB9XSxcbiAgICAgIFt7XG4gICAgICAgIHNjcmlwdDogJ3N1YidcbiAgICAgIH0sIHtcbiAgICAgICAgc2NyaXB0OiAnc3VwZXInXG4gICAgICB9XSwgLy8gc3VwZXJzY3JpcHQvc3Vic2NyaXB0XG4gICAgICBbe1xuICAgICAgICBpbmRlbnQ6ICctMSdcbiAgICAgIH0sIHtcbiAgICAgICAgaW5kZW50OiAnKzEnXG4gICAgICB9XSwgLy8gb3V0ZGVudC9pbmRlbnRcbiAgICAgIFt7XG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCdcbiAgICAgIH1dLCAvLyB0ZXh0IGRpcmVjdGlvblxuXG4gICAgICBbe1xuICAgICAgICBzaXplOiBbJ3NtYWxsJywgZmFsc2UsICdsYXJnZScsICdodWdlJ11cbiAgICAgIH1dLCAvLyBjdXN0b20gZHJvcGRvd25cbiAgICAgIFt7XG4gICAgICAgIGhlYWRlcjogWzEsIDIsIDMsIDQsIDUsIDYsIGZhbHNlXVxuICAgICAgfV0sXG5cbiAgICAgIC8vIFt7XG4gICAgICAvLyAgIGNvbG9yOiBbXVxuICAgICAgLy8gfSwge1xuICAgICAgLy8gICBiYWNrZ3JvdW5kOiBbXVxuICAgICAgLy8gfV0sIC8vIGRyb3Bkb3duIHdpdGggZGVmYXVsdHMgZnJvbSB0aGVtZVxuICAgICAgLy8gW3tcbiAgICAgIC8vICAgZm9udDogW11cbiAgICAgIC8vIH1dLFxuICAgICAgLy8gW3tcbiAgICAgIC8vICAgYWxpZ246IFtdXG4gICAgICAvLyB9XSxcblxuICAgICAgWydjbGVhbiddIC8vIHJlbW92ZSBmb3JtYXR0aW5nIGJ1dHRvblxuICAgIF07XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZm9ybXVsYTogdHJ1ZSxcbiAgICAgIHN5bnRheDogdHJ1ZSxcbiAgICAgIG1vZHVsZXM6IHtcbiAgICAgICAgdG9vbGJhcjogdG9vbGJhck9wdGlvbnNcbiAgICAgIH0sXG4gICAgICBwbGFjZWhvbGRlcjogJ+ivt+i+k+WFpS4uLicsXG4gICAgICB0aGVtZTogJ3Nub3cnXG4gICAgfTtcblxuICAgIGNvbnN0IHF1aWxsID0gbmV3IFF1aWxsKCcjZWRpdG9yJywgb3B0aW9ucyk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9ibG9nLWVkaXQvYmxvZy1lZGl0LmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUlBO0FBRUE7QUFRQTtBQUFBO0FBdUVBO0FBckVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBdEVBO0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBdUVBO0FBQUE7QUF2RUE7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1262\\n\")},1263:function(module,exports){eval(\"// removed by extract-text-webpack-plugin//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWlsbC9kaXN0L3F1aWxsLnNub3cuY3NzP2Y2NGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xdWlsbC9kaXN0L3F1aWxsLnNub3cuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMjYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1263\\n\")},1264:function(module,exports){eval('module.exports = \"<section class=\\\\\"container\\\\\" fxFlex fxLayoutAlign=\\\\\"center center\\\\\">\\\\n  <div class=\\\\\"margin-top-20 margin-bottom-20\\\\\" fxFlex=\\\\\"80%\\\\\" fxFlex.lt-sm=\\\\\"100%\\\\\" fxLayout=\\\\\"column\\\\\">\\\\n    <header>\\\\n      <h3>编辑Blog</h3>\\\\n    </header>\\\\n    <div class=\\\\\"cv-editor\\\\\">\\\\n      <div id=\\\\\"toolbar\\\\\">\\\\n        \\\\n      </div>\\\\n      <div id=\\\\\"editor\\\\\"></div>\\\\n    </div>\\\\n  </div>\\\\n</section>\";//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYmxvZy1lZGl0L2Jsb2ctZWRpdC5jb21wb25lbnQuaHRtbD8zMGIxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8c2VjdGlvbiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIiBmeEZsZXggZnhMYXlvdXRBbGlnbj1cXFwiY2VudGVyIGNlbnRlclxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtYXJnaW4tdG9wLTIwIG1hcmdpbi1ib3R0b20tMjBcXFwiIGZ4RmxleD1cXFwiODAlXFxcIiBmeEZsZXgubHQtc209XFxcIjEwMCVcXFwiIGZ4TGF5b3V0PVxcXCJjb2x1bW5cXFwiPlxcbiAgICA8aGVhZGVyPlxcbiAgICAgIDxoMz7nvJbovpFCbG9nPC9oMz5cXG4gICAgPC9oZWFkZXI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImN2LWVkaXRvclxcXCI+XFxuICAgICAgPGRpdiBpZD1cXFwidG9vbGJhclxcXCI+XFxuICAgICAgICBcXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGlkPVxcXCJlZGl0b3JcXFwiPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2Plxcbjwvc2VjdGlvbj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvYmxvZy1lZGl0L2Jsb2ctZWRpdC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTI2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1264\\n')},1265:function(module,exports){eval('module.exports = \".cv-editor {\\\\n  background-color: #fff;\\\\n  color: #222831; }\\\\n  .cv-editor .ql-container {\\\\n    min-height: 28rem; }\\\\n\"//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYmxvZy1lZGl0L2Jsb2ctZWRpdC5jb21wb25lbnQuc2Nzcz85YTVmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIuY3YtZWRpdG9yIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBjb2xvcjogIzIyMjgzMTsgfVxcbiAgLmN2LWVkaXRvciAucWwtY29udGFpbmVyIHtcXG4gICAgbWluLWhlaWdodDogMjhyZW07IH1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9ibG9nLWVkaXQvYmxvZy1lZGl0LmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMjY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1265\\n')},1266:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\n// 引入基本样式文件\\r\\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n};\\r\\nvar __metadata = (this && this.__metadata) || function (k, v) {\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar core_1 = __webpack_require__(4);\\r\\nvar router_1 = __webpack_require__(173);\\r\\nvar moment = __webpack_require__(1);\\r\\n__webpack_require__(301);\\r\\n__webpack_require__(1267);\\r\\nvar AppComponent = (function () {\\r\\n    function AppComponent(route, router) {\\r\\n        this.route = route;\\r\\n        this.router = router;\\r\\n    }\\r\\n    AppComponent.prototype.ngOnInit = function () {\\r\\n        // this.goToLogin();\\r\\n        this.currentTime = moment().format(\\'ddd MMM Do YYYY\\');\\r\\n    };\\r\\n    AppComponent.prototype.goToLogin = function () {\\r\\n        var a = this.route.params;\\r\\n        this.router.navigate([\\'/login\\']);\\r\\n    };\\r\\n    AppComponent = __decorate([\\r\\n        core_1.Component({\\r\\n            selector: \\'cv-app\\',\\r\\n            template: __webpack_require__(1268),\\r\\n            styles: [__webpack_require__(1269)]\\r\\n        }),\\r\\n        __metadata(\"design:paramtypes\", [router_1.ActivatedRoute,\\r\\n            router_1.Router])\\r\\n    ], AppComponent);\\r\\n    return AppComponent;\\r\\n}());\\r\\nexports.AppComponent = AppComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLmNvbXBvbmVudC50cz8yOTgzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIOW8leWFpeWfuuacrOagt+W8j+aWh+S7tlxuXG5pbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyLCBBY3RpdmF0ZWRSb3V0ZSwgUGFyYW1zIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2hNYXAnO1xuaW1wb3J0ICcuLi9hc3NldHMvc2Nzcy9jb21tb24uc2Nzcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2N2LWFwcCcsXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL2FwcC5jb21wb25lbnQuaHRtbCcpLFxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL2FwcC5jb21wb25lbnQuc2NzcycpXVxufSlcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICBwdWJsaWMgY3VycmVudFRpbWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSxcbiAgICBwcml2YXRlIHJvdXRlcjogUm91dGVyXG4gICkgeyB9XG5cbiAgcHVibGljIG5nT25Jbml0KCkge1xuICAgIC8vIHRoaXMuZ29Ub0xvZ2luKCk7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IG1vbWVudCgpLmZvcm1hdCgnZGRkIE1NTSBEbyBZWVlZJyk7XG4gIH1cblxuICBwcml2YXRlIGdvVG9Mb2dpbigpIHtcbiAgICBjb25zdCBhID0gdGhpcy5yb3V0ZS5wYXJhbXM7XG4gICAgdGhpcy5yb3V0ZXIubmF2aWdhdGUoWycvbG9naW4nXSk7XG4gIH1cblxuIH1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXI/P3JlZi0tMC0wIS4vc3JjL2FwcC9hcHAuY29tcG9uZW50LnRzIl0sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFMQTtBQWtCQTtBQUFBO0FBbEJBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1266\\n')},1267:function(module,exports){eval(\"// removed by extract-text-webpack-plugin//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hc3NldHMvc2Nzcy9jb21tb24uc2Nzcz82MzU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXNzZXRzL3Njc3MvY29tbW9uLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDEyNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1267\\n\")},1268:function(module,exports){eval('module.exports = \"\\x3c!--公共顶部--\\x3e\\\\n<header class=\\\\\"cv-header\\\\\">\\\\n  <nav>\\\\n    <a routerLink=\\\\\"/\\\\\" routerLinkActive=\\\\\"active\\\\\" class=\\\\\"text-shadow-dark-2\\\\\" md-button>Home</a>\\\\n    <a routerLink=\\\\\"/bloglist\\\\\" routerLinkActive=\\\\\"active\\\\\" class=\\\\\"text-shadow-dark-2\\\\\" md-button>Blog</a>\\\\n    <a routerLink=\\\\\"/datav\\\\\" routerLinkActive=\\\\\"active\\\\\" class=\\\\\"text-shadow-dark-2\\\\\" md-button>DataV</a>\\\\n    <a href=\\\\\"\\\\\" class=\\\\\"text-shadow-dark-2\\\\\" md-button>About</a>\\\\n\\\\n    <a class=\\\\\"pull-right text-shadow-dark-2\\\\\" md-button [mdMenuTriggerFor]=\\\\\"theme\\\\\">Theme</a>\\\\n    <md-menu #theme=\\\\\"mdMenu\\\\\">\\\\n      <button md-menu-item>\\\\n        <md-icon class=\\\\\"text-dark\\\\\">dashboard</md-icon>\\\\n        <span>Material Dark</span>\\\\n       </button>\\\\n      <button md-menu-item>\\\\n         <md-icon class=\\\\\"text-orange\\\\\">dashboard</md-icon>\\\\n         <span>Brief Coffee</span>\\\\n       </button>\\\\n      <button md-menu-item>\\\\n        <md-icon class=\\\\\"text-blue\\\\\">dashboard</md-icon>\\\\n        <span>Blue Ocean</span>\\\\n      </button>\\\\n    </md-menu>\\\\n\\\\n    <a routerLink=\\\\\"/login\\\\\" routerLinkActive=\\\\\"active\\\\\" class=\\\\\"pull-right text-shadow-dark-2\\\\\" md-button>Login</a>\\\\n\\\\n    \\x3c!--<button class=\\\\\"pull-right text-shadow-dark-2\\\\\"  md-button [mdMenuTriggerFor]=\\\\\"account\\\\\">TaylorPzreal</button>\\\\n    <md-menu #account=\\\\\"mdMenu\\\\\">\\\\n      <button md-menu-item>\\\\n        <md-icon>account_box</md-icon>\\\\n        <span>My Profile</span>\\\\n       </button>\\\\n      <button md-menu-item>\\\\n         <md-icon>message</md-icon>\\\\n         <span>My Message</span>\\\\n       </button>\\\\n      <button md-menu-item>\\\\n        <md-icon>power_settings_new</md-icon>\\\\n        <span>Log Out</span>\\\\n      </button>\\\\n    </md-menu>--\\x3e\\\\n\\\\n    <span class=\\\\\"pull-right text-orange cv-label\\\\\">{{currentTime}}</span>\\\\n  </nav>\\\\n</header>\\\\n\\\\n\\x3c!--路由--\\x3e\\\\n<section class=\\\\\"cv-content\\\\\">\\\\n  \\x3c!--<main>\\\\n    <h1>Curriculum Vitae Show</h1>\\\\n  </main>--\\x3e\\\\n\\\\n  \\x3c!--根路由--\\x3e\\\\n  <router-outlet></router-outlet> \\\\n</section>\\\\n\\\\n\\x3c!--公共底部--\\x3e\\\\n<footer class=\\\\\"cv-footer\\\\\">\\\\n  <p>@2017 www.honeymorning.com On My Way.</p>\\\\n</footer>\";//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLmNvbXBvbmVudC5odG1sPzM0OGIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjwhLS3lhazlhbHpobbpg6gtLT5cXG48aGVhZGVyIGNsYXNzPVxcXCJjdi1oZWFkZXJcXFwiPlxcbiAgPG5hdj5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL1xcXCIgcm91dGVyTGlua0FjdGl2ZT1cXFwiYWN0aXZlXFxcIiBjbGFzcz1cXFwidGV4dC1zaGFkb3ctZGFyay0yXFxcIiBtZC1idXR0b24+SG9tZTwvYT5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL2Jsb2dsaXN0XFxcIiByb3V0ZXJMaW5rQWN0aXZlPVxcXCJhY3RpdmVcXFwiIGNsYXNzPVxcXCJ0ZXh0LXNoYWRvdy1kYXJrLTJcXFwiIG1kLWJ1dHRvbj5CbG9nPC9hPlxcbiAgICA8YSByb3V0ZXJMaW5rPVxcXCIvZGF0YXZcXFwiIHJvdXRlckxpbmtBY3RpdmU9XFxcImFjdGl2ZVxcXCIgY2xhc3M9XFxcInRleHQtc2hhZG93LWRhcmstMlxcXCIgbWQtYnV0dG9uPkRhdGFWPC9hPlxcbiAgICA8YSBocmVmPVxcXCJcXFwiIGNsYXNzPVxcXCJ0ZXh0LXNoYWRvdy1kYXJrLTJcXFwiIG1kLWJ1dHRvbj5BYm91dDwvYT5cXG5cXG4gICAgPGEgY2xhc3M9XFxcInB1bGwtcmlnaHQgdGV4dC1zaGFkb3ctZGFyay0yXFxcIiBtZC1idXR0b24gW21kTWVudVRyaWdnZXJGb3JdPVxcXCJ0aGVtZVxcXCI+VGhlbWU8L2E+XFxuICAgIDxtZC1tZW51ICN0aGVtZT1cXFwibWRNZW51XFxcIj5cXG4gICAgICA8YnV0dG9uIG1kLW1lbnUtaXRlbT5cXG4gICAgICAgIDxtZC1pY29uIGNsYXNzPVxcXCJ0ZXh0LWRhcmtcXFwiPmRhc2hib2FyZDwvbWQtaWNvbj5cXG4gICAgICAgIDxzcGFuPk1hdGVyaWFsIERhcms8L3NwYW4+XFxuICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gbWQtbWVudS1pdGVtPlxcbiAgICAgICAgIDxtZC1pY29uIGNsYXNzPVxcXCJ0ZXh0LW9yYW5nZVxcXCI+ZGFzaGJvYXJkPC9tZC1pY29uPlxcbiAgICAgICAgIDxzcGFuPkJyaWVmIENvZmZlZTwvc3Bhbj5cXG4gICAgICAgPC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBtZC1tZW51LWl0ZW0+XFxuICAgICAgICA8bWQtaWNvbiBjbGFzcz1cXFwidGV4dC1ibHVlXFxcIj5kYXNoYm9hcmQ8L21kLWljb24+XFxuICAgICAgICA8c3Bhbj5CbHVlIE9jZWFuPC9zcGFuPlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICA8L21kLW1lbnU+XFxuXFxuICAgIDxhIHJvdXRlckxpbms9XFxcIi9sb2dpblxcXCIgcm91dGVyTGlua0FjdGl2ZT1cXFwiYWN0aXZlXFxcIiBjbGFzcz1cXFwicHVsbC1yaWdodCB0ZXh0LXNoYWRvdy1kYXJrLTJcXFwiIG1kLWJ1dHRvbj5Mb2dpbjwvYT5cXG5cXG4gICAgPCEtLTxidXR0b24gY2xhc3M9XFxcInB1bGwtcmlnaHQgdGV4dC1zaGFkb3ctZGFyay0yXFxcIiAgbWQtYnV0dG9uIFttZE1lbnVUcmlnZ2VyRm9yXT1cXFwiYWNjb3VudFxcXCI+VGF5bG9yUHpyZWFsPC9idXR0b24+XFxuICAgIDxtZC1tZW51ICNhY2NvdW50PVxcXCJtZE1lbnVcXFwiPlxcbiAgICAgIDxidXR0b24gbWQtbWVudS1pdGVtPlxcbiAgICAgICAgPG1kLWljb24+YWNjb3VudF9ib3g8L21kLWljb24+XFxuICAgICAgICA8c3Bhbj5NeSBQcm9maWxlPC9zcGFuPlxcbiAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIG1kLW1lbnUtaXRlbT5cXG4gICAgICAgICA8bWQtaWNvbj5tZXNzYWdlPC9tZC1pY29uPlxcbiAgICAgICAgIDxzcGFuPk15IE1lc3NhZ2U8L3NwYW4+XFxuICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gbWQtbWVudS1pdGVtPlxcbiAgICAgICAgPG1kLWljb24+cG93ZXJfc2V0dGluZ3NfbmV3PC9tZC1pY29uPlxcbiAgICAgICAgPHNwYW4+TG9nIE91dDwvc3Bhbj5cXG4gICAgICA8L2J1dHRvbj5cXG4gICAgPC9tZC1tZW51Pi0tPlxcblxcbiAgICA8c3BhbiBjbGFzcz1cXFwicHVsbC1yaWdodCB0ZXh0LW9yYW5nZSBjdi1sYWJlbFxcXCI+e3tjdXJyZW50VGltZX19PC9zcGFuPlxcbiAgPC9uYXY+XFxuPC9oZWFkZXI+XFxuXFxuPCEtLei3r+eUsS0tPlxcbjxzZWN0aW9uIGNsYXNzPVxcXCJjdi1jb250ZW50XFxcIj5cXG4gIDwhLS08bWFpbj5cXG4gICAgPGgxPkN1cnJpY3VsdW0gVml0YWUgU2hvdzwvaDE+XFxuICA8L21haW4+LS0+XFxuXFxuICA8IS0t5qC56Lev55SxLS0+XFxuICA8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+IFxcbjwvc2VjdGlvbj5cXG5cXG48IS0t5YWs5YWx5bqV6YOoLS0+XFxuPGZvb3RlciBjbGFzcz1cXFwiY3YtZm9vdGVyXFxcIj5cXG4gIDxwPkAyMDE3IHd3dy5ob25leW1vcm5pbmcuY29tIE9uIE15IFdheS48L3A+XFxuPC9mb290ZXI+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2FwcC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTI2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1268\\n')},1269:function(module,exports){eval(\"module.exports = \\\".cv-content {\\\\n  flex: 1; }\\\\n\\\\nmain {\\\\n  display: block;\\\\n  flex: 1;\\\\n  font-family: Arial, Helvetica, sans-serif;\\\\n  margin-top: 50px;\\\\n  padding: 1em;\\\\n  text-align: center; }\\\\n\\\\nh1 {\\\\n  font-family: 'Tangerine', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\\\\n  font-size: 4.8rem; }\\\\n\\\"//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLmNvbXBvbmVudC5zY3NzP2NjMzgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi5jdi1jb250ZW50IHtcXG4gIGZsZXg6IDE7IH1cXG5cXG5tYWluIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxleDogMTtcXG4gIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcbiAgbWFyZ2luLXRvcDogNTBweDtcXG4gIHBhZGRpbmc6IDFlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcblxcbmgxIHtcXG4gIGZvbnQtZmFtaWx5OiAnVGFuZ2VyaW5lJywgJ1NlZ29lIFVJJywgVGFob21hLCBHZW5ldmEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7XFxuICBmb250LXNpemU6IDQuOHJlbTsgfVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2FwcC5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTI2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1269\\n\")},477:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar login_component_1 = __webpack_require__(1247);\\r\\nexports.LoginComponent = login_component_1.LoginComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9sb2dpbi9pbmRleC50cz8wODNkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IExvZ2luQ29tcG9uZW50IH0gZnJvbSAnLi9sb2dpbi5jb21wb25lbnQnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvdHNsaW50LWxvYWRlcj8/cmVmLS0wLTAhLi9zcmMvYXBwL2xvZ2luL2luZGV4LnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///477\\n')},478:function(module,exports,__webpack_require__){\"use strict\"\n;eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar home_component_1 = __webpack_require__(1250);\\r\\nexports.HomeComponent = home_component_1.HomeComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2luZGV4LnRzPzZmNzYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgSG9tZUNvbXBvbmVudCB9IGZyb20gJy4vaG9tZS5jb21wb25lbnQnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvdHNsaW50LWxvYWRlcj8/cmVmLS0wLTAhLi9zcmMvYXBwL2hvbWUvaW5kZXgudHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///478\\n')},479:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar datav_component_1 = __webpack_require__(1254);\\r\\nexports.DatavComponent = datav_component_1.DatavComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9kYXRhdi9pbmRleC50cz84ODRhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IERhdGF2Q29tcG9uZW50IH0gZnJvbSAnLi9kYXRhdi5jb21wb25lbnQnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvdHNsaW50LWxvYWRlcj8/cmVmLS0wLTAhLi9zcmMvYXBwL2RhdGF2L2luZGV4LnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///479\\n')},480:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar blog_list_component_1 = __webpack_require__(1257);\\r\\nexports.BlogListComponent = blog_list_component_1.BlogListComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ibG9nLWxpc3QvaW5kZXgudHM/MDBiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBCbG9nTGlzdENvbXBvbmVudCB9IGZyb20gJy4vYmxvZy1saXN0LmNvbXBvbmVudCc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyPz9yZWYtLTAtMCEuL3NyYy9hcHAvYmxvZy1saXN0L2luZGV4LnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///480\\n')},481:function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nvar blog_edit_component_1 = __webpack_require__(1262);\\r\\nexports.BlogEditComponent = blog_edit_component_1.BlogEditComponent;\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ibG9nLWVkaXQvaW5kZXgudHM/NjdkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBCbG9nRWRpdENvbXBvbmVudCB9IGZyb20gJy4vYmxvZy1lZGl0LmNvbXBvbmVudCc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyPz9yZWYtLTAtMCEuL3NyYy9hcHAvYmxvZy1lZGl0L2luZGV4LnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///481\\n')}},[1241]);","map":"{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"}"}